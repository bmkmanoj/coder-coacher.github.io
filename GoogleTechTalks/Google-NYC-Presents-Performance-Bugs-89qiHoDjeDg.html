<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Google NYC Presents: Performance Bugs | Coder Coacher - Coaching Coders</title><meta content="Google NYC Presents: Performance Bugs - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Google NYC Presents: Performance Bugs</b></h2><h5 class="post__date">2011-08-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/89qiHoDjeDg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">questions after the talk what a silly
notion I'm going to be asking you
questions all throughout the talk it
would be grossly impaired if you could
not ask me questions as well so if you
have any questions - don't bother
queuing them just put up your hand I'm
going to talk about performance bugs
programs that are absolutely correct and
doing just what they're supposed to do
but they cost too much to do it I'll
start off with two little stories give
me some perspectives and tales some
lessons I was pretty confused over the
background of the people that might be
here if you have written the computer
program ever in your life please raise
your hand
thank you if you didn't raise your hand
just then now raise your hand now okay
that's great if you're a computer
programmer I'm showing you some code
think of code as code I know there is at
least one person in here who's not a
full time computer programmer but she
soon will be I trust my full time
daughter-in-law and so if you're not so
much of a programmer think of code as
blah blah blah it's a little inside joke
that we programmers have and you'll get
most of the story but if you're notif
your programmer you'll get a little bit
more who here feels comfortable with the
term quadratic growth close enough I'll
work around it good so I wouldn't even
talk if I double the diameter of a
circle how much bigger will be area get
for cool we're cool
buying in bulk this is a little bit more
background somebody cannot at some point
oh one if you're buy gasoline doesn't
matter if you have a moped or I fill up
the ambulance I Drive the other day with
about 30 gallons of fuel fuel this
morning was about 371 ago two weeks ago
was that
that's unit cost sometimes though
there's economy of scale by 12 to get
one free that's a baker's dozen
fast-food they essentially penalize you
for not getting super Mongo drinks I've
seen places that sell but it's a small
medium and large actually it's a medium
origin XL Orson XL XXL and the gutbuster
with it whatever it is where is the
incremental cost getting bigger isn't
that much on the other hand sometimes
there are diseconomies of scale so we
went across the street over to the
lobster restaurant and I was shocked
that the price of lobster did not follow
this thing that I went to a website
recently that more the bigger the
lobster is the more it costs per pound
so if you buy a 1 pound lobster cost 9
bucks you buy two of them as 18 bucks
mm laughter 18 bucks but if you buy a
two the 3 pound mobster down here a 2
pounder there will cost you 25 bucks
sometimes there's a diseconomy of scale
the more you buy the more it costs what
a pain that is anyone think of any other
examples of diseconomies of scale part
of me computer power and getting that
last little bit cost a whole lot more
other examples oh yes III cleverly
stopped at one which is way beyond the
optimal number billing both cells I'm
stupid signs which go for $1 apiece or
two for $5 if I in my spare time I'm a
search and rescue technician if a person
if you get a team out after two hours
and the search radius if a team of 40
people can search if you wait to four
hours how big will your team have to be
to search it won't be twice as much than
twice a time it'll be four times as much
there's some diseconomy of scale we'll
get to that
that's background as they say here is a
great bug report we just happened to be
a lot of books and Rick Becker found
that cue sword it was code 5s
maintaining is unbearably slow now that
by itself isn't isn't that great a bug
report but this makes it a pretty good
bug report on inputs on pipe organ
inputs like zero
two three four six eight nine nine eight
seven six five four three two one zero
that's interesting that's really useful
that's a pretty good bug report this is
a great bug report here's a teeny-weeny
little eight line program that tickles
the bug for you Wow and not only that
here are the timings if I run it with a
certain value for the number of things
to sort a 2,000 it takes that long
intuitively if I run it this work twice
as many elements you would think it
would take about twice as much time but
they did the experiment and here if you
double the number of elements instead of
taking ballpark twelve seconds it takes
ballpark how many times as long they do
it again 21 to 85 that takes four times
as long this is a great bug report here
the problem is this code that you're
responsible for takes too long here's
the generic family of inputs and here's
the pattern they could have just given
me one pair of elements they gave me
three every time we double the input
size the run time goes up by a factor of
four you would like to think that with
the economy of scale it might get a
little bit less than doubling if you
know a bit about the theory of soaring
and see what's gonna be just a little
bit more than doubling but in fact it
goes up by a factor of four there's
something seriously wrong a great bug
report this simple double experiment
establishes that a source that should
have that magic number of run time is in
fact quadratic bummer in fact here's way
it happened behind this there was a
person using the s software system and
they thought that essence broken they
said it just stopped running I was
writing my program I gave it a command
instead of coming back it just set there
broke it didn't do anything else in fact
folks and Becker discovered that it
would have finished in about a week the
maintainer x' headed down the real issue
they found the piece that was broken and
they found the organ
Piper shoe that was and then they wrote
this great bug report I'll return to the
point where I came on where the next
step was to build a new one that fixed
that issue so I'll get back to that in a
few minutes but that's my first tail
above report a program that took way too
long
any questions before I move on here's
another bug for that
actually before I get that it's a
delicate discussion Henry Petroski in
his wonderful book that you voted a
quarter century ago called to engineer
as human talks about quote the role of
failure and successful design and he
says in this book that the lessons we
learn from disasters can do more to
advance engineering knowledge than all
the successes you can imagine that we as
engineers have to talk not only about
our successes we have to talk about our
failures and in fact our disasters are
the most interesting and educational
kinds of failures I have now have been
paid to be a computer programmer for
longer than the majority of you have
been breathing I've worked at some of
the best places in the galaxy Xerox PARC
the Stanford Linear Accelerator Center a
lot of really fine places and real
software has bugs
Joseph Campbell described mythology by
speaking of the Hebrew with a thousand
faces I'm going to speak to you today of
the bug with a thousand faces I'm going
to take them from particular examples
but if you work on big software systems
you see them everyone makes mistakes
excellent organizations learn from them
and I've been privileged to work at a
number of organizations that allow me to
talk about this when the fault is mine
I'll take it otherwise it's not really
important who made these bugs it's
pretty interesting to see them both if
you're a programmer at some point in
your life you've probably written code
along these lines count is equal to zero
and then somewhere much laters iterated
increment count plus plus count if
that's bigger than a hundred do
something expensive one time out of a
hundred I want to do this than the a
reset count to zero there are three
lines of code there
there are possibilities to make mistakes
in each one of those three lines
what mistakes could you make what impact
would that have let's try it what
happens if I forget to initialize that
count to zero is that some big deal it
depends on the language if count happens
to be initialized implicitly to zero I'm
golden
what if count happens to be some garbage
value that was there is that some big
deal well if it happened to be a hundred
and thirty-eight the first time I'm
golden - the first time I'll do that one
extra time I'll do it when it's your
time that I'm fine if count what's the
only real bummer though that could
happen here if family happens to be a
really small negative number instead of
Julian over a hundred times I could
either have little change or I can never
do it like you'll never get to it yikes
leave out one line of code something
where do they happen one percent of the
time doesn't happen ever what happens if
you miss the increment you'll never do
it they'll never do that this thing that
you wanted to do one percent of the time
what happens if you miss the result
instead of doing it in over a hundred
times I'll do it all but a hundred times
everyone see the idea computer programs
are fragile if you lean out a little bit
here or there
it can have a huge impact and here's a
story that happened a couple of years
ago I was on a team doing some
performance issues whatever members
email something said hey search for this
variable and you'll find through
references I initialize it to zero I
declare it and I have that one test
what's missing you never reset it he
points out it's initialized is
incremented but it's never reset after
the to hundreds page fault what it
really was
the test is always true this means that
every time we need a new buffer we
always flush the queue this is in the
middle of about 10 million lines of code
this is on a medium-size
ten million lines of code one line was
left out does that have any impact on
the overall system what kind of impact
could that have in fact this little
example says that instead of doing
something every children's times they'll
do it all but 200 times they'll do it
200 times more often than you do if
there's a really expensive operation
that doubled or cripple the number of
page folds it increased the CPU time by
about 50 percent among 10 million lines
of code forgetting this one line of code
took us from 40 percent occupancy to 60
percent occiput City one line of code
has a huge impact on that what we do is
this pretty interesting questions about
this this is a story I'll get back to it
so a performance bug and I've shown you
two now is a minor glitch there are also
a major design flaws things where you
should have thought oh Jesus it just
can't work I have not a lot of those two
but I don't want to talk about
fundamental design errors I want to talk
about tiny little performance bugs it's
a minor glitch it's an atypical input
it's one missing line it's a boo-boo
it's not a big thing it's a little it's
a think oh that doesn't alter the
correctness of the program these
programs would pass all the correctness
tests it's not revealed by testing but
does cause the program to consume
excessive resources the resources might
be CPU time 2h volts whatever but again
this is what I mean by performance bugs
so I've taken a little time I described
what I mean any questions at all let's
go what effect do they have they can be
accretive where you have death by a
thousand paper cups one the other is
catastrophic I hit enter it has never
came back how are they discovered
sometimes they're found in the field
when they after they weere their ugly
heads other times just by sitting back
in perusing code what causes them
unforeseen cases little typing boo-boos
at one line how do you conclusively nail
them down
tiny well-structured experiments just
run that two or three times show that
the times that should double it backward
rubles or just a thought analysis so
these two bugs I chose to be pretty far
apart into space just to give you a
feeling any questions at all okay I
didn't now survey a bunch of problems
I'm gonna start with sorting question I
don't care about sorting well really you
should be more graceful the way you
phrase your questions I was not even a
question but you know about it and it
illustrates the deep truth and much more
importantly I've and daddy might head
against this problem for several decades
and I can speak from sometimes bitter
experience this is sort of the one that
I know about this is home for me
so sucks to be you I'll talk about
system issues about caching or
allocation I'll talk about is to
sampling or some big systems of telling
stories from big systems here so there I
was minding my own beeswax Becker will
send me this bug report doesn't work
it's broken what do I do
I tried some other key sorts I tried a
dozen of these sport functions they were
traced to three original programs each
of the three hundred different ones if I
distilled an array with random zeros and
ones said sort it
it took quadratic time is that a case
that people really do probably not often
but isn't one that could be done by a
reasonable person yeah a lot of similar
bugs
yikes my colleague Doug McIlroy and I
had to build a new program we started
simple we built one it was in log n in
all of our tests you know what that
means fine is not don't worry about it
it it ran in that time we were really
happy with it we really stood some users
our first user said no your program is
completely unacceptable it's way too
slow yikes
we didn't expect it how else Lou is it
it's a way slow its n log n huh
it takes a Mogan to annoy input well if
it were sporting event login record its
optimal so no no no its predecessor took
linear time because I was asking it to
sort something that was predominantly
equal and the reason you sort often is
to bring together equal elements it's a
perfectly valid thing and the previous
program was really fast on that case
yeah but we dungeon our specification
doesn't matter the user had a
performance curio that implicitly by the
mere existence of the preceding program
we had to be as fast as it was so this
program that we felt was his fine was
optimal was bad for a user so at that
point we had to implement a program
should we implement quicksort or heap
sort people in the business who know
this do you have any idea which one is
faster quicksort or heap sort part of me
they're both asymptotically n log n but
in terms of real speed any idea which of
the two might be faster quicksort by
about how much there are two things one
that I learned when I had a class from
Don Knuth in 1973 unsorted in 13 is that
it's about 30% faster so I'm gonna go
for that one and in fact it is about 30%
faster here's some data except thanks if
n is somewhere between here and around
8,000 is about 30% faster here the
different breads and up here it goes
really crazy so the answer that I
learned a long time ago is true up to
what's going on here
where are the cash is what caches can
you see in that picture
yeah there's l1 cache goes at about
8,000 we're sorting elements here
they're a size 4,000 this happens to be
a 32k l1 cache and what else can you see
there the l2 cache is about two half a
mega so here sometimes you can get
performance bugs if I did all my
experiments in this domain versus that
domain and then ran it for data in a
different domain
yikes so here someone need to hardware
designers or magicians they give us
memory that's really cheap but it
appears to be tasked as these caching
but we have to be respectful of it that
sometimes their performance issues
will this be reflected in any
correctness test not at all that is
completely hidden they work correctly
but these performance issues come up
experiments in one range don't
necessarily line there's one bump the
top one is sort of three straight lines
because of the cache an issue that you
mentioned and these sensitivities can
have a big impact as you're designing
systems so caching has a huge influence
we're a bit I want to make sure we don't
need to rush it all I'm going to go
through a different Q sort bug yeah
let's go through that one here's a big
system I was consulting on the big
system and we had a bunch of the essence
of this system was we ran a bunch of
pages we were printing past us and I
made a page profiler a prototype page
profiler and the literate a for pers my
page profiler that's a lot of fun to say
and I encourage you to say it yourselves
and what we did was just count among 10
million page hits what are the addresses
health and does it happen
what's the page dress and what's the
instruction that rests to cause the page
fault when we did that among 10 million
hits we were surprised to find that the
number one
occurred a lot more than number two one
might think that the dispute would be a
distribution not so the number one thing
was hit three quarters of million time
the number two thing was occurred two
hundred thousand times what's going on
there
it bears investigating about seven and a
half percent of the faults come from
about one inspection second third and
fourth place are only about two percent
time to check that instruction we
dispatched a programmer to do it and we
did it here's what we found
the code looks like this do not deliver
the following lines enabled this is in a
body of about ten million lines of code
and there are a lot of cons like 10
million non-comment source lines of code
there are a lot of comments to probably
30 million lines of code with comments
do not deliver the following lines
enabled these are only used for
automated unit testing this program was
first built in the late 1970s it's been
around for 30 years accreting crud there
was an MRE filed about disabling us just
disable that as the comet indicates it's
only for automated unit testing should
not be enabled additionally it causes
code to be executed unnecessarily I know
this so I did this had a horrible impact
on shadowed memory at that point the
result was because of that one excess
line of code the entire system was about
seven and a half percent slower than it
needed to have been one line of code who
here works or has ever worked on
software that contains a million or more
lines of code who here that is working
those big programs is absolutely sure in
those million line programs that it
contains nothing at all like this you're
morally certain to contain C
and who here if you've worked on big
blood systems think that your system to
prop it contains little boo-boos like
that one or the other one oh I'm trying
to do here is raise awareness that this
this is the enemy
we have many enemies as as system
designers we have to think about the
overall design of the system have to
think about the algorithms but this
little nickel-and-dime sloppy stuff that
has no intellectual merit whatsoever
comes back to bite us in the butt
another alliteration but absolutely true
as well this is where a lot of the
battle is won in losses
a bit more perspective what causes
performance bugs I've shown you two tiny
goofs just not even think those typos
just me the combat in one line missing
one problem with stack space that I
glossed over a different nature of input
Tom that had duplicate input but his
expectations were be fast there was an
implicit contractor you can't make the
system slower underlying system behavior
all these things are the kinds of things
that you have to think about to avoid
these dreadful performance bugs how do
you fix performance bugs how do you find
them how do you fix them this is an
intermediate tau stood the number one
thing is awareness I'm a volunteer EMT
in New Jersey I came to take in lots of
classes all the classes are vehicle
extrication awareness then technician
and all these things above it this is
just an awareness level freedom these
things exist think about it think about
how you can do it performance testing
just to see where they were like that
page profiler is a great thing and
finally I've shown you these little
definitive experiments that show that
yes this is indeed where the problem is
questions at all don't hold until the
end just boredom out now I've known a
number of individuals that you exactly
this that whenever you do a unit test do
two things one is major the actual wall
clock time and things will change on the
wall clock time but if you ever go from
requiring a minute in seven seconds to a
minute them to 10 seconds it's not a big
deal I don't know a minute in seven
seconds to four minutes yeah look at it
very carefully
exactly but do that is in every chance
do you write automated and have and then
do a essentially a diff of the output
and a diff of the times and see if the
times are significantly different by
some measurement so I've done that in
software where I have a big each system
where I test it and in the test just
compare both the things that you're
really looking for and compare the times
make sure the times are close enough and
automate that so whenever you push a big
button to crank it out just do all those
tests again a lot of made all about and
check the times carefully
and all of those things monitor all the
resources very carefully that just like
when you go into a hospital they slapped
an e an EKG on you just to monitor
things that they take your pulse
you can monitor a big system from the
outside by looking at these key there it
was look at those key ones and look at
every other one in our business we have
no excuse not to monitor every single
number that is available make more
available thank you
memory allocation bugs who here has ever
been bit by a memory allocation bug cool
usually you ran out of memory weird
things happen that goes out way too
early I had one where my program was
surprisingly and painfully slow as soon
as I profiled it I noticed that the lion
shares the time goes to allocation yikes
I then beat on it for about a day I got
the program from being a few thousand
lines of code down to being about that
long I got it down to there just just
tune out some things and see what
happens
I did that ransom Taos time at double it
time at double instead of went up by
this is the same old story I focused on
things that you think should be linear
that go to quadratic that do this
yikes I did this I found this in the
early 1990s I run over to my friend Doug
McIlroy and I say Doug look at this
those morons at Sutton's of the
corporation they think they can shipping
uniques look at this sloppy design bare
Malek hahahahaha takes quadratic time
dr. sponsz was that's my code
this guy is a great computer programmer
how could he write this code well he was
an excellent designer who designed code
in his world his world was that he had
made the code 15 years earlier 15 years
earlier
the machine has 64,000 works of memory
his code runs and times C 1 n plus C 2
and squared C 2 was tiny it's negligible
as an engineer we ignore these to make
the cool things all the time so he tuned
it so the dominant room was always small
15 years later if moore's law says that
you double every one and a half years 15
years 1.5 times 10 that's 2 to the 10th
is about a thousand 15 years is going to
be a thousand times bigger the machine
after 15 years had a thousand times as
much memory not surprisingly what
happened his design his design that was
perfectly reasonable in the context all
of a sudden was something that some kid
was trying to laugh out how will the
code that you write today look in
fifteen or thirty years
how will look after a factor of a
thousand or after a factor of a million
men do most engineers have to worry
about a factor of a thousand you know
when the fellas over there a Boeing
designed their design and they built an
airplane is someone in the next 15 years
increase that airplanes length by a
factor of a thousand that would be
really embarrassing I am a complete
addict of the teaching companies
wonderful courses I do a lot of the
courses that I listen to
on CDs but I just finished listening to
Steve Rustler who's a professor at West
Point give a wonderful course on the
great structures just came out from the
teaching company among other things he
talks about the bear mountain bridge who
here has ever seen or been over the
river Mountain Bridge Great Bridge if
span main span is about sixteen hundred
and thirty-two feet I had no idea but at
one point in 1924 1926 it was
longest suspension bridge in the world a
beautiful structure but what's harder
hardware/software I can know if you ask
for a do-over and most of what we do it
has press some buttons and can start
over again from scratch a do-over it is
pretty easy in the software world if you
get a bridge design where you made a
little mistake and all the steel gets
wet a do-over is really pricey so in a
certain sense software is easier than
hardware but on the other hand what
happens if you scale that bridge design
by a factor of a thousand that happened
to poor leg naka Roy's code somebody
scaled it by a factor of a thousand if
you take that bridge design and shrink
it down but I want to throw a span
across about a 11.6 foot long
chasm do you believe the tiny powers of
little wires no just doesn't work that
way you got on a gurney and throw it
across if you're gonna take that same
design and make it instead of one point
six thousand feet you make it one point
six million feet and you just scale that
design or proportionally can you scale
that design by a factor of two that you
can all store completely designed to go
from there to the George Washington
Bridge it's it's the same idea but a
factor of two is a big deal so here we
have to watch about that considering
bridges to that if you left in one test
Griffin that ribbit would end up
weighing as much as seven and a half
percent of the rest of the bridge put
together you pick any place in that
design you put in one rivet the waste
and a half percent of the whole weight
of the design the bridge gets all wet
it's not even closed if they had that it
would be difficult likewise I show you a
people leaving out one line of code make
something 200 times more pricey if you
left out one strand of wire in the main
cable and that increased the main cable
weight by a factor of 200
what happened so that the important
thing here is that just like when Paul
Revere rode along weren't firing his gun
and ringing his Bell and warning the
British that they would not take our
guns I am here my friends to tell you
that we should approach the construction
of software with a little more humility
than we do this stuff really is hard you
know that we go we got mold by the fact
that it's so easy to do it do-over we
don't realize that things can be this
precarious any questions at all about
this a notification system at some
nameless telecommunication company we
wanted to build a system that would mix
and match ways of getting information to
people I want to send out a full message
staff that doesn't work early to
voicemail I'll send you text I'll send
you email again your beeper all these
things I've seen you and I am all these
ways and I work with the testers and
they said okay that the essence here is
this as mixing and matching a lot of
things we want to look at this and make
sure that all these guys would play well
together does each one of these various
things play well and interact all of
their test scripts were designed to
really test feature interaction an
important thing that gets what a lot of
bugs
what's one other kind of tests that
could tell you if you had certain
performance bugs how would you what what
is another kind of testing you want to
run here expressly to find performance
bugs a load test and what kind of load
test and I asked for each dimension this
do it for phone alone do it for a
voicemail alone do it for text alone
all the above and then mix-and-match
meters for each one by itself don't mix
and match to see for that dimension
alone what happens zoomed right through
development after about five months of
Damien rusting and pleading about five
months later we got the tests and when
we did one test how long is send email
to end recipients just send it to a
thousand recipients 11 seconds is that
good is that fast enough is that slow I
don't know
2,000 4,000
yikes and some companies it would be
perfectly reasonable to want to send
email out to a hundred thousand
employees and it would have taken 29
hours completely you know that they were
hoping for minutes quadratic growth is
bad in real terms it's horrible by
looking at each dimension independently
most the tests were passed with no
problem at all but by forcing this we
forced it to instead of focusing on
feature interactions to focus on each
dimension to see how important it was
how could you introduce a diseconomy of
scale in email why if you want to send
out twice as many pieces of email
shouldn't take twice as long fighting
spam that was worse than that Tony Hoare
says that the root of all programming
evil is what premature optimization is
the root of all programming evil what
happened here is that someone said boy
spending the same piece of email twice
is really wasteful how am I going to get
around it I will keep a sequential
structure of the addresses of everyone
to whom I've sent email and now when I
went to send the next piece of email
I'll go down the list and so when I send
out the thousand piece of email I look
at all of the previous thousand names
and maybe I won't stood out maybe a
thousand and first look at all them
again this means that to send out a
thousand pieces of email you sent out
you look total at a million
gets worse premature optimization here
turned inherently a linear task into a
sequential task Ian and again as we
mentioned before when you run this test
you should see how many pieces of email
were sent how much time was spent in the
mail system but the CPU time matters to
major count everything count how many
comparisons that thing was making along
the way how do you find such bugs tiny
performance tests among critical
dimensions in addition to looking at the
big thing in real context if you're a
bicyclist trying to ride figure out
first how many hours you can ride or how
many miles an hour you can you can ride
in a few minutes then how does time
affect it
how does went up hill and down cull
affected how this fatigue after a long
day affected do those other things but
first is major the tiny performance
things along the critical dimensions and
here by going out big and not that big
to begin with we forced these accreted
bugs to become catastrophic some of my
personal favorites these are things that
I've done myself don't blame me I was
raised that way
I changed a function to a macro for my
old evil way of thinking how much faster
could that possibly be on a good day
with whim behind your back changing a
function for a macro gets rid of some
overhead maybe this was a little bigger
what sort of improvement are you talking
about changing the runtime are you
talking about you hope maybe yeah I was
hoping maybe there would be a factor of
two faster wouldn't this be cool change
function in that go for speed of a
factor of two maybe and this one it gave
me a slowdown of a factor of 10,000
something I hope for a factor of two why
it turns out it was a recursive function
at the end I returned the max of a and B
and C and in the function evaluated them
once recursively has to back in the
function
in the macro was forced to reevaluate it
and I changed the recurrence relation
describing it
I took a linear function to be cubic
roughly this is just horrible so
sometimes again premature optimization
always major things be careful I just
worked on this system last year where if
one person had gone through the system
and changed one number from 8191 there
was the the modulus of a hash function
was the size of a hash table if they
change it from 8191 to 8192 and that's a
couple number two to the thirteenth I
love that number
I've inclined 8191 is prime I like
Prime's two powers of two crimes and um
it slowed down things by a factor of
eighteen hundred I was leaving an
unexploded bomb in the middle of this
large software system by having this
hash table there we had the document the
heck out of it scene this is a weird
number is a prime if you ever change it
go to a prime conduct these two house oh
when I first did this I was working on
that with a colleague and I said here's
a hash function he showed me his
factions try this kind and by the way
make it a prime so why should I make it
a prime I said because I read about it
in a book thirty years ago just it's not
a prime now it works fine did some
experiments fail in this case where it
was that kind of slowdown
part of me we didn't even need to do
that and this big system I wanted to
keep things as simple as possible
there's a lot of things we can do but
here we put it in and we just documented
it carefully about make sure that's
prime that that's sort of the magic that
some people have reversed a search week
into one place where if you reverse the
search should be have slowed down by a
factor of 75 these are things that I put
into systems and I'm now much more
sensitive of these things that I'm doing
predominantly for the purpose of making
things faster could make things very
much slower here are the performance
bugs that I've mentioned to you changing
the nature of inputs to be sorted giving
this organ pipe thing for getting one
simple reset to zero I make something
that I can prove Mathematica is optimal
and my user tells me it's too slow
different speeds in different part of
the memory hierarchies I glossed over
this backspace a unit test that was
should have been turned off was in fact
enabled the memory management system is
used in a context there was a factor of
a thousand larger than its designer ever
anticipated she built a program for
right now people thought it was a
program for all time are your programs
programs for the next five years or they
programs for all time how do you intend
them how will they be used somebody made
a system faster by cashing in a
recipient list minor changes to code all
these are just little tiny one-line
changes and they have disastrous effects
what causes performance bugs in general
change the code tiny goofs think those
typos small changes big input doing that
scam before email new inputs inputs of
unexpected size the sort with caching
different nature of inputs the user
expectations you really have to be
careful to design some things you can
add on to a system some things have to
be designed into the system from the
start so
purity and performance have to be
designed into the system from the very
start knowing what the user really wants
has to be designed there you find out if
you didn't design it in test early and
ask the user is as fast enough is this
adequate for your needs underlying
system behavior it's good right now but
as I port my design in different
contexts is the underlying system going
to support my system appropriately and
in those contexts how do you attack
performance bugs all the way from soup
to nuts today I wish I could give you a
certificate that says that each one of
you has performance bug awareness if
nothing else you've wasted an hour a
perfectly good hour of your life but
you're now aware of what performance
bugs are when you specify software talk
then about what kind of performance is
required in the initial design go that
way through the coding make sure that in
your unit tests you do that at both of
the unit tests and other things develop
performance models of your code and make
sure that these little software models
an Excel spreadsheet is a fine
performance model make sure that things
are close enough to your performance
model profiling in various ways
monitoring things in the ongoing way in
every test that you ever conduct monitor
it as well monitor how much time it
takes how much space it takes how many
RPGs it takes whatever it is continue to
monitor it once you identify the culprit
I've tried to focus today on showing you
tiny little experiments to say that this
thing is bad I decided to take
essentially this talk is modeled on
Sesame Street where the word for the day
is performance bug and it's mr.
quadratic is the evil monster that we've
been getting attacked by actually that
that's not the only kind but it's one
that I chose to illustrate because it's
one that comes up a lot how you identify
the culprit how you certify it and then
how you go about repairing things
for performance testing test both
components and the overall system
monitoring profiling tools count
anything and everything there is nothing
that don't need counting does this if
you can imagine a counter whether it's
microseconds nanoseconds kilobytes of
page faults critical events of any sort
furthermore automate the tests the
analysis and the meta analyses automate
the fact that G might my numbers in here
this number is only 1% worse than that
if it's 1% worse for 72 times it'll be
twice as slow monitor things to make
sure you don't have any long-term trends
but monitor all of those automated and
exploit what we have going for us
different kinds of experiments I've
talked about exploratory experiments to
find where does the time go
just the the page profiler on that
system we sent a lot of pages across a
pretty skinny link no one ever bothered
to profile it all I said was let's just
gather here just tell me the page
dresses are going across and we found
this one piece that was left in
accidentally to account for
seven-and-a-half percent of the page of
transfers confirmatory does it really go
there I've shown you these tiny little
dozen line programs where I just pick on
the bug and it's evidence you can bring
in a court of law and you can have 12 of
its fellow functions in a jury boxing
guilty just no doubt about this that it
really does go there for these tiny
little pieces and for maintenance
most of these bugs in my limited
experience are introduced when people
try to make things faster you try to
make it faster and you end up making it
slower so
I spent the last 50 minutes of your life
talking about performance bugs you said
you would accrete questions along the
way are there any questions about
anything I've talked about so far yeah
we have time now or is this a lesson
graceful way of doing that I thought it
was closer
yeah so my good buddy writes me an email
saying another Q sort our our newts for
causing system to crash the maximum
providing sort is 512 I'm only five
million twelve items but that sort is
recursive and wins 45 new 12 elements it
ran out a process tax base so we removed
it we might want to put it back in it
was really handy to have those and
sorted and make a lot faster do you know
of another sort album that can use up to
512 32 bits integers that's very fast
but doesn't use recursion an
embarrassing clarification let's look at
this sort yeah it's the one I wrote so
all of a sudden I had some skin in the
game that became sort of interesting
there were two separable issues here is
the sort really guilty and the other is
do I know another algorithm I happened
to have spent this morning watching a
wonderful video about Sikhism and law
enforcement and sir I apologize if
there's any offense but there was this
video that a friend of mine sent me
about it started off with there was a
mom and her kid or touring the Jefferson
Memorial they come up and they see a
suspicious person in a turban if someone
were taking photographs and they they
they get all upset they talk to a law
enforcement officer the 12th years go up
and it approached the second gentleman
and they say sir may we speak to you for
a moment
he says sure and well we heard there's
something suspicious going on as well
that's yeah I'm in law enforcement too
and it happens that he's the deputy
sheriff and he shows his badge and the
point is that we live in a world of
prejudice and fear a lot of programmers
are prejudiced against and fear
recursion it's just sad but true these
people did this was it really the sort
program that was at fault as a recursive
program the Manas tax base blame the
poor sort program that that's how it is
the old testement
so I said good news I thought three
lines of code is be faster it was great
but let's make sure the recursion is the
culprit I've attached a little recursive
program and all it does is it
runs through an allocates tax base cares
its output on my system it goes up to
around a million that advise all we need
to do is put it at that point in your
program the first time to put it in this
big monster system though the system
runs it's gonna take half an hour to get
up there let it run and this program
will do that and this will test and tell
you roughly how much tax base it does
what is my little testing program look
like so here Isis you custom looked for
a put code like this the place here's
what my code looks like it doesn't
matter it just sums one plus two plus
and recursively what it does essentially
is say if N equals zero return zero
otherwise return in plus the recursive
sum of n minus one and then in the
middle it uses memory and it thinks
around just to try to fool the compiler
if you're just do this run this test
will see is recursion to me to guilty as
tax victory the guilty I don't think it
is what happened
anybody want to guess what happened
there are developers they were busy they
were working hard they found the guilty
party guilty recursions dad I have no
idea it's a story with no punchline
I have no idea how them that I really
wish I did but you do that a lot um I I
assent much in my life as a consultant a
consultant is often defined as a guy who
knows 468 different positions for making
love but has never had a girlfriend it's
a lot of times you did this it seemed
like to me like a really nice example of
a little test program that would get
right to the heart of the matter but
they were busy getting out their code
they yanked it I gave them the other
program I think they put the other
program into their system sorry that
that's why I glossed over it I'm telling
you the truth here any other questions
going back now to the final slide I hope
I'll be about that that's an inspiring
slide any other questions
twenty years ago I could have answered
that but now it all depends in the
system in the context we're at Google
the essence here is every story I have
told you has been about things that run
on one processor at Google that's not
where the action is the tools really
vary from platform to platform there are
some great tools particular platforms
but it's very very platform dependent
and I've been working on some pretty
cool things recently on some particular
platforms but I used to keep up without
I can't any more honest answer
talk to your friends who use similar
platforms and it's very platform
dependent anything else yes my yeah I
really enjoyed writing those columns for
CAC I'm the books have been very very
kind to me I am deeply grateful for
anyone who has ever read the books and
much much much more grateful to anyone
who ever bought the book the yeah I
didn't not being a version of
programming paroles about ten years ago
and it was I try to mention in there
some approaches to this I can use system
Pro fathers if you have them and then
add counters add things measure
everything learn about how real
engineers do it see what they do and how
see the amazing thing is that you can
look at that bridge and you can see you
know they what are the key issues in
this bridge it's supporting weight you
can see where the weight goes you can
watch the weight flow there is no big
surprise for the weight so then actually
in a suspension bridge what are the
issues here and he would have tell me
what the engineering concerns are yeah
number one it's the dead load of the
bridge itself number two it's the
live load do you ever put tremendous
live load on a bridge like this
what kind of live load you put on the
bridge but the wind is something
different that that's um but it snow and
ice for the Golden Gate Bridge when did
they put twice as much load on it as
they ever expected they would yeah that
no not a marathon you don't care about
that much runners increasing contact no
for the 50th anniversary of the bridge
that people sort of going to cross it
they put twice as much by load on as
they stepped the bridge for that they've
affected have 50,000 people that they
was like 700,000 people came out that
day they did some math in a hurry
they found GI cáceres a factor of two
here but they designed the bridge to
take a factor of four and do we have to
stop the party do we have to go out and
throw them off the site or anything they
didn't have to but you're designed for
dead load for live load for win and for
suspension bridges that they learned the
watch about the aerodynamics and they
know now how to get around most of those
problems but there you can sort of just
look at the flow of things tragically
and the point that I tried to make today
is in software you know if there were a
rivet there that weighed 75 percent of
the weight of the foundations you could
see it in software you can't see it you
can't see the read the expensive pieces
that was the point I was trying to make
and it means that we just have to
measure everything and be much more
careful about that anything else the big
hand is now near the six it's time for
us to stop thank you very much I'm
deeply appreciative of your time
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>