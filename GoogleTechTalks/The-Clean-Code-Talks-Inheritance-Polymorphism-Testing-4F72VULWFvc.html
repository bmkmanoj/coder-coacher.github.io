<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;The Clean Code Talks  -- Inheritance, Polymorphism, &amp; Testing&quot; | Coder Coacher - Coaching Coders</title><meta content="&quot;The Clean Code Talks  -- Inheritance, Polymorphism, &amp; Testing&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;The Clean Code Talks  -- Inheritance, Polymorphism, &amp; Testing&quot;</b></h2><h5 class="post__date">2008-12-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4F72VULWFvc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you guys for coming by the way
these are the new and improved code
quality talks we have they've asked us
been a great job revamping them and so
these are the new and improved ones so
if you've seen it before come again and
we'll do it again
is it not Oh pastor doc over here huh
uh-huh I'm so used to the clip-on
microphone that thanks for reminding me
okay
so today we're going to talk about
basically conditionals and polymorphism
and how that affects testability so
here's the premise and this is a bit of
a crazy premise and that is back in the
day when we went from Pro the basic
world is not even procedural languages
what are they called
well the basics of the world into
procedure world we were able to get rid
of go twos and I don't think anybody has
really missed them so here's the
craziest thought and that is if you go
from procedural languages to
object-oriented languages you can get
rid of quite a few if statements I'm not
going to go as far as say although but
for the most part you can get rid of
most of them it's actually kind of fun
to see if you can try writing code
without an if it's very unique way of
writing code as a matter of fact there's
even certain languages out there like
small talk where the concept of if
doesn't even exist it's not act it's not
part of the syntax of the language so
why would you want to get rid of an if
statement here well the thing is that
code without ifs are easier to read and
I don't think anybody can really argue
with that right if you can just breathe
code straight you know do A to B to C to
D it's pretty clear what's happening
we're apps if somebody says well do a
but then sometimes to B and some other
times you see and then maybe you do D
well it's kind of confusing as to under
what condition what's happening and
what's what's HAP what's the output and
so because it's easier to read it also
turns out that functions without if
statements are easier to test as a
matter of fact you only really need
probably one test maybe a couple of
tests for exceptions but for the most
part what this will do because there
really is only one execution through
your code
this particular function and as a result
of all this polymorphic systems or
systems that do not use if statements
tend to be easier to maintain easier to
understand easier to extend and
therefore are those are all properties
of things that we really like and we
look for so when should you how do you
get rid of if I guess a better question
is you get rid of if by using
polymorphism in this place where as you
dispatch into a method whose binding is
not known at compile time right this is
good old polymorphism where you have a
class in the subclass and you have two
different instances and when you say
print it's not clear whether you are
printing to the printer or printing to
the screen because it's a PDF so you
want to use a polymorphism if the
objects should behave differently based
on its state and we're going to talk
about an example of what that means and
you should also use polymers prizm if
you have to check the same condition in
multiple places this usually happens
with flags where you want to enable
debugging or disable and a new code is
sprinkled with all bunch of if
statements saying if this flag is
enabled and deuced this extra stuff over
here so let's have a look before we go
there I want to point out that there are
certain places where you cannot get rid
of an if if you're comparing if three is
greater than seven there is no other way
of doing it other than an if statement
so for comparison of primitive types
with a lowercase int as opposed to the
application teacher you really have no
choice but to use an if statement but
you know we're not going to focus on
that we're going to focus on where the
business logic should behave differently
that's the interesting part I also want
to point out that if you are if you
really want to be if free in your
application the thing you have to do is
you got to make sure you don't return
notes and we kind of talked about that
earlier in earlier talks how nulls are
your friends inside of your tests but
really your enemy inside a production
code you really don't want to get in the
situation when you return null because
when you return the null from from a
method
you can't dispatch off on an oil you'll
get a null pointer exception and so what
you need a
is you need to put in a statement over
there to make sure you don't dispatch
and no and then that clutters your code
and so we want to get away from that so
you simply want to always be in a
situation where you have if you have a
method the method needs to return some
kind of an object it probably doesn't do
anything typical example of this would
be like the know logger if I need to log
I'm always logging except sometimes I
get a real logger that logs to the file
system and sometimes I get a logger that
just eats all my messages and doesn't do
anything um but not all is good and
great you gotta be careful not to go on
crazy with subclassing when you have
deep inheritance hierarchies that
creates problems from not just the
stability also from understandability
and a couple of other abilities probably
as well so it's it's a very fine line
between you know getting rid of your ifs
and at the same time not turning your
application to one ridiculous
inheritance hierarchy so let's look at
the first case of where you can get rid
of an F and that is getting rid of a in
case of where you have state-based
behavior this is quite common if you for
example have a conditional that chooses
different behavior based on its type
typically the way this thing happens is
you have some kind of field inside of
your object and then based on whether
this field is set or a flag you behave
differently and really what we want to
do is we want to say okay when this flag
is on all of this stuff that happens
differently should really go into a
subclass and when the flag is off all
the stuff that happens in the flag is
off to go into this other subclass and
then the common logic stays in the
superclass and that way we can separate
the ifs from the non ifs or from the
flag turn down from the non turn down
simple stuff you know this is described
in the refactoring book so by all means
if you have one of those if you do
suggest you you read it and you use it
as a reference but let's let's go look
at an example of what this thing would
look like so suppose you have a method
such as you know get speed and there's a
switch operation and on a switch
operation we return different things
this is typical things that people do
inside of the
code any suggestions on how to improve
this subclasses exactly and you know
don't we already have a type system like
if you're switching on a type or the
type of bird you are or anything like
that and based on that you're doing
different operations we already have a
subclass system and so we should take
advantage of this thing and so you know
solution for this is quite obvious right
you have your base class bird and you
have your European Norwegian and African
swallow and then you can subclass it out
and have different behaviors in
different locations so this is a my
favorite questions I'd love to give on
interviews I don't know if any I don't
think I've interviewed any of you guys
in the audience but the premise is very
simple you have a mathematical operation
such as one plus two times three and you
want to represent this as a tree so as a
tree it will look like this and I'm sure
you guys are all familiar with this and
so I would like to have a way to of
storing this in memory so I need to have
some kind of a class let's call it a
mode which stores this tree and then I
want to perform operations on this and
two for the purpose of the example let's
say we want to perform evaluate method
on it which computes the result in this
case two times three is six plus one is
seven
right but while I'm going through the
examples I want you to also think about
the typical class such as node would do
other things such as two string
operation let's say and a two string
operation should print this the the tree
placing the parentheses only when
necessary but you know a real class
could have lots and lots of other
methods that can do lots of other things
so once you get into real real class
situation the issues you're going to see
in next couple of slides are going to be
even so much more important so just keep
keeping an eye on them and just keep
thinking us how this would affect your
two string method as I go through the
evaluate method
so when I have an evaluate method that
computes the result of an expression you
know pretty straightforward stuff and
what we want to do it when you give this
problem to most people this is what the
solution they come up with is they say I
have a class node and I'm going to have
an operator on it which basically says
whether I'm a plus multiplication
division and so on and then I'm gonna
have a value which is the number that I
represent I'm gonna have the left child
and the right child and my evaluate
method would then have a switch
statement that switches on the operation
I am and then perform the operation you
want now keep in mind how the to string
method would mimic this right your to
string method you know in order to get
the the in fix notation printed would
essentially mimic your switch statements
here but there's actually a bigger
problem with this before we go there
let's kind of do graphical
representation of this right so you have
your node as we point out we have you
for field and one evaluate method and
this would represent into a structure
such as this notice a couple of weird
things in there our leaf nodes still
have the left and right child and
they're pulling thing to nulls and we
already said that nulls are not a good
idea in production code right and so
we're going to trip up over our no null
values by having the possibility of
having an empty e so you want to kind of
get rid of that also notice on something
else which is the the plus and the
multiplication node has to keep around
zero even though it's a completely
meaningless concept for a plus or
multiplication to have zero associate we
have some number we have to give it
something over there right in our case
we chose zero so it has information that
it doesn't need right so there's two
different behaviors that are kind of
fighting in here and so that the
different behaviors are basically if
you're an operation node then you need
your left and right child whereas if
you're a value node you just need the
value and you can see that in the
presentation how I either need the value
or I need the left and right but I never
need both and that usually is a
example that you have a class that has
multiple responsibilities all entangled
inside of it and then there's some kind
of a polymorphic behavior going on but
the polymorphic behavior is going on
through fields and if statements not
through polymorphism so let's break this
up let's take our node and we say we're
going to have a value node an operation
node and by breaking this up into value
an operation node where we can do is we
can take the value and shove it into the
value node which is the lift leaf node
and we can also get rid of the left and
right child for the leaf node because it
has no meaning over there and so this is
a good way of separating it out and then
simplifying this thing so we would have
our you know standard issue node with
the evaluated operation and then we have
the value node which extends the node
and defines the evaluate method to
simply return your value notice how
simple the value node is right there's
no if statements in there there's
there's no possibility for null or or
npe or anything like that but we're
still left with this OP node which has
this nasty switch statement inside of it
now I want to point out at this point
that think about how you would extend
this not only do you have to worry about
having your to string method and your
evaluate method mimic each other but
every time somebody wants to add a new
operation they have to recompile the
code not only have to recompile the code
they have to get a hold of their source
code first so if this is meant to be as
a library that a third party is using
they might not have the access to source
code or maybe they don't want to
recompile the library right and so let's
see if we can do something better so
with this change this is how the tree
looks like right we got rid of our nulls
for our leaves so we're making good
progress and now when you have operation
node it no longer has the zero that's
what stuck over there before and so this
is definitely a progress in the right
direction but we still have the same
problem as we had with
with the swallows in the previous
example and that is that the behavior of
the node changes based on a type or in
this case it's the the operator field
right so depending on what the operator
field is our class behaves differently
and that's something we want to avoid
rather we want to take advantage of the
construct of a language which is the
polymorphism to take advantage of this
thing rather than encoding it using if
statements so again let's focus on the
addition and multiplication and let's
further subdivide this into a operation
node where we keep our left on the right
because all operation nodes have left
and right children and we now just have
evaluate which is continuous being
abstract and it's count becomes concrete
in the addition node in multiplication
node that's where we have the actual
implementation so from a coding point of
view right we still have our value node
now we have our abstract op node we keep
our left and right in at this level and
now we have the addition node and
multiplication node which does the
actual operation notice what happens in
here first of all the possibility of an
NP has disappeared because you know
operation nodes needs a left and right
child and therefore it won't not it will
never throw an NP e whereas the leaf
node doesn't have a left and right child
and again it will never throw an NP e so
we can really clean up the code simply
by breaking it away into smaller sub
classes that do individual pieces of
work again keep in mind that in addition
node you would also have to implement a
two string method that would know how to
print the the plus operator and in the
multiplication node you would have to
write a two string method that knows how
to print the multiplication operator and
so on and so forth right so it no longer
is bunch of switch statements in
different methods that have to all mimic
each other they're now separate
subclasses and if you wanted to add a
new operation it's very clear as to
which methods you have to override in
what you have to implement over there
right I know I have to implement the
evaluate method because it's abstract
and I know I have to implement the to
string methods and therefore I can
easily any new person who comes to the
project doesn't have to be be explained
or doesn't have to go through the code
in great depth
it's very obvious as to what needs to be
done because it's simply the code
doesn't compile any other way so after
all this we basically end up with
addition node on multiplication node and
again notice how the addition node and
multiplication node now don't have the
operator field not only they have no
operator field they also have no value
field which we originally had at the
beginning so they went kind of on a diet
they became just the meat of what needs
to be done so we kind of talked about
the to string method all throughout the
presentation but this is a good point to
kind of reflect on how you know in
real-world projects where you have
multiple you might have evaluate method
you want to have might want to have a
print method and a couple of other
things how it really helps the situation
because you have one structure that you
deal with and you don't have to go
through multiple places and remember
where everything has to change so I'm
gonna argue that a polymorphic solution
is oftentimes better specifically
because the new behavior has to goes
into a separate subclass right all of
the behavior specific to addition goes
into one subclass all the behaviors
specific to printing leaf nodes goes
into another subclass and so on and so
forth and that actually makes it easier
to test that makes it easier to
understand it makes it easier for people
to extend and maintain you know all of
those are good qualities that we're
looking for so that's one way you can
get rid of an if statement right before
we get there so switch statement
whenever you see switch statement in
your code base that's usually a clear
sign that polymorphism is begging to be
there it's almost the rule I would go as
far as saying if statements are more
subtle subtle and most of the times we
want to get rid of ifs and add poem
orphism but there are certain cases
where you know you do want to be
pragmatic about it
but let's talk about the other situation
of where you want to get rid of a
statement and that is when you have the
same condition all over the code base
let me give you an example suppose you
have a method class called update and
there is a method called execute and
based on some flag you have to do either
a a portion or the B portion you might
think yeah it's not so bad you know I'm
just I just have a flag and I do
different behavior depending on what the
flag is set or not well I would already
argue you probably want to have a
polymorphism at this point but you know
it's still just a single if statement
but at some point you have a rendering
method and now the same if statement
appears again and when you start
repeating the if statements over and
over and over again that's a clear sign
that you what you want there is
polymorphism the reason for this is
because if you look at the do a part in
the render a part they both go in the
stick both can execute it together
similarly with do be part and render be
part right they those pieces get
executed together and the rendering
pieces go I'm sorry the a parts get
executed together and the B parts get
executed together and it's not like you
can execute a and B actually that would
be a bug right if you could execute a
and B and so you really want to make
sure that the conditions are same
preferably you want to get rid of the
conditions now from a testing point of
view this becomes a problem because you
know not only do we have a global
variable which is the flag which is
usually how a command line flags get
dealt with but it's always you're not
really sure like that you really cover
all the if statements because are these
if statements really combinatorial like
is it possible to execute a do a and
render B or is it not you know it might
be easy to see in in a simple class like
this but if you have a very complicated
class with lots of code base it's not
clear which conditions go together with
what and so you might end up trying to
test things that can't actually happen
in production and so what we want to do
is you want to really separate it out
same story as before and that is we want
to use polymorphism to our advantage we
want to take the eight parts and put
them in one class and take the B parts
and put onto the
other class right and the work over here
is pretty straightforward you create an
abstract superclass which is the update
and now you take the the eight do the a
part whether it's a do a or render a and
pull it out on a separate method called
render and execute and you do the same
exact thing for the non-international
class right so now you have two
subclasses representing what you wanted
to do now from a testing point of view
this is great because when I instantiate
an internationalized subclass I know
exactly what I'm talking about it's not
some flag that got set somewhere else
it's a concrete class that I can
associate with it
it's significantly lowers my cognitive
load when I think about the test I don't
have to think as hard when I deal with
this thing and I have a separate test
for the other subclass right and again I
don't have to think about all the
nuances not only are the tests separate
chances are that being International and
being non International requires you
probably to have a different set up
method will probably require different
fixtures and different ways of testing
it so that further helps by separating
the different kinds of tests out but the
if statement really have this didn't
disappear if Sigma is still there rather
there's two different kinds of if
statements there is if the if statements
that is in a location where the if the
original if statement used to be which
is the polymorphic behavior of your
codebase but there's also the original
if statement just got moved somewhere
else and that is if you are a consumer
of the update and you say I need to get
a hold of the update what you're really
saying is I need either the
International or non international one
but you don't know which one it is and
it's really not your business to care
about which one you get so somebody else
is responsible for instantiate in the
correct subclass of what you want which
gets us back to the good old dependency
injection which is that you have two
piles of objects you have the piles of
objects which does the business logic
this is where this stuff actually gets
done
and then you have a piles of objects
that are responsible for the object
graph construction again for those of
you guys who have been here before on
these talks you know we cover this many
times over because it's really really
important by separating the objects out
into the objects that the business logic
and the objects that do construction
you can basically move your if statement
from being in lined inside of your code
which shows inside of the update used to
be just if you're international do
something or something something else
you move that if statement into the
factory so now the factory says ah maybe
I have to instantiate a international
version of the update because the
consumer is asking for it as opposed to
making the decision in line in your code
now that actually can have great
benefits in terms of performance because
you don't have to make the decision over
and over and over again as the code runs
in some kind of a tight loop you make
the decision once you instantiate the
correct subclass and it gets enlightened
it turns out many modern JVMs can
actually inline that for you so a modern
JVM for example notice that nobody has
ever instantiated the non international
version which is probably true if you
because you're only running your
application into one mode or the other
mode and when the JVM notice is there's
no other subclasses of this thing it
will go and inline these operations
which is great speed performance
improvement now if you're using
something like Jews you know you can
take advantage of providers
the fun stuff is your business logic
this is what why we are the software
developers right I'll even live and
breathe to make code and my code is
mostly the fun stuff you know the logic
D the stuff that makes the cool
applications right the factories are the
boring stuff of like I got a wire it
together so that it runs right it's no
good to have a cool algorithm that can
sort your data you need to have some
kind of wiring that says okay
instantiate disorder is 10 shoot the
reader instantiate the filesystem and
then hook it all together and then kind
of orchestrate the whole thing that's
those are the differences between the
the business logic and your new
operators your factories or your new
operators and we kind of mentioned that
how important it is to separate your new
operators from your business logic
because you want to be able to inside of
the test you want to be able to
instantiate a small sub portion of your
application and by mixing the new
operator together with your application
logic you don't have the control in your
test of instantiating things in
isolation and that kind of prevents you
from being able to test things so you
know coming under kind of cover this
right but the part of the the the
business logic is responsible for doing
work right and the Constructors or the
factories are responsible for wiring the
objects together building you the object
graph right the reader talks to the
filter talks to the writer which talks
to the database right the wiring magic
happens inside of factories that's where
your new operators end up it is also
where your some of the if statements end
up because you want to get in the
situation where your application behaves
differently not because you have if
statements and flags sprinkled all over
your code but it behaves differently
because you wired it together
differently and it's a big aha moment
right because when you can change the
behavior of applications simply by the
way you wire it together differently you
have a lot of possibilities of what you
can do at runtime in terms of compile
time in understanding in maintaining it
extending it so if you're using juice
for example the the Constructors could
be your dependency injection right this
is what creates the providers which
hooks it things together where the
actual original check into the flag is
made to see if we are international or
we're not international and then we can
subclass the correct we can instantiate
the correct version of it now going back
to the international example it turns
out that when you subclass things into
international non international chances
are that the two subclasses will
actually have different set of arguments
in their constructors and that's
actually important because if your
international chances are you going to
need certain classes that you don't need
when you are not international and if
you have a single class where everything
is done then you're forced to create all
the objects and pass them into the
constructor even if they're not needed
so let's have a look at this so you have
a consumer and wants the update so what
you need to do is to create some kind of
a factory right this is where the new
operator is for the update and this is
where the if statement happens we are
either instantiating the international
version or the non international version
so the if statement has moved from being
inline in your application to being
inside of your factory and that's great
advantage that's what we're looking for
if you're using juice this gets even
better because then you can simply
create a provider and you can create
provider of International which is
automatically done for you you can ask
for the provider of international
version you can also ask the provider of
non international version and then you
can simply ask for the flag so you can
go a step further and you can get rid of
the dependency on the global variable
and now you can simply test you can
simply say ok get me the correct
provider location so now now you
actually make the provider testable
because all the pieces are fully
injectable
so the benefits of this is the the
conditionals as we pointed out of the
decision of are we International or not
has gone into a single location so we
took whole bunch of independent ifs and
we collapse them into one if and we move
that if from being inline in your
application to being inside of your
factories we got rid of a lot of
duplication in the process and
duplication can cause errors right if
you discover that your if statement has
an error now you have to go change all
the if statements that are spread all
over the code now we have only a single
if statement so if there's an error in
the if statement we can easily fix that
fix that and it also allows you to
separate yourself from global states
like originally we were doing an if
statement on a global variable in line
now that nasty global variable ended up
in some factory so from a testing point
of view yeah I might still have a hard
time testing the factory but I have easy
time testing my logic so we have taken
something that we consider bad and we
have moved it to some other place where
it's still bad but because of where it
is it doesn't cause as much problems for
us so the benefit of using polymer film
instead of if statements is that you
simply have a single locations where all
of your related items are together the
multiplication example you know we had
the multiplication logic we have the two
string logic it's one location in the
rendering example we had a single
location where we could put the
rendering and the operations for the
update in single place and it greatly
aids in cognitive load when I think
about this thing not only doesn't help
with cognitive load it also helps with
testability understanding and makes it
easier when you look at the subclasses
to figure out what the differences are
right if I look at international non
international version I can easily see
what the difference between the two of
them are because the common stuff is in
the superclass I don't have to worry
about that I simply have to worry about
what is different between international
and non international
version or what is different they've
been multiplication and addition I don't
have to worry about the common stuff
because that's somewhere else
anyways behavior so you want to use
polymorphism you know we cover two
different things and that is you want to
use polymorphism when the behavior
changes based on state right which is
the example of the multiplication where
we had a flag and based on that flag
which was whether it was a addition or
subtraction we did different stuff or
you want to use polymorphism when you
have the same if statement over and over
and over again this is typically done
with flags but and on the end of the day
right you gotta be pragmatic so don't go
crazy I recommend that you try writing a
small project without any sort of ifs
just say I'm going to try it without if
so you're going to learn a tremendous
amount about how you can take advantage
of polymorphism a lot of different ways
it's worth the experience but any other
day you know your big pragmatics if
there is a simple extent that I can
throw somewhere that's fine but when it
becomes too many if statements it
polymorphism really is the way to go the
thing is if statements creep up on us
you know you throw in one and you're
saying I'm being pragmatic come along
comes along somebody else and he's
extending the code and now he says well
I'm just doing what the other person is
doing and now you're no longer being
pragmatic
you are now duplicating code but you're
not realizing it because you didn't
write the original if statement
and so Bart says that you promise not to
use abuse conditionals in polymorphic
languages and instead use polymorphism
for it anyways I'm going to open up for
questions
by the way I want to point out that this
might sound like an obvious stuff
especially with the example of
multiplication but my empirical evidence
of looking at other people's code tells
me otherwise it's one of those things
that when you see it people say yeah
clearly it's obvious yes that's how you
should be done but then when you go
inside a code base all you see if
statements everywhere and very rare use
of proper power morphism do we have a
microphone I guess we don't
yes I'll repeat your question
huh
so you're saying that the just repeat
the question you're saying that the
example of additional demote the math
example was too concise and as it was
nicely concise okay and so you're
wondering if a different example would
be uglier he said what I'm hearing
yes
right so your objection is or the
question you have is that many people
could argue that a single file with the
eval with the node where you had a
switch statement is clearly easier to
understand than the whole bunch of
smaller files I have an issue with the
word clearly over there to me it's not
that obvious and again it goes back to
you know you write a simple Nova class
that today is just doing node operations
and additions and subtractions and
tomorrow somebody adds something to it
and they have to duplicate the switch
and so on and so forth to me this is not
even a question of pragmatics there is a
concept of an addition and the concept
of an addition has behavior adding two
numbers and in the OL world behavior
deserves to have its own either a method
or a class where it lives right now in
order to dispatch of the behavior you
would have to go through an if statement
which is what we kind of don't want to
go because we know it's a slippery slope
where we say yeah I wanted statements
okay to bring pragmatics but soon enough
you know we have a file that's 5,000
lines long and there is if statements
everywhere nobody can quite figure out
what's going on especially with today's
day with modern high des the cost of
writing creating a new class is
essentially zero so or traversing it or
finding who the colors are etc so
there's no real problem there where
people actually do get into problems
which I see often is they they don't
separate responsibilities of objects so
a single object has too many
responsibilities now keep in mind that
your object can only have one
inheritance hierarchy which suggests
that you really should only have one
responsibility because that's the only
you can only take advantage of single
polymorphic behavior through a single
inheritance and the way around that is a
rather than either way around it it's
not a workaround it's a good idea is you
should break it up into lots of small
objects that collaborate with each other
yes but you only remember what we did
sorry you repeat the question for the
audience you were saying that you could
be Paul more focus on multiple methods
that is true but the polymorphism is
decided on at the point where the new
operator is instantiated right and at
that point you cannot say that these two
methods will be polymorphic on to this
behavior but these two other methods
will be on this other behavior right
it's all-or-nothing proposition so all
methods have to end up in the same
subclass and for that reason you have to
clearly separate responsibilities of
objects otherwise you have two
responsibilities and those two
responsibilities would want to have two
different kinds of inheritance and they
will be fighting or put it differently
when I am on a team and I see nasty use
of a switch and I say you should do
polymorphism the most common suggestion
is but I came I already have a specific
kind of inheritance right and he
answered that is well that means you're
mixing responsibilities inside of that
object really there is a whole bunch of
related objects living inside of this
one object and their behavior is
controlled by whole bunch of flags as
opposed to collaboration
alright guys thanks for coming we have
these talks every week we always have a
different topic these are new and
improved talks so we appreciate feedback
also as I always point out I do have a
whole bunch of the Java reviewers guide
so some of you guys want one of those
I'll be happy to give them out
thanks for coming and we'll see you guys
next week</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>