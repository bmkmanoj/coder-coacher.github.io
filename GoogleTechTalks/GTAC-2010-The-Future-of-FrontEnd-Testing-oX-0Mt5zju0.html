<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GTAC 2010: The Future of Front-End Testing | Coder Coacher - Coaching Coders</title><meta content="GTAC 2010: The Future of Front-End Testing - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>GTAC 2010: The Future of Front-End Testing</b></h2><h5 class="post__date">2010-12-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/oX-0Mt5zju0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Simon Stewart as you were
just told I'm the tech lead on the
webdriver project which is becoming part
of selenium 2 and I'm an active
contributor to that I work with the
browser automation team here at Google
and doing all sorts of fun and
interesting things trying to make
browsers actually work and make it
possible to write write tests with them
if you're if you're on Twitter my
username is SHS 9:6 see follow me I'm
getting perilously close to 500
followers and you know that would be
awesome I might you know be happy I also
know that it's really really close to
lunch that we're running late and you're
all desperately hungry so thank you very
much for your continued patience and you
know listening and stuff like that
please don't heckle too much so once
again I'm noisy and you're quiet
shall we start by describing what a
front-end test is probably a good place
to start for a talk entitled the future
of front-end testing Greg ok I can do it
yep not a problem you can see that we've
had a long time Greg works in the
Cambridge office and I work in London so
we don't actually get to meet very often
in person and so what's a front-end test
well one way to describe it is it's a
test against your front-end now what's
behind that front end is the thing
that's quite interesting so
traditionally these front-end tests are
also known as end-to-end tests or
sometimes integration tests so you've
got the full software stack running and
and your testing against that in other
cases what happens is people stub out or
simulate the backends and so actually
the front-end test is running against a
fairly slim part of the system obviously
sort of the the more traditional usage
is in the in the end-to-end tests and
that leads to a number
problems yeah and because these tests
are so large our first piece of advice
to you is to not write them if you can
get away with it you should prefer unit
tests or system level integration tests
at the API level because they're so
large they depend on so many backends
and so many sub components if there is
any level of flakiness or brittleness to
any of those dependencies those can
bubble up and affect your tests as well
and they're also the least precise tests
you can write when they fail they give
you the least amount of information
about which component is responsible for
the failure but if you do write them try
to follow the patterns we give you in
this talk yeah I mean they're a fairly
blunt instrument so the patterns that
are going to give you in this talk and
they fall into sort of three broad
categories the first problem that you're
going to encounter is social problems
challenges that you as a team consult
classic examples of social challenges
are things like I don't want to write
tests it's not my responsibility to
write tests I'd love to write tests but
I can't it's really difficult you know
and testing is hard let's go shopping
things like that okay excellent and the
technical challenges we've divided into
the ones we believe you can solve given
the right patterns these include
problems like our tests are too flaky or
our testing code is a mess and then
there's technical challenges that
indicate clear shortcomings in the
front-end testing tools themselves we
hear complaints sometimes like this
click event isn't this click event isn't
doesn't seem to be actually clicking the
way a user might in this one scenario or
I'm taking this action it works fine
across most browsers but it behaves
slightly differently in ie6 and we're
trying to iron out all those problems
and we'll be telling about the ongoing
work we're doing to do that so let's
start with the social challenges since
we put it first so these are tips and
advice on how to sort of knit your team
together get them working effectively
and to address some of those problems to
do with you know it's not my
responsibility I don't really want to be
doing this and things like that
first question who's responsible for
testing anyone when I shout out a couple
of suggestions about who should be doing
all the testing on the product the QA
team should they be doing all the
testing so I'm getting shaking of the
head
QA team not all the testing the dev
should they be doing all the testing
well our answer is view and by that we
mean we do mean everyone the entire team
has to be involved in this process in
particular it cannot be simply a QA our
responsibility engineers have to play an
integral role they should be writing
many of the tests themselves and
contributing to the common test
utilities if they don't you can wind up
in situations where the QA team can feel
somewhat disempowered and unable to
delve deep into the tests to find out
the issues that may be going on with
test failures or test flakiness and they
may not have the insight to figure out
not only identified these issues but to
figure out how the application could be
made more testable so sort of one of the
things actually before I move on story
there is a team that I worked with
recently had the pleasure of working
with recently who were being asked to
write end-to-end tests and they were
going it's not my job to write into
intestine or interested in writing end
to end tests I've got features to write
and and it's continued for a while and
what was happening was their releases
we're becoming slower to release because
more manual testing had to be done and
the quality of the product was dropping
and so the test manager on the project
turned around to the team and said when
we do a release if you were owning a
feature that we're releasing you have to
come into the office and you have to be
responsible for proving to me that the
feature works and by the way we may be
releasing on a Saturday and a team when
yet there was a mutiny basically they
were deeply deeply unhappy until the
test manager turned around when of
course that verification that proof
could be automated if you wrote an
end-to-end test to show that your
product that your feature works then
then that will be okay
sure enough the number of tests that
they had sort of skyrocketed almost
overnight as everyone realized that
Saturdays were a precious commodity that
they didn't want to waste I thought
there's a very nice way of sort of
engineering sort of the the social
aspects of the team and making people
realize that sort of that the
responsibility of testing the
application is on the whole team
um oi Scout rule has anyone here heard
of Uncle Bob
yeah and it's in the 97 things
programmers should know but he sort of
mentions the Boy Scout rule and the Boy
Scout rule if you're a scout is to leave
the campsite as clean or cleaner then
when you arrived in code it's like go
through your code clean things up and
leave the code base cleaner than it was
when you arrived and if you're an agile
fan if you're a fan of XP this is the
equivalent of sort of going in noticing
a broken window and fixing it so
cleaning things up as you go along and
taking some sort of shared ownership for
this codebase thing that you all own and
have to live in and spend months and
months and years in another important
thing to keep in mind is that tests
really only have value when they're
trusted and with such large front-end
tests it's can be easy to lose trust if
you have a test and it's pass or fail
status is not trusted you really don't
have a test at all and in fact you have
something worse because one untested
untrusted test can cast doubt or
distrust over an entire test suite so if
you find yourself in a position where
can you're continually refining a test
to remove brittleness and you can still
you still unable to reach the state
where it's trusted you're often just
better off disabling it deleting it
getting rid of it so that it doesn't
cast doubt over the entire suite of
course one of the reasons that people
lose trust in their tests is because
they're flaky they're unstable and there
are technical challenges that you need
to be addressing on your project
fortunately as well as the internet sock
which is a wonderful invention and very
useful on long flights we've got some
patterns for you to live by the first
thing that we're going to suggest is
end-to-end tests tend to be extremely
slow
they take a long long time to run and
nobody wants to sit there and wait while
all of your hundreds of test runs in
Syria so you want to be able to run the
tests in parallel you want to run
multiple tests at the same time that has
a number of consequences the first thing
is that when you're running a test on
your own and it's a single test you can
you can make assertions like make sure
there are no accounts start the thing
start the test at the end of the test
make sure there's one account present
you can't do that when you're expecting
tests to run in parallel
instead test and and verify for changes
in the system that you expect so rather
than saying make sure that the number of
accounts has gone up by one instead say
make sure that this particular account
is present because that's the one I
created that means if if three accounts
were created five were deleted while the
test was running you can verify that the
test is passed and you've reduced some
of the brittleness in your test case
which is sort of one of the major causes
that people have of sort of experiencing
problems and and and flakiness another
cause of brittleness is non-determinism
in the web application most web
applications have some degree of
non-determinism and this can cause
headaches when you're trying to test it
a real-life example that i've had to
deal with let's say you're testing a
Google search result page in particular
you you want to test the case where
there's a single page of search results
well how do you go about doing that well
through trial and error you can try to
come up with a query that produces a
single page of search results and that
might supplies for your test today
well of course tomorrow the index may
have grown and all of a sudden that
query is producing two pages of search
results and so you can every so often go
back and change the test to adjust for
the non-determinism the web application
but the better solution is to build in
hooks into the application to eliminate
the non determinism and make it
deterministic so one of the things we
did on web search is build a framework
where you can save a set of search
results to a file effectively and have
the test recall that set of search
results enforce that set of search
results when it does a query to
eliminate the non determinism
another example is with CAPTCHA
caPSURE being one of those little
quizzes you fill out to prove you're
human like the distorted image of
characters and you type in the correct
character stylize all the time so you
may have a login process that has a
CAPTCHA in the middle of it and so how
do you go about testing that it's it's
not feasible to write a test that fills
in an arbitrary capture if you do you
probably have a Turing Award coming to
you
so what's necessary is building some
sort of hook into the application that
maybe forces a predefined caption that
your test knows the answer to so
eliminating the non determinism with
with flags like that for testing is good
idea waiting for state change this is
another pattern for eliminating
brittleness and tests in in the olden
days or not not too long ago it used to
be sufficient to wait for a page to load
before interacting with elements on the
page with modern apps and Ajax apps
where so much is happening
asynchronously and so much of the page
is changing without any full page load
that's no longer the case before you
interact with an element you should
really make sure that that element is in
a correct State in assert that it's in
the correct State before interacting
with it and have the test fail right
then and then in there if it's not of
course you don't know exactly when it's
going to be in a correct state so you
typically have to wait for that to be
the case and there's both right ways and
wrong ways of waiting the wrong way of
waiting is too hard code in sleeps with
the you know fixed sleep values into the
test so you know sleep for one second
and then assert that that that element
has shown on the page for example if you
do that you're building in sort of
fundamental flakiness into the test of
course you could increase that sleep to
some arbitrarily large value and then
you've what you've done is you've
eliminated the flakiness but you've made
your entire test suite really slow so
the real solution there is some sort of
busy waiting will you check the
condition if it's true you continue on
if it's not you go back to sleep for a
small amount of time and you eventually
timeout now of course if you litter your
code with all these busy waiting loops
it can become quite a mess so it's
important to make use of the implicit
waiting function
that the front-end testing tools make
available to you it they often have a
kind of kind of wait for condition type
function where you pass in an arbitrary
condition and it will busy wait for that
condition to be true
now these are tips for the test writer
but there's also things that can be done
on the application side to make it
easier to wait for elements to be in the
correct State one thing that can be done
is to make sure that the UI changes
state to reflect that elements are now
in a state where they can be interacted
with so for example if you have a text
box you're trying to type into and
you're and you need to wait for that
text box to let me give you a different
example let's say you have a link and
you need to wait for an onclick handler
to be attached to the link it's probably
a good idea to change the UI state once
that onclick handler has been attached
both for your user but for the testing
as well so maybe you don't show the link
until the handler has been attached or
maybe you show it greyed out or maybe
you show some sort of loading symbol in
the meantime and the other thing that
can happen is you can do is to put hooks
in the application for example exposing
JavaScript variables it could be as
simple as a boolean flag that you call
ready and you flip ready to true once
the application is is is ready in the
elements are able to be interacted with
yeah I mean so obviously I know selenium
and webdriver very well webdriver is we
recently added implicit weights so you
can just sort of wait for the presence
of an element and you can make the
driver do that for you it makes the test
really easy to read and keep some nice
and clean both webdriver and selenium
have a weight interface or class that
allows you to do that I know that other
frameworks such as water also support
that sort of similar level of
functionality which is kind of useful
hey this is another one for you all
right can I see some ideas so this this
slide is about separating the importance
of separating the logical page structure
of the page from its presentation it's a
common design principle that we all know
about and has other benefits but it also
has has been a
it's to testing as well in particular if
you make tradition is on your web
elements in particular though the web
elements that users are expected to
interact with then those elements are
much it's much easier to locate them
efficiently and they're more robust
identifying element is more robust to
changes in the code yeah I mean one of
the interesting things that I see with
people is they go they use they use the
same ID in multiple places on the page
and they go well that didn't work an ID
really should be unique I mean that's
how it's defined in the spec and that's
what you ought to be doing and so some
teams go to the other extreme and they
generate their IDs randomly using a
secret that only the the application
knows in their tests don't know and I go
well I don't know what the ID is going
to be it's not worth putting your ID on
if you can't do that because you don't
know what it is the sort of key for
generating the IDs needs to be a shared
secret so either use clear names that
that you know are going to be there or
if you're generating things generate the
IDS with a sort of regular pattern and
maybe putting like primary keys or a
numeric index in that set to help make
things easy for heaven's sake don't
generate them randomly it's a really bad
idea
of course sort of all this IDs and stuff
like that is all well and good and I
think vivexx talk showed us that the
problem that we have is people are very
key the raw API of your test tool is a
daunting thing when you're trying to
engage the intent of a test I think we
can all agree that so how do we hide
that daunting API and make the intent
shine through so there's someone who
looks at your tests can go I know what
that's doing obviously this has been
mentioned already today page objects are
a very useful pattern for doing that I
was thinking them as being like janus
like objects you know Janus the roman
god with two heads sir January's named
after him looks both ways sort of
looking one way he introspect too deeply
into the HTML he knows the structure of
the page he knows how everything's
hooked together in the understands how
to do you know find a particular element
looking the other way that he presents a
services that the page offers to you
you know in in perfects example there is
sort of the accounts page had the
ability to transfer funds and create
accounts and and do all sorts of things
a login pages is another example sort of
looking one way it knows who username
and password field looking the other way
it offers the service of being able to
log in one of the nice things with page
objects and one on patterns which which
we always encourage people to follow is
that when you do navigation you encode
that as a return value
so maybe classic example let's imagine
you you're on the Gmail page and we've
got like a page object the models Gmail
and you're in the inbox and you click on
the compose button that should take you
to the compose window the compose
message page by linking this stuff
together we get to model the the flow of
control through the application if we
change the flow of control through the
application we change the return values
of the methods but changing the return
values of the methods I test don't even
compile like that's the quickest
feedback loop you can get you know
so once you've fixed the the compilation
step then you've got a reasonable
confidence that your application is
going to work but pager objects are a
bit like low-level right you can model
components on a page and you can wrap
them together taking a step back you
could wire up a series of page objects
to model of workflow so for example if
you're creating testing ads products
maybe you've got a workflow that sort of
logs on as an admin user creates a new
account and then prepares a series of
test data and then continues and you
could model that using page objects but
that would be really really really
painful if you had to do it every time
UI is phenomenally slow compared to some
of the other mechanisms there at event
that are available to you sorry I'll
just run over my words but your your
end-to-end tests don't need to be
entirely through the UI you've probably
got access to the backend systems in one
way or another so maybe sort of you will
have a test that that verifies that you
can create the account data through
through the UI but in later tests you
replace that workflow with a separate
implementation they're just sort of post
the correct values in the in the right
place in the database and and maybe sort
of shove something into the
directory and away you go super super
fast
Slim's down the the time that the test
takes and if you're really worried about
it model the workflows as interfaces in
language such as Java and then have
multiple implementations that you can
inject depending on how exciting and how
time pressed your feeling that's kind of
nice the other thing you can do is at
the other end of the test you can reach
into the data stores and you can verify
that the data you expect to be there is
actually there rather than going to a
results page or whatever it is that
takes you know a significant amount of
time too late like you want your
end-to-end test to run as fast as
humanly possible running them in
parallel helps doing less work also
helps in it you really I mean this is
another example of why it's so important
to have engineers in the loop and for it
to not just be a QA function to be able
to know how to do that to interact in
tests not through the UI requires some
sort of insight into the application
that really only engineers would be able
to have great so you've got all these
tests and they run super first one of
the sort of things that's quite painful
is deploying to a production environment
even if you can't if you can get access
to it so what you want to be able to do
is you want to be able to take your
single suite of tests and as a developer
while you're working on a particular
feature a story you want to have like a
light in memory version of it that super
faster startup that you can quickly
compile in and check that your
modifications are working as a member
that the QA team you may want to deploy
to the UAT environment the user
acceptance testing environment and just
make sure that that the tests continue
to pass and then when you deploy the
application to production it would be
really nice if you could take that same
suite of tests or a subset and run them
up against it so there's a few things
that fall out of this the first one is
you really shouldn't be hard coding URLs
directly into your tests that's going to
cause a lot of pain another thing that
you ought to be doing is and a feature a
thing that you see quite often is people
will go I've put IDs in to make testing
easy I'm going to strip them out when
I'm going to production and going well
why you stripping it out
and sometimes we'll go it's for security
hate it break it to you but the botnets
and Russia that's not going to stop them
for very long it's just going to make it
harder for you to verify that your
application is working the way it should
another common complaint that people
have is you know are the IDS blowed out
my page and I need every single
millisecond of latency well if that's
the case try removing dead white space
that isn't necessary and won't be
rendered as multiple spaces try gzip
encoding and try doing other mechanisms
to make your page smaller rather than
removing a really useful hook for
verifying that your application actually
worked within Google some of the advice
we give teams is to make use of juice
Berry has everyone heard of a product
called juice it's it's about half the
room it's a inversion of control
container basically you you say I need
one of these and the container is
responsible for instantiating one and
giving it to you which is kind of nice
if you make use the juice berry it's
easy to swap out the environment they're
testing against so maybe in one
environment you know that the the URL
for the server is localhost no no that
one it's UAT
my company comm whatever it is but
that's a really useful tool for
abstracting away sort of the differences
behind the different environments you're
going to be running these tests against
of course when you're running these
tests at different scales surely just
carry on yeah when you're running the
tests in different scales data becomes
an interesting thing so let's imagine
you're doing a banking app or actually
you're doing a car resale app like Auto
Trader you probably want to verify you
want to have a test where there's a
thing for sale for 500 pounds and you
want to make an offer for 400 million in
the in the lightweight environment
setting up that data is super super easy
in the heavyweight production
environment setting up data you probably
need to have a car so one of the things
that I haven't seen many teams do but
when they do it's really effective is to
verify the shape of the data that you
need so you say to the test I want a car
that is worth 500 pounds and in the
production environment it goes
found one for you here and gives you a
reference to it in the lightweight
environment saying I need a car with
it's worth five hundred pounds well
actually go and insert that data into
the database for you the assertions on
the shape of the data create the data
for you in the lightweight tests and
they find it in the heavy weight tests
and so you've got all that data and
that's brilliant one of the other
problems that we see when we run tests
in parallel is that people forget the
test run in parallel so they'll probably
use the same you have one of the common
problems you see is people reusing user
accounts you know you've got one user
account you've got one admin account and
yet you've got three tests running as
admin and suddenly all sorts of
craziness is happening in your UI and
you have absolutely no idea what's going
on and the tests are really hard to fix
because when you run them on their own
they work and you know when you run them
in parallel sometimes they work and
sometimes they're a bit flaky and it's
really odd the advice we give to teams
is to lock these shared resources so
maybe two tests start that need the
admin account they both go to the to the
to the service
I need the admin account one of them
gets it and and the the service locks
that and when they return the user
account the second test is given it so
they're serialized on the under shared
resources that will make your tests a
lot more stable obviously having more
than one admin account would also help
more stuff yeah carry on um so sort of
that's a that sort of advice for test
writers right at the beginning of the
talk we said to people you know don't
don't write end-to-end tests they're
slow they're flaky they're not very good
they aren't going to bring your heart a
campaign how do how do how do we avoid
racing these things I mean it's simply
unavoidable isn't it well the certain
number of them are but what one of the
patterns that you can use particularly
in a modern web application is the
model-view-presenter pattern MVP which
is a variant of Model View controller
and message buses MVP is is similar to
Model View controller you've got these
three sort of cooperating entities
unlike MVC the
action between the model and the view is
broken so all access to the view from
the model is mediated by the presenter
and whenever the view needs data from
the model it also goes through the
presenter and this allows you to isolate
your changes it's a very common pattern
that you see on a plication that are
using the Google web toolkit quick
message buses are another mechanism for
communicating so in a test what you want
to do is you just want to make sure that
that when this thing finishes it fires a
correct event and you don't really want
to wire up all the listeners you don't
really want to know that everything else
is done so you want some D couple things
as much as possible message buses are a
really good way of doing this if you're
interested and you want to learn a lot
more about it Rea Ryan at Google i/o in
2008 gave a really good talk on on
exactly this sort of stuff on writing
scalable great applications a lot of the
ideas he covers aren't specific to great
and so I recommend you go and have a
have a lot to that if you've got a spare
hour so we've talked a lot about what
you can do differently and now we're
going to talk about some of the problems
we're trying to it solve so first of all
let's say you decide to do front and
testing and you you're trying to decide
on a front-end testing tool to use well
that decision isn't very easy if you
look in the open-source world there are
some different solutions to choose from
internal to Google that question is
actually a lot more daunting we've had
kind of a proliferation of front-end
testing tools over the years and when we
looked across these tools we've seen
that a lot of them are trying to do more
or less the same thing they're trying to
load a page in a browser they're trying
to assert that something is shown on the
page that some text is present or
they're trying to click or type etc so
there's a lot of code duplication a lot
of duplicate effort and the way we're
implementing this is by looking across
the all the front-end testing tools we
have in trying to pick out the best
practices and best implementations of
each to really form a sort of
best-in-class
suite of implementations here these
atoms have already begun to be
integrated into selenium 2 and so
they're in the they're being built in
the open
source world in there in the som two
tree and so the moral of this story is
sort of if you have the urge to write
you're yet another front-end testing
tool first don't but if you really have
to please try to at least not reinvent
this wheel and reuse these atoms and
improve the atoms and send us patches
etc yeah
writing these libraries in JavaScript is
sort of incredibly tempting yeah you
know element has element docked focus I
think I can focus on an element that
should be really easy you know some of
them have got clique that can use be
used to simulate it click you know it's
so tempting to sort of do this stuff
yourself but then you start running into
the browser quirks and the differences
and we recently checked in a browser
automation atom to to focus an element
and it runs to about twenty or thirty
lines of code it's it's a not
insignificant amount of effort to make
sure that blur and focus actually do
blur and focus it's a terrifying
terrifying thought as Greg said these
are available as part of the selenium to
tree which leads us to the next slide
and we're working hard on improving sort
of the tools that we use webdriver and
selenium and part of selenium to effort
the atoms are there one of the
interesting things that sort of starting
to occur in the industry is people are
realizing that doing browser automation
is a really really difficult thing to do
it is quite literally a pain in the ass
maybe because you sit there for hours
going not working not working works in
that browser it's not working in ie6
though never mind you know it's it's a
difficult thing to do so one of the
things that we're starting to see is
some of the frameworks are coalescing on
top of using webdriver as sort of a
mechanism for controlling a browser and
then Brett petticord the water project
lead sort of described it as innovating
in the API space they're taking the sort
of raw tools and they're building far
more sophisticated or different api's
that match the requirements and needs of
different audiences which i think is is
super super cool and coming from the
other direction we've got companies like
opera who
Austrian as the they're working on an
opera driver sort of providing these
sort of an implementation of these api's
and the sort of meeting of the two is
kind of fascinating and a very exciting
place to be so it leads us into the
future
I'm going to talk about the good stuff
and then Greg gets to play bad cop and
talk about the bad stuff because it's
not all roses I'm afraid as I said more
and more of the frameworks are starting
to sort of coalesce on top of webdriver
which is extremely cool and I'm very
happy to have have webdriver be turned
into a building block for someone who's
going to come up with an awesome API
that's fantastic we're working to try
and make webdriver be exposed from
various products within Google we're
working with the chrome team to make
sure that that's compatible and works
well with webdriver working with the
Android team for exactly same thing in
fact the person who's working doing the
bulk of the work and the Android work is
here right now if you run into Dounia
later shake her hand she's doing great
work one of the other things that sort
of is looming on the horizon is a
growing acceptance that accessibility is
an important part of a modern operating
system and a modern browser this gives
us a really nice hook Apple have
recently released a framework called UI
automation which runs on the iPhone and
the iPad and allows you to sort of
introspect into the doll into the whole
of the phone actually and do as a bunch
of interesting things
Microsoft we've net 3 released a library
also called UI automation which builds
on top of their accessibility API and
provides our like a nice c-sharp ish
interface thought works have released
two testing frameworks based on the.net
version and white which lives on code
flex CodePlex
and wit flash which lives on Google code
and the latter by Liz Keo who's also
been involved with behavior driven
development so sort of the next
generation of testing tools is probably
going to somehow make use of
accessibility API it's like these things
are becoming more and more prevalent
they're becoming more and more useful
and powerful and more and more devices
are exposing these things the nice thing
is that by making an app testable via
the app the accessibility API you also
make the app available to any disabled
user now the Internet is millions and
millions of people only a small
percentage of them are actually disabled
or unable to use like a mouse or a
screen but given the numbers that still
a vast number of people and we really
should be looking after them um so
that's probably what's going to happen
in the future
well the key challenge we face down the
road is that web applications are
becoming increasingly complex and
involving more and more technologies we
already have html5 being supported by
some modern browsers and we're seeing
integrations of non HTML components like
flash and Silverlight and air into the
web app and and that's really you know
in that area the increasing complexity
of web applications is the main
challenge going forward I think sort of
integration of Flash and flex and stuff
like that and Silverlight is it always
used to be fairly brutal it was either
all flash or all HTML and nowadays we're
sort of seeing nicely blended approaches
things like Google Analytics have have
like charts with time lines on and those
timelines are generally done in flash
but some of the other charts are
rendered images and things like that
file upload yeah file uploads that's
that's a terrifyingly complex thing to
do I think Gmail supports file uploads
by the normal file upload button you can
drag and drop from the desktop or I
don't know maybe that's possible you
could certainly do that in wave and also
there's sort of flash uploaders that are
available so there's like three ways of
uploading content and you probably want
to test all of them so api's and things
that need to be developed for that now
it took us ten years to do that for a
simple HTML I expect there to be a lot
of churn in iterations going on as to
sort of the brave new world at html5
engulfs us completely okay I think we've
got to the question stage I think that
because there's a big slide saying any
questions so are there any questions hey
is that his idea there basically what
I'm looking for is the flash objects
flash objects yeah I suppose if you have
some moving text user out so
there's great vision exit walk on so
that's basically a question of like how
can you use yes yeah okay so one of the
interesting things that that we're
seeing is that no single tool can meet
every single need it seems like a really
obvious thing to say but it needs to be
said sometimes because you know we've
got a golden hammer and by God we're
going to hit everything that looks nail
like including our own feet and you know
it's gonna be fun maybe there should be
a golden gun or a silver bullet I don't
know and the point is however that we're
starting to see libraries interoperate a
lot better and the classic example is
selenium and webdriver there's a project
called flex monkey or flex pilot there
are two two projects that sort of play
nicely and you can use them in
conjunction with selenium so you've got
the sort of blended approach at the
other end of the scale people sort of go
oh I want to have far more information
about the HTTP headers and I want to
have a look at the traffic and I want
timing information and stuff like that
and that's ideally solved by putting a
proxy in the middle that measures this
stuff for you in them you can query the
proxy programmatically that's starting
to come browser mob company set up by
country black body have a project proxy
docked browser mob com
that's a open source proxy container
that provides and has that information
there's also the web timings API which
is starting to be supported in the major
browsers which gives you far more
precise timing then Hey look the onload
event fired and my framework happened to
catch it at some point so I think we're
going to see a sort of blended approach
of tooling does answer the question yes
yes brilliant what more question is like
the dynamic iPod link dynamic hyperlink
concept dynamic iconic yes when you
click on like for example if you have
times page every day we would be finding
some different contents on the hyperlink
right so how the click options just
works on that so one of the things that
we've been working with on on webdriver
in particular is this sort of concept we
call native events
so what would happen if a user clicks on
that link is the question we always ask
ourselves so that the browser automation
atoms have an implementation click that
does as good a job as we can do but
native events that have pushed that up a
level what we do is we identify where in
the window that particular element that
we're clicking on is and then we send
os-level
events directly to to that to those
coordinates I'm simulating a click at
the OS level and then we don't need to
know what order events fire and whether
or not a particular key code is set on
our we let the browser handle or things
that need to do by doing that we've
decoupled ourselves slightly from the
browser so your tests become a little
more asynchronous so that's slide about
waiting for things to happen becomes
really important like wait for the next
element you want to interact with to be
in the state it needs to be in because
otherwise your tests are going to
display a certain amount of brittleness
and flakiness cool are there any other
questions from around the room just
think about IDs yeah
based on experience I will be doing my
testing everything and you found that
you know some the input IDs
and when we erase it I say you know it's
still okay because you can still use
them by name and get you know things
running that way so how do you approach
that in that sense so the nice thing
that so do you want answer this Greg or
shall I okay cool
the nice thing with IDs is a in many any
many browsers the lookup time is a
linear or constant even you can find the
elements very quickly the exception are
older versions of ie where we see really
weird timing behavior so if you have
lots and lots of different IDs it slows
down significantly
so like IDs are the fastest and we
recommend that just because it's so
quick finding elements by name that's
actually pretty quick as well
particularly if you know that a name is
unique on a page because the browser has
a mechanism for providing that
information the next quickest way of
finding elements is via CSS selectors so
particularly the modern browsers have
native implementations that are
blazingly fast for locating elements via
CSS the slowest way and and the most
brittle and way that you really
you really really shouldn't be using
even though it looks really nice and you
really shouldn't be using it is for
that's part did I make it clear you
really shouldn't be using extra parts
they're incredibly brittle I know they
can be made to work you'll just have a
lot of pain if you try it the reason why
XPath is slow is because particularly ie
doesn't have a native XPath engine and
so we need to write that XPath engine
and we import one written in JavaScript
sadly the JavaScript engine in older
versions of ie is the slowest one of the
available browsers and so we're doing a
particularly large look-up on a complex
Dom using a slow JavaScript engine and
people go well it doesn't perform very
well the other thing as well is that
people sort of tend to get really really
sophisticated with their experts you
sort of see dot contains and class names
and they go up the descendant tree and
the ancestor tree and it's all
tremendously complex and that's the sort
of thing that just identifies
differences in different XPath engines
so you make a inconsistent results so
IDs names CSS selectors they're there
the daddy is there anyone else I'm
really interested in hearing what you
didn't say about the impact of html5 at
the end on where you think the
automation tools and drivers will need
to go do you want to have a sponsor in
this Craig or shall I continue banging
away speaking right now I mean I don't
have too much to say here other than its
it's merely an error where I
I haven't investigated yet there are new
there are new dawn elements or new
actions you can expect the user to take
and whether or not we can simulate those
events with fidelity is the open
question and in the challenge that we
need to solve I don't know if you have a
yes I mean the thing that terrifies me
the most is the canvas element it's
saying it's already seeing pretty heavy
adoption and the problem is that people
are doing a lot of their own work in the
canvas element and as far as automation
tools that
and it's just a rectangle on the screen
we just have no mechanisms for
introspecting into it I think what we're
going to need to do if we're going to
automate that successfully is have help
from the development teams like people
need to be aware that it's not enough
just to make fancy things happen on that
you need to provide hooks to allow an
automation tool to actually get in there
and figure out what's going on this is
one of the reasons why I think sort of
accessibility is going to be important I
think sort of anyone who's doing an app
that uses a lot of the canvas element
should be making a real effort to make
sure it's still accessible in the same
way that people doing complex app
websites using flash should be trying to
make it accessible and those hooks are
going to be the hooks that we're going
to have to take advantage of in order to
be truly effective as sort of browser
automation vendors and and people
working in that space obviously videos a
fascinating area but I don't think
people test in quite the same way just
because of the visual nature of it tends
to require a person to be involved does
that answer the question by the way well
sort of I mean I think all the things
you alluded to and flash that are
difficult will increase 10x perhaps I'm
vaguely optimistic for the future I
think we've had so many years just
getting people used to the fact that
they can do test-driven development of
their application like selenium has been
around for what six seven years now
webdriver has been around for about four
you know other tools that have been
around for a similar like lifetimes if
you have something if you've never had
something and someone takes it away you
don't notice like but now that people
are used to having this ability if we
suddenly took it away there's going to
be upset and hurt like there's no way
that I'd want to work on a project that
deliberately makes itself untestable so
I'm feeling vaguely optimistic but I
think there are some engineering
challenges that we're going to have to
meet in order to effectively solve these
problems but it's going to be
interesting and it has a potential to be
horrific
there we go that's a dystopic view it's
gonna be horrible hi this is Canal yeah
I wanted to know the two portions which
were not really discussed in this
presentation one was regarding
localization so are any elements or
anything being done in this in this
initiative or certain like how you shown
what controllability or observability
being implemented or anything being done
for that aspect and the second part
again is that browser compatibility as
multiple browsers coming in we are
running multiple attrition the same
tests so if anything is being done or
being implemented for the same I can
take a stab at the localization part of
the question one of the things we
mentioned in the in the talk was the
importance of separating the structure
of the page from its presentation and
sometimes in the tests we see if people
lack IDs or lack names or even CSS
selectors to identify an element they'll
start identifying the element by the
actual text that it shows you know click
on the button that says submit now of
course that is not going to localize and
it'll be called something else in some
other language and so just a emphasize
the importance of separating the
structure the page from presentation
will help with the localization and one
of the other patterns we mentioned was
the you know page object pattern and
abstracting these common tests utilities
into into into objects and classes of
the tests share so the extent that we
can factor out the work of the
internationalization into page objects
and other utilities that the test reuse
will will help there so one of the
funniest problems that I've heard of for
a long time a team was was
internationalizing their application and
their IDs were internationalized as well
so their tests ran flawlessly in English
but broke horribly when done in French
or Swedish or whatever I was like it
took me a while to figure out what was
going on there
and then I had a choir word with the
moment you don't need to
internationalize the IDs
it'll be okay so some of the other stuff
that's happening particularly around
localization people are building tools
on top of these basic building blocks
you know there's there's a at least
so Michael Tam last year ajit act gave a
great presentation around sort of
detecting visual bugs and issues using
webdriver and that's very useful for his
work as he translates things as his site
goes from English into German I'm
Germans a far more verbose language than
English particularly when written and so
sort of it's quite common for buttons to
overlap parts of the UI they're not so
there's things like that it would also
be possible to write tools to detect
right-to-left issues so if you're going
into an Arabic or a you know any any
other Israeli right to left language
then you know you might be able to
detect those automatically but the the
base tools are there now and they can
provide you with a lot of information
that it's it's up to the teams who are
trying to identify these issues to sort
of start building the more sophisticated
tools on top of it and that's we've
become more familiar in ofa with what it
is that we're attempting to do there's
going to be strands of commonality that
are going to appear and when they appear
then we're going to see more general
tools becoming available does that help
brilliant so Simon probably I don't know
whether this is the right forum to ask
this question see one of the common
challenges with selenium probably with
many open sources if I'm right is
towards yes webdriver is gonna address
the configuration problems of all these
web browsers but even the environment in
which you work say for example Java say
for example with what is the version of
selenium what you could work with some
version of Java applies all these
challenges which are coming in one if I
have to compare it with another
open-source project like Bugzilla or
something like that there's a huge
development forum which supports this
whole initiative and
you know at least there is a big forum
to test it out and tell and say like you
know manage these problems if I have to
take the take selenium to some extent
even though everyone talked about it
everyone use it extensively but for some
reason I don't see a great forum which
would solve these problems there are big
forums to ask questions very small for
them to like know solve this is there
any thoughts which happen from your side
or Google in terms of how we would
address this or like no because most of
the open sources are some other open
sources which doesn't fly very well even
though they had a great feature because
not having a great forum Russell so
considering that I know it it might be
not so technical but being a user of
selenium I just want to say this having
a much longer life then yeah that's the
perspective which I you know I asked for
me okay so I heard a question there more
about those sort of social dynamics of
an open-source project and how you
manage to support it so there's a number
of interesting things that you can do in
order to run sort of a vibrant
open-source project rather than one that
sort of moribund with selenium what
we've got is we've got a developer's
list where the people who are working on
the framework itself hang out and they
discuss issues like should this API be
doing this what about this things like
that that's an open list that anyone can
can join anyone can read anyone can post
- you know we're not fussy there's a
selenium uses list as well which is
hosted on Google Groups which is a great
forum for asking questions now the
volume of traffic on that is pretty high
but it there you know some of that some
of the core contributors do you monitor
that list and some of them occasionally
sort of swoop in and help where it's
appropriate we've got the selenium HQ
site which provides selenium HQ org
which provides the official
documentation we've there's a team of
volunteers who have spent a lot of
effort making sure that documentation
reads well is comprehensible providing
information that
people commonly need and you will
occasionally see exceptions being thrown
they're pointing toward from that from
the from the selenium project they're
pointing towards various areas of that
site to go you've run into a problem
we've documented what that problem is
and you can address it there there was
also a move a while ago for a selenium
stack exchange site so I would imagine
that would be a bit more focus than the
users list which is a bit of a
free-for-all and and would help further
help provide some of their information
and while that's being set up
I mean Stack Exchange itself is a good
place to go for help I know that various
members of the core team do hang out on
Stack Exchange and do answer some of the
questions so in answer to the question
how do you keep the project sort of
alive and vibrant I think the people who
are working on it need to be visible and
they need to be interacting with that
community and they need to be finding
out how people are using the tool so
they can keep on making sure it's fit
for purpose like it's so easy like Joel
Spolsky talks about software
architecture art astronauts astronauts
astronauts you know people who are so
far removed from the thing they're
trying to solve that they don't solve
anything you know it there's always a
danger of that but I think sort of
staying in touch with teams and watching
what people are doing in the problems
they're running into is a really good
way and making sure the project is a
good fit the project is a good fit it
becomes more popular and it's a it's a
virtuous circle the other thing is
providing a forum where we use this can
ask questions and help each other and we
provide that for on three three mailing
lists now obviously these advice this is
sort of the selenium example I can
imagine open-source projects doing
something very similar and they waters
got something extremely similar they
also have a regular podcast they sort of
discuss things that are going on in the
community that's a nice way of sort of
keeping people updated does that answer
the question
yeah we can talk afterward if you'd like
ring ank it is giving me the nod that
maybe I've talked for far too long and
hmm yeah I mean I'm lucky I'm probably
taller than Anka which is the only
reason why he doesn't do it thank you
all very much for your attention I know
thank you that we both appreciate it
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>