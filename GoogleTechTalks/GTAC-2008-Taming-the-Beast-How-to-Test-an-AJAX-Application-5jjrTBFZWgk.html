<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GTAC 2008: Taming the Beast - How to Test an AJAX Application | Coder Coacher - Coaching Coders</title><meta content="GTAC 2008: Taming the Beast - How to Test an AJAX Application - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>GTAC 2008: Taming the Beast - How to Test an AJAX Application</b></h2><h5 class="post__date">2008-11-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5jjrTBFZWgk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this presentation is about how to test a
check applications oh yeah one basic
thing about our presentations don't
bother you can always interrupt us with
questions but don't be surprised we aim
to end I mean to interrupt you with
plenty of questions as well so we're
trying to make it really interactive not
only between the two of us but hey half
of our presentation is you we don't we
wouldn't have enough slides to fill the
whole slot without you that's that's
basically Marcus's polite way of saying
don't sleep throughout the presentation
we're gonna have we're going to ask you
questions I thought you're going to play
me now that we don't have enough slides
but so so what's the difference why is
there a talk how to test Ajax
applications why isn't there a talk how
to test software I think there are books
about how to test software there are
probably not books about how to test a
check so what what's really the
difference so for me there is quite a
few difference that make it specifically
hard to test the HX applications so one
of them is I'm having some multiple
components I'm some running in the
clients I'm running somewhere in the
front end some in the back end they all
communicate with each other somehow but
it's very hard to get a grip on this
communication one of the reasons is that
execution is widely asynchronous so
there is many threads going on at the
same time callbacks from one thread to
the other which makes it absolutely hard
to predict client-server communication
if it is hard to predict communication
it's also hard to judge is this going
right or not it's hard to walk out the
component that acts like a server and
give stuff to the client when he expects
it then the other thing is my client is
usually running in a browser there are a
few big browsers out there I don't know
which one with my customer use each
browsers behaving slightly different or
though there are some better than others
we are having various locators locales
where our application will be run and at
the end it means if I want to capture
all of that in my tests I would end up
with many and very complex test
environments
we'd now physical machines of virtual
machines whatever so it's kind of
exploding so just a small example that
we used or that we will use for the rest
of our talk is we came up with a very
simple trivia quit application who knows
what with is okay that's roughly ten
percent come on so gritty you really you
know if you don't look video at the rest
of the ninety percent go to code google
com and look for the google web toolkit
it's a very interesting way to write a
check applications basically it offers
you a quite complete framework you can
write specify your application in nice
neat java code and then compile it down
to javascript for execution in the
browser I'm of course there are some
things that need improvement but I think
it's better than nothing I would rather
it virtus it then tell you not to do it
so for us important great application is
it important that you discreet nah it's
important that it's an AJAX application
so basically that is copy and paste it
from my web browser i'm having on the
left a kind of a tree control that
allows me to apply filters here i'm
having whatever it is chefs desks
engineers quite some mixture between
items and staff or whatever and on the
right obviously I have location product
stock so how many chefs do i have in
mountain view it 65 i could increase it
or decrease it probably by pushing these
buttons what else can i do here this
looks like i could apply filter /
location so i want only to the mountain
view attack let's go a wave is that the
minor says here show me i might probably
be able to add or remove something or to
collapse and expand it and what you
can't see here but believe me this in
the real application if i click on the
header i can actually change the sorting
order pretty awesome isn't it
that's our high-end application for you
so what kind of use cases could we think
up here that I mean it's a simple
straightforward application I think for
me there are three use cases so I'm
probably the most important one is to
increase or decrease the number of items
or persons that I'm having somewhere the
next one would be to apply or remove a
puter on this side and finally of course
I'm just curious how many chefs do I
have a mountain view so I trust want to
see that it's query now how should we
test that so this is interesting right
by the way few things notice Marcus's
choice of column name product for chefs
and engineers and those and those are
not real numbers so you mentioned test
which is which is exciting so you know
i'm jumping in because you know it's a
testing conference that's what we're
here so we need to test this application
right and marcus just walked us through
a few use cases that we can use to test
the application so this is the part
where i'm going to test your caffeine
content right now I need help so we want
to test this this great application what
are some of the test cases we can think
of be sure we are having three slides
full of examples and before you list it
all of them we are not going to go to
the next slide so yes
the other filter goes away excellent so
we have a set of test cases that are
based on filters adding removing and
collapsing them and seeing the effect on
the UI as well as what that results is
in terms of the products okay love that
we had you know that the talk in the
morning actually talk about something
very similar we're testers we love
putting negative numbers right so either
put it either make it MD or put a
negative or some kind of value that
doesn't make sense what happens is the
line just disappear it's a good test
case so I can you repeat that excellent
so to users different browsers one user
changes a value what happens to the
users you I in the first browser
floating-point numbers in fractions so
changing so setting a certain sort order
and then checking to see if adding and
removing filters effects that sorting
order okay we've got to keep going
because like Marcus said we have to
finish off those two slides that's a
very good test case if you put more
chefs than engineers what happens then
haha I can tell you what happens to the
Google stock okay so find out how many
numbers can actually fit in one of these
text boxes here and put in letters
instead I saw some hands go over there
so we have boundary conditions for each
of these values because there are
numbers and you can check either end
positive and negative and seeing the
effect on on the order about whether you
can increase more or less so visual
indication about the values in these
fields where if you make it zero does
the down arrow disappear or if it's a
really high number does the upper
disappear and vice versa excellent so a
very good test case would be sorting
sorting sorting by stock and then
modifying the value in one of the items
to be 0 such that the the column needs
to be sorted does it happen
automatically wow that's what I was
really looking for so set the stock will
have you for one of the fields to be a
javascript alert ok let's try someone
else yes change the font sure so using
the mouse you can change the font size
in your browser yes there you go sequel
one of our favorites huh ok copying and
pasting values and out of boxes back and
forth I mean who doesn't love doing that
in browsers right and seeing weird
errors and exceptions or at the back
there you go so drop JavaScript see what
happens
I'm sorry I didn't catch that Montilla
with a lot of Adam add-ons who doesn't
like that right of course i could get a
really heavily loaded browser and then
see what happens to your application I
saw at the end of the back there yes
different languages and locales very
good we're getting good now you guys are
actually getting warmed up here man this
is nice yes yes we heard that one yes
for the back okay so use W gets to post
nonsense values to the to the boxes
there do you think we're sort of covered
with our test cases oh we're doing
pretty bad yeah ok so we slept somewhere
to go no let's make a short pylons now
ok so how many pests case is do you have
touched the board show too many to count
them I know right so I really like the
the response I mean we got lots of
different workflows and scenarios that
we were covering I'd say you know let's
let's just take some number here do you
think we'd have 20 tests the sound about
right higher 30 40 that's a very good
question but let's get the number first
I just want to make sure firm from from
comfort level like we're trying to cover
this application with tests right want
to make sure it's done is hundred too
high say what several hundreds Wow ok so
we're gonna have a couple of hundred
tests well that's that's probably going
to be a lot of tests but ok there you go
that's our consensus it's a couple
hundred tests that's a pretty much tests
so I I guess some of them will be pretty
easy and pretty cool to automate I was
what kind of percentage do you think of
these several hundred can you automate
what do you think um you choose it so
something that's driving my client
obviously sell any amor webdriver or
it's almost close two hundred percent of
those tests there anything that cannot
be automated over here
those are some of them some of the more
difficult ones are turning off
javascript in the browser maybe even
languages depending on how your
browser's are configured so it seems
like from a consensus we have quite a
few like I would see in the order of
hundreds of tests they're actually going
to be automated intent is using some
magic free month that we have that is
cool like I'm really impressed you know
so there are let us assume your day okay
our software engineer in test our
automation engineer okay so how long did
it take you until I until you are done
with them okay so I now I'm trying to
guess them it a little bit we have lots
of test cases that we got to cover they
have to be all automated pretty much one
hundred percent automated here I'm
guessing you're going to have some
amount of setup so the the freight we're
gonna have to build some kind of
framework that's going to run this we're
going to have this framework do setup of
the environment bring up the database
bring up the system then bring up our
automated framework everything is going
to test end-to-end I'm guessing and
correct me if I'm wrong you guys I'd say
about a week's worth of work to write
the framework and build the tests good
does it sound right more sounds more
than that or less than that a month haha
I think I heard three months well I had
someone see three months okay that
sounds good so we have a proposal to
have a developers write the tests as
they're building the features so that
there's no time to actually write the
tests do we hear something else that's a
good point do we have performance
testing ok so I think this is something
that we wanted to do we should be
touching upon but I think we want to
focus at least on the functional side
which because that's definitely going to
be a different ball game of it so I
think that out going through a test plan
and now let me play the bat karte I'm
your boss I want to figure I want to
hear how long all right time do you need
I'm gonna commit on behalf of everyone
over here i'm going to say i think three
months is way too long because i want to
be really aggressive and get this done
in a month so that's the owner time i'm
going to take to actually author all
this stuff so it's all authored and done
okay i'm satisfied with that I'm
settling back I think you're overly
optimistic but hey that's a stretch
so on the next side now we are having
several hundreds of test cases run by
some improv automation tour how long we
have done around for your automation
sweet pea how long will it take for you
to test the product what do we think
minutes 15 minutes well it's it's it's
our choice we have to make it the best
possible right okay so however long our
longest test is but you know let's be
realistic here I mean we tried shooting
for a month which is aggressive let's
zoom in we can pull that off what's the
best time frame we can expect for these
tests to run in some sort of continuous
cycle 15 minutes just is does an hour
sound too much it sounds it sounds too
much for a cycle it's probably going to
be faster than that half an hour faster
than that 15 minutes I guess you should
be able to that was my next question
that's an interesting that's an
interesting point because all we talked
about his execution we didn't talk about
troubleshooting which is very
interesting so sorry not run so long
running concurrency test I think they
fall in the same bucket as the
performance test the loaded performance
tests we're trying to measure things in
the song there was one test case
actually that we accept it saying we
decrease it in one and we'll see what
happens in the browser that's it's it's
still a valid Deskis i mean i guess the
long-running part of it would would
extend into LNP side of things but short
concurrency is a factor so now again I
know my discussion I ever mine is gonna
push me for getting a number so I'm
going to commit yet another number and
I'm going to see 15 minutes is a
comfortable time I advise you these test
cases automated so thank you John I am
happy I'm we all have the figures you
told us on video so
now let let's go back so this we all
agree like if the applications we would
be working with would be that simple we
would have an easy life or no jobs no so
let's think about our real life
experience and I'm really curious person
I want to pull some stats from you so
how many of you are having like a few
hundred large tests that you have to
take care of that sounds that looks like
ten percent about ten percent um so the
rest have more or less rather how many
have more this is um let's not stick for
the for that question so for your
general application how many large tests
are really full system tests are you
owning I you're supposed to take care of
our are you supposed to run so let's
start at the bottom let us come in who
has who had non at all come on it's
gotta be someone okay so all of us are
testing professionals that that is good
so who has like more than 50 oh my god
so many people have less than 50 system
tests that's the Assumption we're making
that the rest of you guys have got less
than 50 tests which is pretty good okay
okay so who is isn't in there in the
hundreds we know already of those in the
hundreds who is let's say in the 500
plus range so I think it's probably half
of the people who were in the hundreds
so and who is in the top 1000 plus range
the same minus one big tests tests so so
it's about 5% i would say is at the 1000
i would say about ten percent is between
100,000 and the cert is more than 50
there that's about what i say so much
about the right distribution so out of
those people who own large test at all
how many of your tests are flaky where I
mean you execute them twice and once
they pass and once the face
so you have fun so who has any flaky
tests okay so more people who have test
applique test so pretty many of them how
often are you running your tests so
let's say who is running his tests every
hour at least every hour okay that's
about ten percent again at least let's
say on once per day I would say the
majority probably fifty percent who is
running them armed more less than daily
but let's say at least weekly few more
hands and who is running them less
frequently than weekly so a few people
are running them less frequently than
weekly but I think the majority is at
the daily test execution which is good
hey but very few of you actually run the
tests on an hourly basis there that's
another thing so time to feedback from
the test to the programmers might be
longer than we want it to be so how
complicated is it to run them sorry yeah
all of the smoke tests in 30 seconds and
then running the tests that relate to
the future you're working on and then
once an hour running the full regression
sweet what about that sure sure but that
is in principle my quest remotes and
hourly execution so if you run the
regressions read once an hour you are
still in the early execution so so I so
I think that isn't sorry for the short
interruption sir I think it is a very
good question and you have to write to
interrupt us so I think there is value
to it but I think it is a symptom it is
a symptom of having a regression sweet
that takes far too long to execute once
I am going down that road and I'm having
that problem yeah sure thats fast smoke
test suite will help me but it's
probably still a state that I don't want
to get in voluntarily make sense cool
now that we already interrupted anyone
else yeah sure so the question is about
executing the test every time you have a
check in um yeah sure I mean you're
right so executing them more often than
your code base changes doesn't really
make sense I did implicitly assume that
there is a there are continuous there is
a continuous stream of checking your
writer that probably the quest is who
have you cooked given that there are so
many changes have that execution you're
real right that it's a good corner case
that you found further questions at that
point I guess not anything ok let's
continue our collection of statistics
I'm so how complicated is it to random
bear complicated is very hard to measure
subjective yeah who of you has a fully
automated execution system and never
ever needs to bother about test
execution at or they just run running in
the background you guys just look at
results that's it and what is good cool
it's a quarter about 25 billion percent
that's cool so who of you has at least
to push one button to trigger a test
execution so out of so that that's about
another 25 / and that button could be
telling someone on your team go run
these tests so out of those who have to
push at least one button who considers
it a major pain or a task that takes
some time to get your tests running one
there are two honest people in the
audience all the rest just want to get
through the slides pretty quickly yeah
so the other question is how hard is it
to troubleshoot and debug them and it's
very hard now to raise hands but let's
just say yes knows who of you considers
that getting a dis test is broken is
rather far away from the breakage is
fixed now half of the audience yeah I've
actually a little more than half as well
okay cool now how long does it take to
detect a bug that was introduced so that
goes with the how hard is
troubleshooting
so who of you is like time between bug
detection and but fixing let's say more
than a day that's a sizable number in
there yeah almost as a number the
visions again about about the same
number so who is in more than a day so
let's further dridown who is in more
than three days no so you found a bug in
the product you report that back how
long will it take until they develop a
says it's fixed so okay oh no sorry
probably i think i think the point was a
young you guys probably got it right the
first time in yeah yeah we're not
counting your developer productivity
over here so that's a different story
altogether what we are saying is the
time that the developer introduced the
bug into the code that is actually a
very interesting point of time yeah to
the point where you actually detected it
so how long dead was there that was the
question sorry so let us remind the
video and it'll prompt from the moment
when they develop I introduces the bug
into the code until the moment that your
test suite catches the back if it
catches it what's the average time spent
so is it like an hour or less let's
let's say the average time okay so I
think I think we can see there's a few
hands going up and I'm seeing answers
ranging from we don't know which is
sometimes valid to it's going to the
order of days a day probably even three
days before that actually happens so
that's a good point and I'll sort of
pitch in what I feel over here right
because the harder it is to actually
troubleshoot and detect why the test
field will probably tell you will
probably expand the time it takes to
actually identify when the bug was
introduced and
no absolutely all times that it takes
time that it takes for this is not the
frequency of test execution because it's
one thing to write a feature the next
thing is to write the test for that
feature then head attest to the
automation framework and then execute it
and then you might catch the bug which
is probably in the case that the Deaf
was writing the feature is writing the
test it's the same but if you have a
kind of an let's throw the finished
product over the wall and then at the
test it's a different thing absolutely
and that that's one part of the answer
which is which is I we don't know in
lots of cases we don't even know that
that dealt so but yeah sure absolutely
but that would kind of even increase the
time between introduction and catching
yeah you're absolutely right so I think
in short we're seeing it's a long time I
think really depends on the kind of test
again but it's not an easy task and it's
a long time so I think what that little
besides us getting a lot of insight and
how your company's work the other thing
that we gain from that little collection
of statistics is it looks like that
simple problem of testing an application
and atrix application which is really
simple somehow it brought us to a point
where we ask some question that at least
for me they leave an uneasy feeling I
just don't think that maybe really have
a good grip on that you know if my
regression sweet catches it at all or if
it is reported by the customers so it
takes probably a day or or more until
after somebody breaks my built it gets
fixed that's probably just problematic I
won't I don't want to use the word
unacceptable but
it's definitely something we will want
to fix so what can we do about that and
my suggestion is let's dig dig deeper
not only into the problem space of how
to test HX applications but let us dig
deeper into our applications themselves
so for a typical bit application the
reference architecture at least they're
the one that we see every time is your
having your grid client running in the
browser you are having somewhere on the
server side a servlet that basically
doesn't do much but serving the
JavaScript to the browser and afterwards
intercepting the RPC course that come
back from the client and then forwarding
it to some RPC implementation that one
uses some other mechanism so at Google
we tend to use protocol buffers the
outside world is not yet using protocol
buffers but is on the way to adapt it to
communicate with another RPC back end
usually these backends might serve
different front ends or more than one
front end and then that fronted by
itself is using our pc or jdbc or
whatever to discuss with some data
storage at google it is very often a big
table in the outside world mysql
database whatever you want so having to
look at all these boxes i'm wondering
many of the of the box that we've that
we often find and probably even some
that our previous tests would have
exposed i'm just thinking about that we
make a change in two different clients
what happens are probably bugs that are
happening here or here some are
happening only here but they don't
really need to leave that box question
is can't be just test each of these
things separately and won't we get more
insight from that so that's a Consuela
okay back up a second you're just
talking about unit tests aren't you yes
that's what sleeper sync yeah but then
no I don't so I like to think if I'm
thinking unit tests I'm thinking it not
so much I'm thinking it how big is my
test if I'm looking at my application
how many parts of the app am I actually
exercising in the test so if used a unit
test that's for me I'm having here one
class probably even only one method in
that class and I'm looking does that
method fulfill its contract with the
outside world I don't really care
whether it's using a database at all I
just want to know if I'm doing this
following that path am I getting the
result that I expected even work even
better I will try to get rid of all of
these dependencies to make the tests
cheaper and to make the execution faster
I want my depth to basically execute all
this more tests whenever they change a
single dot in the application that works
well if the test execute really fast I
won't get rid of death now most of the
tests that we've been talking about
before here they are large so you're
really having the full up running here
and you're making a use case that goes
from the client through the server
through the RPC implementation down to
the data store so really exercising the
full application that is good it gives
us a great insight but it also gives us
problems several hundred tests take us a
at least a month stretch core probably
more realistic two or three months to
implement execution ok we have passed
its fifteen minutes it's still far too
long to execute whenever I make a change
to the application so that that probably
also something i don't want too many of
them and i'm advocating this kind of
tests so i think there might be a
feature or a problem or part of
functionality in a certain layer in our
previous diagram usually the business
logic for instance might be in the RPC
implementation so if i want to test
business logic why should I bother to
have the UI why should I bother to have
to read a database I trust want to pass
the business logic okay so that makes
sense so we talked about large test
which is basically all that has to be
collected at the beginning we're not
talking about unit tests because those
are for individual components what we're
saying is we need to start testing these
things at levels and layers which sort
of falls in the medium test bucket
right that's the whole idea so if I'm
going back now to my previous arm grass
to my previous slide and I'm thinking of
many of the test cases we had before and
which one would you put for instance
here into the back end what kind of test
should be here what questions do you
want to ask the backhand any suggestions
sorry so we want to check the data
integrity can I make any cords to the
back end that basically leave my data
store in an inconsistent State
afterwards other questions ours greatest
this layer just that box there just for
just let us think about this layer yeah
that is a great point so what happens if
I'm sending an invalid request here is
their back and Trust hanging up or is it
giving me an error code sorry yes so
what happens if if I'm making a call
here and then I'm destroying this arrow
here did I understand it correct that is
hard to automate but what you what you
really could do is so you don't really
use the real big table so let's just use
a mock here and I tear that multi you
know you're going to get a question out
just don't answer it or what's happening
yeah absolutely and I think you know
fault the the whole concept of bringing
down layers and bring our connections
between layers is exactly the part the
part that you can do for these kind of
tests what are the tests we have here
and another probably harder to to
manipulating is what if that guy is
getting a malformed reply from here so
if for some reason the packet becomes
compromised on its way and it's covered
up when it reaches here so again this is
a mock fault injection becomes very easy
you have some other questions that you
want to ask it at layer
right yeah what happens if that ever
disappears remember we had someone who
tried a sequel injection attack at some
point so deleting tables is not
impossible yes okay can you sort of
elaborate on that
very good point absolutely we have any
further suggestions for that layer yeah
sorry low testing that is a very good
point so why should I go all that way
for Milo tests why should I even bother
to go this way for Milo tests if I'm
having hundred clients talking to a
front end and ten thousand clients
talking to the same back end where would
you put your load tests or what load
tests would you put in what place maybe
these are totally different kind of load
tests yeah
right yeah so validating business logic
and business rules i guess that layer so
if you look at the whole thing we've
mentioned now quite a few test cases and
let's put one of them out which was the
timeout test case how long do you think
is each of them taking you to execute
one minute any suggestions is that too
long to short but but I said let's take
the time out out so all the other test
cases so i think we are talking in the
millisecond sing here yeah so instead of
talking about seconds that we were
talking before in the full end-to-end
tests we are now talking about
milliseconds to execute it which
probably will have an impact on the
execution speed of my overall test suite
I think so John what do you think so i
think that sounds like quite an
improvement because we started off with
wanting to cover everything and then we
sort of narrowed down and said okay
let's look at this one layer but with
that one layer we're actually getting a
speed up okay that's i'm i'm starting to
get convinced that this is probably a
good approach what else do you have in
store oh well i think after talking
about the back end let's think about the
RPC implementation so can you think of
tests that you want to drive against the
RPC implementation sorry performance
testing performance testing very good
yeah functionally testing so what kind
of functional tests can be think of
validating all the business rules yeah
okay would we would we want to talk to
the real back end
probably we want to get rid of most of
our communication with the rear back end
so how can we do that any suggestions we
heard my mark yeah cool so the mocking
actually having mocking out an RPC call
is one of the easiest things that you
can ever do in your life believe me I
tried it so so that is really offering
itself to mocking out you are having the
interface for the RPC back and whatever
technology you're using whether it's
protocol buffers or a Java stubble you
see that interface you have it right in
front of you you just implemented with
something different and you either put
it on the same machine where your
implementation is running or you put it
you just sneak in your Mac on a network
address your your mark on the back
network address as its to be record and
then tell your implementation to talk to
the different network address don't even
need dependency injection explicitly for
that it's even easier than that and and
obviously we get speed up that we talked
about even earlier with time with this
approach so but now done for you to the
tough job that I want to give to you I I
think I've been talking for quite a
while now trying to convince you guys
that this might have some usages in our
daily lives the really tough thing is
what would you do biz the client okay so
we try to copy tactics here right so we
looked at marcus's as a strategy and how
he's doing this at a bunch of layers so
we started off at this layer and it
seems to be that the the mantra here
seems to be look at a given layer look
at the the levels above and below that
and see what can be mocked out by some
definition of mock and so we want to
test the client so what ideas do we have
here so remember that's the layer pair
we're looking at we're looking at the
the grid client there so this is in the
browser what tools are we talking here
what techniques are we talking you how
could we test this
Dom objects great so we could have tools
that can manipulate the Dom very feather
the doms actually the right stayed
before and after your test very good
what else
fake messages through record and
playback or even interception storing
those messages because it's HTTP at the
end of the day this is something that
should be mockable by some standard and
that's actually a very good technique as
well and again what we're getting to is
you won't really you won't actually need
the real servlet there you could have
something in place of it again given a
simple interface that's something you
could very easily mock out and remember
the goal here again is your testing the
client I Drive it using any one of my
standard UI testing tools that I have
things that will allow me to manipulate
the Dom things that will allow me to
intercept traffic that's going from the
browser to the backend and use those
tools to sort of create an isolated test
again you're focusing on medium cast
over here so it's you may have you may
be limited in running this is a pure
unit test but it still adds a lot of
functionality at the same time giving
you speed gains that you would get over
your traditional large tests so I think
that fairly covers it that layer so you
see also what the impact of that ideas
are on doing for instance browser
compatibility testing or on doing
localization testing I don't know I know
what a bunch of us had actually talked
about languages and locales and now
think about us doing the same test
except that we have a lot of control
over what comes what data is coming to
the browser how we can fake that data
how we can actually intercept that data
and it's especially useful when we want
to cover across matrix of either
platforms browsers or languages and
accounts the other thing here is that
talking again about speed up of my tests
so you will actually be surprised how
fast selenium can suddenly appear or
webdriver if you cut back if you cut off
that part here if you just have
communication with a server that is
maybe even running on the same machine
where your tests are executed it becomes
blazingly fast not as fast as our really
tests here against the RPC interface but
still surprisingly fast well the other
thing is that for here probably is a
very good place to inject our fake RPC
implementation for our test so you might
not even have to intercept HTTP calls by
shoot you just give deserve the servlet
of your mock server to talk to
and you can very easily do that with any
one of the number of different mocking
technologies that you could have even
for something like the RPC ample you
could use dependency injection you can
actually given the interfaces you can
create a stunt doubles as you call them
of these services which you can inject
in which is excellent because now your
same UI test that would typically take a
very long time to run or running fine
and they're testing exactly what they
were intended to test which is the UI
and not everything in the system at
least at that layer so I've not been
totally honest this year saying we are
we're just looking at every box if you
remember these medium boxes that we had
on that slide after the architecture so
there was actually one element covered
with orange in one example it was one
box plus the data store so that already
gets you a hint that we might want to
test layer pairs together as well can
you think of any reason why we would
want to do something crazy like that I
thought we were actually done with
testing them individually so that's
actually a good question why should we
be testing these in layer pairs now
communication between layers okay we
didn't actually verify that so that's a
good point there's something else so you
testing integration between those layers
limitations and how much you can mock
and even possibly mistakes because again
that is code that you're going to write
and put in sorry sorry maintenance um
elaborate so it's all right depending on
how it's actually being modified in the
code maintaining the sweet to actually
make sure it makes sense given that
there's there are changes to layers you
need to sort of make sure that the
layers are in sync they could be
coaching just any one or both of them
okay I think here the I basically all of
these questions are it's the test of the
box alone is like saying does it use the
other layer the way that I expected to
use it and does it deal correctly with
the replies from the other layer that I
expected to be given here we are asking
so the two of them together do they
really understand each other or am I
just dreaming about it now you might
think so survive bothered to mock them
out in one test and then using them both
together in the other I think the sort
here is a is again for every thing that
we want to know about the application we
think of the smallest possible test to
figure that out whatever it is so if I
want to know is the business logic
correct i'm running a battery of tests
against that component that implements
the business logic and nothing else if i
want to figure out is component egg
communicating correctly with component b
it is a totally different kind of
question which might also have different
test cases and maybe less test cases
then the other question has so all we
think of what is not a smallest possible
test that helps me figuring it out
everything that I don't need to
we'll get that answer to that question
I'm mocking out recklessly if I want to
know whether RPC implementation is
talking correctly this RPC back end do I
need to servlet Bailey do i need the
arbiter with a big table on the other
side now we don't need it we we trust
jumping after the servlet and we mock
out the big table and we have trust what
we wanted so this actually sounds really
good so we started off with you know
defining what these tests look like we
actually broke them down into layers and
we've tested them in isolation we've
tested them in pairs I'm actually
feeling really good right now I think
and I'm going to sort of you know switch
modes a little bit and say and say we're
done this is actually good are we ready
to ship so what do you think copyright
it to hit I don't know feeling confident
what do you guys think is that enough we
just do that and we're ready to go I
mean we've tested these layers in
isolation in pairs they're exhaustively
tested ok so I'm hearing configuration
end-to-end there's something that's
missing is that true so people say
something is missing Larry yeah ok so
last but not they'll not the least
important so everything that we told you
now was like avoid system tests don't do
full end-to-end tests we don't really
want them to be honest for the dramatic
effect we were cheating a little bit we
do want them what we want is instead of
you writing a few hundred of them to
write 2015 think of a number that makes
sense in this more and then for the
whole life of your project decrease that
number even for the full system we have
questions that we want to ask and where
we really need the system running to
work these questions are not does a
pop-up open if the user clicks on this
button that is something I can test
against the pure you I I don't need the
rest that question is not is the
business logic implemented correctly we
figured that out already that question
is simply so if I'm putting everything
together and I'm starting it up does it
really work or does it immediately stop
in each trick if I'm trying to run this
function does it work or does it not
work I'm not caring about boundary cases
I'm not caring about
average I'm just figuring out does the
system is as a whole system really work
so usually one test per use case is
sufficient I've covered all of the
boundaries all of the arrow scenarios in
mice in my medium sized tests now I'm
just trying blogging it all together
will it work yes or no if it does I will
be personally pretty confident that the
whole thing work the whole thing works
so it is about getting confidence into
the system reading so now are we done
now I think we are I mean that that sort
of covers pretty much everything right
we we have the units we have the medium
tests we have the large test we are
confident now the system is working and
to end yes I agree entirely what about
customer confidence unit tests and
pairwise interface component interface
tests don't actually mean anything to
the customer if you're entitled testing
is 20 tasks one per use case how do you
build customer confidence well the
question is what does the customer bond
the customer wants a working system so
if I'm confident that the system is
working and if I can show to the
customer look I am confident that the
system is working why am I I have
covered all the boundary cases for our
business logic I have covered all the
possible cases for our UI I've tried out
whether the whole thing works together
what does really want re i'm not talking
about taking the word for it i'm saying
i can basically come up with a matrix
from this and this is the business logic
I've tested this one exhaustively I've
tested this one exhaustively app tested
this one exhaustively I can say look
this is the UI I've tried the following
use cases against the UI it works
seeing that what actually builds
customer confidence is seeing the entire
system work not just in the sunny day
scenario not just a neat clean path but
showing them some of the ways it
responds to anomalous inputs and failure
and I'm not hearing much of what the
customer wants to see just about how the
customers in to behave I think you just
show them that too so yeah there's a
place for additional acceptance testing
and functional so to build that customer
which which which i think is probably a
valid point in the sense that we should
I think we should this probably met it's
even a longer discussion but I'm glad
that we actually brought that up because
that's the kind of response we want to
get we want people to come up with these
kind of ideas I think in the interest of
time because we're probably running out
of time we should get done with the
slides so please be sure to pick that up
again so I do personally think I'm
driving over any bridge in the United
States although I haven't watched them
being built and tested so I'm confident
enough I'm confident enough to fly an
airplane without having it seen be
written test and test it so I think the
question of what do we have to do to
make the customer confident is kind of
breaking down an engineering problem
into a social problem I think once we
solved the engineering problem they
solve the social problem will go away so
now but but I'm grab me in the next
break I really like to continue that
discussion so if you look at it all
let's compare the two things that we
have done before and hey because you
started off suggesting or die's enter
entity or read now so probably was a bad
idea doing all those big nasty
long-drawn end-to-end tests with all
those different scenarios through the
through the we were kind of testing only
through the GUI which is sort of where
we were driving the whole point and it
seems pretty obvious that they were both
I mean they were expensive limited
inside and sort of all the negative
points that we talked about that a lot
of us over here as testers faced with
our test Suites today they suffer from
problems whereas it seems like going
beyond that where we actually decided to
say let's not just start with the
problem from the UI let's started it
from from an individual component
perspective building up confidence to
the layers and layers and then finally
wrapping up with you know a final gy
test that sort of seems like the right
approach if you compare the two now so
yeah conclusion is beyond that what John
already delivered now so I think the
approach that was outlined in green so
looking at the architecture and making
smaller tests and will bring you to have
faster tests you can begin testing
earlier so if you're not in the happy
position that you really can push all
the writing of tests to your depth which
I think would be the ideal state but I
know the ideal world is a place that is
quite far away still we can basically we
can begin writing our tests much earlier
I don't have to wait for a stable user
interface I can start working once the
RPC back-end has a stable interface
which typically happens much earlier
than people agree about the user
interface I would argue I have reduced
maintenance of my test suite why do I
say that I think if I'm executing my
tests continuously probably on each
submit of change today to the code I'm
detecting problems much earlier and the
social problem of pushing the
maintenance to the person who actually
broke the tests becomes much easier
solvable then if I'm getting a feedback
report one day later localization of
problems is easier so I'm not having one
test that covers all of my boxes and
when it's broken I have to go and debug
it I have one test against one box if
it's broken I know ninety-nine percent
likelihood the defect is in that box
probably even higher the other thing
trust could be in our box execution is
easier so it becomes a no-brainer to
integrate your test suite into the
continuous build and of course it is
cheaper so I probably don't have to sink
so much anymore about how many machines
do i need to paralyze it which let's be
honest so we are decreasing the time
cost by paralyzing the test execution we
are not decreasing the overall cost we
just keep that one constant we are just
better getting better in hiding it yeah
so that that is probably my final point
I think agree i'm sort of convinced now
we started we started off a different
level but we're in agreement that sounds
like a good approach a considering that
we got you right off the lunch you very
Rafe audience thank you
I think they have some 34 minutes left
for questions that ok ok so I'm spending
a significant percentage of my time
working on gmail now so I guess yes so I
think it's not only me I think we have
many engineers I'm very good engineers
in gmail who are trying to change our
testing approach there and we are right
on track we are doing some very
interesting stuff there yes
so if I summarize the quest raise i'm
having in my interface many functions
that i might not even use it i'm testing
this function my dear to forge positives
because y divided should I test them at
all if I don't need them in my product
so my art man so that would be via these
functions in the interface drop them
so so what you're you're talking now
about using AP is that are provided by
3rd party where they are there you have
to draw a line no I mean I if I'm
writing myself if I know for instance my
server is going to run on Linux and it
is using some of the system API some
system course I'm not going to test that
so I have to draw my line somewhere and
think this is my line of trust or my
line of caring so the question was you
know given that we are getting these
three levels of tests and there's
significant work I mean obviously it is
an activity so it's going to take time
how do you actually decide where you're
supposed to be spending your time given
that each of these is an expensive
activity I think a lot of people in the
audience actually brought it up and this
is maybe a good time to reiterate that
and that is if test is not thought about
as an after step or something that
happens later then none of these
activities will actually be expensive in
terms of your time planning unit tests I
think pretty much everyone agrees is is
something we need to have we must have
but think about when you actually write
these tests I think with every line of
code that goes in without a test the
cost to actually write the taste test is
significantly higher and this starts
multiplying as the layers go up you know
higher and higher so having people right
each of these tests and deciding the
break up of what makes sense for your
product is something that's that's
different so for instance in our
products at Google teams may have their
own split and what they think is the
right number of unit tests to the right
number of medium tests and right number
of large test and you may have to decide
the number for yourself I think the only
takeaway would be by introducing that as
an activity
with your development cycles all these
kinds of tests can be reduced in terms
of cost for both development as well as
maintenance I don't know that
specifically answers your question but
yes so that that's probably the very
last question now I gotta go like this
idea so I think that's the last we have
one time for one last question one last
question you sir so I so giving correct
figures out is always liked being one
leg without the job so I won't do that I
don't think the gmail is an example very
doesn't work so I think gmail is
actually a very good example where we
were stuck it at this extreme until very
recently and since then many people have
invested a lot of time and hard work to
move it here I would think gmail is on
track to become a success story for what
we are advocating and we are really
doing we are really moving quite fast
into into the right direction mmm so I I
can't talk about gmail here I can talk
about another project that I've been
working on for in the past where we
followed for instance this approach
right from the beginning where
everywhere basically ones development
was put away the keyboard and said we
are done we were ready to release in 30
minutes I guess that was a mystery you
know via where we are staying around so
if you have any further questions just
um rebels in the bringer coffee and grab
us
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>