<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Brief Introduction to Computational Problems in... | Coder Coacher - Coaching Coders</title><meta content="A Brief Introduction to Computational Problems in... - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A Brief Introduction to Computational Problems in...</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/doMISS_MIIQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody I'm Mike I'm happy to
introduce Dan Brown today Dan worked on
the human and mouse genome projects at
Whitehead and he's now faculty in the
buyer from addicts group at the
University of Waterloo he's going to be
talking to us today about haplotype
inference and i'm just going to pass it
over to him now thanks Mike it's nice to
be here I think I'll start with this
here for now but I may start walking
back and forth which will probably drive
this fellow nuts um so I'll try to be
good about standing still let's see
alright so I'm Dan Brown it's nice to be
here I'm visiting you here right now
from UC Davis which is where I'm on
sabbatical normally I spend most of my
time at the University of Waterloo which
is in southwestern Ontario um I put up
our the full of the full affiliation
there because in fact our department was
recently named after David chariton who
was actually an early investor here at
Google and so he used some of his money
that he ran from that to endow his alma
mater which is kind of exciting for us I
want to start off with the obvious quote
which some of you have probably seen
which is a quote from the kitzmiller
versus Dover trial this was the
intelligent design trial last fall in
Dover Pennsylvania where the question
was whether or not creationism should be
taught in public schools in that
community and the quote here is from
Robert Pennock he's a philosopher of
science in Michigan State and he says
that you can get a job at Google if you
know something about evolution they're
looking for people who know something
about this um I should point out that I
don't need a job but nonetheless it's
it's nice to actually come to Google and
have the chance to spend a little bit of
time telling you about evolution so I
want to start off with a problem um you
may not see this as a problem but I
don't look like you you may see this as
a terrible problem and if so that's very
flattering but it's an interesting fact
about human beings that we don't all
look the same that we don't all respond
to stimuli in the same way that we in
general despite being very genetically
similar to each other are not in fact
four or six billion clones of the same
genetic material rather instead because
of a variety of different things a human
beings respond differently to different
stimuli um this is true in the fact that
we don't all look the same it's also
true in the fact that we don't all get
the same diseases for the same reasons
now there are lots of reasons for that
of course and the majority of them are
not in fact genetic probably or at least
many of them are not but some of them do
have genetic basis I don't look like you
in part because of my genetic upbringing
now there are other aspects of the
reasons why I don't look like you
ranging from the decision I made the day
to wear black t-shirt all the way on up
to the way I was I was fed when I was a
child and so on but nonetheless some of
why I don't look like you has to do with
my genetic makeup
and your genetic makeup and in general
well why I don't look like you may not
be a great influence it may not be of
great interest to you it's still the
case that we should know why it is that
different human beings to respond
differently to different stimuli at
least at a genetic level and the way
that we do this in biology is through
association mapping which connects
particular traits with particular
genetic variations now this is pretty
easy at this point for a variety of
different things it's easy for things
like breast cancer susceptibility where
the the BRCA genes have such an impact
on that susceptibility it's especially
easy for mono genetic diseases like
cystic fibrosis we're all you have to do
is identify a specific gene which is
responsible for the vast majority of the
the origin of the disease in fact at
this point if you created ex nihilo some
new genetic disease that no one had ever
seen before and suddenly found a
community people who had it we could
probably identify the gene responsible
for that one gene genetic disease in a
matter of a few months for a couple
hundred thousand bucks this is a
remarkable change over even ten years
ago but in fact most diseases that
actually affect people most of the
explanations for why it is that people
are say oh be or diabetic at a genetic
basis aside from their lifestyle
differences or whatever um are
multifactorial it's not the case that
single singhal genes explain those
diseases rather it's the case that
nowadays we have to look at a connection
of many genes acting in concert as being
the genetic makeup that's responsible
for a particular disease so there's
basically two problems that are that are
involved in the difficulty with doing
association mapping with connecting
diseases and traits to genetic basis now
the first one is actually the most
important problem in all of science or
the most difficult problem in all of
science and that's the problem of
relating correlation with causation of
course if you say I looked at a
collection of 500 people and they all
had this common genetic variant and they
all had this disease and then I looked
at five hundred other people who didn't
have that
common genetic variation and didn't have
that common disease that's interesting
in fact it's fascinating potentially but
it doesn't tell you the first thing
about why it is that the 500 people with
the genetic variation got the disease or
why the ones that didn't have it didn't
get it so of course that's the most
basic problem of all of science though
why is it that some connection some
correlation how does that how does that
conflate with with with causation of a
particular trade this talk is not about
that question because of course this
talk is not the end of science instead
this talk is about the other problem
that's also difficult which is just
looking at a collection of individuals
and trying to identify what the genetic
variations that they have actually are
in other words if you look at a
population of different people asking
the question for particular genes which
variations on that gene did different
people inherit from there from each of
their parents that problem is called
haplotype inference it actually goes by
lots of different names but that's
that's the name I will give it in this
talk and it's the problem of identity of
separating out um parental chromosomal
of parental chromosomal inheritance from
each other in one person or in a
collection of people so this really does
matter even inside one person it
actually matters and I'm going to spend
a little bit of time now explaining why
thats so why it's even important to
identify for a particular person what
that person inherited from their father
versus from their mother and I'm going
to do that by telling you actually the
origin of this field which
embarrassingly enough I only learned
about a few weeks ago when I was talking
with the statistical geneticist at UC
Davis so you each have each person in
this audience has two copies of human
chromosome 6 you inherited one of them
from your mother and you inherited one
of them from your father now on that
chromosome are our collection of immune
system genes called the major
histocompatibility complex you inherited
um you probably inherited something
different from your mother than what you
inherited from your father the reason
why it's just that there's a lot of
different variations on that chunk of
DNA that are found in the entire human
population
unless your parents were say brother and
sister which would be a very bad idea
you probably inherited something
different from each of them um indeed
actually it's its reasons having to do
with for example that that are among the
many reasons why um well for example
having children with your with your
cousins is perhaps not such a wise idea
so you got something different from each
of your two parents now suppose that you
got very sick and you did a transplant
suppose you needed a liver transplant
for example and some liver got put into
your body and that liver was from a
person who had a different kind of
genetic basis for there for there that
they had inherited from their parents
well then you're in something of a
problem because if you were transplanted
with an organ that didn't match either
of your parents exactly rejection can
happen so the trouble with that is that
the technology that you can get to
identify somebody's DNA sequence doesn't
actually separate the maternal
chromosome from the paternal chromosome
it doesn't identify what came from your
mother and what came from your father so
let's look at this simple example here
here I've got two different DNA
sequences that might have been inherited
in one person remember that DNA is a
very long a DNA sequence is a very very
long sequence of letters over the
four-letter alphabet ACG and tape at
least as far as we're concerned that's
what it is obviously it's really a
molecule but thinking about it in the
sequence abstraction is perfectly fine
for us so suppose that you've got
something like that and suppose that a
person is needing a transplant and that
those are the two things that they
inherited from their two from each of
their parents from their mother they
inherited in a particular chunk of
sequence a gtat and from their father
they inherited ggggg TTT so if you look
at the two columns that are indicated in
red there you'll notice that those are
the two columns where the two parents
differ from each other the mother in the
first case has a a and the the father
has GT now the trouble is that the
technology that does sequencing doesn't
distinguish which came from what and so
in fact if you came if you just used a
typical DNA sequencer
somebody who's sequences were instead
ggt 80 and AG TTT you would actually get
the exact same outcome because in the
first column you've got 1a and 1g in the
fourth column you've got 1a and you've
got one T and every other and the other
three columns are the same in both so in
both cases you wind up with the exact
same result off the sequencer but
unfortunately suppose that you were
actually the person on the top there and
you were transplanted with an organ from
the person on the bottom so you were you
actually have the a gtat haplotype which
is what we will call that chromosome and
you get trend you get transplanted with
somebody with the G gtat what you could
die I mean you actually really could die
this is going to cause potentially
rejection and you could die so in fact
the question of separating out the two
chromosomes identifying for a person
exactly what they inherited from each of
their two parents maybe not worrying too
much about which one was mom and which
one was dad that may not actually not
her very much but identifying the full
sequence of what they inherited from
each parent is actually vital because
again if you get it wrong you could die
there are not that many places in
science and certainly not that many
places in computer science where we wind
up saying to ourselves wow this could
actually result in somebody dying but
this actually is one of them um now it's
also the case separating away from this
question of somebody dying there are
also just reasons why you might wonder
in general so it could be the case that
a particular effect a particular
phenotype a particular experience in the
real world might depend on having the a
and the a together or the G and the tea
together not say the the first G with
the subsequent a or the a with the tea
and so being able to separate out those
two chromosomes might be useful just for
the question of joining together effects
from two different variations into one
explanation so the question of haplotype
inference there then is the question of
taking a part of identifying from what
came from the DNA sequencer and
separating out the two chromosomes that
explain that so again that's what these
problems are all about and there are a
whole bunch of different problems that
all have sort of the same flavor
but I'll differ a little bit in
structure and they're all of this form
you're given a collection of sequence
there's a collection of DNA sequences
that come from two chromosomes where you
have some ambiguity at certain sites
about which one came from which parent
and the question is to find the two
parental sequences the one that
corresponds the mother and the one that
corresponds to the father that explain
either that one person or that
collection of people um oftentimes this
is actually just cast in simpler terms
because biologists know these like this
language well enough that they don't
have to worry about it in terms of
sequences and chromosomes they just will
say that the input are genotypes those
are those sequences that have the
ambiguity is this an a that goes with an
A or an a that goes with atty and and
and how do you distinguish which from
which the input are those genotypes and
again the output or the haplotypes which
are the chromosomal sequence is
separated from each other and that's the
domain of this talk there's a lot of
different problems of this type um again
they actually go back quite a long time
they go back quite a long time because
when transplantation was first started
people needed to be able to identify and
they did it using antibodies actually
for a particular person which two types
they belonged to um this is much more
complicated and much more important
since again you could die and
transplanting is really expensive so
it's kind of stupid to waste all that
time and then have the person die for
rather dumb reasons um then say blood
typing but still nonetheless that was
how it was started nowadays we'd instead
be just doing it off of sequence and
suppose that here's a here's a simple
example of one such problem suppose that
you're given sequences of two different
population members and in this in this
picture here the places the positions in
the sequence where there are no
variations um where there's only one
element in a particular position both
parents agree with each other the only
places where there's any ambiguity are
the ones where I put two different
symbols over top of each other so
suppose that you've gotten a couple
members of a population and you've taken
genotypes of those of those people um
and the question is to try to figure out
what goes with what what was what was
the
way to explain it now in the case of
this simple explanation simple example
I've given you here one thing to notice
is you can actually you can actually
explain both of these two population
members using the same the same
haplotype one in common and it's that a
TGA TGG TT haplotype I've drawn there
assuming that I've done this right it's
in red in both cases there that could be
the sequence of a parent of one of those
people and also the parent of another
one of those people now why does that
make any sense well here's why it makes
sense um it's certainly a bad idea for
you to have children with your sibling
but it's certainly reasonable to assume
that your sibling might have children
and so might you and so if you're
looking at a family it's reasonable to
assume that in fact multiple members of
the the next generation of a family will
have inherited the same haplotype from
their parents so if for example this is
a these are the sequences from two
brothers that actually kind of makes
sense they might have had one parent in
common and they might have both
inherited the same haplotype a TGA TGG
TT from that same parent so this
question of trying to separate out the
two confounded sequences for every
population member in fact asking how to
do that it'sit's no there's no way of
doing that when you've only got one
member of a population but if you're
looking at a collection of people well
you might be able to do it but by
looking at this kind of reuse so just to
now give you that sort of an
introduction to what we're going to talk
about today now I want to give you a
little bit of of I don't know some
abstraction that makes this feel a
little bit more like the computer
science problems that at least I is as a
mathematical computer scientist feel a
lot more comfortable with so again we
start off with genotypes these are the
sequences that come off of a DNA
sequencer but they have this difficulty
that if a person is sequenced and a
particular position of that person
sequence differs in there to parents
well we don't know what came from which
parent haplotypes are actually a lot
more important than genotypes if we're
asking about inheritance of calm
diseases or trying to avoid
transplantation rejection or such oh and
again now let's just start thinking
about this problem rather than as some
ambiguous kind of fluffy biology problem
let's get down to brass tacks and think
about this like a math problem so I'm
going to start simplifying the problem i
just told you about now i should also
say i'm happy to if I'm snowing you
please stop me and just ask a pile of
questions that will make me happy um
let's let's step back away from from
thinking about DNA sequences like in
this picture and let's just go to math
instead and let's in fact in particular
start abstracting away the DNA sequence
entirely I'm going to assume that I'm
now going to restrict the problem domain
to places where if I'm looking at a
collection of DNA sequences at least one
of them has ambiguity so for example in
this here every every one of the
haplotypes it's apparent for either of
those two people has a tea in the second
position because the second position in
both of those is is TT so I don't even
care about that particular position so
just forget about positions where
everybody has the same thing and focus
on ones where there's at least a little
bit of ambiguity the second assumption
that i'm going to make is that every
variable site i'm only going to let
there be two different population
choices so for example here i'm not
going to allow the first position of
another population number to have a see
as a choice because I've already got a's
and G's and I'm just going to make the
rule that every position where there's
variation there's only two common types
that actually is true in the real world
what's more is actually if it turns out
that you wound up finding a rare case
where that wasn't we can actually deal
with that anyway so we're going to make
the assumption that there are only two
choices at every site and for simplicity
rather than a CG and T which is a bit of
a pain let's be mathematicians and use
the binary alphabet instead and have
this be zeros and ones and then we just
need some notation and the notation that
we're going to say is now I might have a
matrix as my input that matrix
corresponds to telling me what is in a
particular position of a particular
person's genome
if a person has a zero in the in that
matrix that corresponds to saying that
both of their parents have what we're
going to call allele or I'll just call
it value for this talk value zero at
that site if I have value if both of the
parents at a particular site in a
particular person's genome have value 1
i'll stick a 2 in that matrix those are
all the ones that are really easy to
resolve though I mean everywhere you've
got a zero both parents are the same and
that's that's the case is like the first
column of the first person there you
know what both of those are going to
resolve to the ones that are more
interesting are the ones where there is
this ambiguity and in those positions
we're going to put the number one now i
should say if there actually is anyone
in this audience who's ever worked on
this problem before I'm totally abusing
notation and I'm taking advantage of the
fact that probably most of you are
innocent of this problem and cheating
the standard notation for this problem
that biologists use reverses the meaning
of one and two and i'll come back to why
that why we've made the change of of
doing it this way in just a second yes
this yes that's right but the thing that
the thing that actually gets us some win
here is the fact that we might share
them um if and in fact if you had random
garbage from all over the world and you
know bacteria that it well bacteria
don't have this problem because they
only have they don't have two
chromosomes because they don't have two
parents but some organism that had two
parents that we've sampled from all over
the world and there was very little
genetic relationship between them you'd
be just as you'd have just as many
problems as before the thing is is that
at least if you have some family
structure maybe you can share haplotypes
or have haplotypes that look similar to
each other because you know two people
might have related parents there might
be one or two mutations that
differentiate them but they do at least
be similar looking to each other but
that's right we want to find two parents
for every population member good okay so
that's the problem we're given this
matrix um just to think about it I
didn't draw out here as a matrix because
um well it just didn't really fit on the
slide but the problem that we had before
we can imagine casting in this term of
just like that where the the first guy
we're going to have all of his places
where there's only one choice be zero
and that means that the a in the first
column turns into a zero the t turns
into a zero and so on we're the only
thing that's different and places where
there's a choice or once the only thing
different in the second guy is you'll
notice that too in position three that's
because uh he has 2 g's and maybe that's
the allele number 2 or that that's the
second allele number one having two of
those means that you have a two in that
particular entry and the places where
there are ones just to give you a little
bit of terminology those are called
heterozygote positions um that just
means that at a particular site in the
genome you inherited something differ
from each parent so again all that we
have to worry about here is figuring out
how to arrange the ones in every one
position there has to be 10 and 11 the
only question is who has the witch witch
chromosome has which zeros and one so
that you put the
together and they all line up properly
in the positions where you have a zero
or two it's all very easy you've got
have a zero in both parents or a one in
both parents um the reason i should say
now that we use this notation which
cheats against the standard notation
here but at least to me as a
mathematician just feels vastly simpler
is that now in this abstraction a
genotype is the sum of two haplotypes
you're going to be taking two vectors
adding them to binary vectors adding
them together and producing this vector
/ 0 ones and twos and well that just
makes me happier so now life is much
simpler and in particular if we have a
population of n population members that
we sampled from and we sampled them that
ends at M as in Mary different sites we
have an N by M matrix / 0 1 2 is the
input and the only question is now how
do we discover how do we dietra a few
couple those those M rows into 2n those
n rows sorry how do we decouple those n
rows of HAP Latino types into 2n applo
types so that if you add two consecutive
rose up in the new matrix that we're
going to form you get one row from the
original matrix G so again the input is
an N by n haplotype mate your genotype
matrix G and population numbers M genome
sites and the goal is to find a 2 n by M
haplotype matrix H so that if i add up
two rows of h i get one row of of g now
the only question here is well i mean
think about it if you've got such a such
a if you've got such an input matrix g
the number of explanations for any row
that has a e ones in it is two to the e
because it's just a matter of you know
do i put a zero here or do i put a 1
here do i put a 0 here or do i put a 1
here you can divide that by two if you
say that that uh you can identify
parents from each other so if you can't
separate mothers and fathers then
there's one that explains at least half
of it but you still have an exponential
number of such explanations which one is
right well that's an interesting problem
and it certainly lets people
arguments as much as they want to but
one way of thinking about this is to
actually do some evolution experiments
and to say the way that I'm going to
answer that problem is I'm going to say
I have a model of how these sequences
could have evolved the sequence is in H
my haplotype matrix I have a model of
how they could have paired together
which is the which in in in evolution we
say that people make rather than pairing
a random mating model for explaining how
they the haplotypes paired to form
genotypes and then the question is to
find the explanation of the input matrix
G our genotype matrix G that has highest
probability 0 now any of you have ever
done stochastic optimization know that
that's really not fine I mean you've got
this very complicated model of evolution
you need some way of really explaining
how the mutations happen how
recombinations happen how how starting
from some least common ancestor all of
these sequences came into being and
that's really nasty and then on top of
that you have to have some way of
associating those population numbers in
H to form G so that then you can undo
the whole process in wind up explaining
your genotype matrix G by H this is
awful you can sort of split the
difference if you really want to you can
try to just find the haplotypes and not
worry about how it is that they paired
to form the genotypes or not have a
model of how they paired to form the
genotypes that's fine um you could
actually give up on the model of
evolution and just focus on the pairing
that's actually easier i'm working on
that kind of problem right now but all
of this is really painful and
nonetheless important again remember
this is go back to the beginning of this
talk you could die this is a very
important talk a very important topic to
get right because you really don't want
to kill people so none of what do you
have now you've got a population of
people you want to explain their genetic
origins and you've got a whole bunch of
statistical problems that are based on
complicated models evolution of
evolution which I should point out are
really hard to parameterize really hard
to optimize really hard to do everything
within the first place and then you have
this nasty pairing on top
of it so well what do you have then well
you've got a problem and so being
theoretical computer scientists people
came in and said why don't we solve this
the way that we solve other problems
that are hard by throwing out all the
hard part and just focusing on something
that's similar but fine and in
particular I'm going to tell you now
about the simplest possible version of
this problem and a little bit that you
can actually do with that problem to
genuinely solve it rather than tearing
your hair out thinking about the
statistical problems so again we have
this input matrix G that's all right
that's our genotype matrix it's this
ternary matrix where zeros and twos are
easy to resolve and the only question
was what to do with the ones and then
our output matrix is some haplotype
matrix H that optimizes some
combinatorial objective or maybe it
optimizes some combinatorial objective
where we restrict the class of matrices
H that we're allowing ourselves to use
based on something that we know about
the population structure and I'll I'll
come to that in a second the simplest
possible example of such a problem is
the haplotype inference by pure
parsimony problem haplotype inference by
pure parsimony well this is a problem
that was introduced by Dan Gus field and
the problem here is just have the answer
have the fewest haplotypes possible why
well go back to this again we wanted to
reuse some of the matrices or sum of the
vectors that we were using we wanted to
say that certain population vaca members
might might have lots of offspring or
might have lots of related off members
who are having children and so
consequently we might just want to
explain our genotypes explain our matrix
G the simplest way possible with the
fewest with the fewest haplotypes again
this problem is introduced by Dan Gus
steel did a conference paper in 2003 and
that's actually where I first heard
about the problem as well so the HIPAA
plet I pin ferns by pure parsimony pure
parsimony being of the heck with all
these evolution models I can't even
think about them they're just too
complicated just have as few as simple
and explanation as possible fewest
fewest haplotypes and so here's a way of
stating that as
um just a simple algebra problem given
as a ternary matrix and by M goal find a
way of producing a 2 n by M binary
matrix where again pairs of consecutive
rose add up to rows of G where the
number of unique rows of H is minimized
or the number of distinct rows of HS
minimized so now it's just an algebra
problem right I mean all you need to do
is some way of structuring this edition
and should be easy well all right the
problem is np-hard that's a paper or
that's a result that Gus field sites in
his original paper as being due to
somebody else it's a fairly easy
reduction to prove so just the ability
to take this problem and abstracting
into algebra didn't actually necessarily
get you very far but again we're at
least we now have a real problem that
isn't that doesn't make you want to tear
your hair out because of all this awful
statistical stochastic pick again you
can also limit the problem a little bit
as well here's one simple limitation and
I'm not going to go into very much
detail but as I said before you might
want to make restrictions on what kind
of matrix H you would allow so for
example you can restrict H so that
rather than having um rather than than
being any binary matrix H might be
restricted so that it has to come from
an explanation you could produce off of
an evolutionary tree will come back to
what that means in the little bit but
just um just for now imagine that the
the modern sequences that form H the
haplotypes that are that we're looking
for are the leaves of an evolutionary
tree and we track back those leaves back
to a single common ancestor um and put
mutations on that tree to explain the
population or do to explain the various
columns of the matrix age in the event
we'll come back to that in a second so
if H can be derived from a tree in that
way it's called a perfect phylogeny
matrix that's actually a definition that
goes back also 20 years and the question
of trying to find the smallest
explanation in terms of having the
fewest unique rows where you also make
restriction that you have to satisfy a
perfect phylogeny matrix um that's
called the min pph problem because it's
a perfect phylogeny haplotype matrix and
you want to minimize something um this
problems also np-hard that's a paper by
Bhavna and bonsall from a couple of
years ago and ironically enough they
it's NBD hard lots of these problems or
even NP hard to approximate but as we'll
see they're actually not so hard to
solve which is perhaps a little bit of a
surprise so why would we use a
combinatorial objective for this problem
again well again the reason why we're
doing this is because all that
statistics was just awful I mean it's
just painful thinking about models of
evolution and how to pair of things
together and it's just painful instead
we just have this simple combinatorial
objective count the number of unique
haplotypes make it as small as possible
good um that's one reason the other
reason to use this combinatorial
approach is do you really believe these
models of evolution well I mean none of
us is an evolutionary biologist I don't
think but having been a little bit
closer to these problems maybe than most
of you I don't um they're nice things to
think about there they're good
representations of evolution in the
absence of selection in the absence of
all of genetic drift in the absence of a
lot of the other classical things that
make evolution actually work and so my
trust them to the extent of being the
answer to your question so maybe
actually reducing the number of
haplotypes and having that be your goal
might be a reasonable approximation to
the to a decent evolutionary objective
instead and plus again mate you know
nothing succeeds like success you can at
least solve it so that's the sort of
practical reason to think about these
problems the other reason to think about
these problems and frankly the reason
why I think about these problems is
they're tasty I mean think about this
problem i just presented to you i just
presented to you a really trivial
algebra problem at its base and it i
mean it took me 20 minutes to get you to
an algebra problem but nonetheless all
that's what it is it's just a bunch of a
ternary matrix that you're saying every
row of that ternary matrix is a sum of
two binary vectors
find the smallest number of binary
vectors what could be cooler than that
and there's a lot of other structure
like that that's very classical graph
theoretic structure that you might be
wanting to look for um so all of these
things are just it's an under colonized
problem domain there's not despite the
fact that there are dozens of papers on
this area it's still a fairly young
field being all of three years old um
and it's just it's just a delicious
place to do work so that's another
advertisement for this rather than
necessarily why you why a real biologist
would care about these problems so
what's not to like and again it does
have a useful application so that that
means that at night you can go home and
feel good about what you did that day
too which is good so where are we now
well now here's where we are we talked
about why genetic diversity is nice to
know something about it's nice to be
able to characterize what separates the
individual inheritance is of a
particular person or collection of
people because it allows us to identify
susceptibility to inherited disease
answer questions about simple things
like like transplant rejection so on
very straightforwardly um in order to do
that we need to be able to separate
paternal and maternal DNA in population
numbers which will represent by
genotypes and then again this haplotype
inference problem is the problem of
separating out a genotype into two
haplotypes that mutually explain it and
now we've been seeing that for reasons
that are not especially convincing but
still worth justifying you might want to
study this combinatorially instead so
where are we going and what's left of
this talk well I've given you an
objective I've given you a nice algebra
problem but I haven't told you how to
solve it so we'll talk about how to
solve it um I'll tell you a little bit
that actually so about why you might
care about this goal because solving it
is actually good for you um and then I'm
going to just tell you the surprising
fact that the algorithms I'm going to
tell you about which are exponential
time algorithms for this problem
actually solve just like that and maybe
try to at least begin to tell you why
that's true unfortunately to do this
we're going to need to talk about how
evolution works
gardless of whether we wanted to or not
and I'm just sort of putting that off
the lead so again we bought this
haplotype inference by pure parsimony
problem it's NP hard we're trying to
find the simplest it's the smallest set
of haplotypes that explains my matrix G
dan vast field in 2003 said that the
simplest way to solve this problem that
he could come up with was just to do it
using an interlinear programming which
is of course a classical optimization
technology for ACK I don't know how to
solve this problem it's NP hard it's NP
hard maybe if I represent it in some way
that has to do with satisfiability or in
linear constraints on integer variables
maybe that will at least help me
understand it better and heck maybe I'll
even solve gosfield said that the way to
represent this problem is to and again
just just a reminder again integer
programming is representing the goal of
the problem the thing that you're trying
to minimize are optimized as a linear
function of a collection of variables
and then casting the the requirements of
your domain as a collection of linear
constraints on those variables where the
restriction is that those variables have
to be binary or integer so the way that
Gus field addressed the H I PP prime was
to notice as I said before that if
you've got e ones in a particular
genotype um so you've got a genotype
with say in this case two different ones
in it that there are two to the e minus
one possible distinct explanations for
that haplotype so let me attach that
it's really rare that i actually have to
use it that i have to use microphones
i'm actually quite loud but i'll try not
to shout into this thing here we see
that there's two different explanations
there for that hat for that genotype and
the question is just which one does the
what does the first one pair with here
it pairs with another one and in the one
on the right it pairs with a zero and
otherwise these two haplotypes these two
explanations are identical to each other
notice that there's that one in the
fourth position in both population
numbers are in both haplotypes to
explain the two
y X so if we start off with an
explanation or if we start off with the
genotype with e ones in it again there
are two to the e minus one different
pairings that explain that no big deal
there um and again also we have to pick
one of those explanations and if we pick
it we have to include in our collection
of H both of the things that we chose to
pick up or to explain it with that's
just a just fair if you're going to
explain something this way you got to
pay for it so that's the the
restrictions that are built into Gus
fields integer program so what we're
going to have then is we're going to
have for every possible choice of every
possible haplotype H they could explain
any of the genotypes in G so any binary
vector that could be an explanation for
any of my genotypes in G we're going to
have a variable X H which is one if we
choose to include it in 0 otherwise and
we're just going to count the number of
those X's that we set to 1 now think
about the explanations for our genotypes
we had to to the e minus 1 different
pairings that explained every genotype
if I pick a pairing again I have to pay
for it which means that if i choose to
explain a genotype with explanation ada
which is haplotype one and haplotype to
I better pay for haplotype one and
haplotype two and i'll do that by having
a variable Y ada that tells me if I
chose that explanation and then the
restriction that if I chose it I have to
pay for it and in fact this is all Gus
fields integer program is the part in
the red is the important part of their
lies that's of course just that's just
words we want to minimize the total
number of haplotypes chosen subject to
the restriction that we explain every
hap Latino type that's that summation X
constraint its second there which is
that we have to have chosen at least one
explanation for every genotype the
second one or third one won't matter um
and then if we've if we've chosen a
particular explanation we have to pay
for it which is the restriction that's
embodied in the third and fourth line
there
of saying that the Y variable has to be
less than the corresponding X variables
now think about think back to what we
talked about before there's this
exponential number of explanations so in
fact this is an exponentially big
integer program as well um this is
worrying I mean why would we want we've
got this giant at this giant integer
program and the integer programming is
this is notoriously complicated and slow
and confusing and well why not at least
give it a shot I mean the problem is and
be hard to begin with so we shouldn't
expect it to solve very quickly anyways
so we've got this exponential size an
injury program huge number of potential
variables huge number of potential
constraints well try it and it really
works well um what is really well mean
well Gus field did experiments
unreasonably small instances of the
problem admittedly the ones that he
could actually write down because it's
an exponential size program and if you
can actually enumerate out the program
and do a couple of tricks to make it
faster um then he just handed it off to
a commodity program admittedly an
extremely impressive one called cplex
that solves integer programs and they
just solved well all right what is
really well mean what does just solved
mean and and it also solved in practice
what does that mean well despite
ourselves if I'm going to say that a pro
at a particular algorithm for an np-hard
problem usually does really well I need
to tell you something about what what
domain i'm working with that i mean i
can't just I can't just say this works
really well I have to tell you what what
kinds of problems did you run it on and
in order to do that we kind of need
something about what G is how we got G
or how we got H impaired H to get G or
something like that um if you were
feeling really naive about this you
could just say oh pic G uniformly at
random overall ternary matrices but
that's not going to work because then
you'll have no sharing and it's just a
bad idea um that that makes no sense
from the biology of this problem it's
fine as an algebra problem but it makes
no sense in the domain um much more
sensible is to start off with some way
of picking H from
some distribution and then randomly
pairing together the rows of H to get G
and just pick to pick two members of H
uniformly at random pair them together
and get G and then that have in some
sense cast your difficulty on to the
question of how you make H again you
don't want if you do that where you're
pairing up random vectors you don't want
those vectors to necessarily be
uniformly distributed at random either
and the reason is because people have
family trees and soda chromosomes so the
way to do this is to actually have some
model of evolution that says sequences
evolved from a common ancestor in this
case I'm going to say that the common
ancestor has sequins 00000 and the way
that this works is that the children or
the leaves of this tree at the bottom
correspond to the rows of H and the
places where i've drawn X's on the tree
those correspond to single mutations at
various sites on the genome and all that
you see there is that places that are
descendant from an ex place is descended
from a mutation at a particular numbered
position have a one in that position and
those that aren't don't so for example
everything that's now highlighted there
descends from that exon number one and
has a one in position one of its
sequence whereas the guy on the right
doesn't and that model of evolution that
in fact is the pure part that is the
perfect phylogeny model of evolution
that you start with some common
ancestral sequence and then descendants
of the of mutations have a unique
include a one in that position and those
that don't don't so all right again I
told you that if you run gusty old
integer program it just runs it just
solves this is not supposed to happen
you're not supposed to just push return
and have it run in half a second um we
now know something about at least a
model for evolution and how to pair
things together to make G the way that
we actually specifically produce ages we
just basically run an evolution
simulator on a particular model of
evolution called a coalescent simulation
it picks the technics the topology of
the
three that is to say how the leaves
coalesce as you go up towards the root
of the tree from a standard distribution
throws mutations at that tree in each
independent of the other and then that
gives that gives you your structure of H
pick H that way pair together random
rose at H to get G run Gus fields
integer program damn it works on less
than a second so why and in what's left
of this talk Oh in what's left of this
talk I want to just give you a tiny
flavor for why because in fact this is
kind of a strange thing it's rare that
we get an np-hard optimization problem
that always solves and it's even rarer
that we get an NPR de optimizations all
probably it always solves for which we
can actually explain the answer to that
question and that's what I want to
finish off by telling so again we've got
an np-hard optimization problem when we
pick input for it from a particular
sensible distribution run an exponential
time algorithm on it we wind up actually
generating an answer very quickly that
in fact it even turns out to be the
right one what's the structure what's
the explanation for the problem well
I've been trying to tell you about
algebra this whole talk I've been trying
to think have you think about this this
talk this problem that's just being
about matrices so let's go one step in
toward that um and in particular I want
you to think about this problem is now
being a little bit different um ji is
just like before but now H is not a 2 n
by M matrix it's a k by n matrix where
I've got k distinct haplotypes and I'm
pairing two members of that matrix
together a way of explaining that
pairing is through a pairing matrix P
and saying that the matrix G that we're
interested in is just P times H oh god
linear algebra well too bad um I'm
afraid that you know into every talk
some linear algebra sometimes must fall
um again we've got two different rows of
of H that we add up to make one row of G
that means that p is a matrix that has
one row of p for every row of g it's all
zeros except for two ones or actually it
can be a two
one position also that means you've got
two copies of the same parent and that
may seem scary until you start reminding
yourself that plants can self fertilize
um so we want the smallest binary H that
explains our matrix G with a proper
pairing matrix P so G is P times H is
our pairing matrix times are haplotype
matrix and here's a fact from linear
algebra H has to have at least the rank
of G distinct Rose why well G equals P
times H P tells us how to add up rows of
H to make G if G has k linearly
independent rows H has to have K linear
it isn't a linearly independent rows 2
so the rank of G which you can compute
in polynomial time you've learned that
in college or even high school probably
you can use that as a way of lower
bounding the number of haplotypes you're
going to need it's just an easy
polynomial time blow a lower bound so
you're going to be at least rank of G
distinct rose to to make this work so is
that going to be the optimal number is
that tight is it going to be the case
that I can explain G with exactly its
rank number of rows well yeah actually
it is um we generated G by P times H
suppose that H is full rank and rank k
and p is full rank and rank K so I
promise I'm going to just if linear
algebra makes your head spin as much as
it sometimes doesn't mind I will do this
quickly but again G is the product of
two distinct matrix of two different
matrices if they're both full rank if P
is full row rank or full column rank and
h is full row rank then in fact that
will completely explain that will give
us a solution that uses k haplotypes and
it will match the lower bound so when is
the rank of P times H equal to the
number of distinct rose again it's the
right this will all line up perfectly G
will have the right number of distinct
the right rank which will correspond to
the number of distinct rows of H exactly
when P&amp;amp;H or full rank and I'm not going
to go into this incredibly in incredible
detail but it turns out that um p our
pairing matrix our explanation for how
we pair together haplotypes from h to
make g well p is actually it's the note
edge incidence matrix of a random graph
why because every time I pick two things
and put them together I pick them
uniformly at random that's just picking
two notes and drawing an edge between
them so suddenly a mating is just an
edge in a random graph well if you look
at a random graphs note edge incidence
matrix that's full rank exactly when
it's a non bipartite and when every
connected component of it is non
bipartite and that's true exactly when
you have at least little elite little
Omega of half one half K log K distinct
edges so if you have at least that many
rows in G then you've got full rack an H
is full rank that was the other part of
our product exactly when well that's
hard to explain but it certainly is full
rank when you got a tree so if you
started off with that simple model of
evolution where things descend from a
common ancestor and you a particular
position in a sequence has a one there
if it if it inherited from a mutation
and doesn't if it didn't well then in a
tree it actually turns out that's full
rank two and the simple explanation for
why which I can show you a little bit
more easily on paper is you can I can
give you a simple explanation of how you
can keep pulling one unique haplotype
out of age and it will be uniquely it
will be linearly independent of
everything else and you just keep doing
that until everything's gone and it
works so what that means is that if you
have 0 point 5 K log K more than that
many distinct pairings then in fact the
rank of G is the optimal answer and so
what that means is that this problem is
np-hard but in fact you can solve it in
it with a polynomial time algorithm at
least to compute compute the number of
haplotypes you're looking for
just really kind of surprising and you
can be a little bit more painful and
actually even give an algorithm for
doing this when when the number goes
from point five k log k to maybe six k
log k but still not so very many
pairings in your population g mean that
you can actually solve this problem
polynomial time this doesn't explain why
the integer program solves quickly this
is an np-hard problem we're showing a
polynomial algorithm for many instances
of the problem of every where it says
almost surely here in red that's the
technical term for almost surely it says
with probability very very close to one
um it doesn't actually explain why the
original algorithm works but it at least
gives an explanation that works quite
that for why it could be possible to do
this and kind of striking that so you
can actually that's the end of the
algebraic pain and then just to step
away from that you can also actually
solve a lot of other problems in the
same domain um many of these problems
are np-hard all of the matter again
because they all give a different way of
abstracting away this question of run
over I've gone I've gone poof of
explaining away you're explaining your
problem in a simple number of steps and
Oliver I'd be hard all of them turned
out to be easy to solve in practice
which again is really kind of surprising
and for problems other than the simple
one I just told you about we're working
on why it is that they saw rapidly as
well where do we go next well the
general problem that i'm working on here
in this whole domain is why is
combinatorial papo typing an easy
problem to solve all these problems you
can state them you can solve them and
they're all NP hard and they all some
the reason why they're easy to solve
must go back to something having to do
with population structures and so the
question is can we actually give and and
typically when you solve them they not
only are easy to solve but they actually
tend to give the answer you started off
with that is they solve that the right
answer which is a bit of a surprise too
so this suggests that maybe one could
also approximate the statistical
objectives that I said were painful and
hellish
and maybe you get a good solution that
way as well in fact you can even go one
step further when people have studied
Association mapping this question of
relating diseases to genetic variations
that's always been done statistically as
well and an interesting question is can
you study that from a combinatorial
point of view too again you might get
simpler problems that you might be able
to then actually solve as compared to
the fuzzy awful unpleasant statistical
problems that you might want to solve
but would never actually be able to
finish so that's the end of this talk um
I think the biggest take-home message
that I want you to leave with is that
understanding genetic variations among
people is actually important it's
important at the level of understanding
how diseases are identified with their
genetic basis it's even an important
foot at a very microscopic level of
trying to prevent things like very easy
ways of preventing people from dying um
you need to be able to in order to do
that you need to be able to separate
paternal and maternal chromosomes and
doing that in a combinatorial domain can
be very easy and even gives them some
pretty delicious theoretical results as
well that may be extensible to other
domains I just want to finish up by
thanking Dan Gus field who's actually my
host at UC Davis for introducing me to
this whole domain many of you may have
read his quite well-known book on
sequence analysis and he's just a
terrific guy and the work that I told
you about the structure of the haplotype
ink problem is joint work with one of my
graduate students and my being able to
be here is thanks to insert which is the
Science Research Council for Canada
thanks very much
yeah what's that so the algorithm for
solving the problem when you don't
actually when you have even more
pairings than you start off with so
actually I mean it's really a cheat what
you get to do is you get to show that a
particular particular algorithm that was
presented in 2004 that has exponential
run time on the runtime of that
algorithm is polynomial times the number
of different explanations that can exist
of a particular type and what we can
show is that the number of explanations
is what and so consequently you wind up
with a very simple algorithm that's
already in fact even been implemented
and you just say I know this is going to
work in very fast time so it's even a
cheat although you can also turn that
around and say that we've in fact shown
why another algorithm even runs very
quickly but no ironically this the work
that we actually did on this problem we
have another paper that actually works
on the integer programming for this
problem so that it's not exponential in
size but most of the work that we've
done on this problem is actually about
explaining why other algorithms are the
right things to be using um just from
this mathematical structure point of
view which still feels good yeah surely
and things I said so obviously the
deposit America's if you're talking
about that's right basically that's
happening how and then you talk about a
few harmless but that's really
analysis not a probabilistic thing so
how do you write so the question is how
to connect the the fact that NP hardness
is a statement about worst-case results
and and probabilistic analysis is a very
different domain that's true and I mean
it isn't it's not like this is a domain
that's particularly a phenomenon
surprising lots of np-hard problems
solved very quickly satisfiability is
all very quickly Traveling Salesman
problem solves very quickly knapsacks
all very quickly a lot of these problems
have that kind of structure um and and
indeed it is the case that um that I
guess the weight is saying that it's a
little surprising in this domain is that
typically when a problem is a easy to
solve in practice but np-hard usually
you have some kind of approximation
guarantee algorithms or something else
floating around in the literature as
well the approximation guarantees for
this problem are appalling they're all
exponentially they basically in fact
start off by taking the exponential size
energy program and then doing randomized
rounding on its result which could raise
you up by an exponential factor so
they're just awful so the thing that's a
little weird about this problem is that
um for one thing that the very first
trick that somebody tried for this
problem actually worked which is a
little weird and also that unlike a lot
of other problems that aren't be hard
but easy to solve there's no
approximation results but yeah you're
absolutely right that I mean if you look
back to the 80's one of the things that
was true in the 80s was that there were
a lot of papers showing that NP hard
problems had very easy algorithms when
they came from very easy distributions
here another thing that's different is
that this is a very this is an np-hard
problem that has very easy instances
when you take them from good
distributions from distributions that
are what biologists say is their best
model of evolution and in that domain we
can still say yep if you run this it's
going to run in polynomial time and
that's a little surprising to but you're
right i mean there is a there's
obviously a tension between those two
days there's two different quite
divergent disciplines for agra rhythm
analysis
yeah the question is why should you care
about haplotypes aren't genotypes good
enough in some sense um and I mean some
people are still arguing about this the
hapmap project which is the project that
actually first identified it was that
was completed last year that identified
well actually it identified genotypes
for about 270 people around the world
and then used a different software kind
of to solve a problem similar the one
that I presented today to infer
haplotypes um so that's the the best
state of the art stuff that we have in
this discipline right now um it's not
the case that uh there are certainly a
fair number of domains in which or
diseases in which it's clear that
knowing what came together on the
chromosome actually gives you a lot more
important value than just having one or
the other it's rather than just having
the ambiguity found in genotypes it's
not the case yet that it's a total win
but it's clear that that's going to be
very important in particular because
certain genes will be tracking also with
the promoter regions that govern their
expression it's very clear that that
that getting that that association
correct getting that inference correct
is going to matter a lot but you're
right it's still I mean we say this is
though of course it's obvious you're
going to want to do this but with the
exception of things like well the
transplantation rejection case it's not
as cut and dried yet yeah
right so if you know family structure
this problem is vastly easier um if you
know family so the problem that I
presented to you was here's these
genotypes these people are I don't think
they're related if you know that this
person and this person are the children
of this person in this person um even if
you don't know the parental genotypes
the problem is gum is vastly simpler um
and and in fact that that allows you to
do much better than much faster analysis
to solve it
no and in fact of course that's the
reason y y1 y1 solves the haplotype in
problem for people who are transplant
patients differently although it can be
the case that so it is actually my
understanding is that I mean this this
domain of course changed dramatically in
the last five years once easy DNA
sequencing became possible but it is
apparently very helpful if you can
actually have parental and a paternal
and maternal DNA which isn't necessarily
possible for a transplant patient who
might not have siblings and parents um
so you're right the end so one way of
also addressing this is you can
haplotype gametes which is to say you
can take a sperm or egg cell sample of a
person and then that's a haplotype and
that because of recombination the
problem is a trivial but you can still
use that as a way of mapping back to try
to identify whether</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>