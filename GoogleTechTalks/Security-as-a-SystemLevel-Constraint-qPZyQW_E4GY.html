<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Security as a System-Level Constraint | Coder Coacher - Coaching Coders</title><meta content="Security as a System-Level Constraint - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Security as a System-Level Constraint</b></h2><h5 class="post__date">2008-06-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qPZyQW_E4GY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm very pleased to welcome Perry
Alexander he's going to talk about
system level design and security
thanks John I'm going to give a largely
non-technical talk about some new work
that's been going on in my lab that
deals with system level security which
is only we've been dealing with it for a
while but I'm going to look at it in a
slightly different way for a different
project before I get started I have to
acknowledge the people that I'm working
with Gary minden and Joe Evans are also
investigators in this project they are
software-defined radio people networking
folks that they kind of keep us grounded
and I have to acknowledge also Guerin
kimmel and Ed comp who are the really
really smart guys who do all the work I
also should acknowledge that part of the
work that that I'm presenting today was
is currently being sponsored by DARPA
I'm going to start with a quote that
kind of sums up the problem that that I
try to deal with it's cool by Kurt
girdle that basically says the more i
think about language the more it amazes
me that people people ever understand
each other one of the problems that the
i guess the problem area that I spend
most of my time working in is called
system level design or systems
engineering where you're you're
responsible for bringing together
different aspects or different facets of
a design and understanding what those
different facets mean together and it's
often the case that the people who
design or care about different aspects
of a system talk different languages and
think in different ways and bringing
that information together can be a
challenge I'm going to talk today about
about software-defined radios and I
don't know how I never know when I go
anywhere how familiar people are with
the software-defined radio community but
basically what it's about is radios are
currently one-shot designs right now if
you go to the store and you buy a radio
that radio will do precisely one thing
you can't reconfigure it to you can't
reconfigure a radio to all of a sudden
implement a new protocol the idea of a
software-defined radio is let's treat
the radio like a PC like a computing
platform and we'll compile radio
descriptions down to that platform and
the same in the same way that we do it
for pcs so the notion of a
software-defined radios is very popular
right now I was trying to make the radio
up
a commodity platform you buy a radio and
you can go out and buy different
waveforms that you're going to implement
on that radio the cognitive radio is
even more interesting the cognitive
radio takes I guess they don't have to
necessarily be software-defined radios
but they typically are the cognitive
radio is a radio that senses in is aware
of its environment so for example if i
took a radio that was operating in the
US and i took it to germany and i turned
it on it would understand where it is
and and it would reconfigure its
policies to deal with spectrum
management in germany rather than the
u.s. other things optimizing
communications policy adherence already
mentioned electro space resource
management these are the kinds of things
that cognitive radios are designed to
deal with so you have a front end on
this radio that's actually doing some
reasoning some sensing of the world
around it and reconfiguring according to
what it senses this is all a part of
this is this is all actually all over
everywhere but the part of it that I
deal with is called the joint tactical
radio system which is is where the
military is going with these radios and
I put this up because they call this
jitters and if you know anything about
radios jitters is jitter as a horrible
horrible thing to have in radios but JT
RS is is that is the acronym and what
we're trying to do is define a way of
synthesizing these radios and
synthesizing these radios in a way that
guarantees that they will meet certain
kinds of constraints system level
security being being one of them I have
this slide up because this is this is
the list of a subset of the radios that
are in production today that s dr's will
implement and I I don't put this up to
talk about any of the specific radios
but simply to say that you have to
implement all of these radically
different radios on a single platform
and all of these radios will require
certification they all have to go
through a government certification
process before they'll ever be fielded
well it's hard enough when you have a
one-off box that that could that
implements one radio to get that radio
certified well now you have a system of
compiling a radio description to a
platform that certification process has
become an enormously
more difficult process so one of the
things that we're trying to address is
how do we certify certain things in
particular security when we synthesize
these radios so this is an architecture
this is what's called a waveform
architecture it's it's a generic picture
of what a transmitter and receiver
looked like this is the first picture
that you see on the cover of our
proposals it's the picture that shows up
on all of the nice glossies and whatnot
and this is the first picture that I saw
of a software-defined radio and this is
a cool picture if you're a synthesis
person or a verification person this is
awesome it's data flow you put in data
in the front end it goes through this
series of transformations that do
various different things communicate
over a channel and you reverse the
transformations on the other side it's
data flow I can do this I'm excited I'm
excited problem is it's not when we
start thinking about some other aspects
of the radio we have to start thinking
about about issues other than just
transform transforming data other than
just getting data from one place to the
other the cysts that one of the areas
that I'm particularly interested in is
looking at the security of these radios
if I'm going to feel the radio be it
civilian or military I want to know
certain things about my data and the way
my date is being handled so that I'm
going to start out by thinking about the
three fundamental aspects of security
confidentiality availability and
integrity the standard CIA model not CIA
Central Intelligence Agency but but
confident she confident she ality
integrity and availability so I'm going
to start thinking about what what where
these things manifest themselves in the
radio well the first thing I'm going to
go to is the encryption and decryption
components that's going to give me a
pretty good picture or it's going to
give me a pretty large piece of the
functionality that I need to have I have
solid an encryption and decryption well
I've got a problem all of a sudden when
I start thinking about about exchanging
keys and doing authentication I'm not
following my nice data flow pattern
anymore now I've got out of band
communication to get my keys exchange
I've got authentication that goes on and
these things impact confident
confidentiality and integrity so I've
got to worry about this this new aspect
that's outside of my main data flow but
that's not bad we understand we
understand these aspects of a radio we
understand encryption is well understood
key exchanges well understood this is
not a problem however we do have a
problem when we start looking further
the next point I started looking at the
radio people want to start looking at
modulation and demodulation because we
understand that really well that's a
place where my students and colleagues
who are working on software synthesis
can talk to the radio designers because
modulation is a pretty easy thing to
understand all of a sudden we have a
different set of security concerns we
have to deal with with establishing
frequency hop sets if you're doing a
frequency hopper a style of establishing
hop rate and all of a sudden you have a
completely different set of people
talking about a completely different set
of security requirements but they impact
the same things that we're concerned
about if your hop rate is known you
can't communicate confidence
confidentially you can be snooped if
your hop rate is known you can easily be
jammed therefore your availability drops
so now we have these system level
requirements that are being impacted by
the only two aspects of the radio that
we've really looked at so far well if we
keep going now we start thinking about
error control introducing a coding
scheme this is going to going to impact
integrity and availability and I can go
on and step through all of the different
aspects of the radio or all the
different elements of the radio and talk
about how what they do impacts the
system level requirements problem is
that the guys who are talking mod and
diamond and the guys that are talking
encryption and decryption are talking
fundamentally different ways and in
front there speaking fundamentally
different languages they probably don't
even hang out in the same building so
you've got to somehow get all of these
folks information in one place and being
able to be able to deal with it together
we have further problems in that this
radio also has operational modes it has
a setup mode and it has a teardown mode
and those modes are different than the
operational mode when you're going
through set up
you have to know that the radio that you
end up with can be trusted when you go
through teardown you have to know that
none of your secrets have been exposed
you have to know that you aren't
violating security problems you have to
also know that you can get the radio
back when you tear it down when you shut
it off so we also have different
operating modes that we have to deal
with in addition to the different
aspects of security and finally we're
going to start thinking about other
other issues besides security because
they play an important role power for
example power attacks are very common if
one of the ways to eliminate a radio is
to drains battery particularly if you're
looking at sensor nets or some other
kind of radio that can't be associated
with a large power supply cost is an
enormous problem form factor also when
you start talking about a backpack radio
that's the size of a kitchen
refrigerator you've got a problem so
form factor is also an issue and we're
also looking at this notion of
evaluation and certification as another
constraint that we have to deal with so
the idea here is what we want to be able
to do is make system level guarantees
about this entire radio when multiple
people are going to be involved in the
design and multiple people speaking
different kinds of languages are going
to contribute to the radio design so
when we talk about system level modeling
issues in the radio I've hit most of
these already but just a quick review
we've got multiple heterogeneous
perspective we have the information
security folks up on top looking at
encryption and decryption we have the
analog and digital signal processing
guys very different languages energy
real-time form factor all kinds of
things going on there we have
heterogeneous domains or different
languages that people are talking some
folks are using continuous time and
frequency domain other are use others
are thinking about digital signal
processing and others yet are looking at
temporal and modal logic stew think
about security at it at the information
level I mention we have multiple
operating modes set up operation and
teardown and finally we have we have a
system architecture that we have to deal
with you can't just throw the baby out
with the bathwater and start a fresh
you've got a system architecture that
you have to deal with and we have to
think about about decomposing this this
thing and putting it back together so
for the last about nine years I've been
working on a language with with with a
number of people called Rosetta Rosetta
is a system level description language
that's currently being standardized by
Triple E for dealing with this kind of
problem it explicitly provides support
for concurrent system level design
concurrent design is is is the the lingo
I guess we're thinking about multiple
different perspective simultaneously it
provides something called facets and
components for defining individual
models domains for defining multiple
multiple models of computation or
multiple vocabularies for design a facet
algebra for composing models and a
mechanism for defining interactions
between models that don't share a common
language or they don't share a complete
common language the semantics of rosette
is formal it has a set theoretic
dependent type system it's very similar
to to what you'd find in PBS it has a CO
algebraic semantics i would go i'll be
happy to go into that further with
anyone who wants to talk about it but it
turns out that college break semantics
are very nice for modeling the kind of
non terminating systems that we're
dealing with here there's an also an
algebraic semantics underneath for
defining local behavior I won't go into
the category theoretic model composition
operations will see that in a bit and
it's also reflective one of the things
we have to have is a way to reflect on
our specifications and one of the
biggest things we provide is this notion
of a heterogeneous extensible domain
system and I'll talk some about that in
a bit but basically what it does it
gives us the ability to relate different
languages for representing different
characteristics and then also defining
how new languages are integrating new
languages in defining how they interact
with existing ones a standard slide I
use a lot when I talk about rosetta is
is the anatomy of Rosetta spec all this
sounds good but but a picture is a
really nice thing to have so I related
specification is written around
something called
fassett i'll show you example of that
just a second a facet is a single
specification in one domain one system
aspect in fact it very much resembles an
aspect and aspect-oriented programming
facets are written around something
called a domain and a domain provides a
language for or our vocabulary for
writing specifications remember what I
said that that the folks that are
working on these radios that we care
about all talk different ways they all
speak different languages we have to
have a way of embedding that language in
our specification system where we have
no hope so we have these things called
domains that we write facets around
we're going to take facets and compose
them we're going to compose them we're
going to perform what we call a
horizontal or sees me vertical
composition we're going to put them
together and say this collection of
models defines a single component we're
also going to excel them structurally
and talk about a collection of
components defining a system a
collection of interaction interacting
components defining a system and this
comes largely from hardware modeling but
the notion of structure is becoming more
and more prevalent over the last say ten
years in soft remodeling but when we
first started talking about rosetta to
software folks the notion of structure
seemed kind of kind of odd but now that
that's that's very very much changed
then we define something called
interactions between facets that allow
if I have one facet in one domain that
that that impacts another facet and
another domain i can move information
across boundaries and get those those
components to communicate and we also
have interactions will reach across
components predominantly through
interfaces but we can also define
interactions that allow communication
across components what I'd like to do is
is is kind of step in to what Rosetta
looks like and talk a little bit about
the way we do specification as I as I
mentioned the the facet is a single
model of a system aspect and what this
facet this facet is taken from the
actual body of specifications that we
use for software-defined radios this
particular facet defines a QAM
modulation function and if you know a
little bit about QAM I
got a definition for what qm it QAM dot
is down at the bottom but basically I've
got an enable signal that's going to
turn the modulator on and off and the
inputs are related to the outputs by by
this this term otek equals enable and
QAM modulation function now the
interesting thing that's going on here
is the domain that this is written in is
discrete time so I have the notion of
state in this domain and I have the
notion of a next state so i have tick i
have in specification parlance tick
always means next so tick is defined by
the state-based domain which is which it
is is extended to give us discrete time
so the notion of tick it has an explicit
definition it's there and it one's not
guessing about what that thing means
parameters and variables provide a way
to allow fastest to communicate and also
be specialized we have the notion of
functions all functions are pure if we
don't have pure functions things get
messy really quickly one of the things
that that we've discovered in looking at
VHDL and the addition of global
variables is it's kind of a mess all of
a sudden dealing with the semantics of
global variables and how different
activities are synchronized becomes
quite difficult so that's what a facet
looks like you'll notice things are
borrowed from a lot of different
languages we've borrowed a lot from
larch one of my favorite specification
languages one of the very first that
I've learned we borrowed several things
from there the type system is very
reminiscent of PBS we've also in in the
definition of functions we borrowed
quite a lot from Haskell which is our
implementation language so we've we've
begged borrowed and steal from from the
best here to define Rosetta Rosetta also
allows the definition of something
called a component and the specs that I
end up writing the most end up being
components and I want to make sure that
that that the uniqueness of what a
component provides is well understood
there are three blocks to a component
the assumptions the definitions and the
implications the assumptions define a
collection of assumptions that must be
met before this component can be used if
you don't meet the
that the key is confidential then if I
use this component then I can't
guarantee that that the component will
behave properly the definition in this
case I'm simply referring to them to the
definition that you just saw the
definitions part gives me a set of
requirements for the model and then
finally the implications give me a
collection of correctness conditions
that must be met whenever I implement
this model and in particular the
definitions and the assumptions together
should imply the correctness conditions
now one thing that that we provide that
that's very important in system level
design is the notion of a justification
and you'll see the justification with
the the double arrow backwards
justifications are associated with
things that we want to be true and what
they do is they give us an argument for
those things to be true they are not
proofs they can be proofs but they are
not necessarily proofs so the hope is
that as the system designer puts this
together he or she is recording the the
assumptions that are made when a
components to find they're also
recording what what this component
should make true but they're also
recording the reasons why they believe
that these requirements are met it may
be a proof it may be a code review but I
can I can refer to whatever that is in
the justification and and this is
critically important for certification
if I can build my system this way and
the system certifier sits down and looks
through it I've given them an argument
for correctness for this for this system
and the component it turns out is where
we end up writing most of our
specification facets are are very very
useful and and they are actually used to
define the semantics of components but
the component it ends up being the
workhorse of our specification
activities and again this is a this is a
model that's taken directly from the
from the specs that we're writing right
now for the software-defined radio and
this is defining again the AES
modulation requirements i will say that
i fudged a little bit on the correctness
conditions but largely they're there
what they should be and the
justification refers to another system
level spec that that that we use to
justify that
particular implication so we can we can
also assemble I mentioned the notion of
structural design I can also assemble
components this is it what we call a
component waveform and it represents
that linear flow of components that we
saw on the first slide and it's
parameterised over components it stramit
rise over other models so want to
instantiate this thing what I'm
providing are these components
compression a yes modulation on these
things I'm providing those definitions
and plugging them together in a standard
way so i can define architectures and
instantiate those architectures in many
different ways of many different types
of components there is nothing I
wouldn't say there's anything
particularly unique to the architectures
they're pretty standard structural
things from as I said very similar the
hardware community yeah you have a
question yep that's a typo yes sorry
about that should be in component
waveform it's the third time i use the
slides and you're the first
congratulations you're the first person
that's got it so this is how we put put
components model two models together
structurally now moving forward I've
mentioned this notion of a domain I'm
going to go from from how we write
models to how the domains we write
models with are constructed how they're
put together how they're assembled I
mentioned already that domain domains to
find vocabularies perspex they form a
lattice that mathematically they form a
four they form a complete lattice which
gives us some properties that we really
want when we do verification and then
they deform a lattice because we define
we define domains by extending existing
domains we also define interactions
between between models to allow us to
explore system level properties and I'll
talk through this in the next few slides
here's an example domain lattice this as
of about eight months ago this was the
correct one it's not we've done some
revisions and I haven't updated my
slides but it's fairly close to what the
what the the actual domain lattice looks
like what this is defining is a
collection of domains in which we write
specifications we
start at the top with what's called the
null domain which is a basic co algebra
that gives us nothing we can't we can't
write really any specifications in that
at all we add to it all of the
mathematical ideas and notions kind of a
prelude to get what we call the static
domain it's static in the sense that it
has no notion of time it's not static in
the sense that we couldn't define time
in it we've kicked around what to call
this domain quite a lot but the static
domain has no notion of time it has no
notion of change as we see that the
lattice branch out what we see is the
notion of time and change being added
there could be also the notion of
physical what's the best way to say it a
physical change moving around a surface
for example but right now what we
predominantly counts and trading on our
temporal systems and on one side we have
a signal based semantics to the other
side we have a state based semantics
representing the dichotomy or that or
that the specification styles of process
algebra vs vs state-based specification
styles we further refine those these are
called unit of semantics specifications
there's no magic notion of what a unit
of semantics domain is it basically
simply provides a collection of
definitions that we're going to refine
later the model of computation
definitions gives the things that we
define in the unit of semantics
definitions meaning for example in
state-based I have state and change and
that's all I know I have stayed in
change and that's all I know so I'm
going to refine my state based
specification into continuous state
change and discrete take state change
and I can refine further down down the
lattice and define different kinds of
models so I also want to want to mention
real quickly the notion of moving things
around in in the domain lattice the
concept of a functor which allows us to
move things between specs there are
three kinds of functors extensions
homomorphisms and generalized functors
and I got the 10-minute slide back there
so i can't spend much time here but
extensions are exactly the way they
sound the blue arrows are I'm going to
take one spec and extend it I morphism
is
an extension but it does preserve
information and a generalized function
eat functor need not preserve
transformation over a over a transfer
over a functor so what we use these
things for us to move models around what
I'm going to do is write a motion of
security or model security in the
state-based domain and that will have
the notion of how things move as or how
things change as I move from state to
state and I can refine that if I have a
system whoops too fancy if I have a
system if I have a digital system what
I'm going to do is take my model
security and refine it down to the point
where I can talk about that that
specification with respect to my digital
system well I can also go up as well I
needn't just go down but the this this
particular example that that again comes
from our our radios world allows us to
move down so I can also use this is
basically a slide that depicts using
functors for refinement it's a it's a
repeat of the last slide so I'm going
I'm going to skip this for now happy to
talk to anybody outside or after the
talk we can also verify these
transformations in in the lattice by
using something called a Galois
connection one of my students is working
to prove that abstractions or sound when
we move up and down the Latics using a
Galois connection I can also compose
facets and I'm not going to have enough
time to do to do examples here but
suffice to say i have a collection of
operations that allow me to put models
together i have product in some which
are or and is a good way to think about
that homomorphism in equivalence
relations the notion of a functor is
simply a function over facets and i have
instantiation and inclusion capabilities
for including fast one facet in another
i have some examples of composing models
that I I'm again happy to share with
folks after the talk this is an example
of defining operation modes and
assembling those operational modes
disjunctive Lee I do the same thing
in the next model sorry in the next
model I put specifications conjunctive
ly to say that the AES specification
must satisfy its modulation definition
it also must satisfy his confidentiality
constraint and these are done using
products and sums standard category
theories definitions that I won't spend
any time on at all I spend the rest of
the time that i have on how we process
frazetta specs this is a picture of of
the the the rascal environment that we
use to process specifications and the
one of the key things I wanted to
mention was how we write the the
specific tools at the bottom we do this
using a technique using modular monadic
specification actually that the paper
that we presented it last year's
conference dealt with the way that we
write these these we write these these
language processors basically we take
bits of syntax right processors for each
of those bits of syntax and then built
then pull those processors together into
an algebra that defines a transformation
we also have defined and this is again
what our what our paper was about last
year we also define ways of assembling
transformations together and it sounds
like a very simple thing but because of
the magnetic nature of our transforms
the even sequencing can be a reasonably
complicated thing to do and as I said
this is this is work that we did last
year and presented at the conference so
you can go back and refer to our ASC
paper from last year the synthesis of
two software-defined radios is I've hit
most of this already designed once use
many defining radios for defining
domains for requirements definitions we
have a domain for radio component we
then instantiate that domain to do
various different things we define
domains for architectures and then glue
our components together and then we
define functors to do our synthesis and
our analysis of that system that we
build and this is what the this is the
outline of what what this specification
system looks like what the processing
system looks like we are taking our
specifications that we write
in a high-level specification domain
transform those into a waveform domain
then move to what we call the
intermediate domain which is where I
mentioned Deron kimmel and EDD comp
right now they're working on ways of
moving specs from the center media
domain into VHDL and good new radio so
that we can actually synthesize radios
and the interesting thing here is we're
taking the same spec to both places
we're synthesizing both Pedro VHDL that
we can run through a VHDL synthesis tool
and also synthesizing a new radio that
we can put on a board finally this is a
kind of a definition or a description of
why this is a hard problem what we have
is is abstraction across the top and
value down down the saw excuse me time
down the side what we're representing
here is a collection of values flowing
through the radio and what happens is as
we decrease our abstraction level to the
bit level our symbol rate doesn't change
but our bit rate does and our bit rate
changes between specs so we have a real
problem when we when we set about
synthesizing these things dealing with
the changes in in in symbol rate and bit
rate between components a little bit of
current status and then I'll close the
rosetta language definition I mentioned
is an itrip police or is becoming a
knight replace standard we're working
through the design animation standards
committee it's about seventy percent
complete there's a book out on rosetta
one that's that's in progress and it's
going to be in progress for quite a lot
longer at this point the rascal system
is is available for download if people
are interested in it although it's still
rough at this point right now we have a
parser printer AST non ate mostly
cursive and non recursive a STS those
things are completing quite usable that
the language that we use to develop
interpreters is is complete and
functional and we've got several papers
on that we have a prototype for
generating simulators that's also also
quite usable at this point although it's
a it's a little bit riddle it's still
quite usable the sow
and Isabelle interfaces that we're using
for checking specs are in developed
right now and I don't feel comfortable
handing those out at this point at all
we also have this nice Eclipse authoring
environment that we put together so
actual humans can use our tools for some
reason our sponsors thought running
command line tools wasn't such a whippy
thing so we put together an eclipse
interface and there are some other
active applications that are going on in
the in the Rosetta rascal world in
addition to the software-defined radio
synthesis we're looking at power-aware
design we're looking at specification of
a secure a secure operating system would
be the best way to say it also looking
at specification of trust across the
system between components and if you're
interested in this in more information
about what we're doing the standard
language status all these things you can
visit WWll rossetti lang gorg and and
catch up with what's with what we're
doing I should also mention I've got to
got to do an ad for the standards
committee we have a standards committee
that that meets very regularly to talk
about semantics and whatnot if anybody's
interested in participating in that we
would love more company particularly
more really smart company to help us
with the hard problems that we're
dealing with right now that's all I have
thank you questions yeah so you've
talked about like using this for
developing your radios but is that
basically is this useful for sort of
mere mortals that are just developing
software for like regular people though
during Radian regular humans if you were
just doing software that's kind of the
rosetta started out in the world of
hardware design what was what what
happened in the in the late 90s there
was a system level design revolution
that that came about in the hardware
community all of a sudden you're dealing
with chips that had multiple cores
frequently analog and and digital
components mixed together all kinds of
things working together and the decision
was made and I think a valid one
that the current set of design languages
VHDL in Verilog weren't going to we're
going to cut it there so there was a
movement to to move away from those
languages to try to find new things
rosetta was one of those things system
see if you free with that was another of
those I should also mention system
verilog and some of the VHDL extensions
what's what's happened with rosetta
though is what we did what we figured
out was that that the hardware community
was was less interested in this than the
software community was so yes we're
doing software radiat software-defined
radios with it but many of our other
projects for example I mentioned the
secure system is a purely software
system now in that system we do no
synthesis we don't try this up we've not
been asked to I suppose we could but we
try to analyze the system level
properties of a collection of virtual
machines working together to accomplish
a task so yeah you can go after software
with it it's not useful for going after
device drivers or something in something
low level if it's if it's fairly routine
code then I don't think it's very useful
for that but looking at system level
issues and integration of things that's
what we've designed it for Jamie what
about validating the Rosetta specs like
making sure that you got the right spec
do you have tools and techniques we
don't really we've looked a lot of
verification but we haven't looked a lot
of validation I will say that that I
mentioned the notion of a simulator and
be able to being able to generate a
simulator what we found and I think what
every person in the formal methods
community has found is that handing
people theorems and and limos and proofs
is no good it that doesn't convince
anybody what we have to have the
simulation capability that's the only
thing that's ever going to give us we
might get verification with the with
theorems and limos and whatnot but we're
not going to get validation what we hope
is that the simulation will give a give
the user an idea or a way of validating
what they're looking at but as far as
providing a formal way at a designated
way of doing validation we really don't
that right now Colin so I'm interested
in how open and your system and rosetta
is to other formalisms and tools so I
see that you have CSB but by the sound
of it sounds like you're you're
recreating the semantics for that
process algebra within the system but
equally you could have have a algebraic
interface and have a functor to look at
other tools model checking tools or
whatever it is that some the case yeah
that's a great question one of the
decisions that we have to make we had to
make this with the software-defined
radios every problem we approach is do
we stay in Roseto to do our analysis or
do we hop out and what you've what
you've said is exactly what we do if I
want to bounce out and use an existing
tool like sallar Isabelle i define a
FUNKER that will that will perform a
specification transformation and spit
out a model in a language appropriate
for Isabelle Oh or Sal or whatever it is
we happen to choose simulink would would
be what would be an option as well but
it's really hard to make this call about
is it better to stay in rosetta to stay
in the Rosetta semantics and do your
transformations in rosetta or is it
better to hop out and use an existing
tool and we've done both for for
simulation for verificar e for
verification we always hop out I'm not a
theorem prover guy I use them but I
don't write them I don't and I don't
need to rewrite them there's no way I'm
going to compete with what's out there
so for our Galois connection
verification we move out to Isabelle
we're working right now to move
specifications out to Sal for model
checking and Sal we've chosen simply
because that's what the sponsor wants to
see but for the synthesis stuff we stay
inside because we don't have a good
synthesis tool so a supplementary
question is is there a well-defined
method to a procedure for other people
to glue their tools techniques on to
your there is it's not particularly well
documented but
isn't that the standard response there
is but its optical duct they're very
much is and and that's something we have
to have beat you if for no other reason
the amount of legacy VHDL verilog C++
out there is absolutely huge and we
can't ask people to rebuild it so we
have to be able to move in and out of
Rosetta and that's something that that I
had I very quickly went through the
picture of the of how we build our
functors or how we build our tools with
the module Mac semantics that's the
standard way in which we which we do
this and we've got several examples of
it we have a we have a I think we have a
methodology but it's not written up any
place yet thank you I'm happy to sell
you my students though if you'd like if
you like some of it thanks a lot</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>