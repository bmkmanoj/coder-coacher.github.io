<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Redis - The Hacker's Database | Coder Coacher - Coaching Coders</title><meta content="Redis - The Hacker's Database - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Redis - The Hacker's Database</b></h2><h5 class="post__date">2010-12-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1BS3UVSLX-I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">it's a great honor for us to invite to
have a I think all a program here and
Amir is going to kept giving give us a
presentation of some open-source
database that if they use the IMP work
so but then then let's welcome Amir yes
Thank You Victor and thanks for the
invitation so I'm going to speak about
Redis which is open source database so
this presentation won't really be that
much about Redis
I mean Redis is the main theme but I
also hope to inspire and also talk about
how we solve things at work and what
problems we have faced it and how we
have solved them because I think alike
I don't really think Google will switch
to read this I mean you have your own
databases and so that's the reason why I
mean it will be about Redis but it will
be more than that so a bit about me I'm
co-founder and the developer of the I
have been there from the start and yeah
I have helped scale to millions of users
and billions it seems of data yeah so my
general interest isn't really up
databases I can code in almost anything
and I'm coding on both fraud and peg and
and doing all kinds of so yeah but
I do like scaling a lot and I do read a
lot about it and I do care a lot about
it yeah so my main philosophy is this
and it's a quote from ghost in the shell
which is a enemy movie from Japan and it
is your effort to remain what you are is
what limits you so I think that
developers should expand their horizons
and do well
lot of other things besides developing
and this is like design and copywriting
and just being more creative yeah so
let's begin on a journey on how work
ended up with Redis and what problems
really face and in this journey I will
present like what kind of problem really
forced us into using Redis and how
picking a database isn't really the most
the most crucial issue adding solving
problems and understanding problems and
solving them creatively and simply it's
much more important than just speaking a
database because a lot of times you can
save a lot of effort and a lot of money
by solving things differently so this is
the big problem we have faced and it is
a lot of data growth and this is based
by the way that social networks work so
the more users you get the more data you
get and actually this data grows grows
exponentially so this is a major issue
and this is why I like Twitter and a lot
of other states startups have faced it
major issues with scaling up and we have
faced this as well so there are
different approaches to solving such a
problem and one of them is the easy
solution you throw a lot of money at the
problem you buy a lot of hardware you
hire a lot of people and you build very
complex solutions and this solution
didn't work that well for us because we
aren't we don't have any venture capital
so we are using our own
and we can't just say okay we are going
to build two data centers to scale this
up so but on most problems you can do
some compromises and you can solve
things partially so and this is like I'd
better approach you find a solution
where the data grows linearly and where
you maybe don't solve every problem but
you solve them like good enough for most
use cases and how do you do this well
you're doing you do it by cheating so it
seems like you are solving the whole
problem but you aren't really and most
users don't really notice that you are
cheating so this is a great great quote
that really expresses this and it is
said that there is nothing so useless as
doing efficiently that which should not
be done at all so I mean if you are
solving like exponential problems with
exponential growth then and you don't
need to solve that those problems then
your effort is wasted and you have
probably waste of a lot of money as well
so let's take an example with Plurk and
it's it's without timelines I mean when
we started out we had like major issue
scaling and this is because our
timelines just grew and grew in size and
users come they start to follow users
they start to create content and then
over time it just gets bigger and bigger
and bigger and yeah you can scale this
but it requires tons of hardware so a
creative solution to this is to make
timelines a fixed size so this basically
means that
they can't grow that much I mean and it
means that your data also grows linearly
and what this also means is that there
are some constraints but yeah I'm and
those constraints are of course
significant but for the users they
mostly care about recent data and about
recent looks so no user Scrolls back
like a month in in time so it doesn't
really affect how they use the service
and we have solved this problem without
using much hardware and without using
much effort yeah so this is like I think
much more important than just speaking a
database it's like thinking about the
problem domain and solving things in a
smart way so you don't really have to
put CHUM's
yeah spend tons of time and money and
stuff like that after this I think you
also have to be yeah reading and
researching what others are doing and
the verb is really great for that I mean
you can follow some great blogs by like
Google engineers and all other kinds and
engineers that are blogging about their
experiences you can find articles like
on how big table is designed and you can
get all kinds of ideas how databases
work in general and how others have
solved similar problems and I think this
is also a very important step and it's
also that we have yeah we have been on
like scaling plug up and picking the
right database and coming into Redis and
then you can like
research on what performs best you can
do benchmarking profiling and all kinds
of tests like that to see which database
really suits your needs
hmm yeah so I want to tell you how we
came to use Redis and what pad we took
so we started out with my sequel which
many of you probably know it's a
relational database it works pretty well
but the problem is when you get a lot of
users a lot of usage then it does not
scale that well especially if you have
like exponential data growth then my
sequel isn't that good a solution so one
of the optimizations we did was like
okay we can't really let timelines grow
on an infinite size we have to limit it
and that's when we did that and we
implemented a distributed database
called light cloud which is open source
and yeah so we implemented mostly for
our time lines actually and we based our
database on something called Tokyo
tyrunt tyrunt which is a Japanese
database used by mixi which is a huge
Japanese social network and it's
implementing C and it's basically our
key value database with some pretty
interesting features and one of the most
interesting features is its lua
scripting so you can basically script
the database using lua
and this enables all kinds of
interesting opportunities and one of
those in opportunities was to implement
a fix that
list so that's what we did and that
helped us scale a lot maybe to add a few
million users but the problem is and
this is the problem by the most database
I've used is that once you start to hit
the disk and your data can't fit fit
into the active memory then the database
performance drops down a lot and this is
what we experience or experience with my
sequel and this is also I think we
experience with Saki observant and light
cloud so you really have to like come up
with with and more creative approach and
this approach is to store everything in
memory and this is where raddest comes
into play because it is mostly memory
only database so what this means is that
everything is stored in memory and it
sync to the disk once in a while so that
data is still persistent and this is
that they default behavior read is also
supports like a normal usage where
everything isn't stored in memory but
it's not really recommended so what this
office is like amazing performance and
the Redis performance is very similar to
memcache D or memcached so it can do
like hundred thousand set operations per
second or 80,000 ket operations per
seconds so this basically means that
currently we can like insert a hundred
thousand looks a second and that is like
many millions per minute and
billions Wow yeah so I mean it offers
really amazing performance yeah so I
like this quote and I think this sums up
the movement that is currently happening
in the database space and it is said
that memory is the new disk and this is
the new tape
so this basically means that the memory
will replace the hard disk and you can
see this movement a lot like vault DP
which is a relational database a new
relational database implemented by using
the memory mostly yeah so what does
Redis offer other than then a great
performance and in-memory features what
it offers is I think one of the most
interesting thing about it and it's rich
data types so relishing our data
database is like my sequel operate on
schemas tables columns rows indexes etc
column databases operate on a similar on
similar things while read is really
operates on key values sets lists and
hashes and I think the thing that is
most appealing about these data types is
that they resemble the data types that
we know in in common programming
languages and this makes it a lot easier
for us to think about the database I
mean I have used like my sequel for
about I don't know five to ten years
maybe and I still don't really
understand how how to read
we optimized it because it's so complex
and they are like many books written on
just how to pick the right indexes and I
think these complexities it's really
slowing us down and I think this is
where red is really is shining and will
shine in the future because it's just so
more much more natural to use of course
you can't I use Redis for everything I
mean if you are op you I mean if you
need like I relish in our database for
for your data then it doesn't make sense
to use Redis and I think this quote sums
up yeah what the philosophy is five read
by Redis and it is that the simplicity
is the ultimate sophistication and I
think that Redis hits that simplicity in
that you can solve a lot of problems
using just the normal data types found
in programming languages you don't
really need the features all the
features that like my sequel offers
because most applications you don't
really need them so now I will showcase
some code I have written that uses Redis
and that really shows how powerful Redis
is as a database and how can implement a
lot of different things using just those
simple primitives so I have implemented
something called the Redis trap which is
a wrapper for Revis and it basically
mimics the datatypes file in Python so a
programmer doesn't really know they are
using Redis
so the coat looks like normal Python
it's a bit hard to see I think but
basically I mean the problem is when you
use like something like my sequel you
have to like wrap your head around it
using Redis you can just use your
database as you use the normal Python
Python data types and I think this is
really powerful so we have a in the
first example in a mimics Python list so
you have something like append you have
length and you can use the in operator
and all this users read is but it's in
the background and all these operations
are atomic then you have like hashes
which mimic item dictionaries and it's
the same syntax as in semantics actually
as in Python so a programmer doesn't
really have to learn anything new they
can just use it and they don't even know
they are using Redis and the last one is
set so yeah and the whole implementation
of this is like under a hundred lines of
code and I don't think I mean you can
make other databases behave like this
but in red is this is just natural and
the performance of this is pretty
amazing and as we will see in the last
slide radius is currently adding a
distributed layer so you can like use
this on many thousands of machines and
have just our very powerful syntax so
and this is again simplicity and and
this is done by
or set by koishi cabana who designed
some gardens and he said that simplicity
means the achievement of maximum effect
with minimum means and I think read it
does exactly this and it enables you as
a programmer to achieve this so you can
implement like stuff in in a few lines
of code and it can do like all kinds of
things and in the next example we will
see how we can use Redis to implement a
simple graph and this graph can scale to
a few million knows currently by the
using something like Redis cluster in
the future it can scale to like many
thousands of machines and it's
implemented in under 40 lines of Python
code and it's also open source but I
mean anybody could implement so it's not
really there too big an issue so if we
see here we have the basic primitives of
graph we have add edge width which can
add edges between nodes we have a has
edge function which can tell us if there
is an edge between nodes it has
neighbors and it can delete edges and
then we can set node values and edge
values so this is the basic primitives
of 1/2 graph and like I said this is
super simple and it's you can use it to
implement all kinds of stuff with a
graph database like user recommendation
graphs are pretty useful for that or any
kind of recommendation where you need to
look at graphs structures
hmm so this is the basic implementation
and yeah for the lines of code so you
can see reddit enabled us to implement
something that maybe may seem complex
but in reality we can just skim it down
in maybe 30 minutes and be done with it
and like I said before Redis in the in
the future will be distributed so you
can like implement this and scale it on
thousands of machines and have a like
are really really powerful graph
database that fits your needs and you
can extend it in any in any way you like
so I think you can get a lot of
inspiration in a lot of different places
especially unlike IP design or database
design or I mean any kind of things and
this is from Charles Mingus who is like
a jazz god and he said that making the
simple complicated is commonplace
making the complicated simple also many
simple that's creativity and I think
what what Redis enables is like
creativity because you don't have to
like write 5,000 lines of code to
implement a graph database you can write
it in 50 lines and just explore many
different things so next we'll see how
to implement a queue so we use Redis for
our cues as well and we use them to
process like many millions of background
tasks and this is again a great example
of how you can just use the simple
primitives to implement something that
fits that is implement in 80 lines of
code
and that can process a lot of things and
in the future can scale like infinitely
mmm so the the basic you is that you can
put jobs in it you can reserve jobs and
then you can delete jobs and you can get
some stats so I mean that's very very
basic principles of a queue and all
those operations are atomic and this is
the basic implementation of it
so again yeah I mean it's pretty simple
and I don't think I mean I have used a
lot of databases before and I have never
used a database that enables such
simplicity and as such clearness as
ready to us so that's the reason or one
of the main reasons why I like it
because it's I mean it's it's just very
very nice to use and when I use like my
sequel I have to wrap my head around it
and I have to fight it and then it
doesn't really scale and then I have to
like come up or find magic solutions
where you can tweak a parameter and it
suddenly scales and stuff like that I I
don't I don't really think that's the
future of databases and I mean as Google
you probably have like maybe a similar
system to Redis that's like hidden from
away from you but the most other program
has done really have those kinds of
solutions so they have to like fight
with their favorite database system
no you don't everything it's lazy so
yeah it basically just fetches a
connection which is cached and then it
just does a list append operation to
Redis so you don't really fetch the list
it's committed right away I mean I think
actually that Redis is non-blocking
so maybe it's not committed right away
but I'm pretty sure that or it is atomic
so when it's done
I think it's committed but I'm actually
unsure I think also maybe that's confuse
you can configure that so yeah but I
mean Redis operates on memory so it's
like super fast any more questions about
this
yeah so Redis has two things first is
replication another it's like a pent log
so I think it keeps it on the disk but
you can keep it in the memory yeah but
you could keep it in memory then it's
not really but I'm pretty sure it keeps
it under this so and not really I think
the event log is updated in a
non-blocking manner but I think for most
cases you know if you just use
replication then it's not really an
issue and for us I mean if we lose like
five seconds of data it's not really
that critical I mean it depends on how
critical your data is yeah so it's true
that Redis offers less data security
than something like my sequel but I
don't think yeah III don't I don't think
it's that bad
I mean it's not an issue in like 99.99
of the cases yeah so I will talk about
Redis cluster
which i think is like the yeah it will
be a big thing because it will enable
scaling of Redis across many thousands
of machines and it uses very similar
scaling as BigTable and Cassandra and it
will just it will enable and I mean
currently the most use cases of Redis is
like a highly optimized database where
you just run it on a single computer and
that isn't really that smart so the
current solution you you do is like you
shut or partition manually and that that
is issue in a lot of cases so you really
want just a solution where the scaling
and distribution is hidden away from you
and this is what a Redis cluster will
offer and there's like a link here but
uh and currently it's like they don't
really know 100% how they are going to
implement it but they are working on it
and then you can follow that link and
it's like a presentation on how they
want to implement it but the basic ideas
of the implementation is the same as we
have seen in BigTable or we have seen
Cassandra and I think also scaling or
distributing Redis is much easier then
say my sequel because the data types are
much simpler then say my sequel joints
or relational database Jones so it just
makes a lot of things a lot of more
simpler and I'm really looking forward
to this feature and I think Redis in the
future can replace
like normal databases like my sequel
Cassandra or whatever because the
features as I have shown the features it
offers is pretty pretty much the core of
what you need in most applications yeah
so this is actually the end of my
presentation here and I will end it with
this quote and I don't really think that
Redis is that perfect right now or but I
think it's good enough and I think it
has a lot of great great ideas and I
think we can learn a lot from it in
terms of how to design our systems so
they are pretty simple and how to solve
problems in a very creative way and I
think solving problems in a smart way
and so on with problems like with
minimum means it's a lot more important
than just focusing on raw performance or
what kind of database is the best yeah
so any questions
if you want you have items on a list and
whose operation allowed iodine and push
it back I know that push a popper atomic
but will the composition of the whole
session yeah for some I mean Redis
offers transactions but you probably
want like a manual lock on top like a
distributed lock on top of that so if
you like fetch a list and do some
operations on it you probably want to
like lock it and we actually used those
kinds of locks in plugs code base but
they are implemented in on top of
memcache
yeah so it's like distributed lock I
mean the problem like with with the
employees of course we have different
servers and we have to ensure that two
servers aren't operating on the same
list yeah
in some cases I mean for most usages you
don't really have that issue but in some
usages you you do have that issue and I
think it can be solved pretty easily
using a distributed lock
the performance no less I don't know why
yeah I think maybe it's because it
doesn't return anything you know and I
think yeah III don't really know why
whites first action that's interesting
yeah it does depend so those performance
numbers far four key values they weren't
for lists but I think the performance is
very similar for lists and sets as well
so it's probably one of the fastest
databases I think
you can't really do that I mean the
thing you can do is like fetch the whole
list and then filter it in invitin yeah
but it does offer some things like
regular expression matching on keys so
you can like get all the keys that are
starting with a or something like that
the the pattern matching of keys is done
suicide by the the custom filtering has
to be done fine side yeah all the other
data we store in my sequel and yeah we
also still use the light cloud for some
things like analytics and we'll use like
Redis for for things that have to be
performed really well
yeah on the Redis website you can get
like the complexity of most of the
operations and I think most of them are
actually in constant time especially on
key values I mean the only like Oh n is
like a regular matching because it has
to buy life when you just access
something it should know we have it on
different machines but I mean like I
said with the with this is that
currently when you have to scale it up
you have to implement your own sharding
like you do in my sequel and that it's
like a big issue because it's just I
mean it can be optimized away and yeah
so currently we write we are like
manually sharding and partitioning but
we dreaded cluster it will be done
automatically
yeah you use ID yeah no yeah we don't
really have to do that but yeah you
could do that I mean yeah like when you
shot my sequel or any other relational
database you mostly like you have to do
joins in the client code yeah so the
same applies to read this but I think
actually with with Redis cluster it will
have like smart routing so it will it
will do the work for you
the the joints or anything that affects
like multiple servers and yeah that's I
think is the greatest thing that will
come
we actually don't really do that I mean
the thing is we store your plugs or I
use of lurks in my sequel so you can
only always fetch your own perks the
thing we done store is like all your
friends clerks and you can't actually
scroll back that much back in time I
think you can scroll back like 500
clerks back but you know most users I
don't think in the like three years time
we have received very few complaints
about that
so most users don't really know their
their timelines are limited they are
cheated yeah yeah you can find your own
and private but it's like you're all the
others you can't really find
you can you can is yeah if you only
search on your own but you can also
search on other users it's just like
your general timeline of all your
friends perks you can't really search
that but that is also the biggest issue
in scamming like blur
it's the dead timeline of all the users
because it has most blogs I mean most
users look a few times a few clerks they
yeah they don't like the thousands and
thousands
more questions
I'm actually unsure about it I don't
think you can put anything I think it's
very limited maybe only a s key that's
true but I mean you only allocate a
certain size so so it never grows like
it has only a certain size so each user
you get I mean it grows in size for his
own plugs but yeah
and yeah that's not yeah so maybe like
the day the patterns aren't really like
linear that but they aren't like
exponential because they just grow yeah
they grow a bit but it's not an issue
because most users don't put that that
much that its size it's much worse like
when you have all your friends yeah when
you have like a timeline with all your
friends plugs and it just keeps getting
bigger and bigger
yeah then you have a problem but I mean
that problem can be easily solved by
just like allocating more space for for
your user I mean yeah yeah but I think
you know most users can't really follow
like I mean then they wouldn't really do
much else other than working if they
like which is in real life in the
offline world you really only have a
maximum about like 150 relationships
that you can you know very intimate
relationships you really know about same
thing with the time line once you start
to add hundreds and hundreds of people
you know your time line is rendered
ineffective so it's the same if you know
it you just if you have put in your
falling in thousands and thousand people
you just move yourself in all that data
so there's a there's a certain limit we
have kind of the approach that we've
taken to our UI that you can only follow
a couple hundred people before you know
you say this is too much and it's
information overload that that approach
tends to mimic you know real human
interaction
I'm gonna psychology behind why we've
done things yeah it's not a limit that
it's that it's still engaging and that
we can keep users attention span on
clerks and actually you know interact
rather than just like you know with
Twitter you have so much same with
Facebook there's really no limits you
then you continue to add friend and
friend and friends and then you know
you're you completely sucked into the
system so it's just like you know I'm
gonna be spending you know six seven
hours on Facebook wanting to know when
is it enough there's no limit or there's
no constraints more of a it's it's just
not a very clean system or it it's not
really meant for the users benefit I
mean I think we care a little bit more
about our users and so we sort of
develop things in a way that keeps that
in mind
that's which mo yeah and your payload is
we fight yeah I don't know I mean the
benchmarks should probably be taken with
a grain of salt sell salt because that's
why you can't no I think it's just they
have just done some butter
I mean that performance is pretty very
good so I generally don't really trust
benchmarks that much because you can
cheat on them because said operation is
quicker and get operation is quite
country yeah yeah it is trying to figure
why that is a good reason I think thank
you guys
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>