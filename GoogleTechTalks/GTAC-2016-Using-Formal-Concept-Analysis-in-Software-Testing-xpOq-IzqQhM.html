<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GTAC 2016: Using Formal Concept Analysis in Software Testing | Coder Coacher - Coaching Coders</title><meta content="GTAC 2016: Using Formal Concept Analysis in Software Testing - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>GTAC 2016: Using Formal Concept Analysis in Software Testing</b></h2><h5 class="post__date">2016-12-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xpOq-IzqQhM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so let's get right to it next lightning
talk is from fedor or he goes by Ted but
he also has a fascinating history about
his name that you should ask about
afterwards and you take it away okay
thank you okay here it is
so my talk will be about using formal
concept analysis whichever it is I guess
that nobody here have ever heard about
formal concept analysis am i right
yeah that's the case so I have a double
affiliation so one of them is Yandex and
the other one is higher School of
Economics and so it is the theory comes
back from high school of economics and
the practical tasks from Yandex so it
would be a challenge so I would wish to
be able to use the previous experience
but nobody today told any words about
model-based so just to remember some key
facts about this it is a kind of cycle
between the abstract things like models
and abstract tests and the real wife or
have the system and the tests that you
run and there are several ways how to
get actually the model it could be
obtained either like Oracle that is kind
of implementation that works just
requirements are and so the other hand
is to get that sequences which should be
ran over the system under test and after
you implement the model you can get the
test output whether it is possible fail
and as for the modeling there are
several approaches how to do this
exactly first of all is to extract from
the existing system how does it really
works it is of a special interest in the
project with long history and a lot of
product features the other hand is to
model before implementation that will be
quite applicable to crucial pinks and
and so the third approach is just what
we see in the real wife and just to
build both of the system and the model
so the alternative is just to do it
online or find whether we use the system
under test or not and in offline case we
could just generate test cases and
somehow postpone them to the system
under test so four possible
implementations of the model-based there
is a set of them like they are implement
state machines and so on so forth
and now I would like to say some words
about the theory that is completed from
the other hand in terms of test case
derivation so it came from algebraic
theories it is rather new it is called
formal concept analysis and it's mainly
works with such thing as formal context
it is a triple when you have a set of
objects sets of attributes and binary
relation over these things and this
binary relation means that an object has
an attributes
quite intuitive and so then we have
special operator that shown with this
quotation mark and they say that from
the set of objects we can get all the
attributes that are common for them and
twice words from a set of attributes
gets the set of objects that has all the
show attributes and how can we use this
actually we can find in some sense
maximal subsets of objects and child
attributes which share and form the
ideal concept or the concepts it means
that you have set objects they share
some set of attributes and this set of
attributes is just general for all the
objects and these objects can be this
concept could be natural ordered with
the such kind of think like sensitive
operations you mean that one concept is
more general than the other if all
objects are just included so the
intuition behind this is like this that
you have all attributes and in rewards
usually no object has all tributes it's
a kind of both
concept and on the top you have the very
situation where you have all objects and
usually they do not have any common
attributes and then we can proceed to
such a concept as a implication
implication is just designed to show the
dependencies between sets of attributes
so there is a mathematical concept how
to show the implication but in natural
world it's can be described in the
following way if you have an implication
from A to B it means that all objects
that have a letter also have B there is
some system that could make more
implications from the basic theories so
there are called Armstrong rules for
example you can have always written the
rule if you have a then you have a and
some more interesting things like you
can add attributes to the left-hand side
which is called promise and it is a
restriction on the set of object that
you are just interested in and so so how
can we use this to get from the comb
from our context and set of implications
there is a procedure called an attribute
exploration the main advantage of this
procedure that it is interactive and it
cooperates with two types of data on one
hand it is a set of implications so you
have the dependencies that are expressed
in the form if a then B and on the other
hand you have a set of counter examples
and they're just you've for more context
so I have them available on github you
can just proceed with the following
example with me to make things easier
and going to easy for what was
considered an example let us have a
simple program and input it just one
number and the output is a set of
features of a given number I took and
taken to consideration just five of them
like even old prime factorial e until
the number is divided by 3 so this
attribute the exploration procedure
starts with the following it just asked
choose whether some implications are
true or false for example it starts with
like following is it true that all
numbers share all the features from the
given set and will have to provide the
contour example for the system to make
it understand that the world is built in
some other way for example I took the
number two and have to describe it in
terms of features the type that it is
even factorial and Prime and then the
system thing that's all the numbers Ajay
just like the two and say that every
number is even factor and Prime and so
on so forth I could provide cons are
examples fill in my table which is just
the representation of binary relation or
formal contacts at the same things and
when I proceed with answering the
questions at some moments I give the
implication that really should stay true
for example yet if you have factorial
divided by 3 then it is even yep we
can't think of theory of numbers and if
we consider a factorial number which is
divided by 3 it already has a 3 in its
the we in divisors and so it has 2 just
by the definition of factorial so yes it
should be even and then after the
procedure just takes you the whole way
from all the implications you get two
types of knowledge actually on the one
hand you get this set of contr examples
which say that there are typical number
that you should check and for this
procedure to work you need a domain
expert that should precisely know how
the domain is just organized so it would
be difficult for an inventory person to
fill the features if he's not equated
with the domain specific specific
features and so in the end there are two
types on the left hand side we can see
all the implications that hold for our
small loads of numbers described in
terms of five attributes that
example if the number is prime and
divided Madrid then it is old and so on
and in some sense it is very likely to
walk like a model based because you have
a set of dependencies and somehow you
could generate the things on the right
hand side but to make the difference
more clear we could try to write so this
example in terms of model based so we'll
have a set of outputs and there are two
just two values for them true or false
so everything is quite easy and for
example using pairwise we get the sets
of outputs that could be in no way
it's crept in real world then we have to
think of conditions and check that not
all of these numbers adjusting the set
of em and then we have to consider that
if we would like to have the jail the
same numbers we could add them as a
result and moreover have to consider the
implications for the model-based they're
just written as in the previous thing if
you have something then you have
something and that's implication for the
case of model-based would be of two
types first of them is just to say what
are the implication that we get through
attribute exploration and on the other
hat so there should be some data-driven
just to match the result with the output
so in the end we finally set up with the
same representation so the binary table
is just like I get from the formal
concept analysis and so what are the
main pros of the approach of using
attributes exploration you have two
parts of the result on one hand it is
test cases just written in the form of
objects and then on the hand you have a
dependencies between attributes and you
do not have to keep track in the head of
all the possibilities that are just able
to be so this procedure just stores
information also the set of attributes
can be
extend it at any moment and you can
start from any part you can provide some
counter examples and ask water
applications for these examples and then
to proceed and if you just decided to
extend the set of attributes what you
have to do for the existing objects you
have to mark what objects just really
has this attribute so the other very
nice approach how to use the formal
concept analysis toward software testing
we can consider the following obtaining
a formal context just using white box
sickening
for example usually the program has the
sets of ifs and then it proceeds to the
output to their return statement and how
to get all the cases done we just can
get labels to each switch statement and
then we can see all the our ways from
the beginning just till to the end and
in this way it's to a formal context so
you have sets of objects that correspond
to the paths across your program and on
the other hand you have labels which if
you have covered then you just do this
intuitive procedure of covering all the
paths in your graph and you end with
such a nice picture that's all the tests
that you should do is just shown on the
right hand side one thing that is not
very intuitive that's the implications
in this form they are just about the
presence of attributes so on the left
hand side there is a small formal
context and according to the theory
behind it I'll have to write that there
is a dependency that even you have just
one attribute just one object and it has
just one attribute B then you have the
implication then from a B and C it is so
because there is a nice rule that if you
have something wrong on the web front
side then any statement would be right
just from the definition of complication
and how to avoid it you could just
consider or attribute how as a pair of
attributes it's actually voice in the
case with the numbers we now have even
and odd numbers there is no number that
which is simultaneously even adult so
another quite good thing about formal
concept analysis that you can use this
nature order on concepts for example to
get a nice test report so this partial
order by some subchannel extends or
intent so about on the sets of objects
are on the sets of attributes and all
these concepts formalizes just to be
brief for example have such kind of test
report so some tests are just fails and
some of them are not we're interested in
the failed part we start from drawing
the whole angiogram of the wedges so
they're ordered from the beginner on the
bottom there is no objects and on the
top there are all tests in some sense so
then we focus on the failed part and we
get that the most common feature that
they share is just one feature and down
side you have some more details about
whether at several cases they have
failed so this way just use it's just a
good thing because iceberg analysis is
equal to finding the most common
descriptions of failed tests so this is
of extremely use in big systems with the
tons of tests and there is a graphical
representation how to get a use of it on
the other hand in big systems this
technique could be very useful to get a
good representation for finding similar
functionality that would that would be
of a special interest if you just do
with feature that's a quite common and
you have almost the same test and how to
find this for the same test so about the
future work this framework is quite
useful but unfortunately there are some
borders example
do not use non binary attributes but it
is doable it is called pattern
structures and there's a part of future
work and another thing we could use
machine learning based on these formal
concept analysis we can just find
hypotheses why some test failed and this
iceberg picture is just a good glitch
how to do this so thank you I just hope
that this talk was a bit inspiring and
you can find me in the break and give
the questions for you the online
contacts excellent thank you I just have
to wonder is if we use this model can we
use it to actually figure out JavaScript
operations actually yeah because there
are some researcher then research that
use these techniques to explore the
world to forge a break structures and I
believe that javascript is more bounded
oh well that would be work I killed
JavaScript because I care people I
actually like this really and we just
have one question
do you have to provide counter examples
manually or can it be automated cons for
examples should be provided manually but
so there are some researchers when you
have to find out the features of the
counter example and so this part could
be automated so if you could find that
here is an object and what attributes
are typical for him this part could be
automated
so the procedure overall is same
estimated you don't have to keep track
of all the possibilities because you
just answer one question at a time
but this knowledge of domain is really
useful here no excellent thank you again
it's another round applause for federal
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>