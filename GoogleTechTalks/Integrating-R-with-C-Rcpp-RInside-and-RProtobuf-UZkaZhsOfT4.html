<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Integrating R with C++: Rcpp, RInside, and RProtobuf | Coder Coacher - Coaching Coders</title><meta content="Integrating R with C++: Rcpp, RInside, and RProtobuf - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Integrating R with C++: Rcpp, RInside, and RProtobuf</b></h2><h5 class="post__date">2010-10-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UZkaZhsOfT4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well first of all I'd like to thank
Google for the opportunity to share some
of the work we've been doing around RN
C++ on a personal note I you know I've
been using our for for so many years now
for about 10 years and the joke I
usually say now is that it almost feels
like I'm married to to language to our
language I am I I keep having fun with
the language I keep learning new things
about about you know about our I keep
being really interested in this language
although it doesn't mean though that I
don't often like to spend time with
other languages you know having a few
indiscretions with with you know other
other sorts of languages I've had a long
long-term story on the side with Java we
sort of we're not talking too much to
each other anymore these days but this
was a nice relationship so when Doug
introduced me to C++ last year I really
spend a lot of time now with C++ and I'm
really happy to to learn this language
and and and now what we want to do today
is share some of the work we've done and
show this indiscretion obviously Dirk
has spent much more time than me over
the years with C++ ah I've just started
a year ago but we've managed to do quite
a substantial amount of work since then
and so this is what we want to share
with you today okay Jinyu yeah let me
just briefly share what romance said and
say thank you to to Google for having us
and Marie for making this this happen
this is this is really nice we're
sorting going to talk about I and C++
and connections in a large sense the
bridge that was on the previous example
will come again as a metaphor and here's
just a few points sort of what we
assuming so
generally speaking everything should
work with current packages on all
supported operating systems exceptions
noted so we didn't have a protocol
buffer binary on Windows that's
something that we may sort out and some
of the most recent slides assume the
version of other was released last week
and also we made shortcuts and things so
then as an introduction we weren't quite
sure who we'd be talking to experienced
long time I users or you know otherwise
computer scientists interested by us so
you know just just to get warmed up
here's a really simple example on why
you would want to work with our that
that crossed sort of my daily readings
that was on the mailing list the other
day and in the beginning it's just sort
of three statements sort of we assign
from one of the given data sets it's
sort of a bit like a running joke that
in are many things are on standard data
sets so eruptions of the faithful
Ricardo are one so we're just assigning
those we're fitting a density function
we plot those with three standards
nothing special about that but the
actual example that was shown was the
following so with just four more
statements you get you know a Monte
Carlo replication over 10,000 repeats of
estimating this density then taking
quantiles out and hence seeing the the
uncertainty around that density
estimates as well as the fit itself and
that you know why we keep using R
because it's not that easy to do this in
certain statements with another language
so with that let's sort of take R as a
given and once you work with it in our
curious about pushing it a little you
think about extending it so that's
that's how we got here sort of extending
@yr C++ extending our is covered in two
chapters in John Chambers most recent
book and that sort of really spoke to me
when I first read that so I just want to
highlight what what he's set here which
is you know it's it's I itself the
interpreter is the C language program so
you can extend it easily from C but it
may not be as easy as it seems so he
says there are some edit dangers and
then maybe a substantial amount of
programming and debugging involved so he
discusses this a little bit more and
puts a road map up with a couple of
points against if you do this it's more
work than programming enough if you get
bugs they will be nasty if this may
introduce potential platform
dependencies and your code may be less
readable may or may not be however if
you do this you can go and into
uncharted waters there's the directive
and the mission of course all throughout
the book so you know can you can you can
boldly go and try things that haven't
been done before you may also just reap
speed and there was something already
about object references we will come
back to that but basically one of the
two extension paradigms in our made that
relatively easy so you know I grew up
with a lot of soccer around me if I look
at that it's the score of four to three
towards the end so it's the deck stacked
against err should we do this or should
we not do this and what we want to do
with this talk is to convince you that
absolutely you should do this because
you pick the half that you're playing in
and we hope to convince you that we're
sort of some of the tools that we've
worked on it gets a lot easier so
remember from the opening slide there
was a bridge bridge as a metaphor to get
from one language to the other and that
bridge we'll come back to it briefly is
sort of a dangerous bridge what we are
sort of trying to think is that you know
the work that we're putting together of
course it's not quite as impressive as
Norman Foster's work but it's more sort
of along the lines of this and this is
actually something relatively close to
to where o man lives in Montpelier and
it shapes an hour or more than an hour
office office travel time so you know it
gets you different places it's well
engineered it's safe travels and a lot
faster so works for us so what are we
going to talk about it's mostly about
our CPP and a couple of other projects
that came along with it the goal is to
make the integration between R and C++
easier and more seamless this uses a
standard interface in the our system the
DOT call interface on longer talks are
sometimes mention also the the preceding
ones but let's just let's just work on
this and basically it operates on a
standard you
in style data of structure on inputs as
well as outputs we do come back to that
what a CV offers then is the natural
mapping between objects in sort of the
programming sense between R and C++
using C++ classes we've also did some
work that helps tremendously for
prototyping using a package called
inline work by somebody else that we've
extended to use it in this context it
also heavily used by us we have over 700
unit tests in the package and they
basically all use use inline we will
show how that works
this puts no additional hurdles and
burdens on you for package building and
you know some extensions that came along
helped with other things like highly
efficient math using other recent C++
tricks and I think we'll come to that as
well
shall we why don't you do to him so okay
so essentially what what what Dirk said
before with with the other side is that
there is an existing bridge I mean are
already lets you connect to C or C++ out
of the box but we feel that to be able
to cross this bridge you have to wear a
nice fedora hat and and another web and
well not everybody you know does that so
we believe we can make a better bridge I
am there so this this is sort of a
comeback from previous slides so R is a
C program and then so quite easily lets
you hook mount our with with our other C
extensions and any easily extends to C++
as well all you have to do is include
adult CPP file in a specific place in
your package and and you're able to use
C++ but you do this through a C API
which is essentially you know C
functions and n macros and
we believe we can encapsulate things
much more nicely and then with what
we've done with our CPP so the sort of
the sort of function we will see here a
function that all looked the same they
that take one well they take zero one or
up to 65 our object any our object is s
exp and they return another one and to
be able to call them you do dot call the
name of the function and then you pass
arguments to it so that's the classic
sort of how to call C or C++ function
from from and then the sort of things
you do is not sure everybody can read
this but yeah yeah you see the you see
the sort of C API you able to do to
manipulate there so we get a and B from
from are the two parameters of this
function and then we sort of carefully
coerce them to two numeric vectors on
the fourth and fifth line with the
protect statement then we create a new
numeric vector of a given size that we
you know that it is the size of the of
the a object and then we grab the actual
data pointer double double pointer and
then we manipulate this to do some
really simple computation there the the
sort of thing I probably want to
highlight there is the the protect when
when you create new objects you need to
protect them so that the garbage
collector doesn't come and steal them
from you and then when you're done with
these object when you want return back
to the outside you need to unprotect
right this asks a lot of work from the
program and and we believe we we can do
nicer than this and well we know we can
do nicer than this some other example to
manipulate character vectors so you have
to again protect you don't have to call
a locker vector to create a new cracked
vector of two strings and then to set
the strings you call an another macro
set string element the object position
and this funny MK car function again and
so on so you this is typical let's see
examples you use when you extend yes M
and another function I'm not even going
to talk about this too much but the what
if you want to call an hour function
directly from C well you can do things
like this it makes a lisp people really
happy but it makes me you know going to
the pharmacy too much though so there
you go that's the kind of examples of C
code you can embed in an R package if
you don't have our CPP and if you do
have our CPP now well this is what we
will talk now if you want to so just to
summarize what we're offering is
encapsulation of these s expression
objects that's a union type and it's
it's the thing that gets passed no
matter what is represented as something
you generated in an our session our
program we represent those then as you
know vectors of numerics or ins as a
function as an environment language lots
of them there's two very important work
of functions s and Raph which help you
to go from our
you know the wording is still wrong and
yeah so as actually the other way around
it's from C++ to R and it's rap for
sending it back and the way we've said
the classes up it also cooperates quite
nicely with with current programming
standards it uses a lot of you know
things from the STL like like iterators
so here's a bit of a long table we'll
stay too long on it but basically what
you have on the right you may know as an
AR programmer you know there's integers
numerix logical expression characters
there's more advanced things that you
may have used you know I once worked a
lot with external pointers to overcome
some memory limitations there's as for
classes functions environments all that
we have that if you're a script has one
of these you can pass them down and you
have them in C++ and you can work on
them that's a good thing just a quick
example about how this works there's
there's different ways to go about the
business we don't prescribe a single one
so suppose that you've you know gotten
through call or otherwise and s
expression X you can immediately use a
constructor from an SE XP to create a
numeric vector Y of X a really important
point that we'll be coming back to is
this tests for type the SX P is a union
type and it could be anything so you
could be writing down a function and
want to construct a numeric vector from
it that won't work and that gets called
properly I know that you're programming
guidelines sort of argue against
exceptions we found it helps us for sort
of cases like that that you know may be
a point where you guys need to need to
differ in the code if you want to avoid
that other things are deep copies of the
object we're using what sometimes it's
called proxy classes because these are
objects really are pointers we're having
relatively shallow and efficient
wrapping around them so if you're not
careful and we had some examples like
that on the mailing list if you create
two objects they're actually not
distinct if you want the same sort of
content twice you have to use clone
that's you know common with some other
C++ frameworks too so in essence we
offer a deep copy you can also of
construct just from a numeric if you
just give one for vectors and semantic
is then oh you want a vector of that
size likewise you can also create offset
size and have it filled that works if
you have a numeric vector which by its
type is constrained to be of a single
dimension if we give two arguments
that's into a British size and payload
you can also have sort of an internal
sweep if you wish over it and have it
filled for example with uniform randoms
what happens is you see sort of coolant
: RF there are itself
capi see header files over the years
that I've used that I've often combined
it with you know other software that may
have an elder header files and an erisa
is a little generous at times about what
it defines in macros there are things
like lengths max and you can run into
accidents with that and the best way
around it there is of course everything
can be done with other is it this way
around it so you basically have to
define no remap which we do for you but
the the consequence of that then is that
you need to basically explicitly the way
it's done in C prefix your namespace
with our F underscore for all functions
so instead of having lengths that may
conflict with somebody else's length now
you have our F underscore length so this
fills you with with the uniform and then
likewise you can also use the colon
colon create that that's often used on
return from functions to have existing
options basically just just placed in
there we showed you other examples
character vectors how to call a function
he is just something that we hadn't
shown at the I example but environments
are something very important for
advanced sort of our programming there's
a few constructors for environments that
your our session will already have
global environment empty room and bays
and so on you can create new
environments you can inherit them from
existing packages you can refer to
parent and child environments so it's
it's basically what you may need to
encounter is is provided here is an
example from
I think the first user package that I
had when I started working on this again
after sort of the rebirth of our CPP
that's that's from someone else housed
Africa who wanted something really
simple he just wanted to create a new
new distance metric on vectors and he
had a C++ function that did that and
came to our help or other valent didn't
quite know what to do so I told him well
you know there's this package that makes
it really really easy and at the time
there weren't that many other existing
packages to point to so just gave him a
hand and it's still only an hour Fortran
not on cran because the underlying C++
function I think has a corporate
copyright from Siemens on it and with
that it's not sort of really open source
so we didn't feel like it's worth
putting on cran but we may I put that up
here to show that if you have something
that wraps say you have a certain
library function summer and you want to
bind them this is sort of the minimally
sufficient framework in this for this
particular function earthmoving distance
L one measure they're sort of two
vectors in there it computes the
distance between the two and the sex for
parents the way it's used then is that
you instantiate the two vectors that's
very straightforward just just as we did
on the previous slide then there's also
parents which we stick on a list and
this slide sort of works as a reminder
what lists can do lists this our
you know catch-all for all purposes data
structure in our it's the one data
structure that can contain lots of
different objects of different types and
it allows us basically to do key value
lookups so here we then just looking for
parameters that should be passed in in
an our list parameter called verbose
which we expect to be a bool an
exception will be thrown if that's not
the case and with that we can just
assign it to bool you could have one two
or two dozen such lookup parameters and
it also allows nesting because lists can
contain lists contain this basically
it's a data structure that is a list of
s exp s each element can be in S exp so
we could also have passed those two
vectors inside that that parameters had
we cared for it but it's less obvious
the same thing happens when you return
so here we're using the create member
function for numeric vector to send the
the distance value
which is actually at that point of scale
I believe so we could have sent a double
crochet with the names with the name
disk back so it's a it's a vector that
you can use named lock up on s and R and
at the bottom is the standard framework
to catch exceptions of that inherit from
standard exceptions um and then the text
gets passed back and you actually get
that at the operand or if it's an
unknown exception you just get a get a
stanza you want to take from here that
leads to shorter thing um so some some
other example I'll quickly go through
wit because I have a lot more things to
cover this is the same example that we
did show before with it with a macros so
as you can see with they're not well the
code is much much shorter and then we
can use larger font so that you can
actually see what's happening
the so what are we doing we from the s
exp we grab from from our we create
numeric vectors objects from from our
CPP and then we can start using them
using them so we can grab the size of
the object with number of elements in
the vector create a new vector of that
size and then and then it's just regular
sort of c++ business I mean we grab the
each element from from each vector and
then do some really simple computation
there as you can see there's no more
macros there's no more protect and
unprotect the DRC PPI API takes care of
making sure that your object is
protected when when you create it and
then just relieved to the garbage
collector when it's no more needed so
for this we use we use the regular sort
of C++ life cycle and and it makes code
more easy to write and debug and and
while it makes a bit fun to use as well
so some some of the examples there so
creating a list so imagine you have a
STD vector from from some other library
you get and you want to return the list
you also list that will contain the
first item will be a numeric vector of
two objects so a numeric vector create
one two and then the other one is is
integer vector with 1 one element 3 and
then string and then and then the vector
and all that makes it really easy to to
create data structure that you can just
ship back to the outside with a really
nice syntax there and then you can
assign a class to it if whether you want
to use a s3 object and then return the
object I mean if you wanted to write the
same code with the our classic sort of C
API you you you would have to use a much
smaller font to be able to show this on
the on the slides some of the examples
this isn't an example that came fairly
recently on the mailing list
I was actually came on the our help
mailing list but some someone picked it
up well Doug Bates picked it up and send
it to us on the our CPP mailing list and
said well can we do something about this
to make it to make it faster on the our
CPP slide so we oughtta go with that so
the idea is that we want to go from the
first matrix to the second one which
well for people familiar with applying
comes and did this so that the second
column is the sum of the second column
of the output is the sum of the first
and second column of the input and the
third one is the sum of the
first second and third column grab so
you get the picture so in our if you
want to write this in our you go either
using apply or you can do it directly
using a for loop turns out that the for
loop is quite it's quite an efficient
way to do it on this example as opposed
to what I initially thought it would be
but can we do better using using C++
that's that's the function we we ended
up writing so we grab we grab the
objects as a numeric matrix as Doug
pointed out before when we create a
matrix if it's not a matrix on the
outside then we'll this will not fly
this will throw an exception and let let
us go back to the outside but then here
we know it's a matrix and then we grab
them off row number of columns of the
matrix we cloned this matrix to create
the result and then we can then just
scan the matrix so the the current
column is then the sum of the previous
column and the current column of the
input that it makes really
straightforward sort of a yeah
vectorized code in in c++ so does it
actually make it better in terms of
benchmarking it turns out that it does
well when we started working on these
slides a few days ago that the version I
add was not better than than the R
version and so we've been able to to do
some work there on optimizing things but
yes the the in that example the C++
version turns out to be faster not by a
big margin but we have other example
where the margin is quite more
impressive
stl is a fairly used library in the c++
world all of our data structures you
know vectors list all expose STL sort of
interface so we will have begin and end
to to be able to scan a list and we've
used this in this in this example to
implement a a C++ equivalent of the L
apply function in R we have actually
another one that that's better than this
now but this came fairly early on the
project so we grabbed a list from our we
grabbed a function we create a new list
of the same size and then we just scan
the input with the our function using
your STD transform really easy and
yeah it's sort of self-explanatory she
do this this is from something that I've
worked on the last couple of days or
weeks I I got interested in taking an
old actually implemented in C optimize
it not old current package but plain C
optimization function where the user can
send in a function and this is what what
looks like if you were to evaluate the
vector of parameters par underscore
given a function that map's from a
vector to a to a real to do vector
valued numeric to a single numeric in an
environment row with our CPP that's
pretty straightforward you just decide
the numeric vector you assign a function
you assign environment you then create a
language object that's the function that
combines the functions of parameters and
evaluate that in the given environment
and return the scalar but as I found
this particular one if you do that in
the context of function evaluation make
it call 10,000 times there's a little
bit of overhead in this and you know
these are just good exercises for us to
find where bottlenecks it just as we did
with the the preceding example on the
cumulative sums of the columns of the
matrix where at first we weren't
actually faster than an already
vectorized version and a so this this
isn't as good but you know if that's the
case or shucks I mean we will get there
so I settled essentially for something
like that even though I was working with
aa CPP in the rest of it you can also
just use the the standard are functions
so there's there's length to which helps
you a little with the Lisp headaches
Romain was kindly referring to unone as
the earlier slides the things you have
to do for for function and likewise eval
both of these here prefix with the RF
underscore can be evaluated that's
that's the same thing which then is when
we're using our CPP the same as the in
speed and performance as a si version
because it really is the same other
things that we're having so this is this
is a slide that details the
aforementioned s conversion function s
is basically what you do at the input
to your C function when you come from
our it's templated so the templates type
T it converts to an S exp and it's
pretty feature-rich there's just about
anything you may encounter now sort of
primitive C++ types recall again this is
for passage from C++ from our to your
C++ context so you're mapping into an in
double blue long in any of the standard
C++ types anything that already can be
constructed with an X anything that
further specializes this template or
containers from the STL we speak a
little bit more about that in the
extending vignette because it has to do
with some of the wrapping the converse
is then wrap which goes the other way
around in goes the template type T out
comes the s expression that's what you
do at the end it can again take any
atomistic C++ type in double bool any s
exp anything that further specializes
the template anything that has iterators
and begin an end as well as STL objects
that you use STL containers around the
wrapper ball type and there's plenty of
examples now in the documentation in
other places here's how you would use it
for example suppose that you had a
vector of doubles which we're just
creating a type def shorthand here
so if then a vector Z comes in you can
assign it to vak just as before the
depleting example in doubles you can
also wrap them on the way back and you
can create relatively complex maps of
string or vector but by putting all of
those together so there's yeah two two
vectors and a scalar likewise we have
implicit conversion that works for
environments lists functions you can
look up my name from environment and
lists the way you would do it in in
scripting languages with you know
dictionary or hashes some of the
expressions get by with implicit calls
to wrap that sort of not really clearly
demarked in the in the documentation I
find myself sort of that way sort of
trying sometimes and then you get one of
those fairly verbose compiler messages
back and then you have to put an
explicit wrap there so I'm not really
sure how I would describe to how to use
it I mean if in doubt I I most often
just actually put a wrap around with
that we have a few slides about the
inline package that I started to refer
to a lot in a couple of tours I gave one
on on our and high-performance computing
because it was a super useful package
and it later occurred to me I was
talking about inline and then I was
talking about a CPP and I did that a
couple of times and then I realized wait
wait wait I should stick those together
so I did a patch to it and then later
remanded another patch to make it making
it better still this describes the way
it's now in the current version after
after after or two sets of changes so
now you have a function CSX function
that extends the original c function by
oleg what this does is it picks up an
idea that i had first seen i think in
the perl world essentially in your
scripting language you have what is a
character string it just so happens that
inside the character string is a valid
program in the language you want to use
this package then does the housekeeping
it sets this program body as well as any
other management it needs around it
additional headers make files
environment variables puts it down on
your operating system calls the compiler
for you called the linker and loads it
it does is really really cleverly
because once you know your a system in
environment there things that you can
take advantage of every our session is
guaranteed to have a unique temp
directory that will get cleaned at the
end so it's really natural with that to
write your temporary file in the temp
directory put your object file in there
load from that because whatever else
happens when this our session terminates
this will all be picked up so it's it's
literally as simple as it is there
so you can you know sit in your our
she'll install in line for the second
example you also need ask BP because we
use it but I get to that in a second for
the first one you don't need anything
else but having a compiler on your
system so you know that differentiates a
little bit with say the Windows users
don't always have the tool trained so
what happens is there's a bunch of
arguments we will see a few you don't
need that many the first one always is
signature so you want to dynamically
load a function so you have to tell it
what goes in here we're saying I want to
have something that's a variable named X
in my program and it'll be an int and
there will be variable Y that'll be a
numeric so int and floats in C++ and
what we're doing here I mean it's of
course it's a trivial example we're just
you know returning a product so that I
can have it in a simple simple line that
is the second argument to see execs
function it goes from the apostrophe to
the other apostrophe it's a character
vector that gets passed down and if you
were to turn an additional optional
argument verbose on with the value of
two you would see the temporary source
code that's being put out there it's
compiled it's being loaded and you get
it back and for simple programs like
this it just takes a second or two
because that's the time to write this
mini function compiling loaded and then
you have a new function FX because the
result of C X X function gets assigned
to FX and you can call FX with an
argument to which you know with one of
the newer features we force to be an int
rather than cast up to numeric and the
numeric 5 you can do the exact same
thing now with something very clever
that romaine came up with with with
plugins that certain packages can then
make use of and talk back so our CPP has
a bit more in terms of requirements if
you have looked at it because our CPP if
you want to build against that it has
headers so now we have to tell the
compiler where to find these headers so
that it can happen for the original
program all it did was using our headers
and you can inquire are about where
those sit that's always in the file tree
now we have to do the same for us VP and
we have to provide a library too so
that's basically what plug-in does and
what you then get in the simple example
min long we excuse me for stepping back
from the Mike for a second
instead of using plain old school Metro
API in CNI you now get a rap as
templated functions that we just talked
about and that does the same thing now
with our CPP and you know it was there
before us we've just found it extremely
useful we use it extensively in the
package over 770 unit tests of last
count and many of the collaborators that
we've now found since we went full force
onto this including John do most of the
prototyping this way it's it's really
quite nice but even if you don't want to
use our stuff it's really neat for C C++
and Fortran and sometimes present some
up so I have a friend in New York who's
also in finance who puts a lot of trial
and testing packages onto github and one
of the things you've recently played
with was that he wanted to replace users
of bugs with something that's very
popular in the Pisan world called PI MC
so he was doing a lot of Montecarlo a
simulation with pi MC and then he kind
of figured well wait a second can i do
that with your stuff what about
templates and be sure but yes of course
we can and I and I quickly cooked up the
same a simple example where a template
tape is type is defined and used and
we're basically doing the same thing
here and it's because it's a full
program I had to cut it short but if I
go back a slide whoopsie
this the body argument this is signature
equal then body out an optional argument
is Inc four includes which we're using
here so I have valid C++ code that just
you know goes to some other headers he's
on a linux box so those are being found
a module we'll talk about later cpp bugs
is his program on on github
he really very much like booth we use
the boost random number generators
rather than ours or ours or or Matias
even and you know sets up his model and
then go on and that's all he had to do I
haven't shown that the core here but
it's public he posted it to us if you
need available while ago and with really
simple example here's something that
then render
around pi MC and n bugs because it's
just templated c++ what i should add is
that he's a big fan of doing everything
templated and having no library so for
him just to also declare the include
files was what was critical so it really
works as a framework with that we are
now sort of closing in line and we got a
lot of the preliminaries out and no man
will take it now and talk about
something we added in the summer called
sugar right so sugar comes from from
from desires we so we spend a lot of
time with c++ and and we don't liked the
way we program in c++ and some of the
benefits but it turns out eventually
that we miss a few things from from the
our language and the our syntax in
general so sugar is a is an experiment
to bring some of the our syntax back
into c++ so that we can sort of up both
of best of both worlds so how did it all
started it started from a few questions
on arm and our mailing list about how to
do certain things and so this this
example there is a is again the same
example i've shown before with with a
bit more with a bit more care with
missing values so what I essentially
want to scan a numeric vector and and do
something with it it it's all nice I
mean it's it's really sort of pedestrian
C++ coding exercises there's nothing
nothing wrong about this but we sort of
missed the our syntax they are way to do
it the if we want to express that kind
of code in our you would just do if else
explore lower than Y then x times X or
minus y times y obviously this is really
silly example but anyway so what we do
with sugar
we bring F else back into C++ so that
the function you-you-you write is
essentially the same as the one in our
so we grab numeric vectors so that we
have object of the appropriate class and
then the expression is exactly the same
as in the our expression and and we we
have a lot of feedback and people really
enjoy using this some other example
using our for so many years people love
to use L apply or I supply or things
like this and now we can use them in C++
so assume you have a really complicated
function there called square that takes
a double and squares it many years of a
you know engineering in C++ to come up
with this one you you then can s apply
this function directly in C++ so you
grab the numeric vector and then you say
s apply X square and then it will do it
for you and some of the magic we've put
there is that if the function was
returning I don't know some something
something else for example a numeric
vector instead of you would get exactly
the same behavior as you would get in
our that so that it would create a list
of numeric vector for you and all of
that happening at compile time thanks to
template metaprogramming and things like
this so what's in the sugar box we we
have logical operators is is a vector
lower than another vector greater
different equals we obviously have
arithmetic and we have many many
functions that we are borrowing from
from our we obviously can't bring
everything but we quite confident that
we bring in a sufficient subset to be
able to do some things and people are
quite getting happy with this so you
know Rev or
power men l apply air supply this
function really allow you to write
concise code in C++ functions to operate
on matrices so out cold row the lower
triangle of a matrix and so on and
lately with a tremendous help from Doug
Bates we've added all of the statistical
functions you know our norm the norm Q
nom P nom and so on for every
distribution that's in our but these
function on our C++ functions in that
that allows us to to embed a few
optimizations also in them you'll find
much more information on the AR CPP
sugar vignette because we can't cover
everything everything in in one
presentation and I wanted to close the
the sugar part with with a few
benchmarks of of this it's all very nice
to have a nice syntax but if if we have
to pay the price some somewhere else
then it's not interesting
so what we wanted to to see here is that
does it actually work is it faster than
the R version and so on so we tested
this with the with a few expressions and
well we've introduced a bit of bias
there so the first expression you see
quite quite enormous benefit there well
the where the sugar version is about ten
thousand times faster than the our
version and I can explain you why in a
second then if else which works about
fifteen to twenty times faster depending
on
on the information we embed with one
version we have we are allowed we we can
embed in in the India expression the
fact that the vector does not does does
not contain any missing value and this
allows us to calculate the the project
or any other expression faster and and
then as supply as you can see there
without the overhead of the our
interpreter can get much faster now why
why do we get such huge benefits on the
on the first one that what essentially
happens is that the evaluation goes lazy
so in in our if we had to evaluate any x
times y lower than zero what what would
have to happen is that we would have to
calculate x times y allocate new data
for this wall vector and then we'll have
to allocate another logical vector to
host is x times y lower than zero and
then we scan this in C++ we do it
totally differently with compile time we
allowed to compare the first x times the
first Y with zero and if this is already
true then we can stop there there's
nothing more to do so this is why in
this example though we get so much
faster because there's no extra memory
allocated and and and and the first true
condition this is where the bias was
sort of introduced by by us is really
early in the vectors so this is why we
get such improvements somewhat some of
the benchmarks they're in there writing
our extension deser notorious so example
about convolution and so in in a
forthcoming well hopefully paper in the
in the our journal we've we've came up
with another na CPP version of the
convolution and we wanted to see
we could do better than the than the
usual example in and it turns out that
we can we can make a version that's
about 1/3 faster than than the than the
benchmark so we quite thrilled about
this that covered a lot of our CPP
there's two more extension modules that
Romain will talk to towards the end and
I hope we'll have enough time to do that
but I want to break a little and talk a
bit about our inside that was something
that we also had on the on the title
page so this is something completely
different with Monty Python um you know
if it was out about a decade and every
couple of years someone came up and sort
of said well we should really have
something for shebang scripting because
you know with our you could do our
command badge for redirecting the sort
of crutches it's all awful at some point
maybe around our 1/6 or 1/7 there was
someone from RD in Detroit at the time
they still had our D I think who had a
patch that did something to the engine I
think Duncan temple laying also had
something but sort of it never happened
that they asked a guy he sent me that
pitch I never really looked at it it
then so happened that a friend at
Vanderbilt the Jeff Horner had learned a
lot about embedding are for using our
Apache which is a wonderful product that
he authored and I think in response to
one yet another email about that with
the shebang started doing something and
you know by that time I learned sort of
some tricks just about the ropes was
config you and other things so I I
helped and we started working on this
together
that led to littler so littler then
that's the one time in my life that I
was a little faster and sooner out was
something that worked and Brian Ripley
Brian Ripley being ultra competitive
will never admit to that littler is now
shadowed by our script but you know we
were there it works it still has sort of
some examples and some adventures to the
internal so long story short little
embeds are it's it's it's sort of a
shebang piping front and it's really
really good you guys will like it on
large systems I
used it a lot for some of the HPC
exercises and you know doing that what
it does there is it just runs through
our files picks them up line by line
sent them to the interpreter so then
kind of figured ha that would be useful
and I needed something like that for
just back testing operations that I was
doing at a time that I had I had data
that are accumulated in C++ programs and
I wanted to do all over it and what you
then commonly do is that you know you
cook something out that writes out a CSV
file you call our you bring the results
back in it all works it's all very
pedestrian it's really boring you have
no oral control and it doesn't perform
well so I kind of figured wait what what
littler does is exactly what I should do
for really simple exercise in creating
and class that embeds are all the
functionalities there things to argue
about how to embed it and then we we did
that and that's so so I released that a
while ago and that because it interfaces
between R and C++ also got a lot better
now with our CPP it's a nice little
package now we're co-authors on it and
there's this tremendous number of
examples in the package it's pretty
straightforward and sort of this is what
it does you instantiate an object or
inside you give it oxy and Acme that's
it you now have an interpreter in your
C++ program and thanks to our CPP and
the explicit implicit representing
things back and forth is a lot easier I
had something relatively pedestrian now
we have something high-end so just how
we showed example earlier for the
environments you can just assign you
just have a key value lookup you know
you have an object text in the eye
interpreter that gets assigned and it's
the our semantics on the other side that
find the proper type to it because we
sent a string to it it's you know it's a
character in our behind it and then the
basic hook to get everything out is
passed eval or pass eval q for quiet it
doesn't return anything so if I just
want to say hello world well that's my
three lines of hello world so that's you
know the silliest hello world the two of
us could come up with so it doesn't do a
hell of a lot but it shows you already
what it can do
other examples are that you know you can
assign two numbers evaluate an
expression and get the result out and
point it in so it goes really easily
directional this is something I don't
want to spend too much time on it that
was sort of one of those oh my god why
are they doing this way there was
someone on either a develop maybe on the
asset finance list that I'd share who
wanted to do something that had to do
with service with standard finance using
one of the wonderful a metrics packages
basically just calculate something to
portfolio on a constraint you see it
here thanks to the beauty of of
highlighting in red I don't want to get
into the detail but but he was you know
trying basically to milk our
computations from a standalone C C++
program but he he had great difficulties
there he and he kept emailing for weeks
and then I just want evening I just
cooked that up and it became you know
sample sample for in our insider just
the editor ten brackets just means I had
to sort of shorten something to to fit
it on the page but otherwise the same
example and it it works if there's you
know a functionality in packages you
want to load you just like were you at
portfolio and off you go and you use it
so if you have internal or external
packages they available now to your C++
program last example we added its
relates to the embedding suppose you
have a multi you know highly performing
C++ function about as powerful as a
square example that we had earlier so
this one takes hello and concatenates a
given string to it just to show you this
is a standard C plus plus plus equal
couldn't do that in C function we can
now assign that to an operator in our -
excuse me to a value in our so that
function because we take the function
pointer assign it to an our object hello
and then just pass an eval hello world
so we're calling the hello function
answers are due at the end of class just
kidding
obviously it tells you hello world so
even in the embedding you get back to
basic C++ it's it's nice but you know
one of the greatest things about open
source is that every now and then you
sort of you put yourself out there on
shingle and wonder whether people find
it use it extend it and then sometimes
people come back so jumping whoo I hope
I pronounced that right is I think at U
of Arizona last winter sent me something
back that made me just go wow that is
really clever so what had she done she
just taken your basic MPI hello world
example and use that together with our
inside so now you're in the environment
of say autorun for the openmpi
environment you spawn a large number of
c++ programs and lo and behold they all
have our insight now you're taking the
advantage of our well advantage that
it's single threaded doesn't have many
large requirements is the way we're
dimension system these days a reasonably
small application and you just throw it
out to a thousand nodes and each of
those things to the metric of MPI just
works so you get you know twenty years
of our truth and test and it just works
and you get you know 25 years of MPI
they work together and it just works I
haven't really had a chance to really
crank this but this is this tremendously
clever and we take no credit for it I
think I reworked it a little I think she
sent that as an MPI example with the C
API and then I kind of just figured out
may as well make it C++ API that's how
to examples became for so why is our
insight interesting you may have C++
programs that compute gather or
aggregate data go figure
I mean that's why we've write C++
programs or do something with data so
you have data so then you want to
program with data so you want to benefit
from our because you need to you know
save and analyze your data and you may
have to do that you know in the cycle
you don't want to dump it out of files
so with our inside we can now skip this
dumping and launching and what-have-you
step we just collect our data in the
beginning I was just using STL vectors
of STL vectors to approximate matrices
because I had nothing better with little
time we can send those two are very
easily things to the RTP wrappers s and
wrap and all that have short simple our
expressions maybe they load another
package maybe this was another file you
ever encoded somewhere evaluate and get
the results back and it just works like
that we shipped nine examples in the
standard sub directory
of examples and for sort of two-by-two
for MPI with with that so that's a
really short run through for our let me
do that and when I give it to you for
object protobuf this is sort of really
funny because s Romain alluded to this
is how we got started with this and that
is what are we now yeah October it's
just about a year ago and you know if if
I could milk this power that I have to
transform lives you'd see me on
late-night TV because I sort of
suggested to remain well you know you
want to learn something profess with
these Meyers books and you know weeks
later he comes back and does wonders
with it if only knew how I did that um
you know now I stand here explain proto
buffers to you guys so I don't really
have to so you know I often refer to it
as you know binary better faster XML
hence hence you know I example with
those icebergs these glacial large
horrible icebergs I XML to us so now now
we're photograph we describe data
structures and code gets generated for
us wonderful so there is a really simple
proto definition you get the C++ code
from your standard documentation for
protobuf and on the right you get what
we can do with that it's really sort of
quite an achievement because we almost
have full introspection inside of C++
now because of the way our CPP the
object model the our protobuf library
all interact there's no code generation
and compiling and linking going on
that's what my very basic first example
did what we're doing now is proto files
get analyzed and the rest of it just
just flows it's it's it's quite
impressive there's the second example
but you know with 28 minutes left I'll
just skip that and oh sorry meant to
take this one too and then I'll pass it
to a row man so one of the things that
are done then with our CPP was you know
how can we do things faster I grew up as
an econometrician econometricians often
write papers by doing Monte Carlo
elation of small sample properties you
know you want estimators as well as as
the estimated standard errors are has a
couple of really fast functions to do
linear models or LS estimation quickly
but for the fast ones you don't
necessarily get the standard errors back
so we figured okay what can we do to do
that really quickly this was the first
version again it just this is all it
takes
thanks to inline I guess we're still
using CPP function there rather than CX
x function what happens is we're getting
some numeric vectors that's the type or
that should be oh no well it's a really
old code so then we we still used in
America we call it America corn with
matrix so don't want to stick here too
long there's some passage going on into
our data structure over to our module
data structures a module is a maybe two
year old lovely project out of ni CTA or
maybe they call it NICTA which is sort
of a government-sponsored research
organization in Australia really clever
heavily templated linear algebra stuff
with really clever benchmark examples
how it outperforms other C++
implementation so it's it's a bit like
like Blitz plus plus which no longer
lives and it is a bit better I find them
them them the boost linear algebra stuff
so we use something like that we started
working with that and then created a
little bit of glue so we can do better
than sort of the basic example now
there's a package our CPP i'ma deal
which basically sends our types through
efficiently so we're using armor which
basically take a memory point of the
dimension and the false boolean saying
that don't do a copy just just pass it
through trust us this object has N by K
dimension work with it and then
estimating your linear model is nothing
more than solve X in Y so that in our
lingo fits why tell the X then you're
calculating residuals we're calculating
as we're really quickly and with that
can return the coefficient
Aaron the degrees of freedom that you
know what's motivated once by by a
question where someone wanted to do
something really really quickly we
started doing it with armor in the HPC
tutorials I did it with armor and before
that with GSL as well given the time
constraint I won't stay here for too
long this is sort of a half-finished
package that we have on our Forge that
this this takes these sort of the
wrapping the glue the access to other
given data structures to GSL which a lot
of people use it's unfortunate it's not
as slick as Armour because it can't be
because the underlying data structures
are see and not C++ so but we still want
to get back and finish it eventually but
I'm not going to say much about it that
was so basically just there's three fast
examples for say you want to run a
million gazillion linear models and you
want to do it fast these are choices
that you have the best one for that
definitely it's fast LM now in the MIDI
or package okay so we have about twenty
minutes to two to finish now so I'll go
fairly quickly through this did the idea
was to to give a short preview of how to
do objects in in R and and and so using
this as a sort of a thread to link to
new developments we've put in in in in
our cpp recently with with John's help
so I'll go quickly because some of this
material
you probably already know a fair bit
about so there's many many more ways in
in R to to to come up with ways to
represent objects and you and you'll see
the list there with pencils so I'll I'll
quickly go through them the thread I'll
used there as a fairly sort of old
example which is the bank account
example a fairly well really schematic
view of a bank bank account is the
balance you have on your account and
perhaps the authorized the offered
and then what you want to do with the
account is do you want to open it
check the balloons put some money on it
get some money out of it and so on so
the first way to sort of do this comes
from comes from a demo that's in our
demo scoping uses a feature that's
perhaps not as known as it should be in
art for me it's one of the best features
of the of the our language the lexical
scoping it works it essentially works
because you define a function within
another function and and the way objects
are being looked up if an object is not
found in the in the environment of this
function you're creating it looks up in
the other in the enclosing function and
so on and this this simple mechanism
lets you encapsulate data in a really
simple way which there so for example in
the deposit you query and set total
there in the enclosing environment but
but the but the actual account you
create after that does not let you well
does not let you easily modify the total
variable but but you get access to it
through through the elements of the of
the list you do return and this this is
fairly nice that there's there's a few a
sort of small problems with it and will
maybe cover this so on top of that
there's a as three classes so which hope
I'm not saying anything sort of a stupid
hair but so as three was the
so the first object-oriented way of
representing a data any object in our
can can become an s3 object the only
thing you have to do is assign the class
attribute to it and for that reason it's
really easy you just grab an object give
a class and that's it but for that
reason is really also very dangerous
because you you cannot just grab any
sort of you know garbage from anywhere
and say that's a GLM or that's LM or
that's density fit or whatever so that
there's there's no restriction there and
this is why it's really dangerous but it
gets the work done so how do you do this
as I said you just assign a class to
your object in and then it works with
generic functions and implementation of
this generic function that our cool
methods and so on so the balanced
generic function there you recognize it
generic because it calls use method and
then the implementation of balance for
the particular s3 class is given there
so I'm going really quickly on this but
anyway so other functions as well so
little checking of consistency of
arguments and so on you and and and then
you would use this like this so you
create an account check the balance put
money on it
withdraw money from it the the only
thing I'd like to highlight probably
there is that because of the way date is
being passed you if you modify the
object you have to grab the result from
it if I if I cycle back there you see
that I do X dollar balance equals x
dollar balance plus something well that
actually creates a new X right right
and and so you need to grab this this
this this new X because it it will be
different then than the so for example
I'm passing myself to the deposit
function and the results I'm getting
that's not the same object and and it's
it's it's nice enough I mean if you want
to create for example a GLM and then do
something from it
s3 is nice enough but once you really
start to want to do object you know oh
oh P then it probably you want you want
something else right so s4 classes I'll
go even even faster on this it's it
gives you much more control of your of
your classes so you have formal
definition of the class you you're able
to embed validity so that you're able to
define if this object is valid and
dispatches is much more powerful but I
mean I don't want to be insulting or
anything but it it's a system that
requires to write a lot of code and and
and more annoyingly a lot of
documentation I mean there are helpers
that that are nice but when you start
writing a substantial package using s
for that you end up writing tons and
tons of documentation and well people
like this people don't like this I'll
let you choose your side anyway so yeah
the class is more formally defined so
you define a class you define the slug
soft of the of the year of the object so
the balance is a numeric vector the
overdraft authorized overdraft is a
numeric vector you're able to give a
prototype of the of the object and then
the validity function there it and then
it sits about the same thing as s3 in
respect that you define generic for
action and and implementation of these
generic well you can go much further
than necessary because you can do
multiple dispatch and things like this
but the idea is the same that it's the
verb that controls everything it you
don't say objects you know you don't
invoke a method of an object but you
invoke a generic function and you get
this part from yeah so the syntax is a
bit different but then once you have
done all of this the you use them about
the same way so fairly recently appeared
reference classes which some of us call
our five it's not the official name but
which we're trying to get jump to to
agree on this name anyway
the the way I see them are five well
reference classes are let you have both
advantages of s4 and of something simple
as lexical scoping there are real actual
classes but you know which implies
formalism and and dispatch and and you
know in all the rest of it quite a bit
of documentation but not as much as this
for at the moment like at least me maybe
John will change his mind other but the
real interest thing is that the these
objects are passed by reference which is
quite different than what whatever else
I presented before and this this is
really easy to use so the way you would
create a new reference class is about
similar to it's a bit between s4 and
lexical scoping way of doing things so
you give a name to the to the class and
give the definition of the fields
so and and the fields is really what
defers from S 4 in s for you you call
them and those are passed by value
in a reference classes they're called
fields and this is what is passed by by
reference
so the balance and the other draft and
so on and then the the other argument is
the methods so a I'm defining two
methods withdraw and deposit this
doesn't appear there but one really nice
thing about this is that one method can
call another method and well this dis
also as inheritance and everything I
mean this was just a quick a quick view
of it if you're interested in learning
more about this this just came out in
212 just go questionmark reference
classes and and really encourage people
to have a look at this right so once you
create a new object they're using the
generator then you then it it sounds
look more like usual Opie systems you do
object dollar we cannot do dot because
we cannot anyway we do dollar so object
dollar method and then parameters of the
of the method and as I said before those
apart by reference so if I were to
create a ball roll function so that
dough can borrow
maybe not money but perhaps time from me
I go like this so I'd what what the ball
roll function would do is that withdraw
money from one account to deposit on on
some other accounts and what what I
wanted to show there is that since
objects are passed by reference the they
are you know modified in place so you
don't have to grab the result of the
function so so to make sure that you
you're still in sync the your object is
really a reference that's that changes a
lot of things you could do it
differently you could dynamically add a
method to the reference class by calling
the the methods function of the
generator there that's another way to do
it but much more documentation to read
on on the question mark reference
classes in our 2.12
anyway so going further i what we want
to do is rather than use our object we
perhaps want to use C++ classes directly
in our and for that for that we we came
up with something we call our CPP
modules that's inspired from from
another library called boost bison that
does something similar for C++ and
Python so we want to expose this fairly
simple C++ class so that people can use
it directly in our so the class itself
is sort of self-explanatory and well
that's the same example we've seen all
along so so what if we want to expose
this to the eye level
all we have to do is write this piece of
declarative code there so we create a
module using the are CPP module macro
there of which we give a name yadda
I hope the Seinfeld fan would appreciate
the the reference and then we
essentially say that we expose through
the template argument the account class
and then the argument of the constructor
of class underscore is the name we want
to give to this class on the outside and
then we declare
Woodfield and what methods we want to
expose to the outside so we want to
explore the read-only field balance so
we give the name balance and we give the
the pointer of the C++ field and
similarly for the methods we we give the
name we want to use on the outside for
the method and the method pointer right
once this is done compiled and
everything we can directly use this on
the on the outside so we grab account
from the module
well yadda is the module the module will
let you expose either C++ functions or
C++ classes we might have to skip this
later then we create a new count deposit
money withdraw money check the balance
everything there that the only thing
that's on the outside is really a
pointer to the data structure the data
structure that lives on the c++ side
there's nothing else on the outside and
all of this is is sits on top of
reference classes that have been
introduced in in our 2.12 yeah so that
that that's a quick way to obviously
this example is really sort of simplest
and stupid but if you add a fairly
complex C++ class and you didn't want to
manage this in our directly but just do
a few operations on the instances of
this class then modules lets you do this
quite efficiently well we've already
covered this but another way perhaps to
do objects protocol buffers it's not
totally appropriate for object because
protocol buffers really dumb data
collect data structures that you cannot
associate methods to them but as a quick
way to encapsulate a certain type of
data
not as possible right there was a there
was a bit of a few slides on directly
modules but I'll really go quickly on
them so as I said before modules lets
you expose C++ functions in classes back
to our so let well again the most
engineered function of the of the of the
slideshow hello so as you can see there
there's no there's nothing are related
in this function there's no macro
there's no sex there's no even our CPP
thing is just a function that takes a
string reference and sends back a C
string and and I want to expose this
back to our so I want to use this
dysfunction in our and module lets you
do they do this quite quite easily the
only thing you have to do is declare
that you want to use it so you go
function give the name of the function
and give the function point to that and
and then you're just able to use the
function by grabbing the reference of
the module and call the function and
obviously there's a lot of type checking
and everything to make sure that you're
not passing something that it's not
appropriate for for this particular
function exposing classes we have
covered this already so I'll skip
do you want to finish up with this and
you have two minutes
so getting towards the end so we just
thought we hadn't really said how how
you use this in your package other than
pointing though the fact that among the
eight vignettes included in the Seb
package vignette as a sort of
self-contained PDF document is one RCP
package that has details but one really
nice trick is to prototype using inline
which we advertised earlier it really
works quite well and then the object
returned by si execs function the
function that you can call it has a lot
of baggage behind the scenes about how
it was being built which we can then
pick up or which you know pecker
skeleton picks up to basically generate
yourself a picture a package out of it
so you use inline you call packaged
skeleton on on the generated function
and you know magic happens as with
Disney sort of killing inside the thing
that happens is that we we overloaded
packaged skeleton and made that do stuff
for us so but you know as it then goes
as we were debugging that in the hotel
this morning actually turns out that it
got a hiccup with the single one so
that's a good excuse to show you see
execs function for several functions at
the time these are now once again
nonsensical but the nice thing that goes
back I think to earlier versions of C
function is that it generalizes to lists
of everything so if you just want to
generate several functions instead of
passing in a signature and a function
body you just pass in a list of
signatures and a list of function bodies
these are named lists so we're creating
tick and tack and between signatures and
bodies the names have posed to be
present or it just returns empty so you
want to do it this way so this this is a
real life example we ran this so this
then generates you foo which has a
function tick and a function tag is
defined there by the code you can test
them it you know I was doing some simple
sort of distant measure like things in
all the computing that it does but if
you know want to create a package all
you do is call echo skeleton with the
name of an art maker if you want
me and the web packaged skeleton
generally works you pass it a list of
our objects that should be in the
package and in this case we just give it
to I guess as the code is in the report
as of today it wants list there so now
you have a package that generates two
functions that's really all there is bit
off further reading in case this sort of
whetted your appetite the package as I
mentioned has eight vignettes
the first one is an introduction that's
that's reasonably full-featured now
revised and you know resubmitted and
hopefully forthcoming it's
self-contained and and current things to
the review process we also have an FAQ
document for a couple of things that
have come up on the mailing list we tell
you how to use it in your own package as
I just did there's a document that talks
a little about the glue that we use for
a MIDI you and GSL reps then we have
three further vignettes that are in a
half-baked state that isn't fully
finished sort of one on sugar one on
modules which still chain which is a lot
we borrowed sort of something from other
FSF documents we want a quick graph that
just shows you the API but you know
there's so much there we haven't written
that one either and always generated
that that's an idea I think we got from
some other packages is this there's unit
tests in the package in our unit tests
and shows you the result of all of them
the unit tests generally also double up
as hard to read documentation sort of
kidding aside we try to stress every
relevant facts if you think about can
you do this or that that's unfortunately
what we do ourselves every now and then
we just grab among those so that that's
sort of there are CPP is being picked up
then all fifteen packages on cran
including our crane and bioconductor
some some of those our own but but not
too many there are a couple of other
people who we didn't coerce to use our
stuff and they still do and then there's
the mailing list which was also growing
in has has archives and with that we're
sort of at the end this is a final slide
from one of the other presentations
given this year so if you want you know
paid support for that I think Romain
would be happy to help I do have a job
so I don't really offer that but
again thanks for having us are we happy
to take questions now and or later
oh yes and microphone was recommended so
that it gets recorded yes so this may be
a question is a little premature given
the rapid pace at which you guys are
doing things but trying to play around a
bit with this lately what I've been
doing is to look at pieces of C++ code
particularly pieces of C++ code that are
already interface to R which of course
biases it and what I tend to see is
often interesting stuff but of course
it's very C++ oriented and so to take
one example which apparently isn't too
popular around here the boost library
for we're dealing with graph structures
it's very nice but internally and even
in terms of its interface it's very C++
so the challenge then is how do you go
about taking something like that and
presumably adding something to it that
then makes it compatible with something
like module or or even even somewhat
lower-level RCPD code and ends up with
something with a few hooks that our
programmer can deal with now in the
existing code of course is done by pages
and pages of C code and pages and pages
of our code you guys have a way of I
think getting around a lot of that but
it's getting from here to there seem
still to be quite difficult yeah that's
a that's a great and relevant question I
mean I am I recall that I think in in in
soda you also review the gbn code which
is sort of you know pretty nice C++ code
that all existed even though it had to
do protect and uppercase macros and all
the Eglinton you know ugliness is bad
but Greg Greg did ages ago it's really
good code Torsten Horne has some
fantastic code you know for his tree
base of stuff it's also filters that's
sort of there we haven't really thought
about boost
we did think about QT I liked QT and you
know depay in and Michael have done a
lot of work sort of redoing some of the
graphical infrastructure that say in in
G go be in and have possibly answers to
finally having dynamic you know graphics
devices in on sort of all that it's yeah
it's not clear because if there's a lot
of baggage and a lot of head splitting
and a lot of you know trips for romaine
to the pharmacy to get more volume and
in Tylenol and it's yeah not not not
clear because at the end of the day the
you may remember this that that back
when Borland was still sort of a market
reigning compiler I think the expression
was that there's five people on the
planet who can write a C++ compiler you
know and the language is there I I
sometimes joke that the language now is
no longer the language I learned twenty
years ago which is why I'm beg you zhing
it because it's rich and it's changing
but it's it's Mike Myers calls it sort
of four different facets there are so
many different ones to support that you
know going out boldly and claiming that
you can do all of them you know we can I
mean we sort of do that part-time here
so I mean it's just it's a great
initiative and I think it should get
tackled but we may need a plan and help
I think it's sort of it's sort of doable
but some of the staff boost which is a
good example it's fantastic it's rich
it's peer-reviewed it's fast but lots of
interdependencies and and lots of you
know coding baggage and intricacies
which which you can't really with a
scalpel take out so it's great question
great challenge maybe we will meet it I
don't know yet I I don't really have
much to add to to what Dirk said but the
what tends to happen is that we've done
this with a few with a few library as
we've shown we done armadillo with on
GSL sort of making wrappers around these
libraries so that did yeah so that so
that they sort of talk to our CBP and
then talk to our we there's there's no
real recipe and every time we do it it
is sort of changed what we do in our CBP
itself
and we we try to embed this information
in a vignette but you know with with a
new library you'll have different
challenges and that there's no real
recipe there adds yeah this is sort of
what I had to say about this any anyone
else Oh John again so I think there's
some chance I might repeat John's
question but I want to repeat it in a
different context and maybe it's a
different question I don't know so let's
suppose I've got a C++ library and I've
got an object and you know we can call
it a foo or we can call it maybe a
capital M model right and I've got
another object and its capital D data
right and maybe these are abstract
classes or something or maybe there's
actual instantiations of them in
concrete classes if I use your objects
framework and instantiate a model kind
of swig it or whatever boost Python it
into R and then I have a data can the R
version of the model construct itself
using the R version of the data do the
different do you sort of you have to
assume that all these things are
freestanding things and they're only
going to operate on ants and doubles or
once you've instead two different things
that play together nicely in C++ do they
continue to play together nicely once
they're in our well there really is
nothing in the outside the outside only
holds pointer to the internal data
structure so I love to say yes this hmm
yes it would work yes definitely
obviously I didn't try it on this
particular example so my word is as good
as no but I'd have to say that yes it
would would work because what's on the
outside is really just plumbing to to
let you access methods and fields so
yeah the you only really have a pointer
other than a few no I really agree I
think for as long as it's compatible and
linkable it happens because that just
means that you know the unit's come
busting the C++ code generate what it's
needed to to run it the way this started
a long time ago was I used to call this
sort of vertical you know I I had had a
prompt in I wanted to get something done
that wasn't C++ so I just wrote
accessors and returned us and we're much
richer now and you know it sometimes
call that horizontal it's not the
greatest metaphor but but now it sort of
goes this way and that's sort of where
you coming can you sort of come in here
somewhere and come out on the other side
and at the end of the day we're still
building you know a single program so if
something allows us to compile and Link
this together then then it should be
resolved</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>