<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Advanced Topics in Programming Languages: JSR-305: Java... | Coder Coacher - Coaching Coders</title><meta content="Advanced Topics in Programming Languages: JSR-305: Java... - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Advanced Topics in Programming Languages: JSR-305: Java...</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/J2fgb8nWUo8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so this is going to be a talk about jsr
305 chime bleed on annotations for
software defect detection and this is
going to be both a deep dive followed by
a discussion and weave and yes I have
pimped my keynote this keynote 808 but I
mean so this is a straw man proposal
this is not a done deal
I am very actively interested in
feedback about what I'm proposing and
I'm gonna present a lot of details
things are far more detailed than
somebody who would be a typical user of
this system would actually use
so I'm actively seeking feedback I've
got too many slides so I don't want to
get into any long debates during the
discussion but I've actually got a
conference room reserved downstairs for
an hour and a half after the talk and
would love to entertain all the
discussions we can there and you guys
can I'm still at Google for another week
and a half and you guys can plug me so
one thing this is it's a jsr through the
java community process david Morgentaler
is google's representative on this jsr
and so Google is giving comments you
know he's part of the expert group and
hopefully this will actually turn out
something okay so annotation so we've
already got static analysis tools static
analysis tools can do interprocedural
analysis to find some bugs that cross
procedure boundaries but annotations are
really helpful they express design
decisions that may be implicit or
described in the documentation but not
easily available to tools so here's some
code we need to figure out where the bug
is right so if specs not equal to null
we add SPECT F fragments and then if
spec is complete we add SPECT F
preferences well you can't really see
what the bug is here now if you look at
the body of is complete you can figure
out that if spec is null here then when
we call is complete we're going to get a
null pointer exception
so we found a bug but we haven't done
one of the most important things when
you find a bug figure out who we ask to
fix it right is the problem with this
code that is complete should have
handled null by returning false or
something or is it the case that it was
wrong to pass null in to is complete a
static analysis tool can't tell you that
you can't tell you who to blame me and
that's important right so a lot of bugs
can only be either identified or
localized - you know who's responsible
for fixing this if you actually know
something about what the codes supposed
to do and annotations are well-suited to
this and when the most compelling
examples is to have an annotation called
non null which says that this parameters
not know now I'm going to assume that
most people know what annotations are in
Java there was something that was added
to the Java programming language in Java
5 it allows you to define new
annotations and then you can put these
on things such as method parameters and
so forth and you can and then whatever
tool you use to then look at the code
can add its assignments of meaning to
those annotations
okay so annotations for null nough sits
a great idea and for so great that at
least two different tools to find their
own annotations for non null and they
actually had and not only did they use
different package names
for where the non null annotation
resided but they actually had slightly
different semantics and as hard as it is
to convince somebody to use annotations
in their code it's really impossible to
get them to put in two sets of
annotations into their code and so one
of the things that was very clear that
we had to do is if we wouldn't have a
non null annotation we couldn't have
each tool vendor having their own non
null annotation we had to come at least
to an agreement with a common name you
know common package name and what its
semantics are and so that was one of the
things and I'm actually served pushing
305 to include a little bit more than
just coming coming to an agreement on
standard names
so 3:05 is intended to be compatible
with any version of Java that supports
annotations it doesn't require any
syntactic changes we're not allowing
ourselves to require any syntactic
changes so if you're running in Java 5
then you can we'll be able to download a
jar file that contains the new
annotation names compile it get the
stuff and then tool but Java 5 won't
interpret the annotations but in tools
you happen to use like find bugs or
IntelliJ will be able to interpret the
annotations and we hope to have usable
drafts and a preliminary tool support
out by the end of the summer which I
just checked gives us till September
23rd there's a separate jsr annotations
on Java types which is designed to allow
you to put annotations in more places
that targets Java 7 it interacts with
this jsr but we're not dependent upon it
okay sonal Ness is the great motivating
example it's the one that you say yes I
want an annotation if you can sell an
annotation for anything you can sell an
annotation for an illness so most method
parameters are expected to be none no
always no no there are some research
papers that support this it's not always
documented in the Javadoc and we've had
a number of cases where we say oh this
looks like our tool found a bug let me
look at the method spec to figure out
whether or not this method is supposed
to handle a null parameter and it's
often very hard to figure out whether or
not the method is supposed to handle it
and so what do we want to do we want to
document parameters return values and
fields that should always be none null
and then if you've declared a method
parameter as non null then if you see
code that is passing that could pass a
null value to that parameter you want to
generate a warning hmm it would also be
nice to have annotations about which
things should not be presumed to be
nominal so for example the equals method
that's supposed to handle null and
handle it by returning false as opposed
to handle it by throwing a null pointer
exception okay and so not only is this
not a non null parameter it's a
parameter where you need to expect no
and so in particular because of what we
know about equals if you see an
implementation of equals that
immediately dereferences the parameter
that's passed to it we want to generate
a warning okay so we have not null and
then we have expect null or something
I'm not quite sure the name but I think
we may actually need to have served
three cases in terms that's useful to
say three different things about Nonna's
because what about map get the return
value of it right so it returns null if
the key is not found right it also
returns null if the key is in there but
the value associated with it was no so
the return value can't be non null
right but there are and I've gone
through and done this stuff and like
student project student program projects
and so forth there are lots of places
where you call get and you know that
they're damn well better be a non-null
key value in it for this particular key
because you know it's already in the map
and if you forced programmers to say
every time you call map get you better
put in an explicit null check I think
the programmers will hate you we don't
want programmers to hate us right so I
think what you want is to basically be
able to say one of three things about
for example a method return value with
regards to null miss one is that this
thing is guaranteed to be non null one
that null is definitely a value that you
have to worry about when interacting
with this method and the other one that
just says you know this is too
complicated to boil down to like a one
word phrase maybe it depends on the
calling context maybe it depends on the
method parameters maybe it depends on
the state but Aaron with unwell and I'll
talk into some of these I'd love better
name suggestions if anybody comes up
with him I'm not we'll come back to that
right questions do we need a name for
unknown illness and yeah we do and I'll
explain to that nullable might work for
one of these yeah but I don't know so I
won't debate names at the moment okay so
none null a little subtle thing for
fields that it has to be interpreted as
what the field should have after the
object is fully constructed because
fields are obviously null initially and
the tool will try to generate a warning
if they see a possibly null value being
used in a place where something that's
been marked as non null is required same
thing as if they see a dereference of a
possibly null value
I mean the question is well the system
tried to sing some I mean to some extent
this is all up to the tools right this
is just indicating your intention and if
a tool wants to get more sophisticated
and figure out that though this object
is still in the part of it still in the
process of being initialized thus even
though it's filled this mark does not
annul it might actually be now that's up
to the tool it's not part of the spec
there's never enough information I mean
thing is the intent is to provide useful
information and it's not complete
information you can't provide complete
information without getting into a page
of spec for every page of code okay so
no feasible means the code should worry
that this value might be known for
example the argument to equals and tools
you know if you see place where you
invoke a method that returns a value
that's marked as null feasible and you
immediately dereference that they'll
want the tool to generate a warning
right and then unknown illness which is
the same as having no annotation as Neil
point out the reason I think we actually
need to be able to do this with an
annotation is because we're gonna wind
up introducing something I think we need
which is default annotations that you
can say for a class or a package I want
my method parameters to be treated as
non null by default but you might in a
couple of cases say no but for this
method parameter I want it to be treated
as though I don't know whether or not I
don't know anything about the null nough
Sat this parameter so we need to be able
to get back to the original state and
this means that it smell under some
circumstance might vary in the subtypes
depend on other parameters of state
interprocedural analysis might give us
better information I mean if something
is marked as not null sorry something is
marked as unknown illness that doesn't
prevent us from doing interprocedural
analysis to find a potential error it
just means there's been no statement of
design intent about the nullus
of this element okay so actually having
tried to apply this if you mark that
some value could return null it tends to
require work it's sort of like marking
something as Const right I mean this is
something fun you know you you you go to
a meth and say oh this method could
return null so you mark it as null
feasible and then you find out oh well
this method returns the value of that
method so you have to go mark that when
you get this whole propagation that's a
little bit similar to what happens when
you use constants C++ so I'm just saying
this is why I'm convinced that you need
you need this concept of sometimes you
just want to say I don't want to state
any clear guidelines about whether or
not this value is null and just want to
leave it as unknown okay right
but it's still a matter of once you once
you apply an annotation of null feasible
to something you frequently have to go
through several iterations of applying
additional annotations or null checks in
order to get rid of all the warnings out
of your code you know I mean we can take
short things I don't want to get them in
any multi minute long discussions oh
sorry what they don't I'll just repeat
the questions okay fine
okay so numbness is the great motivating
example and I could talk about all sorts
of various other ones that we would want
to do but actually a lot of these form a
part of basically doing a type qualifier
a way of defining additional type
constraints on top of the existing Java
type system I mean
gilad bracha has talked about pluggable
type systems which has a lot of
similarities with why when talked about
and rather than talking about the three
or five or six other type qualifiers
that the type that the jsr might provide
I think the most interesting thing is
that we're going to provide a general
framework that will allow anybody to
define type qualifiers that can be
interpreted by tools okay so actually I
want to get to one more example before I
generalize so non-negative right there
are a lot of methods that require
non-negative parameters do we need
positive
mm-maybe none zero questionable power of
two I can conceive of it prime I think
we're stretching right but let's just
considered a non negative for a moment
if we want to have non negative we also
want to be able to talk about something
that's signed something a value that
could be either positive or negative or
zero right so for example hashcode and
random that next int returns something
that's signed
I mean unknown Simon would be similar to
unknown illness so this is this idea
that you know with numbness we had none
no worry about it being null and I'm not
going to tell you and with signed we
have none negative worry about it being
negative and I'm not going to tell you
right and this is a pattern that comes
up when we look at a lot of these things
I think you might want to Express so the
other thing that comes up a lot is
particularly if you look at AP eyes that
were created before Java 5 a lot of
people used either integer values or
strings where an enumeration would have
been better right and this creates an
opportunity for lots of potential errors
that are uncompromised compiler so for
example here is Java SQL dot connection
there's a method called create statement
which takes a result set type a result
set concurrency and a result set hold
ability and all three of these
parameters are declared to be of type
int and then there's a whole bunch of
public static final inste cleared right
so there's result set dot type for word
only types scroll and sensitive type
scroll sensitive and then there's
concurrent read only concurrent
updatable and then cursors over commits
or cursors app commit and if when you
invoke this method you get the
parameters in the wrong order nobody
complains right because just three intz
right and you just get weird unexpected
behavior and so how are we going to fix
that so what we're actually going to do
is we're going to allow the SQL people
to define their own annotations so they
can just define an annotation as simply
as this this is all the code they would
need to define three annotations they
define one called result set type result
set concurrency and results have hold
ability so this public at interface
result set hold ability declares results
have hold ability to be an annotation
and then I put an annotation
on the annotation saying that this is a
type qualifier then once I've defined
these then in SQL I can go in and all
those method parameters that are
supposed to take a result set type I put
at result set type on the method
parameters and in the public static
final intz that declare the constants
I declare those to be a result set type
and now I've served added an additional
type system on top of the Java type
system and if you try to pass things in
the wrong order we'll want the tool to
generate an error okay and when the
important things is is that three or
five isn't going to declare results that
type it's not within our scope right
rather we're going to define the meta
annotation type qualifier which will
allow anybody to define their own type
qualifiers which can then be interpreted
by the tools
okay so I showed you before we serve
like the minimal type qualifier
definition which left out a lot of
capabilities now I'm going to show you
like a full-fledged type qualifier with
all with bunch of bells and whistles and
this might actually be how non-null
looks so we can tell we can say that
it's documented right which means that
it goes in the Javadoc
we say it's a type qualifier and then we
can decide whether or not we want this
type qualifier to be available through
reflection or not in this case I said
make it available at reflection and then
I've defined a interface called non-null
sorry an annotation called non-null and
then I have to find two elements of it
win and default for it and I'll be
telling you what these two things do in
just a moment okay but so this is
defining a type qualifier called
non-null that's documented
reveille labelled through reflection and
it's got these two attributes so
whenever you apply it you can optionally
provide these wind values okay the wind
element this is one of the subtle and
sort of deeper parts of it so I'll try
to slow down a little bit here and in it
if you don't understand this please make
me stop right or at least slow down okay
so the wind element is something that
when you apply a type qualifier in a
particular location it allows you to
describe the relationship between the
values described by the type qualifier
and what can actually occur at that
location I mean so in particular
so we're gonna do some little Venn
diagram stuff so we have a set of you
know so any type qualifier basically
splits the universe into its values that
have the property values that don't have
the property one time this is well
particular instances of it
yeah runtime values I guess concrete
values I would I would say rather than
runtime okay and then we wouldn't
describe the values that can occur at a
location one of the things that I found
was quite useful is it's really nice
when you try to describe something is if
you can try to describe not only your
knowledge but your imprecision in your
knowledge and so when we describe when
we're gonna allow a user to describe
what values are possible at a particular
location he's going to describe what
values are definitely possible at the
location what values are definitely
impossible and what are the values that
we're not sure about we're not sure
about whether or not these values can
occur at this location we don't want to
say anything we don't want to mandate
anything about whether or not these
values can occur at this location
hopefully this will become clear in a
few slides and turns out that sometimes
you don't know anything is definitely
possible we just know some values aren't
possible you know these things may be
possible but nothing is known to
definitely be possible okay where is
this leading okay so here's the wind
value we've got the universe concrete
values that have the property concrete
values that don't have the property and
win isn't a new and it has a couple
different values one is always and
always simply says that all the values
that could possibly be in this location
are contained within the set never
everything's outside it now there are
some esoteric ones and I'd once again
I'd like better names maybe not which
means we know that there are definitely
some values that kind of
at this location that are outside the
set and there might be some values at
this location that are inside the set
but we're not sure maybe either
basically means we know that there's
some values that can occur that this
location that are outside the set and we
know there are some that it can occur
inside maybe yes means we know that
there are some values that can occur at
this location that are definitely inside
the set and maybe there are some values
that are not in the set and unknown
basically means we don't know anything
and I can express these in logic rather
than pictures but I figure pictures was
a more useful way to do it in this
context okay so if we start out by
defining defining a type qualifier non
null now I mentioned I wanted to have
this idea of saying null is feasible in
this location well that's simply non
null win maybe not unknown illness I'm
not gonna say anything about whether man
although you can appear here that's none
no wind equals win unknown okay so for
non null we separate the universe into
the non null values and then the one
null value so non null is inside no
feasible you know could be both but we
definitely know that a null value is
possible here and unknown illness says
we don't really know you know nothing
definitely about whether or not it's in
one or the other so there are a lot of
wind values and they're not always
useful so like we could use none null
win equals wind dot never to locate a
place where only null is possible right
so you could annotate that it's not
particularly useful but on the other
hand one of the things I think well if
you want to have annotations about null
Neuss what do you start with as your
building block do you start with null or
do you start with none no as your
building block and then build up the
other things around it
and if you started with no then you'd
want null win equals never to reflect a
value that's not known and you'd want
now when equals maybe yes to represent
null feasible let me give you another
example negative numbers so once again
whenever you have one of these type
qualifiers you often find yourself
saying well what's our building block
well let's assume we start with the
building block of negative in that case
negative win equals window never is
non-negative and non-negative
when equals maybe either is signed
I'm sorry showing that to you with the
pictures right so we have non-negative
you know we have the universe of
negative values non-negative values are
the ones that are definitely outside it
signed
we know that it's this location can have
values that are both negative and not
negative unknown sign we don't know
anything definitively yeah
yes I this turns out you don't want to
have to type none all win equals so yes
I will propose nicknames for type of
qualifiers right I mean the thing is is
that this sort of situation came up and
I didn't really like the idea of just
defining like three different qualifiers
and saying that they're connected and I
like the idea of having one that you can
put these different flavors on but then
they say you don't want to say it that
whole way okay
maybe yes and maybe no or both possible
no name so a number the wind values are
obscure and seem unlikely to be used but
they naturally fall out of the logic we
want to express and removing any of them
would reduce the expressiveness and
would force you into situations of oh
well I have to define negative as the
primitive as opposed to defining none
all as the primitive so it's possible we
could reduce the scope or it's already
this trade-off we could we could
probably get by with fewer sets it would
reduce the expressivity it's not clear
it would really hurt but on the other
hand maybe if we sort of declare them
and just say you know 98% of you don't
need to worry about these other ones and
then and it gives other people too
capability to build the annotations and
once again I'm not keyed to the names
well you can't under Java 5 so you can
drop a 5 because you can't put something
on a branch the other thing that these
are type qualified so they have to be
attached to a value so you mean you
could have a branch and in a branch you
could declare a local variable on which
you put the annotation ok yeah
okay
so and what do we actually do what's a
whole point of doing these type
qualifiers and once again names they're
in flux but basically what we want to do
is we 1 do a dataflow analysis through
the program if we can find a feasible
path on which an always maybe s or maybe
either source flows to an ever sink then
we want to generate a warning and also
to Congress if we see and never maybe
not or maybe either source flows to an
always sink we want to generate a
warning and so in this context we talk
about a method parameter you actually
most things are served both sources and
sinks so like a field is a source when
you read it in a sink when you write to
it a method parameter is a source inside
the method but it's a sink when you
invoke the method ok so so that's how we
check it now like I wanted to you want
to make it easy for people to do the
simple things and like I mentioned for
the results that concurrency sometimes
you don't want to bother with all this
wind stuff at all you just want to say
you know this is really a result set
concurrency and I don't like muddled
with all when maybe all that sort of
stuff so when you define the type of
qualify if you don't give a win
attribute then you can't say when it
occurs it's basically if you don't
define a win attribute then whenever you
apply it and says though you said always
and also then given the initial stuff we
wouldn't ever generate a warning is if
we see always an unknown we won't
generate a warning so in that case if
it's strict if you haven't defined a win
attribute then if we see an unknown
source flowing to an always sink will
generate a warning right and that's
basically how so if you've defined these
things you know for these new constants
if you pass anything if you've got
method parameter which is annotated foo
bar and ku bar is a strict qualifier
then the only thing you can pass to it
is something that's been labeled foo bar
okay
the default for element alright so we so
and I'm gonna get to a moment in terms
of why I think we need defaults but let
me just explain the syntax of it for the
moment
so unfortunately do some way of
annotations work you can't say like
default for parameters and then pass it
an arbitrary type qualifier as an
argument right so instead what I'm gonna
suggest is that if you want in a class
to say I want all my method parameters
to be none though by default what you do
is you just put the annotation on the
class but then put in a parameter that
says no this doesn't really apply here
I'm applying it as a default for
parameters and this can actually be a
list of things you want to apply it to
and so this just means that now within
this method and I'll get back to
justifying it if you see a method
parameter and there's no explicit
annotation there's no inherited
annotation then I'll be treated as
though it was marked as being a non null
parameter
okay so one other thing I haven't shown
you yet is we need to find the type
qualifier you can define a value element
and then so if I've defined here as the
fou qualifier which has a value
attribute this just allows you to define
an entire family of type qualifiers for
one food to food three and unless you do
anything else these are all orthogonal
or independent whether something is a
through one is independent of whether
it's a food two and this doesn't look
quite compelling yet I'll come back to
what makes it more compelling so one of
the things that you can do is you can
actually say I want a value that's
exclusive so one of the things this
actually happens inside findbugs
at the source level java class names the
packages are separated with dots at the
JVM and in class files they're separated
with slashes then fine bugs we deal with
both and if you pass a class name that
separated with slashes someplace that
expects a slash name with dots it's bad
so I can define a type qualifier called
class name that takes a value which is a
kind to either slashed or dotted and
thus this defines two exclusive type
qualifiers they're exclusive because I
put this attribute on the value and what
does it mean that they're exclusive that
means if something is always a slash
class name that means it is never a
dotted class name
when fit when brainstorming about
possible things we thought well should
we also have exhaustive right so if you
had an exhaustive value and in this case
would only really make sense if the
value wasn't a noon then if it was never
read and never green you would know it
would have to be blue I've not come up
with a lot of compelling use cases for
it but it sort of seems natural I I'm
not sold on this yet not particularly
relevant or important
I'd be happy to have somebody come up
with some good use cases for this sorry
boys question
I mean thing is I don't think you're
gonna be switching on the noon types
yeah maybe I mean if nothing else it's
helpful serve as a design decision okay
so type qualify our nicknames question
in this race before nobody wants to be
able to be typing at none null win
equals win dot maybe not all over the
place so my proposal is that you can
define your own interface whatever name
you want and you put an annotation on it
saying it's a type of qualifier nickname
and then anything that looks like a type
qualifier which is applied to the
annotation essentially means apply it to
wherever you want in this case I've also
provided here the default four which
allows me to use this as a default so
basically this just gives you a
shorthand it's sort of like type def
although whenever people hear type def
they groan right and there are few
subtleties to doing this but it we've
generally found it to be useful one of
the other things they'll be really nice
about it is it will allow us to just go
in and serve retrofit some existing
classes so we've already had non null
annotations and we can go into the non
null annotations that both find bugs and
IntelliJ have and say that they're a
nickname for this kind of nullus type
qualifier and then they don't have to be
treated specially by the tools and we
can also go in an other places where
people have defined their own annotate
that have meanings like their type
qualifiers and say oh this is a nickname
for this kind of type qualifier okay
default and inherited type qualifiers
sure
you want it to be how do I say that this
no okay so generally we haven't I mean
I've not come up with use cases where
you actually put a type qualifier on a
class because you want to say something
about the class I mean you know I gotta
say that there's been a substantial
challenge in the fact that we're working
within the existing Java 5 annotations
and there are all sorts of ways he could
do this if we could change the language
and and you know I'm not particularly
keyed to this if you can come up with a
better suggestion for doing it I'm happy
but generally I you know I've not come
up with use cases I mean so I guess the
keys just are talking about in this
somewhat compelling is to say ok I've
got a class and every time you see a
field that has this class I want it to
be treated as none no right you know I
mean maybe we can find some other way to
actually do that and so forth I mean
there are a couple of other issues the
fact that for any particular annotation
we're allowing values for annotations
but you can only apply a particular
annotation once at a location you can't
apply it twice with two different
elements so we have foo sub 1 inclusive
2 you can apply them both in the same
location there are all sorts of
interesting challenges in terms of
making this work
okay so default and inherited type
qualifiers okay so most most parameters
are none no many return values and
fields as well there's been some
discussion about this but I believe that
if you tell developers that you have to
change the source and put in at non null
on top of every parameter that's
expected to be non null that they won't
do it they'll make the source code ugly
hard to read it will involve changing
too many lines of code which will
require some vice-presidents to sign off
on how many lines of code you've changed
maybe not at Google but at some
companies I know that's how it would be
the other thing is is that just say oh
well weird you're going to treat if you
haven't annotated a parameter we're
gonna treat it as none known throughout
your entire ten million line code base
name that's also not gonna sell and so
what I think you want is to and the most
compelling use case is to say okay for a
particular method class or package I'm
gonna say that this thing has none null
parameters by default and if a parameter
so if a parameter doesn't have an
illness annotation you climb out worth
looking at the method and then the class
and if it's a nested or an inner class
you look at the outer class and you
claim all the way out then you look at
the package and what I've actually found
I've done some of this actually using an
earlier version this we have findbugs
is what will often happen as you said
you know what today I'm going to apply
illness annotations to this package and
you start by saying this package has
none all annotations by default and then
you look at all the places where you get
warning messages from your code because
there's some parameter where you are
passing null and null is okay and then
you go in you say oh you know this place
smells alone oh this class this class
handles a lot of nulls and Joe wrote it
and I don't want to deal with it so I'll
just put in a class annotation of
unknown illness because I don't want the
package one to apply and you just do
several levels of iteration and you get
down to
you know what you want so you can mark a
package as having none null parameters
by default and Jing said on the class of
parameter basis as needed once again
this is the proposed syntax that you
just annotate the class or the package
or I guess method would you there'd be
some problems with am taking the method
due to multiple annotations of the same
thing but basically if when you apply a
type qualifier it has a default for it
then that says this type qualifier may
not actually be intended for this
element but it's intended for all things
that are contained within this that
match whatever element type is said okay
inherited annotations we also want to
inherit type qualifiers so for example
the equals method I fetched on names
whether it's check for null or null
feasible like I said I can't decide of
my names but you want to inherit the
fact that equals is supposed to handle
null you want to inherit the fact that
compared to should never be passed a
null value clone should never return a
null value these are things you want to
inherit without having to explicitly
state them so what happens so FA
parameter has an explicit annotation and
that's the one we're gonna use in the
analysis there might be a separate check
to see if that's compatible with
inherited annotations but if it has one
that's the one we'll use for the
analysis if there's not one then we're
going to like to see do we inherit an
annotation do we inherit a design
decision for this method parameter this
method returned though if we do we use
that if there is no inherited annotation
available then we're going to climb out
lexically and look for a default
annotation a default type qualifier
question yeah I'd say the question is is
could you change the null nest parameter
for an equals method right the way I
mean first off you can do whatever you
want
sar through if I won't forbid it because
we don't really say how your tool has to
interpret these right but what I would
recommend my yeah there's so there's a
little bit of a suggestion what fine
bugs will do is that in terms of
analyzing this method we will treat it
as being none null but on the other hand
we will also separately generate a
warning saying you have annotated this
method with something that is not
compatible with the method it overrides
sound reasonable okay so it's really
clear that we need to do something for
numbness in terms of default annotations
absolutely clear right it is not as
compelling that we have to make this
available for all type qualifiers right
but maybe that's just because I haven't
thought about it enough I don't know I
you could try to argue that well we need
to do this for null in this but it
doesn't need to be general I don't know
I I like to provide general capabilities
because somebody smarter than me will
come up with some way to use this in
some way I hadn't thought of on the
other hand maybe somebody will come up
with some really confusing way to use it
that I hadn't thought of and of course
having IDE s be able to like interpret
the default annotations and the
inherited annotations would be great so
that when you like mouse over a method
parameter it could like tell you or
display in some way that this is a non
null attribute we use color coding or
something like that to interpret all
these because the fact that in order to
figure out whether or not some parameter
is not a null you might need to look in
here and if there's not a default
annotation their goal
in the package that is unfortunate and I
think would be a great place for tools
to help people navigate this stuff yes
question right okay the reason you said
the question is why can't you say you
know at default for parameters as now
tension and as a parameter you supply it
with none no the reason you can't is
that under Java five when you define an
annotation the elements of that if you
define if it takes an annotation as a
parameter it has to be a specific
annotation so I could define a
annotation that took a numbness
annotation as a parameter but I can't
define an annotation that takes as a
parameter an arbitrary annotation now
I've got a proposal to change that for
Java 7
repurposing the animation places you
also provided all things make everything
much more confusing and yeah III I'm not
if I could pass an arbitrary if I could
define an annotation which took an
arbitrary annotation as a parameter I
would be using that and perhaps we will
actually deprecated this way of doing it
once if you're in Java 7 and provide a
different way of doing it but the
problem is it's a limitation of the
annotations in Java 5 ok so if you guys
haven't ripped into me yet here's some
some new meat so one of the things I'd
like to do is to allow you when you
define a type qualifier to define a
validator so a validator is and we I
think typically we can just do this by
using a design pattern where you put a
static inner class to an annotation I
didn't know you could put a static inner
class in the meditation but you can and
what this is is it's a class that can
check to see if a particular concrete
value is an instance of the values you
know if it's in that set okay and then
if you've got a static analysis tool the
static analysis tool can actually take
the annotation libraries load them and
execute them within the static analyzer
at static analysis time and check to see
if this constant value is actually an
instance of it so for example I talked
about having an annotation for slashed
class name or dotted class name I mean I
could write a validator that checks that
and if I see a constant value being
passed to a place where a class name is
a being used we could do a check at
compile time to figure out if that is
indeed a slash class name
these three guys I'm actually so what
I'm proposing for these is that it's not
actually going to do any walking over
the syntax tree then all will do is
simply say here's an annotation here's
an instance like a constant value tell
me what like a string value tell me
whether or not it's an instance of well
at static analysis time I'll only work
for constants you could also define this
thing to allow tools that would walk
over abstract syntax tree I think that's
getting too complicated
none no loubies I think we may need to
take that into later discussion selects
it at at static analysis time we're own
we're at least in theory only going to
do this for constant values you could
actually do some abstract interpretation
to try to figure out stuff but let's not
go there you could also imagine dynamic
instrumentation right so if I put in
stuff for slash class name and odd class
names you could imagine not with Java C
because we're in Java C we're not
allowed to change the semantics but you
could imagine a tool that would do
bytecode rewriting so every place you
had a method parameter that was declared
as taking a slash class name it would
insert instrumentation to call the
validator and check to see if what is
being passed to this parameter is indeed
a slash class thing you could imagine a
tool that would actually insert
instrumentation to check whether or not
all the method parameters that were
declared as non null were indeed non
null
I mean and this actually overlaps some
with the validators with jsr 303 which
is also defining a set of sort of
annotations with validators that's more
designed for stuff like interfacing with
databases and so forth and here's an
example which is too small but so this
is a credit card number annotation and
you could define a validator that
actually checks that it matches the
right regular expression and performs
the lung verification right to verify
that this is indeed a valid credit card
number and one of the other things I
mentioned that type qualifiers have this
value attribute right so when you'd call
the validator you actually pass in the
actual annotation and so I think it's
the actual annotation has a value right
and so if you had two of one foo of two
foo of three then when you call the
validator it would know whether this is
a foo of one or a few of two or a vu of
three and it would be able to check
things separately based on
this is a little bit we're not as far
along with our implementation here this
is a little bit more out there but I
think this will be a really interesting
way for people to do some things
particularly when I think I talk to
people at a guitar and so forth and they
were very interested in not only things
like validators but generating factories
to help them generate test cases so if
you have credit card number on something
than if you defined a validator for it
sorry if you defined a factory for it
then you would have a tool that would
automatically generate credit card
numbers that you could try to pass that
method to generate unit tests so there
are all sorts of things you could do in
terms of and the nice thing is is you
don't want to do this in terms of jsr
305 defines the credit card number
annotation the thing is can you do the
meta annotations that design patterns
there are all tools to do this all right
so do we need a way to cast so you know
how do we force the analysis to assume
that the result returned by a method is
a credit card number even if it can't
prove it
perhaps because we've done some sort of
validation I'm not entire you know one
way to do it is to have another wind
value called assume always which says I
don't care how you put stuff into it so
see if you had a method that was
annotated its return value this credit
card assumed always then anybody who
invokes that method would assume that
the result is always a credit card
number but within the method you could
return anything you want because you
said assumed
okay so I have a little bit of time talk
you know so yeah so I can run a little
bit over so now I've served given you
the general framework let me just give
you a couple to concrete type qualifiers
that I think we might actually define
the standard so one is untainted and
tainted right this is one of the places
where you definitely need a cast because
you will have cleansing methods that
take tinted values and return untainted
values and you'll want to have some way
to make you know to say that okay well I
computed this from an untainted value
but I now know sorry from a tainted
value but I now know that it's untainted
and hopefully you guys know all about
SQL injection and nasty stuff like that
so those syntax one of the things that's
been proposed and IntelliJ has some
features like this is to say you know
what goes here should be should have the
syntax of a regular expression if the
string you pass me here is not a valid
regular expression I want a warning to
be generated me or this parameter should
take a string which is Java syntax or
this parameter should take a string
which is SQL syntax now of course
there's more than one SQL syntax
unfortunately but you know in spirit
right and then this could be used both
statically dynamically and so forth and
also the other thing that might be nice
is IDs might be able do some refactoring
support here right that if you mention
something has Java syntax or SQL syntax
that could help tools do better things
in terms of refactoring pattern although
we probably won't actually use pattern
because it's a name collision but be
nice to just have an annotation that
says what goes here must match it should
be a string value that matches a
particular regular expression so this is
would say what goes here has to be a
string of digits
okay so that's type qualifiers okay so
let me see if there briefly any
questions type at qualifiers now I'll
talk about a couple the additional
annotations
I'd like to bill to provide so we've got
plenty of time for discussion efforts
yeah question
gets under the structure so the question
right so so the question is in general
for type qualifiers is if you see an
arbitrary computation is there some sort
of way to figure out what type qualifier
applies to the results of this
computation based on the type qualifiers
of the values used to compute it right
specify that relation in some way so
14th
if any thing tainted is used to compute
something you're going to assume the
result is untainted non negative you
know the rules for whether or not the
result of an arithmetic computation is
non negative based on the sign of the
arguments can get kind of complicated
right you know I think we may just go
one or two simple ones either it's
contagious or it's not contagious right
so if it's contagious that means if it's
tainted ting propagates if it's
uncontained if you see a computation you
don't understand
you just assume that it's unknown I mean
how do i specify whether it's contagious
or not
yeah so I mean the so for example one
question is how do you specify something
which is polymorphic and a type
qualifier right right so taint is good I
mean so at the moment we're not planning
to address them right I mean there we in
some ways taint shoehorning taint into
here this sort of complicated because
all these rules about polymorphism and
so forth we're not true we don't and I
basically I don't think figuring how to
do polymorphism overtype qualifiers I
don't think that's well enough solved
that we can propose to implement it well
thing is it's like Fran ulness right the
tool will do its own analysis based on
you know what it knows about numbness
and procedures and if statements and and
and how instance of works to propagate
an illness - that's not dependent upon
type qualifiers what I'm not sure we
want to do I mean there has been some
work on this I don't think it's right
for 305 that allows you to define okay
for my type qualifier I want to give you
an abstract interpretation that tells
you how to compute the results based on
that I don't think we want to do that in
305 I think even getting what I've got
in is getting all the cats herded is
going to be a challenge and I'd rather
not try to define an abstract
interpretation that takes the abstract
syntax tree or anything like that
definition this is about being able to
declare an interface yeah but I mean
like I said you you would also want to
be able to define in a similar way how
to compute whether or not the result of
an arithmetic operation is non-negative
or not based on the sign of the
parameters so I don't think that we can
shoehorn that into three or five
I think various tools will do that but
this is not saying tools what they will
I think I think given the number of
people who are disappearing I'd like to
move on and discuss a few more things
and we can discuss this after the talk
okay okay so thread and concurrency
annotations so we're you know so the
Java concurrency and practice had a
couple of standard annotations thread
safe not thread safe immutable and
guarded by which basically allows you to
say that this field is guard you know
this is what locks you should acquire in
order to touch this field right and
we're looking and my only sort of
concern about that is I haven't thought
real deeply about this I think what
somebody really needs to do is apply
them to a large chunk of code before you
know we'd be really happy with them but
you know they're the best we've got at
the moment and we'll probably include
something like them what's wrong with
this code well it's hard to see but the
promise doesn't close the file and so
one of the little subtle details that
actually isn't even documented well in
the Java doc is that properties dot load
does not close the input stream that's
passed to it
and so we'll probably have annotations
or current suggestion have annotations
will not close will close or will close
wind Coast right said you you would
typically put these would typically be
on a method parameter right simply say
if you invoke this method is this method
going to close the object and the only
one which is a little subtle as this one
would typically be used for factories or
constructors and it would say that when
you close the object that's returned
then whatever you were passed in will be
closed we're almost going to get close
to our time so two more that I found
really useful check return value and
injection annotation so check return
value indicates a method that should
always be invoked as a function not a
procedure there are a whole bunch of
these in the JDK for example string dot
to lowercase if you see a statement s
dot to lowercase open paren close paren
it's almost certainly wrong they're
thinking that that's going to modify the
string it's invoked on but it doesn't
because strings are immutable it returns
a new one big that one has effects right
well actually start not get class I was
thinking of class not for name I'm get
class
yeah actually I would put in that check
I mean you know I have actually seen
code that will for example and get the
length of a string as a shortcut for
check asserting that the strings not
know okay so at anything so but this
will so we've already done this we've
basically gone through the JDK and come
up with a bunch of methods that if you
invoke them like this it's a problem and
the main thing is we won't allow people
to do this in their own API so we want
to allow people at Google to put this on
api's within the Google code base says
if you invoke this method you better
look at the return value we've thought
about things like idempotent and things
like that and I think those are more
complex than simply saying if you invoke
this method look at the return type
Injection annotation so static analyzers
get confused if there's a field or
method that's access to be a reflection
or injection they don't understand that
that can happen a lot of people have
their own annotations that they've
defined that indicate that you know you
know the framework should do some sort
of injection on this field and so what
we're going to do is we're going to find
a meta annotation so we'll define
injection 't annotation and if you put
injection annotation on an annotation
you define called X then wherever you
use X static analyzers will understand
oh this thing is going to be manipulated
through some way I don't see in the
source code okay so over the past six
weeks Dave Hoover Meyer and I have
largely implemented what's described
here for type callfire's mostly Dave we
still need to work on the validators and
that type qualifiers with exclusive and
exhaustive values but other than that
the basic type qualifier stuff is done
we haven't done like will close must
close so I will close won't close stuff
and I'm at now actually about ready to
wrap up so generic wrap-up slide static
analysis is effective at finding bad
code one of the questions is this you
know is bad code found by static
analysis important problem getting the
static analysis into the software
development process big problems has
been worked on here and annotations will
be helpful and I think the two things
one we guy get developers to use them
and the other thing I think is that
coming up with a way that we can enable
developers to express the design
property is this special type qualifiers
in their codebase will make it far more
useful than if we come up with a JRE
that's restricted to expressing five or
six or eight or twelve concepts that we
could squeeze into the jsr in that point
I'm out of slides and Dave I actually
got through like 70 slides in an hour
yep alright so some a brief questions at
this point need answers
okay thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>