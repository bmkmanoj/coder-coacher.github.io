<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Haskell Amuse-Bouche | Coder Coacher - Coaching Coders</title><meta content="Haskell Amuse-Bouche - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Haskell Amuse-Bouche</b></h2><h5 class="post__date">2011-10-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/b9FagOVqxmI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks everyone for showing up for a
crazy taste of Haskell I'm Marc and zero
blah blah uh so Haskell is scary you've
all heard it you've all heard the rants
on Reddit right you know it's got no
state um you know who wants laziness
laziness is what's lazy you know and PHP
has you know combinatorial screw that
and after all didn't we just spend the
last twenty years
like making dynamic languages rule the
world I mean we did didn't we
right and monads um okay but Haskell is
actually really scary cool it is
functional which turns out to be kind of
scary and cool and it's lazy and it has
high order functions and type inference
and Shh it has monads okay this is why I
got hooked in the into Haskell I've
actually been programming for more than
half the time the profession is even
existed and so three years ago when I
ran into Haskell or sort of looked at
Haskell again I was shocked and really
enjoyed that like my god there was like
something new to learn about programming
I mean something really new so that was
fun
um it really does twist your mind I mean
you know Haskell is really makes you
really rethink a lot of stuff but the
two things I think it really got me is
look the language is beautiful you write
code and you just look at it you're like
wow those are like the nicest seven
lines of code I've written in the last
month like they're just gorgeous you
know and so it's really beautiful code
so because of that reason a lot of code
to show you I have 50 more slides and
every one of them I think has code on it
so we're gonna go really fast but you're
all Googlers so it'll be no problem oh
cool not you we need a mute on some VC
hopefully some tight oh this no new
commute don't know if it is alright the
code is gonna look like crazy moon
language it's just insane you know it's
just totally different well not really
but it is different so just be brave
okay just be brave
all right um there is a git repo if you
want to pull everything although of
course I edited the slides 15 minutes
before we started so it's not quite up
to date you can just Google for Haskell
amuse-bouche and the first hit is this
repo and I haven't pushed yet to get the
latest stuff so it's a little bit out of
date from the slides um but it has not
only the slides it has all the source
code I'm going to show you in Haskell
files that you can load up in the repple
and edit so you can play along as well
if you want but I'm not going to give
you too much time so let's start with
something really really familiar
um this is bash not Haskell right and
this stuff should look pretty familiar
to anyone there we go
Oh beer all right this is just standard
pipelines on the shell okay what do they
all do they all take input they process
it they produce output as soon as they
are able that's actually a feature of
most most Unix commands most of those
commands do not modify any state
actually I chose ones which didn't
modify any state at all right but those
are useful things you do all right in
short those are functional pure and lazy
right so you're actually used to this
stuff it's actually not as crazy and
weird as you think and you know the bash
shell or the shell and the concept of
the shell has been around for how many
decades now and we still use it so it
might have some value there okay let's
rewrite that in Haskell hopefully that's
big enough for you to read so there's
some gobbledygook on the first line
which we're going to ignore for this
millisecond there's a next line we're
going to talk about a lot and if you
stick that in a file called run has in
part one HS and run it you give it this
poem as input and surprise it sorts the
lines and gives you that at poem as
output Zen master batch Oh haiku for
those who want the reference okay so
let's look at the actual processing
right which is right on that first line
it is not exactly rocket science we're
going to define a function called
process which takes some tea some text
and it's going to call some functions
and the only difference from what you're
used to is that functional arguments
don't go in parenthesis we just use
parentheses for grouping so
be brave just look at the code get the
lines of T means take this string and
turn it into an array of strings over a
list of strings technically a list sort
that list and then unlined switch is
another library function which takes a
list of strings slams new lines into
them and throws it all together all
right so the first line should be like
dead clear right let's see anyone
looking strained you can like get
everyone's nodding yes so good okay now
I know I had to take you back to high
school and everyone hates that but in
high school you algebra but Chris you
know you learned this right F of G of X
can be written as this funky thing with
a dot in the middle right right just
function composition F of G of X all
right so you can see that well in
Haskell it turns out that's actually a
programming language feature so in the
same way we can do that up here we can
factor you can sort of rewrite this this
way right so the function process of
some text T is applied to that text T
the function lines composed with sort
composed with unlined x' right so that
dot operator is exactly like it was in
algebra all it just means is apply the
thing on the left the result of having
applied the thing on the right so
unlined zit then sort it I mean lines it
then sort it then unlined zit right it
reads kind of right-to-left which you
might seem kind of strange to you
because bash things go in the other
direction but look up here right I mean
it's just getting rid of all these
parentheses okay now here comes the real
brevity we can actually do algebraic
simplification or it's sort of the
equivalent so work with me here if
process of takes some input right
processes a function apply to some input
T and all it is is this composite
function these three things applied in
sequence to T in Haskell we should get
rid of the T's because we can say well
processed by the way the tick marks are
just valid characters for identifiers
and I had to name them all three
different things they can go in the same
file process double tick mark is a
function that is just the composition of
these three functions
I lost anyone yet
good onward okay so we can code a bunch
of other ones we can say sorting lines
is unlined dot sort lines right compose
those three we can reverse lines we can
take the first two lines because take
two is a no it does what you think right
so anyone see a pattern it's a pattern
it's algebra we can factor it so we can
actually write a function called by
lines which takes a function f and it's
equal to we just write the same
expression but stick our variable in the
middle right so by lines of F is the
same as having written on lines F dot
lines so now I can rewrite those three
functions sort lines right by lines sort
reverse lines by lines reverse first two
lines by lines take two yes yes no yeah
okay getting yes it's good
all right let's write our own okay I'm
going to write a new function sort of
from scratch Earth's hold indent this
funny line at the top is a type
declaration it says indent is a function
that starts with a string takes a string
argument and turns it into a string has
a string result it's kind of very
functional style notation oddly enough
all right anyone noticed that this is
the first type I have shown you anywhere
all the other code is completely 100%
valid Haskell you'll find it in the in
the files that are with the repo exactly
as I wrote it here with no additional
typing so Haskell is a language that is
really strongly typed and yet we didn't
have to type any types
that's because Haskell is type
inferencing which means that when you
type some when you write line of code
the expression Haskell figures out what
type that must be when you write a type
two the first order of approximation 98%
of time the type is for you not for the
compiler in fact the compiler ignores
what you write as a type figures out
what the type is on its own and then
says did he get it right
now you might think that's kind of crazy
like aren't like should we but now the
compiler it's there because we write the
types as communication between
programmers and a communication of our
intent and the compiler is actually
checking us checking to make sure we're
honest
okay so indent is a function from string
to string it's really complicated it
takes an argument s and it appends
that's the double plus operator a bunch
of spaces to the front great so we
should be able to follow our pattern all
right by lines sort by lines reverse and
say by lines indent anyone what I guess
boom doesn't work and the worst problem
is if you put this into gh so you'll see
this horrible thing down there
that is the Haskell compilers idea of
poetry um it's writing you kind of a
love poem but it's from a compiler and
so as a consequence we ignore it to the
degree that this is just crazy moon
poetry and you just have to deal with
the fact that it's there and most the
time you just figure out what line
number it isn't go look again okay what
is the problem the problem is all our
other functions sort and reverse took a
list of lines and did something to them
but we wrote something which takes a
string okay so we're going to use
something called map map to the rescue
now you've probably all at this day and
age programmed in a language that has a
collections library and that collections
library has either a for each or a map
function right and usually map takes a
functional argument function pointer
depends on the language you're working
in and iterates through the collection
applying the function and gathering up
all the results and returning you a new
collection this is nothing new map
exists and you I'm certain everyone here
has been exposed to a map function and
just to make sure we realize what we're
talking about I gave you some examples
compare if we map Reverse over this list
of strings right it reverses each
individual string versus mapping reverse
to the list of strings which map
reverses the list itself got it right
same thing is like sorting um some of
you might at this point be scratching
your nose and go wait does reverse work
on a list of strings or does reverse
work on a string the answer to that
question is yes does both
okay so to indent each line of our poem
right I have to do something by lines
but I better map right by lines expects
a function over a list so I'm going to
map indent over that list by lines map
indent I could also factor that whole
pattern out because we had a thing
called by lines have at each line given
a function now I've written as now
written a type given a function from a
string to a string notice the
parentheses and a string return a new
string so let's look at what that's
gonna happen each line F it's going to
take this it's going to take a string
apply lines to it give us a list of
lines map our function f over each
individual line and then unlined the
result back together into one big string
to return so each line is now a useful
utility function which does something
apply something to each individual line
yes ah no it is not so the question was
and when you write map space indent is
that the same as indent dot map no it is
not we are passing indent as a function
as an argument to map map is a function
right there's no period or object
there's no receiver in this language it
is not object oriented so map is just a
pure function at the top there um but
we're gonna you're getting close to a
problem anyway close to a minute
so indent line we can do it this way or
we can use this common at or the thing
we just built called
each line each line indent and if you
run them either you get indeed an
invented poem it's very exciting but
wait where is the second argument to map
I told you back here map takes a
function and a list and returns a list
in fact at this point looking at that
top line should hopefully be kind of
clear that that's what that says it
takes right starts where it takes a
from A to B a list of A's and gives you
a list of B's but in this code up here
there is no second argument to map where
is it right of course it's not there
because map of F so look at map this way
we can say map takes a function from A
to B and because of associativity just
trust me
I can parenthesize the remainder so you
can think of map as taking a function
from A to B and turning it into a
function from list of a to list of B
right that if I just apply map to the
first argument I get back a new function
it's called Karine it's curried and I
get back a new function of function with
list a B so it turns our indent which
only works on a string to a version of
indent which works on a list of strings
we call this lifting we're lifting up
map is kind of bringing our simple
function up into the world of of lists
and that's what's going on all right I'm
gonna write some more code here quickly
we want to yell because we like yelling
right so this is another function from
string to string and so I'm going to
yell and I'm going to map this function
called to upper it's from the library
yes it upper cases characters I'm going
to map that over the string and append a
bunch of exclamations and I'm going to
write yell each line I'm going to use
our each line function to apply this to
each line of the poem and indeed what
happens I've yelled each line of the
poem not particularly exciting it's
pretty much what we did before but what
if I want to yell each word well we're
very very lucky there's actually like
lines and on lines the library has words
and unworried so we can define
equivalently a function called each word
that given a function we'll apply it to
each word of a string so all right we
call words which breaks it up into a
list of words we map F in this case yell
over that list of words and then we
unwearied all back together and when we
go off and do this crap it all comes out
on one line
right because it broke all the words
apart all the words got slammed together
with spaces and we lost all the lines so
what do we really want to do we want to
yell buy words buy lines well guess what
we can actually write yet another helper
function each word on each line right
given a function f this will apply to
each word on each line by wrapping our
function in each word and then calling
each word on our function and then
calling each line on that and indeed if
I apply that I get this right and I've
managed to preserve the lines and do it
to every single word notice that I have
used the very functions we have defined
ourselves as functions two more
functions we've defined ourselves right
so what bus do we just get hit by this
is the power of higher-order functions
right you can very quickly build
yourself up a library for doing higher
level manipulations of things and then
reuse it very very very quickly onward
okay so we've talked a lot about
functions what about data got to have
data in a program somewhere so of course
we're gonna talk about structured data
we might as well talk about lists and so
one could choose to define lists like
this this is actually a user-defined
type this is not the built-in list it's
just a list if you come from a certain
persuasion you might choose to call that
nil and cons instead of end of list and
link but let's just read this when you
have a piece of data of type yes either
good question so yes I actually wrote
the Alfa's because I just want to flex
that Haskell is actually defined in
terms of unicode whoo-hoo
and so you welcome to use Greek variable
names if you wish actually in fact you'd
probably not unlikely to see this most
people do in fact use Latin letters in
this particular context so that is
actually a type variable
well type variable um so this is so when
you have a list of some type either
note the or sign there either it's just
the end
list the empty list or it is a link of
the list with some value of whatever the
hell alpha ends up being and then
recursively another datum of type list
alpha right this is just standard kind
of recursive definition of a list okay
so we can all play around with some
obvious types right B we can define the
value empty equals the end of the list
notice that we can kind of use these
user-defined options we call them
constructors to don't think constructor
like C++ or Java empty is end of list
one word is a link of the string Apple
and the end of the list right so that's
a one word list two words is a linked
banana and then in parentheses I create
another link of cantaloupe of end of
list right kind of sort of should be
sort of straightforward be brave just go
for it
all right pop quiz if we've given those
three things I just typed what do you
think happens with the bottom one of the
first mysteries so anyone guess what is
mystery number one it is a list of a
pair it's one thing right so the first
thing this is showing you is that right
remember there's no modification of
state in Haskell so when I declared
empty equal to end of list I can use it
just as well anywhere else you might
think that's annoying because if you
can't modify state but it's actually
really nice because things factor really
well like the guy who wrote mystery dot
one is like look this is a single
element list I'm certain of it you know
isn't gonna change out from underneath
me mystery too well you can compose
these things link the string peach and
then what and then some other list right
some other item has to be another list
datum so mystery two is a two word list
right peach Apple mystery 3 anyone want
to guess what mystery 3 is once we brave
what lots of finality it's an infinite
list of pineapples Haskell's perfectly
happy with this completely happy like
you type that in a CIL's like sure no
problem what works fine um anyone guess
what mystery 4 is yeah it's a type error
right because something that's odd
here's that lists are right we said it
was a list
some type and all these other ones have
been a list of string this first link
has an integer but the second link has a
string and if you looked at the
definition you'll notice that it had the
same alpha in both places yeah um what
is the context of mystery these are
typed at the top level yes yes so so
your names are in school the top level
Sam it's a root it's a mutually
recursive set of definitions yeah so you
can refer to yourself and the reason
that this doesn't go off into infinity
at this moment is it's lazy alright so
no one's asked for what happens after
the first link of that list so we
haven't bothered to go look there and
the fact that we will eventually go look
one step further is fine um okay so yes
number four is a type error okay let's
write some quick functions on lists oh
good I'm doing great on time
all right here's some examples of how
you write functions notice list back
here has two different kinds a datum of
type list can have one of two forms it
can be the end of the list that's one
form or it can be a link that's the
other form so strangely enough it is
common that all our functions on lists
will have two clauses yes yes no not of
the type you are used to there are
strange weird wonderful odd things which
you will be tempted to use in your first
weeks of Haskell you know that lets you
do this oh I really really really need a
help you know heterogeneous type um and
and then when you've used Haskell for
six months you're like I was so foolish
I never needed that heterogeneous type
ever so this is one who's got to be
brave and like trust that this sounds
crazy that you can't do this but in fact
you really won't actually need it mmm
there are other ways to achieve what
you're trying to achieve which are
actually more powerful and more
importantly safer okay so some functions
because list has two forms a datum of
type list has two forms almost all
functions on it will
- clauses notice I have two equations
for drop one so we can read this pretty
straight for a drop one takes a list of
some type I don't know what type it is
and returns me a list of the same type
if it has the form linked first rest
missed first written pattern matched
variables they're just variables for
what we'd be matching in those positions
then it's just the rest of the list
having dropped the first link and what
if drop one gets a list of type form end
of list what should it do well I don't
know we'll decided that dropping one
element off an empty list is just an
empty list that seems like a nice safe
thing to do
all right we'll write end of list and
we're gonna guess what happens if you
leave off that second equation compilers
like dude you forgot one you're missing
out all right so one aspect about
Haskell um is that it's pretty easy to
make sure that you caught all the cases
all right it catches it at compile time
yeah a compile time it's like yeah you
missed one like if you really want to
miss one go turn off this warning here
but like we really don't suggest you
miss one why wouldn't you why would you
not want to miss one you don't to miss
one because right if you have all the
cases covered then you're certain the
function always has a well-defined value
in fact this is kind of something subtle
takes a while to get used to if you have
all the cases covered then you're
certain your function never crashes and
I mean never in a much more serious
sense than the never that you're used to
I mean it never crashes a camp like it
has a well-defined value all right if
you covered all the cases and the valley
dozing a plane right then the only
possible problem that the function could
have I mean it might not implement what
you're trying to do right it might have
a different function than your compute a
different result
right the only thing you can really do
is go off into it you know go off you
know diverge go off an infinite
computation that's the only real error
that you could have left which is kind
of fun okay here's another function
called just one it's a little weird it
takes a list it returns a list if the
list is just a link then we return a
list of just that will first item right
and what do we do if there's nothing in
the list what should just one return I
don't know it's got to return something
or I get that compiler warning which
yells at me so I'll have it returned an
empty list okay seems kind of weird but
there's a function definition okay
we'll be back to reality actually high
schoolers you know lists are really
commented we don't like to type so much
and so this is from the standard library
I want to point out a little bit
something amazing here the syntax of the
square brackets is actually built into
the language but the type list isn't
this is actually defined in a library
file whose source code on your
installation you can actually go find
and look and inspect in fact you can
copy it into your own modules and create
your own version which is kind of
astonishing right I mean it's actually
built in the language there's nothing
magical about how this works so here's
everything I just wrote but written with
this new notation
notice I'm end of list is written at
this funny empty square you know double
square brackets and link is written by
an infix operator called : right so
colon puts an item the a on to and this
is kind of a funny list of a don't worry
about too much the the syntax of lists
looks pretty much like what you expect
in fact it's so much like what you
expect what I just wrote is has closed
don't even type that much and flip back
and forth a little quickly between these
two big whoops it's not that there you
go the only real difference is on these
lines people like to write lists this
way because they don't like to write the
silly : look at the colon write the
string Apple : linked on to the empty
list they don't like to write that you
like to write Apple you know inside the
square brackets it's purely syntactic
sugar that's all and these are all the
same functions and so much for that okay
two more standard things I'm going to
get to some code more code okay a string
is just a list of characters really
there it is and then there's this funny
other type a datum of type maybe it has
two clauses to just like lists had two
clauses but it's even simpler than list
maybe is either a datum of type maybe
some type is either nothing or just a
single value it seems kind of a crazy
little minor thing to write
this is how you'd use it like maybe if
this function takes pic message gets
maybe an integer right has to have two
clauses because there's two forms all
right so we take message if it's just an
end then I'm going to construct this
string pick a number or like in you know
show is how you turn a value into a
string
you know display it and then pick
message if the value is nothing I'm
going to say a different message that's
how you use it just pattern matching
just like we did with lists so we had
this awkward function called just 1
right remember I said like on what if
the list is empty what should I do
like what should I return until the
awkward because I want the first thing
on the list but just 1 gives me the
first thing on the list but damn it's
inside another freaking list right it's
kind of annoying right so you might be
tempted to write the bad function at the
bottom in which case you would be bad
because look at it it says if the list
is here's some cool notation stuff we
like to we don't like to type a lot as
house close all right if the list
consists of a value a and the underbar
is yeah whatever I don't care
it's a variable that matches but doesn't
no one uses it then it's just a just the
first thing on the list but if it's the
empty list
well I can't like what a would I return
I mean if a is integer should I return 0
I don't know maybe 0 is a useful value I
mean what are you going to return well
it turns out there's like nothing you
can return in this case and so you write
error and error is this magical built-in
function which which like kills your
program and crashes it with a message
actually it does if you end up trying to
use it but so you don't want to use an
error it's a bad thing
so that's a very bad thing to have
happen so that this one like shuts the
compiler up but you end up inducing an
error into your program so here's a
better way so let's use maybe because
the answer is this function maybe has an
answer maybe it doesn't right and so
this is a much more clean way to write
this all right the first one of a list
is maybe it's something we either have
just or nothing okay
keep your eye on the code very carefully
here is a real function that finds the
first character after a star so given a
string maybe it's going to return a
character maybe chart notice we're
getting rid of nulls there's like no
null in this language right find after
star well if I have a list of a
character and another character and then
the rest of the list then if that
character equals a star let's return
just D because we found it we have a
character after a star else let's just
recurse find after star
we'll put D in front of the rest of the
list and call it on that list let's have
another Clause if all else fails under
bar this is a catch-all catches
everything then nothing there is nothing
after a star got it
anyone confused on how that code works
nope yes yes so the question is are the
pattern matching semantics in order and
the answer is yes they right they trust
in the order that you write them none of
this funny reordering or any that stuff
it's like exactly just read it in order
that's how it tests it makes it easy so
just is right back here there's this
type called maybe it's a data of type
might all right so maybe has two forms
if you have a datum of like maybe an
integer
either you have a nothing or you have
just an integer so as two forms just
like the list had two forms a nil and a
cons or a end of list and a link so
there's two forms so we can return
either kind right here we could return
two things now in this case you might be
asking I'm not sure this question you're
asking is just acting like a function in
this case it's actually like a
constructor we're building a value of
type maybe so this function is going to
return a datum that has either two forms
just a character or it's going to be
nothing
constructors in Java constructors all
have the same name as the type yes yes
right every form has to have a unique
name right and that's how we distinguish
them and tell them apart
right and in in essence you don't in
another language the concept of
constructors you know you have
constructors are just different ways of
building up you know an instance of that
class but you know then you just have an
instance that class and they're all the
same this is sort of the other way
around right when you build up an
instance of maybe by using the nothing
constructor it is different in structure
than the version that has just a value
it actually is a different internal
structure no no this is user-defined
that's not it actually I mean it's in
the library it's standard but this is
just built out of the language ah
because you always need a tab with their
tags in the front that identify think of
it as a discriminated Union this is like
a union of different struts and you need
to have a tag in the front so you can
tell which one you've got and you use
that tag both when you build it and you
use that tag when you tear it up part
when do we tear it apart pick message
here is tearing it apart
it is looking at the Union and saying
huh is this value of maybe have a just
tag on it
oh then of course it's got a value a
that follows the just tag right and the
bottom one says oh does this value of
maybe have just a nothing tag on it
well of course doesn't have anything
else with nothing all it's got is
nothing nada okay so here's the version
that does string just at find after star
I'm going to change it to find after
charring to be a little more generic I'm
going to give it a argument takes
another argument a character upfront M
the match and so all I did is instead of
saying C double equals so I gave an
extra argument M you can see it up here
too to do too - there it is right you
can see that it does now compares
against M instead of against the fixed
character star I change the type
signature takes a character and a string
and returns maybe a character so it
finds after this character I had to add
another
thing here for nothing but otherwise the
code is basically the same oh and when I
recalled recursively I had to pass em
again okay I'm going to make this once
more generic so that this is this
function I made it a little more generic
by checking for any character let's make
this a template and make it work for any
type not just strings ready one two
three go
anyone notice the only thing that
changed okay
the name of the function find after elem
instead of find after char the only
thing I changed here is the type
declaration that's it now I did add this
very funny weird piece of cryptic
nonsense be brave just you know trust me
it's good all it says is that a is a
type that knows how to do equality
that's all that's saying but instead of
going from char to string number string
is just a list of char - maybe char I
just made this generic go from some type
a and a list of tittays and maybe a
notice that the code is the same the
actual body of the code is identical yes
ah boy you're like that you know like
string man from the question yeah so
mark what is the deal here like what
like like what is the type line the
answer is when we wrote this the
compiler compiled the bottom code and
went wow this is a nice cool generic
function it finds any element after any
other element in a given list oh man he
wrote this restrictive type signature oh
well whatever fine I'll only let him use
it in context of cars and strings when I
wrote this the compiler did the same
thing at rent looked at the exact same
code came to the same exact conclusion
and said ah his type line is right
that's exactly right that's the type of
that code this code is this code will
work if and only if a is a type that
understands equality it figured that out
because I used the variable here and it
figured out that indeed there better be
a list because I used the list
constructor here and it figured out that
the result better be dot maybe because I
use Justin nothing it figured all that
out automatically that's all it takes to
make your code generic it is really
common when writing Haskell
to suddenly realize that the thing you
just wrote for some particular case is
actually completely generic and you just
fix the type line and go on list of
charm no no no you don't have to
actually ever write that that's all
inferred maybe was written so when we
wrote maybe writes the issues like well
okay so what happened like there's maybe
int and maybe char but I just wrote this
thing called maybe a know that a didn't
mean oh yeah when you get around to it
like type a version with replacing a
that really is a type variable huh so
you write that line and maybe is now
defined for every type past present and
future and it's already in the library
okay onward now maybe actually is really
important maybe is so important that
maybe is actually the thing that blew my
mind this silly little teeny tiny
itsy-bitsy type this was like the first
thing that like after my first two weeks
back and asked I was like oh okay this
thing is really useful okay these
functions I just wrote they're type
signatures and you don't really pay too
much attention them cuz just look at the
names these are all functions you've
used in libraries all the time find the
index of an element look up something an
app right strip this prefix from this
string you know get the port out of a
URI anyone ever written that one okay
these are all functions which may not
have an answer and in almost every
language and in every library I have
ever seen gee whiz we write conventions
like if the element is not in the list
return negative one anyone ever been
bitten by that ever Curtis right that is
a sucky design that's just bad look how
easy it is when you have maybe because
you can declare precisely and so here is
the first ah-ha about types and Haskell
types and c and c++ as we know are for
the compiler to make sure it lays it out
in memory correctly I mean at least
initially types in Haskell are for you
to communicate with other programmers
what you mean in a really deep sense in
a sense I think that is
deeper than others right so these are
all examples of functions where maybe is
far better than returning null did null
mean it wasn't there didn't all mean it
was an error I mean what what is that
null like I don't know what that null
means is the empty string and error or
did stripping the prefix from the string
return me the empty string because it
was only the prefix or did Embree right
you all see the errors here right okay
yeah
so let's look how you use this so it
turns out there's other fun stuff about
maybe because once you have something of
this concept into the language or you
can build language you can now start
building better utilities for using it
right so for example all right here's a
function called add a weekday comes from
a library right so we add days seven to
some day object and we get you know one
week later and imagine I've got some
list of interesting dates and we're
going to use our first one function
which given a list returns maybe one
right because if the list is empty then
you get nothing so I want to find all
right
one week later from that interesting
date I can't apply add a week to an
interesting date everyone see why I
can't apply it directly right add week
takes a day but interesting date has
maybe a day right because there might be
a nothing so how do you do that now in
most other languages what we would
probably do at this point in our code is
we would write an if statement right if
date equals null then do this else right
okay and we would probably propagate
that null further up the line if date
equals null return null else add seven
to the date okay here we use F map what
is f map well you know what map is right
map took a function like for example add
a week and map what apply it to a list
of days adding a week to every single
one F map lets us take a function of
days and apply it to a maybe day an F
map says well if we just have a day then
we'll apply it to the inner
you and return just that and if we have
a nothing we'll just return nothing will
propagate the nothing F map does exactly
what we want
so furthermore if you want to think
about this like sorry have I lost no on
how F map whatever map does f map takes
a function from A to B from a to a
actually form a to B but moving on that
in this case it takes the add a weak
function which goes from day to day and
allows us to apply that function in set
to the value inside a maybe if there's a
just in there we'll apply it if there
isn't no not of course we think of it
yeah
well it's in the library but it is
user-defined yes ah how does how does it
know how to apply the real value not so
he isn't even bigger sort of a here's a
assignment for a true head explosion how
that is done is not built into the
language either that's in the library as
well so you can go find how F map is
implemented and you're like oh my god it
can do that that's cool um little
outside the talk but that that is that
is true right
yes there is writing code for that
although yes so alright so f map in the
same way that I said you could think of
map as taking a function from A to B and
turning it into a function from list of
a to list of B we can think of f map at
least in this context as taking a
function from A to B or in this case day
to day and turning it into a function
from maybe date and maybe day F map is
lifting your function up into this other
environment okay and so you can do a
week later now the cool thing about this
stuff is that all the stuff is in the
library you can build things which end
up being really powerful here's a here's
an operator it's got a funny spelling
greater than vertical bar let a less
than greater than or less than whatever
you can define your own operators out of
symbols and has
ad nauseam people sometimes do um this
function don't pay too much attention to
it does exactly what you think it does
it is short circuit evaluation not based
on maybe it runs the first function
favorite show which returns maybe a
string if the person has a favorite show
or it returns show with name right and
it does show with here so it takes all
right or takes two maybes and if the
first one is just a value it returns
that if it's nothing that it returns the
second one it's short circuit choice the
cool thing about this is this is not
right now we all work in languages with
the short circuit choice but they're
generally built-in and you cannot build
user operators that do the same thing or
user functions that do the same thing
unless you're working in Common Lisp and
you've got some scheme and you've got
some great macro system right but you
know most of us are stuck with you know
C++ where you can't really do this it
turns out you can make your own
functions do this kind of stuff all the
time because it is lazy and so the
reality is that any of these operations
can be extremely complex to compute but
because the or operator will never you
know if your operator never selects that
option and never returns it the
computation never actually gets done so
that's kind of fun here's another common
thing we often do right so this would
have been a series of ifs had we had to
write this with null as the key value as
the value indicating that there was no
answer root of this is syriza so this is
much more concise right okay here's
another thing we do so here's a set of
functions that like get head or takes a
string and a message and maybe gets a
string because there may not be a header
and parse Tate gets a string and maybe
returns you a date because maybe it
isn't possible and mailbox for day takes
a date and maybe we have a mailbox in
the users file system for that date or
something you know who knows what that
function does but they're all value to
maybe and so what I want to do is I want
to pass the values along stopping at any
point in the sequence in which I get
nothing
so get header for date that's answer is
nothing we're done we return nothing
otherwise I need to sort of unwrap the
the just value and pass it to the next
function parse date which if it succeeds
in parsing that header as a day
then I want to unwrap that maybe the
just get the date value out and passed
that to mailbox right so we would
normally write this as a giant cascade
of ifs the nested ifs all the way at the
bottom and the else avarage of the whole
either would return from the inner part
or worse if we had to continue to use
the value we'd have to set some value to
the default value at the top or null and
do the live you know it would be some
horrible nested thing and so we have
this kind of injection operator it's
pronounced bind which does that now I
won't get quite two in there but this
gets a little bit of the question about
like how does it know how to do F map so
it turns out that these functions these
things these operators are actually part
of type classes which I'm not going to
explain too much but are wonderfully
useful and the answer is that they're
highly generic so it turns out we can
use F map actually over lists we can use
that alternative thing with lists we can
use it with big news bind with things
that are monads these things are highly
generic and get used for lots lots of
expand places ok do we have time for
just one more yes we have 11 minutes so
go now the thing I really love about
Haskell one of the things I really love
it's a strongly typed language the types
really help you encode what you mean to
say to your fellow programmers the types
the compiler will really catch your ass
when you forget like oops you didn't
cover the empty case you know it's
really nice but here's the thing I like
most about the types in Haskell you
don't actually type them very much ok
here is a run length encoding ssin I
will not work through how it works you
can work that out fun little puzzle well
it's not really a puzzle just a fun
little piece of code the only type
declarations are on the very first line
it says if a is a type that knows had to
do equality then given a list of a I
will return a list of pairs of a and an
integer right this is standard run
length encoding and blah blah blah and
now I've got I'm aware lets me introduce
like local functions these are just
local functions that arm only using
inside this other function that's what a
where clause is I've got local variables
I've got this crazy function called next
group which seems to take one to three
arguments I think you know it's got
tests
it's got all this stuff in here the only
types I wrote are up at this top line
and yet alright the type of every single
thing on the rest of this function has
been completely inferred by the compiler
checked and verified and I get all that
protection for all those things even
though I didn't bother to ever write
their types right this is like the like
the Epiphany here was like wait a minute
it's all the benefits of type checking
or even more benefits of type checking
but I write it like I used to write
Python where I didn't write types
anywhere like oh that's nice I don't
have to write all those things now C+
C++ X 11 0 X 11 whatever it's called
these days has Auto the auto type which
is somewhat like this although I don't
believe it's quite as powerful or quite
as ubiquitous um and you know there are
languages that we use that sometimes
have types are not types or let you have
things on typed this is great this is
types that get all type checking but you
don't ever type them now let's compare
that to C++ right we that's fun um there
are a lot of types here and what bothers
me most as a programmer is there are a
lot of types that are repeated a lot
okay so first off I have to tell C
something that this is generic okay
whatever then I have to decide list of a
pair of T's and ins okay that's a lot
more wordy than the way you write in
Haskell but I had to write that in
Haskell and it takes as an argument a
list of T's I had to write that and
asked Haskell to will ignore the
constantly and then I had this local
variable and crap I had to duplicate the
freaking type again and I had to do that
and then here's the line I really love I
have an iterator but I like that I have
to type type to tell the compiler that
the next thing I type is a type right I
mean this is really bloody awesome now
it's true C plus the new super plus plus
will let you write Auto there and we'll
figure it out yay C++ learn something
from Haskell or other type inferencing
systems but there's a lot of type stuff
you have to write here and it's pain and
it's gnarly and it's in the middle of
all the damn code and it annoys me by
the way just on there a minor little
point um the type system has lots it can
lets people do crazy wonderful things if
you've never encountered a quick check
library I don't know if Haskell was the
first quickcheck library but I think who
knows but it's certainly a here's a
bunch of properties about that
run-length encoding function I've just
simply written them as functions from a
given input and two boolean and I expect
these all to be true like I expect that
the length of the list equals the sum of
the second elements of the run length
encoding list oops right sorry that line
is really long
right I'm run length encoding the second
elements of all of them and I sum them
and I expect that to be the length of
the original list that's kind of you
know a run length encoding invariant and
these are all various invariants that I
just wrote
okay I would like to actually test this
so I could go to my unit test framework
and write you know several hundred you
know unit tests or I could write by
probably what maybe a dozen tests unit
you know test cases for this by hand but
in Haskell because of the type system I
can use a thing called quick check and I
can ask quick check just to check this
function and quick check will derive
from the type of the function the
possible set of inputs that could go
there then generate test cases and it's
relatively smart about generating test
cases that actually matter like you know
like oh it's a list I better try empty
list that's got to be really important I
better try a list of just one item you
know it gets all the good corner cases
and it generates cases so this actually
allowed me to run 300 test cases on my
run length encoding function you can
actually really honest to God like pull
this in type it and run it this is the
entire sorry that plus this plus the
loading the module quick check is all it
takes to be able to run this there was
no actual additional scaffolding I've
left out so that's actually really sort
of fun okay so a few other things to
point out about the haskell ecosystem
we've gone to the language a lot but the
ecology of haskell is actually
tremendously nice to work with
GHC the glasgow haskell aureus glasgow
haskell compiler is the probably premier
standard in the most common used
compiler now it has a command-line
repple called GH CI the interactive
version which is just a delight to use
it's really trivial loaded all this code
up in there
and reload your code and you can ask it
things like I wrote this code and I
didn't write a type signature can you
tell me what the compiler thinks the
type of this code is that's actually
really common for Haskell programmers to
do god I want to figure out what it is
you just tell me
cabal and hackage cabal is a packaging
and building subsystem and hackage is a
very large package repository of now
about 3000 packages
Cabala is the nicest package manager I
personally have ever used it's the only
one you know that knows how to install
things locally just for you by default
you know I can do system installs or
personal installs and it does all the
recursive dependency analysis and
download and configure and reinstall all
those things and it's just a joy to use
um Haddock is the inline documentation
system which I admit I worked on so
recently so but it's nice it looks cool
Google is astonishing do I have three
seconds to show you who --gel I do he
okay oops that's um I want to do all
right
Google again the power of types Google
is a search engine for for code that
you've never seen the gist um let's say
I have a function I need to go from
maybe some value and the list of values
and I want to end up with a list of
values is there a function that does
that oh yeah there is um so you can
actually or you can say like like or
what's a better example like I've got a
I've got a string I'm looking for
something that's like uh I don't know
you know what manipulates to string you
know you can actually search by type
signature and find all sorts of
wonderful functions that you need it's
astonishing how quickly it is define
what you need and this search is not
just what's the search is like all the
packages and stuff so Google is very
wonderful and great mentioning it is
worth noting that I think until very
recently hash haskell on freenode was
the largest room IRC it has typically
six to seven hundred people on it it's a
very friendly community and it's a
really great place to go get your
questions answered any time of day or
night which is kind of fun want to learn
more go go Haskell internally we'll get
you a bunch of stuff including some of
these links
as well Haskell is actually used here at
Google in a few select secret corners
find out more there what else learn you
ask these are some great online
tutorials and stuff and we're done
Thanks I have two minutes for questions
so we ask what does it look like when
you write big table or some big giant
server and is it this pretty um the
answer is uh yeah lots of it are so one
of the nice things about Haskell is it's
very easy to cleanly separate out parts
of your code it's really good at its
ability to use modularity and reuse is
very very high and so often is really
easy to take um the parts of your code
that are gnarly and dealing with the you
know the network stack and dealing with
you know the vagaries of well like I've
written I've written back-end web
servers in Haskell that do standard
stuff talking to my sequel and it's very
very easy to sort of encapsulate because
you can do all these really nice
high-level functions but deal with the
i/o stuff or deal with the database
stuff you can stick that on the side and
then have like your logic be nice and
your logic and your business logic if
you want to call that back-end stuff
really clearly separated out it's also
the case that because of the high order
nough sand the laziness often in
libraries we have to because we don't
want the user to actually execute user
code if it's not necessary we all have
to bubble control back out to the user
users of libraries or generally have to
do the control operations high level
control operations and in Haskell you
can you can bury all that back down in
your library so the short answer is yeah
it's a lot nicer in my experience
writing the exact same server in well
big server library in C++ Python and
Haskell the Haskell code was literally
one-third the size I can give you
pointers that codes open source you
won't actually see the comparison of
Pascal that's one third of the C++ size
it's about half the size of the Python
let's say Pascal
that's not Python yes it was a question
over here
which office has all the people yeah
who's who's the big office is that oh
cool
Wow hi New Yorkers great anything else
um I can answer that question offline
yes it's in yeah our build system has
stuff in it that blaze has support for a
school well I don't like to write a
client a web front-end code because I
can't get the damn castle to run inside
the passer on the front end I would in
an instant um you know in my mind
Haskell has over the last couple years
finally traversed into the realm of like
yep it's a good general purpose
programming language with enough
functionality is do almost any kind of
stuff that you need um I don't know I'm
too much of a fan to answer that
question man my answer is I do
everything in Haskell oh if I can all
right I can stick around we're
officially over and we can stop the
recording thank you
and I'll stick around if anyone wants to
talk or go over a finer</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>