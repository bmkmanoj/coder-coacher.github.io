<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A quantum computer can determine who wins a game faster than a classical comp... | Coder Coacher - Coaching Coders</title><meta content="A quantum computer can determine who wins a game faster than a classical comp... - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A quantum computer can determine who wins a game faster than a classical comp...</b></h2><h5 class="post__date">2008-04-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gKA1k3VJDq8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning everybody and
honor for us to have advert fire with us
today
advertise the director of the centre for
theoretical physics at MIT and by
training and by heart at this particle
physicist but that didn't prevent him
from becoming one of the most
influential thinkers in quantum
computing Edward is the inventor of the
quantum adiabatic algorithm which think
for folks like me who work in machine
learning pattern recognition is probably
the most enticing entranceway to quantum
computing people who are familiar with
concepts like simulated annealing even
though it is and it's called a different
algorithm sort of the flavor how you
present data and how you get results out
of it are very similar and easy for us
to get into so Edward today will present
his newest work and very curious to hear
this talk on my own ok thanks very much
for having me let me get my thing up and
there's my talk oh wait a second option
command ow
and I go bad ok so my talk is really
about what I call physics based
approaches to quantum computing what I
want to talk about is using physics to
design algorithms and I'm gonna do this
really by example to show you that we
can use physics to design algorithms and
the example that I want to focus on has
to do with games determining who wins
game and let's begin with that I want to
imagine we have a game and a game I'm
going to abstract the game down to a
game where we just have two players each
of which who could make two moves and
the game is a finite game
after M moves the game is over so what I
have up here is a depiction of oh this
is kind of confusing these are the same
okay right there's the natural tendency
to think this is the next slide but it
isn't it's the same I gonna deal with
this okay that's the same slide so I
have a I have a two person game and each
person can make one of two possible
moves in their M rounds so I'm gonna
represent the history of the game by a
tray so we start right here at the
bottom and it's my move and I can either
go left or right then it's your move and
you can either go left or right and then
it's my move and I can go left or right
so as we go up the tree we have a
depiction of the possible histories of
the game and at the very end of the game
every final position is either a win or
a loss for me depending on the rules of
the game that's what defines the game
the game is defined by the the rules
that say whether a final position is win
or a loss for me please ask questions if
it's not clear okay and the way the game
is going to be given to us is if you
know the final position if you you can
look up on a table or make a query and
see whether that final position is a win
or a loss for me now so and I really
almost any game can be put in this form
chess can be put in this form or
checkers I'm a limited I just don't have
draws and I make it end after a fixed
number of moves okay any questions so
far now in this situation it's
determined at the beginning who wins the
game if we both play best possible and I
would like to show you that um let me
show you why that is I just copied over
that game tree from the previous page
and at the top I had wins or losses for
me well let's look down here where it's
your
move at this point suppose we reach this
point in the history of the game and
it's your move well both places that you
can go are wins for me so you lose I
hope that's clear that you lose because
I the place you go is a win for me
if we reach this point in the history of
the game then if it's going to be a win
for you because you're gonna go to the
place that's a lose for me if we if we
go down one more layer in the tree if we
see if it's it's now my move and I see
that if I go here you lose well it's a
win for me
and if you recurse down the tree to the
very bottom using all the information
from the top you can determine at the
bottom who wins or loses by recursing
down the tree so this is a general
property of all games that if both
players play best possible it's
determined at the beginning who wins or
loses now it may be very complicated to
figure that out because if you play
chess there are so many possibilities
down here that it's impossible
practically to recurse down but in
tic-tac-toe we all know that at the
beginning you know one of us is going to
win and you can usually figure out who
it is so this this is the general
structure of a game and like I said it's
determined at the beginning who wins now
but you can ask yourself the following
computational question do I need to look
at all the final positions to determine
who wins or loses do I have to query
every final position the answer is no
you don't have to look at every final
position let me show you why let us go
back to this corner which I've been
focusing on in this little corner if we
if we look at these two wins for me that
produces a lose for you and it that
means that at this point it's a win for
me regardless of what this is it doesn't
matter what these positions are if we
reach this point in the game
and I go here you lose so it doesn't
matter whether this is a win or a lose
for you I win if that's a lose okay so
in fact you don't need to query all the
final positions to determine who wins
the game you and there's a classically
there is a randomized algorithm for
determining who wins the game and it
requires end to the point seven five
three queries a query means a check of a
final position to see whether it's a win
or a loss at end to the point seven five
three no where does that come from well
the way you get the end to the point
seven five three is there's a recursion
you can write down for the number of
queries when you look at a subtree so
you write down the valid umber of
queries you need to evaluate this the
number of queries you need to evaluate
here and then you use that to infer the
number of queries you need to get there
and when you solve that recursion you
get a quadratic formula and this point
seven five three involves the square
root of 33 so I'm not going to show you
this algorithm this is classical but
this algorithm this end to the point
seven five three is best possible what
yeah it's yes this is there is no better
algorithm than this it's a randomized
algorithm and its best possible so so
what we are going to now show you is
that with a quantum computer we're going
to do better than this then the end to
the point seven five three okay so we're
going to I'm going to show you
eventually a quantum algorithm that
outperforms the best possible classical
algorithm for this problem now another
just one word on notation here this
thing game tree evaluation is equivalent
to something called nan tree evaluation
because if you look at the rule of the
game the way I had it in the tree the
rule for the evaluation of the tree if
there were two losses above you there
was a wind below a loss and a win above
you it's a wind below a win and a loss
for your opponent is a win for you below
where two wins for your opponent is a
loss for you but if you look at the nan
gate that is exactly the same thing if
your place in L buy a 0 and a W with a 1
so this is sometimes called NAND tree
evaluation and in all paper it's called
Nana Nana tree evaluation so a nan tree
is a tree where I put a string of zeros
and ones on the top that's the input and
at every vertex below you have the NAND
of the two things above it and then the
question becomes what's the NAND at the
bottom given the input so it's exactly
the same problem the game tree as neon
tree evaluation but nan trees the NAND
is a universal gate for computation and
nan tree evaluation is led to circuit
evaluation of boolean formula evaluation
so this is not just an exercise for
games ok now I our what we're going to
now do is I'm gonna switch to quantum
mechanics and I assume some of the
people in the audience I maybe I should
even ask how many of you had an
undergraduate class in quantum mechanics
okay that's a lot good hmm just a
graduate one okay that's just as good
okay did you get a good grade okay go to
just check okay so I want to give you a
little refresher so let's just walk fast
quantum refresher I'm there summarize
everything we need to know about quantum
mechanics
if you quantum systems is described by
finite dimensional hilbert space the
reason I'm only I'm only gonna really be
interested in finite systems I'm gonna
use an infinite system as an
approximation but we have finite systems
and the way a quantum system is
described is by a Hilbert space a
complex Hilbert space and we have
vectors which live in this Hilbert space
and we depict the vectors just so we get
my notation by these things called cats
and the thing inside the cat is the name
of the vector so this is the vector
whose name is sy if we have two vectors
there's an inner product which we denote
like this and we can have a basis for
this Hilbert space so we could have a
set of ll vectors which span the space a
linearly independent set where a goes
from one to the dimension and then a
sigh is the component of Saia in this
basis if this is an orthonormal basis
for example that means the inner product
today with B is Delta a B
that means that this that they're
orthogonal every vector is normalized an
orthogonal to the others that's called
an orthonormal basis and the inner
product of syusai is then written as the
sum over the components squared of the
vector of this quantity
okay everyone know this much a quantum
mechanics now if we continue just a
little bit more all quantum systems obey
this equation this is what I call the
Schrodinger equation I set h-bar to 1
which means that there is the time this
is the time evolution equation of the
system it says that given the state at
one time I can determine it the next
time by solving this differential
equation this is the Schrodinger
equation it's never been violated
there's never been a violation of this
equation ever seen it's consistent with
relativity we need to go do relativistic
quantum field theory you just get a nice
relativistic Hamiltonian but this is the
basic law of quantum mechanics and note
that the evolution is deterministic
because if I know the wave function at
early time I solve this differential
equation I get the wave function at late
time in when you make a measurement
though probabilities can arise and the
way measurement works in quantum
mechanics is you associate with
observables which are things you measure
operators which are hermitian operators
and every observable corresponds to
hermitian operator and these operators
have eigenvalues and eigen value means
the operator acting order matrix if you
wish acting on us on a vector is a
number times the vector so the way to
read this equation is this cat is has
its name is given by its eigenvalue so
this is the cat whose eigen value is
lambda sub I which is an I it's an
eigenvector corresponding to the
eigenvalue lambda sub i and according to
the rules of quantum mechanics when you
make a measurement you only ever get
eigenvalues and if you're in the states
I the probability to get this particular
I can value is the inner product of your
normalized wave of your normalized state
vector with the eigenvector squared and
that these are the rules of quantum
mechanics and these rules have never no
violations has ever been seen okay and
so when we do quantum computing we're
just basically going to assume these
rules since they are they are god-given
and never been violated and then try to
turn that you see whether we can design
computers which use these rules as
opposed to binary arithmetic and see
whether we can turn that to
computational advantage okay any
question okay now
in quantum computation there's something
called the conventional quantum
computing paradigm and let me try to
tell you what that is again I told you
that every quantum system obeys the
Schrodinger equation which means that
your time evolution is given by this but
what that actually implies is that if
you have your state vector at an early
time the vector in a later time is given
by a linear transformation on the state
vector at an early time and that linear
transformation happens to be unitary and
what unitary means basically is inner
product preserving and the reason that
an inner product preserving in this
implies that your norm preserving which
means you don't lose probability so you
can view evolution quantum mechanically
either as a continuous time evolution
with a Hamiltonian or you might think
that what you're doing is applying a
sequence of unitary transformations
which take you from here to there and in
the conventional gate model of quantum
computation the algorithm designer
designs a sequence of unitary
transformations which the designer
thinks of as gates and the shor
algorithm for example for prime number
factorization is presented as a sequence
of unitary transformations which he
identifies he says do this this this
this this and out come the factors of
the number we are going to take a
different approach what we're gonna do
is physicist is design Hamiltonian not
the unitary z-- obviously these things
are equivalent in some way but when
you're searching for new algorithms this
the old the the the difference in
approach might help you in the discovery
of new things I'm not being I'm not
going to be philosophical about which is
a better approach I'm just gonna do it
by example you know if you can if you
could find something in this approach
it's the value okay
so in this context I would like to talk
about what is a general quantum
algorithm what's what is a quantum
algorithm well the first thing to have a
quantum algorithm is you need a problem
to solve because quantum computation at
least in the stage it's in now is not
Universal computation it's not internet
search what it is is it's solving
special problems like factorization or
game tree evaluation or and and these
spent and so you have to have a special
you know it's not an all-purpose
computer yet it's something which is
designed to solve problems so the first
thing you need is a problem then what
you do and what I buy a problem I don't
mean of course I don't mean factor a
number I mean design a program which
will factor for any input because we're
computer designers here we're not
looking for answers were looking for
algorithms which provide answers okay so
so we have a problem design to solve
then the then what is the quantum
computer algorithm designer do well the
designer then picks a Hamiltonian
because that determines the evolution of
the system the designer then picks an
initial state of the quantum system the
designer picks a runtime of the
algorithm the designer says the runt the
quantum algorithm is gonna run for a
certain amount of time capital T he or
she then lets the system evolve
according to the Schrodinger equation no
choice here so you start your initial
state you evolve the time T you then end
up in the wave function at time capital
T because you evolved with your
Hamiltonian from your initial state the
time capital T you then measure some
operator you make a measurement and what
you get out from that measurement is a
number which shouldn't or a string of
numbers and which an encode the solution
to your problem so that's the view of
quantum computation that I wish to take
general Hamiltonian time of
according to a design Hamiltonian
followed by a measurement which encodes
the solution to the problem now is this
a good thing to do or not well that
depends on how the runtime of your
algorithm scales with problem size and
that depends on how the resources needed
to build the Hamiltonian scale with the
problem size so this is good if you can
discover like for example with the
factoring algorithm which I assume some
of you have heard about that the runtime
scales very favorably in terms of the
number of digits this is a success so
we're going to that's our standard here
and of course I'm going to show you in
the game tree that the the the it's it's
a success we're going to do better than
the classical algorithm okay any
question about that but the general
quantum setup yeah no no no no he's out
the question I'm supposed to repeat the
question because there are people far
away the question was do we care about
implementing quantum computers not for
this part of the talk I looking at you
can ask me that at the end but for the
sake of this I would like to assume that
we have perfectly functioning device at
our disposal we have endless engineering
capability we just must do things
consistent with the laws of physics
that's our only restriction and after we
if we first see whether according to the
laws of physics we have advantages and
we worry about engineering later okay
okay now in order to I need to take you
in a little aside which hopefully some
of the people who know about computer
science know a little bit about this has
to do with what an Oracle lives to
people known and I know Oracle's the
other company but I mean the people know
what an Oracle is in computing you do
some of you yeah okay but I'm gonna go
over it I thought what an Oracle is I
would like to consider what I call the
conventional classical Oracle so the
classical means we're not doing quantum
computing for a minute and I'm going to
apply this to it the particular thing
which I call grover sir
Church I would imagine I want you to
imagine we have a function f of X and
this function is defined on the integers
from 1 to capital n okay and in this
function outputs a 1 on all the inputs
except for one of them which I call the
winner and it outputs a minus 1 at the
winner all the other inputs it outputs a
1 and this function is or racula in the
sense that you know nothing about the
function other than at one place it
outputs a minus 1 you have no other
information about this function except
that at one place it outputs a minus 1
and if you if I give you code for this
function which evaluates it I will allow
you to query the the function in other
words I'll allow you to say at 72 what's
your value function but I will not allow
you to read the code that generates the
function because if I if you read the
code that generates the function you
might see the if statement that says if
X is 999 output the minus 1 so by not
allowing you to read the code I've made
it into an Oracle which you can only
query now your task then is to write
code which can call F which will
determine the winner and what strategy
do you have well you really have no
strategy that other than to call F at 1
f at 2 F of 3 F at 4 until you find the
winner if you don't know anything about
the function and you go in random order
it's not going to help you so clearly
this problem takes of order n Oracle
calls to solve now if I go to the
conventional quantum if I take this code
for this function though and I and I go
to a quantum computer which is executing
which is works on a quantum system I can
turn this function call into a phase
multiplication in other words I now have
basis a remember I told you what a basis
was now I have a basis vectors for a
Hilbert space where X goes from 1 to N
and my function call takes the the
little basis vector X and leaves it
alone if X is not the winner because f
of X is 1 if it's not the winner but put
some minus 1 in front of it if X is the
winner ok and I can I can I'm not giving
a class here on elementary quantum
computation so you have to trust me that
this can be done but you can turn this
function call into this with very little
effort now if you do that and you make
function calls quantum mechanically
using the classical function actually it
turns out that you can solve this
problem with n to the 1/2 calls and this
is algorithm as best possible this is
one of the big results in quantum
computing because this is provable
speed-up because if you what does that
mean it means that if you the computer
time has to scale with the number of
Oracle calls of course if I if I copy
the code I can run it on two computers
but it doesn't reduce the number of
calls so we just have one computer so
the computer time scales with the number
of calls so if I have a fast classical
computer which is represented by this
because that slope it's very fast
because the time is very small because
I'm the slope is very little on my scale
the slope is supposed to be very small
but I don't want to draw it like that
because would look bad whereas the slow
quantum computer starts out like this
but there will be an N beyond which any
constant times the square root of n will
fall below any constant times n and this
is what we mean by algorithmic speed up
and that's what quantum computing is
about it's not about running a chip fast
it's about taking fewer steps to achieve
the answer than you do on a conventional
computer and this is called and this is
provable algorithmic speed-up because
the quantum computer has outperformed
the classical for this problem and this
is you know ok that's I'm not this is
just a known result in quantum computing
yeah
for that speed up for that end to the
1/2 does it have to do with
probabilistic nature I don't know
actually I mean I don't have a good
intuition for that first of all I would
say you have to be able to do two things
you have to be able to act on super
positions which quantum mechanics allows
and the other thing is you have to
introduce minus signs into the problem
you have to use interference if you
don't have interference it will never
fly and did you notice when I when I
told you the Oracle call in the quantum
set put some minus sign in front of a
state and you know the amazing thing
quantum mechanically is that you can
have something happen with with it with
the coefficient 1 and the coefficient a
and the square of that is a squared and
you can have something happen with
coefficient minus a and the square of
that is a squared but if I add them I
get 0 and the probability is 0 you can
have interference quantum mechanically
and you need that but I don't have much
into it should be on that
the other thing I should say about this
is the best possible you can there's no
quantum algorithm that will do better
than that
ya know if it's a data set it could take
time n in other words if it was a phone
book it might take time n but if it was
a function if it was some you know hard
to invert function which existed on a
computer was a satisfiability problem
and you know the output a yes if it's
satisfiable and no not i could that
would take very little time to encode so
you it depends on how I give you the
problem probably like log n yeah log n
log n I'll talk about that too
ok so now we're gonna have to switch
language though because I've talked to
you about the conventional Oracle but I
want to do things in the Hamilton with
Hamiltonians so I have to introduce a
new I'm gonna have to introduce two
concepts before we solve our nan
a problem before each other I'll walk
game three the first is the Hamiltonian
Oracle because we're comfortable with
the conventional Oracle but now I want
the Hamiltonian Oracle and that we're
gonna put like this I have a Hamiltonian
which is a diagonal matrix in some basis
and all the entries on the diagonal are
the same but what entrances entry is
different and I want to find the spot
where that is different and in the
Oracle model I can't look at the
Hamiltonian and figure that out but what
I can do is apply the Hamiltonian to a
quantum state so I can evolve with it
and in this rule according to the rules
of this game I'm allowed to build a
Hamiltonian which is the sum of two
terms the oracular pod which you can't
look at and a driver which you design
and we evolve according to the
Schrodinger equation so we take this
drop this so we we evolve a quantum
system with a piece which is kind of
hidden from us which we want to find out
about it I'm I'm trying to make a
parallel to the Oracle model and and
another piece which we design and we
pick an initial state and we evolve
according to the Schrodinger equation
and it turns out that you can design a
driver Hamiltonian which will always
take an initial state which is a uniform
superposition of all amplitudes and at
the end of time n to the one-half that
state will be 0 0 0 and have a 1 at the
winner spot and be all zeros ok and in
that sense it identifies this spot and
the time there takes n to the 1/2 and
the reason I'm telling you this is
because this is very analogous to what
we just saw in the grove of a problem
there the number of calls was n to the
1/2 here I'm in continuous time and and
the time is n to the 1/2 and so what I'm
trying to argue here is it and a
Hamiltonian Oracle is like the quantum
Oracle and time is like the number of
Oracle pools yes
with the egg inspectors the wrong way of
David lingmerth
which has won one and all the rest are
zeros but isn't the whole point that
this problem is hard because it's hard
to find the one thing that's one well no
but that's what you find after time n to
the one half yes the thing that's oh no
then you can just make a measurement and
you then you then you get this vector
and then you make a measurement and that
and it'll pop out yeah once you have
that vector then you know it's zero zero
zero one zero zero zero you make a
measurement and you know where you walk
yeah I didn't say that you make a
measurement on that factor yes in a way
yeah it does but I'm a it's very
analogous that's right mm-hmm
yes I'm trying yeah I want you to see
the connection good
so I yes oh because the Hamiltonian well
you know I've set H bottle one here and
basically I normalize that Hamiltonian
to have a 1 in it and that sets the unit
of time because time is mentioned in in
inverse energy in the units that I use
so I have I have fixed something I fixed
HW to have a 1 in it and that sets my
units a 1 in other words if if I made
this if I multiplied everything in this
Hamiltonian by a constant factor I would
decrease the time evolution by that
factor because if you go back to the
Schrodinger equation you see that if you
multiply the Hamiltonian by 7 you evolve
in time 1/7 so that's not fair to do so
I have to so this one means it's in some
units I have normalized things
and no it's just yeah I don't know I
don't know the biggest eigenvalue
anything you want any any norm you want
the biggest eigenvalue or anything it
would be fine I normalize it so that's
that's what I mean so I've set the units
here ideal hidden milk because of my
choice of H bar equals one because that
you know and when you have h bar equals
one you know the uncertainty principle
says del t delta T is H bar so if H bar
is one then time and energy are in
heaven verse unit okay so now I need to
introduce one more concept which is
called quantum walk in continuous time
and what does the quantum walk I want
you to imagine we have a graph a graph
is a bunch of nodes connected by edges
so I I want you to think this is an
abstract thing I have a graph it's a
bunch of nodes connected I assume people
here know what graph saw probably Google
Network is a graph of something I don't
know so so you have a bunch of nodes
connected by edges and I'm now going to
define a Hilbert space whose dimension
is the number of vertices in the graph
and I'm also going to define a basis
where each corresponding to every node
is a basis element so I have a basis for
this Hilbert space and now I'm going to
define a Hamiltonian and I'm gonna tell
you the AP matrix element to this
Hamiltonian is minus one if there is an
edge between a and B a single edge and
otherwise it's zero so what that means
is that the Hamiltonian is called the
adjacency matrix of the graph the
adjacency matrix of a graph is a matrix
when you look in the a be spot if you
see a nonzero entry there's an edge
between a and B if you see a zero there
isn't and what I mean then by quantum
walk is I'm just going to evolve with
this Hamiltonian Oh see if you solve the
Schrodinger equation I guess I didn't do
that if your Hamiltonian is time
independent then this is the solution to
the Schrodinger equation just
exponentiate you exponentiate the matrix
so Phi of T is just e to the minus IHT
Tsai of zero and and we call this
quantum walk because if you put all your
am
to adhere in the beginning what happens
is in a short amount of time you go to
the connected nodes and then you start
to spread out through the graph there's
nothing random about it though because
deterministic evolution so I don't call
it random what quantum walk and this
isn't away an analogue to what's called
classical walk classical random walk
okay
so so so so I've been so now given a
graph there is a Hamiltonian but given
by my rule to help you look at the graph
you build a hilbert spaces dimension is
equal to the number of vertices and that
rule tells you the Hamiltonian and
there's the time evolution now I'm going
to show you the algorithm for the
Hamiltonian and tree I call it the
Hamiltonian and because we were evolving
in the Hamiltonian model yeah I can
general question yes what does it tell
you in general I don't know just the an
understanding that allow you to
understand this slide nothing else okay
I lead you along you know in fact I was
criticized by my students last term
because they said I used the surprise
method of teaching which means that I
don't tell them in advance where we're
going and then I I lead them along and
then I say this is where we got and and
I was told that that was not a good
thing to do but I actually think it is a
good thing to do because you have to
trust the guy in the front to lead you
to something interesting instead of
telling you in advance what's happening
so there's no outline we just proceed
okay so here we go so here's the
Hamiltonian entry algorithm first of all
there's a graph so that means I have a
Hamiltonian what does this graph
consists of well first of all it has a
perfectly bifurcating part which is this
this is this is not this it looks like
the knee entry from before but this is a
graph each node is a node in a graph and
there's a Hamiltonian which is connects
nodes in a Hilbert space there's a
helper space wherever with it which it
was a basis that corresponds to each of
these little dots there are two there
are three parts to this there's this
piece which is perfectly bifurcating
there's an infinite line of nodes at the
bottom which it really is an infinite
just very long which I've connected and
at the top for every node on the top
there's an another node on the top a
parallel set of nodes and some of them
are connected and if there's a
connection I want you to think that
there's a one incoming into a NAND tree
and if there is no connection it's a
zero so if I had a man tree I would put
a connection if there's a one and no
connection if there isn't and I want to
know what that NAND tree evaluation is
is it is it one or zero at the bottom
and this is the algorithm I'm going to
build a packet which means I'm going to
build an initial state which is a
superposition of amplitude over here
that's I'm going to tell you what that
is on the next slide with that initial
status I am then going to let it go
meanings I'm going to evolve according
to the Schrodinger equation
oh yeah first of all the size of it the
packet on the left is going to have a
length gamma n to the one half with
gammas and independent constant which
we'll talk about later but think of
gamblers a thousand so there's some
number I put here a thousand n to the
one half then I build this packet and I
let it go and I evolved the time gamma n
to the one half and then I make a
measurement here and when I make a
measurement here I either find amplitude
here or I do not it's a yes/no
measurement
I either find that I ask I make a
measurement on all
nodes and I say it's my quantum system
there and the answer is yes or no and it
turns out that if the answer is yes the
end of the tree is 1 and if the answer
is no demand of the tree is 0 so this
whole thing fits in the context of the
of my general setup for a Hamiltonian
algorithm I have an initial state which
I'll specify I have a measurement after
a certain amount of time and it tells me
the answer to the problem now I don't
expect you to understand this I'm going
to try to explain that as we go I guess
I do have one question which is what is
my real cutoff time what is my actual
cutoff time I mean what time do they you
know shoot me at 12 o'clock hmm squared
of n yes at 12 o'clock pretty actually
really shoot 10 to 12 the video
conferencing my ok a little bit longer
okay just want to know ok so so let me
just say a few more things the
Hamiltonian has really two parts to it
is the oracular part which comes at the
top which depends on the instance and
then it has a driver pod which is
independent to the instance and again
this is not to be viewed as physically
laid out in space and the reason is is
because if you have s sites you encode
that in log base 2 of s cubed so qubits
is a spin 1/2 particle and a spin 1/2
particle has dimension 2 to spin 1/2
particles dimension 4 3 dimension 8 4
dimensions 16 so if you use spin 1/2
particles to build your quantum computer
you only need log s spin 1/2 particles
to encode something like this so the
actual quantum computer is not users
just log base 2 of s of things
well what I'm now going to show you is a
couple of things let me just try to go
really
okay what I'm gonna do is I'm gonna do a
lightening quantum lesson I what I
really wanted to do is prove this to you
but I don't quite have enough time so on
the but I'm gonna shoot through these
slides I don't really expect you to
understand them but if you know a little
bit about quantum mechanics it'll it'll
help I have this infinite line at the
bottom and I want to talk about it for a
minute
I want to look for the eigenstates so
that the energy eigenstates well the
Hamiltonian connects me to nearest
neighbors so H on a is minus a minus 1
minus a plus 1 cuz I'm connected and the
energy eigenstates in the position basis
in other words if I if I have an energy
eigenstate
h-honey is EE then the energy
eigenstates are of the form e to the I
theta a those are plane waves if you've
had a little car of quantum mechanics
these are just plain waves and the
energy is minus 2 cosine theta and I
proved that here in these lines which
I'll skip now for every energy there are
two Thetas that correspond to it one is
positive and one is negative because
cosine theta you know theta is PI over 9
and theta is minus PI over 9 has the
same energy and what these plane waves
correspond to a right mover and a left
mover these are the analogs of e to the
ikx which are right movers and left
movers if you remember a little
continuum quantum mechanics and there's
zero energy the way I've normalized
things corresponds to theta equals PI
over 2 that's the zero energy right
mover and what we're gonna take if I had
an infinite line of nodes with the phase
being e to the I PI over 2a I have a
superposition which went forever with
this property where theta was piled the
two that would be a zero energy state
but I really want to have a finite
system because I don't want to have an
infinite number of nodes I don't want to
have infinite resources so to make a
finite system what I'm gonna do is take
that zero energy state I'm just gonna
chop it but if I chop it so if a is less
than minus L or more than
what - one it's not there if I just chop
it this state is a packet a square
packet which is near very near zero
energy and it's actually right moving
with speed - and I want I could show you
I want to show you a movie of it moving
but I don't know if I'll get there so
what I'm gonna do is I'm just gonna
shoot through my slides what we really
want to do is send in a pack of a state
here which is going to bounce off this
tree and come back and in order to do
that we're gonna do a little quantum
scattering theory where I send in
something with unit flux and it can
reflect and on the other side I can
transmit and when you do this it's a
standard quantum scattering theory and
what it tells you is that if you can
find this thing called T it is the
probability that if you have one unit of
flux coming in you get to the other side
it's called the transmission coefficient
ot is not the probability excuse me t
squared s and this is called the
reflection amplitude it's square is the
probability that you reflect R squared
plus T squared equals 1 because you have
to either reflect or go through and it
turns out that this transmission
coefficient can be related to the ratio
of amplitudes between this node and this
node in the tree again I'm not going to
do this because everything is here if
you follow that so the transmission
coefficient is related to the ratio of
amplitudes between here and here the key
ingredient to the understanding this is
that the ratio of amplitudes in the tree
is determined recursively down the tree
so if I take three nodes and I tell you
the ratio of amplitude here to here four
nodes excuse me is y double Prime the
ratio of amplitudes here to here is y
Prime the ratio of the amplitudes here
is y it turns out that Y has this
recursion relation in other words if I
know the ratio of amplitudes here to
here and here to here I get it below I
show that in more detail in the next
slide which proves this recursion which
I won't do but what it tells you is that
when you if you recurse if you know the
ratio of amplitudes above you you get it
below I'm actually going to be I then do
one other thing I look at I equals zero
because my state is very very close to
equal zero
and what I show is that if you go to the
top of the tray this is just a little
bit of math it's very elementary if I if
I had 15 minutes I could go through it
slowly enough that you would see it but
there's a little bit of elementary math
that shows that at the top of the tray
at zero energy
the ratio of amplitude here to here is
infinite because if this has amplitude a
I have to have zero here so the ratio of
amplitudes is infinite whereas if I have
a thing sticking up and I look at the
ratio of amplitudes here to here it's
zero so at the top of the tree at zero
energy the ratio of amplitudes is either
zero or infinity and if you look at the
top of the tree you either get a zero or
a minus infinity but inside the tree I
had this recursion at equals zero Y is
minus one over Y prime plus y double
Prime and that means that if two
amplitude if two ratios above you are
zero the one below you is minus infinity
if one above you is a zero and the other
is minus infinity to zero and if both
above you are minus infinity you get a
zero below so what that proves actually
is that the amplitudes were cursed down
the tree according to the NAND for
according to the NAND that's what I'm
trying to say so there's a recursion for
the ratio of amplitudes which is the
NAND and then at the bottom what happens
is since everything was determined by
the very last one at the bottom if that
one was zero then their transmission
coefficient was one and if it was
infinite your transmission coefficient
was zero so this action those three
slides actually just proved that the
transmission coefficient at energy 0 is
the NAND so the key to this was seeing
somehow another that the recursion for
the ratio of amplitudes followed the
same logic as Demand and given that we
have an algorithm because it's not
enough though to look just at e equals 0
because equals zero is something
infinitely big so you have to save
yourself over what range in energy is
this relationship essentially true and
it turns out that this relationship that
the T is very near the man's as true as
long as the energy is within a region
about one over N to the one-half it
takes a bit more work to show this
that's the only real work in the paper
beyond what I already showed you is
showing that this is true over a little
range of energy and you can get this
range in energy if I make my packet big
enough and so if L is gamma n to the one
half the packet is narrow enough in
energy and the time of the algorithm
goes L goes like gamma n to the one half
and the failure probability of this
algorithm is out of order 1 over the
square root of gamma independent of n
where gamma is the constant so I know I
did that too fast for anyone to follow
but so what this really tells you is
that you build this packet on the on the
left it's a right mover it hits the tray
and it transmits if the NAND is a 1 and
it doesn't if the nambas is zero I can
show you a computer simulation after if
anyone wants to see that I have a little
MATLAB program that that involves this
so that's that now what's interesting
here is that I showed you this in this
Hamiltonian model but then if you go
back to the conventional Oracle model it
was immediately shown that the discreet
query quantum out for the finance Rees
would also have an N to the 1/2 Roberts
Balak was here at Google now wrote a
paper with child who was my student at
Ben Reinhart saying everyman formula
size n can be evaluated in time order n
to the one-half on a quantum computer
there was a paper by a - showing a
nearly optimal discrete query algorithm
for evaluating and formulas that allowed
for the possibility that the input or
the fan out of the NAND doesn't have to
be - and the tree could be trimmed and
there's been more work on this including
evaluating mid max trees so this
Hamiltonian approach was the first idea
but then it led to a whole series of
papers in the discrete query model which
really showed that a quantum computer
can do something that a classical
computer cannot do
this end to the 1/2 is also best
possible let me try to explain why that
is if well let me try to give you a
little sense of this remember that grow
for problem where we have the function f
of X which is 1 o minus 1 on all these
integers now I want you to imagine now
that I open this function up and I just
let it be 1 o minus 1 ever anywhere it
wants it's just all over the map 1 and
minus 1 let's consider the parity of the
function the parity of the function is
the product over all inputs of f of X
now how many times do you have to call
the function to get the parity
classically we have to call it n times
because if you don't the last call could
change the parity you don't know
anything about the parity of a function
unless you call it on every single input
well it turns out that quantum
mechanically we and others show that
there can be no speed-up for evaluation
of the parity function that this is a
function which is so sensitive that
there is essentially there's a effect of
to speed up but that's not algorithmic
for the evaluation of parity and it
turns out that using that you could show
that if you could evaluate an and tree
faster than n to the 1/2 you could do
parity faster than n which is what's on
this slide so that so that means that
the algorithm we found not only beats
the best classical but it also is best
possible so this was my talk about about
game trees and using ideas from physics
for that afterwards I'll show anyone the
movie of the thing scattering I want to
talk for a few minutes about another
physics based approach to quantum to
quantum computing which is called
quantum computation by adiabatic
evolution this was introduced by me
Geoffrey Goldstone that's the same as
the Goldstone boson guy oh he was my
co-author on the other paper - I
shouldn't told you that sorry and Sam
government who's my friend
and Michael septuagint computer
scientist but anyway this will they're
all my friends but this is quantum
companies metabolic evolution and this
is the general approach to combinatorial
search problems and why are we
interested in this well one reason is
because it is a general approach to
combinatorial search problems and I
think maybe some people Google are going
to might be interested in having a
general approach to combinatorial search
it's also Universal which means that any
ordinary computation could be written as
a adiabatic and it's also possibly a
good design for building a quantum
computer in fact the company d-wave
which claims it's trying to build a
quantum computer it uses the adiabatic
algorithm as it's all for its
architecture so I want to just been a
couple minutes explain what this is I I
want to imagine we have a time-dependent
Hamiltonian H of T and this Hamiltonian
has eigenvalues those are the energies
and they vary in time because the
Hamiltonian changes and one of them here
is the ground state energy which I call
eg of T the grounds eath the G means
ground ground means lowest to quantum
mechanics the ground state energy it
depends on time I made it go from zero
to zero I don't know why now at any
given time there's also a state which is
the instantaneous ground state that is
to say it's the eigenvector of the
Hamiltonian with this eigenvalue which I
write in this formula so EJ of T with
the cat around that is the eigen vector
with this eigen value now I want to
imagine that I have a quantum system and
I start that quantum system at time zero
in the instantaneous ground state of the
Hamiltonian at time zero and then I
evolve with the Schrodinger equation
well the adiabatic theorem says that if
I evolve slowly enough then the actual
states I of T will remain near the
instantaneous ground state and what
slowly enough is actually determined by
well what if you want a little help with
that think of having the time
independent Hamiltonian if I have a time
independent
Tony and I put a quantum system in the
ground state oh the only thing that
happens is the phase changes you stay in
the ground state if the Hamiltonian
changes slowly enough then you slap the
state along which with the Hamiltonian
it's almost like imagine we had a
potential and you put a ball on the
bottom and then you kind of moved it
very very slowly the ball would stay at
the bottom it's that kind of thing so
this is the adiabatic term which I'm not
going to prove both what slowness is
determined by it's actually this spacing
which is the minimum distance between
the first excited state and the ground
state now what we're interested in in
this context is something called
combinatorial search your computer
scientist so I can summarize this is a
second combinatorial search is a problem
you have n bits which can take two to
the N values x1 through xn each X I is 0
1 and we have a system of clauses which
are truth tables acting on subsets of
the bets an example might be a clause
involving bit 799 and 103 and it's true
if and only if X 7 plus X 99 plus X 103
is 1 and the mother of all computational
problems is find the assignment of the
bits that minimizes the number of
violated clauses finding in general if I
give you constraints on bits and I say
find the you know the global the the
actual assignment that violates the
fewest clauses that's np-hard and I hope
I'm not gonna define that but that means
it's really really really hard and
that's why this is the mother of all
computational problems and this is
considered an intractable on a
conventional computer almost all
computer scientists believe that P does
not equal NP which means that's a Mathew
way of saying there is no Popov fast
algorithm for that how could you think
about that thing well imagine you have a
cost function one approach to it would
be to build the cost function you have a
cost function which depends on a bit
string input and the cost function is
simply the number of clauses violated by
the bit string so if you could define a
cost function which is the number of
violated clauses and you minimally
if you found the minimum it would answer
your combinatorial search problem of
what configuration violates the fewest
clauses so clearly cost function
minimization is is equivalent to that
problem and there are no general
algorithms which are guaranteed to find
global minimums of functions sorry so
this is my last slide almost about the
second to last slide so the quantum
approach to this is the following thing
we define a Hamiltonian which in some
basis has the cost function at on the
diagonal we define a Hamiltonian which
in this basis x1 through xn has a cost
function which is equal to that previous
one and our problem now becomes find the
ground state of that problem Hamiltonian
and our approach to that is the
following thing what we're going to do
is construct a Hamiltonian which which
at time 0 is an easy to construct
Hamiltonian whose ground state we know
and we're gonna put the half of the
quantum system in that ground state and
then we're gonna morph this Hamiltonian
into the problem Hamiltonian and by the
adiabatic theorem if we morph it slowly
enough if we started in the ground state
of the Hamlet which we know we're gonna
slap the state along and at the end of
the evolution we're going to be in the
ground state of the Hamiltonian whose
ground state encodes the solution to the
problem we seek and this is called this
is the method of quantum computation by
adiabatic evolution softkey will be near
the ground state of HP if T is big
enough so the computational question
becomes how big does the time have to be
for this to be efficacious how does that
time scale in order to make this an
effective algorithm and the point is
that if this approach works quantum
computers will have power beyond
factoring in game trees and
that would make this a general interest
in all areas of computation and I think
for those of us who are interested in
quantum adiabatic algorithms and maybe
even people at Google I think what we
need to do is study the performance of
the quantum adiabatic algorithm in
specific cases because if we could
identify places where the quantum
adiabatic algorithm could clearly
outperform classical algorithms I think
that would be a huge thing so what I
have shown you I hope is that by doing
the game tree I used one set of ideas
from physics involving scattering theory
here I'm using a different set of ideas
for physics involving adiabatic I didn't
really expect you to follow that I just
wanted you to see it because I think
it's of general interest and I think
quantum computation benefits from
physics because there are ideas that the
physicists have which are sometimes a
value and that's basically what I want
to say thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>