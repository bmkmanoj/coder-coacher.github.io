<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Introduction to Kotlin: Making the Java Platform a Better Place | Coder Coacher - Coaching Coders</title><meta content="Introduction to Kotlin: Making the Java Platform a Better Place - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Introduction to Kotlin: Making the Java Platform a Better Place</b></h2><h5 class="post__date">2012-07-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/sP9R9Nc3sRA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is andre is working at JetBrains
and you might know father product
they've developed cult IntelliJ IDEA and
he's here to talk about the new JVM
based language that he's been he's
developing right now thank you very much
thanks everyone for coming and thanks
again for organizing this it's my great
pleasure to talk here so on today I'm
telling you about project Coughlin this
is a set already a new motor statically
typed object-oriented language primarily
for JVM but currently Jaden is not the
only flapper we work on and I'll give
something like an introductory talk here
but I would really like to make this
session as interactive as possible so
please go ahead and ask questions as
soon as you have them and so if we get
up my product it's ok just forgive me
for not having slides for those things
and we'll discuss what you like so the
biggest thing about sorry any
interesting front project is why you
want to start it right and so by
language here is maybe very much like
any other project project that may be
very different from any other project
because the language it's very low on
the tool stack which a programmer uses
so of course that did there was a
motivation I can tell you about but
actually there is an interesting
observation that makes whatever I say
about my motivation not very relevant
the observation is that there are many
people create languages all the time but
recently this this tendency changed a
lot so if maybe 15 years ago and most
new languages were by enthusiasts or
researchers today very many new
languages come from industry there are
big vendors behind many new language
initiatives in the last 25 years and in
Google being one of the right
representatives so when we started
thinking about comment was two years ago
we primarily targeted JVM and JVM there
were two alternatives then it was well
to five alternatives where groove dance
Cala
and basically it about the landscape we
adjusted to adjusted against but in a
year from then when we announced the
project we were not alone so the scene
here in four months actually there were
four projects by different companies
announced in 1204 of the GBM and the
interesting thing is that the
motivational part of all the projects
was almost to say we want a better
language on our awesome platform so and
these are by real industrial vendors
like our biggest competitor now is Red
Hat which is you know a giant
so why people want a new language on the
JVM the the answer is actually quite
funny is because the Java is a great
platform people even write those books
now let's say say John Woo and the cover
and Java does rule as a platform since
1995 it was steadily developing and
every year bringing who wearing more
interesting things new libraries new
frameworks improvements to the virtual
machine so today I have a really good
platform that serves their many purposes
very well so it runs on servers trance
on some desktops across mobile of with
the Android so and so forth so it serves
very many people but the thing is that
all that is about the platform and the
language is a different story here
because designing 1995 it today maybe it
is not 1995 design yet but it's 1990
design probably and we are in 2010's
already right so the state of the art in
the understanding what a programming
language can do for you is far ahead
what we have in amazing languages and
it's on John by the way but Java is a
very very good example here so the urge
to fix that is there natural and people
are trying to fix Java and I'm myself
volunteering on this for group for
project lambda where we try to squeeze
this very very media thing in Majella
but it's been six years and it's not
here yet it's not because we are too
lazy I mean I'm lazy definitely but
people at Oracle are not and they're
really working hard in that it's not
there because it's a very hard problem
to squeeze something really different
into this design because the design just
doesn't like it it your checks didn't
you think so this is why yeah G okay a
new language is a pretty illegitimate
one actually so what kind of man would
you want it's serious simple go on and
water language for industry so basically
we want recyclers and what mortar stands
for is basically the modern
understanding of experts emiti so you
want your your code to be a kind of
corresponding to what you think it
should be and the biggest biggest
problem there is that you don't want to
say more than you actually need to
communicate to another person really the
program and a person is a very important
thing here so if you take Java or C++ or
many other mainstream languages you have
to tell the compiler so much that people
reading that don't need that much
information you definitely do not want
to strip everything away but there are
many things do not be generally to be
told to people but have to be told to
the compiler so one source of your
verbosity in the code is that your
compiler is stupid and that is a
technical problem you can fix it
actually there are many to make the
earth aquifer and stuff like that and so
this is one source which is really an
engineering problem you can fix right
away and another problem is more
fundamental it's you're repeating
yourself over and over again because
your language does not allow you to
abstract this idea over and put it into
the library so this is about having the
right abstractions of the right means of
abstraction in the language that make it
possible to abstract over some complex
pattern or something and use it as a
library call so these are two things we
want right abstractions and smart
compiler
and the industrial industrial setting
actually makes it interesting do because
you know you can think about their many
interesting languages they're not
applicable industry at all just because
of the specific setting we have so
here's Joe he's not a good work is
working in hard core core industry you
know no fun at all it's just hard work
so Joe environment is that he has they
do something mooing lines of code
project which is ten years old
and maintained by 30 people and none of
them love their job but this is not the
point the point is that it's a huge
thing and you have to have a base for
maintain it more than you actually write
new things do you read more code than
you right and probably this even holds
in Google and everywhere all right so
the point is that it is much more
important to make your language readable
than to make it easy to express sense it
should be easy to communicate how to
express actually and this is a
constraint because you think about very
powerful techniques like meta
programming for example this takes so
much away from from the readers eyes you
cannot afford that for example our
biggest problem problem with Scala when
we fry it to gala and JJ brain what that
is cally relies so much on the concept
of implicit where you have a bunch of
code and it works you don't know why
because it's so much going on behind the
scenes and it's not in the text of the
program you don't even know where are
the points where the employees are
called you have no means to suspect
which particular poll to inspect and all
you actually are left with is take a
debugger and just step through all that
and figure out what what's coming in
from where so you can't supply a
boilerplate you can't afford just
removing all the detail from the program
you have to to find some middle ground
there
or pretty much relevant I'm telling you
that while Jed rains has enough
expertise for programming languages and
we did try different type of languages
but they didn't work for us
feel free to ask questions about that
and any other questions on motivation
you would like to ask yeah sorry about
that okay so uh yeah that was a pity
hello there and it's a talking Colin by
me thank you very much for your
attention so I've done my motivation and
the question I get after that is what is
this third third language here that we
tried it did work for us we actually
didn't try it it's a new language it's
our biggest competitor after Scala today
it's like language by Red Hat which is
also statically typed in object-oriented
and try to tries to fix Java in a way I
think the biggest difference between
carbon and sullen is that someone's
approach is ok we have a language and we
want to redo all the platform like no
JDK you just take our own classes our
own class loading strategies our own
execution environment over JVM and you
work there so it's basically making it
pretty hard to interrupt with the
existing code base and my setting say
JetBrains and I think many people
setting would be you want a language
that lets you take your huge Java code
base that you already have and put new
things in the new language keeping the
old things in Java without having to do
anything other than setting up the build
basically so this is the the huge
difference between the karma caught my
attitude and say selling a teacher than
many other competitor projects okay so
to summarize the design goes behind
Coughlin are the environment friendly
where environment is whatever platform
you ran on so we started with JVM but we
actually now compile the JavaScript and
plan to compiled to native platform so
whatever platform you're on it you want
to be environment friendly in the sense
that you're compatible with everything
available on the platform already and
you want to be productive with that
which this means you want to be
expressive but type safe concise but
fast and just look at this and figure
why many languages don't fit because
some some of these are missing from very
many settings you wanted to learn of
course
so our own outlook is that you need
tools so how many how many people are
using them daily here
Emacs okay actually I thought it would
be more like them against Emacs in here
but it actually looks like it's a team
against a more like modern IDs Bemis
they're very more so the thing is that
so we are an IT company so everyone uses
a powerful idea brains and we know that
many other people like therefore I IDs
and I personally admire people who use
text editors for for doing code because
if you use them for a large-scale coding
this means your Jedi and and this is
cool
but the problem is that if I'm running
my whatever software shop somewhere not
here it would be quite expensive for me
to hire you
for example just cost too much money
it's of course you do not charge for
using them the charge for what enables
you to use them and this is why we
believe that people in general need
tools need their smart IDs and stuff
like that so our third requirement of
language is a tool support so before I
get to the examples here's my timeline
we started two years ago and now we're
at this m2 stage here after a couple of
milestones we'll be in beta which will
mean that compiler does not crash too
often and at this point we're starting
to use the language JetBrains
extensively currently it's used in
production a little bit and we'll
proceed to to massive use and after we
validated this why we specify and
release the
first version and since February it's
open source so if you're interested in
anything about it just check out the go
fix the bug if you like submit a support
request and join the joint icing and
making the future better all right any
questions here then the boring part is
over yeah sure
okay the question is what are you going
to do with those problems in these java
libraries of is out there will it fix it
in your standard library so the thing is
will do as much as we can without
breaking compatibility so if we don't do
not need to disable your your ways of
communicating with the old code we'll
try to fix that and actually there are
there interesting challenges there
because for example if you want to use
Javas collections you want to to make it
better than Java because javis
collections are invariant classes you
cannot whatever your list of objects is
not it's not compatible with a list of
strings you cannot assign a list of
strings to a list of objects and this is
legitimate because you could break it
otherwise but if you could have a
redundant list that would work but Java
doesn't have the notion that enables you
to do that and we want to introduce that
notion without actually going away from
javis collections this is one thing we
are going to do and but this is a
particular solution for collections as
such so this does not scale on the whole
library so it will be point by point
personal decisions on every question
there okay
should I proceed to the examples all
right so I'll try to go as quick as
possible not to were you with the
uninteresting snap so here is hello
world which is probably obvious so pre
please know two things one thing is that
code is organized into packages and a
function can sit under a package so if
the Java world you cannot have a
function outside a class and here we get
it back to say simplest class all times
or whatever good times where a function
can actually sit under a package and the
rest is pretty obvious so this is a type
a generic type yeah and you should have
fun of course
any questions here red line is a
standard function so there are
implicitly imported stand
things and this one is defined in the
carbon IL package so you can actually
navigate to the source and it internally
it uses the Java system class we'll get
back to the question mark a little later
more questions array is invariant
because it is correct oh that wouldn't
be too much of Java incompatibility
because so you cannot you cannot pass if
you have an array of objects as a
parameter
somewhere in Kotlin it cannot pass an
array of strings there but this is not a
jobbing compatibility because if you
have a java method that takes an array
of objects we actually load it into
cotton in such a way that this parameter
is covalently projected so that it
actually looks like it is an array of
what remark extend string in Java terms
it's a little different in common so it
is not an incompatibility it's a mild
fix that compensates for a problem we
have in Java
more questions okay so yeah one thing
just to illustrate what we are finding
so here is a bunch of Java code the
question is what it does what does it do
sorry there is yeah nothing thank you
very much this code does nothing and
does not fit on the screen so this is
the problem we're trying to solve here
so yeah so here is the conference
version of that this is not perfect
coughlin I will fix it a little bit
later so here's a class with the three
constructor parameters so you define
your constructor writing the class here
here and these Val's are read-only
properties so these are just filled with
gatherers right away and we just assign
the constructor parameters to these
getters and this makes a little more
sense than Java but still it's not
perfect because you have to
pick yourself with those types here and
with these names mentioned three times
each right so I can fix that by doing
this I just call them old valves right
in the constructor from your list
this is what's called a constructor
parameters as properties so basically
you want to say I have a bunch of data
here this is what you do say my
constructor parameter is a property
right away and this one as well and this
one as well and this basically generates
that Java class we had before so all the
gathers are there the constructor bodies
there the fields are they are behind the
scenes and the to string is this concise
so you can use what what we called
string interpolation inside the string
literal you can mention your variables
just to be put in there very useful for
debugging and not yet yeah so the story
about immutable objects is a little more
complicated so we could actually figure
that as these classes are immutable and
these fields of these properties are
immutable we could figure that the whole
class is immutable but that will require
a lot of annotation because of all these
classes are standard we could be
annotated out-of-the-box but if
something else is not standard you'd
have to somehow denote the immutability
otherwise the compiler wouldn't be able
to check that modularly so I think what
we demand the mutability we need to put
an annotation on the class and it's
actually a very interesting story about
so people keep asking me if our our
language sports multi-threading in any
way so the only way we are going to
support multi-threading in is providing
immutable data because otherwise I don't
know how to do that I can support one
model of multi-threading like actors or
software transactional memory or Java
Java style looking or maybe something
else but there will be only one model
which is anyway not the best one because
the best one is to fix our hard
are actually not to provide any means on
software level so we do not war any
model of multi-threading into the
language we provide libraries for that
and from the language perspective we
provide only immutable data that Silla
dates a nice communication between
between your threads any questions here
yes yes so a property as well as a
function can be overridden by another
property and of course you can customize
your accessors here so not in the
constructor of course but when you
define it properly you can provide a
custom getter or a got some setter
now this is a nice question and the
answer is no you cannot have multiple
constructors but why are you asking why
do I need the second constructor right
so the maybe 90% of the focus of
overloaded constructors in Java for
example or maybe in other languages too
is for providing default values for
constructor arguments and this is what
you can do here probably zero is not too
good Det so if I want this property this
constructor parameter to be a by default
have some value and we not fast on the
call side if I want to omit this 18 here
I can just mention it here and it will
be pass automatically my constructor
bold so this eliminates maybe 80 to 90%
of the need for a multiple constructors
and the rest of that need is evil anyway
because of you if you have differently
significantly differently structured
initialization logic it means that you
have many classes not one what yes and
actually one out of the fraction is is
covered by factory methods yeah
yeah sure
you just put anonymous anonymous
initializer so whatever you you probably
don't do much with this class because
it's just a poor joke but if you want
some code here you can just put it
inside the glass body so basically the
glass body is the body of the a primary
constructor over here more questions how
can you have named arguments so you can
do it this why here I have first name
equals John last name equals DOE and the
age is not there so on the call site you
can specify only those arguments you'll
like using names and you of course you
can reorder the names and specify only
those you need my questions I think this
is the closest you can get to keyword
arguments because it's a static language
so you cannot do like map right because
this has to be statically checked
somehow no no defaults whatsoever so
this is this is a kind of implicitness
we're trying to fight actually and I'll
get to null to live later that's an
interesting point okay
yes we do and here yeah so here is this
is an unfixed issue in cotton we'll fix
it definitely so it will actually say
public override function but currently
for just string individually it is so
because the string is not available on
the so it's not a member of the root
class so the root class currently is
empty there is nothing there and two
string is something coming from the
outside by convention and this is wrong
and we'll fix it okay let me get to some
more interesting things and here is my
string iterator example so this is a for
loop in Gatlin we don't call it enhanced
for loop because it doesn't make any
sense to have an unenhanced for loop so
this is not possible in Java because
Java string is not an iterable and
Java's for only accepts iterables in
this position it rubles or arrays but in
company it is possible and not because
strings are in trouble and coddle
actually strings are just Java strings
in Catalan but this is because the
string has this iterator method in
Catalan and four can iterate over
anything that has the iterator method by
convention now the question is okay you
use Java strings but Java strings don't
have the iterator method how does get
there the answer is this is something
called an extension extension function
so if I navigate to the source here it
is the declaration this function says
there is a function for the receiver of
type string called iterator and
returning some obvious implementation of
the dream so actually in the bytecode
this is a static method in a utility
class basically which takes one argument
of type string so it's all statically
dispatched we didn't touch the actual
string class but from the syntactical
point of view and from the conventions
point of view you have a new method on
the string class and you can call it in
any context it is demanded for example
in the for loop
any questions on this okay so the
question is what happens so where where
do do you see those extensions and what
happens if there are conflicts so this
extension here in my example is just
defined in the same file and the
relevant part is that it's in the same
package so by default your extension is
visible in the same package you are in
otherwise you have to employ it
explicitly so you say import and the
name of the extension if you import two
extensions that are conflicting you get
an error on the call side so when you
try to all iterator and there are two
iterator is applicable at this point you
just have an overload resolution of
acuity and you for example can rename
one of them on the import to disappear
yeah so and these are purely static so
you don't have any problems like you're
like somebody coming in at runtime and
adding a new extension it just does not
happen more questions you can use
extensions to get properties as well so
there are extension functions and
extension properties I'll show one
little later
now by the way I can and no because
extensions are defined statically the
the notion of overriding doesn't hold
the earth it's something you can
overload them because this is a static
mechanism and answering your question
about yeah about extension properties so
here is an example of how you use
extensions to accommodate big decimals
in the language so you know that java
puzzler or whatever puzzler
that's tracked 11.1 from to and gets not
0.9 but 0.8 and many nines so this has
worked around by using a class called
big decimal in java and here is a cotton
dsl for big decimal that enables
creation from string literals with this
BD extension property and then enables -
unpick decimal with an extension
function
so here is my BD property it is just FL
with this three receiver that returns
big decimal and here is the custom
getter that just creates a new instance
of big decimal we don't use the new
keyword cough on this here a reverse of
course to the string that was passed and
as the argument what's just here ah yeah
so the question is there is an opinion
that extension extensions make your code
less writable because because you're not
familiar with extensions provided by
somebody else so this may be a fair
point although I think that when we have
to compare two things being able to make
existing classes nicer in this way in a
static way and this problem of maybe not
knowing what the extension name means I
think I choose extensions because it's
your code you can actually see the Ducks
for where the extension function and
actually if you think about it in a
broader setting well somebody could add
a method to to a class you're using well
maybe not to a library class but still
you're using a lot of classes that are
maintained by your teammates and while
somebody could add a method and then you
just go there and read the code or read
the comments and this is what happens to
the extensions I think yeah so I do not
think that it this is so much of a
problem but yeah if you have arguments
please communicate them after the talk
it's very interesting thank you very
much
the second thing here is this minus
operator which is of course not
available for as a built-in flan thing
it's actually available by convention so
when you say a minus B this actually
means called a minus function that is
called on the left and takes the right
as an argument so if you if I navigate
to the source of this
here this is what I have is my extension
function called - yet by convention it
should be this name - it takes another
big decimal and actually just redirects
to the building method to the to the
method of big decimal class so this is
how you make you make existing libraries
play nice even if the initial library
design was not did not fit well with
what you need from from the library
especially for really old classes this
may make a lot of sense yeah so
basically when you when you resolve the
call of the extension you take the
receiver argument as one of the broad
there's a value of 1 to 1 of the
parameters function so it's normal
overload resolution there and if
something was defined for the superclass
it's available on the South Plaza thank
you so the question is why don't we have
the notion of operator instead of having
named functions so this is actually a
matter of taste depends on what you want
to want what you want to reuse so the
initial point for doing this is that
many existing classes Java classes
already have some some functions with
write names and write positions and we
could reuse that but it's it may be a
weak argument so what we actually want
to do now is to demand a special
annotation of this function that says
operator phone and then there is just
not to alter the linguistics too much
because you know the question if if that
deserves a separate syntax construct is
a very big question I wouldn't like to
new things but to restrict the usage of
only intended functions it's actually
good idea more questions ok
why do I important it ray list this is a
ArrayList good question every list by
mistake I think I don't think it is
needed here will be a warning not an
error yeah and the warning is out there
yet but it will be my questions ok very
good
the question is if I can control the
precedence of my operators the answer is
no the table of elba your presidency is
wired into the parser which makes your
strings of characters possible by Kaplan
which is good the question is if the
extension can be seen by normal Java
code yes it can but Alison if not as an
extension function it will be seen as a
static function as a utility function
like watch what you put in your string
GGO class or whatever by default you
will see that as just as a top-level
function in Garland so you will be able
to call it like - of a comma B and since
we we provide some means of annotating
Java code to be nicer to rattlin you
will be able to annotate that to be an
extension function in Java or you could
write your wrapper function in carbon
code but that would be some overhead
aborting ok let me show some other nice
DSL so as we are talking about oh no
this is too early for DSL sorry I'll
show you this first so here is an
example about collections people ask if
we have literals for lists and maps and
the answer is no because functions are
good enough so here is a piece of code
that creates a list of users
with two elements actually this returns
an array list but later on we'll be
returning and immutable list now I want
to filter this list only take those
users who are older than three and this
is that an obvious way so I think in
this audience I don't need to introduce
function literals or anonymous functions
or lambda expressions so this function
called filter takes this lambda
expression as a predicate for filtering
any questions here excuse me it was too
many I recognize this expression from
here can I throw away those curly braces
answer is no but it can throw away the
as the round break braces so you can do
this and the rule is if you have your
lambda expression the last on your
argument list you can actually pass it
outside the the brackets this can be
very useful I will show you some
examples later more questions go ahead
you don't have to specify the type for
this parameter here because it can be
inferred from the context so here we
have quite a bunch of type inference
going on so first of all you don't
specify the type of this variable
although it's there actually inferred
from from the right hand side and here
you can the compiler infers the type of
the you from the definition of this
filter you cannot take this anonymous
block as as it is in and assign it to a
variable without providing any types you
have to put types there ah sorry no so
actually this question generalizes as do
you have any kind of global type
inference in your project in your
language the answer is no because I used
to read quite a bit of Haskell and the
thing is that okay
Haskell is this powerful global type
inference but reasonable people never
use it because if you don't put types in
a Haskell program you can't read it so
the point is why bother doing that
complex thing
your language if it's not usable anyway
although I like the algorithm more
questions please that okay okay so now
we have so of course this this is a
normal ArrayList and this is an
extension function and I'll show you the
definition it is pretty straightforward
actually so we have a generic function
on collection of T's taking a predicate
over T let me scroll ah collection it
could be eatable actually yeah so in
this example it's collection just
because I made it up so this is not a
library function it's just my example
here so the predicate is a function from
T to boolean and we return a list of T's
so we have built-in function types in
the language which which is a huge
difference from what we're doing for
Java now without introducing new kind of
types to the language we're putting just
lambda expressions which is an
interesting solution theory Java style
questions here and not yet so the
question is if we have list
comprehensions or collection
comprehensions like in Scala currently
we do not have that but we are aiming at
having something like that so it
basically amounts to if we are going to
have something like a yield operator in
from Python or from c-sharp or from
Scala probably yes the question is how
you make it better because the Scala's
way is very slow so we want something
something more performant and as
flexible as possible all right now let's
do something let's push this idea of
hierarchal as extension functions to a
little bit of an extreme and get
something funny out of it so here is I
don't know how many people here with any
swing in their lives I hope you didn't
suffer from that too much but this is
swing wrapped into a little bit of
Kotlin so what this actually does I'll
just try it
so it breeds a window with the textarea
in two buttons and the interesting
property of that program is that if my
resolution wasn't so low it would
actually fit on the screen so it's just
two more lines there the thing is that
we have something very much like a
declarative program here that defines
the structure of a window and this is
using pure swing plus a bunch of
extension functions so I'm creating a J
frame this is basically effect your
method I wrote myself J frame with this
title and this says so what are these
curly braces here actually the closing
one is down there so what is this well
actually it's of course it's lambda
expression yeah so it's a lambda
expression actually passed outside the
parameter list as I showed you before so
basically I instead of doing this I
could say demo comma lambda expression
and then close this later on but I can
afford using it this way so this is a
lambda expression passed to this
function and if we look at the
definition of this function it will be
interesting because it takes everything
together having I'm just great line here
so here's my jframe function the first
argument is easy it's a string and the
second one is interesting so have a look
at this function type here what is it
well unit is void of course but what is
the function type so what kind of
function do we have here right so this
is an extension function - J praying
being passed as the first class value
and inside here it's absolutely nothing
interesting because here we have the G
frame we call this extension function in
this syntax nobody cares actually and we
return the frame but if we returned back
to the calling site here is my extension
function right and what being an
extension means here
means that there is it this inside here
so my goals here are actually this dot
hiding these dot width which means that
the compiler is basically tracking the
context for me
so these height width and center and
South are for Jeffrey but this West is
already for J panel because it sits
inside another extension function and
this actually enables me to create this
idea of declarative DSL with tracking
context without any special language
constructs it's only extensions plus
function literals and function types
that's it
nothing nothing special no object
initializers no special syntax for
assigning robberies no nothing it's just
code inside function literal questions
here it should not be all obvious yes so
if you if you say something that is not
available for J panel but is available
for Jeff jframe unfortunately you get
access to that so for example a height
is available on J panel as well so you
will if you say height here it will be
height of the J panel but if you think
about something that is not available in
J Bell and remember what it is default
close operation yeah default post
operation will be from g3 just because
the result or resolution works so that
if on in this object it's not available
you go all the time because it's a
closure you're taking oh it was
available from the outside actually
we're thinking about some ways of
blocking this scope from taking from
getting into this but the question is
how how you make it not too ugly because
you know it's this is already something
you want to hack to tweak your DSL and
that there it's questionable whether you
want it actually but we're thinking
about it the interesting thing about
this feature
is that dynamic languages are very proud
of having something like this like in
groovy this idea of builders is very big
and it's purely a dynamic concept there
because the context is being direct
dynamically and what we have here with
combining very simple features actually
is purely static that's safe and
performant implementation of what before
that could be only done dynamically well
and I say anyway another example of the
same technique which is actually more
relevant than building swing windows is
doing HTML or whatever XML so here I
define a bunch of functions that
correspond to HTML tags and here's my
HTML with the table inside and rows and
columns inside the table and I can even
generate many roads for the table with a
normal for loop because this all is code
so I can do something like I'll like i
doing say JSP or some some nicer
generation frameworks in pure Kotlin I
can't crease my font size sorry about
that
nevermind so the structure of these
functions is all the same as it was
before right so this is taking an
extension function to the HTML class and
this for table so and so forth and every
time you call a TR it actually adds a
new row to the table which is outside
here because TR is defined here like
this so TR is an extension function on
table so as a receiver it will actually
take a table that was somewhere outside
this is probably the the only presence
of an implicit concept and kapha has the
most complicated being a governs which
we do not get rid of because it's giving
us a lot of power questions here
Oh double exclamation mark I'll get to
it in a second and I'm okay so now let's
forget about those interesting things
and get down to hardcore work
hardcore my hardcore work is something
like this I'm creating a final object
call a list files and take its length
here and then I just want to print it
this is very bad program and people who
are not doing job all the time may not
remember this but the thing is that this
list files tends to return you null all
over the place because if this test is
not it's not a file does not exist it
will be null if test is not a directory
list files which is supposed to give you
all the children will be no it's not an
absolute it's no so when I say list
files of length I just get a null
pointer exception and there are of
course there are many things like that
all over the place and this makes people
in Harper industry with a instead of
having fun write those null checks
everywhere because they don't know we're
cutting out smells come from and we
aimed at fixing that problem a little
bit by introducing the idea of nullable
types in the language so our our type
system actually has the notion of of a
nullable type so if you have this file
that lists files in cotton it actually
has a funny type with the bunch of
question marks here is the type it's
actually a nullable array of nullify 'ls
so the question mark after you type
means that this type can hold now
otherwise if there is no question mark
it means that there may not be any nodes
as value so this array the ARBs array is
not null itself and holds no null inside
and this array may be no itself and may
hold nodes as memory now so what does
this mean means that if I want to call
files dot size here my file size does
not compile because the compiler
complains about dereferencing and
potential a null pointer and this is
just not allowed what you're supposed to
do there are many ways to work around it
and one of them being double exclamation
mark which is an intended ly ugly way to
say okay forget that I know it won't be
now just get away and it will throw a
null pointer exception if files is no
but this is not a good way and the
intended good way is to say if files is
not null just access the remember and
that's it
the compiler Cal can learn from from
your checks that your variable cannot be
now because you just checked for that
and under this check it's legitimate to
to make it reference outside this if it
won't be so the thing is that this is
what we call flow based typing so will
the compiler learns from from what you
wrote and basically just lets do
whatever you like if it's safe questions
here right initialization for nullable
types is okay can you clarify the
question great question so the question
is what do i do if i have a non null
field in a class and the the field is
not yet initialized the thing is that
this is a problem very hard to solve and
we do not do anything about it yet there
is a there were little hope that we can
fix it somehow but most likely it will
be just a hole in the types because it's
very hard to track initialization logic
in general because you can call methods
and just stuff like that that compiler
cannot get keep track up but there is a
little hope that we will do something
about it thank you for the question
okay the question is can you create a
method like assert not null actually
this is a surgeon now basically okay
yeah so the answer is you of course you
can but the question is will the
compiler actually learn that the files
variable is not now after that so this
is something not implemented yet but
we're going to do that we'll have
something called inline functions and
inline function is not a function
normally it's inlined on the call side
otherwise it's type checked as a
function so it's not a macro in C++ it
was plus way but as it is in lined the
type checker will know about everything
going on in there and you will do it
that way yes I can say fun T which is
any is the top type teehee question mark
to do whatever so this means that if I
have any non na level type T I can
extend t question mark which is
guaranteed to be knowable and extended
this one
the restriction is that we do or
whatever you can do without looping over
a program so we do not do any abstract
interpretation as such because it's it's
not deterministic at a time so what we
do we just keep track of all the
variables while traversing the tree so
we're not doing any fixed point there
it's just one iteration over anything
and its type safe in the sense that if
we did not learn anything we we say it's
knowable yeah so this is what I told you
about the extension of the the inline
function so if that is an inline
function so not a function actually you
will you will have been else's otherwise
you've all that and so this is the
concept of nullable types basically and
this flow-based typing I think I have
one more ah inaudible type is a super
type of non-local you can assign one way
I think I have time for one more example
and it will be an evaluation of a of an
arithmetic expression the trade is kind
of an interface and here is a constant
and sum of two expressions so I have a
tree of objects like that
now what evaluate it to an end just
normal school example so this is how I
do it in pork cutlet I have an
expression I want an end I check if
expression is numb I invent a new
variable name I cast and then I access
the value here this is something I had
to do in Java and in many other
languages because this variable is
completely useless of course I could
inline the cast but it wouldn't make it
much more readable this is why I got on
with the same concept as we had for
knows we allow you to do this if it's
already known use it as a numb you know
that so it's about making the compiler
smart
I told you it's Nam already go ahead
technically it's actually inserting cats
here so a green variable means that it's
automatically cast or something and of
course you can do the same with with
someone with any other class so this is
how the this code looks for very simple
evaluator and we reuse this idea in the
our extended version of switch operator
which we call Rin and here is what it
looks like so you can say you can say
when e is numb use it as a numb when it
is the some use it as a sum otherwise
grow something so this saves you a
little bit of if else--if else--if
else--if and makes it a little more
clear otherwise that's a normal I would
say pattern matching operator may be
poor man's but a pattern matching
operator so if one of the alternatives
matches you get the right hand side and
no matches further and of course the es
Jack is not the only thing you can do
here you can match to an expression
which doesn't have to be a constant so
you can have let me give you some some
example here just not too well X is 1
Val X is 1 and when X you can say 15 and
do something you can say X plus 1 it
won't probably match but you can still
do that you can say even some use some
range checks and stuff like that or
negative range checks so you're you have
some reasonable power inside this which
is which covers most of the use cases
plus you can do is checks and have your
flow based typing this is my last
example any questions
about examples the question is can I
have a switch that actually makes sure
that all the space of the values of X is
covered well yes
first of all if you command out this
else here you get an error but this is a
silly thing so for for enumerated types
we have this concept of in classes where
the space of values of that class is
known we check that you you actually
covered everything for numbers it's how
about stamp problem is undecidable worry
about that we can do that yes for yeah
so you you can think about a new class
as a seal plate something that you know
all the subclasses of and for that you
can do one question the question the
question is do you have real pad match
and the answer is currently we don't so
currently we have this poor man's
pattern matching that instead of binding
here actually gives you this e that you
can access the access members of and we
are trying to get away without any that
imagine because it's a complex feature
so if it works without it we'll be happy
will not implement it although it is
designed there so in the design
documents we have the Batman
specification but I've always hated it
and I'm trying to get away with us okay
a few words about exception handling
exceptions are not checked otherwise
they are like any other exception like
like manage exceptions in Java or in
c-sharp that's it
the question is are we going to
bootstrap Kotlin yes of course so when
we get to the beta stage it's probably
very soon we'll start to use color in
production J brains which means redoing
Goblin and doing a parts of IntelliJ
IDEA so oh yes of course well and this
is my dream you know I have so much code
and you rewrite it all from scratch this
is so cool my trade is very very much
like an interface it you actually can
implement methods inside trains and this
is the difference so it's like Java
interfaces blast method implement the
implementations right hand side so this
is kind of close to what Java 8 will
have maybe this is multiple
implementation inheritance in a
restricted way trades cannot have state
and this is visit a huge thing so when
you have multiple implementations
heritance in say a plus plus the problem
there is state and actually not not
state as such but initialization our
trades have no state thus no
constructors there's no problems with
multiple here
you just say after this : here you can
specify your constructor parameters
right here you can have only one base
class so it's not like huge expression
is just one one of them is getting the
audience
okay I'm wrapping up here so I didn't
cover a lot of things and you will find
them on our homepage you're welcome to
contribute so if you have spare time and
Google policy allows that come over to
our bug tracker and you know attaches so
and so forth and we're constantly
looking for ideas so if you have any
interesting things to suggest any any
critical notices anything please we'll
communicate them somehow from the forum
through the forum fro through Twitter
whichever way you like and if you have
friends who are very fond of programming
languages tell them that we have a very
interesting project and we are
constantly looking for promoters and for
as well as contributors or employees
oh I think we're pretty open to changing
things before we release anything
I mean beta is still not effects design
so the point is to try it in the wild
and to fix things that are not working
good so we're willing to improve
anything we have yeah so all the
suggestions on the syntax are very
welcome and I will really appreciate
that help because syntax is probably the
most painful although the least
interesting part lang Marquess
agree yeah I would say that okay so the
question is why are we postponing was
Pony yield basically technically the
answer is that our language is
imperative stitute to implement yields
efficiently you need to do this EPS
transform your code which in Java means
that you actually emit a lot of objects
and this is problematic because your
generate a lot of garbage and this just
does not meet any performance
expectations so the plan about yield is
that we first do inline functions that I
mentioned so the point is that if you
have a function that takes another
function as an argument
you can inline them both and this means
no quarter objects whatsoever and that
code is efficiently transformable for
cps and then you can do yield on top of
that feature I mean you you can before
that you won't be before much actually
and it makes mostly no sense to to work
work out the whole power of field
without inline functions yes
well if you think about it what he'll
does it puts your value inside some
collection and then proceeds from from
the point it was it was in the execution
right so this actually means that there
is some transformation to go going on
behind the scenes because to proceed
from from the point where you were
it means you either had to somehow
transform your code to pass the
collection to put your things in into
the code or you had to transform the
code so that you can so that it's an
otamatone and you can stop it and then
proceed from that point on right okay
yes yes yes but but if you just use
porters there it means that you you
either create many quarters behind the
scenes and these are objects that cost
or you make your users create those
objects explicitly and this is just huge
code yeah so the point there is only
performance of course it's doable
but it's mostly pointless so as a scalar
shows got lots of performance problems
with Ford and Scala just because it
emits so many objects so this is this is
what we're trying to avoid and this is
why we are pairing the implementation of
yeah so our our environment is that we
have so around me I have like 100
developers use IntelliJ IDEA daily with
Java if I want to migrate them on
anything that cannot do a global
refactoring they just wouldn't do it
so yes fortunately we have we have
people who did the IDs huge IDs for Java
on the design team so if anybody
proposes anything that wouldn't work in
that scale did you say guys sorry it's
not an option no no so there will be one
thing will have it what we call a
dynamic type this is something you can
say call anything on but there's an
explicit thing so if you if part of your
code is dynamic you cannot rely on a
factoring there and this is your world
orientation but this this is actually
supposed to be something in the corner
because you need it for say JavaScript
interoperability you need it for maybe
some dynamic frameworks instead of
reflection for example many things like
that but that you never refactor it
anyway
yes that's correct
okay so what's about mocking good
question first of all I don't believe in
mocking classes mocking classes networks
walking interfaces does so in in the
trades
everything is open by default course so
in classes yes we took this actually
this is something we might reconsider at
some point because the story was that we
started with the full model of multiple
inheritance language and there there
were a lot of associated costs with
non-virtual with sorry with virtual
things and classes you can inherit from
so we try to minimize the number of
those open entities by making them
actually final by default but we
couldn't take over multiple inheritance
it's not solvable in any good way so we
took least a doubt and we separated
classes and trades and but that decision
of making everything final by default is
still there because well this is what
books tell us right you have to design
for inheritance so by default you should
be able to override that it is an
arguable point I'm not sure which way is
better I definitely do not believe in
mocking classes I do not like that code
that hacks all over swing with
overriding some productive things that
were not supposed to be overridden and
by breaking everything eventually so I'm
not sure if if we should actually
reconsider that but we might so well
actually just gather some something back
from people and see if that's a huge bay
which is removed by the way
there is interesting thing interesting
thing about tests the plan for for tests
in Kaplan is that you'll have a special
mode for compiling tests where you have
access to everything private and
everything that you normally don't have
access to and there are questions about
whether we can allow of writing there
where no overriding is possible but this
is not clear but at least for private
things you will have access to them and
it will be actually the code you're
running but just compile with a little
bit extra accessors in in different
places if you have any feedback on that
I'll be very grateful because this is
not done yet and not tried out yet it's
very good time to give feedback more
questions
I tried to match what you what you're
talking about to what we have so there
will be a few things first of all the
compiler front end so the type checker
is a reusable component so you can
actually take a bunch of code analyze it
and get the ast out of it this is what
the ID does actually one thing second
thing of course you have your annotated
bytecode and for static analysis
actually the bytecode is the best
presentation because this is how all the
analysis actually working internally
everybody generates bytecode and
analyzes that like maybe not that
precise as Java bytecode but still yes
so there is a third thing ylor plugin
architecture where we we aim at
providing a stable API for the ast where
you you're guaranteed to have this
structure and be able to analyze it with
standard things but this is not there
yet of course because the compilers
being refactor all the time so we cannot
guarantee the stability of that until we
are done with the release of course but
there is a plan to do something like
that where I think we're a little bit
over time so thanks everybody for your
attention it was very interesting you
have any more questions come over and
I'll answer them do I have anybody else
in this room do we have to leave right
so if you have more questions just
approach me and I'll tell you everything
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>