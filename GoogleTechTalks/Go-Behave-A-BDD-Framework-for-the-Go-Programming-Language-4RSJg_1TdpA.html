<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Go Behave! A BDD Framework for the Go Programming Language | Coder Coacher - Coaching Coders</title><meta content="Go Behave! A BDD Framework for the Go Programming Language - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Go Behave! A BDD Framework for the Go Programming Language</b></h2><h5 class="post__date">2010-01-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4RSJg_1TdpA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm Sam Tesla and I'm here to talk about
development in go and a framework that
I've written called go specify a little
bit about me I'm a development lead at
Engine Yard where I do a lot of ruby
programming but I like a lot of
programming languages I've used over the
last ten years or so I've used all of
these for various kinds of projects I do
a lot of Ruby right now but I like to
look at new programming languages when
they come out so naturally last fall
when go was announced I looked at go I
took a project that I've written in okay
amo lambda calculus and i ported it over
to go using just the tools that were in
the in the suite and it was fairly
straightforward but i found that go test
the framework that comes along with the
package didn't provide me with the warm
fuzzy feeling that I like in a testing
framework like what I'm accustomed to
with our spec or even j unit and so I
decided to write a new testing framework
for NGO called go specify which I will
be showing off here in a little bit so
go specified is a BDD framework I don't
know how familiar your folks are with
BDD it's pretty much like TDD
test-driven development but it's a
little more focused on how you say
things I'll talk about that tdd start
out with unit testing right ten years
ago unit testing was something you
should be doing but you wanted to do
something a little bit more test driven
development is more than just unit
testing yeah you're writing unit tests
you're using a unit testing framework
but we were already doing that before
test driven development came around so
you think about what is different what
sets test driven development apart it's
not that it's unit testing it's that
you're developing to clients for your
source code you've got your tests that
you you know theoretically even write
first so that you can sort out the
interface to your code and then you've
also got your production application
whether that's you know server a desktop
app a web application so you've got
tests and you've got your app and you're
focusing on the interfaces so the
trouble with test-driven development
isn't what you do it's the words that
you use we were using existing tools
unit testing frameworks like J unit and
there they've got a very test centric
vocabulary you make test cases you write
tests you have assertions and in the end
you get a regression sweet absolutely
you've gone through and written all of
these tests to specify your behavior and
you can run them at the end their
executable and they prove that your code
does what you think it does but really
for test-driven development that's a
side effect it's a really nice side
effect but it's not the real push of TDD
the push of TDD is building modular
software that's got good interfaces that
are thought out for the purposes of
testing at the beginning and usually
that also means that they're really
extensible so taking a little foray into
psychology very briefly there's this
thing called the sapir-whorf hypothesis
which basically says that the language
you use to describe something affects
how do you think about it so language
matters basically so we've got
test-driven development the first word
there is test that already just puts us
in to this verification mindset you know
I want to make sure that every little
piece every little bit of behavior
behaves exactly like this and then it
looks like this everything is perfect we
get into a quality assurance mindset
which is great we need to do that for
software but with test-driven
development that's not the main pushed
main push is to help it help you do
tactical design you've got an
architecture but you want to have a more
tactical design and you want to push
that off to the end and you want your
test to tell you what that should be so
get rid of the word task replace it with
the word behavior and you have behavior
driven development
wow that's been around for the last four
or five years you've got things like
r-spec cucumber now and that's great you
can build up a ubiquitous language for
the domain driven design folks around
your specs saying you know given the
circumstance when this happens then I
should see this result you can use the
nice language that you get from a spec
framework to write your test driven
tests but I think that even this is a
little a little too misleading because
you've got behavior driven development
which is a whole life cycle it's from
the customer to the programmer making
the software but at a more fine-grained
level when you're doing BDD as a
programmer you're not so much focused on
the whole development process it's about
design you come back to this wanting to
do tactical design pushing off your low
level interface design decisions all the
way to the end and so I like to think of
BDD is behavior driven design now this
is me another name that people like to
use is designed by example and so you
see we replace tests with examples it's
the same thing just a different name and
we replace assertions with expectations
so you have an example and you expect
that one plus 1 will be equal to do and
that's the kind of framework that you
set up it frames the whole situation
slightly differently it's you're doing
the same thing as TDD when you do TDD
right but you're using a different
language so that is where frameworks
like go specify come in
go specify is a BDD framework for go it
gives you the framework to run your
specifications to write them in a
language that's a little more English
I'll show you a basic example here this
is j unit I've got several j unit
examples so this should look very
familiar so the first thing i noticed
when i look at this is there the word
test is everywhere and so i'm testing
this and also the other two things
there's an assertion which when I think
of assertions I actually think all the
way back to see I put in an assert and
my program will blow up if that fails
that's really not what we want here we
want something that describes a behavior
but my favorite thing about X unit in
general is the order of the arguments to
the assertions I always would get them
wrong especially because some frameworks
do than the other way around and so here
the expected value is what comes first
but really I'm saying 7 times 6 is 42
not 42 and seven times six so when you
do this and go specify what you get is
something it's a little more verbose
there's strings around to describe stuff
and you say it should have the answer
and that the value six times seven
should be equal to 42 there's some
interesting things about doing things
this way it separates what you're doing
to determine if the expectation is
correct from the idea that it's a
positive or negative test because you'll
notice that be equal to is a separate
little method call in there but the
biggest thing it does is it expresses it
more like an English sentence and it
puts the actual value in front of the
expected value which is intuitive and it
has you describing things more you know
it should have the answer or you know it
could be something like it should match
when values are odd things like that and
it's just it's more English it makes it
more like a executable specification
yeah before blocks does the same thing
that is set up in j unit would do oral
actually calling before now you've got
this this is your j unit example the
same thing in go specify looks very
similar you specify a callback for
before because this is all being done
with closures the funks are lexical
closures you don't really get fields
like you do on a test case because you
know an X unit you have fields on your
object and it's a new instance of the
class for each test well here these are
all functions these are all anonymous
functions and if i put a variable in
that outside scope it's the same
location in memory but i'll get to
thinking second each specification runs
in parallel so we don't want that kind
of access so the state the context of
the example gets passed in and you can
set a field in that there's a hashmap
behind the scenes and you can get to
those values yeah I know example is a
type that go specify defines so far are
these are all these are all types in co
specify there is also interface context
which you'll see in a second example has
a context and that's where the fields
actually live methods that you can only
access from before and it or on example
methods that you can access in
everything including after blocks are on
context so speaking of after blocks I
actually didn't add these to the
framework for a while because I haven't
come up with the situation where I
needed them I find that usually tidy
specifications clean up after themselves
anyway but eventually you do get to
something where you need to clean up and
it looks better if you do it in an after
block so here it is in j unit again
setting up a file and deleting the file
when you're done if we imagine that we
wrote an open file in a closed file
function to make my slides shorter this
is what it would look like you open the
file you set it into a field so that you
can get
later in the separate call back and then
after we'll get run after the test
regardless of whether or not the test
passes there is a context for each task
for each specification and go it does
this kind of inheritance through
delegation so if i have an object that
implements the context interface but it
also has the additional methods for the
example interface it's both of them and
every example is a context because it it
expects those methods to all be there so
basically it's the same pattern as j
unit there's an object that gets
constructed for each specification that
runs and its present for the before
block its present for the if block and
its present for the after it just has to
get past in there all of the that the
value method is that's pretty much the
only thing you can't do the idea is that
assertions in your after block is bad
style so I use the type system to make
you not be able to do them so here's
your after block
all the expectations here's the these
are all of the assertions on the assert
class in j unit as of the Javadoc that's
on the internet yesterday there is a
corresponding matter for each one be
just uses the Equality operator to test
the values so for integers for Strings
floats pointers that'll give you what
you want be equal to uses the equal to
method it's an interface that's defined
and go specify and if you define that
method on the type that you pass in to
the matcher it will compare using that
method otherwise it falls back on
equality just like be beat Ruby Falls be
nil those are just using the Equality
operator to compare but there are things
that you do so often in specs I'm a
mattress for them should will do a
positive test should not we'll do a
negative test usually style is good to
say should but sometimes a sentence
makes more sense if you say should not
so both of those are their custom
matchers are pretty easy to make you
don't like the vocabulary of matchers
that I provide is pretty narrow and I'm
working on making more but the idea of
behavior driven development is that you
want to have a wide vocabulary you want
you don't want stuff to look like test
programs you want it to be as close to
English as you can so if you've got some
tests thing that you repeat over and
over it can be who view to make a custom
matcher an example would be if you have
something with invoices and those
invoices have line items and there's a
certain behavior that takes five or six
lines to express and you want to do this
kind of test over and over well in j
unit you would you know just expect a
function and go specify you can extract
a custom matcher so you can express that
a little more a little more differently
the interface that you have to implement
is very simple
there's a positive test and a negative
test and you don't necessarily even have
to implement both so I've got an example
of implementing this interface that I'll
walk walk through real quick so first
I'm going to implement a satisfy matter
so the function that you actually call
satisfy is down here at the bottom I've
got some types defined up here we've got
a predicate it's a function to take some
value returns a boolean we've got one
that always returns false and then we've
got a structure if we wanted more state
we could add fields there and then we've
got the function that actually construct
sour matter if for whatever reason the
nilly path or the predicate you passing
is now I'll just default it to always
return false and then we return the
structure this isn't I kind of whip this
together the next part of it and the
font gets smaller because the code gets
longer you implement both sides of the
interface now I've defaulted that should
not here to just return an error it's a
nice pattern I've got on the side
project I'm working on that I'm using
this to test I've implemented several
custom matchers but I only ever use them
on the positive side so they all blow up
and fail if you do should not but that
way it's not you don't have to write the
negative case and copy the code over you
don't have to abstract it right away and
in the future if you actually end up
calling it it tells you exactly what's
wrong but here called method if it does
not match return an error and otherwise
return nil so should and should not you
basically return an error from those if
it fails if it does not return an error
than it assumes it passed there is a
consequence of this for actual errors
that I'll show show in a second and then
we can implement a predicate is an odd
integer it won't pass for anything
that's not an integer and it won't pass
for anything that's odd
and we could call it like this should
match odd integers that battle pass so
that's how you implement a custom a true
now I really wouldn't do it for
something as simple as that but you can
get more complex things like reading
byte streams off of channels and saying
hey I should have gotten these 20 bytes
that kind of thing you can abstract it
all behind there and make something nice
in the specs for go specify itself I've
got mattres that say I should have
failing tests with message and then you
know I passed on a string and it looks
through all the failing tests that it
recorded in the test run and looks for
that string in the error message so that
i can test that the reporting stuff is
coming through okay so another thing
that you can do in j unit is you can
ignore tests so that you can kind of
ahead of time go out and say these are
all the things i should do but i don't
have any of that implemented yet ignore
ignore ignore ignore here I find that
quite often I've got several ideas about
what behavior I want and so I'm gonna
write out several requirements or maybe
you're translating a requirements
document so you can have pending specs
so here's what you would do in a unit
here's what you do in go specified you
just don't pass in a call back if the
callback for the it block is now it will
treat it as a pending inspect errors do
happen I mean Joe is for systems
programming systems programming has
errors and the trick here is that in j
unit and other X units style frameworks
use exceptions for all this stuff use
exceptions to report test failures a
particular class of exceptions and then
any other exceptions which would
represent errors such as not being able
to open a file they just filter all the
way up to the top well go doesn't have
exceptions and the way that go specify
simulates the test failure exception
which I will get into a little bit later
the way that that works it completely
doesn't distinguish so if a test fails I
need a different way to tell it that it
failed with an error as opposed to it
failed with a failure so this is a
function that's a method that's on both
example and context there is an error it
will terminate the test immediately so
if I had code after that if block it
would not get run but it reports
differently to the reporter you'll it
gets tallied up as an error instead of a
failure it gets reported in the earth
section instead of the failure section
beyond that there really not any
different but so you're not going to
call error all the time it's not like in
j unit there's fail that's not what this
is this is I have an exception because
let's say do something is opening a file
and that's going to give me back an
error or something bad happening opening
a file otherwise it's going to be now so
this is an exceptional case now forgive
me the font gets a little bit smaller
here this is an entire spec file I'm
going to talk about several things in a
minute when i get to the section about
the hacks i've done to get go specify to
behave nicely but you put your specs in
the main package the command that you
run builds up another main file that
runs them so you put them all in maine I
I like to import the specify module
itself into the current namespace it's
not something you're going to do in most
go programs but here it prevents you
from having to qualify like the example
type in the context type it just makes
things a little more concise I thought
that funk II specified example looked a
little noisy but you don't have to do
that if you don't like to and then I've
got an example of one of each I've got a
test the passes a test that fails and
test it blows up
pending test so if I were to run this
file you run it very simply by saying
specify and the file you can say star
dot go and that will pick up everything
that matches the wild card it compiles
them all together into the main package
and then it runs them using the source
code that's in that shell script it
spits out a source source file and it
cleans up after itself so if you look up
underneath the command you'll see the
passing tests produces a period the
failing one produces enough the error
produces an E and the pending one
produces a star just like our spec does
if you're familiar with our spec tells
you a tally and then it'll print out
errors failing and pending in that order
kind of order of importance errors of
the biggest deal notably it also prints
out the file and line number of the spec
where the expectation that failed was or
the it block of the pending example or
the line where error was called and I'll
talk about about how I actually got that
information because it's cool so before
I get onto the hack section are there
any questions about the girl was specify
syntax it's pretty straightforward I I
was really pleased actually coming in to
go you know coming from see I've seen
test frameworks and see and they're
really pain to use and they're ugly even
when they try to not be ugly and go you
know it has a similar heritage but the
ways it's different from C and C++
really enabled a nice syntax go specify
tests look a lot like our spec tests
surprisingly enough I mean there's some
syntax stuff you just can't do and go
because you know Ruby's dynamic and it's
all you can change everything all the
time add methods to any class whenever
you want but here there were several
things I did to improve the readability
and to remove boilerplate from specs and
the first one is put everything
package made all of your specs just put
them in a package together if you wanted
to get all fancy you could make separate
test packages but the idea here is your
specking one thing you don't need to use
the package system to separate your
specs the described blocks are separated
already and so just put it all in
package made it also makes it easier
easy to make helpers you don't really
have to worry about exporting stuff
there's a lot of things that I
capitalize the word anyway which exports
it but that's just to make it look like
the stuff that gets exported already I
like having the Masters having a capital
name but custom matches that you right
they're going to be in package main as
well there's a lot of helper functions
described it before after those are
actually defined in the template that
the specified command uses to make mango
and mango has a global spec object
that's defined for your test run and
these helper functions are just there to
hook up your call backs into that you
could conceivably write it without that
you could make your spec object you spec
dot before expect off describe that kind
of thing but it just makes it look nicer
the kind of the ethos behind making this
was you should have as expressive of a
DSL as you can manage in go and that was
part of what I was trying to figure out
as I was writing it is how expressive
can I make this how much like a DSL can
I make this look without actually having
to write an external dsl and I was
pleased I got to the point where I
really didn't feel I needed to import
specify into the current namespace not
really a hack um and in fact if you look
at the ghost specification when they
talk about that syntax they say it's for
testing that's why you might want to do
that and so I do that to get
specifically the types because most of
the functions are actually
most of the functions are ms in the
aren't coming from specify they're
coming from the helper functions this is
the biggest half putting the describe
block inside a net one thing I wanted to
avoid experience I've had in other
languages where you don't have a method
for introspecting your object space for
your class space is you have to register
it so you use something like oh unit 40
camel and you have a test suite where
you explicitly say here are my tests run
them in this order I didn't want to do
that I wanted it to be you write a spec
file and the tool magically finds it now
go test does that too what go test does
is it looks through the file for
functions that start with the word test
and it stitches them all together for
you I didn't want to have that
requirement and I didn't want to have to
make something different for each spec
file in it is kind of neat in as much as
you can put the same function in each
file they can all get compiled into the
same module and they all get run so long
as you don't have any ordering
dependencies between them because the
order in which the Nets get run is
non-deterministic it's all good
described blocks don't actually do
anything they just take that call back
the whole thing and stuff it into a
collection so that's fine it's just
initializing your test run and then the
actual main function is generated by the
by the command the next thing that's a
little more hacky and cool and exhibits
doing something like exceptions and go
is using channels to catch and throw now
there's a module in the experimental
part of go called Xbox epson's that
essentially does this I just wrote it
myself it's pretty neat when you have a
failure it puts their there's a channel
that gets constructed fifo buffer that
gets constructed before the test runs
and the go routine that's running that
that spawn the task holds on to that and
then the go routine that's actually
running the test has a reference to that
as well
and if you fail an assertion or if you
call error anything that should cause
the test to stop where you would have
raised a test exception in Java you just
put true or well you put the error on
the channel and then that comes back and
gets recorded in the reporter so you get
the same kind of behavior where if
you've got three or four expectations in
a row the first one to fail will
short-circuit and the rest of the rest
of the spec won't run the other thing
that i did and i was i was very pleased
when I found this function it's nice to
get a file in line number saying hey
here's the place in your spec that fail
you can get a long way with just error
messages you know you put a different
error message on each on each assertion
and J in it and then you don't need the
line number i mean it's there you get a
stack trace but I'm not raising an
exception so I don't have a stack trace
from that and go doesn't have a
preprocessor so I don't have you know
double underbar file and double underbar
line and i really wouldn't want them
because they're ugly anyway but go
provides this runtime collar you can use
it to get the file in line number of
stack frame and where that is all the
way up through the assembly language of
the of the runtime and I thought that
that's kind of neat as far as I'm
concerned that you can get all the way
out of your code but go because the way
specs are constructed you know exactly
how many stack frames out the thing that
you know the expectation line is or the
error line is or the hit line and so go
specify uses that to get the file and
line number and in some cases you can
skew that i found this the wrapper
method that i put around it gives you
know it adds another stack frame so
there is a way to customize how many
stack frames up it looks but you
probably aren't going to need to use
so here's a few URLs the code for go
specify is up on github there's
behavior-driven org it's a website put
up by dan north the original inventor of
BDD it's a great wiki it's got a lot of
resources a lot of behavior driven tools
and other languages if there's a J spec
there's a CPP spat a lot of really cool
stuff the go website if you don't know
it and then last but not least my blog i
blog about this stuff periodically so
thank you are there any questions yes I
could use a global variable so the
question is can you use global variables
inside and it block and 0 instead of the
unit function I you could I mean the
trick there is just you got to stitch it
into the main function the main function
has to know hey this is what I'm running
so behind the scenes there's a global
variable that's a single specification
object and each time you call describe
it calls the described method on that
object so there's one global variable
but I'm just hiding it and then i use
the in it to run all of those method
calls on it's mostly just so you don't
have to register tasks and it's the only
function that you can call the same
thing in every file and have it work if
you you know did something else it would
complain that the method get' sorry
declared and that's because in it
special and I didn't feel it was two
hacky I am initializing my program I'm
just doing a lot of initialization so
any other questions
there's these big tables of test cases
definitely if this were the goat testing
framework would you suggest still having
a t-bone and describing it up apply from
that or would you suggest Eliza
it's a good question so that's actually
exactly how i used go test when i when i
used it you make a big table of input
and output on something the question is
sorry the question is if you look at the
actual test for go they're very table
driven you construct this big table of
like for the thumped module you have a
big table of input and output you know
this string with these parameters
produces this string and you just run
through it and that's a great style for
using that testing framework in
particular it made it really easy when i
ported my lambda project over because
that's exactly how i had written my
tests in o camel using o unit because it
lends itself to a table different style
as well and so I actually had these
tables have been putting up with and I
just copied them change the syntax and
then made the pass so that was really
great in behavior driven development
what I'll often do it's just coat right
so you can make the table and then have
the table generate it blocks I did that
on this proxy project i'm writing
because i want to test how a certain
thing behaves on each of possible 255
values of a bite i have a function that
generates an it block for each one and
that gives me a nice message it'll say
hey I this back failed you know for byte
127 I expected to see this I got that
and so you can still use a table driven
approach BDD is very much still about
eliminating boilerplate in places
another thing that you can do I'm
writing specs for less than matter right
now and go specify and you can't really
do tables on types they're not they're
not first class like that so I've got a
lot of it blocks saying you know if I'm
comparing an int with a float that
should work if I'm comparing a float
with an it that should work and so on
and so forth you can write all this out
and then extract that into a function
and then you've got this function and
just past the example so so soon your
land a kind of this thing that you
actually convert
now now when i did the lambda calculus i
just did that all with go test i wanted
i wanted to see a how long it took me
and be what it looked like just using
what I got with go I didn't want to do
anything else and after you know the day
or two it took me to put that over I
said hey if I were doing a real project
that I haven't already written in
another language I would love to have a
BDD framework because that helps me
think about things you know I talked
about how I view TDD as a design tool it
the big thing for me for the last you
know five or six years doing test first
development has always been test first
development keeps me honest right away
it's like this is what I think I'm doing
that is in fact what I'm doing and so
you can look at a passage of code and it
looks really obvious you know on visual
inspection that this is what I should do
but there's some corner case and it's
not really a corner case it happens a
lot but you don't realize it and doing
things test first tends to keep you a
little more honest and the value of BDD
is it reminds you that that's actually
what you're doing more questions Kevin
so go specify is really not doing much
code Jam the file it does spit out a
file but it doesn't actually I don't
think it substitutes anything into it
it's entirely static it's just a bunch
of helper methods the global variable
and a main function that's about five
lines long most of what it's doing is
okay here are all the files you told me
you want to run I'm going to compile
them into a module I'm going to turn
that it's a bash script that's the subs
to do for a make file really and it
spits out a file statically and then it
deletes them after it's all done so
there's really not much to it I try not
to put anything in there if I can help
it more questions
great thanks guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>