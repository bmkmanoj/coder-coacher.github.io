<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>i3 - An Improved Tiling Window Manager | Coder Coacher - Coaching Coders</title><meta content="i3 - An Improved Tiling Window Manager - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>i3 - An Improved Tiling Window Manager</b></h2><h5 class="post__date">2012-06-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/QnYN2CTb1hM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">and this talk I will give an
introduction to i3 which claims to be an
improved tiling window manager and if we
can hold up to that claim I will cover
that later so before the presentation
starts I would like to know who of you
is basically interested and doesn't know
what this is all about and two of you
who is in the camp of what another
window manager you better have a good
reason for that so please raise your
hand if you are using a standard desktop
environment okay so most people do use
the standard environment good so I will
briefly cover this what you see here is
a screenshot of a standard gnome session
right what you also see is that on the
top left the menu is expanded and you
have big bars on the bottom and on the
top of your screen and you have a
desktop background and window
decorations around the file browser
window so a desktop environment in
general is a collection of software and
libraries and tools which aim to provide
a consistent look and feel so in this
case the decima moment is known so it
provides the gtk toolkit which was born
when Jim proposed initially developed
and it comes with all these tools which
start with G like GIMP or GED or genie
or decree or whatever right you have a
lot of tools which provide a consistent
look and feel and you can change
different settings on your system like
what monitors are configured you can
configure your printer is your internet
connection stuff like that so this is
all shiny easy why would you switch to a
different way of doing this so a window
mentor is part of the desktop
environment
McNown comes with a window mentor and
KDE comes with one but what I'm trying
to sell today is just using the window
mentor without all the rest so what you
see here is a screenshot of a typical I
three sessions and what you will
immediately notice that there is no big
bar at the bottom or at the top you have
a very tiny bar
you have no desktop background
you have no big icons and no fancy
window decorations so it's all very very
small and lightweight but however
there's one big difference and instead
of having multiple windows on your
screen and seeing the desktop shine
through with a tiling window manager
your windows are arranged like tiles on
your screen so you will always use the
full screen space okay
so let's start with a bit of history we
started the i3 project in February 2009
so in a few days it will be three years
old it was initially thought and still
is as a successor to wmii which we
absolutely could not hack so we looked
at wmii which is a different window
manager and we were using it at a time
and there were a few little annoyances
which we would like to fix for example
instead of having very clear window
decorations like the one in this
screenshot you can see that there's just
a rectangle with the window title right
in wmii they introduced these little
edges and that annoyed us we want to fix
that and it turned out to be pretty hard
the source code of wmii was largely
structured in such a way that they used
many abstractions which we couldn't make
any sense of and also they had a very
tiny amount of comments and the comments
which we found said something like he'll
be dragons and that's not what you want
to read when you start hacking a
particular piece of software so we we
actually try to fix this we started
writing comments for all the different
functions in the WMI source code and
contacted the maintainer and said like
hey can you review our documentation and
merge it into the source code and he was
cooperative it just was a very slow
process and we quickly got sick of it
because I'm documenting software which
you can't really make sense of it's
pretty hard right so instead of trying
to fix the WMI source code or or
modified we decided it is time to start
over from scratch so out of the
experiences we
when dealing with the WMI source code we
decided that one of our selling points
is clean readable and well documented
source code and in addition to that we
also want to have documentation right
it's not enough to have documented
source code we also want documentation
for developers and for users and this is
one of our strongest points we have
excellent documentation for for both
people also what WMI was lacking at the
time was proper multi-monitor support
there are two ways to do multi-monitor
in x11 one of them is having multiple
x11 this place and basically not being
able to move one window from the left
display to the right display which
pretty much sucks and this is therefore
the obsolete way and the new way is
using Cinerama or nowadays x-rounder the
rotate and resize api to have one large
x11 display and then you have an api
which tells you okay the physical
monitors are mapped into this space this
space in this place right and WMI didn't
support any of this
they nowadays they have support for this
but at the time this was a very annoying
issue
so the multi-monitor support in i3 is
pretty good it behaves the way you
expect it to at least if you have a sane
model of how this should work which is
every workspace is assigned to a monitor
so in traditional desktop environments
like gnome when you have say 10
different workspaces and you have two
monitors when you switch from one
workspace to the second workspace you
will switch on both monitors but usually
this is not what you want because it
turns out at least in our observation
that on one monitor you tend to have
like these status applications like an
IRC client or a mail client or a browser
which just always stays there because
you always need it and on the other
monitor you do your work so our model is
very convenient for this kind of
workflow it also supports the workflow
where you want to switch both at a time
but that's not what we are going for
and also we make extensive use of the ex
renderer API and this is pretty good
because it allows the window manager to
know about the physical outputs you have
so on a modern laptop you would have an
output called LVDS one which is your T
of T and an output which is called VGA
one which is the VGA output which I'm
currently using right and by making a
three use D X renderer API we can
actually give you possibility to in your
configuration file assign different
workspaces to different outputs or
specify commands to move a window to
this specific output so its output aware
and that's a great thing also one
feature which we're going for which WMI
didn't provide at the time was utf-8
cleanliness so this shouldn't really be
a big issue right you shouldn't have to
mention this nowadays but still
achieving utf-8 cleanliness in all your
aspects in like the configuration file
the window titles everywhere is not that
easy in x11
the API is were made a very long time
ago and it shows okay so just to jump
back to the successor point I marked it
with an asterisk why's that because we
didn't start with a WMS source code so
it's not just a fork and we also didn't
say okay we want just WMI with these
little additions instead we are like the
successor and what does that mean wmii
itself is the successor to WMI which
stands for window mentor improved
wmii stands for window mender improved
in group and i three stands for improved
group improved so we just continued that
generation and we see ourselves as the
next generation of improvements in that
kind of window management in in the way
of tiling window management so one of
the goals of course is to be passed and
lightweight which means that not
necessarily that your binary is as small
as possible
but instead that it fields passed and
lightweight just much like Chrome right
chrome is a huge binary and still it's a
very fast web browser so much like
Chrome and the the the aim for having
every
user interface element react within 50
milliseconds we also run this kinds of
pests and we achieve much better rates
because our program is much simpler so
every action you do in i3 is instant and
that's a pretty cool feature also we
explicitly aim at power use so this
doesn't mean that beginners are like
second-class citizens to us we also want
the software to be easy for beginners to
get into but this is not the main focus
right if there is a trade-off which we
have to make between making a feature
good for power users and making it
easily accessible we choose the power
users let me just show you how that
actually feels I just switch to a
different workspace my presentation is
running on workspace 2 and I just switch
to workspace 3 which you can see in the
little bar at the bottom left and when I
open a new window in this case the
terminal window which is pretty much the
default window you could say in i3
because it aims at power users and
usually you do most of your work in in
terminal applications so the shortcut to
open a terminal emulator is the modifier
you configure plus enter so as you can
see it fills the whole screen right and
now when I press all enter a second time
it will be split in the middle and both
windows will still use the full screen
but of course this last space for each
of them I can continue this and open
more windows but as you see on this
small displayed quickly becomes unusable
so instead what I can do is I can press
alt V for vertical split and what you
probably can't really see is that the
bottom border is now highlighted which
hints to the next window appearing at
the bottom so this whole area here these
three windows are now in the vertical
split container and I can press alt H to
make it a horizontal split container and
just continue this and this way I can
build arbitrarily complex nested layouts
it's pretty powerful however I don't
need to decide before I open my windows
how they should be arranged right I can
just move a window to the left or to the
top and to the bottom again
there's
like no limit here okay so let's go back
to a rather simple layout of three
windows which is pretty common so I just
open the process list and as you can see
you can't see much right because the
window is pretty small so what can I do
you can violate the the tiling paradigm
in the sanstead you can choose for the
whole container consisting of these two
windows to be in different layout mode
at the moment they're in the default
layout but I can just as easily switch
them to the stacked layout what just
happened is that both windows are now
expand to the full size within that
container and I have both title bars at
the top so I can just switch between
those two with the shortcuts to move
focus in specific directions I can also
use the mouse which might come in handy
so we're not like an elite window mentor
aimed at only keyboard users because we
do agree that sometimes using the mouse
is actually pretty handy for example to
resize windows right that's a pretty
easy operation with your mouse it's
complicated with the keyboard so we
empower users but we do agree that there
are some some trade-offs you can make
here so this is the de stack layout and
this is pretty useful if for example you
have a shell configuration which you
will see the terminal title in your
window title so you can have information
in there but for many people who are
using i3 on a netbook or on this place
with which they just want to use more
screen space they aim to use tap layout
which works the same just that there's
now one single line at the top which
will contain all your terminals much
like tabs in your web browser right okay
so I can switch back to default mode and
of course di3 being a tiling window
matter doesn't mean that it only
supports tiling windows I can very
easily pop out a window out of the
tiling mode and make it go into floating
mode and now I can move it around freely
and resize it as I want because it just
may
make sense for many windows to not be
huge on your screen right if you have
like a 27-inch monitor and there is a
password dialog which I'd like two lines
of text you don't want it to fill half
of your screen that will just just
wouldn't make any sense so there are
many windows which set an appropriate
hint for example GIMP the gimps clay a
splash window and also the toolbars will
set the appropriate hint to be floating
windows by default and I three respects
these you can also override it if you
prefer your your toolbar windows to be
in tiling node or if you prefer any
tiling window to be important mode okay
so sure
okay so the question was if I have a
window in floating mode can a background
it what exactly do you mean by the
background like make it invisible all
right so basically let's just put those
two in floating mode and you want to see
this window oh like this one there was a
shortcut to make to hide all the
floating windows but we didn't
reimplemented when we did the major
redesign yet so if it's really a use
case for you then yeah send patches but
it turned out that for most of our
workflows it just isn't necessary
because most of our windows are in
floating in in tiling matter and we
specifically empathize to two people
that we are at tiling window manager in
the first place not a floating
millimeter if you need a window mentor
which is good and floating mode you
should choose a different one okay so to
compute this live demo what I just want
to show you is the most important piece
of documentation we have for users which
is the i3 user's guide and this contains
basically everything I just showed you
including a key map of the keyboard
layout so you can see that the default
modifier is not one which is usually the
Alt key on your keyboard and then you
have left down up right on your right
home row and you have all the keys which
I just used for tab layout of people at
static layout fullscreen I didn't show
you but the rest I showed you on the
left hand right and the the user's guide
will just give you all the instructions
to achieve what I just showed you so if
you want to try this at home and you're
welcome to just read to you this guy
additionally the user's guide will cover
the whole configuration file of hi 3 so
we have a configuration file which is
unlike other window mentors implemented
as just a plain text human readable file
in comparison WM I was designed in such
a way that it had a shell script as
configuration file and WMI itself
exported a plan 9 file system virtual
file system so
when you would press a key it would
generate an event which was accessible
using this file system and the shell
script would fall on the file system and
read that we banned from the file decide
what to do and then send back an action
to WMI so this sounds interesting right
but the problem is when your computer is
very loaded a simple operation just as
switching focus to the window to the
right would take multiple seconds
because schedule and not giving the
shell script cycles it requires right it
was a lot of back and forth so this was
one of the reasons why we decided to
just use a simple as a simple text file
instead of a shell script right also and
this mostly occurred to me after
actually doing it many people came to
meal conferences or at other occasions
and told me that they are so happy that
you can configure i3 without learning
like Haskell for exponent or Lua for
awesome or ion or whatever a programming
language the author of a specific window
manager thought was cool at the moment
right so the users guide covers the
whole documentation with explanations
and examples for every single statement
and in fact I just want to show you how
simple the configuration looks by
opening the system-wide configuration
file which is just the default
configuration so I think you can read
this just fine point should be large
enough we have like two statements at
the beginning which which is the font
for window titles and the floating
modifier to specify which key should be
hold down while dragging witness around
and then you have this huge block of key
bindings which are just for opening a
new terminal killing a window starting a
launch or changing focus etc and the
configuration file should be pretty easy
to understand for you because the way we
really signed it in the last major
version of i3 was that I basically
thought of good names for each and every
command and then I showed them to a
friend of mine who would who had never
used i3 and I had him explain what he is
commands did to me without giving him
any documentation
and we reiterated on the process and
stopped modifying the language when he
was able to tell me what my program did
without even knowing it so I am
reasonably confident that you will be
able to make sense out of all these
commands and if not there is excellent
documentation to help you okay so yes
okay so the question was watch what
language would you use to extend the bar
at the bottom we see on the screen so
this bar is the what you see there the
status output of the bar is actually
generated by a program called I 3 status
which existed before the window manager
existed it was back then it was called
WMI States and I wrote it because I was
dissatisfied with the way that wmii
populated its data spot which was by
using shell scripts again and this was
pretty slow and like your bar would not
refresh when your system was on the load
and this was annoyed me so I wrote a
very tiny C program which had as its
goal to use as little as possible system
calls to generate the whole system
information right so this is I 3 status
I can just demonstrate what it does it
just prints out a status line every
second and then the bar picks it up so
it's just plain text format what you can
do to extent this with your own widgets
is you just create a wrapper script in
fact we have C alright okay right in
fact we have a sectional man page which
covers that external scripts and
programs with alpha status so you just
use a simple loop around I 3 status and
then you can use any language you want
to extend this output you could use like
shell or a higher-level language which I
would recommend and to put your own
stuff in there okay so inter process
communication and this might seem not
that interesting for you if you're just
the user but bear with me so we have a
UNIX socket for inter-process
communication instead of a pseudo file
system like wmii and we use JSON for
serialization because it's available in
like every language high level or low
level there are several implementations
which make use of the IPC socket which
makes me confident enough that it's
simple enough to anyone to implement a
party because I only wrote the first two
implementations and the other one
we're sent by external contributors so
we have a three message which is
implemented see we have a Perl module to
communicate with I three we have a ruby
in the python module one of our users
even implemented a node.js module and
then had like a simple web page which
you could use with its mod phone to
switch workspaces on this computer
pretty pointless for my point of view
but but nevertheless so what can you do
with the IPC interface you can send any
command a command step what I just
showed you in the configuration file
like focus left or floating and able to
make a window I go in floating mode
right you can also receive certain
events like focus changes and the most
important thing is that you can actually
access the layout tree so a bar which
you see at the bottom is actually
implemented as a separate process it
just communicates with your window
manager over the IPC interface it gets
event whenever I change to different
workspace and it can also send workspace
changes by just clicking on the
different buttons for workspace so how
would I use this I could do a three
message workspace or to switch to a
different workspace right so you can
automate and script every command which
win which just will amend your supports
so whenever you figure out that there is
something which is very specific to your
workflow you can just automate it in
fact to make this more semantic and more
nice the id3 binary itself will accept
commands so you can just do I three
workspace 4 and this is pretty nice
because you can use it interactively I
will show you that later on
so what's deal with the the layout tree
um as I showed you before we have like
multiple split containers and every of
these containers is just a node in the
tree so we use one big tree as the data
structure of Pi 3 and every node is
either a split container or a real x11
window or a sudo window like for your
outputs and the x11 route or a workspace
right and in fact you can get the whole
tree but
using IP message get tree and it will be
a JSON tree containing loads of
stuff but this is essentially all the
internals which I three uses to manage
your windows so you can access the whole
state from the outside what this allows
us to do is have a very sophisticated
test suite so I will just run the test
suite to demonstrate how it looks and we
have 96 different test files at the
moment with well over 1000 test
instructions which all just ran in about
8 seconds because of the crazy
optimization tricks we use in the test
suite and this has proven to be very
valuable we could do lots of
refactorings which I wouldn't have done
otherwise and we can do test-driven
development and I think I don't need to
you know advocate test from the moment
here so this is pretty nice we of course
also have documentation on how our test
suite works so there is like the
introduction how did we implement it how
do you invoke DTS with runner how would
you structure a new test case and going
through a whole test case to really get
people to you know live test-driven
development even if they are not used to
it
and our first-time contributors to open
source ok so I want to give you a few
example workflows because you have seen
what you can do with this window manager
but in practice if you want to evaluate
if it's good for you you need to you
know actually use it in your daily work
life so here's a few things which might
make this easier and might convince you
to actually try it out so one of the
things I want to cover is the urgency
hinge as you might know there are
programs like pitch in the instant
messenger who will indicate a new
message in one of your chat windows by
making the window
you know glow or whatever in your
taskbar in a traditional desam
environment and the way this is
implemented is by setting the so-called
urgency and in fact the terminal
emulator and
using supports this so i configured my
shell in such a way that when I start a
long-running command like the sig five I
can switch to a different window or a
different workspace and when it
completes it will set the urgency and so
I get alerted by the little red three in
the bottom that there is something which
just finished there and the window is
drawn in red until I switch to it right
so whenever you have something like a
download or a compile process or whatnot
you can just fire it off in the
background and switch away and do
different work and you will notice when
it's done so this is a relatively cool
feature another pretty valuable feature
is the scratch pad so whenever I do some
development for example in languages in
which I'm not that familiar in like
Python I would open an editor of course
and then write some code and wonder huh
how did this work again I would just
need to try this out in a little example
right so what I would usually do is I
start like an interactive Python shell
and see if what I expect to happen
actually happens but as you can see this
uses space on my work space and this
kind of destroys my previous window
alignment so I could either say okay I
will just open this and then close it
again then go back but I could also say
I will just open this once and then I
will say I three move scratch pad the
command is shown at the top of the
window in the launcher which is
interactive and you can just launch any
command I'm sorry that font size is so
small but it's just I tree moved scratch
fit just as the command I showed you
previously that's an external launcher
it's called a menu so now the window is
gone right as we can see there are no
additional workspaces and the window is
not shown but when I press alt and -
just next to all the workspace buttons
which are all and all the numbers I get
the window back again and this works
regardless of on what work space or on
what output I am so this is like a
window which is hidden in the background
and whenever you need it you just pop it
up and then you send it back to the
background again and the concept is
pretty powerful because it doesn't
interrupt you from your work your window
alignment is still the same and you can
just you know have a quick look okay
this works go back to your code and
actually do it and I found out that this
is much nicer to use in comparison to
just switching to an entirely different
workspace trying something out and then
going back because it kind of interacts
you and you see a different set of
windows and you can use this approach
not only for like interactive shells but
also for your medic line richer suppose
not to see all the time but whenever you
need it it's handy to just pop it up or
your music player or your IC client
everything which just you know is
somewhere on your workspace cluttering
up all your work environment you can
just move it in the background and not
care about it anymore
okay so the question is can you do that
with multiple windows and the answer is
yes you can let me just demonstrate this
I will also send this to the background
and now when I open the scratch button I
will get the Python shell which I had
there before and when I open it again I
will see the new window which I put into
the scratch pad of course you can also
configure keys which will open one
particular window in the scratch or send
one particular window to the scratch pad
you can also automatically let I pre
start an application and then
automatically put it in scratch fit so
it waits for you until you need it
okay so web development right some of
you might do this there is the typical
configuration or web development is like
you have you need a browser right you
need an editor and you might need access
to some log file whether it's like the
Swiss mark where your server process a
lot too or interactively running some
server process so how would you do this
in r3 you could just you know open
windows like this which is a pretty
quick operation and then have your
editor here and have your log file here
like this and the thing is that of
course you can also do this in
traditional
ninja right but how would you switch
between all these windows we press alt
tab and then the order in which you
switch to the windows in all tab would
be different depending on how you switch
between them right so it's always the
operation of pressing the key looking at
the monitor seeing if that is actually
right and then releasing the key or
pressing it again
or you choose to not do that and get
confused in between the you end up
so in I 3 there is no alt tab equivalent
we just have Direction focus keys so
when I press the key to go to the left I
will go to the browser when I go back to
the right I'm in the editor and I go to
the bottom I am in the lock file right
so this is very clear and you explicitly
state your intention and you will
quickly note that you can just very
intuitively navigate through all your
windows you have in a typical work
environment what you can also do is use
full-screen mode right so especially for
log files it might be helpful to
whenever you edit the code and made it
you change and check if it works and it
doesn't you want to see the log file and
you want to see a lot of it then you can
just pull screen this particular window
right this is one operation which is
also very fast in i3 in comparison to
different window managers because you
know in traditional images usually
requires you to double click on the
title bar or or one eye and then either
it's just a short it so these are the
points where it really starts to get
nice ok so this is this and now will be
the coding workflow where I have two
editors like ok let's say I am coding in
ivory and I source to this point and
then I would typically have the
corresponding test case that is this one
and I would have like a test runner on
this year and now I would wonder about
let's see the syntax of das printer
command so what I can do of course is I
could open a new window and look up the
man page for this but there's more than
one way to do this right you could
decide that you want to read the man
page in full screen or you could say
that you want to read more of the main
page and rather switch
between those two windows or have it in
tap mode so there's there's multiple
ways to do this and whichever one fits
you right is possible in i3 it's pretty
flexible and what a lot of people notice
is that depending on which screen they
are working on like they were working on
a notebook or a big screen in the office
they have completely different workflows
and they are using the window manager in
completely different ways and this kind
of demonstrates how powerful it actually
is okay good
so few numbers because these are the
questions that many people ask me when
they see me at conferences so the most
important question is of course how many
people are involved in the i3 project
and we have at the time I made the
slides we had a bit more than 3,000
commits by 39 different people but the
set of people who are actually regular
contributors is much lower much lower
likely less than five people we have
over 600 tickets open you have handled
over 600 kids and about 60 of them are
open right now these are like feature
requests or bug reports and we try to
fix bug reports as soon as possible or
multiple reasons one of them is that we
want to encourage people to report bugs
right because reporting a bug is not
saying to us
hey you're stupid you made a mistake
it's more like I noticed this is wrong
and be nice if you fix it and in fact we
profit from fixing it because the sooner
I fix it the less likely to chance that
I will run into the bug right because
I'm actually using this program too so I
profit from bug fixes and everyone else
also crop on bug fixes so in order to
encourage people to report back fixes
what we do is we have a black stud III
we at WMUR G which is a track instance
which is open to everyone so everybody
can just submit a bug report without
registering this is this a big
difference actually there are a lot of
open source projects out there which
require you to make an account in their
 Bugzilla so I have like over 60
accounts of Bugzilla which I use to
precisely once report it back and often
when I find a bug I decide to ah come on
not Bugzilla another account nah that's
not worth it right we don't want to run
into the situation we want people to
just report a bug so they can just come
to our IC Channel and tell us hey I
noticed this behavior this is intended
or is it a park and then we might fix it
or they can open the ticket or they can
send us an email to the list right so
there are many ways to to report bugs
and if you find a bug please report so
in which language was I pre-written in
we have about 10,000 Souls lines of code
or C code and a bit of color code here
and there most prominently for the test
suite which is entirely implemented in
Perl
we also have a few tiny bits for example
a new passer for the command language
like the commands like focus left and
focus right and stuff like that so we
previously used legs and yak to generate
a positive product right
but there are multiple problems in
Lexington one is that it's made for
context-free grammars and we don't have
a context-free grammar we have a very
context-sensitive grammar so basically
we implement a lot of state in the lexer
to actually make it pass our language
and then it's very complicated
to understand what a specific grammar
file is actually doing and one thing
that contributions frequently tell me is
that either they don't want to touch our
parser because they don't understand it
at all or when implementing a new
feature or fixing a bug the changes to
the puzzle we're the hardest so we want
to get rid of it or the reasons I just
told you and also for the very important
reason that it doesn't provide good
error messages so you probably all know
like the error messages which do plus
plus produces right when compiling C++
code and you make one single typo in
your template specification and it
produces pages of errors and then there
was si Lang which provided much better
error messages and it was like a breath
of fresh air to the whole C++ community
so
what we want to do is we want to provide
the best error messages there are for
any given this configuration of i3 right
there should never be the situation
where you should where you have to come
to our IC channel and ask us I got this
error message what does it actually mean
right we want to avoid that
but the problem with legs and yak is
that they are not able to provide
flexible enough error messages for us to
actually implement this so for these
reasons we decided to implement an own
passer which is very simple and it uses
a bit of Perl to parse the input
specification and then generate a bit of
C code and there's a bit more secret
which is handwritten and not generated
and together they form a very well
testable parser which generates good
error messages and we have full control
over the error messages it generates so
we can improve whenever somebody says I
have a problem with this error message
so it is pretty important we are not
done switching to it yet but this will
happen soon so the test suite I already
covered this we have more than 1,000
test instructions in 96 files which is
pretty good and many people also asked
how many people are using i3 they
absolutely cannot tell right there is no
way for me to know but we have few
indicators like in the Debian project
there is thing called popularity contest
and for any package it will give you
numbers of how many people are
approximately using it and how many
people have it installed and let's have
a look for the i3 WM package in Debian
there are also other distributions like
our clinics which provide these kinds of
numbers as votes in their package
Explorer 2 and then there are
distributions which just don't have
these numbers at all like all the BSD s
for example don't have used numbers and
of course there is an amount of people
who are just downloading the source
compiling it and then running it right
but we can't really count the downloads
because downloading it doesn't mean you
actually ever compile it or you actually
ever run it so we can just provide
conservative guesses but based on the
popularity contest numbers right now in
Debian we have
yes clearly how to say we have a three
WM installed at about 300 people or 300
computers or Debian installations to be
more precise right and then there's a
dark number of people who did not enable
the popularity contest and a number but
still are using it on Debian and then we
also have the download count script
which is pretty nice so what this does
is it uses our gate lock and I will try
to make one two bit okay so it uses our
gate lock and for every revision we have
in our git repository it will show the
downloads of automatically compiled
packages so whenever I do a new commit
or anyone else does a new commits then
we have an auto builder which will build
packages for Debian and Ubuntu to
provide the latest version so why do we
do this it's for two reasons the first
one is of course we want to encourage
dogfooding right people should use our
software in the development version and
tell us about bugs as early as possible
in order for us to get them fixed for
the release because once we put out the
release many people who are not in
contact with us will actually use it
and maybe not report bugs at all right
but the people who actually care about
the product or the project are in our IC
channels or are in contact with us and
should be able to use the new version
without putting any effort in it right
they shouldn't I have to check are there
any changes do I need to recompile do I
need to reinstall why doesn't compile
anymore right this should all be
abstracted away and they should just be
able to update their system and get the
newest version and the other big reason
why we provide the service is because I
think that nobody should have to compile
software more than one specific set of a
system architecture and distribution
right it's a waste of CPU cycles to
compile software all over again and it's
a waste of our time to explain to people
you need this and that dependency and
this build arrow means this and that and
you need a compiler installed and if it
doesn't work then do this right it's
a big support hasland by providing
binary packages and saying okay you can
use the binary packages you're very
welcome to but if you want to compile it
on your own your are on your own right
so this reduces support by a large
amount okay so we have like I think up
to 50 downloads from the auto builder
for for some versions so a conservative
guess of how many people are using I
three is more than 1000 people I guess
seems reasonable from the numbers I have
okay one more interesting fact about the
the auto builder is that when
correlating the downloads to the git
version we can actually say how long has
this change been in production right how
many people are using it is it
considered stable or not so when we
introduce the new puzzler we can just
commit this and then a few weeks later
say ok 3 weeks and like 47 downloads and
no bug reports on this part of the
software ok that seems reasonable we can
release now right we have a very good
way of getting feedback without actually
getting feedback from anyone for our
changes alright so if you're interested
in this go to AI 3wm dot org for like
everything we have links to the
distributions in which it is available
we have the documentation the developer
documentation the ways you can reach us
if you're using Ubuntu please upgrade to
our repository diversions which are
enable to are very old because they sync
with Debian every 6 month and this is
just too old so we provide a repository
with these stable versions for a loop
please do that if you're using Debian
just upgrade to the version Debian
testing if you don't already you step in
testing it's pretty well maintained and
if you have any questions I'm happy to
answer them now thanks for your
attention
ok
okay so the question was how does it
handle external displays and it handles
them how you would expect it to right
there is the the X render API which I
mentioned at the beginning of talk which
provides an interface there are
graphical computation tools for the X
render API like the ones that ship with
gnome and you can of course use them in
i3 you can also even use a genome panel
that you want to so you can integrate i3
into traditional decima environments you
don't have to however so you can use one
of the graphical tools or you can use
the extra Andrew command-line tool so
the way I actually set up this
presentation was using x-ray and Rajesh
- output VGA one mode thousand twenty
four times 786 same as LVDS one which
basically means clone what I see on my
internal display called LEDs one on to
the VGA output and this leads to I three
reacting to the size change because now
we have two outputs with different sizes
because my laptop display uses 1280 x
800 and it reacts and saturated will say
okay the usable screen space is now the
lowest common denominator of this and on
my screen I see exactly what you see on
the screen I could also have chosen to
configure this in different ways saying
that instead of using the same as
parameter I could have said right off
LVDS one and then it would be configured
in such way that when I move my mouse
cursor to the right of the screen it
will go to the screen and then I would
have a different workspace on this
screen and I would see something
different than you would see right so
whichever way you configure your system
I three adapts to it okay more questions
yeah yeah
oh okay so question was how would I
change focus between the different
displace and the answer is that by
default you can use the key bindings
which are configured to switch between
workspaces right so you have in my
example I would have one two three and
four on my notebook and then I would get
an additional workspace for the video
project or like workspace five safe and
then I could just switch to pipe and it
would switch to pipe right there's no
distinction between it doesn't know so
ex Mona does flip your workspaces around
but in i3 the workspaces are tied to a
given output so whenever you switch to a
workspace you will get to that output
you can also be more specific about this
and there are ways to configure a key
binding to switch focus to a different
output regardless of what workspaces on
it and you can also move workspaces
around so if you want to you can
configure this in a different way okay
more questions yes please
because the question was is there a way
to go to the previous workspace if I get
got incorrectly Oh previews okay so what
you're looking for is a pager yeah so
the way of pager works is by the window
manager setting up different hints
following a specification and we do set
up a few of these hints but I think
they're not enough to actually use a
pager so one of our developers has said
that he has interested in making I three
usable with the pager I don't know about
stages I think there is like no usable
implementation of that but in general
people remember what's on the workspaces
you can also name your workspaces right
so for example I have on the bottom
light on the bottom left you can see
that I have a workspace called one
dub-dub-dub right this works with where
my browser is on you can do this with
any name you want you don't even need to
start with a number right so you could
say okay I want to have a static kind of
workspace configuration but in practice
most people just remember this there's
also one more interesting thing about
this and just that you can configure
commands to match a specific window so
you can jump to a specific window by
examining different criteria it has like
two window title or the window class or
the program it belongs to so you could
say that I want to have the key binding
and in fact I have such key button to
always jump to my IRC client or to
always jump to my Mac line and no matter
on which workspace it is on we will get
to that window so that might be an
alternative to having a pager
okay more questions yes
okay yes the question was that I
mentioned that a tree is passed do we do
any benchmarks and yes we do we have set
of tools which will basically grab the
whole display then do an action on i3
and grab it again within a specific
fixed time range and we'll see if I
three reacted to the change within that
time and we get very good results out of
that so we can actually guarantee that
on a reasonably modern computer like
this one which is like four years old
you will get a reaction within like ten
milliseconds
oh okay yeah
yes it has okay yeah okay so the
question was do we respect in our
decorations hint and it's a bit more
tricky than that because there actually
is no no decorations in decor x11
protocol so and in fact we had multiple
issues with Chrome to make it behave
correctly there have been like two
different bugs which were in the way
that we set up our hints to make it
react a bit different so I have to admit
that I haven't looked into how chrome
actually implements the override the
system decorations thing I would have
guessed that it is pretty specific or
only tested with traditional desert
environments like gnome right
yes
yes
okay so I have to admit that I use none
of them except for Chrome there is a way
to just say I want a different border
style for a specific window you can also
make this automatic you can also choose
to have one pixel window borders without
the window title or no window borders at
all in your configuration for every
window so what I just did was I told I
three to not draw a border for the
Chrome window whenever it's necessary to
draw a border because for example I put
it into stack mode then it will draw one
but when it's not necessary it will just
skip that so this achieves pretty much
what you get by using by by by
overriding the system decoration right
because what this would do is it would
show a little X here in typical window
managers but you don't actually need a
button to close the window because you
have a shortcut for that so I think this
is reasonably close so that is not an
important issue that we don't support
this yet but please open the ticket and
we can look into it
yeah okay so to answer the question in
the way that you're intended it to
we aim to support all of the core x11
like pins and whatever the protocol
specifies right then there are multiple
different hint specifications like the e
wmh or the IC CCM which we support to a
certain degree to which it makes sense
so the policy is that whenever there is
something which is broken because of a
hint we support that hint if possible if
there is no indication that something is
broken then nobody cares anyway and we
don't need to waste time to limit the
technique right because it's a it's a
volunteer driven project we can't afford
to make it compliant for the sake of
compliance
you
you
okay so the question was we don't
support d-bus but IBAs would need to be
at the women there would need to be
divas aware to make the system aware of
events such as plugging in one time and
the answer is that actually it doesn't
have to be so the window manager doesn't
need to be give us aware at all
as far as I know and in fact very little
inventors actually are and the events
such as the the mouse how many you know
how many input device have you connect
how many monitors you have connected are
entirely handled by you de and in fact
you can have external scripts which
react to the change in a display like
plug it in the monitor and popping up a
configuration dialog or automatically
applying a configuration completely
regardless of which way no measure you
use so I would be surprised if we were
to have to use give us to probably
integrate with your system
right we don't use it because not
necessary the for example the use case
of plugging in a video projector is
perfectly handled by x11 and I think
that it it will not really change in
foreseeable future that window manager
hints and communication are handled by
protocols on the x11 level and not
requiring the bus ok sure
the question was where do dialog windows
appear on the same workspace as the per
window or not the answer is at the
moment they appear on wherever you are
currently sorry I know they don't follow
you just pop up on where you are
currently so popping up a floating
window is mostly controlled by the
client application so for example again
remembers the position and size of its
toolbox right and it will aim to pop
them up at exactly the right spot again
when you close it and reopen it and I
three just based it since it could be
changed to always tie a pop-up window to
its parent application this is possible
in standard and could implement it but
at the moment it will just pop up
wherever you are
you
right this would put up the question was
about password enter dialogue searches
for example pass for ACC GPG or one and
this would pop up on wherever you are
currently because it doesn't make sense
to you know so the thing is that the GPG
passphrase dialogue and in fact all of
the passphrase dialogue implementations
as far as I know don't have a parent we
know they are just a separate floating
window in order to make them not pop up
on any specific works with wherever you
are and this is important because they
grab your keyboard and your mouse so
whenever this dialog is open you cannot
have any other input to any other window
so we would effectively be locked in
that situation so yes we do handle it
correctly
you
yep yes
to be precise is not configurable yet
but you can easily make it configurable
so this is just a few lines of code and
it would be a very interesting beginner
project so if you're interested in that
let me know we can work it out I'll take
a few hours and it will be fun and we
will have 40 committers then okay any
more questions mm-hmm
all right then thanks for your attention</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>