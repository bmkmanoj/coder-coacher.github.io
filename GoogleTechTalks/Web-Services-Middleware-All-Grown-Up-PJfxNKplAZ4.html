<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Web Services Middleware: All Grown Up! | Coder Coacher - Coaching Coders</title><meta content="Web Services Middleware: All Grown Up! - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Web Services Middleware: All Grown Up!</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PJfxNKplAZ4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning everybody so I'm going to
give you a kind of a historical view of
how the Apache web services check has
come about and how things have evolved
over time and the current directions
that we are taking and of course it's
all open source projects so as as you
know anybody is really work to come and
contribute to them and help improve them
in the direction that you think is right
so in terms of you I'm going to start by
giving you a perspective of how the
specs have evolved because that has an
impact on how the code has evolved as
well and kind of go through the
evolution of the various specs that have
been driving the implementations of the
web services middleware and then talk
about the the Apaches tax and how those
have evolved and just to give and give a
quick understanding of where we are
right now and what the current direction
is and so what kind of stuff is being
built now very briefly look at some of
the alternatives checks out there and
how we stack up against those things and
then wrap up I should be done in with
enough time to have questions and
answers if you have questions feel free
to jump in though I'm finding that okay
so a small bit of history about how soap
came about so soap was originally
started at Microsoft it was a project
that they started in the early 90s mid
nineties ready to look at how to bring
XML into into the communication mediums
that they were using so instead of
evolving DC they will be looking at ways
of bringing XML as the protocol to us
basic as a message format use xml RPC
which is a widely used protocol now was
one of those things it was done in that
chain of evolution and kind of walked
off and when public and took a life on
its own and it's very much a very simple
our PC protocol down with XML as as the
as a message format in 1999 there was a
version of soap released publicly called
so question point 9 and what that was
basically was an RPC protocol and it was
very much tied to HTTP and and the
problem with that being tried to http
was that they couldn't get traction in a
wider community so IBM kind of became
part of the community in late 99 and
then one of the major things that was on
in the next
version somehow 10 got lost in the way
right there was no one or the other 11
when 11 came out 11 basically was
designed to be completely agnostic with
regards to transport so HTTP was rated
as a transport and it doesn't matter
which transport was on also while RPC
was supported there was sort of a more
of a messaging structure underneath yet
there was a core part of there was a
major component of the suspect was was
something called the soap and coding
data model and what that was was a way
of serializing graph data into XML and
and and recovering it on the other side
and that really fundamentally is
inconsistent with with trading with XML
messages because XML doesn't represent
graphs naturally yes you can represent
graphs in it and by doing that you
effectively brought the whole weight of
our PC structure into into the soap
infrastructure basically and that was
that was released in april of two
thousand and then the spec was submitted
to the Jalopy 3c2 and there was a
working group form over a couple of
years soap on to came out and soap on to
basically is a purely messaging format
it just it just talks about how you take
a a simple message structure take it
over the other side and how the
processing should work and the semantics
of the message exchange and and defines
what I call message exchange patterns
which are ways in which you can have a
one-way message or a request-response
kind of pattern or arbitrary patterns
like that biscuit so it fundamentally
went from being in fact the soap
instrumen acronym until want to so
please stood for simple object access
protocol but it was it was dropped and
soap on to is just hope it's not simple
at object access protocol and and the
way people experience really that is
really soap never had anything to do
with object access it was not a protocol
it was a message format and he certainly
was not simple so it was really not a
good acronym so it was sort of a good
time to drop it and also the entire
graph stuff was completely taken out and
and it's very much just a very
straightforward Victor
I was Microsoft working after the Akron
question me and it was you know it was
it was at a time when when the it was
remember that come from a DC legacy
right so it was just real object
infrastructure and internally was
impossible to say there are no more
distribute objects what we have now
messages and as you probably know in the
in the disputed systems community this
is a this is a long-running battle
whether you need this weird object
systems or you can just do with messages
and and and who's on top is always an
ongoing historical battle and in the web
services well that kind of battles me
inside or basically there is no concept
of speed object anymore it's very much
is purely messages so that sort of how
soap specs evolved over time to where we
are now let's look at the other other
core component of of the web services
tech wsdl so wsdl started with from the
Microsoft side with something called sdl
service description language it's sort
of the inverse of the way wcl its
structure now nobody the steel structure
now is that there is a notion of an
abstract interface and then you bind
that interface to some protocol and and
and wire format and so forth is how
you're going to send the data in stl it
was the opposite it was that there is a
way of sending messages for HTTP there's
a way of sending message of something
else and then you put it all together
and said this is a service so sort of it
really wasn't a service language sort of
a protocol description language IBM my
group we had an alternative proposal
called NASA network applications the
specification language which is very
much like the current obligation in
terms of the abstract and concrete nurse
except was all about RPC basically right
and then when those two were merged a WL
10 was very much a merger of the two
which took the abstract and binding
nature from NASA and combined with with
the more message oriented structure that
stl had instead of the RPC structure and
we came up with this concept called
message which how many of you know what
WS eight is whether it is whatever else
people know a few people okay so waz I'm
sorry so wustl sensor web service
description language it's a language
that you use to describe what a service
does basically I did so if you
it allows you to say this service has
this kind of message interactions it
takes this schema and produces that
schema simple stuff like that and then
tells you how you carry those messages
back and forth how you format the
messages what kind of headers here to
put and so on so in order to do that
wsdl I when these two things were merged
w cylinders this concept called message
which is a representation of all the
things that are going from the source of
the message to the destination and and
its really the structure was that it was
a collection of pieces of data that had
to be sent or received so it's all like
think of email right so email an email
message contains a main body and a bunch
of attachments and and so waz a
structure that this is the collection
there's a collection of parts and each
part can be sent in in certain ways wa11
came out a few months later that sought
to submit to the w3c it's it's pretty
much industry standard everybody uses it
it's quite ugly a lot of people hate it
and you can blame me for most of it but
it works basically right so it's not
it's not great but it works and it's
widely used every everybody supports it
so before we go on let me kind of
explain the design principles that drove
wustl was that the design model I was
rewind IBM so from ibm's perspective
while all this XML HTTP stuff is
wonderful there was no interest in
losing JMS there was no interest in
losing iop there was no interest in
losing any of the other mechanisms that
IBM had for interacting between
different components of residual system
so the design point was to say what we
need is a abstract way of describing
what a service to us and then concrete
ways of binding them into various forms
so wustl was designed with with that
idea in mind so they attract description
of wel even though it uses xml schema to
describe the data that goes back and
forth in fact the data doesn't even have
to be XML at all it's just an
abstraction saying xml schema lets you
describe a data model and that's it how
the data model translates onto the wire
with 18 xml / dates in an iop call an
in-memory call what was a separate thing
basically and and this was implemented
this is not some random thing we created
something called WSI f web service
invocation framework
and and it was open sourced to Apache
after a while what that does basically
is provide a single programming model
that works at the abstract level of wsdl
and then lets you plug in different
bindings so in fact iBM uses this very
heavily in various products the the
workflow products and a bunch of other
places and and what it's used to is to
allow somebody to conceptually program
and design compositions using web
services but yet underneath what you
have are positively soap HTTP services
maybe it's an XML message going over JMS
or maybe it's an iop are michael
basically okay and and so on so it in
fact we even had a cobalt binding
somebody did a cobalt binding so you
could make a cobalt copybook and and
invoke a mainframe activities as part of
the service invocation basically so
that's really what motivated this
abstract concrete design so the idea was
that web services have are an
abstraction not a concrete XML HTTP
thing but an add instruction that can be
realized in various forms and that's the
same principle that you see when people
talk about service-oriented architecture
today you talk about service-oriented
architecture as an approach and web
services as a realization of that
architectural model right and that's the
same principle that you that you see
here for the question is does it really
work then how far can you take it so the
idea was that if you can if you design
completely abstractly then you can bind
them to various forms so think of like
security the original idea was that I
should be able to say this service
requires authentication and maybe the
authentication happens over symmetric
SSL or maybe it happens over WLAN
security or maybe it happens over some
rmi iop you know security context
flowing through right and and those are
all authentication conceptually but in
practice that's not the way this the
standards of all while IBM had that
mindset it was impossible to get
Microsoft who had the exact opposite
mindset which is that the world is
completely bought XML there was really
bored HTTP to buy into this stuff at all
so what ended up happening was that the
the other quality of service pecs that
were defined like ws-security reliable
messaging addressing all of them
basically only work for so if you
addressing it defines a bunch of Cepeda
saying this is how you set the target
and the the fort address and the reply
address for service invocation if you
look at reliable messaging it tells you
how you reliably send the soap message
back and forth and so on so what that
does is it basically makes it so that
the w's i have stuff works as long as
you don't have any of this additional
qualities of service alright so if you
want to lose our lightweight service
invocation which doesn't have any kind
of extra security any kind of extra
liability then you don't you don't have
a problem but if you want something
deeper then then the model doesn't work
so the conclusion you drive from is that
really you cannot make web services work
completely completely transparently
across all different protocols so even
right now IBM civil positions web
services as something that can do that
but in fact is you really can't do that
anymore the reality is that if you want
to do with services and you want to take
take advantage of things like message
level security that ws-security gives
you and not depend only on transport
level security then you have to buy into
into this stuff there's no other way
around it ok so that sort of a a that
gives you an idea of how how we went
from having this Web wustl centric view
of web services to going back to saying
well really it cannot be made to work
because if we try to push it too hard he
doesn't it doesn't hold up and then you
have to go back to saying it's more
about so so there's a new version of dub
you Sir coming out called WTO final yes
right so it same things so I actually
let me answer a little bit and then I
have some slides about that so rest all
let's just look at that of XML over HTTP
right without so the the difference
basically is that if you if you don't
the value of soap comes in if you have
something beyond the message that you
need to send so if I want to sign a part
of the message right I can't do that
with rest I need some additional on
without structure to say this is the
message and this is my signature right I
have to keep that somewhere else and if
you don't have any of that stop rest is
good enough you don't need anything else
so as you go forward you'll see in
access to that's a model with support so
the program model is purely at the
message payload level basically with a
with a you need web services or not it's
a passion of the kind of qualities of
service unit right we come back to that
with wh 0 point 0 is easy is a new
version of the spec that's kind of
fundamentally different from w11 it's
been it's robbie 3c version it's going
to it's basically done now it's going
through interop testing the fundamental
difference is that it has eliminated the
message concept and and gone to saying
well actually the thing that matters is
well it's replaced a message with an XML
element so it uses an XML element as the
abstract description of an entire
message now in order to make this work
you have to deal with with first of all
this makes a common case of sending a
bit of XML back and forth extremely
simple to describe because it just says
this particular message exchange has
this XML element going in this XML
element coming out and you want to send
it over HTTP just says drop the XML as
the body of the payload of a post and
you get that in the response and that's
it so you don't have to say anything it
just sort of works same thing for soap
with the simple soap binding you just
means take the XML element drop it
inside the soap body right and and on
the response here live around its inside
the soap body come in order to make this
work though you need one other bit of
information which is that XML has this
issue that you cannot have non xml
content in the middle of an XML document
so so XML element as the abstraction of
a message works nicely as long as the
whole world is XML but often you want to
be able to
an image for example right you want to
attach an image as part of the message
and send it somewhere else in order to
do that the only solution in XML is to
represent it as as base64 and embedded
in the middle of the XML document and of
course basics before is inefficient to
do that so what so to solve that there
was something called xop &amp;amp; M Tom now
that was created so let me explain what
those are EXO P stands for these are w3c
standards by the way exops chance for
xml optimized packaging which basically
addresses the problem of having non xml
stuff in xml using a trick in the xml
infoset so XML infoset is the
information model of XML that means it's
that it's the abstract description of
what an XML document represents
basically now it turns out the
restriction that you cannot have binary
characters in the middle of an XML
document is the restriction in the xml
serialization that is if you look at the
angle brackets but XML means the angle
brackets XML infoset means a tree data
model that represents what the angle
brackets contain and at the tree data
model level there's absolutely nothing
which constrains you from having any
kind of characters in in a node of the
tree right so what xml optimized
packaging does is basically use that
approach to say look at the abstract
level at the data model level there is
no problem you can have non xml stuff ok
so and then when you want to put it back
down to the wire and print it out as XML
characters with the angle brackets then
you have a problem because you cannot
put it out there because it doesn't it
doesn't allow you to put it so if you
take an info set that has non XML
characters in it when you serialize it
into XML you have to put it out with
base 64 stuff ok and then well of course
the problem is basic c4 is it's
inefficient it you get the 33 person
overhead and so on so there was another
speck unit is called message
transmission optimization mechanism
which uses mine basically said if you
have a XML document which has these
binary infoset items in it and if you
not see realize it if you have the
option of going into mine that binary
attachment becomes a mind part mime
attachment and then that element gets
replaced with the reference to that mine
part right so if you're going over a
transport that sends mime in binary like
HTTP that works great
if you're doing it over some TP it
doesn't do anything because the mind
becomes base64 again anyway right so so
it works nicely for HTTP to deal with
the non xml content in an XML document
so really that's what makes it work
that's what I loves wlcm to appoint
orders say the the entire message that
we are sending is a single xml element
and now i can package it all together
and send it out so what does that mean
what this means is that the the concept
of attachment is no longer a problem and
and they are essentially built into XML
wsdl and so right and and that's really
important because what that does is the
earlier if you go back to the soap 11
world and soap with attachments which
are suspect that describe how you send
attachments if you want to digitally
sign the the message that's going you
couldn't sign the attachment if you want
to sign the attachment i do SS mine
basically right there was no single
security model that covered both with
this approach because logically the
attachment is part of the same
information model what you sign is that
extended infoset basically and then when
you sign that one is to put the
signature as a soap error when you
serialize it to send the message over
there you might end up taking that
binary content putting it as base64 or
take the binary content signal as an
attachment but it doesn't matter it ends
up on the other side when you recover it
you get the same model back check the
signature and it works all right so this
this makes it makes it basically that
the concept of attachment has
essentially gone away it's now part of
the data model of the message and it's
very easy to manage that and it works
completely consistent here yes there are
couples first of all you can also do the
same forest right so the same because
these are an XML even set it up into it
so all right so you can do it for rest
which is the same thing there's a whole
bunch of binary serialization that
people are defined which essentially is
Rob using mine just takes a binary info
set in the middle of it so right so
binary serialization is a is a non
standard approach yet so if we are
talking to each other amusing by nurses
in wheels in central using a private
protocol there is a working group that's
defining a binary serialization it's not
done yet it's going to take a couple of
Moya's
so Web Services is not just about the
soap level there's a whole bunch of
stuff that's being built on top of it so
let me kind of explain I'm not going to
go my girl go through all these facts
i'm just going to give you a little bit
understanding of what what they are and
why they exist so web services messages
are described are basically soap
envelopes that you send back and forth
and they can be carried over all kinds
of transport HTTP SMTP XMPP whatever
there's no restriction on what you can
carry it over w is addressing
essentially plays a role that the
message headers do in an email message
if you look at an email message the
message headers as a set of standard
message headers like from to subject
reply to and so forth I this all
standard is part of RFC 822 basically
saying this is the the headers that must
be there so didn't define those headers
SS addressing define sorcerers those are
essentially so pedals saying this is
where the message is coming from this is
where the message is going to there's
the subject of the message and so on
then on top of this base infrastructure
there is there is a there are three
broad categories of features that have
been built one for security one for
reliability we are the one for
transactions so for security there is
something called ws-security which is
uses the spec call xml security and
extend it to fit it on top of soap to to
be able to encrypt and sign xml messages
soap messages basically so you can sign
a part of it you can encrypt a part of
it and then do all kinds of stuff like
that and and then that's basically
public key encryption there's something
called W secure conversation which does
what ssl does basically which is insert
being public key every single time we
establish a context and then drop down
to a more efficient encryption mechanism
and then there's something called WS
trust which is sort of like Cobra so you
have a trust server you can get it you
go authenticate with it both parties
trusted and you can send the ticket over
the other side it authenticates and the
message goes through so essentially a
full security stack available on this
infrastructure reliability there's
something called Douglas reliable
messaging which implements a protocol
that guarantees delivery so there are
different kinds of delivery gonna treat
delivery assurances so you can have one
saying if I send a message from A to B
it should be it should be send exactly
once and in order and then then certain
protocol messages that go back and forth
to make sure that the message actually
gets to the good ones and delivered in
order to the other side then there's a
set of transactional protocol said I've
been defined atomic transaction that
this is agreement becoming transaction
is a this basically two-phase commit and
it's not something people will do over a
wide area network it's used primarily to
carry a transaction between a.net
platform energy to a platform for
example if you want a more transaction
between the two of them this is a way of
doing it then something called business
activity which is a loose couple
transactional model it's essentially a
coordination protocol that lets you have
many parties that are involved with some
sort of distributed wide area
interaction be able to coordinate and
come to a single agreement on on on the
on the activity now on the metadata side
wustl solves a problem of basic cells
description it tells you this is a
format of the message that I'm going to
send you this part of the message you
must send me what it doesn't tell you is
if you're coming from Microsoft your
messages must be signed and must be
using this kind of algorithm or it must
so there are no policies basically so
it's another spectacle WS policy which
is a framework for how you will assert
into each message into each interaction
what the what the business protocol must
be right where they must send those
reliably with you in the middle of a
transaction with the transaction is
required whether it's optional all of
this kind of stuff so essentially enough
to so this is similar to what if you
look at j2ee and look at the the the
policies render it's sort of similar to
that in terms of what you get out of it
business process execution language is a
is a service composition and workflow
language what that allows you to do is
to say there's a service here and
there's another service here I'm going
to put them together and create a new
service and publish a new service so it
allows me to compose a set of services
and to publish new services basically
and metadata exchange is a way of
querying an endpoint and saying what
what do you what do you have what are
your policy is what is what is your
service description and things like that
so taken together all of this stuff lets
you essentially do anything that you do
with the current enterprise middleware
basically so if you look at what j2ee
does I look
what Ned infrastructure does there's
enough stuff in here to cover all of
their functionality now do you always
need this absolutely not right if you're
doing something over the web and the
other end of the consumer application
you don't need any of this stuff but if
you need a more reliable interaction if
you want it to be secured at a higher
level of granularity than just saying
transport level security you know send
it over SSL then you need to have some
infrastructure saying I need to be able
to sign a message and hang on to the
signature and send it off with the
message when you get to that level you
absolutely need either soap or something
like so because you need to have some
envelopes structure to say this is the
message and is a signature that's
essentially where soap comes in there is
a ongoing battle in the world about rest
versus web services it's interesting
within within enterprise structures this
battle doesn't appear to be there
because we play sort of settled on
saying I need all this extra overhead
that in order to need to get reliability
and transactions and security and so
forth so first of all rest is not
something new rest is what what is the
underlying structure of the web and it's
been around for 15 years and it's been
it's working really well of course what
web services the the ws starts tagged us
is define a set of protocols using the
web as a medium of communication not not
building not exploiting wall of the web
but using sort of part of the web to
allow people to communicate with this
additional qualities of service so in my
mind the battle of restaurants web
service is the wrong one because it's
solving different problems the use of
web services is to create what are
called service-oriented architectures
but the design point is that there are
services and I'm going to invoke
services and go discover services and
and so on the web is not a
service-oriented platform web is a
resource oriented platform the web there
are no services there are resources now
this I'm sort of look at the pure web
right when you take web with cookies and
web it with with with queries that going
with gets and so forth it's a little bit
fuzzy because it's not really what the
web is supposed to be in theory in a
resource oriented architecture the you
can build distributed systems with
either of these approaches which we will
run at the results or a resource
oriented architecture what
end up with what you have to implement
the design is fundamentally different
from what we end up with as a service
oriented architecture and and so the
reality is that there is a sort of
battle saying one is better than the
other and it's really unnecessary battle
because it's not that one is better than
the other depending on the kind of
system that you're trying to build
resourcer and architecture is a better
model and in father's things service or
architecture is a better model the web
itself which is essentially information
distribution system research education
works absolutely well but for certain
other kinds of integration scenarios
where you're talking from one program to
another program that's not necessarily
the one that works very good so so
there's sort of a this is an ongoing
battle but but it's something that you
know in the next few years will get I
think more clarity on when one should be
using one style versus the other side
there's another aspect of this battle
which is interesting which is the idea
of plain ol XML vs 0 which is a question
that you were asking earlier the
question is when do you need so
basically it's a bottom line question if
you look at soap soap is basically a
envelope structure which says there's an
element called header which contains any
number of XML elements which are header
elements animal called body which
contains one special element which is
the body and then and that's pretty much
it and there's some rules about how you
process the headers and software that
but basics hope is pretty much that so
if there are no headers so gives you
absolutely nothing other than two
element wrappers right so if your
message that if the message you're
sending basically doesn't have any soap
headers then the soap envelope is
exactly the same as taking the XML
pillow that you want to send wrapping it
twice and sending it over there all
right so it gives you nothing at that
point so the point is if you don't need
any of the other qualities of service
that you get by using soap such as the
ability to sign a message or such as the
ability to use real ability to deliver
the message using soap doesn't buy you
anything and that's really what W to
appoint no design point has been to say
the thing that matters in the message is
this the payload is the XML information
that you're trying to send so that's why
it is obvious to a pie no description
the body is is this XML basically is the
thing that
describing as a data that you're sending
is the payload just at XML bit okay and
I'm finding this out because this is
sort of a the design point of access to
as well access to a design point is very
much that the thing that matters is this
payload whether you carried over so poor
you carried over a payroll XML it
doesn't really matter from the
programming model perspective and I'll
get back to that in second all right so
so this is another another one of these
religious battles that happen on the web
in the blogsphere saying you know rest
is a pox is the right solution or soap
is the right solution and the answer is
neither is the right solution depends on
what you want if you don't need anything
beyond just sending the payload XML you
don't need so it doesn't buy you
anything at all at the point advises
something when you have something extra
to send w 2 pi know defines a very nice
as GDP binding if you haven't looked at
that it's really interesting what it
defines is basically how you take an
abstract xml schema and map it into a
uri to do a get so it takes basically
takes the child elements of the scheme
and makes them into either path elements
or query credit parameters the oil can
map it into a posts where part of it
goes into the URL part of it goes into
the pillow and same thing for / and
delete and so what this allows basically
is to support Fox bindings over HTTP
very nicely so essentially you can
describe any web form using the ablation
to point o and say this is the data
model that that needs to be sent and
here's how it should be sent over there
should be this part goes in as part of a
path information part item in the URL
part of it is a query parameter and part
of it is payroll right it doesn't deal
with right now it doesn't deal with the
the the attachment stuff but actually
with a very small extension which we're
working on we will be able to deal with
that so essentially you can have a xml
message which has an attachment then
when you do it over 10 or XML binding
you'll do a post and have a mind part
basically yes
doesn't exist in the service packs
that's the whole point that's a flaw of
the software i'll get back to its
excellent question all right that's my
next next topic is this sort of the
evolution of the software with this
evolution of thinking now again going
back I'm one of the people who started
this job so I wrote the first object at
that point it was all about taking Java
and serializing in and out of XML axis
one very much followed that and then
that's 2001 2002 time frame every web
service check done at that time frame
was done like that right the new stuff
that is very very different stop so
let's look at sort of the history of
Apache web services stop apache soap was
the first soap implementation we did it
basically while doing the spec as an
implementation to prove and to make sure
everything was working right and was
released right after right with the spec
and essentially it took I took the model
that the way you implement a web service
by writing a Java class and that's been
an amazing mistake because today to date
everybody implements a service by
writing a single Java class and really
that or a class in whatever language and
that's completely under the complete
disconnect between those two things the
lifecycle of a class the lifecycle of
service are have nothing whatsoever to
do with each other there's no concept of
instance in a service so so much of
disconnect between what a a
object-oriented implementation
methodology is Anna service
implementation is and unfortunately
going back to the original
implementation because it was done that
with basically every implementation has
follow that model and now everybody
expects that if you don't have a switch
to drop a Java class and make it into a
web service and your stack doesn't work
because that's how it should be there's
really not and the reason it shouldn't
be because he is is that web services
are not about synchronous invocation and
getting a response back with the
blocking thing right java classes are
fundamentally in any object and language
a method invocation is a synchronous
method call and it's not a model where
you have a some some message going into
some running system it does something it
may be some time later it will send a
message back and so on and then and so
that's really been a bit of a mess right
from the beginning apache soap only
dealt with the soap body it ignored
basically everything else
it was very much a quick implementation
and it's still used in production by
various people unfortunately patchy axis
was about a year and a half later we
decided to rewrite it because he didn't
deal with headers there was no
convenient way to write handlers that
let you play on with various setters and
this is when different protocols like a
level messaging was starting to come out
so we came up with this concept of
handlers which is now pretty much
standard the.net infrastructure has it
all the jax-ws jax-rpc all these guys
have it and it switched from Dom to sex
to get slightly better performance and
access to was extremely widely used and
in still by Lewis is pretty much in
every application server in various
forms some of the key characteristics of
access to the the co of the system had
the mindset that the XML has to be
converted to Java so in in the in the
guts of the system there is his concept
of data mapping basically or for type
mapping going from XML types into Java
types and having the ability to convert
that before getting out of the system
and also it assumes the synchronous
response modalities the execution path
was you get a message coming in
something happens message goes out right
it was always just request response
pattern again now if you understand the
specs you know that's not the case it's
really there is no such concept that the
message level it's just one where
messages so access to was something we
started in 2004 and essentially kind of
broke all of those fundamental models
and says the thing that matters is
really just the XML there is no concept
or data binding at all in the web
service track and what you need is a
one-way message processor so it's simply
an XML pipeline so you view you get a
message coming in one way or the other
and it lets you put filters to mess
around with the headers or whatever you
want in the middle and then the message
gets delivered to the application and
it's done all right and and because the
programming model is dealing only at the
payload it natively supports both box
and so by design because all it cares is
basically at the payload gives a pillow
to the application yes set some context
if you want to find out whether our
headers with you and we'll have a soap
envelope or just box you can figure that
out the way it's built is using
something called axiom access object
model so what we do is the following
when a message comes in
we create so everything is built using
stacks is something called streaming it
therefore api for xml and that's a java
api and this similar one we were written
for see what so it's a pool api
basically for reading xml so when a
message comes in we start reading the
the envelope and read off enough to get
the headers now if it was a box message
right player or xml message there are no
headers basically and then then you
don't read the rest of the stop so you
build using the bit that you read you
build an X XML information model and you
create a essential you leave it unfilled
right so it's a deferred built model and
then pass it through and then once it's
built and and and then the header
processing happens so if there's a
reliable messaging stuff it might do
something with it if the security it
might read the rest of the message and
so on and eventually it goes out the end
and gets to the application at that
point you can go and say actually I want
to now read the the underlying cool
stream pull the thing and if the tree
hasn't yet been built it's going to be
pulling right off the stream basically
right so it's it's a pull-through
differed built model okay and what that
allows you to do is you get very high
performance because you don't have to
build the XML information model and then
pass it on to the application because
many applications do still want to do
data binding but we do it outside of the
co of the engine so we do support it
because program has wanted but it's done
outside the core so when you do data
binding what we do is we don't
essentially we don't take the heat of
generating an XML model and then
converting it out to a Java model right
we keep it in the stream and then pull
it right through into the application so
yeah so basically you build it up to up
to the point of the end of the header
because we process all the headers that
sort of rules or so processing you have
to do that and then whatever the data
that's say we just give it to the
application and it just pulls it through
the way it wants to pull it so the wrong
time model of access to is that a
message comes through in some kind of a
transport listen it could be HTTP could
be XMPP could be whatever you want and
then it gets massive map to something
called a message context which contains
in it a logical soap infoset now I say
logical because the way we represent a
message in the system in axis is always
this open for set whether it's a plain
old XML message or whether it's a JSON
representation or whatever so we map
everything into
is open for said now in some cases the
fictitious open Fassett because there
was no soap at all it was just a plain
ol xml message but we do this so that
every handler can perform the same way
everybody gets the same data model in
the rest of the chain basically and then
the real data may have might have been a
planar likes ml thing or might have been
a JSON representation and so on and then
once the message has been brought into
this structure the engine applies
whatever the policy handlers that I've
been there maybe there were security
maybe there was some transaction policy
whatever that's basically and then
message gets delivered to something
called a message receiver which is at
the point at which we get out of the
engine week context which to use a code
and then it does whatever it wants so
the concept of data binding is not in
the core but yet we have to support it
because programmers don't want to deal
with XML and the primary reason for that
is dealing with XML in Java especially
is absolutely crappy the Java API spur
XML really are not or nice to work with
if you affinity for X if uruk's has a
much nicer model and it bhp for example
as a nice model and so on so what we've
done is basically once you get to the
message receiver when you're out of the
system if the user wants it databound
then we will at that point map it from
the XML infrastructure into into a Java
class whatever they have asked us to do
and then hand it over to the application
and typically this code is actually
generated at development time using the
schemas that you have in hand all right
so that makes it very efficient there's
no reflection in water all in executing
it so we support different kinds of
service implementation types that is the
actual logic that the person it writes
can be written as a POJO just as a
regular Java class can be written as a
spring description that that that gets
executed within the spring context so
that you can pump it on to the
appropriate bean that you describe can
be generated classes that we've
generated for you or it can be supplied
directly deals with the XML which is
sort of our preferred way because the
most efficient is the most direct route
but it takes a little bit more work
because XML programming in Java is a
pain basically and and then you can do
whatever you want so for example if you
are tie this into a BPL process a
workflow process you would take that XML
message and pump it right into the
workflow engine as an XML document
because that's what it's going to be
dealing with an
navigate with expert and so forth now on
top of this Cove we have a set of
modules that we've written the modules
are extensions of the of the co system
which implement various handlers
remember I said there are these handlers
that you drop in now what these handlers
do is implement various protocols so we
have implementations of security secur
conversation trust all of these things
basically and these are just our own
modules so you have the access to system
and these get packages something called
a ma module archive and once you drop
that in it picks it up and it inserts
handlers into the execution chain at the
right place so there's a small
constraint language saying which which
handlers go in front which I will go
after relative to the others and so on
and then then the execution chain get
set up and messages come through they
get pumped through that and execute it
and dropped at the other end to the
message receiver now we are not
implementing this stuff only in c we're
also doing a job or other we also doing
a see implementation it's exactly the
same architecture we started this little
bit later and if you guys write in C you
know that it's a little bit more work to
write in C so it's lagging a bit behind
in functionality but it's very carefully
designed to be highly embeddable so we
are working on embeddings into PHP Perl
Python Ruby Firefox ie and and also
meant for different devices so let me
try this back a little bit into what I
do so the company that I set up w so too
is the one who is driving most of this
work they all apache open source
projects so they are not our projects by
any means but we are the ones who
contribute to most of the projects in
most most amount of work basically so
the thing we do is of the 0 is take this
Apache components and kind of tie them
all together into into a product form
and the reason you need to do that is
because access to is a separate project
foundation separate project rampart a
separate project so if you want to do it
yourself you have to download all these
different bits get the right versions
that work with each other and sync them
up so that's what the web services
framework that we put out is basically a
packaging of all of that stuff as well
as language bindings so we've already
released a first version of the PHP
binding we have a extension that extends
c5 we have an XP I that extends the the
JavaScript program model for Ajax with
with full web service capability and we
work out same thing for IE we have
something called WS client we're doing
which is essentially to find a double
get in Linux it's like W get except that
it can do full that service invocation
and it's just a command-line script
basically a command line program that
you run on the show and we're doing a
swig binding and through that we expect
to do pearl and also Ruby and so forth
so access to is really only the
beginning of the of this stack of web
service stuff that we're trying to build
it's a core of essentially what becomes
an application server the access to
engine becomes the guts of an
application server so we have something
called a wso2 web service application
server which is which is a packaging
that takes access to in the gut the
whole and then wraps a runtime
environment so that you can open up
different listeners and send messages to
it and it runs as a server basically
right so it's an alternative to a j2ee
application server we are also working
on other products on top of that
something called synapse which is an ESB
basically synapse is something that
allows you to take messages that are
flowing between two parties stick its
nose in the middle pull the message out
we already do some transformations and
do whatever logging and manage with
stuff that you want to do so it's
essentially a small rule-based language
that you write in synapse saying this is
what I want to do the message is flowing
through and it pulls them out execute
the roads and then passes the message
through access to now I only talked
about XML messages and XML protocols so
now i'ma tied back to the the the
evasive stuff that I'd mentioned about
multi-protocol stuff in fact access to
can deal with that because what what
missive depended on was the wsdl 1.1
data model of a message and it had
something called basic message which
represented that access two runs on the
WHL coupon or data model which is that a
message is an XML element and because of
zop and an M Tom the XO P&amp;amp;M Tom stop you
can actually bring any kind of data
model into that and make it work very
efficiently so it is possible to bind
access to do all the visit protocols I
have a grad student who's were doing a
masters with me who's actually done that
we are just in the process of getting
the code out into access to right now ok
so let me just wrap up quickly by
mentioning couple of our comparison
there are other subjects out there is
something called xfire which is quite
popular it's a very nice hope engine but
it's it's real
very Java centric it's designed
primarily for the problem that cake XML
map it into Java execute with a Java
code and if that's a problem you want to
solve it's a wonderful lightweight
system but it doesn't really deal
cleanly with other web service protocols
it really cannot be made to work
properly like that and and the project
has been there ended its been combined
with something called Celtics to form
this new project called CX F which is
currently under incubation and what's
the except this is basically it's quite
different from x5c accept data model is
that the world consists of either XML or
some other stuff and so on so the
message model is in access to its
completely an XML data model in C except
there is a sort of a union of things
that you could have there if you're
firming it something called jbig our
business integration this is sort of
like JB I but an improved version of JB
a model basically it still uses Dom for
the examiner infra set model and doesn't
end and when you comes to when it comes
to attachments they don't have a model
that sort of represents attachments as
part of the information model so they
kind of drop down and bring it back out
basically they they follow a lot of
stuff that we've done in access to so we
consider that a form of flattery at this
point and it's it's it's very new so
it's hard to compare performance at this
point because they are not done yet ok
let me wrap up i follow this running a
bit late here so fundamentally the
thinking behind web services when we
started this stuff was very much web
service is all about XML all about doing
RPC calls / XML and at the end that
they've all about being in a wsdl level
which is at this abstract description
that you could bind to rmi cause to java
method calls to do xml calls basically
but that has changed over time as
hopefully you saw by the evolution of
the specs and the implementations now
the thinking very much is a web services
are basically about carrying XML
messages from one place to another place
and how they and then then the the the
anything else gets mapped onto onto that
abstraction not something else basically
so that's essentially what access to is
doing kind of
rethinking the whole stack along those
lines so what we are implementing is a
very XML centric processing architecture
in Java and C with with both men to be
plugged into all kinds of different
languages and we are certainly doing
that and we would welcome help in doing
that for more languages right now it's
pretty much a faster soap engine and
there's a hell of a lot of performance
left we haven't we've only done very
little bit of tuning we know so many
different ways in which they can make it
better perform better including with
optima optimized passes that are so /
where and can deal with it much more I
intention is to bring the excessive
stack to perform at the same level or
better the Java RMI performs so that the
the use of web services versus not
should performance gets taken out of
that angle right it becomes other
decisions not performance and we
certainly believe we can do that and the
c1 we expect to be able to beat pretty
much anything because there's absolutely
no reason why the sea implementation
doesn't perform as fast as any any sea
bass mrs. model okay I think I'm done
thank you very much any other questions
I'll be happy to take it
right thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>