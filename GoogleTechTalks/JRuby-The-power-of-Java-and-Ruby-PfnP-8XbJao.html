<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JRuby: The power of Java and Ruby | Coder Coacher - Coaching Coders</title><meta content="JRuby: The power of Java and Ruby - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JRuby: The power of Java and Ruby</b></h2><h5 class="post__date">2008-03-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PfnP-8XbJao" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we have our Ruby series continuing we
had Matt's last week and now we go over
to the the Java side
the Ruby house and Matt's kinda said a
little bit in his talk last time how is
a bit of a bittersweet taste with JRuby
being a little bit faster than than he's
interpreter and so now we get to hear
from one of the guys that made a big
difference to give us those performance
improvements so let's give a hand hola
thank you
it's wonderful to be here I actually
haven't been turned down them SFO in
this area before so coming down to
Google and see all the stuff and feel
the vibe here is it's nice
so yes JRuby what why now it's actually
I mean I have lots of slides but I'm
gonna keep it kind of open so if anyone
has any questions anything you want me
to expand more on just feel free to say
so and I'm sure we can accommodate that
I am from Sweden so if you're wondering
where my accent is from that is it I am
a programming language nerd I'm not an
educated one I'm just dabbling in them
I've been DJ would-be core developer
where one of the day before developers
for two years and spent two and a half
years trying to make sure would be one
of the best Ruby implementation
available I'm happy to be the author of
practical JRuby on Rails - it's the only
book on JRuby right now so if you're
interested in JRuby and JRuby on Rails
yeah that's the choice you have I'm not
endorsing it I'm just saying so I'm
gonna talk a little bit about Java
versus Ruby first of all I am sure all
of you are kind of familiar with a
little bit actually I'm not sure Ruby
how many people are familiar would you
be ok so this is good so this is not
gonna come as a surprise I'm gonna focus
on a few of the aspects that make Ruby a
different language and different and
more useful for other problem domains
that they're where Java might not
actually be so well suited I'm going to
talk about JRuby obviously how to get
started some problems with Ruby that
actually JRuby Souls and I'm gonna take
a look at the implementation and that's
where the real language geekery comes in
and I'm gonna end up looking at some
cool things possibly some rails
possibly not some rails depending on
people being tired of hearing about
Rails all the time and some plenty of
room for Q&amp;amp;A so let's start with my
first demonstration and this is actually
I usually do this live coding but I'm
not gonna do it this time so you'll have
to bear with me having a pre canned
example for this one so I have this code
here it's it's about a screen full of
really readable code right so I'm
wondering what's the actual purpose of
this code where is the business logic I
can describe what this code does unless
characteristic to compile in Java I can
actually describe it as saying create a
list of these names I want to sort it by
length and then I want to print them out
separated by a comma I don't know how
many syllables that is but I'm sure I'm
around the main statement if I if I kind
of did a count so let me just for
comparison okay not normal so this is
the rubic finland's now here we're
actually talking about the same length
of code for what I said there are lots
of things that we tell the Java compiler
that we shouldn't really tell if we tell
it for once we tell it two times that we
need to do as a list of string but it's
kind of annoying here we don't really
care what the list is of because we know
that we're just sending in strings we
are sorting by length and we are joining
them by a comma and then we are printing
them if you have Ruby 1/9 of support is
extensions you can actually just say
sort by length and we don't need to even
have this this implicit this a variable
called name here to make that example so
that was just a very short comparison
and I'm gonna come back to that later on
so the thing is there are a few things
that are extremely verbose in Java the
base language is verbose and you don't
really have that many things that can
help you to abstract things so Ruby you
have blocks blocks help you to abstract
things quite
heavily actually because you have real
closures you have modules that can
access mixes that means that you can
actually share behavior shared behavior
that doesn't really depend on
implementation you can still have a
shared implementation for stuff that
just depends on something something it
doesn't really matter and then you have
the metaprogramming well ok
metaprogramming which is really useful
if you really want to compress things
for real I happen to be one of those
Lisp guys who prefer Common Lisp real
style macros compressibility and
readability doesn't really have to go in
opposite directions I believe that with
Ruby's meta programming facilities you
can create small languages that are
extremely readable but still expresses
exactly the business intent of your code
and nothing else and it can actually
expand into something that is a really
good implementation that gives you all
the secondary things that you actually
need from a business implementation
there are at the end of the day there
are more means of abstraction and that
is really what matters the more ways you
can abstract something the more choices
you have to make your implementation
readable understandable maintainable so
I mentioned verbosity that is one of the
things Ruby also it's not a malleable
language no sorry Java it's not a
malleable language you can't really
change the way anything works just take
a typical example Ruby you can leave off
the parentheses on a method call that
means that you can choose which looks
great which looks better if you want to
do a DSL you usually end up not having
parenthesis so you can do something that
is readable in a different way also the
malleability of the language makes it
easier to have a quick turnaround you
have an agile way of working where you
can actually change the application in
real time while the customer is sitting
by your side you decide you can change
it and you can accomplish things without
actually having to do a long compile
cycle and so on of course you have all
that stuff with a test cycle in Ruby too
but to actually just spike functionality
you can do it faster and DSL
well you can say lots about DSL they are
one of the hype words right now I would
say and Ruby is better at it than Java I
would say it would be very hard to write
a domain-specific language inside of
Java you would actually have to just go
outside and use a Parsi and rach or
something like that ruby is also full of
innovation right now I pointed rails as
an example of the innovation that can
happen if a language frees you to
actually don't care about things that
doesn't matter when you're doing
something when you want to do when you
want to do exploratory programming for
example you don't really care about the
types of your list you just want to have
a list of something that you can shove
things in take things out of constraints
into some way etc and that kind of
exploratory programming ends up being
really hard in Java of course you can
start out in Ruby and then transform
into Java but that kind of programming
is really when you have invested lots of
amount of time in exploring and
implementation with Ruby most programs
doesn't really feel comfortable
translating this into Java and see the
source code explode with type tags so it
doesn't end up happening that much but
we're seeing that rails for example has
a real effect on programming language
environments outside of the Ruby world
we're seeing that Java frameworks is
actually taking up the learnings from
rails and putting them into the Java
world and this is happening in other
areas too you have stuff like testing
for example where r-spec is leading a
way of behavior driven development now
this started out with Jay behave which
quickly got turned into our behave and
our behave got merged into r-spec and
this is where all the new stuff is
actually happening so it's to me it's a
matter of language power in some
situations Java makes sense in some
other situations Ruby makes sense and
the important thing is to actually
choose which is which so Jay will be is
an implementation of the Ruby language
it runs on top of the JVM it's wonderful
compatible in the current trunk we have
a one now release that we are
maintaining that is one for compatible
you can also use retro vive to get one
or compatibility of JRuby it's fully
open source you can choose which slices
you want to use you can use GPL Cpl and
yeah some bsd-like license so it's kind
of free one of the things that I end up
saying every time I stand here talking
about Jeremy is that Jeremy can be a
little bit boring because it's really
true be it works exactly like Ruby it is
the Ruby language there is no difference
well there's slight differences but
differences are extremely small compared
to the fact that basically the whole
language is there it's compatible with
Ruby 186 we count compatibility
basically by doing lots of testing
against different testing frameworks and
specifications that exist and we also
basically just run application framework
so when rails in r-spec and a few other
of the most complicated Ruby systems out
there actually work flawlessly that
means that we are compatible our current
release is one at one rc2 we are
planning on having an RC 3 out this week
or this weekend hopefully if I get the
time to pitch in it might actually
happen we do have the 100 branch I
mentioned it's kind of falling behind
though because we can't really back
porch I'm going to some one more cool
stuff we've been adding in a 1-1 branch
so we are probably going to continue
doing bug fixes but if you want to be
actually getting 2 full Ruby treatment
Jeremy 101 is going to be that the
product is old it actually started in
2001 and we've had lots of different
developers to current old as long as
developers Tom anybo he's been around in
a project for four years I joined two
and a half years ago and well that is
really it we've had lots of people just
going into the community and get then
going out of it right now we have eight
core developers 4050 contributors
something and we have spikes so every
time we do a release we get a new batch
of contributors that kind of get the
numbers up and we have actually had some
interesting development happening some
outstanding contributions marcin one of
our one of our core developers this fall
he actually ported the full-on yoga room
regular expression engine
and on a guru my is the expression and
unit lies behind regular expressions in
Ruby 1:9 it's very large I think it's
the C implementation is around 120,000
lines of C code and this is a full Java
porch it just as a side effect it
actually ends up being the fastest
regular expression engine available on
the Java platform right now so things
like this kind of end up happening as a
side side results of doing a good Ruby
implementation it's really really really
really simple to get started with you if
you want to try it out you download the
distribution you at that point you
actually get the Ruby standard library
you get ruby gems to react rake you
unpack it and you add the binaries to
the path they've been direct you should
have and then you can just go on using
it's using JRuby command you can use it
in several different directories as long
as you have one canonical Giroux command
that's fine you can install gems either
you can do gem install if you don't have
regular Ruby install you can do JRuby -
s gem install this will use the gem that
comes with JRuby and that's really it
for getting started and this is just an
example of how easy actually is with
Java 6 to call out to Ruby code from
Java you create a new script and your
manager you get that engine one name and
then you evaluate the code and what you
get back here is actually the result you
what you will give back here is an
unwrap nil object because that's
actually returns nil so it won't get any
interesting from from this evaluation
but you can imagine actually doing some
say for example you can imagine creating
an interface implementation in
implemented in Ruby that you return from
this evaluation and use in your code in
general using JRuby is easier if you let
the Ruby layer drive the Java layer you
can do it this way but the easiest way
is actually running it from the JRuby
side so a small demonstration of
interactive Ruby so how many yeah of
course all of the people who actually
put up their hand saying they know Ruby
have used interactive Ruby right so I'm
gonna show you the JRuby flavor of
interactive Ruby so I'm just gonna
resize this a little bit because I
happen to know that this is gonna be so
that's it's this readable okay good so
let's see sometimes this command takes
some age to start because the Java
loading of all these stuff cold loading
on the Mac has a tendency to be a little
bit slow than it should be it's just the
first time though so this is IRB running
in JRuby so it's just one that one
prints hello Google all the regular
stuff that you kind of expect would work
works but there's also this oops there's
also this that I can type wrong require
Java now requiring Java gives you access
to the the other component of system so
I can do a Java long system dot out dot
print line hello and this will work as
expected so this is the way I can
actually work with these classes
printing out stuff might not be useful I
keep around I keep around this console
because I find myself a little bit
frustrated by the Java Docs in some of
the security API for example so I keep
IRB around open so I can try things out
so I can for example I can get all the
algorithms
since the available algorithms is
different on all the systems in Java
this will always return different
results so in this case we get a few
different algorithms for message digests
now what I get back is a Java object
this is some Java array if you actually
look at implementation of Java security
security you'll see that this method
actually returns primitive string array
but I can use something like grep
to just find all the shower
implementations so in this case I'm
running something that is typically Ruby
the grep command on a Java array and we
have all these kinds of integrations
that help us do that stuff so I can
manipulate data from Java as if it was
Ruby data I can create a new Java util
hash map dot new if I want to I can say
okay at the index flow I want to have
world there okay so age can still see in
this funky syntax that this is still a
Java object this is still a Java util
hash map so all other stuff kind of
works and we've added lots of extensions
to the Java integration to make it
really really obvious how you can work
with stuff and in many cases if you use
two Ruby it just works if you use the
Java you will find more and more
shortcuts that kind of make sense so I
have a tendency to just as a typical
example of what you can do with a
dynamic language that allows you to
manipulate stuff at runtime this means
that I can create a new swing frame for
example and I can set the size to 400
times 400 and I can show that show that
and I got a frame that I started from a
nerection
interactive prompt but that's not really
it I can actually work with this one too
so I can create a new button each other
X dot swing J button right hello
well I need to come up with you examples
okay so I have a button that I added
dynamically okay so that's cool next
step would be to actually do something
so in this case and when I add an action
listener
so let's see if I typed everything right
okay so the button takes changed button
pressed
so I'm now executing Ruby code from a
callback from Reyes right inside of
swing and this just works notice that I
actually didn't implement any interface
to do this because the actual listener
interface has one method we can actually
curse a block to just do the same thing
as would have happened it kind of
understands that the interface needs to
be implemented and puts the block
implementation as the action of that
interface there are a few shortcuts like
this but if you wanted to you could have
just implemented interface create a new
Ruby class and create an instance of
that works too so this is the gist of
the Java integration from gob it kind of
the focus of it is that it should just
work one of the things that I really
like about Ruby is the whole principle
of least surprise and this is really
true for the Java integration stuff I
want I want to be able to just assume
that stuff works as I expect him to do
and that's kind of the guiding
principles we were using yes it's
creating interface behind the scenes can
you still do the trick where you just
say define a function that is the
actionperformed method and then pass
that into the add action listener
that as well so if you had an interface
that had multiple methods on it you
could still just create anonymous
function dirty so that's an interesting
question so what I was just sorry not to
hijack anything this is exactly what I
told you to do right in the beginning a
talk so let's see so in this case I'm
not gonna actually well I'm gonna
require Java so the way I would do this
I would do it like say button action and
I would do that to be a proc that takes
an argument and then later on if if we
assume that I still had to be the B
button still available I could do B dot
add action listener button action now if
you know Ruby you know that the
ampersand is actually coercion to a
block actually occurs is a proc into
your block so I'm doing exactly the same
thing as I did the last time it's just
today kind of gets around it by saving
saving the block inside of a variable so
this is the way one of the ways I could
do it another way I could do it is
actually I could do java.awt event
action listener dot imply this is
something we've added which will create
an anonymous implementation of the
interface this anonymous implementation
is kind of created using dynamic proxies
and the way it will work is you can use
it on either interfaces with just one
method like action listener in that case
actually it's no difference you can use
it on any interface and you will get
back an anonymous class every method on
that interface will invoke this block
the name of the method invoked will be
the first parameter which is down the
score here because I don't care about
that since I want to do the same thing
on all of them so this is the equivalent
of an anonymous implementation except
that this is actually implemented in
Ruby
so if you define a function in the
scripting environment then the current
you know IRB object this gets that
method so be a duck typing if you pass
this as the current interpreter like
main object into the method will be able
to duck type the method signature and
call it for any given interface
implementation know the question
actually happens just four blocks so you
would have to what you could do of
course you can use Ruby so you can
always do say if I wanted say P the or
putz to be called I could do method putz
and I think I can do to proc on that one
right yeah so I can call method puts and
to proc and then I could actually yeah
so I could just do but beat a add action
listener and I could do the ampersand
and then I could skip the to proc so
this would do the same thing this would
actually call puts and print out the
argument is that what you were asking or
did I misunderstand again okay so good
okay so let's see there was a okay so
that is kind of the interaction there as
I said the guiding lines is that the
Java interaction should just work now
this means that the Java interaction I
just show you swing class this I showed
you collection classes and stuff like
that it also means that more complicated
stuff works you can do this with eg B's
if you like that kind of thing you can
do it with jmx you can use it with you
know I don't want to get into all those
TAS but you know you can if you can
imagine in a Java TLA you can use this
with it it works so let's get back to
some of the issues that we're actually
trying to solve I mean the this were not
the rationale for creating material B
from the beginning but they are kind of
the guiding light for us to continue
working on the everyw because we've
believed that we actually solve problems
that have not been solved in Ruby 1/8
and Ruby 1
and we want to solve these problems
because they are kind of in a way of
really actually getting an attraction
really has some traction right now but
we at least in thought works we believe
that Ruben could get so much more
traction than it does right now and
these things are kind of in a way so we
have threading ruby a18 has green
threads that means that they don't scale
that means that when I run Ruby on this
lovely machine which has got two cores I
don't really get my full money's worth
C libraries can't won't yield and the
scheduler is kind of kind of basic in
Ruby 1-9 this is getting fixed by using
native threads but they still have the
global interpreter lock which means that
no native threads will run at the same
time so I will actually not have a
solution to this and as far as I
understand the global interpreter lock
is not going to go away because so many
extensions rely on the way the threading
features work there's no synchronization
no mutex is in any of the Ruby C code or
the C extension code and there are just
too many extensions to handle this
correctly we kind of faked this issue
out by not caring because we are using
Java threads as Ruby threads that means
that they are native they are parallel
and since all of the code in JRuby
is Java it means that we get the same
threading semantics for the Ruby
implementation as you would get from
Java so extensions need to okay so if
you've write an extension yeah you need
to synchronize the way you do in a Java
program and everyone is kind of used to
that when they write Java code so we
don't really need to do anything
specific to handle the problem Unicode
gets actually guess a solution in 1-9
it's kind of the full monty solution
meaning that not necessarily only
unicode or utf-8 but you actually get
all the any encoding you can imagine you
can actually use in Ruby 1:9 and all
different strings can have their own
encoding and they can kind of float
around in this same area and have fun
together that is very nice it's kind of
hippy we don't
oh that for so we use Javas unicode so
once that once again we fall back to the
Java platform it's it's just stuff that
we get for free for being on the Java
platform I'm going to talk about
performance a little bit more later but
suffice to say right now
Ruby 1/8 kind of the the motto is that
Ruby 1/8 is fast enough but it written
routinely finishes lost and there is no
real plans to improve this the
improvements in Ruby 1/9 is happening
I saw the talk that Matz gave last week
if I remember correctly he said there
were improvements on several benchmarks
from five to a hundred times in
performance but the general performance
improvements for applications were more
like 1.5 times so this is 1.5 times for
a new virtual machine there are other
things that aren't really sold by the
1/9 release for example you only have
the implicit ahead of time completion
that happens inside of the engine
there's no way of doing ahead of time
compilation and Dom about the bite cuz
there is no just-in-time compiler and so
on so I'll go back to JJ Abrams for to
this to this part later memory
management I actually I did a talk at
powerset yesterday the powerset is doing
some really cool stuff and my question
what's your main problem with Ruby and
their main problem was memory because
the interpreter kind of leaks it's got a
very very simple garbage collector and
it's not really it's not really fit for
use in large-scale environments right
right now because the design is simple
and it works for simple apps but yeah
and Ruby 1:9 is not going to change this
it's actually gonna worsen the situation
because improved performance means more
garbage which means that garbage
collection problems it's just gonna
explode in our faces when we try to use
it and yeah this this this question this
answer is actually getting a little bit
old because we've we just use Javas
garbage collector we have a few hundred
options that can tune it we have four or
five different algorithms
for the garbage collector in current
Java release and all of that works
happily with our code see is a lovely
language for writing operating systems
it doesn't really scale and it's got
some problems that makes it unsuited to
make extend create extensions in the
Ruby implementation you see lots of code
devoted threading and garbage collection
issues and so on and in JRuby well the
extensions are Java extensions so once
again no problems like that no explicit
garbage collecting handling the only
credit handling that is expressed at
this real synchronization we need to do
oh and then we have the political on you
want me to switch to watch this is gonna
improve later on in the game hopefully
with time but that's not really quick
enough to actually get real traction
there are also lots of Java applications
in the world and so many Java frameworks
it's kind of like I would say that the
Java libraries are definitely
approaching Perl Sipan in completeness
and comprehensiveness and I would say
that they are much better in stability
and quality than Perl C penis just
straight over the board so which is why
we're one of the reasons we're running
on top of Java implementation
credibility by association by just
running on top of Java it makes it
easier for us and we find that the
regular Ruby implantation actually have
an easier situation because we exist now
companies that wouldn't use Ruby are
actually switching to the regular Ruby
interpreter because they know they can
fall back on JRuby and proven Java
technology if they need to so it's kind
of a false thing that it doesn't really
solve anything for real but this is more
about perception and it's actually funny
we we have some real stories about where
this really helps us we did some work at
a large financial institution and most
of the people really really wanted to
really want it to have JRuby they really
want you to have real Ruby on Rails I
mean there were developers and they saw
the benefits of using rails in their
environment and
they couldn't the custom management
didn't really allow them to use another
language they were based on Java so what
actually ended up happening was that
they did it in JRuby on Rails they gave
it to the highest department they said
okay so here this is our application
it's this really large cool java
application it runs an application
service and have all these cool java
features and so on and oh we have this
long configuration file with it which is
one way of doing it it worked in this
situation and the management is happy so
then we have the performance performance
is usually well fast enough is good
that's a good answer
in many situations because performance
is it really all that important in most
cases but at the end of the day you will
end up in a situation where sometimes it
actually is important so our general
numbers right now JRuby one no in June
was actually two times slower and then
Ruby 186 the one that one beta one that
was about Java police time December that
was two times faster and current trunk
is about five times faster we're talking
about we are actually competing against
will be one nine instead of ruby one
eight in performance right now and we're
doing this with full compatibility of
the Ruby 1/8 language Ruby one nine one
of the reasons Ruby one-niners a stir
for many cases for many other benchmarks
is because they have removed features
that were hard to optimize so right now
we are actually going to stop working on
performance and concentrate on other
stuff for a while when we get back to
performance we are going to target you
all that performance we want to have
equivalent Java performance for
operations that are logically the same
I'm not sure we're going to get that
close to Java performance but we should
get in at least a magnitude one of the
questions people always ask is about IDE
support and these are the ideas that I
know about right now and that means an
FPS Ruby ID Eclipse rdt rad rails aptana
DLT k rail IntelliJ edit all of these
support
and those are the those are the ones
that you can count as IDs I don't count
Emacs and VI and textmate as IDs in this
manner because that's not what people
really want to know when you ask about
this
I happen to use Emacs only but that's me
IntelliJ is extremely interesting
actually because they have specific
JRuby support not only Ruby support but
they had JRuby support so when you
refactor something when you change the
name of a Java class or a Java method
IntelliJ will actually find your Ruby
code that uses that Java class and
refactor at that point too and back and
forth like that which is really cool
overall the regular Ruby refactorings in
fps seems to be really going well too I
couldn't do people who use them mmm yeah
all of these actually used JRuby parser
because there is no other complete
partial around and no one want to use
the C parser from a Java program right
so it's one of those nice side effects
of doing implementation people can end
up actually having a real Ruby person
like you use that I can integrate in the
Java ecosystems without shelling out to
another program so the parser right this
is the give part of the presentation the
implementation if you're interested in
stuff like this we have a handwritten
lecture it's kind of ported directly
from Ruby JRuby started out as being a
line by line port from the regular Ruby
interpreter in 2001 the lexer is
probably the part of JRuby that has
changed the least system well I do say
many changes system but many less change
system we have done to the rest of code
base we haven't really reflected this
part yet we would love to be able to
switch to antler and there are some
people getting really close with antler
Ruby grammars they're not close enough
and the problem right now is that all
the Anne telegram is we've looked at
happen to be more than twice as slow as
our parser and tend so I don't know why
that is and from the maintainability
perspective this is really I don't want
to touch that and
I mean our right now our parser actually
so we have a parser generator that is a
yak based it's it's an old Java program
called J it's jacked by some based it's
kind of a pain the ast is quite similar
to MRI we have kind of changed a few
things that were
implementation-dependent and then it
makes sense we have lots of core classes
most of the map is straight down from
Java classes to Ruby classes
string is Ruby string array is Ruby
array and we use annotations to point
out this it's kind of interesting if you
look at this because this stuff is
things that you need to know about a
ruby method from the implementation
perspective this is all we really need
to know this information is spread out
all over the MRI implementation in most
cases is not even verbalized it's just a
side effect of how the interpreter work
but we have actually put them here so we
can now allow the compiler in the
interpreter to use this information for
example we have the framing of scoping
which we in many cases don't need so
when we don't need it we can optimize
away from that if we don't need frame
and scope information we can omit the
whole stack framing we can just store
local variables in local Java variables
for example so that is kind of how our
source code looks we have lots of
implementations and we have an
annotation saying JRuby method we are
looking at adding a few other
annotations for documentation z' and
other purposes but those perfections
kind of go get a little left behind
after actual implementation of features
the interpreter is really easy it's a
switch based ase walker it recursos
most of the code actually starts out
interrupted except for command line
scripts that are compiled immediately
it's quite easy code actually if you
want to learn if you want to understand
what Ruby does what happens under the
cover of a ruby implementation if you if
you don't know exactly what happens when
I singleton class is created and or what
happens when you use two double left the
double angled bracket syntax to get that
the singleton class is something like
that I would say that absolute best
solution today would be to look at the
JRuby into interpreter because that is
straightforward Java
MRI is fine for looking at the C code
Rubinius is going to be really lovely
as soon as all of the core is there in
Ruby code but right now J Ruby's
interpreter is the only part that is
really readable in my implementation in
my invocation of lease the same is not
true about the compiler the this is kind
of a mess actually it's a mess that is
kind of necessary it's Ruby it's a
complex language to parse and it's even
more complex to actually compile down to
Java byte codes to get equivalents
actions we in wanna do-- we have a
just-in-time compiler it was not really
full scale it was 25% finished something
like that
current trunk has got a full Ruby
compiler from NJ and we can compile any
structures in Ruby and the compiler
itself is just an AST walker it emits
the code structure and we don't have a
bytecode emitter that actually generates
java classes and methods and they are
real Java bytecode if you compile in
ahead of time mode you will have a
mapping from Ruby Ruby files to your
class files and they're not going to be
real Java classes because a ruby file
doesn't really match to a real Java
class so it's more of a collection of
methods it's a bag of methods so to
speak but we do have a main method for a
command line execution in just-in-time
mode we need to actually create one in
memory class for each separate method we
are compiling there's no other way of
doing it really so these are a few of
the compilation optimizations we can do
to actually get some really good
performance we pre-allocate cached Ruby
literals we use Java opera a byte curves
to improve the local flow control in
many cases not many people know that if
you use an explicit return in Ruby code
it will actually be slower than using
the explicit the implicit return at the
end of file that doesn't happen in jail
because we use the same operation at
both times we try to use Java local
variables because the performance of
these are really really good but we can
only do it when we don't
have any closures that are going to be
used in other places so evil and binding
and stuff like that just kills
performance and it's no there's really
no way around that
but in most cases in most code you don't
need that stuff so your performance is
good because we can optimize that stuff
we use right now I'm on a morphic
eonline meta cash we are looking at
possibly implementing epic I'm not sure
if that's gonna happen for one-on-one
but if we do that's gonna improve
performance even more so just to give
you a small example of the kind of
performance we're talking about let's
see so I have we we kind of tried to
have a really good test suite so let's
see we have lots of benchmarks here one
of the more interesting one is actually
met the dispatch because MIT met the
dispatches at the core of the whole
environment so let's see where Ruby 198
may to dispatch mm-hmm so let's see if
this takes an argument oh it doesn't
okay so this is these are a few
different things we have a control first
that was what's really slow okay
interesting
so you know what I'll let this run in
the background I'm waiting it back to
the presentation so remind me we are
having a benchmark running in the
meantime I can continue talking about
some things about the implementation
POSIX
has been a problem for a long time for
us because Java doesn't really support
all the stuff you can do in a POSIX
system so in many cases normal Ruby
things that we expect doesn't really
exist in JRuby native extensions are not
supported and well interaction with C is
kind of painful overall all of an all in
all then we find a library called J a
Java Java native access it's kind of
it's kind of like the L to do dynamic
loading and the main thing about it is
that we
don't need to compile stuff ourselves we
don't need to write C code to interact
with this stuff we can just write the
stubs in Java and we can call C method C
methods so we've actually implemented
quite a lot of POSIX compatibility like
this mmm
and we're also thinking about doing this
for native extensions for the most
important ones I'm not sure we're gonna
do that like DNA actually allows us to
do lots of stuff some interesting stuff
like UNIX domain sockets and we actually
implemented fork in the JVM I'm not sure
if we should have that in the codebase
because if someone kind of tries to fork
when you're running an application on
production mode and an application
server something really big and honking
you can end up having a really
interesting situation when you're trying
to fork that in memory so I'm not sure
if we're gonna do that okay sorry about
going back and forth like this Wow
Ruby one-one-nine is really really slow
for this one so this is this test case
is kind of interesting define method is
when you define a method and you give it
a block to actually have this
implementation for that one so as you
can see it's it's really stable it has
this exactly the same timing for
everything
so I'm gonna kill this process Oh No
Yeah right through b19 can't be killed
by control C lovely so let's do it
another way
okay I don't know why Ruby 192 in this
okay so now you have seen Ruby 1:9 so
let's see what we have we want to have
the server flag but that's not really
that's really all we actually need it as
it turns out the server flag in Java 6
especially gives us much better
performance and we done than I would
have expected from something like that
actually the hot spot in Java 6 is
actually really good so let's say this
is Java
this is JRuby trunk right now running us
Ruby 1 9 so let's see the control 0.05
and 0.08 I would say something like that
accessing the fixon war and calling it
to I that is 6 seconds 4 will be 1 9 1
second for JRuby
calling selves foo is 8 seconds yeah 8
seconds for Ruby 1 9 and 7 seconds for
JRuby and finally define method method
is 31 seconds and 4j will be the winner
timing is 3 seconds so for this
benchmark we're actually faster on
everything except for the control and in
one case we're actually 10 times faster
than Ruby 1 9 so we're actually talking
about a significant improvement and this
benchmark if you're interested in
actually seeing what we're testing here
bench method dispatch this code so
define method method this defines an
empty metal with an empty block and
invokes that lots of times that ones are
kind of similar this one defines
something on the top shelf
top shelf that returns self which is
actually the most this is the quickest
operation because we always have the
self returning nil is slightly less
efficient than returning self and then
we have the a 2i
and then we have the control up here
which is just accessing so this is a
control for this one because we actually
need to access the a local variable to
be able to call stuff on it but we don't
want to yeah
you understand the benchmarking process
here so actually that was much better
than I expected I was amazed about how
much sauce so we were in some situations
compared to Ruby 1:9 it's interesting
the define method benchmark is actually
faster on Ruby 1:8 then it is on Ruby
1/9 but we still have a significant
performance increase compared to them
and this is kind of one of the most
central benchmarks because met to
dispatch is the core of an
object-oriented language
the one thing you are doing all the time
is meant to dispatch all over the side
of place so if we get this this fast and
we are actually working in getting it
even faster we can improve general
performance all over the board just by
doing that I told you that the Java
integration stuff yeah actually I've
talked about all this stuff so I'm gonna
swing by that one if you are doing any
JRuby stuff if you want to take a look
at your B and you want to look at the
internals there are a few things you can
do by doing your required JRuby one of
them is this method called AC for it
used to be called actually there is
still a method call that way it used to
be called parse but I prefer ASC 4
because this is just it takes an
expression or a block and it returns the
Java ast the JRuby ast for that and what
you can do with this ast you can
actually modify the ast and you can
execute that ast from this module so
it's not really Lisp style macros
because ruby has about a hundred
different nodes and they are quite
different and quite irregular so you
won't do the same kind of macros but you
can actually inspect and change a few
things if you put an effort to it you
can part can compile stuff with the
JRuby compiler what you get back is it's
compiled script that you can use to
inspect the bytecode
mm and then you have the more
interesting stuff you can get the
current runtime and you can also get the
Java integration equivalent of a ruby
object by calling reference now what you
can do with that one is kind of neat and
it's not something every kind of
recommend for for actual usage but what
you can do is that you can freeze a
string and you can get the reference to
that string and set the frozen status on
it to false you can create a class you
can create a new object and you can get
a reference to that one and then you can
set the metaclass of that object
actually in the effect that becomes the
become command of Smalltalk Fame you can
get all the methods of a class like this
and actually change to met the table at
runtime if you want to but that one is
not really as compelling as at once
because you can actually do this through
Ruby methods all of this is evil stuff
but it's kind of useful if you want to
learn how the implementation actually
works so I'm gonna skip over Rails if
not anyone raises their hand and really
wants me to talk about rails sorry judo
has a worker in jail rest you know if
that works with Ruby in JRuby yes yeah
so the rails performance is slightly
less than the rest of the performance so
these benchmarks indicate very good
performance over the board we there is
some part of Rails and this is true for
rails one two and rails 2 data that we
haven't been able to identify that
causes performance to drop that means
that we are still faster with JRuby we
have a smaller memory print and during
the equivalent the deployment with
mongrels but it means that we're not as
fast as we should be we should be two to
three times faster right now we can
maybe we have one twenty percent on what
the Ruby one they in general it's kind
of hard to benchmark though because we
don't have anything that we can use as a
reference for benchmarking this is
actually something we are working on
getting some getting to get is something
that we can use
a reference that we gives us a reference
for numbers that we can actually improve
the performance with focus on rails
performance because it's important that
we find this bottleneck there is
something strange going on yes so the
membership in it kind of depends on what
you're doing if you're doing stuff with
cycles lots of methods and and creates
new methods quite a lot at runtime the
compiler will take up more Perm gem
space because class is going the permian
space but overall with compared to
mongrel do Paul do you remember david
has told us about this I don't have the
numbers we're not talking magnitudes of
difference we're not talking we've maybe
talking half the memory footprint to to
get the same requests per second
something like that yes so how do you
actually deploy a rails application at
the table maybe you run it inside an app
server somewhere No so I was planning on
doing some demonstrations but I'm
running out of time so I'm gonna skip
that one it's not really an interesting
demonstration if you've seen if you've
seen the rails rails podcaster rails
screencast when they do a blog so the
thing about it is that rails works
exactly like it does on regular Ruby but
you have a few different deployment
options first of all you can deploy
exactly like you could do with regular
regular Ruby but you don't want to have
ten mongrels running in their own JVM so
there's another way that you can use a
mongrel cluster that actually runs
inside of the one JVM but uses different
runtimes since JRuby is by the way by
design multi virtual machine so you can
use more than one JRuby virtual machine
inside of the same actually one of the
fun things we do in our test processes
that we use JRuby scripts to start new
JRuby runtimes inside of those JRuby
scripts and we skipped them from the
outside to do tests on the internal
runtime we can do all that stuff because
we don't have any shared safe we don't
have any single zones now mongrel
cluster works kind of if you stuck in a
ruby mindset but there are
two ways of doing stuff there is much
more convenient the first one is to do
new something called GlassFish you have
heard of GlassFish right so glass this
is really cool and they have a gem a gem
that is 2.2 makes Lodge you install it
saying gem install GlassFish and what
you get back is a glassfish rails
command that you can start any
Juby on Rails application with you don't
need to do any configuration
it just works from scratch and you can
do it in development mode it picks up
you can start several runtime so you can
try perform this and so on and you get
the whole application server the whole
GlassFish in two Meg's of a gem that is
an interesting option it's not
necessarily good for deployment it's
good if you're going to deploy on on the
GlassFish server that that exists
somewhere that someone takes care of
then it's good to do that development
locally in the same environment but I
would say the recommended way of doing
deployment is by taking one of the
existing there are a few plugins for
doing this Warbler jaehwi works and gold
spike they allow you to package
everything up into a war file so they
give you you install them as plug-in
then you you create some you sometimes
you need to create some actual
configuration to point out which gems
you need because all of these create war
files that are actually self-contained
archives that contain the JRuby runtime
and all the gems needed all the
libraries needed so you need to create a
war you need to point out the gems that
needs to be included you possibly need
to change your web XML and then you get
a war file out that you just deploy the
process is extremely simple and you get
a war file that can be deployed in any
compliant java web application container
this is the preferred way of doing it
you have you can have a few other ways
of duty too right now for example mingle
which I'm coming to in a few slides is a
bundle application that we bundle and we
send it bundles so people can install it
locally and the way that works is
basically that when it starts up it
starts up an internal jetty that serves
a ruby that's handles the jury room
times using using the gold spy service
which is it's a real servlet that allows
you all of
projects can be used the rail servlet to
actually serve the rails content so
those are the options and the best one
for real production is to just push out
it in push out a war file and deploy
that the way you would do any java
application because in that case you
also get all the money
monitoring benefits you get all the
management benefits you get all the
clustering you get security you get some
of the transaction support you can get
all of that for free by just putting it
in a war file so a few different things
that kind of can be useful to to know
about around the JRuby ecosystem
outside of rails there actually there is
actually well outside of rails one of
the parts that I like to think about I
think I've been testing affected since I
don't work side I thought a lot about
tests before that but yeah so in good
port works manner I have created my own
testing framework this is a testing
framework that doesn't really create
anything from scratch it's just a
bundling of stuff it puts things
together and makes it really easy for
you to use Ruby frameworks to test your
Java code so this is for those
situations where maybe you need to have
Java code in your main project for some
reason but you have some flexibility to
use something else for tests so J tester
lose JRuby together with r-spec test
unit dust mocha and a few other
libraries so it gives you flexibility in
which test framework you want to use it
doesn't really matter you get ant and
Maeve into integration and you can also
interact back with J you need to test ng
tests that you have written earlier that
you want to include in your stuff so and
all of this generates a unified output
if you want that the r-spec support
actually have support for stories so if
you want to do behavior driven
development with stories as acceptance
criteria this is a very nice way of
doing it actually record is nice it's
simple it's not scalable hibernate is so
we are working on something to kind of
the easiness of defining stuff within
actor record and working with actor
record and the easiness of Yoruba
language together with hibernate so this
is just a proof of concept if the
project is still going on but we don't
really have the resources to put lots of
man hours behind it right now
the purpose is basically to be able to
do something that is in spirit like
active record but uses the base of
hibernate and also allow you to reuse
your existing investment in hibernate
yes this is a JRuby thing yes you could
imagine possibly doing that with RJ B or
something like that but it wouldn't
really be feasible you can do it but it
would be painful to say the least so
this actually depends on having
hibernate the hibernate libraries on the
classpath I uses Java integration the
Java integration features of JRuby we
have discovered that Java is a very good
platform but it's not the best platform
in the world for dynamic languages right
now so we're working on improving the
situation by jsr to 92
something we'll call jl r and the
DaVinci machine and all of these kind of
aim to to provide more cool stuff in the
next Java version that allows other
implementations to live well the most
important one is to do dynamic
invocation invoke dynamic you have meted
handles anonymous classes faster
reflection escape analyse all of this
stuff is kind of important and then you
have the more cool stuff that is kind of
probably not going to happen but could
be interesting if it happen
interface injection real mixes in the
Java platform continuations value
obvious tuple types might possibly
happen actually tail calls would be
really good for many languages I'm not
sure if tape call optimization is going
to happen or not but all of this is
going to be is being prototype in the
division machine right now finally I
just want to show a few examples of
stuff where people actually use you back
sorry yes
80% of that stuff is already in CLR like
in mono and stuff like that so does that
mean like for iron ruby ruby dotnet
because I don't have to do as much posit
that most of this stuff is not in the
CLR I said I don't think that most of
this stuff is available in silico sites
from the lr it's a library on top of CLR
there is no support in the CLR in modern
for actually doing this so this is just
library level on top of the CLR there is
no support in the actual virtual machine
for these things so what we're talking
about here is actually a new bytecode so
that's going to change the story the way
did the DLR stuff do it does things is
to take one thing they do have is metal
handles and the dynamic cool sites that
they have is it's it's a class
it's a genericized class that allows
them to quickly and performant ly switch
out metal handles but they don't have
support from the virtual machines so
they don't get any actual just-in-time
confirmation and so on so I would say if
we get this actually even if we don't
get it we still are in a better
situation than the CLR for performance
right now
for the simple reason that the CLR is
not this is stuff that was actually
reported back from the land of net event
in January the sealer doesn't do much of
the hotspot optimization that Java does
currently Java saucepot just lots of
interesting stuff that Co still doesn't
do so general performance is going to
take some time for for this year to
catch up
No in Java in general in Suns JDK the
Java six hotspot is more advanced but
still the Java one for hotspot is more
advanced than what you can find in
actual CR implementations Oracle
actually released mix that Oracle that
come and the research a Ruby on Rails
site we built it in six weeks and it's
kind of sharing Network idea sharing
networking Q and a production
environment for all of Oracle's
customers and it runs on top of the full
oracle stack and one of the reasons was
the production staff wouldn't actually
be able to get MRI into the resulting
stuff and they also wanted to be able to
run on top of the full applicable
application stack so this is actually
running with using let's say oracle SSO
oracle erector server oracle
apache oracle linux oracle rdb ms and
oracle application servers so it's kind
of the read stack from top to bottom
sun is doing something called media
casts that is kind of a media marketing
distribution channel using JRuby on
Rails and then we have thought works has
released a product called mingle how
this is kind of a screenshot of how the
general interface works it's the first
year ruby projects a product to ever be
released was released in june the two
that over should is gonna be at some
time in March it's kind of for
collaboration and agile workflow but it
doesn't restrict you in any way
cod are basically only the restriction
you have and you can use that to do
quite flexible things actually we use
that for we use JRuby for several
reasons we ended up in a situation where
we need a library that we couldn't get
to work on both linux and windows in the
raela ruby distribution so we went to jb
and used a Java library and that works
perfectly then we ended up using some
other things too for example darby we
used for a long time we used to be to be
able to actually protect and encrypt the
source code of the ruby application and
we're probably going to go away from
doing that and just use pre
instead because precompiled JRuby
bytecode is incredibly unreadable it's
better than the best obfuscator you're
not gonna actually understand what's
happening there without some serious
analysis which is nice
Gaea will be allowed us to do easy
bundling too so all of these kind of
benefits so that's actually the end of
my talk and this is the book I mentioned
earlier and I didn't actually add in
resources because all this stuff is very
easy to find with a well-known search
engine exactly it's all right so are
there any more questions yes okay if we
can use the might so we get it for their
video so when you marshal between the
JRuby interpreter and Java when you're
like making new buttons and stuff like
what's the what's the overhead for the
marshaling between the two like how many
objects are made and thrown away the
Java integration marshalling yeah yes
when you made a button in whatever like
how many extra objects are main stuff
like this so at creation of new objects
the most stuff that happens that's a
good question actually because that's
the area we're gonna spend lots of time
after one or one release now the Java
integration features are extremely
complex right now and the implementation
have kind of grown organically when we
need new features so right now two times
new objects are being created first time
when you actually use the class ID you
have a class for the first time at that
point lots of different obvious are
created to actually represent the Java
methods and in all the metadata
structure that we need to be able to do
the Ruby kind of features on top of the
Java stuff and then I think two Pro
objects are usually created for every
one Java object you create like that
because they always need at least one
wrapper as if I remember correctly you
don't need more than one wrapper but all
of this is gonna be revisited we're
gonna rip it all out and redo it because
now we know how the interface is going
to look we know how how the integration
is actually going to work we just need
to implement it better better and more
performance in duders wrapper objects
have the same
or stimulator wrappers do they have the
same lifetime as the object itself or
they made them thrown away relatively
quickly that's a good question I would
say I'm so they don't have the same
lifetime as obvious if the wrapper
objects have the same lifetime as the as
the objects are referenced as long as
the refere obvious a reference from the
ruby side of stuff so if you pass
something back into Java and and that
local variable in Ruby goes out of scope
yes the wrapper LBX is going to be
collected okay and is there any objects
that like this that are made for just
method calls after you create the the
Java object within Ruby so if you make
an object and then you call a method is
there going to be any extra GC overhead
just from calling method than that
object that you already created no so
the only thing that's gonna happen is to
wrapping around wrapping up parameters
to that call so that might be something
there but we are we are moving quite
heavily towards lightweights and that's
also one of the major restrictions we
are looking at making to actually make
right now everything is wrapped but we
want to make it lightweights
so we can actually work around there
there are some challenges in doing
lightweights and implementation but I
think that especially when you have a
language like Java that doesn't actually
have a unified or big structure but we
think we can work around that then it's
gonna be lots of benefits in many cases
especially no rat bursts and stuff like
that of course so does the hotspot one
last question does the hotspot VM in one
six or one seven or whatever in line to
the point where the method invocation
overhead for these wrappers is
non-existent or does it not in line at
all in between it does in line and it
does improve performance of invocation
of these but the the problem for hotspot
is that our usage patterns for this
stuff is kind of not what hospital specs
so the problem this is a problem with
Java ones it's not a problem with Java
one 60s problem with algorithm to use up
till Java one six because the hotspot
optimizes based on current Java items
and what current Java items compile into
which is why you should write simple
Java code because that
hotspot compiled now Java 1:7 is
actually gonna be much smarter and
optimized all kinds of bikers
combinations in a much smarter way
without taking into account items like
that so that's gonna improve the
situation and it's kind of funny when
when we when we upgraded when we started
testing performance in one six zero one
five just the hotspot and running server
it gave us twice the performance just by
upgrading we didn't do anything that's
the that that's the best kind of
performance improvement I like the ones
where I don't have to do any work for
them yes any more questions two quick
questions one in terms of compatibility
is it generally safe to assume that
pretty much any Ruby application or Ruby
library that doesn't use native
extensions works with JRuby as well yes
if I wanted to use something like the
merb web framework with yeah example
something that actually has native
extensions okay what nerve works because
we have ported native extension merb
uses TM the HTTP parser from mongrel
which is actually the only C competent
of mongrel
it's a regal state machine and since
regal rail is really cool by the way if
you if you like if you like finita site
theory it's really nice since it has an
output mode for Java what we needed to
do was essentially just torch the small
helper methods in the C regular
definition and then we could just
generate a Java
parser for HTTP that works as well so
that was actually a quick process so
since that is available that means that
Merv works fine oh great
another quick one is it possible to
share gems between the regular Ruby VM
and the JRuby VM on the same system yes
we don't can't really do it because
there are lots of gems that are kind of
jury was specifically sis in some cases
actually happens because they're the way
they are if you use JRuby to install a
gem that is Java specific into your
gem repository when Ruby rubies ruby gem
tries to load the manifests for all
these because it keeps a manifest
running of all these tools stuff right
so when it tries to load that it's gonna
barf on seeing well I can't have this in
my manifest and then just can go poof
and say it's actually not gonna say
anything if I remember correctly it just
barks on you so if you want to have
shared that's fine but be careful to not
put any Java specific stuff there make
sense okay any more questions yeah right
there sir compatibility questions
Ruby Coco is one sorry Ruby Coco I'm
sorry I don't hear Oh Ruby Coco ribbon
culture framework on Leopard okay for
rating Coco Epps and Ruby oh sorry yes
does that work I haven't tried it I
would assume it kind of extends it uses
native extensions but there is a Java
interface to interfacing with object you
see on what I think that's been
deprecated all right and that's tough to
anyone mm-hmm sorry defecation never
stops and what no so yeah as far as I
know no one has actually tried to
interface JV with Coco right now there
as long as there is some way for us to
get them there it should be possible but
on the other hand Apple has actually
spent lots of time writing integration
things and writing lots of C code and
I'll be able to see to integrate
integrate Ruby with Coco so I'm not sure
that's gonna happen in just a blink of
the eye what Bernardo test auto test yes
if I remember correctly we have that
working there were one or two
command-line options we didn't support
for a long time that kind of stopped it
from working we'll fix that cool any
more questions okay great great well
we're having the air so much for every
new low</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>