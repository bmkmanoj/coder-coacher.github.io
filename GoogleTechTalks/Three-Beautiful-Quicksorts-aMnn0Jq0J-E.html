<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Three Beautiful Quicksorts | Coder Coacher - Coaching Coders</title><meta content="Three Beautiful Quicksorts - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Three Beautiful Quicksorts</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aMnn0Jq0J-E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I'm very happy to have Jon Bentley
visiting us today there's quite a crowd
well it seems to be occupying a fair
chunk of the front row here of people
that used to occupy the UNIX room back
at Bell Labs so in in the olden days
there was one bell system and it worked
and a lot of us were sitting in this
place in Murray Hill and over time more
and more people have come to Google so
now it feels like this has become sort
of the home base for a lot of us so
we're really glad that John joined us
over the years that Bell Labs split into
a bunch of pieces one of those is a vile
ABS that's the part of bell labs that
split off that kind of owns the
enterprise telephone systems and I guess
this campus uses via product so so good
John has done a lot of great things over
the years in computer science right i
first started reading about his papers
i'm probably back in graduate school
right i was searching in space and so
forth and one of the big things he's
made a name for himself for it balances
coming up with little languages that we
could quickly allow people to express
solutions to problems he'd worked a lot
with Doug McIlroy on various things and
I believe that's the topic of today's
talk so for the different John
eric was being particularly gracious
about describing villa's enterprise
communications when I chose to go to
avaya darkness pal Shep said oh you're
going to rocky set to use pbx research
lab so we have some other alumni of the
pbx research lab here but I won't
disgrace Tom in that particular way so
today I want to tell you about beauty
it's sort of audacious to do this but
there's a a reasonably cool book you
said you spent this morning looking at
the book it's a reasonably cool it's
reasonably cool and ok description yeah
but I think it's sort of a really neat
idea of a book called beautiful code and
you get a few dozen people to talk about
what's the most beautiful code you've
ever written I'm here unabashedly to
talk about the book and the only reason
I don't feel really even more shame than
I should well apart from being raised
wrong is the fact that all profits are
going to an organization and the Morgan
ization that I has a guy who goes on
wearing West Point t-shirts and not all
that fond of so it's I have no private
monetary axe to grind hear a delicious
question what's the most beautiful code
you've ever written got email out of the
blue but I want to write a chapter for
this book about the most beautiful code
I've ever written think about that my it
was delicious they're all around my
brain for the better part of the day a
beautiful code well maybe you mean
what's the simplest cleanest smallest
implementation of a function that most
people make pretty big in our way that
best beauty maybe forget this this
beauty for its own sake maybe for a real
production code what's the most
beautiful piece of production code
that's been widely use that you've
written and finally
the one that really intrigued me is
what's the most beautiful piece of code
you never wrote I once heard a colleague
of ours described someone praise someone
ultimately as quote he adds function by
deleting code and how can I talk about
that and that's really in a certain
sense the most beautiful so I thought
about these three things for about a day
and I realized that my answer to each
one of them was quick sort that I had
three different versions of quicksort
and so in back in the book chapter three
is called the most beautiful code I
never wrote and as about this but what I
want to do today is that if you want to
look at the book that it's available
that's I think sort of neat but I'm
going to tell you the bigger story so in
the second section I saw just very
briefly survey that but it's fun to tell
you the bigger story and that's what I
want to do so i'm going to talk first
about a really elegant tiny
implementation of quicksort then i'm
going to tell you the story of analyzing
the runtime of quicksort where we'll
start with number one instrumented for a
long time then transform it where each
one will go through a series of about a
dozen different programs each one is a
very simple change from the previous one
you start off with a dozen lines of code
and finally poof it disappears into a
puff of a mathematical smoke and all you
have left is a mathematical analysis so
that's going to be the third thing and
finally a production cuse work that I
wrote with Doug McCoy the first two are
admittedly only Faberge eggs they're
tiny beautiful deliciously crafted small
objects that really have not much real
world use the third thing with E is real
world code but it's still in the small
side so everything I'm going to talk
about here is smallish but some of it is
semi real if I say quicksort just to
make me feel better or not who feels
yeah I know the quicksort algorithm
this is so cool it's the classic
divide-and-conquer algorithm a sort the
array you choose the first element
partition around it so everything over
here is littler everything over there is
bigger the first element is right there
so you divide it now you conquer by
recursively sorting both sub-arrays a
really simple delightful easy algorithm
in the very best case how much time does
it take one the very best case you get
lucky computer programmers are optimist
think of the things going to happen I
split in the middle I get a recurrence
attea then equals twiced even over 2
plus 0 of n solution is in log in it
takes n log in time which is optimal for
sorting we can't do much better than
that and the worst case however and
every computer programmer who's ever
written at least one program knows that
this often happens I only peel off one
element at a time and therefore the
algorithm takes n squared time so
best-case worst-case on the average why
just add them up and divide by two well
not really it's really in log in and
bass 2 i'll give you the details soon so
it's a pretty reasonable algorithm how
exactly so the idea of quicksort is
really easy but how exactly do I
partition the elements of an array
around a given element such that littler
ones are on this side bigger ones are on
that side and exactly what happens to
the equal elements you know what do I do
with that it's conceptually
straightforward there were a couple ugly
days in the summer of 1975 when I took a
a quick sort right out of a classic
algorithms book now at the time it
wasn't knuth and I wouldn't badmouth a
hoja crofton Uhlmann because they're
they're friends but I took it out of
some unnamed algorithms book
and I spent a couple days debugging I
didn't look there because i knew i had
that code by out of the book it was
great but it wasn't so it was a couple
days of debugging made it tough I'll
give the details short way but here's
what the code looks like you know many
of you I think most of you have seen
code like this where you run one pointer
up the other pointer comes down the
descriptions to go like this and like
that and you swap them and keep on going
so that's the code that looks like
pretty reasonable coke it's not that
long tad over dozen lines but I realize
that it's more than the likes of my
little brain can understand that I was
able to look at the code like this and
get it wrong for a couple of nasty days
of debugging I think the reason is that
whenever you have a dual while construct
whenever you sort of set things up that
I do the option first I do the operation
first and something else happens it's
sort of hard to understand so but this
is the code it's not that subtle I'm not
going to describe this from the details
I want to get it simpler so what I'm
going to do is I'm going to tell you
about one classic technique
randomization if a problem is too hard
toss the coin to weasel your way around
it in quicksort what i could do is G it
works really well in the average but if
I haven't had two elements that are
already sorted each time i'll choose the
first element of partition it does
nothing i only play off one element i
keep on going one by one by one horrible
if I shuffle the whole input before the
run that gets around that problem even
more easily this is from 462 paper if I
just randomly choose for titian element
with that much code I can let the
randomization apply the expected
analyses to end but from your worst
enemy not that's pretty cool here's the
partitioning when teaching I really had
trouble explaining the code I just
showed you while kody and i always had
to use my own trusted version I couldn't
read this sit down and type out the
lines of code I didn't we understand it
I wanted to find its noun rhythm so
simple but I could understand it code
and explain it I was reviewing a paper
named Nicole amuto who had a really
clever algorithm for related problem and
we use this loop invariant which says
that rather than having these two
pointers I'll just have one pointer and
this should this is so cool so here if I
want to sort the array from l to you
I'll let the middle value M fall in the
middle although the current index I be
right here the invariant is it this is
the oppression by UT everything over
here is less than T everything over
there is greater than equal to t well if
I come here what do I do now well if
it's greater than T what do I do it's
pretty easy to sleeve it alone if it's
equal to TI leave it alone but how can I
maintain this invariant if it's less
than take well that's also pretty easy I
can just to swap it back to hear but
this one up there and continue so if if
I do that at the end of this operation
I'll have the array that looks like this
I now to swap t from here into position
em and I can recursively sort from L to
L minus 1 from M plus 1 to you that's a
really simple partitioning scheme it's
sort of important to understand this I'm
going to stop right now who thinks that
they really understand this dead cold
already who has any questions if you
have any questions at all please ask
it's in Sweeney's yeah
no no so here all you're assuming is
that the elements are totally ordered
that there's some comparison function
you can call and it will be either its
littler it's bigger or it's the same as
soul I'm assuming the total order okay
so here that's pretty easy code and that
now here's the algorithm and there's l4
I gets l plus 1 up to you in committed
if X sub I is us next to t only for
surfing lesson swap it increment em and
I pretty pretty pretty simple stuff this
is my first claim the code that might be
close to beautiful it's a really simple
little quick sort and this is beautiful
only in the sense of taking an algorithm
that when I first saw was presented as
30 lines of code and when I first
studied it in knuth was presented those
50 lines of mix code and really it's it
doesn't need to make a little not that
much a deal out of it if l is greater
than you I went to the sort female to
you well I'm done by definition
otherwise take the loop we saw before
swap it at the end then recursively call
it i'll call it from lv m minus 1 and n
plus 1 do so a really pretty simple code
yes part of me
if all of us were the same it's still in
squared and that is going to come back
and bite us on the but repeatedly but
fortunately on this next slide I say
right here ah it's quadratic time for
increasing elements randomization fixes
that is quadratic time for equivalence
is there a beautiful solution to that
problem so you foresaw this one is only
a factor of two what's a factor of two
among friends we don't care about that
really this one is pod Radek but here we
can fix it this one we can't fix so you
see you honed right in on the major
weakness I think sort of an interesting
open problem is is there a beautiful
code that fixes this particular problem
it this doesn't fix that problem I I
have some ideas about that i'll be happy
to talk people afterwards only on maybe
adding three or four lines of code to
fix out i think if i might work oh my go
other questions great question thank you
yes it is not stable
it's not stable and essentially one
really nice property of a sort is that
you lead elements in the state you need
equal elements in the order in which
they appear things like merge sort have
that property it's really a delightful
property for many things you can gain
that property by adding on fictitious
numbers but this one is not stable picky
picky check you jeez Oh any other wines
okay so like I said its strengths are
numerous it's simple and to explain it's
simple to code it happens to be correct
I'm pretty sure that that's you know I'm
a clever lad but getting the bug into
that much code is hard even for me it's
pretty fast yeah Prasad is a master he
knows that he could do it it makes
experimenting easy Strunk and white
admonish us that vigorous writing this
concise omit needless words it's a real
joy to take a program to try to make it
as small as possible try to just cut
things down to its essence and again
there are these weaknesses other
questions suppose
the number of elements are so large that
the originals
I suppose it takes ten thousand machines
to store you all right no wait wait wait
let me see where I am 00 Google okay
yeah yeah then that's a really
interesting question but it's is it's
beyond what I want to talk about today
no no problem is so large that it can't
be run away from it's an interesting
question but beyond the scope for the
day so here might be the simplest semi
production see quicksort just the
previous code before where I add in the
swap and this this is a pretty useful
code it's not not solely that's point
number one tiny little code point number
two is how much time do it take before I
gave you the worst case the best case
how about the expected runtime on the
average how much time does it take and
here i'm going to say let's do expected
first only on indistinct elements I'll
come back shortly in about 20 minutes to
what happens we have equal almonds I'll
get to that again but for the time being
is help me out here with the issue of
how much time will it take on a set of
indistinct elements well firstly what do
I count do I count the nano seconds on a
particular machine that's really useful
if you want to do real engineering do I
count some critical operations but I
count the number of comparisons died
Calvin number of swaps whatever how do I
count it do i do experiments do i do
mathematics do i combine it
all those are difficult questions how do
i graph the output well if i graph the
size here at one time here but will the
graph look like what's in here and run
time there what would be sort of a line
roughly what's the better graph in this
time versus run time well one thing that
I might do if i put the runtime divided
by n over here in a linear scale and if
I have n on a log scale there that'll
show me the time per element and if it's
an n log n algorithm how should that
grow so if i do a real graph of real
runtime what will this thing look like
well you might hope there will be a line
will it be a line what will it be I'm
getting towards your question and that
is it if I do if I major real runs plot
average of so many runs with nanoseconds
divided by N and I do it for first
quicksort and then for a heap sort icy
curves like that why do I see curves
like that these are lines mean these all
are straight except they're straight at
three different angles
so I'm tickling at the other end of the
question you asked where do these so
here this one is linear up to about
where the first place with what number
yeah at about 8,000 for bite injuries
but about 32 kilobyte for the l1 cache
here up to 512 kilobytes for the l2
cache and then here ram so here for
heapsort it really runs around memory it
bounces all Oprah it's not a particular
cache from the algorithm therefore you
see three different domains heapsort
some much more cash from the algorithm
even though here you can see that there
are still three different domains there
so and sometimes something else happened
on my machine where my machine burped in
the middle of the experiment and this
happens so you can look at real run
times if you do that it's a bit delicate
run times are interesting interesting is
sometimes interesting what I can do
instead is out count key operations I'll
be much more mathematically smooth I
could count the number of swaps I'll
instead count the number of compares
because before i do any swap i'll do a
compare so that's what i'll do so i can
do now is I can take this program that
we had before and it's to add the
statement to it initially comps is equal
to 0 afterwards I'll print out the
number of comparisons and here right
before i do any comparison i'll add in
one line of code so i'm going to take
this program add in one line of code and
instrumented and go from there
if I run this program now I'll be able
to get a graph where I can see the
number of comparisons as a function
Nevada number of an president / in if I
want to a pretty interesting graph but
am I ready to run this program me out is
there anything I can do to make it a
little bit faster a little bit cooler
before I run the program what can I do
to make this program cooler before i run
it will get right there but so i'm going
to do a series of transformations a
designer knows he's a chi perfection not
when there's nothing left to apple and
if i have to take away and software the
most beautiful code most beautiful
functions those beautiful programs
aren't there at all sometimes fasten
your seat belt i'm going to go to a
sequence of a dozen versions of this
right now there is no test at the end
about this so you can weasel out of that
one but the first thing I can do is
rather than having to count right in
there I can put this up here and I can't
get rid of the rage until I do this was
a great thing so the first I can do is
that just just move the comparisons out
to make it a bit easier but now I can
take the advice of dispense with the
array that's the quote why can i
dispense with you sorry I'm sorting I
have to sort something don't I well no i
don't i don't really have to sort
anything what i can do is i can take the
program and run it what I'm doing now is
not I start off by writing the store
program next I'm going to run a program
that just models a sort program a swart
program sorts this model program is
going to be a schema that does the same
action the sort program would have but
it won't bother sword in the array if I
don't have the array what can I get rid
of here I don't have the array I don't
have to do all those nonsense of
swapping if I don't have the array going
through that swap I can get rid of the
end of your eye and instead of saying
that swamped with random partition
element just to sign the middle value to
be some random element because I'm going
to swap and again I've assumed here that
these are all in distinct elements so if
I swap all this I just get down to this
schema program
looks roughly like this and like a now
simplify this just to be the skeleton
program to be a quick sort count if l is
greater than you return otherwise your
partition around this that's your middle
element the comparisons are incremented
by that and recur both ways here
everyone get that idea so I'm going from
a program that really sorts to a program
that is over here modeling this work
that on average will have exactly the
same stochastic behavior
it's not depend on the data in certain
census yes so here I'm going to
accurately count the number of
comparisons I'm making am I going to
count the number of swaps I'm making no
I think what he would rephrase what he
says I think this there's implicit
assumption about the randomness Brandon
is
mimics the district
yeah and again that assumption is clear
that if I have God's own random number
generator here it gives me that then
it's easy to prove that on the average i
make likely to choose any particular
notion here so you can't do this
everywhere you can do this in a
surprising number of places i chose this
example that the first time I really did
this was an analysis of a traveling
salesman program where i wanted to do a
strip heuristic where you go inside this
trip and come down that strip and go
back and forth for planar points and i
realized that i could generate all the
points at once and do that i could just
consider the points in the strip and
then i could say well how far up is the
next point how far over the next point
and all of these were very easy
distributions and i found a way to get
down from a hundred lines of code
without dozen lines of code and then i
found that those bastards beardwood
Holton and Hammersley in the Proceedings
of the Cambridge philosophical society
 in 99 in 1957 had done the same
thing and it was into a double integral
but this sort of thing happens I'm
cheating but it's a general trick you
can cheating a lot of places you know
Newton didn't look at the planets you
just had this little model for the
planets bastard as I have so what that
does is it reduces the time from n log n
done to linear and it reduces the space
from linear to log in so again I'm
cheating here I'm only doing a model I'm
not really having planets go around the
Sun I'm having this model of nothing and
what what if an inverse-square lobs so
Pascal famously said if I had more time
I would have written you a short letter
we have the time is it possible to
shorten this letter
well that's pretty natural but we didn't
need the ll you now well i can replace
two indices of one length so just choose
the length here if n is lesson one
return otherwise it's a random integer
do that one and that one that's pretty
nice but do I really need to make it a
function or to make it a essentially a
procedure avoid I can just do an integer
comparison count we're here I say if n
is lesson one return 0 otherwise it's
random nth and return this thing so here
I bought and down from this doesn't mind
program to about a four or five line
program that does the same thing I hope
this is pretty clear so far next step is
going to be difficult we started off by
a real program that we these warts we
went next to a skeleton program I'm
going to now do a model of the program
polla admonishes us that the inventors
paradox says sometimes the more
ambitious plan may have more chance of
success suppose that we don't want to do
one experiment but I want to find the
true average what would that program
look like so i want to make the goal of
computing not just one experiments worth
but the true average number of
comparisons assuming that all partitions
are likely here's a pseudo code to do
that c of n it venez us in one return 0
otherwise compute the average let every
single partition element be chosen and
again this is just making a statement
for the partitioning element from 1 up
to n that can be when you choose some is
that and return the sum divided by M so
here I'm making the same outline as
before but now I'm add metal dividing
that by in to do the average
it's really cool it's a much more
interesting answer now instead of n run
a bunch of experiments I just get one
true answer unfortunately I'm computing
the same answer over and over and over
again recursively and that makes it
exponential sucks to be John and in so
many ways but
is there a trick that anyone here knows
for if you do the same answer over and
over and over again yeah you're dividing
by n so the sum is summing a number was
an integer plus two floats which are not
on the same
yeah this is I should have said 0.0 my
bad now let's see the N minus 1 this is
the number and the others are yes
and there's not going to be a test at
the end there's some subtle stuff going
on here I minute sort of zoom along if
you understand it find if not I think
you'll appreciate it anyway just to see
where we go at the end but it's subtle I
could easily spend the whole hour just
talking about the details of this but
there's other cool stuff to talk about
so here i compute the same thing over
and over again it's exponential what's
the magic technique we have to solve
that problem Neville eyes see it shows
the benefits of a bad education that you
came from this nasty this background in
your kindergartner and dynamic program
you hung out with proper oo are people
so say you you are you were raised
appropriately because on the next slide
I slide after this so here we have the
real deal we have an instrument program
we have a skeleton program and now we
have a model of this so how you we come
up behavior and how do I make it faster
dynamic programming so I just felt memo
eyes honey I didn't go to MIT so i cant
spell memo is a really trivial example
of dynamic programming let T of n store
see you then computing increase in order
to compute this up to the value capital
m for every in beating the program sized
up to some maximum capital in just do
this is to the table access so I'm just
going to do that by converting this
function to a table and computing an
increase in order pretty cool are we
done ready to run the program nah right
now it looks like this what I can do
instead is move this in- one out of the
loop that's pretty easy this becomes the
inner loop
can I make that loop it all faster this
nasty interloop this is going to loop
enough and make it a little faster I'm
adding up if n is 500 yes so the inner
loop is like this originally it adds up
t of 1 plus C of 30 equals 4 t 1 plus t
up to G of 2 plus T of 13 plus T of 0
notice this is the same as I just adding
things up this way and that and dad is
coming from the it's so much easier so
much cleaner to write it as twice this
so here I'll take that Luke and place it
without lube pretty obvious currently I
have quadratic code we're in the inner
loop every time I add up the sloop but
what changes i had a tia one of those
tf2 close to ft plus DF four plus TF 519
busty of 520 all the change from last
time is the last element so i can change
this by not recomputing the initial
terms and just add in the last element
here whoo so now this is my new complete
loop I've taken it from quadratic time
in capital in square down to capital m
so currently I've had a pretty small
piece of code about four lines of code
that gives me much much more than I got
before and if I continue with this
can I make it any better than that space
spaceman's the final frontier I can
remove T to compute see you then in this
much time in space just by saying that
rather than making tea the table
elements only compute the last element
and if i do that this becomes the final
code so it's just essentially a
recurrence relation a system of
recurrence relations of two equations in
two variables and if I want to now I can
turn this pretty much into mathematics
perlis as one of his many wonderful
perla systems observed the simplicity
does not proceed complexity often but
follows it so I started off in version
one of how 13 lines of code can give you
one answer in n log in time by the final
one I have four lines of code that
instead of giving you a sample give you
an exact answer I can compute all
answers in capital n time and constant
space
in that I can sort of review this or
rephrase this as this recurrence
relation that many of you who studied
the quicksort paper and it's descendants
and if you have studied the quicksort at
all you've studied the quicksort paper
and canoe this description of it we can
go to this recurrence every one of the
mathematical tricks that you may have
been tortured by in class and that
corresponds to a code prickly to saw
that one of the real cool things like
talking about this to undergraduates is
you ask an equal love coding Hall of
code and people like mathematics boo
that's as bad but it's the same thing
it's just different writing it with
different hands so here each
mathematical trick corresponds to a code
optimization and there's one thing
called a summing factor and the final
answer is that the number of comparisons
used is n plus 1 times twice the n plus
first harmonic number H sub n is 1 plus
a half as a third plus a quarter plus up
to 1 over Y so this harmonic number
minus 2 minus 2 in it is about 1.3 86 in
log M Einstein encouraged us to make
everything as simple as possible but no
simpler if you want to find the exact
one time of the algorithm that's about
as simple as possible that's a little
bit simpler but it loses something you
can see it's proportional to n log n
questions about that
okay I made you suffer through one
analysis but the good news is but wait
there's more you just saw not only an
analysis of quicksort you saw an
analysis of binary search trees why is
that if I show you both the order
preserving quicksort and again
randomization says that they're all like
and I compare it to binary search trees
if i put the elements in in this order
3141 59 2653 the first element goes
there second element goes there 59 goes
there 26 goes there this binary search
tree is strong the isomorphic it makes
not only the same number of comparisons
it makes exactly the same set of
comparisons so the analysis I just
showed you applies not only to quicksort
but to inserting random elements into a
binary search tree two for the price of
one complete analysis search costs on
the average for quick sort and binary
search trees a sequence of
transformations a continuum from code to
mathematics there's an old line that
dumb if architecture is frozen music
then Stanford is frozen john philip
sousa in the same sense that data
structures are frozen algorithms you get
a two for the price of one where is the
code
well in the book I described in some
detail how I never really wrote the code
I played that I wrote it on paper but I
never compiled I never tested it at the
very end it took the final one put it
into a spreadsheet and I got the right
answers I spend enough time in the unix
room to realize that you should not
speak in public about code that you
haven't really beat on because someone
else can just take it back on and beat
out once and make you look really really
silly it might happen that I but I've
never written this code I'm going to
keep it that way issues sometimes be
seen as a soap bubble that's the end of
number two questions about that yeah
your definition of pseudocode is across
the seven calls
I'm trying to think if there any other
exceptions well and I don't need to
declare functions while either yeah but
pretty much that yeah yeah and again
this is something that I as in point of
Honor I didn't want to write the program
I wanted to make it close can I
translate that into a program that
worked probably other questions so
throughout the paper I have all these
different aphorisms about simplicity
it's good but it's not necessarily good
at that level of detail yeah what I you
showed you is cute it probably hasn't
killed you to waste 40 minutes so far
maybe even inspirational civil engineers
can admire balsa wood bridges and i work
at carnegie mellon it was so cool to see
the engineers as we called them the real
engineers walking around with these cool
little bowls with models they put on
things and put a big bucketful and see
how much of water that gets support in
it that's cool some of us sudden the
audience and heard McCready talk about
the gossamer Condor a tiny little thing
really inspirational really cool but
does it work in the real world so I'm
going to talk about the C library cuse
work who already knows way more than
they want to know about the C library q
sort who has never heard of the C
library q sort okay so back in the day
before youngsters like eric groves for
even born there was this beautiful
library function first time with a
lesson operable name it should have been
an array sort or whatever but it was
called inappropriately q circus was
based on quicksort if you went to sort
integers you define an integer
comparison function and you call the Q
source by saying i went to sort this
array a of integers I have to cast it to
that there are this many of it each one
is that big and here's the function that
compares the two
if you want to do it for fixed length
rings dust at it usually runs an inn log
in time here's a beautiful bug report
wouxun beckerson makes an email we find
that cue sport is unbearably slow that's
a bug reports not beautiful not really
beautiful that's a pretty darn good
looking bug report it's slow and organ
pipe inputs like 0 1 2 3 4 5 6 7 8 9 9 8
7 6 5 4 3 2 1 0 so before you move on
there's another really
previous slide you are going to talk
about aren't you exactly it doesn't work
for certain obvious reasons yeah if the
numbers are big and in might in the
summer of nineteen seventy-four I spent
two very very long nights debugging that
on the on a machine with 16-bit integers
there's a horrible napkin Sidious bug
that's doesn't work it usually works as
long as things are in the range but
don't most of us work as long as our
inputs are in the appropriate range so
only one we get stressed out but yeah
there is an assiduous bug there well I
or somebody smarter than I will talk
about that soon or before beautiful bug
report that's okay pretty good looking
this is great here's a beautiful boat
report here's a little program that will
run through it starts in from the
argument line it built the array and
then it calls it a sort of element of
size 2 times in and furthermore here are
the timings
what do those timings tell you
so this is clearly quadratic behavior
each time we double the input size the
runtime goes up by a factor for so this
whole thing I will argue is an amazingly
wonderful truly beautiful bug report
that contains a succinct and beautiful
bug report and a little experiment a
tiny little experiment they're really
shows that things are failing miserably
for my second experiment I wanted to see
how bad it was feeling so I added these
lines to the code exactly i did before
turn increment the comparisons by at
every comparison started off at zero
printed out afterwards here for a
thousand elements 14 to thousands takes
exactly a million comparisons wait one
second here
as we say in the math business
definition theorem proof it is you know
three data points hang the bastard it's
um it's there and in fact what we did
was we then ran some algorithm animation
to show exactly why that showed you how
to phrase the loop invariant you could
prove it that it does not randomized but
rather chooses the middle element the
combination of the petition element in
the code together leave this shape
invariant and if you run the animation
you be just see how this thing that
enough shape and during then you could
put the statements in and prove it so at
this point in the early 90s Doug McIlroy
and I set out to replace a veteran of
about two decades experience a little
bit how many to take some codes been
around therefore since the late 60s
early 70s and try to replace it our
strategy was to start simple add only
essential things use new technology and
then just test the bejesus out of
everything this test as much as we could
correctness profiling do cost models all
these torture test through as many
bizarre shapes out to see if it was well
behaved we started off by taking the
code I showed you before the two pointer
scanner code converted it into this
model it's not all that obscenely ugly I
didn't really understand it but I lived
most of my life not understanding things
can cope with that we did a field test
on it it was based on the classical
algorithms about 20 lines of code the
broken keep one was five times as big
ours was vast room for the robust it
doesn't die on anything we noticed this
is pretty reasonable however on all
equal amounts again this will run to you
greatly on all elements the old q sort
takes linear time ours took in log in
time a vigorous interesting incredibly
helpful user by the name of Tom Duff
said pastures it's not enough you don't
understand we provide predictability
what we're giving you hear what we're
offering you at no additional charge is
completely ours always takes in log in
the other one so it shouldn't take know
people sort to bring together equal
woman's to do it all the time you're
making it run way slower on a really
common class of inputs you can't do that
well he's a large guy and a mean guy so
we couldn't do it so what happens on
equalness the Sun quick Swartz go
quadratic the one I showed you some is
exactly in log in that's better but some
use linear time than predicted the
broken element did and I think a really
interesting problem is is there a
release of sync element that gives you
linear time on equal it's sort of fun so
quickly do a fast algorithm for ternary
partitioning well people have been
thinking about this for a long time like
since the early 60s and they can do this
so the classic algorithm was well you
divided into less than over here greater
than over there the equals come sort of
there but if I have three or four equals
what ends up happening is that the three
or four equal guys have to sort of roll
over like a tank tread h1 go over in the
middle and it really slows things down
is there a way that I can get around
that well we thought about that and it
turns out what was what seem more
natural to us was the following this is
sort of an aha moment but then having
them role of like a tank tread I find an
equivalent I'll stick it over to one
side I'll stick all the equal ones there
whoever finds any want to put it there
at the end what do i do i'll swap them
back to the middle that'll be cool this
will give me most of the speed but the
code still wasn't beautiful why is that
code not beautiful it's something that
all of you have been genetically
programmed for the past hundreds of
millions of years to really like a lot
what does that program not have that all
of us like a lot symmetry I mean we had
this deep genetic programming to really
enjoy symmetry and so if I make it like
this it becomes less ugly
and the final state will be like that so
I can just swap these things back if I
do that I get to this code that code is
not subtle code but this is as the for
pointers are showing you before it's
pretty straightforward its vast it has a
lot of properties at the end you swap
back as many as you need to sort of
reasonable that gave us our baseline
code it was sort of a new partitioning
algorithm got the baseline there what do
we do if you have algorithms they teach
things like well the first thing you
want to do is make a handmade stack new
quicker not only will cease use built-in
recursion no manly men real men real
stupid men always always go for their
own handmade stacks got guy Steele has a
great quote about if the user can do it
faster than the Machine implements that
then the compiler writer has blown it
badly well you insertions works small
file is well not just insertion sort any
what's to continue to do binary
insertion sort you do the smaller sub
array first that way you'll bind it down
to the login sighs you sample the choose
good version element you do sentinels
you tune the loops there all these
things you can do many of you have had
classes algorithms classes let me
rephrase that many of you who have had
algorithms classes have to any quicksort
you've seen all these things where they
sort of pile on these traditional things
and if you're working in mex boys
exactly the right thing to do i how do
here writing nicks on a regular edition
2009 if anything I trust em mix how do
you choose which ones to do what we did
was a whole bunch of experiments 1 times
of implementations and a whole bunch of
simple cost models I'm not going to get
the details but we did things like
saying ballpark here's a cost model
wherein a simple program on this machine
at this time integer operations took
that much time pointers of that much
time control fractures took that much
time all these comparison functions took
an order magnitude more what was really
surprising was that our swap function
took about another order of magnitude
more why was swap so outrageously long
well swap did it char wise it is a lot
each character so you went along and it
would write back into things whereas in
fact if you did it with a bit more
cleverness and I'd swap two ends I get
an order of magnitude speed up so by
doing a simple cost model what ballpark
two things run in we learned a lot swap
is really expensive we swapped into wise
when we can char wise when you must we
hit that all macros the canonical model
that people they knuth introduced in the
70s and people kept with it for at least
a quarter century beyond when it was
appropriate I said that overhead and
comparisons are the same swaps of what
really kills you we found out that if
you do fall properly comparisons are
where we should focus we did focus on
that
we found that choosing a partition
element was really important the typical
one of the first for the middle or
random gives you about 1.4 in log n
meeting of three beats down to 1.2 and
log in we used a variation of what John
to he called a ninth or at one point one
and log in we just the overhead from
forty percent to ten percent we
insertion sort of small files nothing
fancy a simple insertion sort that was a
pretty big win so we had these things in
here we left out all these things it
wasn't prudent then do your own handmade
stack we didn't want to sort the smaller
sub array first no sentinels we couldn't
do it for the certain technical reasons
no binary insertions warped Gordon Bell
has a lovely observation that the
cheapest fastest and most reliable
components of a computer system are
those that are there and it was
certainly the case the cheapest asked a
smooth reliable components of our sort
were the ones that never went in there a
question which is the binary insertion
sort is n log in comparisons
the comparisons are really killing good
white
oh we could have tried it but it only
gets down we only use it when n is less
than eight or ten yeah so it's only for
very small values and you can reduce it
but it's too much overhead and just
didn't seem worth it here's our complete
code and the code insisted here's the
swap macro here is this adaptive
partitioning here and here that here's
the final insertion sort here's a couple
partitioning so just take what matters
and use it we needed this it was
inspired by a real problem it was a
world champion if anyone I'm on the
paper of some applied algorithms
conferences or on the program committee
of conferences and people often still
choose this as they want to compare it
to wait is a nice theory along the way I
came up with a new tool that lets off
some other interesting algorithms some
beauties of keys what I wanted to talk
today to waste your time just to think
about the beautiful code that you've
written and thinking about this what are
some things here that was on this I'm
talking about work that people been
thinking about for 45 years a beautiful
algorithm I had the pleasure of
discussing of Tony core at one point and
he pointed out when he did quicksort he
wasn't going to publish it it wasn't big
enough to publish he only decided to
publish it when he could do the
mathematical analysis of it and he wrote
this wonderful article in the computer
journal the interface is a cute short
interface is very nice the bug report I
really like people know how to do a
succinct beautiful experiment as
wonderful these cost models it's the
swap stupid now stick comparison doesn't
knowing what the models are our
correctness tests and the time torture
test for nice and then I like the
beautiful sequence of functions in both
cases
many of us do that we start with the
program and we make it better and better
and better in these logical steps but if
you get to step 12 step 6 really still
relevant can i how can I think about
this go back and do things in this
systematic way so I've tried to show you
some beauties a question for you is
what's the most beautiful code that
you've ever written it was really fun
for me to think about and there are
different answers so if I were to ask
what's the simplest implementation of a
potentially nasty function the
correctness proof it's almost right
almost I might have one answer if I ask
what's the most definitely devilishly
clever speed hack I've ever done or
what's the most beautiful extension of
an old idea into a new domain in these
cases it would all be sunder into binary
search so it's a binary search much Josh
recently found a really interesting
subtlety a subtlety in the sense of you
know when you fall down smack your face
in the road you say ah there's a big
subtle be on my forehead a loop and roll
binary search is pretty cool and
generalizing binary search into to space
and beyond and multi-dimensional binary
search trees so they're there some
clusters here so I encourage you I found
a very worthwhile think about what's the
most beautiful couplet I've written I
encourage you to do the same what are
your questions what are your answers
there's some references there what I've
talked about here are three beautiful
quick sorts i hope the first is it's a
simple teaching tool a dozen lines of
code the second is trying to make the
point i think this is the most important
point about adding function by deleting
code that's something where I tried to
tell this little tiny story in real
stories you can sort of hear it talk
about it no around the lunch table where
you get these things where we're really
makes a big difference the action there
is not in dozen line programs i ate it
for during crete nests with a dozen line
programs get it down to zero and made a
continuum from code to mathematics but
the real thing is it's adding function
by doing code and finally I gave you a
brief history of an industrial-strength
you sort that seems to have made a
difference parting platitudes strive to
add a function by deleting code and make
everything as simple as possible but no
simpler I wanted to stop when the big
hand was right in front of the 12 and
the big hand right now is pretty near
the 12 any questions any anything else
we want to
I'm sorry but three things King one is
that your QR code is actually really
what serving modest weeks it's still
kind of widely in addition to the
faculty steel in odd you know it's
platforms it's also standard from the
sorting Java that I just took John's
code and so but I didn't give it credit
second thing is he said q so it was kind
of beautiful interface I have equivalent
that because the tri-valley comparison
function error-prone and which is e
towards fix or we may be really want to
use merge sort it would be cheaper to
have to value just no less a little too
or not actually less than or not if
you're doing murders so so I kind of I'm
sorry that in job I didn't allow that
choice oh and finally you know this
business about as simple as possible but
no simpler I don't believe Einstein said
it I actually have spent like maybe 20
hours trying to find out you know I i
I'm good through like this number one
thank you number two you're right down
on I agree number three my boss now is a
guy named dave weiss who was talking
about someone s RI and say it seeing the
same thing about designs i never say it
and the sky at us right said well i
think he said it because i heard him say
it so i don't know if it's ever written
but at least I i can give you the back
pointer to my boss dave weiss and
adjacent to two wice at avaya com he can
give you the name of the person that
said I I think I intense etic as i heard
him say it
had some leverage Congress research yeah
and again that that's totally consistent
with this but Weiss at avaya com had
this wonderful story so boy a comment
like that's going to be hard to follow
but thank you yes maybe anything else
thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>