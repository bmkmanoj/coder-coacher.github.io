<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Assertion-based Repair of Complex Data Structures | Coder Coacher - Coaching Coders</title><meta content="Assertion-based Repair of Complex Data Structures - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Assertion-based Repair of Complex Data Structures</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/q2-P0dlcYoM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so today i'll be presenting a
surgeon based repaired complex data
structured this is part of my thesis
work at the University of Texas at
Austin so let's start so and as an
introduction so data structure
corruptions are the bugs that reduce
that is the real liability of programs
now program is always used as surgeons
to check the validity of a program now
what happens if a program if we have a
violation of an assertion the additional
approach is terminated the program d
bucket again and run it again however
this approach although like it's used
sometimes it even doesn't work because
suppose you have a file system with
corrupted data again you will have the
same violation every time every time so
even if you debug Utley executed if you
have persistent data you might fail
again so I'm going to propose like a
present a new approach for handling
these violations and this approach is
Ripper so instead of an assertion the
checking for the validity of the state
of the program how about and a search in
checks the validity and if the if the
program has something wrong in its state
a trip urgent and how do you do that so
the new debt so the new approach for
handling this violation is repaired
repaired the structure the underneath
the program state continue the execution
and report that evaluation that's the
now how to repair these structures we
will see soon a brief background what
are these complex structures that we are
talking about so most of the programs
use complex data structures for example
red black trees intentional naming
networks or software caches these
structures have like special constraints
in the for example red black tree all
and all the paths should have the same
number of black nodes and an intentional
naming system and naming networks we
should not have any cycles in the
software cash you should have like
collect a correct hash table and you
should have the correct doubly linked
list to keep track of which is the least
recently used item in the cash so these
complex properties are the ones that are
going to be violated
they might cut up the program any
violation of any of these properties
might cut up these programs now what
differentiates one structures from the
other well these are called the
structural integrity integrity
constraints and these are can be grouped
into two parts the first part is the
structural characteristics for example
you can say like a linked list is a
cyclic or like a doubly linked list
should be circular so this is all about
the structure the second part which
differentiates them is the data
characteristics and for example in a red
black tree or in a tree that the values
of the items inside the tree should be
ordered now how do we check for these
characteristics using a surgeon's now
these assertions can be written or the
description of these characteristics can
be written a declarative language for
example the lots of languages like alloy
Z a s and L these languages are
something that use first-order logic or
it can they can be written using an
imperative language and by imperative
language you means i think that the
language that we use for our coding for
example Java C sharp or whatever we are
using now how do you describe these
characteristics these characteristics
using Java we have a method that returns
a boolean and the check simply traverses
the graph of the heap and checks for all
these characteristics now for example
for the binary three of eight nodes so
given a binary that has a root and the
size and the left and the right element
for each node a method rap okay which
returns a boolean simply checks for each
of these characteristics for example if
the root is null the size should be zero
any time you hit a visited node then you
should return false any time you hit a
visited note while traversing the right
branch you should return false or if the
number of elements inside the tree is
not equal to the size value of the tree
you should return false now repaired
performs the following it takes this
report a description and the perverts is
set to see if you have an underlying
three and if not it will mutate the tree
to the pearly to become a valid binary
tree so what does it mean so
structure or any program state such that
and the class in value in cap okay that
describes what should what is the
underlying state if we have not asked a
cup of K which means if there is a
violation in the program the report will
mutate as and will generate as prime
such that as Prime dr. Polk returns true
now is this the intended behavior of the
program no but it is a state where the
program can continue and my not crash
because of a corruption inside the data
structure so for example if we have such
code of structure so the side we have
the corruption in the size we have a
corruption in the right field over there
and to hear repaired will take this
structure and generate that one over
there however that might not only
generate this one there's another
possibility because who said that this
node here is the corruption because
maybe this is the corruption and you can
generate another theory that is valid
but it's not the same one that the
program intended to generate so what I
will be pairing we repair falls in the
structure and we repair falls in the
data so in the previous example we had
falls in the size number and we have
falls in the structure so we have two I
two things to repair and two things
might get violated during a program
execution which is the structure of the
underlying heat and the data that's
found inside so to repair this to repair
the data use an approach called symbolic
execution and symbolic execution add
I'll give an example about symbolic
execution soon and for the structure for
structural integrity constraints we use
a systematic search which has been used
for test generation I'll also to grab
described soon so symbolic execution
what is symbolic execution symbolic
execution is a technique that the runs
the program on symbolic values and not
conclude values this thing has been like
this since the 70s and been used for
testing purposes because it reverses all
the paths of the program and generate a
condition that says to go into this path
which
have this this these conditions on the
input if you want to go to another path
these you have another conditions on the
input for example so let's take this
simple program if a concrete execution
with X equal 1 and y equals 0 will first
check is one greater than zero we'll go
we'll take the F statement executes X
and execute why find X again check that
yep its neigh- one is not greater than
zero and terminate whereas symbolic
execution does not consider values it
considers x and y as symbols and it will
start by X equal big X Y is equal big y
and check if x is greater than Y we
should go this way if X is less than Y
we should go to the other path and as it
continues executing it just updates the
symbols so if we see her that it either
goes this way and ends or goes that way
and execute all the statements when it
hits another if statement it will either
go to the left or to the right at the
end it will generate three pass
conditions in this case if X is less
than equal to y 8 30 minutes if x is
greater than y however the difference is
less than or equal to 0 it will end with
it will assert false and the third
condition will terminate successfully
why do we need these so if a program
terminates because of a corruption in a
data value and it should the rep ok
should return false so symbolic
execution will give us the condition so
that rep ok does not return false one
snap ok does not return false we can
generate the correct data values that
will allow the program to continue a
systematic search now to repair the
structure s we first execute cap ok we
need to see if maybe the structure is ok
so replica will tell us that the
structure is fine or the structure is
faulty we execute their pocket and we
monitored how are we accessing the
fields once once kept ok return false
then most probably a field is corrupt
and we need to repair it now how do we
repair this field we look at the last
field that we visited
and we modify it how are you going to
modify it we modified and will execute a
rap okay until the porchetta turns
through now how do you modify these
fields if the field is the data field we
change it into a symbolic value and we
say okay this field was five for example
and we had a corruption in the structure
and we we just know that okay this field
should not be five if we have a
reference field axis we not
deterministically mutate this field to
first as the field tunnel and see what
happens look at everything that we saw
during that revert sort of wrap okay and
see what happened and we choose only one
new node and only one new node is the
trick here because you don't have to
visit everything in the structure you
only need to see one unvisited known and
that sufficient sufficient to generate
to check all the isomorphic structures
that you can see so let's take an
example of the binary again so let's
look at this binary tree we first
execute your pocket and on this one so
first of all we visit the root node then
we visit n 0 and 0 dot left we visit n 1
and once we visit a right we notice that
whoops we visited and one earlier so
there is a corruption in the structure
we note that hey we visited root and
then we looked at left and then we
looked at rap and we triggered our
deeper program what does the repair
program do it will backtrack on the last
field that we saw which is the diet
which is the right note and what's the
first choice to do since the right-field
is a reference field it's not a data
field the first choice to do is set it
to know it sets the field tunnel and we
have this structure good at continual
and the execute strap okay now of when
we execute type okay again the structure
looks fine because it will check route
okay route is fine left is fine we don't
have any right node anymore so
everything is fine it hits the data
corruption oh the sizes to the sizes 0
however the number of elements that I
visited till now is too
so what do we do in this case change
this thing into a symbolic value and add
the condition that will allow that will
not that will may make rep okay return
true so what's the condition the
condition here is size does not equal to
so the path condition is not size does
not equal to you send it a constant ajit
constraint solver and in this case is
very easy to return size equal to and
modify it in the structure this and we
execute their pocket again on this one
and there you go the program will
succeed another example another example
a doubly linked list now suppose this
Excel suppose you have this doubly
linked list with the corruption not the
n3 now what do we do in this case and
three the node coming out of nth the
next the next fields coming out of n 3
is caught up and it's a reference field
so the first thing to do is we try not
and it fails try and one with don't
always remember we have to try
everything that we listed earlier
because we might find the solution early
on without trying a new field try n 2
didn't fail didn't succeed try n 3
didn't succeed try and fold and the
structure is Ripper so if we keep
following this approach this approach is
complete I it will find a structured for
you if such a structure exists however
if you notice that this is all
controlled by the way you write this
setup ok method so if this wrap ok
method is unsatisfiable from the
beginning so if the report a message
simply returns false then that's it you
cannot do anything you cannot repair the
structure so we thought we make the
assumption that the user provides the
rep ok which describes what the
underlying structure and the program
mean so having spin about that how did
you perform our experiments well we
generated a set of valid structure of
different subjects and I'll show you the
subject zone and we block all the
structures by injecting faults that take
all the integrity constraints for
example in EE linked list we break the
circularity constraint we may
next does not equal to previous we make
next point somewhere else and then we
take it out the pedal teen and run the
program that's the first experiment the
second experiment is we had used a
software cash and in this software we
lend us a faulty software cash and we
then the system on like a system that
uses caches we simulated the
microprocessor and every time we had
default and the program a null pointer
exception was being thrown if we didn't
have our deeper routine this thing will
crash so with our the patina to deploy
itself and the program continued however
it provided a log that okay that is a
problem in your program but it
successfully continued this time check
it out and fix it so instead of crashing
you deeper so the performance of this
approach is as follows we tried it on a
set of a bunch of data structures and if
you notice we can handle structures with
hundreds of south of thousands of nodes
with like almost 20 falls within 10
seconds and even like complex structures
for example the file system in 15
seconds and intentional naming system
and 9 seconds so the performance is
pretty good however if some we if more
faults exist end up in the pro in the
structure then the performance might
grow quadratically not linearly as we
see here but we expect always that once
we have bugs in the structure the
program is most the once you assert that
and check that the program is fine you
will be able to catch this bug earlier
on so that's why we expect lower number
of faults than like between 0 to 20
false go to appear in the program that's
in the buggy program before catching
before either crashing or triggering all
the proteins so how hard is it to write
these assertions now the de / idea is
not new and it's been there since the
60s or the black ones they started the
computers so once you have an
application and if you need to increase
the reliability of the application you
write a specific routine
that reports this application for
example FS check disk which like checks
file systems so once you have a tree in
the file system before third meeting the
computer you will end this view over the
file system and fix your file system so
these were the but what's the difference
between our approach and the approach
that that was look all that approach
always use specific routines to repair
the structure so to use the deeper you
first you need to inspect all the bugs
that might occur in the end up structure
and then write a repair routine however
in our approach we don't use we don't
have any specific code specific for
repair routine we only have the
description of the structure which most
probably will be there because you this
is the spec so there are lots of other
language for example other languages
like GM L which you can describe your
red pocket in the same way which you can
describe you what are you doing in this
structure in the same way so what so
most programs have these rap okay
methods in them or have some method to
check the validity of the program so
this and this way it comes forth free
another point is like for example any
red so the properties of a program are
known you while implementing the program
so it's easy to write it up okay however
efficient prepared routines are not so
you have to see what bugs can occur in
the program and how to repair them so in
this way we can writing an assertion is
pretty easy like we load a surgeon's for
more than 15 benchmarks and basically
writing apps a surgeon as a simple
checking of the properties each one took
around like 15 minutes or 20 mins to
that I'm searching for the program know
how efficient can how efficient can
repair be so we looked at the problem of
generating one repair is basically the
problem of moving from the structure
that you have to generate another
structure that satisfies the conditions
so there have been other tools for
generating large data structures for
example esta for example karad and
tester are two tools for generating data
structures from such description so you
give them the description they generate
all the data structures that you want
these tools proved efficient for small
structures and since we are only
generating one and we expect the fault
to be in the neighborhood so expect the
distance between a faulty structure and
a non-faulty structure to be very close
then we our deeper duty that's why I
would repair 13 was able to handle one
thirty three thousand structures with
130 thousand nodes and less than like 10
seconds applications of repair now we
look also at how to apply this sole
repair this fine it can repair the
structures and let the Machine continue
now how what are different applications
for the third one is generating a large
data structure so since we know how to
repair data structured but however we
don't know how to generate them given
just the description like give me a data
structure that's a cyclic and the nodes
are orders well we can easily generate a
random graph which we don't care any
what is this data structure and around
this rep ok on it every time it will
return false it will keep repairing it
until they generate something in you and
this idea was also like public or will
be published in August so that's another
use of Reaper another another way which
was investigated by a colleague of mine
which is repairing the program so if I
know that this program this this doubly
linked list is always failing because
the next field is not equal to the
previous field that most probably the
underlying program has the same property
and how about translating these repair
actions that we do into actual Java
statements and plug them into the
program so automatically generating the
fix now how good is this we've tried it
for simple data structure we haven't
looked at very complex data structures
for this one because like it's tricky
how do we know that the next field is
not equal to the previous or the
previous is not equal to next which one
to assign so it's very hard to know how
to generate the Java code to the / to
like how to generate a fix for the bug
automatically by looking at the
violation but the first the idea is this
so we're still investigating it so
related work as we talk as I told you
earlier that fault tolerance error
recovery have our featured in software
systems long time ago first most of the
past the program's use these specialized
routines so fsck or the IBM and the S
operating system the Lucent 5 ESS switch
which is a phone switch also use
continuous to use these routines every
time that's why it never breaks because
every time it place it repairs itself
and continues a decent working tooth out
2003 was by them scan Ronaldo chart at
MIT and what they did is instead of
using Java like we did for example using
their pocket and execute this rep okay
and check one will it return false and
when it return false to repair the
program what they did is translate the
program into another language so they
have a compiler that takes the the
program which is written in C or C++ and
translate it into another language
analyze that language repaired up repair
the structure over there and send it
back to the program so it generates the
repair routines that are similar to all
to those that are there so given a
program you feed it the program it will
say okay this program might fail heat
heat and the and these are the routines
afraid so these guys like I think they
want best paper award and the academic
community like this idea very much so
that was again a motivation that since
they do it in declarative language it's
easy to do it in an imperative language
because usually the programmer is
writing Java and not any other new
language to model the system so
conclusion what we have here is a new
view of a surgeon's so you usually say
if you say a setup ok right now you
check the validity of the program
however if we say it up a search our
pocket using our framework it will check
the program and if it fails you repair
the program so now we have a way to
repair the program similarly the same
uploads the same algorithm can be used
to generate that
just so we can generate data structures
to test our program and we can inject
this framework inside to repair the
program in case anything miss the
testing and the biggest conclusion is a
third first programming and always right
as surgeons to check to describe what
you are writing in the code and like all
the academic tools that other use these
descriptions to generate tests for these
structures so once you know what we know
what is this what's this called doing in
any way any language not necessarily we
use imperative languages any declarative
languages like gml can be used to
generate unit tests automatically so
most of the test automation test
generation is easily performed if we
have a way to know what do you intend
what do what's the difference between
the police state and the post state when
you call this method or what you expect
the data structured always to be so we
expect the hip always to be in a tree
like once we have this information we
can easily prepare the structure and we
can have more reliable systems now
comments on implementation of the
structure luck how did how do we
implement a reaper I don't have this in
the slide but like I'll describe it
because i thought i did shorten time so
how do you implement this Ripper so
given the Java program the Java program
is translating the bytecode so we take
the bytecode and every time the program
accesses the field or the data value we
change this access into a method that we
provide so instead of F dot next or n0
dot next we say n0 dot get repaired next
which is a special method that we
provide which keeps track of what feels
that we we did with writer now and it
can mutate the fields to like to apply
the same algorithm that adjust the scrub
so once you he's you see a violation we
already keep track of everything that
happened the system we can easily mutate
the field to all the previous stuff that
we did also a new things that we expect
to happen and any questions
okay how this is this to be using
conjunction or to the exclusion of
test-driven development ok so this as
you noticed we don't need any
implementation so ok let's start by the
applications of this thing so the last
slide which I talked about the
application of this repair thing which
is to repeat to generate larger data
structures so the refugee need to
generate larger data structure which is
somehow similar to test driven
development swear you generate your test
inputs before even writing the
implementation and you don't even need
any implementation to do that however
for the / you also don't need any
implementation to do that but still the
bug the source of the bugs is from the
implementation so if me if you need to
use it for test generation this is
perfectly for test the driven
development and if you need to use it
just to the patio program you need the
program to the bed right so that's so it
is like highly related to that thing and
that's how we actually that's how we
motivated the other approach luck we
just need the declaration of the
structure and we need this rep okay
method and there you go we can start
generating tests automatically okay so
just again relate to the application of
this you said that you're repairing was
non deterministic right yeah so I mean
aren't you scared that this could lead
to programs that we repair themselves 99
out of 100 times perfectly but then one
out of a hundred times exactly let's
that's ready like that oh if I'm writing
board for a Mars rover 99 times on earth
it's gonna work and that when it
actually goes to Mars okay it so this
brings us to the points so first point
is completeness of the algorithm that's
the pairing okay so maybe this this like
march over will not crash for like this
99 times on earth but like it will crash
this one time and the deferred routine
is complete ie if it can be repaired it
will repair it so if there is a bug and
rape okay itself
the repair team will not prepared now a
more tricky think that this approach is
like ken has should the hand if
carefully is data like although I we use
symbolic execution but I can't take a
binary tree which has the values 5 10 20
and which are in a different order and
they put them by putting values 1 2 3 so
we don't want to lose the data we need
to reorder the data and that's what we
face the problems where we need to have
some way from the user to tell us that
okay do not change this data just try to
reorder them and once this is given we
can do that but for the completeness of
repair f3 poker is that incorrectly the
program will be repaired at least a data
structure underneath will be using law I
know your program won't crash when we
have been risk introducing logical
errors because okay so but think of it
this way so the program expects a valid
structure so for example assume like you
have a delete method so the delete
method expect a binary tree with some
values and its output as a binary tree
but missing one of the values that you
wanted to delete so what we're doing is
initially we didn't have a binary tree
we reorder the values and we order the
structure to be a binary and apply the
delete so what we're doing with not
changing anything with the logic we're
changing the structure because you are
expecting a banana tree but you are not
expecting a specific shape so we are
changing it however if we change data
there that will be like a problematic
because you're expecting some value to
be there but it's not there and however
sometimes if the data itself is
corrupted we can do nothing can i
generate any new data we can isolate the
data but we cannot do anything for
the triplicate say you're missing data
or the data is corrupted yeah you would
end up with a period of days so what's
itself yet they also kind of depends a
lot on how well the Replicators
read/write you you want like the get
more importance assertions to come first
right hey exactly excited if there's a
surgeon like no this must be three or
something like that yes yes I can't be
repaired if you can are you going to
like generate and Oh to make sure that
yeah you can do that so it just just
adds like some red yeah so that's that
that's the thing so we can so take take
another example which we faced which is
suppose this there's something something
some something happen with that each
ability of the structure so you start
with the linked list of 1000 nodes and
the corruption happened at node 9000 and
the rest of them are garbage collected
so you can't get these notes anymore you
can't get the data how to repair this
you cannot but what we can what what we
do is cut the linked list with this
number of nodes that we have so it is
still a linked list with the values
inside it and continue or we have a
configuration which sells at the random
nodes with this default value but like
you cannot just guess what's the next
one now we are planning on extending it
okay predicting what's the next value
from the other values but this like
doesn't meet our goal which is trying to
repair the program rather than
predicting what can go there
sorry we intercepted every field access
not just once so you should know okay
okay so so in this example we need to
know what is the last field that we
accessed so that we start creating it
and maybe the problem is not in the last
field maybe the problem is in the field
before that so we have to try everything
for the last field then we'll go to the
previous one change it and go back to
the last field and try it again what
field you touched yet because most
probably the violation in the structure
is because something that you tried
earlier or something that's gonna appear
in the future and that's why we also try
one single visited node okay now that
depends on how okay so this is a program
okay let me say I will send you again
the paper which we discussed this issue
very much like and we have experiments
on how if we call it with every garbage
collection if the program is most
probably is not going to crash and you
check it with every garbage collection
then you have a higher overhead then if
you're checking it once you call a
specific method that you expect this
method might be buggy or like somewhat
in the program some some part of the of
the program that you need to be very
highly reliable that's where you assert
but any word like you need to know when
to assert right so this the the repair
routine triggers when you'd call a cert
Rep ok but when to call the assert you
can have a conservative approach which
you need the system to be highly
reliable so you check it like with every
garbage collection and all the
experiment we checked it on every time
we throw an exception the system throws
an exception we check it and if we can
find the falls from the cache the
exceptional continue somewhere over here
someone had question
more question I think he had question
but he's working right ok so that's it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>