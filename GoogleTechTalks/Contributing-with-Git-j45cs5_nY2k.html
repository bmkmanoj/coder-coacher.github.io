<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Contributing with Git | Coder Coacher - Coaching Coders</title><meta content="Contributing with Git - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Contributing with Git</b></h2><h5 class="post__date">2008-10-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/j45cs5_nY2k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">today for the next couple of days Google
is hosting a get developer conference so
we are quite lucky to have a very large
majority of the get development group in
house and one of them Johanna shanlin is
going to give a talk about what leaf
contributors work like with get and I'll
let me honest talk with this one and
nothing else hi there thanks for having
here by the way if anybody has any
question please do interrupt it's no use
if you're just thinking of pondering
some stuff where I go on and on and you
lose the track so today I'm going to
talk about how to efficiently kanji
contribute to projects using the
software as a source code management
tool get first a brief overview I will
tell you I will motivate why you need
version control then I will give you a
short introduction to get then I will
show you how to submit patches and then
go on to more more details more
technical subjects okay so version
control why would you know why would you
need it how would you do it and what
would you use for that usually if you
develop something you have certain
revisions and from time to time you want
to keep a certain state that you can
recall why would you want to recall it
the number of reasons why you want to do
it you want to maintain stable branches
so there might become new features and
those are in the main branch but you
still want to have bug fixes for for
older versions that people rely on and
you also have to make patches and it's
much easier if you have defined
revisions if you want to give somebody a
patch that give that makes out of
version of 10 version 11 if you have
both versions in the same system it's
easy to generate patches of course it's
also to document changes when it
you make it fix or whenever you add a
new feature you want to explain why you
explain want to explain how you want to
go about that so that everybody is more
likely to understand the patch what it
actually does by having the ideas in
mind also it is very important to be
able to attribute good or bad changes
when when you find something that works
not properly you want to identify what
happened and going through the wholesome
source code is not really realistic so
what you do usually is you go back a few
revisions to test and you go back as
much back as you need to identify at
which revision this regression of this
bad behavior came in and also you want
to use source code management version
control to cooperate with other
developers so you have a small team
somebody does something and you want to
get those changes into your own working
directory so you use version control the
guy who does it pushes these revisions
on to a central space and you get it
from there okay how to do it I'm mainly
talking about the command line today the
command line is the original interface
for get there are a few other add-ons
programs that use under the hood these
commands but those are not i'm not
familiar with them that's why i'm not
talking about them so the common
commands are something like get space
and then subcommand and it may have some
options which usually start with dash
dash and then it has some parameters you
can commit changes make new visions that
is you can inspect history and you can
do a lot of things with that a few of
which i'm going to talk about in the
next few minutes of course version
control is not get there are other
alternatives there are options for
example if you have if you don't need to
cooperate with other deaf
you can have purely local solution which
is our CS and friends you can have a
central repository which basic means you
have one one place where everybody has
to publish the changes that are official
which means you also have to have the
permissions to access that repository in
a right fashion and you have distributed
repositories distributed repositories
means basically that everybody has his
or her own repository and they can they
can push and pull from each other they
can exchange their modifications those
are only examples it's by far not a
complete list but this is just to give
you an idea what I'm talking about okay
a quick start in ticket first let me
start by explaining some words to you
some terminology because it is often
confusing to hear some words that you
heard may be working with subversion or
working in a totally different field and
you don't know what I mean so a commit
is a noun describing every vision that
has 0 more parents revisions that has an
author a committer and a message the
message should describe what the change
is about should motivate motivate why
you need it and should explain the
technical difficulties that were
encountered so that others don't repeat
the errors and of course the content
that is a tree which contains other
trees or blobs that represent files or
symlinks of course trees are not
directories trees are just a
representation that could be understood
in the way of directories but the
working directory actually can have many
many more files than what are and gate
if you have C programs you compile them
into object files those object files
should not go into this version control
because they're generated out of the
source code so trees are not directed
and blobs are equally not files files
usually have a name and the blobs are
just the contents so if you rename a
file in get everything you do is change
the tree but not the blob okay in order
to efficiently work with it you need to
have pointers you need to know where you
are at so these are called refs those
are just pointers into the so called
comet graph the commit graph is what I
depicted here and the pointers just say
you are at this revision these pointers
can be tags tags should not change at
all they should stay the same so they
are non moving as well as opposed to
branches which point to a certain commit
and you can actually add another commits
moving the pointer to the new revision
if I call if I talk about revs with a V
instead of F then those other revisions
actually the revisions are there and
they are immutable they can be
identified by their contents and those
are basically big boxes to refer to them
there's a special syntax oh you can for
refs that are Rebs you can use the name
like master which is the main branch
name and head is the special riff for
the current the current branch this is a
special ref it points to another ref so
it's a symbolic breath if I want to
refer to the parent of stable then I add
tilde one if I want to refer to the
parent of the parent I say till the two
and so on of course I can do that with
all the ref name's not only stable which
is the stable branch master can do it
also with the symbolic riff
ok now let's let's do something let's
start with get usually when you start
with bids somebody told you oh I have
this cool project you might want to
check it out you just have to clone it
so you do that you get the edge of the
address of the repository of the public
one and you say git clone of course
after someone sometime when you worked
enough with get and you're comfortable
and you may be excited about it you want
to start your own repository without
having a point where you can clone it
from so you initialize in the current
directory with get in it that just adds
rudimentary they are repository which is
empty as of yet which has no branch
which has no revisions but you can add
them as you go if you just want to track
a remote repository you use the pool
command the pool command just downloads
everything that the other side got in
the meantime since you last pulled or
cloned and it will integrate these
changes in the working directory so that
you can stay on top of some other
project you can look at what happened
with with two different commands
actually with many more but these are
the tools that come with mainstream get
the one is command line based and the
other one is graphical it uses tickle TK
that is the one thing that is not
command line that I'm going to present
today so get log would look like this
you see the commit with an internal
reference which you can take in in place
of these master or master tod two names
that I mentioned earlier then you see
the author you see date and you see the
corporate you see the message the
message is actually cut off but that's
only because my window is too small get
K would look like this it's a little bit
intimidating first but it's not really
that hard to read
basically you have a list which is just
the same as get log you have some some
call it nice graph on the left side you
have all the information that you ever
would like to know about to commit and
you can actually click on one line and
you get more information like the the
commit message in the lower left window
and in the lower right window you will
see what happened one what files were
touched and if you click on those files
you instead of the commit message you
see a diff so that's good to inspect
what happens in since the last time that
you actually pulled now if you want to
do your own changes in the repository
then you can update or add files it's a
little bit confusing to call this get ad
but actually the main idea of get is
that content is king so if we say we add
we also add another revision another
revealing of contents so that means even
if you already have the file read me in
the repository it is not the same
because it has different contents so you
added in order to commit a new revision
what you do with it commit command this
fires up an editor we provide
information usually as i said the
motivation behind the change and
whatever technical the discussion you
need to add to so once you do the commit
because that's your local repository and
nobody else can see it yet so usually
you have some public place way push it
to and if you clone from there then you
already have the shortcut origin where
to put a way to push your changes to and
you also specify what you actually want
to push their in this case is the most
recent changes to the current branch so
these are the commands that are the most
important commands if you ever want to
work with get as to initialize to clone
to pull then look at the history with
get log and get k and then too
to make your own changes with get add
comment and commit and to publish them
with push now if you commit then you
don't want to commit something that you
forgot to remove so you want to inspect
first what what was happening there I
had some some debug message and I wanted
to remove it but I forgot where it was
so you just look at the differences of
the working current the current working
directory as related to head to the
current tip of the current branch or if
you have already staged added some some
changes with git add you can see just
the changes that you did after the last
get ad with git diff or you can see what
will be committed if I hit called git
commit now with git diff cached of
course you can also do other changes
like remove actually our remove remove
the file too because if you'll remember
c.d.s you had to remove the file first
with RM and then you could remove it
with CBS RM that was deemed not really
appropriate we are we want exactly we
don't we know exactly what we are doing
we want to remove the file then we want
to remove the file we can also remain
very name the file actually this looks
as if it would record renames explicitly
it does not envy is just a shortcut to
remove the file under the current file
name then added under another file name
and move also rename the file in the
working directory this is just a
shortcut for convenience some people
prefer to do it by hand I like that
command but it does not record the
rename as it as it is but you have to
generate generate from the data what you
have from the history what every name is
yes
ok the question was if I can see the
diffs also over renames yes there is a
special mode to log which says that you
can follow renames unsurprisingly it's
called get log dash dash follow but due
to technical reasons it only can track
one file so you have to specify which
file you really want to see the changes
of which file you want to follow through
the whole history yes if you what if you
move move a lot of files get lock dash
dash follow for technical reasons as I
said yes it breaks down if you specify
more than one fire that doesn't even to
work well it depends so it's a rename
detection usually the problem with
renamed detection is that the files have
to be similar enough so that it actually
can derive yes this was remove renamed
some people I try they say okay I want
to see if it works they add a single
line as a file and then they rename it
and they change that single line the
contents changed completely soaked it
says there was no rename in that case it
breaks them but if the contents are
similar enough it works we can look at
the data other questions yes
okay why doesn't why doesn't get have
explicit renames it has been discussed
quite a lot on the gate mailing list and
basically in the end the people that
actually do the development and get
agreed on the fact that most people are
not as accurate as they want to be and
they forget to label that and also it's
a redundant information if you all if
you really do a rename a verbatim rename
the information to detect that rename
already is there so why bother just
adding another metadata to describe what
you know already and there's a third
thing some renames are not renamed you
might start out with say say you have a
java class and you want something
similar but different enough but you
want to start from there so you just
copy it or you rename it in the case you
don't need the old class anymore and it
changes almost completely you just keep
the skeleton then the explicit renaming
would record a rename which is not true
at all so basically we decided in the
end that recording renames explicitly
it's not worth all the hassle that you
get with it rather have it work for the
most common cases where you have
verbatim renames or renames where you
just change one or two lines and let get
just detect it does that answer your
question
actually what you could always do is you
could enforce for your project that the
fact that you renamed a certain file is
recorded in the commit message either
the visible part or even the invisible
part if you so decide and then you just
use your own tools to extract that
information and use it that's possible
so there is no technical reason why you
shouldn't record the renames it was just
the agreement of core developers that
it's not worth it okay good so in order
to inspect committed changes as I told
you already we can use git log you can
see the messages but you cannot really
see the changes you can also all only
see the reasoning behind it but of
course you you can do that with get to
it when you specify the short option
Dash P to log and in this case I also
added a parameter that describes a
commit range you can see interspersed
between the commit messages also the
gifts that are associated with that
commit a word of warning if you see head
till the two dots table you usually
think of a linear range so the
grandfather or grandmother of head until
stable that it those are two commits but
that need not be true if the parent was
emerged already then all this does says
everything that is contained in head
dash had till d2 and its ancestors are
uninteresting to me don't show them to
me but if in stable there there are
actually merges which taken whole side
branches then you will see those side
branches to that's to keep in mind if
you use commit ranges you can also show
a single commit that would be just like
git log
for 141 commit you can also use the show
command to actually inspect certain
parts of the commit if you say kid show
head Colin read me that means that you
want to see the contents of read me of
the file read me as it was recorded in
the current tip of the current branch
okay to summarize you can see changes
with git diff you can manipulate you can
bring move and rename files with iron
and v it can inspect the log with dips
with log Dash P and it can use show to
look at comets and blobs this is just a
very very rudimentary quick starting to
get it can do much much more but first I
don't want to confuse you and second I
don't know what you need I don't want to
describe something to you that you will
never need ok now let's let's go to the
subject of this talk if you submit
patches so just imagine you are
contributing to a project take it itself
you will clone the repository and you
will work on it you will make changes
you will commit them and then of course
you you're nice people you want to know
that you want to have all those people
out there in the world profit benefit
from your patches so you submit them get
provides the command format patch the
first one would say I just wanted to
commit to submit the first patch the
last patch that I did or five patches
the dash n means that they are numbered
so the subject will say patch 10 52 or
53 or five and then you can send them
off with get send email so how would it
look like if you called former patch
with a dash five dash n you would get
files that are named 0 0 0 1 2 with the
first line of the commit message
slightly modified so you
get spaces because spaces in filenames
are evil and the extension is Dogpatch
and the contents would look like this
it's more or less the mbox format
because it stems from the mbox idea that
you get your patches in your inbox and
you you put them also into an box to
send them off and in this case you see
when who was the sender the author and
when it was sent for in this case when
it was actually committed the subject
and you see description with dash dash
dash and short diff stat that shows you
which which files were modified in and
which what number of lines were added or
deleted and then comes the actual diff
and you could send it off with send
email like I said you could also
maintain your own repository if you want
to submit the patches to the upstream
for example by having an own repository
there are many many places where you can
have your own repositories in the
internet most of them are are also able
to have Forks so you have one project
there and you say i want to this
project i want to have my own repository
which however has most of the same
objects the same commits the same file
revisions as the original one you could
also post bundles that is especially
true if you don't have a mail program
that copes with white space work very
well because white space damaged ifs
cannot be applied easily or you could
publish it via get svn if you are
unlucky enough to only have a subversion
repository which is public okay now the
question is if you submit patches those
patches get reviewed but what to do with
the comments with them so some people
say ah I would have done this much more
efficiently with these two lines in
instead of your hundred and you say own
that's quite a clever idea so let's do
that what you do they're usually and get
is you have a topic ranch so for
everything that you want to submit to to
the official project you have an own
branch a side branch and this branch
looks more or less like this so you
started after a certain revision was
published from that revision you do so
you make some some change on the
framework that you need in order to
implement a new feature and of course
you could format patch exactly that send
it off oh yes I wanted to explain how to
do that actually with commands that's a
good idea so to start a topic branch you
need to check out command and you
actually specify what the name is that
you want to give this branch if you
already have a branch then you can
switch to that you can also branch from
a certain point in history that is not
the current revision okay so what you
can do with branches and what you have
to do with branches is you have to shift
changes back and forth from one to the
other so i will present you two methods
to do that and get as cherry pick and
rebase what's the cherry pick you are
on-topic branch you have a new feature
and you co the upstream has a type of
fix i want to have the type of X I so
have to need to have this type of fix
otherwise I will die so you say cherry
pick origin master to the one which is
exactly that commit which have that type
of fix and this will apply the changes
the diff of that that commits it will
keep the author but it will now record
you as committed with a new committer
time sometimes you want to do more than
just cherry-pick you want to really you
want to transplant whole branches or
commit ranges then you need rebase
rebase means you have
the topic branch framework new feature
but you want to put it on top of what
the upstream has now which was the
version 20 in this case first go to the
topic branch and then just say three
base on to origin / master I was easy
enough so to summarize you start new
branches with checkout dash B you switch
to them with check out you can
cherry-pick and you can rebase comets
does rebase throw away or history to the
to the other people yes no it's not it's
not gone locally it is recorded in
so-called ref logs so ok let's go into
that the history is not the history
there are several histories out there
right so for example one is the commit
history that's what is recorded inside
the committee it says exactly what is
ancestry was and because all the merges
and so you have a very defined state
there but of course it didn't happen in
your local repository and your local
repository that at each time each point
in time you had a defined state that was
your head at that time and that is
another and then another type of history
of the Comets right so for example you
did a rebase an hour ago so an hour and
one second ago now five seconds ago was
a different state a different revision
and this is history as seen in your
local repository and read flogs actually
let you specify that revision history
only locally it's also important that
it's only locally because first of all
if you by mistake committed some trade
secret you don't want others to see it
or more commonly if you just made some
stupid mistake you don't want others to
see
that either so you have it in your
history you can see it others no okay
but I didn't prepare any slides with ref
logs so you would have to read the man
page which is actually not that bad yeah
reflux is a wreck history is also very
easy because it's purely linea unless
your time travel okay let's have a
complete concrete example how to split
patches say you send off that the patch
series of to the framework and the new
feature and then somebody said what that
framework thing that is way too big it's
500 kilo about kilobyte patch I won't
review that so why don't you go and
split it into two things because
logically you have to separate changes
okay how to do that you need an
interactive rebase so you will in effect
take those two comments and you will
reapply them that's nothing else than a
rebase but you will do it interactively
so that you can certain points change
the course of action so let's say you
have a commit that needs flitting the
framework then you would first go to the
topic branch and you would say I want to
rebase interactively the dash I or dash
dash interactive does that you say onto
which commits in this case it would be
head tilted too because you have two
linear commits that would be bug fix and
then it will pop up an editor which look
and the contents look something like
this it has a command pick with an
internal reference to the commit and
then for you because you don't know what
that reference means the first line of
the commit message you have the two
commits as they would be applied after
each other
then you have some comments which should
help you to determine what to do how to
change it so in this case the framework
comet is the one that we want to change
right so we change the pic into an edit
command and the idiot says after you
apply that patch as a new commit just
fall back to command line let me do
anything I want and then I want to
continue later so what what you would
have then as you would be at head so you
still have the topic branch you still
have the origin / master branch butthead
the tip of the current branch with it
which is now a temporary branch is at
framework now if we want to split the
framework we have to reroll we have
actually to repoint head even to bug fix
but we want to keep the changes that
were introduced by framework because we
want to split them we want to apply them
one after the other so this is a new
command which is called reset that
resets the pointer head and it also
resets the stage changes so that there
are actually no stage changes but your
working directory still has all the
changes and then you would you would
actually split it by by staging a part
of the changes that you have on commit
them in this case I want to introduce
another option to add it's the
interactive add which lets you decide
which of those hunks and all those dips
that you have you want to stage for
commit that allows you to not only split
the patches by file boundary but also a
hunk boundary okay now you would have
part 1 and now another option to add is
dash you it's the lazy way to say every
file that you know about and that has
changes pleased
stage the changes because I want to
commit them now and then you would have
part two and now you continue the rebase
with the option dash dash continue and
it would just run through and say okay
rebase successfully finished in our case
there is only one more commit that it
would apply it would be the new feature
and all sudden you would have a new
topic branch and that's what you refer
to that would rewrite the history of
course the ref log still would know an
hour and now five minutes ago the topic
branch was at this now half hidden new
feature commit and now it is there at
new feature now if you're happy with
those changes you can again use format
patch to send them off to the mailing
list and say hi I succeeded in splitting
patches now please review to summarize
there's rebased I which is which gives
you more control of the process of
rebasing commits and there's ads I which
also gives you more control about what
is added what of those contents are
added as new and dash you to just update
everything modifying patches so let's
say you made a typo and one of those
commits then you can also use the Edit
command because it will just stop at a
given point and it will let you edit the
file like here you would edit with the
editor and then you would amend the
comet which means basically that it
would roll back to the parent of the
comet it would add the changes that you
added and it would take the same commit
message and reapply yes
actually in this case I had in mind that
the type of was in the commit message
but you're completely right usually what
you will need a good ad or a dash I okay
and of course after your edited and
amended the commit again you would
continue with rebase continue and it
would apply and again you have a
rewritten history which you could then
format patch and send off and just so
you know maintaining portable brushes to
contribute with kids not necessarily
means that you actually provide patches
that are integrated in some upstream
repository but you can also have
branches that you provide in case people
are interested so you add another value
to the project and you ask you ask the
maintainer to pull from time to time to
integrate the changes into her his
repository so let's say in case of get
you have the core of get and then you
have this graphical history browser
called get K this is a component that is
not totally separate but can be
maintained totally separately from the
core of get and this is maintained in a
portable branch now what do I mean with
pull of a branch then the main problem
is if you clean up your history so if
you change your history if you rewrite
history then you will make you will
cause problems to those who pull from
you why is that just imagine somebody
clones from you so has an identical copy
of all the commits all the contents of
the commits and now Yuri base that means
that you have rewritten changes
rewritten commits they are not identical
the identity the internal identifiers
are not identical because the internal
identifiers actually identify the
contents so if you change the contents
the commits are different and what was
in the ancestry of this new history the
old comets are no longer there but they
are still on the side of the one who
cloned so a pool would say oh there are
new changes I don't have them yet but I
have other changes that are not there
remotely so I need to merge and you
would most likely end up with merge
conflicts that are totally undesired but
that's what you would get so if you as a
maintainer have a branch and Yuri base
then all the people who pull from you
will have problems you have to keep that
in mind if you want to maintain polar
branches it is often better to just
admit okay that was not completely the
thing that I wanted to do i wear about
brown paper bag now but please you can
pull and you can still you don't get any
new history rewritten history
you can you close a bridge you cannot
clone a single branch you can there is
the right word yeah exactly their ways
to do it you can actually initialize a
new repository you can add the
information that kid needs to to know
what is the upstream and then you can
could pull just that branch that's
possible but equal oh sorry a clone is
really a clone of the whole repository
the rational rationale behind that is if
you really have branches that are so
independent that some people want one
branch and not the other then there
should be two different repositories to
begin with okay
now related to the political branches
are the forks those are not branches
that you want the maintainer to pull
back into the main project but those are
repositories that our mains to stay
alive for a long time and not be
integrated back so you have long-running
long-running branches that are side by
side if you pull of course you could
also maintain the thing as a rebased
pool which basically means that you
would instead of merge the changes
rebase your changes that you have on top
of the upstream repository you would
rebase them after after you get the new
changes on top of the newest changes
again this on the left side is portable
and on the right side is not probable so
it's nicer to pull it but of course if
you do the rebasing all time then you
have a nicer history much a nice a
history because you don't have all those
marriages back and forth okay just as an
example the the colonel linux kernel is
mostly maintained in the left manner
like pull nice to pullers while the wine
project decided we don't pull at all we
we always want people to rebase on top
of what of what we have okay so thank
you very much there is supposed to be an
EPS which is not displayed that's funny
so just imagine they're your favorite
get logo and I thank the gate community
I thank Google and of course all those
who used get and helped us make it
better thank you
questions no not so the mental model is
instead of there being you're like a one
like a in one stage commit like you have
with CBS where you at it and then you
and then you push really have thurs
there's like well multiple stages more
than two whether its first there's
there's this this cash thing that you
have before you put you to an actual
content right before you get to commit
there's like two phases yes then you
commit to the local repository then you
you you kind of you push which is kind
of a committee or to a remote repository
so that's like one two three three
stages okay so the question was in in
contrast to CVS we have several changes
stages before we actually do it commits
the thing is we really have we have the
working directory we have what we call
the index or staging area and we have
the commits but actually you always need
that you also need in CVS it's just
hidden from you but we realized that
it's very very yeah sometimes it's
really helpful to have a staging area as
a mediator between the commit and the
current working directory for example if
you already know you will will want that
change to be committed but you still
want to polish to brush up some other
parts before committing then you already
staged those changes you can't forget
them but then a git diff will also not
show them you're not distracted from the
rest so it's actually quite helpful
there and of course the most important
part that the part that serious gets
utterly wrong as emerging if you merge
with get all the merge conflicts are
actually haggled out first in in the
index and if those merge conflicts are
in fact none if there can be resolved
trivially then they are are
in the index they are staged as changes
to be committed and only the conflicts
will stay there in the non staged area
so if you make if you call get stiff
then you will really only see the
conflicts and that's really helpful that
you're not distracted by everything that
does not matter at all for the merge so
this is kind of an innovation I so
mercurial tries to be a simpler simpler
alternative to get and it so it doesn't
for example doesn't have this this kind
of concept yeah McCarroll does not have
that well it has the concept but it
hides it from you you can't explicitly
reference it you can't you can say
what's the diff between between my
working directory and the stage changes
or between the state changes in yeah
that's right you cannot explicitly
recall what what is stage and was what
do I not have staged yet you can you
also cannot do the interactive add that
I mentioned earlier that you can say
okay this hunk of that if I want to be
staged for commit and the rest of the
file please do not commit yet you can do
that in my crew that's right yes
index and spinal flex do I need to then
build it and test it also in some sort
of in-depth directory others how do I
know that okay so um yeah so your
question was what what happens with
integrating and testing what was staged
before committing that is actually a
real problem you don't have a directory
for the index you don't have so the
stage changes don't exist in the file
system anywhere they're just they're
virtually and so you have to be
extremely careful about that that's
correct if you commit something that you
haven't tested and that is not obviously
correct then it's easy to commit
something that didn't really test on it
and that doesn't really run that doesn't
compile what you should do then if you
really want to want to commit something
in order to work on something else first
you can do the commit but you don't push
it so you don't publish your changes and
you come back with the interactive
rebase you just mark that to commit as
edit it stops there and you can test you
can compile you can fix things and then
you continue so that's your job the tool
helps you but it doesn't relieve your
thinking yes
help that situation is also important
heat index stash man but it does is you
state your carefree state your change
the changes you want to have your commit
but you are work work working directly
hire a lot more than done but the
practical month is it removes all the
extra changes work bring the state
change to your work so that they feel
yes whatever you make and after that you
say okay I want to have that stash
change back
just for the people who need them what
it's talking spoken into the microphone
it's we have a command that's called git
stash and recently it gained the option
dash dash keep index which helps you
exactly in that setting yes we can do
that it's perfect so I'm totally new to
get and I'm trying to wrap my head
around this whole distributed chaos
right so let's let's just pretend this
start from scratch I just happen to
start my own company here in Mountain
View and I have some developers in China
and have some developers in israel and i
want to set up my source control system
with get I know how to do it with svn or
perforce where everyone just goes and
into the same repository and I know
exactly where the source course stands
except I don't know what's on their
local hard drives ha what is the best
practice for setting up gate for a
commercial and developer environment I
know for open source the best practices
might be different because you have all
this patch is flying around and all that
stuff that doesn't happen very much in
commercial software development so what
is the best practice for setting up get
for a commercial software development
house I think so as always there is no
one golden solution everybody has their
likes and their needs and so they differ
a little bit but I think the main idea
to keep in mind when you have it in a
commercial settings you probably need a
central place from from which everybody
gets the new changes and to which
everybody has eventually at least has to
push the own changes so I would have
exactly the same setup as with
subversion the central repository where
the official change is coming and of
course the advantage by by using git
is that you also can work on it even if
say a cable is cut in the middle of the
ocean and also you don't have any any
connection to a Singapore you can commit
locally you can even exchange locally by
setting up a temporary server and
pushing to that one you don't need to
have one single chair but it's over to
which to push so if you say git push
with any SSH type URL and then your
branch name you can push to other
repositories just as well as to the one
where you clone from and I would
recommend that so as a follow-up it does
that model require somebody acting as an
integration person in this wherever that
central location is or do you expect
every developer everywhere to push into
the same central repository and and
resolve the conflicts as they are
pushing in which is prima same as using
subversion or perforce for simplicity I
would recommend to stay with that model
like subversion does it every developer
is responsible to integrate the changes
and to test and to verify that nothing
broke due to these changes if you need
to be a little bit more strict about
what goes into the official version you
need to have an integrator but even with
that setup it's very easy there is an
integrator cloning and pulling from that
central repository and then verifying
that everything is correct in another
repository and this will be the
repository in which the releases are
actually made and that integrator
trivoli has physical access and the only
physical access so permission problem
solved
other questions yes right I I'd like to
have a short part because you describe
it how to order changes when the
upstream update is using Cree base and
this of course very cool and if you are
an individual developer maintaining your
patches this works fine but sometimes
you might find that you need to you need
to maintain your patches in multiple
repositories or cooperate with other
people on developing the patches and
then this rebase method can became a bit
problematic because you don't keep the
history so since thinker pitches across
repositories can get a little
troublesome so there is a tool which is
called top get and you might want to
keep your eye on that tool the tool
isn't really mitra so far as so you if
you want to use it you have to be quite
brave but hopefully it will get the
stable and then if you have this kind of
needs it might help you thank you yeah
so yes there there are a lot of addons
to to get if you don't like this this
workflow that you work on comments and
and fixed revision histories then you
can also work with patch based flows and
there are programs like Top Gear like
stacked get like guilt on top of get
that use the basic framework but support
another workflow so there is a lot out
there I just described how to do it with
with corrugate and and for a single
development that's true
ok our times about out so let's thank
everybody for coming out especially
haunt us for doing this topic so thank
you and we're gonna try and get this
posted up on YouTube and thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>