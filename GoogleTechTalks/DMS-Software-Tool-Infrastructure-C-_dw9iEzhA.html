<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>DMS: Software Tool Infrastructure | Coder Coacher - Coaching Coders</title><meta content="DMS: Software Tool Infrastructure - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>DMS: Software Tool Infrastructure</b></h2><h5 class="post__date">2010-07-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/C-_dw9iEzhA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">IANA is the principal founder of company
called semantic designs in Austin and
he's been working for over a decade on
tools to handle how to analyze and
maintain a large software systems so I
invited him over to give us a talk about
the stuff that he's been doing to see if
any of his ideas or tools could be
applicable to software systems at Google
hi good morning I'm IRA Baxter CEO CTO
chief follow washer small company called
semantic designs in Austin Texas we're
very interested in dealing with large
software systems all right we all see
that software systems exist okay if you
look at the ones that run large
corporations you discover they're
actually very big and they're not
getting smaller they're growing and so
the problem is we kind of see it this
sort of indicated by this galaxy you
know you're at some point here where you
can see this very large piece of
software and it's enormous and it's
getting bigger and the question is how
are you going to deal with that over the
long run so I'm going to talk to you
today about tools that we have been
designing and building it's actually for
about 15 years now ok what actually save
people some 15 years into a five-year
technical plan okay to give you some
idea of what we think these tools might
look like and what kinds of things you
can do with them so semantic designs we
think our goal is to change the
economics of how software is built at
least for large scale software okay if
you built things by hand the way the
Egyptians did it's going to take you 30
years to build a pyramid 30,000 slaves
by anybody's standards that's truly
expensive if you want to change the
architecture the pyramids that's just
not a good answer okay that's not going
to work you need to do something
different about the method is obvious
bring machinery to the table looking you
need automation to make this kind of
thing work so we say all right bring
automation what would it look like okay
the company was founded in 1995 okay off
of a core idea called DMS which we'll
talk about a lot during this
presentation okay and since then we've
been trying to enhance this engine put
features in it and facilities to help us
deal with these large systems we're
small about 10 people okay but half the
staff or PhD level computer scientists
with very
backgrounds and operating systems
software engineering AI theorem proving
so on and so forth okay so it's an
interesting crap you're a good crowd to
work with now a lot of companies a lot
of investors ask us well you specialize
this company specialized in software
what kind then one oh if we specialize
in banking software or embedded software
a medical software no no we specialize
in software okay in big pieces stuff
because there's a whole lot of machinery
required to deal with just the software
in terms of its scale so we're not
specialists in any problem area the
specialist with software systems in
general right now the tools that we
apply our to our activities to our broad
spectrum as a consequence okay they go
from embedded systems to aviation and
military software to large-scale banking
it's all across the map it's kind of
surprisingly broad and you'll see a
whole bunch of examples I go through
here today and we use these tools to
carry off activities like ARCA
structured architecture extraction we
are protecting a software that is
changing its shape we're structuring it
right translating from one language and
other and carrying out things like code
generation that's a very high level view
so we see software everywhere
interesting systems have oceans of code
people it's easy to find million line
systems when you find them what you
discover is there are million line
systems but they're coded in five
languages and they're all connected
together in complicated ways and there's
not only running on this machine but
they're spread across other machines
that communicate through distributed
methods and mailing files and doing FTP
everything you can imagine so the
challenge is when you face these kinds
of systems are how do you build this in
a timely way this is a problem software
engineering still doesn't know how to do
very well right how do you understand
the artifact that you built if you're
going to make any kind of changes to it
almost every organization has a big
piece of software will tell you that
nobody here knows what the software does
because all the people that built it
left or are dead right so how do you how
do you deal with the thing you don't
understand what do you do right how do
you deal with the quality of this stuff
if this thing is running your
corporation and it's broken your
corporation is gonna hurt
right this is a pretty strong theme for
upper management software quality needs
to be good with your large systems or
it's not good for the company how do you
make small changes the kind of change
that people do every day how do i hammer
on some little piece of it okay and how
I make massive changes how do i reshape
the system to meet the needs of the
future how do I switch from the
mainframe based system say to an
internet-based system or go from one
data model from the kind of data model
or take two data model some two
different kinds this isn't merging
together so I can get a system which is
smart across two kinds of data wait do
you want to make all these changes of
some kind you need automated tools to
help so how do we do that well we
fundamentally offer two kinds of support
activities and tools to help people
carry off these kinds of deal with these
kinds of issues
the first one is analysis okay help
organizations with large amounts of
software kind of get it under control
help them understand how the pieces are
hooked together what information is
flowing from one part to another right
the second thing is help them understand
what the quality levels are help measure
is this code good for some definition of
good is it good because you've tested it
well it's good because it's structured
well it's good because it has a good
architecture is good because it's
layered well so analysis is pretty big
most of our customers when they first
come talk to us want to know something
about what they have
tell me about what I have but the
question is why right
analysis is an interesting topic but
nobody does it unless they're afraid of
the answer when you go to a doctor okay
and you're feeling ill you want an
analysis doctor doctor tell me why I
know tell me what disease I have but he
can give you a very long complicated
definition of your disease very long
complicated name you can describe it to
you okay
and if at that point you leave the
doctor's office the visits really
unsatisfactory nobody really wants to
know what the name of the disease is
what they want to put is a label on the
name so that you can do something about
it
it's the Cure that matters not the
analysis so analysis done to support
change so the other thing that we do and
I think the thing that makes us really
really unique okay is carrying out mass
change to large systems use analysis to
drive change okay so do cogeneration
okay from some kind of a specification
where the nails
might require you to a same domain
specific analysis upfront to invent a
DSL so you can do cogeneration from that
restructuring take your system and we
architected okay to make it more useful
modernization rip out some kind of
underlying piece of technology which
this piece of software depends upon and
replaces remove green screens and place
and ok with with HTML move a
hierarchical database replace it with a
relational database switch from a single
threaded system to a multi-threaded
system these are all massive changes and
they're not the kind of things the
reason do by hand ok the last one was
like migration ok converting from one
system to another and changing platforms
while you're at it so I'm going to give
you some examples of analysis and change
that we've done in various kinds of
tasks some very quick ones ok and I'm
going to talk about the technology we
use to do that so on the analysis side
ok here's a customer came to us with an
IBM mainframe system well they kept the
mainframe in Australia and they said we
have 10 million lines of COBOL ok 3000
JCL scripts ok 6000 input/output screens
500 databases and we don't know how name
it's tied together so when they want to
do simply impact analysis we want to
change the way interest rates are paid
to our customer base they first of all
struggle to find a place to start well
we think this database holds interest
rates another question is what other
parts of the software talk to that
database so they can think about
modifying not so they can actually make
the modification or actually
architecture but what pieces touch it so
they can actually start thinking about
the impact analysis if you cannot do
this on a very large scale you cannot
schedule things well you can't time it
well you know what your everand evel's
are it's gonna hurt you with quality
you're gonna get hurt when you install
it because you didn't take it through
because you didn't find everything just
finding all the pieces and talking about
how they're connected is really hard
problem so one of things we did for them
is we built in the custom analyzer that
reads COBOL at the 10 million line scale
that's 8,000 COBOL programs they reads
all the JCL reads a peculiar thing
called a Hogan DB
this particular application system is
called Hogan it's a banking system that
you can buy commercially from CSC and
the Hogan system happens to be an
architecture that makes it really hard
to see how anything works contains a
bunch of men today that says all these
programs talk to each other through
the way this metadata predicts so in
order for them to see what's happening
you have to understand how the COBOL
programs talk to which or how they talk
to the databases and how they're
directed by the metadata in the Hogan
database it's when we built on the
custom tool will read all that stuff and
give them an answer and I'll show you
what that looks like in a little bit
okay to give you a sense of it the main
point is it's ten million lines of code
it's bigger than you are if you try and
pick up a disk washer I so you need
machinery to do that so that's the
analysis side okay they're struggling
with just understanding what they have
their next question is going to be don't
we make this thing better that's the
next step this is a more interesting
example okay you're not supposed to be
able to see that airplane right this the
b-2 stealth bomber okay
b-2s are made out of essentially stealth
materials and software right so half of
there's about 150 micro process in an
airplane okay it's a 25 year old 30 year
old 30 year old design at this point so
which using the best microprocessor you
could get in 1975 right it has 16-bit
CPUs it actually do floating-point in
the hardware I didn't know you get CPUs
like that 1975 but if you were the Air
Force and you were building this thing
you could get that kind of stuff so
people wrote software to run this
airplane all right so the software to
run the ailerons or software run the
engines there's software to manage the
airplane fly to Baghdad drop a bomb come
home the pilot doesn't do anything
except for say no my tier planes goes
down some path or somebody's does abort
the mission since no going around the
mission software basically runs the
airplane the Air Force thinks is a
really interesting device for forward
force projection okay and they would
like to integrate this device into their
quote unquote battle sphere it's amazing
what kind of terms you come up with when
you go visit these different arenas they
want to integrate their battle sphere
and all they have to do to do that is to
take the software which is running in an
airplane that was designed in 1975 and
didn't know anything about the internet
okay your radio links or communications
and replace it by something they can
enhance so the software's written
something called jovial Jules own
version of the integral of the inner of
the International alcohol language
designed by Jules wort it was the best
and better programming language you
could get in 1973 that was before
anybody had ever heard of see
in a serious way the good news was they
had 1.2 million lines of code 3 on the
airplane did the mission software all
written this thing it all works
runs the airplane everything's fine the
bad news the people that voted are
retired or dead development tools on
which it was still run out of axes so
the development tools are written in
software for a machine you can't buy you
can't even find him anymore ok so this
thing was a disaster of first magnitude
in terms of dealing with they had to get
out the jovial into if you like anything
but jovial would have been their goal
but they were happy to go to see there's
a complication this is a black code the
top secret we SD aren't allowed to know
what's in it
or see it can you please convert this to
C without making any mistakes oh that's
just yes okay all you need is enough
automation and you can do that okay so
this 100% automated conversion it's now
flying in the b-2s that are being used
around we're very happy with this
particular thing now I have to kill you
since you're seeing the airplane okay so
we've seen an analysis example and a
transformation example okay to give you
an idea of the kinds of things that we
do so let's talk about how we do that
okay now if you had to build a tool to
build each one of those things each one
of those are now of the analysis engine
or the b2 thing and you had to build
from scratch you'd simply die okay
there's just too much machinery involved
in doing that we have a very simple
insight and the very simple insight says
that when you build large complicated
tools for dealing with software that
much of the infrastructure they have is
the same as every other tool you build
okay you need parsing you need analysis
you need this now you're gonna hear that
theme a lot in this talk so we did a
simple thing we built an engine that has
a lot of shared infrastructure think of
this as an operating system supporting
application programs which are software
engineering tools so that's what DMS is
it has this long complicated name which
is another our talk as to how it got
this long complicated name okay so it's
official name is DMS software
engineering toolkit we call it DMS for
short okay so what is this
so it's device not for being a tool that
does something directly you never does
anything by itself okay what it does is
it manufacture the tool that does what
we need
so you can think of this tool as being
something that takes in a bunch of
description bunch of raw materials for
describing what has to be processed and
spits out a device for carrying off a
specific task at hand so what we
actually do is we take DMS we
manufacture a tool with DMS and then we
applied the manufacturer tool the
problem task okay and the good thing is
we can use the raw materials for DMS
over and over again now there's a list
of applications over here on the left ok
talks about various kinds of things
we've done for matters migration tools
test coverage tools code generation from
C++ I'm not going to describe those in
any detail here what I want you to do is
see that that list is long and they look
really different ok and you wouldn't
have guessed if I hadn't probably
pre-loaded the question that those all
might be highly related but they are ok
you people are related of fruit flies by
your chromosomes share about 85% of them
it takes a certain amount of stuff to
just be alive
ok and that's the observation 85% of
those things are the same
in fact our experience is more like 95
percent and that's the wind here so
we'll talk about what's in this engine
to give people some idea how we can do
this it's very simple idea there's two
things we put together would together
the compiler technology that the
compiler engineers have been building
for the last 50 years ok if you're going
to deal with large pieces of software
you ignore what the compiler guys do at
your peril it's real simple you need
this machinery so we've taken a lot of
machinery and integrated in the DMS okay
now that machinery is mostly compiler
stuff
compilers take in source code they
analyze it they look for special cases
they do cogeneration from it they spit
out something else that's what they do
ok now if you specialized that to a
particular input language and a
particular cogeneration style and a
particular kind of set of optimizations
and a particular kind of binary output
you get a particular compiler like GCC
ok
that's a nice thigh ok it's pretty
useful there's lots of other compilers
built around that the difference between
what we do and those kinds of compilers
is we've generalized the daylights out
of the boxes right so you need to parse
the input languages whatever language
you need to read you need to read you
need to read them from their external
textual form that people deal with into
an internal form which essentially
compiler data structures which have
symbolized by abstract syntax trees
right so and you'd like to parameterize
that by language definition so you can
feed it lots and lots of different
languages and have it processed them all
you need an analysis engine because you
need to ask questions about your
software if you're going to remediate a
problem first of all you need to know
where analysis machinery and you can set
up general kinds of analysis okay and
configure them to ask the questions that
you want all right now most compilers
will MIT error messages in this diagram
you see them coming out or in the writes
called analysis results so you might
have the tool just focus on analysis and
printer report and we'll see examples
that further run well but more
interestingly what you want the analysis
tool is to drive the signal from the
snails results if I can find it this arc
here from analysis analyzed transform
this is the key interesting arc okay
analyze to find my problem use the
analyzer to drive a change to cause an
impact caused an effect in my system and
we feed that to a transform engine what
the transform engine does it Maps
compiler data structures to compile data
structures okay if you look at the way
compilers work internally that's what
they do this in the middle of five
chapters then you compile that book
you'll see how to map from from a
high-level form to a low-level form
that's what it is but you can generalize
that okay with a notion called program
transformations which we do when I'll
talk about that in the next slide
then it's the formatting which in our
case is mostly about taking the compiler
data structures and converting it back
to source code because what programmers
will want is control their system put my
code in have something happened to it
have it come back out have it mostly be
my code with improvements in it so our
formatters base who generates source
code so they're kind of funny compared
to the kinds of objects the kind of
things got a regular compiler now the
way we deal with this is we parameterize
these boxes okay with the various kinds
of things that takes to do that and if
you'll see down here yeah it looks like
we have a damaged arrow in this diagram
you're supposed to be an arrow from this
list of language definitions and the
school compiler and I don't know why
it's damaged right and in case the rule
compiler accepts two things it accepts
language definitions in the form of what
you might think it was BNF augmented
with a bunch of other things about how
to analyze that language particular
properties and it accepts a tool
definition okay which is what we want
the tool to do what kind of analysis
how we wanted to use that analysis to
dry the transformational change alright
so the stuff in the gray box there stays
constant in the same way your operating
system stays constant these pieces are
just there we feed these two things in
and wiggle them in order to get the
effect that we're looking for
and that's the principle value that we
think we bring to the table here's a
piece of machinery that lots of
organizations could use okay by wiggling
these inputs for their particular tasks
all right so what makes us interesting
well there's the fact that the tool can
provide some kind of understanding help
me understand the source code by for
low-level parsers the compiler data
structures make it possible to do
algorithmic analysis over the code and
get some kind of answers okay and we
actually have deep information flow
analysis if you really want to
understand what happens in a system you
have to know when information flows in
and where does it go and what happens to
it that's a flow analysis question so
fundamentally flow analysis quarter this
right right the core of this is a
transformation engine I'll talk about
that in more detail just a moment okay
and the other issue that makes this too
interesting is not just to sort of a
theory picture okay it looks nice
picture that's cool you could find that
condemning paper okay I wrote one like
that about 25 years ago okay but rather
because it actually works on real
systems that it works on scale we've
actually dealt with systems we have
millions of lines of code multiple
languages mixed languages there's a
computational element underneath there's
a parallel processing engine to support
the size of computations we're doing
because doing symbolic computation at
the million and ten million line scale
is expensive there's a parallel
processing system underneath DMS that's
what I'm gonna say about today but I
have you talked about offline right and
it's been actively used in enhance for
over a decade okay by a small but very
clever team I think okay so let's talk
about program transformations this is
not going to be my day I need to advance
this slide the point where you can see
it all I don't know why I'm not getting
it protected the way I want all right
let's start here
there was an idea back in 1969 that says
we're really cool if we could synthesize
programs from scratch all right and what
these guys said was you imagine
something that's the requirements bubble
over there on the left and I'll write
down some formal specification for it in
my favorite formal language
whatever that was no no there's dozens
of for language have been proposed and
then we'll get some magic engine that
takes that formal language spec and
generates code up the backside and
produces a program okay that idea has
both been famously a failure and a
success okay
the high-level version of it may be high
level requirements and specifications
been a complete disaster I don't know if
anybody can really do this very well
the low level version have been a
gorgeous success to the point where the
body forgets about they're called
compilers right everybody has one
everybody uses one nobody thinks about
it just works but if you push on the
high level version of it okay what you
realize it going from a spec to that
final program in a single step like look
it takes in two million lines of spec
and it produces ten male line program
and it does that in one step
it seems pretty hard really hard to
believe the only hope you have of doing
something like that say why don't we do
this in stages let's our that
incrementally convert that specification
into the final implementation by
applying a whole bunch of knowledge
which we'll call rules that map that
spec to the code and then lower part of
the slide I'm going to show you a little
simple version of that so you can
imagine down here in the lower left you
can see we have a little specification
it's written in algebra because this way
I don't have to explain it's playing the
spec language to you
I assume you all have had algebra right
so that's a specification then what we
want to do is compile it to a more
efficient program ok compilation means
more efficient for some definition of
more efficient most people think more
means compiled to machine instructions
that's one definition another one is it
just takes less time to run that's a
version of compile but because that's
what everybody's really looking for so
on this slide we're gonna do the second
one takes less time to run we're going
to do that by it basically simplifying
this program playing optimizations to it
and with the optimizations we apply are
all ones you learned in ninth grade so
this first step goes from our simple
spec here to the second spec and it
applies the distributive laws you learn
in the ninth grade and then we use a
Unity multiplier to get rid of one times
y and convert it to Y and we apply a few
more of these very simple ninth-grade
transformations you know about get to
our final program this is a compiled
program in the sense it's better it's
smaller if you build a dumb interpreter
to interpret the left one and the right
one the right one will run faster so
it's compliant so this achieves the idea
it doesn't she
to scale you want think about 20 million
these transformational step but I
couldn't get those on the slide so I
tried to keep it simple but this is the
sort of idea we want to take this analog
and apply it to software where the thing
over there on the left there's a formal
spec or a piece of code or piece of
object code any kind of a formal
document and the rules okay are pieces
of knowledge which legitimately tell you
how you can manipulate this program to
make a change so the issue is how can
you give it different language
definitions how can you feed it a lot of
rules all right well what does that
really look like this is what
transformations look like when you go
from the algebra world in the
programming world all right so this is a
transformation that maps from the source
domain in COBOL I have got some kind of
COBOL program and what I'd like to do is
I'd like to convert this COBOL program
into c-sharp okay we can talk about
whether this is a good idea or not it's
certainly a popular idea with lots of
large mainframe guys right now all right
so there's lots of interest in that and
being well a money-grubbing company we
help people do this kind of thing so how
do you get from COBOL to c-sharp well
the answer is convert each of the
constructs in COBOL into a corresponding
construct in c-sharp which that will
give you equivalence and so here's a
rule that does a piece of that this rule
takes care of the special case in COBOL
where you can say add some variable to
some other variable that's a COBOL
phrase legal for some source expression
some target expression and some target
variable right that add v1 to v2 in
COBOL rewrites to the slot called v2 in
some object okay it's updated by the
value that you computer from v1 from
whether object it came from so hiding
behind this thing is an analysis that
backslash object thing ism is a meta
code says I need to go off and do an
analysis to figure out where we decided
to put this object okay in the target
system so it's hiding an analysis there
this is a second analysis there that
says you can only do this if v2 is
actually represented in the target
system as an integer
doesn't work of this a decimal number
because c-sharp doesn't do decimal add
plus won't do that okay so we see on
this particular transformation is a
syntax directed on the source if you see
this piece of syntax here replaced by
that piece of syntax
that's what that's mathematics it's
called equational equivalence a ethan's
be replace this by that okay do some
analysis to figure out what to replace
it with and do some analysis add some
conditions like if represented as
integer if you take that transformation
and you apply it to the before piece of
COBOL down there at the bottom and you
run it with some other transforms that
are allowed to actually do the the
object lookups and things like that you
can get out some of the invoice that
ship total plus equals that should say
plus equals order that widget count so
there's a transformation all right now
we write those transformations as source
text because we're engineers and we
don't know how to read compiler data
structures easily as engineers we want
to work with that but the tool can't
work with text it has to work with
compiler data structures and so the way
it handles this kind of stuff is it
takes those rewrite rules and it
transforms the same kind of compiler
data structures as the actual source
code so it can match them all up and
that's how it works internally so it
maps from that structure that's
collection ok now if I give you one rule
you're not a mathematician ok X plus 0
make you and get you a job ok at John
Hopkins right so if you want to be
really good at mathematics you have to
take a lot of courses you have to learn
the various kinds of mathematical
systems there are the various arrays to
write down for looms the various ways to
manipulate those things is a bunch of
rules and if you're going to be really
good at you're going to spend a long
time doing this and if you do you can do
spectacular things with mathematics DMS
is the same way if you give it one rule
you get a cute example like the one I
had in a previous slide but it's not
really impressive by itself you get
three rules yeah you don't get much you
get 50 rules you start to get the place
where you can do things like building
test covers tools and we'll see some
examples of that down the road then you
give it several thousand rules and you
can just spectacular things you can move
the pyramids okay in particular you can
move the v2 it's just a matter of scale
so number rules matters now we've talked
about the transformational aspect of the
tool ok it's supported by a bunch of
analysis engines what I said before was
the flow analysis is important how does
information flow throughout your system
we don't do anything magic here ok what
we do is we implement the compiler
technology you can find in the stanford
computer science bookstore go to the
back wall where it's a bunch of compiler
books
I got the first book on the left
implement that till that went away pick
up the second book and put that or that
one away repeat we're about halfway down
the wall right fundamentally what they
say is you need to figure out how how
information flows throughout your system
okay so computing flow graphs
information flows use definition change
definition use change points to analysis
all these things are interesting so this
is an example of a flow graph okay
decorated with data flows okay for that
little tiny spot up there at the very
top which I'm sure you can't read unless
your eyesight is far better than mine
okay that's a Fibonacci program all
right this is all the stuff whoops the
scrap that you get because all the
information flows that happen inside
that Fibonacci program
my first comm is man no wonder
programming is hard ok you have to
understand all these kinds of
relationships in some sense in order to
believe this program is right right if
you can collect this kind of information
flows then you can discover that that's
some event here in your code at this
point can have an impact downstream on
there whereas that event doesn't have
any downstream impact on this part and
being able to just simply separate the
part of the program which is important
for the tasks you care about is
fundamental just to focusing your
attention but so you need it you need
the flow analysis just to help find out
where things happen to help separate
things that are irrelevant to you for
things that are not irrelevant to you
for understanding how information flows
around the entire system so this
machinery is built in the DMS okay and
it's been applied to a number of
different languages it's a generic
subsystem and we connected different
language by providing some extra
information but language definitions if
you have this language definition here's
how you feed the flow analysis unit
here's another analyzer this is a range
analysis how big is this value okay why
would I want to know this well I want it
off I'm getting overflow I want to know
a if I you know exceed my storage demand
on some array I wonder how much storage
to allocate for this particular variable
I'd like to do all kinds of things right
so this analysis is done using abstract
interpretation over symbolic range
constraints a symbolic range constraint
is a very short formula okay
to constants I'm sorry three constants a
b and c and to program variables x and y
and it says i can discover this
particular property is true of this pair
of variables at some point in the code
and we have examples of that up here
okay here's a small program okay going
into the program we know and we know
nothing at all okay coming out of this
first conditional what we know is minus
I is less than minus 4 that's a
complicated way when you write this down
this complicated way say I is greater
than equal to 4 shouldn't surprise you
from the conditional right and likewise
I is less than equal to 3 if you come
out this way on the branch if you take
these if you take these range
constraints and you propagate them
through the various kinds of statements
that occur here you end up collecting
more information as you go through the
program think of this as symbolic
simulation on what's happening in the
code what do I know about the answers in
this case we got a fork here coming off
this way collects information we have
four coming up this way and down here we
have a join where these two set of facts
come together and so all we know at this
point is the intersection between those
two sets of facts we take that
intersection we end up down here with
this particular facts as minus K is less
than or equal to minus three and that
might not seem very exciting so you
think about what that really means is K
must be greater than three okay and
there's no upper bound on K what that
means is that this array access down
here it's gonna fail because there has
to be an upper bound on K so in essence
this kind of analysis helps you find
things like subscript faults all right
it's not just an example all right so
that's an analysis so what's in the
engine well it's a pile of gears it's a
toolkit you screw them together the way
you want to get the output that you're
looking for it contains parsers contains
pretty printers with your anti parsers
that's all they are it's as inverse
functions okay it contains a surprising
number of mature front ends for tough
languages okay there are about four or
five C++ parsers on the planet we have
one of them right because of the
machinery we built underneath it so C++
C Python Fortran ADA a bap okay we have
a large number of well test that front
ends
applied in serious commercial contexts
right it takes a long time to get the
details on those things right we've
spent about the last five years busy
tuning our C++ front-end to try and deal
with all the various weird peccadilloes
that show up when you deal with C++ and
you deal with the dialects that come
with C++ okay Visual Studio C++ is not
the same okay is GCC C++ there are
different subtle ways and your reasoning
turns out to be different depending on
which compiler using right there's this
part down here called a procedural API
this is what you find in the compiler
books I have a tree I have a symbol
table I have a flow graph and here's a
bunch of api's I can use to manipulate
those things that's the very bottom of
our system it shouldn't surprise anybody
okay it's what you do if you need a
compiler we try not to use it okay we'll
try and use instead so we try and use
these various kinds of analyzers we've
talked about them control flow data flow
symbolic range analysis now we try and
use the rewrite engine ok this pattern
matching language says you can if you
see this replace it by that okay either
in different from one language to
another or from the same language to
itself for optimization purposes right
and as hit the bottom of the stack my
light and I said it was only going to
say it once
while I'd there's a parallel programming
language to bottom in a discussion main
point is the big pile of gears you screw
them together to get the effect you're
looking for so this is kind of another
view of it okay so we've got that
compiler front end it actually reads
these various definitions dumps them
into a set of internal databases and
they drive essentially the evaluators
and the Transformers and then we have a
set of sub separate subsystems down here
they actually carry off these loops to
carry off these analysis in the abstract
and can be tied to a particular
programming language by the description
that we gave it on that input over there
ok so we're going to take some look at
some other applications of DMS just to
give us some sense of the kinds of
things we've done with it ok we found
that well a lot of people want to have
really good information with their
system and they want to have it now
sometimes you can't get really good
information fastest so maybe it'll be ok
to get pretty good information really
fast all right so we built a thing
called a search engine this is a tool
fishing around in large bodies of text
okay it doesn't have any really deep
knowledge of that text in fact basically
what it does it takes a source code and
Lexa's it according to the lexemes of
the language but when you got 15
different languages you can Lex them all
according with specific language then
you can build a query language over
those lexemes and now you can search for
things this is a search in a language
called I think this is natural this is
natural this is a 4gl this is a
programming language for business stuff
okay in the 1985's 1970s and 80s okay
and we wanted to find out was how many
input screens did this thing have ok
across this 1.3 million lines of code
okay the customer came to us said we
think we have I forgot what they said we
think we have something on the over 1600
input screens right in our application
we'd like you to convert it now please
give us a fixed price bid for this based
upon 1,600 screens would you trust him
right the answer's no go check it out
for yourself okay we found and this says
we found 1112 these things okay these
are not the input screens they were
talking about but their input screens so
there's no thousand screens that they
didn't tell us about so this is really
good in front so this is good
information really fast so this is a
search across a system you can kind of
think of this as Google for code okay
you only it's internal as opposed to
external I think you guys already have a
tool do something like this this used
for fishing around internally so this is
okay information but really fast we
talked about the mainframe problem the
guys for the 10 million lines of COBOL
okay what they wanted to see was a
picture like this and this in fact is
exactly the picture we gave them okay so
this is a COBOL program here in the
center okay and it reads this database
it reads this database it writes to this
flat file okay and it's controlled by
this piece of JCL so basically it says
you point me to a module and I'll tell
you how it's connected to its neighbors
okay and they got a course they can
little search mechanism over here so
they can figure out which components
they want to look at this allows them to
look at their 18,000 components one
small sub graph at a time and get some
sense if I make a change to this program
who do I have to worry about
so it's very simple answer both in
concept in terms of delivery very hard
answer to get because you got to read
all this stuff and get all the details
right do this flow analysis across these
ten million lines of code all right
here's a second kind of analysis done
with DMS okay
people have closed in their code anybody
here not clone any code no ants okay
it's a surprise everybody knows they
have close you know how much it's a bar
bet I'll take with anybody you got 10%
or more clones in your code anybody I'll
take the bet right all right reason we
know that if we've been running this
tool for detecting clones for the last
ten years over everything you can
imagine from Python to Fortran to Visual
Basic 6 okay and it comes out ten or
twenty percent at worse on everything we
see okay the Sun guys the only guys that
beat it it was nine point eight seven
percent
okay with the JDK somebody's actually
been working on her heart I'm impressed
so here's a tool for locating duplicated
code somebody's found wrote something I
thought was useful and they cloned it
someplace else the good news about that
is it's software reuse it makes them
more effective the bad news about this
bug reuse okay whatever you cloned has
some kind of problem in it in the future
maybe it's not actually wrong okay but
you can change your mind about the
architecture and it contains an
architecture decision if you replicated
me or in trouble here's another way to
think about it imagine your source code
base is 20% redundant what that means if
you pick a random line of code in it
somewhere
there's a 20% chance that someplace else
in that system that same line of code
exists and you decide you have to change
that random line of code to improve it
that means there's 20% chance to
someplace else in the system's another
line of code that you should fix how
many of you know where that other line
is so you'd like to have as a tool for
locating where all these clones are
telling you where they are and showing
them to you all right
so here's an example from Python ok this
is the I use the this is the bio Python
test something like that and people
could see down here if they look they
can see it says 11.1 11.7% redundant ok
across something like two hundred and
two thousand lines of code this is a
small system from our point of view this
is these things get bigger
number goes up so this is just a summary
summary report from the tool okay as a
sample of a clone I didn't take one of
the pH from Python I took one from PHP
just to show that we're different we
have a PHP front-end for DMS so this is
a cloned piece of code okay you can see
it's occurred in three places okay it's
in three separate files okay these
clones happen to be exactly the same
100% of that goes copy paste on okay
most of them are not okay most of we're
slightly different than two windows how
to detect that okay this kind of tool
works on any language that DMS can
process and if we run into a language
the DMS can't process for this well we
define the input to it and then this
runs we had a customer in Austin that
said I think I've got clones in my code
and I'd like to manage them and they
came to us and they worked with us for a
while after they did this exercise they
drew a size curve on their system and
here's a size curve and it went up and
it went up and I'm not very surprised by
this systems could bigger and then it
did something that's shocking in the
soccer world it went down okay guess
what that inflection point is they
started using the clone detector alright
so here's a way to manage your system
size here's a way to cut your
engineering costs on large scale systems
go find the clothes go manage the codes
control the clones make sure you're
processing the clones
okay he was very happy with this as a
tool
all right so that's kind of how things
are similar in the big it's also true
that you'd like to see how things are
similar in the small everybody uses the
diff tool okay show me to take two files
one which I've edited and show me how
they're different
now what diff does is it shows you how
they're different
on a line by line basis nobody I know of
uses a line editor so it seems like
really the wrong answer okay if you
think about the way people work with
code what they do is they say here's an
expression or a statement or a block and
I need to do something to this I need to
move it I need to modify it I need to
change it I delete it I need to insert
it I need to copy it they think like
that we just I think like that I don't
know what the rest of all and so a tool
that told me with differences between
two pieces of code in that vocabulary
seems like would be much more effective
you change this variable you move this
block code not this line is different
somehow okay so an engine that we built
called the smart different there uses
the same machineries the clone detector
doesn't the small look for two things
that are the same okay
now instead of showing you what's the
same it shows you what's not the same it
shows you the complements just the other
answer right and that gives you
essentially a Levenstein difference
between the abstract syntax trees what's
the smallest set of changes you might
make to get from one that's tree to the
other and you can think of that as being
a plausible editing path how did he
modify this program to get to that it
comes out and hand you things like this
could block a code got moved one of its
more interesting aspects is you renamed
all the variables in this scope this way
as opposed to I edited 47 places okay
it's completely insensitive to the
formatting and the comments so if you
change the formatting of the text it
doesn't get fooled by any of that stuff
so this is a really useful tool in the
small okay
here's kind of a quick example okay this
is non COBOL all right so we look over
here on the Left we have an original
piece of code we look over in the right
we have a modified piece of code and
what you'll see is the term name term
name got renamed consistently term title
and term title thought this piece of
code so essentially did the diff painted
up these two screens that even the
difference is so that you can see it if
you're a code reviewer and you have to
see how your code got changed this is a
much much easier way to see
what actually happened okay what we've
talked about migrations okay and so we
use the sort of like nice scene from
we've seen from nature shows about this
guy leading these birds on migration and
then we have kind of go to the
stealth-bomber up here in the corner
well alright so we've talked about
migrations I think I've made that point
right so if you need to move from one
system to another change platforms
change languages this does all that
right now
that was transformation as opposed to
analysis you can use transformation to
support analysis okay in particular you
can use transformation to instrument
your code to collect data as it runs to
help you decide how good it is so a
fundamental question before I ship my
code is did I test it everybody says you
should do unit testing we all buy that
right y'all write unit tests but do you
know how much of your code you tested
okay if you tested five lines of your
code with your thousand unit test I
don't want to ship it I should be afraid
so if you'd like to have a tool that
essentially says tell me what part of my
code got executed by my tests the tests
all pass and most of my code got
executed I might feel comfortable about
shipping it the tests all pass and
hardly any of the cogut executed I
should be scared to death so I have no
idea what that line of code that I never
executed does I just don't know
I have no test so what test coverage
tool does a ninja instruments the code
to collect execution information I got
here it does that massively over the
entire system you run the code it
collects all the probes it displays in a
nice format paints them up in a nice
screen nice picture like this so the red
part here is a piece of the C++ code
that did not get executed meaning red
for stop and green means this stuff got
executed meaning for go all right you
can use that kind of instrumentation to
do not only test coverage but profiling
both counting and timing profiling okay
and the styles the same instrument the
program language whatever the kinds of
probes you need for this particular
language so the transformation is vary a
little bit but the style hasn't changed
at all okay
some of our customers ship intellectual
property to each other they want the
receiver to use it what they don't want
them to understand it and they want them
to ship it again so what they actually
want to do is to take the code which is
shipped and scramble in a way that makes
it impossible for a human engineer to
know what's going on oops so here's a
piece of error log this is a chip design
some guy says I want to design my chip
and I will sell to you and I want you to
integrate in your chin but I don't want
you to ship it to a third party so what
they'll do instead of shipping that
thing is they'll ship you something like
this this is code obfuscation take the
code scramble it change all the names
remove the formatting move all the stuff
which are cues for people okay so that
they can ship this and have some kind of
technical support for the intellectual
property safety all right there's a lot
of other applications of DMS that we've
done okay I'm not going to go through
the detail I'm leaving the slides behind
some people can look at it they could
take a look at the slide in general okay
but they cover the spectrum from
embedded systems okay to SOA to other
migrations okay to generating vector
machine code okay for parallel machines
these are all done with DMS basically by
carrying out transformations on source
code we get continually asked can you do
other new things people show up and ask
us all kinds of questions some we can
some we say yeah we think so some we
can't these are sort of things we're
talking about with people and sort of
serious ways at the moment ok migrating
applications from mainframes we have a
bid into the University of California at
Santa Barbara to migrate their student
information system off of natural and a
mainframe into c-sharp right a
particular task that they want done
right control developments control
development cost by minimizing the
software base ok we have a customer it's
got 55 million lines of Java code
they're pretty sure half of its dead
they don't know which half helped them
find it help remove it that's a big task
to do my hand ok I got multi-core CPUs
we're talking to able to say a big
packet switching vendor ok they've built
themselves a packet switching piece of
software which they make a lot of money
off of
and it was assigned around a single
threaded execution model suddenly they
have 32 CPUs and their codes not ready
for what now brown cow
okay you need to analyze the system at
scale to understand where you can break
it apart what you might do to paralyze
the thing right
well US Navy came to us a while ago and
said we're buying software from
Czechoslovakia because we're hate paying
money to Lockheed okay into good news
it's cheap and the bad news we don't
trust it so now the question is can you
find malicious software that's not an
easy task to do but you need to build
tools to analyze the stuff and help them
book around so on and so forth we're
currently talking to University wants to
take C code okay for high-speed image
processing algorithms pick out the inner
loops and converts the inner loops into
FPGA so they can build a basically a
code design system okay which they can
have low speed C code and high speed
FPGA for the core of the algorithms all
that so that that that whole trick is
just basically driven off the flow
analysis stuff that graph you saw for
the Fibonacci is perfect for what they
want to do so I got invited out here
after a conversation with some other
folks at Google okay and so I thought
I'd put one possible Google application
to this okay and as I understand it
there's you know building process a
construction process that says I have a
very large library of support utilities
I have a large number of applications
and there's a dependency network between
them and we'd like to have us a build
process that says okay when I touch one
of these things on which something else
is dependent okay that all the things
downstream get compiled that's good we
all call it make or whatever is you
happen to do okay and so here we have a
model in which if you change Z we'd like
to recompile Y and Q and G and then a
okay that guarantees that when somebody
modify is Z that a gets updated the
problem with it is it's granular okay
yes it's posed on almost everybody's
world
it's the dependency bang the dependency
is based upon not the details of Z but
rather Z itself is a thing okay so it
says Y depends upon Z as a whole so of
anything in Z changes you rebuild y even
if Y didn't use the thing that Z
changed so here we have an example we
look inside what you see as Z has some
sub component Z 1 and Z 2 and Y depends
really on Z 1 ok M depends upon Z 2 now
if I change Z 2 the question is do I
want to rebuild a the answer's no I
really don't want to do that and the
secret to doing that is essentially
something like the smart difference here
what you want to understand is what's
the difference between the old Z in the
new Z so you can say hey this world
changes got made here Z 2 and then you
want to look at the past relationships
between z and y and z and M and say does
y actually use Z 2 no you don't have to
rebuild this so you can build a smarter
make by looking at more fine-grain ok
in the code ok and looking at the Penan
sees it doesn't change the fundamental
model how you build things
it changed the details of how you do it
and it cuts the cost erratically well we
think anyway especially if you do this
on the scale I think you guys are doing
it ok alright so we've talked about a
piece of machinery okay we haven't
talked about sort of the ideas behind
and drivers behind it ok we think that
not only is the machinery useful but our
perspectives as a company is useful ok
we've been doing this for 15 years we
think about this differently than most
people do at the stage of the game
because we ask what can what kind of
hammer can I hit it with not how can I
do with a team of people ok and it takes
a while to get used to that idea because
it's amazing how many different ways you
can hit with this kind of hammer if you
think about it hard ok the engine we
bring the idea that you need
semantically precise analysis as opposed
to people precise analysis people are
good they're not going to scale right
that you want to deal with very large
artifacts ok with automated engines ok
that you should build an engine ok one
uniform piece of machinery to carry off
this kind of work and you can actually
use it engine you can amortize its cost
across lots and lots and lots of
different kinds of tools ok it's
surprising how are your kinds of tools
right and it's also interesting that by
using these tools we've managed to carry
off some tasks that most people consider
it'd be almost impossible most of our
customers have come to us after they
tried to do it themselves and
failed okay the b2 exercise interest
they tried to do it internally by hand
twice before they came to us and they
said basically they're gonna give us the
business because we look weird right we
don't look like we did it the way other
people did it and the way other people
that it didn't work right it was a
really strange reason to get a piece of
business but it worked out for everybody
all right point is we do hard with this
kind of machine just sort of very
surprising things things that people
normally think are impossible right in
practice were a small company okay and
this only works when we find a partner
that has a specific task of his own okay
and he wants to bring somebody the table
so we actually work with the integrators
or the other guy on the other side of
the wall to carry off the task so we
usually provide them lots of advice
here's the piece of machinery we might
build some pieces of it they might build
some pieces of it we might go through
lots of training it's an interactive
process okay with our partners all right
so lessons one software is bigger than
you are
we're still getting bigger right it's
expanding the speed of light can you
catch if you run a light way out to it
you're gonna catch the edge of the
galaxy okay the key technologies for
doing this are really simple really
simple you got to be able to parse the
stuff duh okay you have to be able to
analyze it you have to worry about data
flows at scale all kinds of data flows
kind of fundamentally implemental that
make it available to build tools on top
you need to build care a transformation
for change you don't want to go to the
doctor's office for an analysis you want
to go there for a cure tie analysis to
change that I think of anything you walk
away from this talk it's tie analysis to
change
that's what tools are really good at
right you're always going to need a
custom tool because your situation is
different than everybody else
you grew up the way you did look at your
perspectives the way it is you have a
bunch of historical baggage you need a
tool that deals with the world that
you're in that means you need a custom
tool and you're never gonna find it
lying in the gutter okay you'll have to
build it all right so I think this is
another insight it's hard to build you
don't want to build this infrastructure
by hand it's way too expensive I will
scream if I hear another guy and working
conference on reverse engineering saying
I'd like through I'd like to redesign
the system and if I just had a parser
I'll scream fighting that again right
they're always there they don't seem to
understand that if you even if you
a parser okay it's like climbing the
Himalayas like climbing Mount Everest
the first eight thousand feet cz anybody
can do it with a backpack the last
19,000 feet requires a completely
different technology to get up to the
peak completely different game might
looks easy
yeah first 8,000 feet is easy any clock
can do it but that doesn't matter so the
infrastructure is expensive built it's
hard it has scale you need generic
analysis you need robust language
front-ends you know stuff to fit
together okay bottom line here is TMS is
an engine for doing this the reason I go
around and pop proselytize is because
there are no other engines on the planet
look anything like this at this kind of
scale that I know of there are some
research systems called Stratego and tic
soul which you can download for free and
they say this they they tell the same
stories but they don't apply them like
this okay they aren't going off and
fighting the battles that people have
the real battles and can you really
parse C++ can you really do 10 million
lines of code if you do this flow
analysis can do a call graph this entire
system they don't do those kinds of
things it takes an investment in the
machinery for 15 years to get here okay
I'm open for questions I understand as
Nadia's here okay with with mutes so you
may have to turn your mic on if you want
to ask your question and we have a mic
here for people to step up and ask if
they wish I was curious when you were
talking about looking for duplicate
sections in the code or like copy pasted
code are you able to do that even if
it's not identical code if it's just
similar in structure or maybe close to
the same code yeah we detect what we
call exact clones and what are called
near-miss clones
now we don't detect our semantically
equivalent clones it doesn't detect two
pieces of code with which compute the
same thing but do it radically different
ways to text pieces of code that people
have literally copied and modified okay
it's really weird perspective to realize
what makes clones findable is the fact
that somebody stole them in the act of
stealing them mean invisible okay but so
it's not finding semantically equivalent
things it's finding syntactically
equivalent things that somebody has
stolen so the smart part of the clone
detector really enough is in the clone
attack it's the guy that stole the code
he made it visible he went and
identified this blob of code is this
thing with his formal boundary so
here's the line here's the part which is
good pull it out set it over here and
the moment he does that and now you can
see the boundaries and they're drawn
they're drawn black microphone example
of a small differencing that you showed
that sounds didn't seem very different
from a line difference so I guess that's
probably because you chose a simple
example but in cases of semantic
differences how have you thought about
how to show that visually because well
so let's talk about the example for a
moment okay I mean you're right if you
were to do this line by line a lot a
peer line detector might actually detect
this okay the question is what did it
say okay a line Orion detector wouldn't
sure I wouldn't draw those green patches
they would simply say that line 1 109 0
0 was different in line 1 1 o 3o was
different what our tool says is the
variable name term name has been renamed
the term title throughout this block of
code that's all it says it says it once
so it's a very it really isn't a line
oriented answer ok you can't see it from
this particular one okay I'll go back
and ask you other part of question again
the question I was getting to is if
you're showing if you're finding
differences that show the difference in
an abstract syntax tree representation
how do you actually surface that back we
don't do people we don't show it you
never show an abstract syntax tree to a
person that doesn't work ok that's the
reason for the pretty printers for the
pretty printers do is allow us to take
an arbitrary internal data structure and
convert it back to source code and so
the kind of thing you'll see coming out
of the abstracts out of the smart
difference or if you tell it to do this
is I move this block of code from here
to there
and it'll actually show you the block of
code it's this block of code and it
might start in the middle of a line and
in the middle of a line because it's
pulling out the abstract syntax tree not
the lines right so it shows you the
source text the way you would see it as
a programmer I can only put up one slide
here and have time right so something
what's the largest system you ever
worked with you're talking about you
know apply this to Google
how many lines of code we have maybe 50
meeting a hundred meetings like that
have you done it seen well I think the
right way to ask the question what's the
largest system we work with okay I mean
my suspicion is that you don't have a
single monolithic 50 million line system
you probably have a lot of five to ten
million line systems okay you may prove
me wrong okay we did have well the
packet switching customer had thirty
five million lines of C code as a single
system okay and they stretched us to the
hill and one of the problem there is
what to do what's called a points to
analysis where you want to know is for
each pointer in the system what could it
point to this is what's called a may
analysis this may point X it may point
to Y okay and we essentially had do that
analysis across all 35 million lines of
code okay university papers weren't good
enough okay we actually did something to
do this it ran for I think was six and a
half days an eight-core machine okay and
use 90 gigabytes of RAM to go to compute
this answer probably not big by your
standards was big by ours okay to
compute this answer that's the biggest
thing we've dealt with okay as a single
monolith I had a conversation an
eye-opening conversation with the CIO at
Metropolitan Life back in 1995 when I
first started the business okay at that
time we had no technology at all and so
we walked around proselytizing okay so
we went to visit these guys because well
they seem like interesting customers I
asked this guy so how much code do you
have uses I have 100 million lines of
COBOL right no no you points out the
window we're in New York points out the
window this building three building
where you see that building over there
says it's full of Cold War programmers
okay I need to control that what's the
problem he says it isn't 100 million
lines of code that makes me crazy it's
growing at five million lines a year
that was 1995 god knows where that man
is now he's probably retired but his
successors got 200 million lines of
COBOL we went out to visit security
ministration about two months ago they
do have two hundred million lines of
COBOL okay and that's the mainframe part
then there's the external facing part
and they've been doing almost
distributed stuff in c-sharp and java
200 million lines of COBOL it's
breathtaking
I will say that we're probably not very
good at this we're probably better than
anybody else in the planet
okay it's a tough choice and one of our
one of our struggles as a technology
company is to try and make sure we that
we stay on that curve that we follow
people up as their systems get big right
because otherwise we're all headed for
collapse okay
black holes happen okay when the amount
of mass in there gets to be too big then
you're dead you don't want to be there
when when you get a horse-collar radius
effect right anybody else</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>