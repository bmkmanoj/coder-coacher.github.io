<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Object Capabilities for Security | Coder Coacher - Coaching Coders</title><meta content="Object Capabilities for Security - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Object Capabilities for Security</b></h2><h5 class="post__date">2007-12-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/EGX2I31OhBE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">today we have David Wagner speaking to
us about object capabilities for
security
David is a professor at Berkeley and
he's also quite famous and skilled for
attacking various systems I've learned
I've been through three security reviews
with David and I've learned more by
being attacked by David and by by
watching him attack than probably any
other single experience my own
educational insecurity he's also found
some the best vulnerabilities found to
date in AES he led the effort to attack
voting systems and and document their
vulnerabilities and today he's going to
present his work on the defense side for
all the rest of us to attack so here's
David all right thanks great well so I
want to tell you a little today about an
approach to building secure systems that
I find exciting let me make one quick
correction to what Mark mentioned I'm
not going to be telling you my ideas
almost everything I show you in this
talk is ideas I've learned from other
folks many of whom are here in this room
so all credit to them in particular why
I tell you about an idea a theme
community coalesced around the term
object capabilities there's a small
community of folks who've been working
on a set of ideas that I think aren't as
widely known as maybe they ought to be
known as so that's what I want to show
you in this talk okay and please feel
free to interrupt me with questions stop
me at any time I'd love to have this be
an interactive process okay so let me
start off with a motivating example I
want to show you an example of a very
powerful program on your computer
installed on your very own computer you
probably know many people who use this
program
this is an extremely powerful program it
has the ability to delete all of your
files it has the ability to misuse your
credit card number and place all sorts
of of e-commerce orders you wouldn't
have liked it has the ability to trawl
your email and post the juicy excerpts
on some news group what is this program
well solitaire but it's not just
solitaire it's every program you run
every program you run has all of these
powers okay every program you run has
has the power to delete all your files
has the power to ruin your life has the
power to do all sorts of nasty things to
your to the files on your computer and
why is that
well let me come back to why in a minute
this is a problem for security reason
you should be concerned about this is
that this is one of the contributing
factors that makes viruses and worms so
devastating because if solitaire is
corrupted by a virus or a worm then it
can do an enormous amount of damage if
the creator of solitaire was malicious
it could be it could he could have
hidden a backdoor in there that could do
all sorts of damage
now there's I have no reason to think
that solitaire does any of those things
but this is a powerful program and as we
know power corrupts so in particular
this is I would claim this as one of the
major risk factors that that contributes
to the security problem we face today
and if you've read the old literature on
computer security you'll recognize this
as a violation of the principle of least
privilege
back in the 70s Salter and Schroder
wrote about a set of principles one of
the principles they recommended was the
principle of least privilege programs
should be given the privileges they need
to that they legitimately need to
accomplish their purpose and nothing
more
what a solitaire legitimately need to
enable you to play a game with it well
it needs the ability to render to paint
to its window it needs the ability to
receive Mouse actions that are directed
at that window but it doesn't need the
ability to write to every file on your
file system but it gets that anyway okay
all right so the solution to this seems
like it should be obvious rather than
granting solitaire the ability to ruin
your life it would be much nicer if
solitaire and every other program
you ran received only the rights and
privileges it needed to do the useful
work and not all this excess rights and
the purpose of object capability is one
of the things about object capable is I
find exciting is that they can help make
that task easier okay so in this talk
I'm going to talk a lot about privilege
I'm going to talk about the principle of
least privilege and how we can
accomplish that I'm going to talk about
how we can enable and help programmers
to reason about about privilege and the
privileges or programs use and of course
I'm going to talk about object
capabilities which are intended to help
accomplish all those goals so one of the
greatest enemies of least privilege is
an approach that's I'll call ambient
Authority now let me warn you up front I
want to share with you the ideas that
I've learned from the capabilities
community they've developed the whole
set of terms and slogans and and names
that might not be familiar to you so one
of the things I'll be doing is I go
through this talk is exposing you to
those names and though and the concepts
and here's one of them ambient Authority
I'm gonna explain in a minute what what
that what that means please stop me if I
forget to explain any of these any of
these jargon okay so let's take an
example let's imagine you want to copy a
file you want to copy food out text to
bar text well how do you do that in a
typical UNIX system you run that command
up there
you run the CP program and you pass it
two strings on the command line now when
your shell runs the CP program when the
CP process is executing that
going to run with all of your privileges
it's going to run under your user ID
it's going to have the power to open and
modify and read and write all the files
that you have the power to okay so it
receives all of your authority and it
has to if you think about how the CP
program works the interface to this
program really there's no other option
there's no other way it could work
because we're passing two strings to
this program and the program has to be
able to take those strings those
interpret them as file names open those
two files the operating system better
allow those open system calls to succeed
and to ensure that that happens that
means well look I might want to be able
to copy any file on the system anywhere
under any other file in the system that
I have the right to so it sounds like CP
has to have the ability to open any file
that I have the right to open that I
have the right to read you know right -
so it sounds like it's follows almost
logically from the specification of what
CP is supposed to do that the operating
system has to grant CP all of these
powers all of these extraneous powers
even though this one running instance of
CP really only needs to be able to
access those two files it's getting a
whole lot more than that okay so let's
consider another approach which is
somehow analogous to what the
capabilities approach is trying for
let's imagine that instead we copied
those files using the cat command
all right now I could type this second
command into my shell and what would cat
be passed cat is passed not to file
names but to file descriptors okay
passed a file descriptor for food out
text and it reads the bytes from that
and perhaps a file descriptor for bar
dot txt and it writes to that and you
can notice that with this interface now
that I changed the interface in this way
cat no longer needs any authority no
longer needs the operating system -
granted any of my rights and privileges
because the file descriptors just have
having a file descriptor alone gives me
the ability to read and write on that
file descriptor so cat doesn't need to
be able to open other files on the
system so if only we could structure our
systems like this then we wouldn't need
to grant all of our processes all of
this excess authority okay so this is an
analogy to illustrate what we're gonna
try and head towards and by the way let
me introduce you to some more jargon
I've mentioned I've used the word
Authority so let me explain what I mean
by that what I mean is Authority is the
power that a program has or process has
to affect the outside world okay to
cause side-effects on the outside world
to cause the ATM machine to spit out
$100 to - you know stamp a hole in that
device over there or or maybe to write
to a file okay and authority is in some
sense transitive let me distinguish
between what we might call permissions
and authority
I might have permission to write to a
file okay because that files access
control list mentions my name it says
I'm allowed to write to it okay that'll
mean I also have authority to write to
that file but I consider the following
variant suppose that I can talk to Bob I
can't write to the file myself but I can
talk to Bob and Bob can write to the
file and I can send Bob some message
that will cause him to write to that
file okay in that case we'll say that I
don't have permission to write to the
file directly but I have authority I
have the authority to write to that file
because I can take an action which will
cause that that file right to happen
okay so in some sense Authority is kind
of transitive an ambient Authority is
Authority that's that's in the air for
the taking it's it's available for you
it's sitting there waiting to be used
even if you didn't explicitly ask for it
okay so you can think when the CP
process gets instantiated by the
operating system it's like the operating
system had this you know big old bag of
Rights that it's remembering it says
with this
says here's a set of all the things
operations it's allowed to do and when
the CP command asked to open a file the
operating system starts going rooting
through that bag of Rights and says is
there anything in there that would
justify allowing this this open called
succeed oh yeah I found one okay I'm
gonna let it I'm gonna let the CP open
that file that's an example of ambient
Authority ambient Authority is kind of
the global variable of security okay now
ambient Authority is really bad for at
least privilege I hope it's clear why
this is the case and main Authority is
really bad for least privilege because
by default you your processes get
everything get all the powers they could
the maximum possible power which means
that they get a whole lot more than on
than any particular instance of that
process really needs okay so one of the
goals of object capabilities is that
we're gonna is we're gonna just say no
to ambient Authority we're going to try
to achieve at least privilege through a
an architecture where processes by
default receive no authority not where
processes by default receive all
authority okay so to introduce a little
bit more jargon we could say that
ambient Authority violates the principle
of least Authority because the default
gives programs Authority they don't need
okay and you notice that I switch
talking now from the principle of least
privilege to the principle of least
Authority because the principle of least
Authority is what we really care about
so we call that polo for short
are you okay with the capability jar
good so far all right so now here's the
point here's the thing that's is
exciting about object capabilities is
that capabilities make it easier to
achieve the principle of least Authority
our current operating systems do a lousy
job of that my Windows machine my Linux
box your Macintosh machine they all
violate Pola because they are ambient
Authority systems they give every
process you run all the authority that
your user has in fact on a single user
machine that likely means basically all
your files almost all of the interesting
files on there okay capabilities have
the promise to change that because the
traditional view says well accomplishing
principle least authority is really hard
capability is trying to make this easy
and one of the key ways that it makes it
easy is that they make the process of
identifying which files you want to
operate on also automatically convey
with them the authority the the rights
you need to be able to operate on those
files so imagine if the CP program
instead of receiving strings that
receive some magical entity that not
only identified the which file you want
to operate on that's what the name food
text is supposed to do is supposed to
help you identify which file you want to
operate on but also that magical entity
also gave the CP command the power to
read and write to that file ok well then
that would be great because then we
could give the CP command
by default when that process starts we
could give it no authority at all and
then the process of running CP to copy
food out text and bar detect when we
pass that those magical entities it will
receive just the minimum it needs
okay well that magical entity is a
capability capability is is a both
identifies what file we want to operate
on and and provides the authority to
modify that file if you have a
capability to that file then you have
the right to modify that file that's all
you need that capability is enough to
allow you to act on the file okay so the
classic example of a capability if
you're in a UNIX world is a file
descriptor if you have a file descriptor
to some file that's all you need that's
enough for you to modify to act on that
file no matter what the access control
permissions on that file say okay so
this has two advantages well first it
means that that system administrators
don't have to configure complex security
policies we can get fine-grained pola
without requiring system administrators
to do a whole lot of work to configure
these really detailed access control
policies because just by virtue of the
way that users invoke programs causes
those programs to receive the least
Authority they need to do their job okay
and we comply this not just to programs
the users run but we can apply this to
software architecture so the internal
interfaces the programs we build so that
the interface between modules the module
that's being invoked when it receives
not in the capability way we don't pass
a file name telling that module what we
wanted to what file we want to top right
on we pass a capability to that file and
that and just by virtue of defining the
interface in that way that module
receives the authority it needs and we
can be granted when it starts up nothing
more than what it's going to receive
through that interface okay all right so
what's an object capability system i've
been using new words object and
capability so let me define my terms a
little bit in an object capability
system there's only two kinds of things
there are objects and their capabilities
an object he is think of like Java a
Java object it's it's an entity that has
some state and some code okay and it has
some public entry points that anyone can
invoke they can send messages to it that
will
execution of some code and it has some
private state that its own code can can
read and write but that the app but that
is not accessible to the outside world
okay so the object is a protected domain
and a capability is just an object
reference it's a it's a pointer to a nun
for Allah to an object okay and the key
feature of an object capability system
is that that's all there is
there's just objects and just object
references and and moreover that the
only way to obtain Authority is by
receiving a capability okay so one of
the key properties of an object
capability system is if you don't have
any capabilities you don't have any
authority you can't affect the outside
world and the only way you can gain the
ability to affect the outside world is
someone gives you a capability okay and
moreover in object capability system all
the rights that we care about should be
represented by capabilities okay so this
means for instance that if Alice has a
capability to write to some file and she
wants to cooperate with Bob and she
wants Bob to be able to write to that
file all she has to do is just pass that
object reference to Bob and then Bob
will have that capability and Bob will
be able to operate on the file as well
now what I'm particularly excited about
capabilities are an old idea but all
right what I find especially exciting
today is a the possibility for language
support to make it easier to build
capability systems to build system in
this style
particular type safe object-oriented
languages seem to be just perfect for
the capability style the reason is if we
think of a language like Java job is
already very close to an object
capability system Java objects can be
our objects
it's got references which are type safe
unforgeable object references there are
capabilities the language itself is very
close to what we want we just have to be
a little careful to make sure the one
way that Java violates the object
capability paradigm
is that it provides the class libraries
for instance provide methods that allow
you to write to a file even if you don't
have a capability okay so that violates
the capability rules so the but the
language itself if we exclude the
libraries is pretty close to what we
want and notice that the key bit here is
is the type safety and the the notion of
code and state in an object-oriented
language you don't care about things
like polymorphism or inheritance those
may all be good features may be nice
features but they're not necessary for
the object capability weight okay and
one of the key things here is that by
working a type safe language the
language type checking rules are what
provide ensured that objects are tamper
resistant will provide the protected
domain question thank you yes so the
question was the observation was that
one problem with job is that Java has
static fields they're effectively global
variables and that's right that violates
the capability rules if you have a
mutable static field then then that's a
that's provides Authority and if I have
a static field that can hold a
capability then that's even worse that
violates the rule that when I write code
when I instantiate a new object by
default that shouldn't have access to
any capabilities so the answer to that
is that you have to excise roughly
speaking excise
static fields from the java language if
you want the java language should be an
object capability like and it seems to
me like you also need you can't just
excise the mutable static fields even if
you have a static field that's in
immutable that allows that potentially
allows people to get information that
they shouldn't have even if they can't
affect something they shouldn't they
shouldn't affect they can still get
something they shouldn't have
excellent observation the observation
was that
even if we think only about immutable
static fields then they provide all of
your code access to whatever information
is held in there if that's a crypto key
or some secrets then then that might
leak secrets and you're right that's an
issue and I should warn you of one of my
biases in my own bias is that I tend to
think primarily about integrity issues I
find confidentiality very challenging to
reason about because of issues like
covert channels it's very hard to come
up with sound styles of reasoning for
confidentiality so for this talk let me
focus only on integrity you're but
you're absolutely right to identify that
the key thing you notice that we're
talking about static fields is this
drives into the scoping it's the scoping
rules in the language which what which
is what gives us the least privilege and
what gives us no ambient authority
because objects only have access to the
capabilities that are in scope if we're
in a language where What's in scope
where the universal default global scope
provides no authority then newly
constructed objects have no authority at
all now thank you for raising these
issues about Java your check is in the
mail
because this transitions very nicely to
the next thing I want to talk about I
want to tell you a little bit about some
ongoing work that's going on in my
research group particularly by Adrienne
Mettler and others here to build a
subset of Java a new a new programming
language that we call Joey it's
basically a refinement of Java it what
what Java should have like like if it
was going to be built in the object
capability way okay it turns out that
there's not as I mentioned the Java
language is already pretty close to what
we need there are a couple of things we
need to eliminate from the language such
as static fields native methods the
libraries have to be subsetted there
they're a major issue also
multi-threading and class loaders pose a
number of challenges so in the current
iteration of the the language Joey is a
single threaded single
classloader subset of java i'm not going
to tell you too much more about the
details of Joey I'd love to tell you
more after the talk one of the key
things about Joey is that we think that
an object capability language can be
pretty familiar to programmers it
doesn't have to be a major learning
curve I think if you found if you were
programming in Joey you might find it a
little unusual to program in the
capability style but the language itself
would look very familiar to you if you
if you're a Java programmer we think
Joey is a promising basis for building
really secure systems for building
extensible systems where you can allow
people to put in plugins that where you
can limit the amount of thority those
plugins will receive you can envision
all sorts of ways to structure your
systems and I encourage you to think
about how you could improve the security
of your systems and and help them to
achieve the least principled least
privileged by structuring your systems
and building them in an object
capability style for instance give you
one example to get your thinking imagine
you could imagine a Gmail where after
the user has logged in gotten past the
login screen all the code that runs from
there on imagine if that code was handed
a capability to the users mailbox and a
capability to the session but not to
anything else in particular not a
capability to any other users mailboxes
then you could have an incredibly
complex and rich code that handles the
user interface and just by virtue of the
capability language you could get some
confidence some assurance that one users
actions won't disrupt someone else's
mailbox
okay so another topic I think at this
point maybe I move on to the second part
of the talk tell you a little bit about
how to reason about Authority if you're
going to build programs in this way one
of the one of our goals for Joey was to
make it easy to do code reviews for
security of these kind of systems and
make it easy for programmers who are who
are implementing these systems to think
about the flow of capabilities of
privileges throughout their programs so
give you some examples suppose I have a
really important data field in my in my
program account balance or something
like that and I want to know I want to
know what are all the places in the code
that might be able to write to that
piece of data okay that's a kind of
query that would might be you might like
to answer during a code review or
another example of kind of reasoning you
might like to do in a code review is
I've got a chunk of code I'm reviewing
right now
what is the maximum amount of authority
that code might be able to receive that
will help me understand how much damage
it might be able to do if it goes awry
okay so those are the kinds of some
kinds of reasoning that I think are
really important and that I've the
capability languages and intended to
help you with and just a little bit of a
notation here I'm drawing each object
here's an object Alice an object Bob and
Alice has a reference to Bob she has a
capability to Bob okay now one of the
key challenges in reasoning about large
systems is how to make this scale
because we can't keep all the code in
our head at one time that's just not
feasible so in the programming languages
world Piell folks have done a lot of
work on what they call modular reasoning
and the idea is that we want to look at
one module at a time and understand just
that module and how it interacts with
the rest of the system and in this way
by doing only local reasoning try to
infer some global properties about the
system is it correct so the most naive
way you could imagine doing this is we
could say well let's look at the code of
Alice and just by looking at the code of
Alice not any another code in the system
try to try to determine whether the code
of Alice is correct
okay so when I say not by looking at any
of the rest of the system what that
means we have to assume that all the
clients of Alice are potentially
malicious they might behave in arbitrary
ways because we haven't looked at their
code so we can't characterize how they
might behave and all of the services
that allas calls but also will presume
malicious we can't assume anything about
them because we haven't looked at their
code the only thing we can assume is
that that other code has to follow the
capability rules because it's written in
a capability language okay and then you
could imagine trying to reason about
Alice draw a perimeter around Alice and
just by looking inside that red
perimeter determine whether the code of
Alice appears to do what it's supposed
to appears to be correct okay so if
you're a security person you say well we
draw a security perimeter we assume
everything outside that perimeter is
malicious and what can we conclude if
you're a programming languages person
you say well we look at the code Alice
and we quantify over all the possible
instant instantiation of the rest of the
system and we try to say what properties
can we conclude now the problem with
this kind of reason this naive version I
showed you here is this doesn't work it
doesn't work very well because in
practice you'll find that you can never
convince yourself that alice is correct
or rarely can you convince yourself that
alice is correct just by looking at the
code of Alice because quite frequently
Alice provides service to some of her
clients but she in turn relies upon the
services provided by other objects or
modules that she invokes so this is too
naive so but we can fix that we can
there are patterns of reasoning to allow
you to take that into account this
brings me a topic of trust and
vulnerability and reliance in a security
system here in this diagram alice is a
client and bob a Bob and Charlie she
invokes them for to use their services
maybe Bob's a hash-table and Charlie
something else you can imagine that in
some cases Alice might decide that she's
willing to trust Bob and Charlie and
that's a peculiar way be careful what
that word trust means that's a funny way
of saying that Bob's willing to accept
she's willing to render herself
vulnerable to failures or misbehavior of
Bob and Charlie
she's willing to rely on them she has
faith that they'll do the right thing
and if they don't do the right thing
that she's she can be totally screwed
okay so this is a fairly common pattern
you might find in a system how can we
reason about that well one way you could
reason about that is we could say let's
reason about Alice
let's read look at the code of Alice
looking just at the code of Alice I'm
looking at the contract that Bob and
Charlie export and just assuming that
Bob and Charlie correctly implement that
contract but not making any assumptions
about Alice's clients can we convince
ourselves that Alice is correct okay and
once we've convinced ourselves that
Alice is correct
then then we're entitled other people
are entitled to rely upon her okay so we
might have started by verifying that Bob
and Charlie were correct and then once
we verified that Bob and Charlie are
correct then we verify that Alice is
correct and we're proceed in this way up
the culturing so this brings me now to
the notion of defensive consistency
because that is also a little tone too
naive in practice it's often the case
that their Alice has multiple clients
and Alice typically Alice will export a
contract she has some preconditions if
the client satisfies those preconditions
then she she is promising to provide
useful some kind of useful service to
them now we could say that Alice must
provide a useful service to all of her
clients but that seems like too strong
of a requirement because what if one of
her clients violates the preconditions
one of one of her clients does not you
know does not follow the contract then
in that case we ought to release Alice
from her obligations okay but this is a
little challenging because you know in
this case we'd like to know that if Zack
is malicious but Yolanda is honest and
is relying upon Alice that Yolanda can
still count on Alice to provide
Yolanda would useful service but we'd
also like to say the Zacks and Zack
violated the contract you know Alice
doesn't have any obligation provide Zack
with any useful service okay so this is
the notion of defensive consistency if
Zack misbehaves then then we release
Alice from the obligation provide
correct service to Zack but she must
still provide correct service to Yolanda
okay defensively consistent services are
up and more useful okay if I want to use
some other service I don't want to have
to characterize all the other clients of
that service to know whether they're
malicious or not I'd like to know that
as long as I use that service correctly
that I'll get useful service even if the
other users of it are malicious so
defensive consistency enables a kind of
modular reasoning because in this
industry zijn anyway this reasoning
works is that we look at the code of
Alice we look at the contracts of Bob
and Charlie we assume we assume that Bob
and Charlie follow their contracts and
then it's our it's our proof obligation
when looking at the code of Alice to
verify that if if Yolanda meets the
preconditions then no matter how Zack
behaves quantifying over all possible
instantiation of Zack that Alice will
still provide correct service to Yolanda
okay all right so this is an example of
modular reasoning because you notice to
do this kind of reasoning if the system
was constructed thoughtfully was done
right we only have to look at the code
of Alice to convince ourselves that
Alice is defensively consistent and the
contracts that Bob and Charlie but not
the code of Bob and Charlie not the code
of Zack okay so we've constrained the
scope of the code we need to investigate
so let me give you an example to help
you understand how this might play out
in a concrete situation this is a toy
example imagine that for instance we've
constructed a system where we want to
build a pen don't log okay in a
capability system the way you do that is
you build a logger component this is an
object the
has a reference to the actual log data
and the logger component the code of the
logger component is written only to
append not to overwrite existing log
entries so to verify that this really
does provide a append only log what do
you what code in the system you have to
look at all you have to do is you have
to make sure that the logger has the
only reference to this this underlying
private data we've got to make sure the
logger creates that that reference and
keeps it closely held and that the code
of log or only appends okay so you
notice we've only had to look at the
code of the logger let's compare that to
if you'd written this system in some
language like C not memory safe not
object capability style what would you
have to do if you wanted to really be
confident that this is an append-only
log Mattson there's a million lines of C
code you're a hos do you have no hope
because for all you know there could be
some other C code somewhere else that
concocts up a pointer into the middle of
this data structure and starts over
writing it and that could happen
deliberately maliciously or it might
happen accidentally maybe there's just
some array out of bounds error a buffer
overrun bug elsewhere in the code okay
so it's in the inna system written in C
one giant C program you'd never have any
hope of really being confident that this
is an append-only log because it's just
not feasible to go examine all of the C
code in the system and convince yourself
that it will never concept a pointer
into the middle of this data structure
and start over writing log entries
whereas in an object capability system
verifying this is simple and that's good
we would like simple tasks to be simple
okay so to jump ahead to the end
summarized what are the key messages I
want you to take away from this I think
one of things that makes exciting
capabilities makes capabilities exciting
is that they seem to make principle of
least Authority easy in particular
principle at least aforethought EC me
come from good object-oriented design
and good design of your of your of your
class hierarchy and the second thing I
wanted to take away was the capability
enable modular reasoning they can make
it easier to reason about your code they
can make it easier to code review they
can make it easier to to gain confidence
that your system will work the way you
want if your system is constructed
thoughtfully in a way that's amenable to
this kind of analysis ok so personal
view here object capabilities I think
are a really intriguing set of ideas
you've now learned enough that you can
form your own judgment I encourage you
to look for opportunities and systems
you build to apply these ideas look for
ways to minimize ambient Authority look
for ways to combine designation with
Authority with authority for instance
don't pass file names past a reference
to java.lang file you can look for ways
to write your code in a way that enable
modular reasoning and make it easy to
verify your code is correct just by
looking at local instances of this you
don't have to use Joey you don't have to
use an object capability language
benefit from all these although it helps
ok so if you're interested in any of
this I'll leave up a few references here
for more reading you've got some of the
experts right here in Google go talk to
them thank you for your attention
yeah how do you deal with sending
capabilities over a network like I let's
say in some case you want to send a lot
of data over the network
um but on the other but once you send
the data over the network then you kind
of lose the guarantees of the language
because that whatever is processing it
on the other end might be malicious how
do you deal with things like that yes
okay so this gets a whole lot more
interesting and when you talk about
distributed systems let's see what I can
say about this I'm not an expert in
distributed system sorry I hope I don't
mangle this mark and Tyler who was
sitting near you can probably give you a
better answer to this question I you can
build distributed systems in the
capability style what you need is you
need a an RMI like layer that is that is
built to support capability like systems
okay so for instance if I'm an object
sitting on my machine and there's an
object sitting on your machine and I
want to invoke your object then I need a
capability to your object I need a
reference to your object and one of the
things that are on my protocol can
provide is it can provide me with what
looks like looks to me like a reference
to your object and what is actually
implemented as a proxy object that's in
my object that's in my address space
that I can invoke and when I invoke that
and then cause in turn causes messages
to be sent over this secure RMI layer
which then cause to be invoked on your
object now what properties can I count
on the properties I can count on in a
distributed system are a little bit less
than what I could count on if I knew
that my entire system was hosted on a
capability a local capability machine
because if I don't trust your machine I
don't know whether the code on the far
side of that network link is going to
follow is going to respect the
capability rules but what my
communication protocol can do is it can
enforce some of those capability rules
okay for instance I can info
course that you can only invoke one of
my objects if you have a capability to
it meaning if I've actually given you a
capability and my RMI system has turned
that into a cryptographic secret which
is the representative you hold as your
representation of that capability you
can't just send me an address space and
tell me ur into middle of my address
space and cause my code to jump into the
middle of that address you constructed
so I think that I have probably mangled
some of the subtleties here but it is
possible to build pretty exciting
distributed systems if you want to take
a look at one example you can look at
Tyler's water Ken system where
capabilities at the language layer is a
system that translates them into URLs so
you can invoke them by HTTP the URL has
a cryptographic secret and unguessable
secret in there which enforces the
unguessable 'ti the unforgeable attea
capabilities Tyler who's 10 let me just
before I hand the mic off to the next
question let me just mention I'm good
I'm going to be inviting Tyler and to
give a tech talk probably early January
on the water can server so if
capabilities are so great then how come
they haven't revolutionized the world 20
years ago yeah it's a hard question you
know there's this famous quote that says
I think it's from Butler Lampson the
capabilities are the way of the future
they always have been they always will
be I think I have a couple of potential
answers to that I don't I can't say with
confidence until you know we built
successfully builds enormous systems in
this style historically I think there
are a couple of challenges capabilities
came out of desire again the same
motivation G principle lays privilege
would be great we can do a better job of
principle least privilege if we have
fine-grained access control but
unfortunately many of the fine-grained
access control systems at the time
required system administrators to
configure complex policies what are all
the set of files you should be able to
write to what are all the set of network
ports you can open and that just isn't
reasonable it is it's it's not practical
and so fine-grained access control
systems got a really bad name rightly so
because they were impossible to
administer so I think one of the things
that's new about capabilities is that
they're in some sense self-administering
I think the other thing that that makes
them exciting now is that now we have a
programming language technology which
can provide the make this capabilities
easy the capabilities look like you're
just programming in a type safe
programming language and but languages
type system enforces the security checks
for you so I think there may be an
opportunity now for this idea but you're
completely fair and right to be
skeptical David could you say just a
little bit about what the current status
of Joey is I've talked to some customers
who might be interested in actually
being able to write run untrusted code
within a server that I'm building and I
wonder how many of the libraries are
available how much is it aiming have you
done all that kind of stuff yeah all
right so I'd love to find some users for
for Joey it's a it's a somewhere in
Alpha you know research prototype state
right now it's a surprisingly mature for
a research project and Adrian's done
some great work on it so what we have
right now is we have a language
specification we built a Clips plugin
that will verify that your code follows
the restrictions of the language the
primary challenge right now that we're
working that we need to do a lot better
on is the library taming we have we need
to do a better job of putting placing
policies that say these libraries are
consistent with the capability style
these libraries are not and to have our
plugin enforce that for you so it'll
give you a warning message or an error
if you're using one of the disallowed
the libraries we're actively
working on that we've got a good handle
on that but it's not done yet so right
now we've got a little bit of
implementation experience we've got one
user the water can system I mentioned is
built partially in Joey so we've got
over 10,000 lines of Joey code there and
one of the students who's here Matt
Finister I'm happy to introduce you to
him has been gaining some experience
taking legacy Java code that wasn't
written in a capability style and
experimenting to see what does it take
to turn that - Joey is the java to turn
that into a capability style now that's
not the way that I recommend to use
capabilities that's not what Joey was
designed for but we're trying not to see
to get a handle on how unnatural a
programming paradigm you know does this
feel unnatural does it feel strange that
you lose expressivity and I guess the
bottom line is we'd love to have users
and if we have users we'd love to
support you and provide you with what
you need so that you can be useful to
you hi it sounds like Joey doesn't have
multi-threading in fact you said Joey
doesn't have multi-threading do you have
it turned off because thread safety is
not easy because it's got there are
gaping covert channels in today's
architectures is there anything else on
top of that that you haven't turned off
for oh man thread safety is a can of
worms the Java threading model wasn't
designed with the capability style in
mind it makes a lot of the the
invalidates a lot of the assumptions
we're currently making so for instance
one of the things one of the ways that
we use Joey right now is that we have
some infrastructure that allow you to
verify that classes are immutable
they're semantically transitively deeply
immutable that once they're constructed
the value can't change well it turns out
it's a real intricate of intricacies in
enabling to build a practical and yet
sound verifier that rule that if it says
that class is an immutable means it
really is and one of the ways that this
is challenging I think that threads
would raise a set of issues here which I
have begun to think about
is what happens if some other thread
modifies some of it tries to modify the
state of that object in the middle so we
haven't yet begun to think about thread
safety at all there's a set of issues
that I'll give you another example of a
a tricky issue their monitor locks in
Java are effectively kind of and their
ambient available so you have to think
carefully about what kind of ambient
authority they provide I can acquire a
lock on any other class I want I believe
and that might invalidate all sorts of
assumptions that doesn't sound like the
capability way the biggest hurdle having
multiple threads is that it raises lots
of non-determinism issues and right now
we actually have some determinism
guarantees that were able to guarantee
with with Joey or we believe that we can
guarantee with Joey and those all go out
the window if you have concurrent
modification from multiple different
threads to the backups to the same
object so are you thinking about adding
event loop concurrency instead like as
in ease batch and stuff like that that'd
be great first step is to get a single
threaded Joey that's a useful and
production quality it's a great research
question could you talk a little bit
about dependency injection and the
differences from the capability style no
probably not because I don't know enough
about dependency injection can anyone
else talk about that I can say a bit I
don't really understand dependency
injection yet but one of the things
that's interesting is that what
dependency injection is trying to
achieve seems very similar to what
capabilities are trying to achieve which
is a dependency as dependency injection
seems to define it is basically ambient
access to some state or Authority to the
outside world and if you make all if you
make all such dependencies things that
need to be explicitly provided
essentially you're programming the Cape
style one way to think about Joey from a
dependency injection point of view is
that it enforces that all dependencies
must be injected
hi um I was actually going to ask the
same question about this is an old idea
why hasn't it caught on sooner and in
fact there was some language-based work
done on this back in the early 1980s and
oh sorry and in the UK on something
called flex the Flex architecture which
used I will 68 and a kind of Mexico
closure approach to implementing
abstract data types and so on so it's
really quite interesting that led into
the 10 15 and F architectural neutral
distribution format so let me ask a
different question which is I was a bit
concerned that your model as you defined
the objective mobility model you said
that the property is that if you have a
capability you can give it to someone
else and that doesn't seem like a good
idea you might want to give someone the
capability but not give them the right
to pass it on to someone else
and they actually found a paper just now
which said that if you have that that
the an unmodified capability machine
with that property violates the star
property which is one of these security
things about information flow so
wondered if you had a view on that great
I'm glad you asked this question because
this is one of the most frequent ones we
get let me see if I can clear it up okay
so let me state first a little more
precisely with the capability model is
if I have a capability talis then I can
give her the capabilities I have in the
capability model yeah no restrictions on
that why is that a reasonable thing well
the slogan that I used to justify that
is don't try to prevent prohibit what
you can't prevent okay so in particular
if I have a capability to Alice I have a
communication channel with her I can I
can talk to her you can exchange
messages if we can exchange message by
have a communication channel with her
and if I want to give her some
capability then
gee even if you try to prevent me you're
not gonna be able to prevent me because
I can always proxy / actually I can
always just wait for her to tell me what
she wanted would have wanted to do with
the cake build and she just tells me to
do it instead and I do it on her behalf
okay so you can't prevent that so
preventing it wouldn't it wouldn't
provide any you know stronger security
properties wooden able you to rule out
misbehavior that you can't do in the
object capability system so so this
that's my primary answer now we can talk
about this
the star principle offline I think that
there my understanding is there's some
flaws in that the the argument and that
in fact this is this is not a correct
conclusion but you know what I don't
want to get into that because I'm gonna
tell you with my Joey mindset I
mentioned I'm focused on integrity not
in confidentiality and reasoning about
confidentiality is incredibly hard I
have no idea how to prevent covert
channels how to prevent any two objects
from communicating with each other if
they're running on the same machine or
in the same JVM there's so many covert
channels they can use a wall banging
attacks that I have no clue how to solve
that problem so in Joey the philosophy
is Joey is not going to help your reason
about confidentiality or covert channels
we assume we reason only about side
effects
we don't reason about knowledge okay so
in particular we're trying to enable a
kind of a conservative bounds on the
behavior of our program and that part of
the way that that reasoning works is if
there's some secret knowledge some
secret bits that would enable you to do
something then the kind of our style of
reasoning says we assume you've got
those bits you guess them luckily or
someone with a Cobra channel
communicated them to you so that's just
not a style if your system relies upon
secret knowledge for its security then
Joey the Joey style a capability
reasoning is not going to help you
verify that it's secure you'll have to
use some other kind of reasoning okay
that answer your question
um yeah I guess what you're saying about
the the passing on the capability thing
seems to relate to this trust issue
because what you're saying is if I have
a capability if I'm you know there's no
difference between me passing it on to
somebody else and me kind of betraying
the trust that's been given to me and
giving me the capability in the first
place
because I cannot act on behalf of that
other person you know and then I mean I
would I'm not entirely sure about that
it seems that you know maybe there's but
it doesn't seem to come down to the
breach of trust in some in some way III
agree that there are differences there I
don't want to suggest they're exactly
equivalent their performance differences
our difference of reliability but my
argument is those differences are are
not are not significant enough to
provide a foundation for your security
case yeah yeah it's an interesting point
anyway thank you you haven't said
anything about the revocation of
capabilities so if you give someone a
capability do you later have the right
to revoke that capability and revoke
only the right you gave them not rights
that others gave them yep great question
yes so one of the standard criticism the
capability model is it doesn't provide
any any answer about revocation at least
doesn't provide any answer within the
system and we could argue about how
important revocation is but fortunately
there's a simple pattern that enables
you to do revocation that capability
style what you do is you build a proxy
object which has a single bit okay by
default that object is enabled and all
message calls are just passed through to
the end target but when you flip that
bit when you disable that object now now
they're no longer passed through and if
I want to give you access to something
that I think I might later want a revoke
I don't give you access directly to the
end target I give you a capability of
that proxy object that I constructed on
the fly and then later if I want to
revoke I can flip the bit I can disable
the proxy and what would the performance
implications of that be don't know I
think one of the one of the one of the
philosophies of the capability approach
is it would provide a bare minimum from
the underlying access control system and
enable you to build your own flexible
abstractions on top of that so if you
want this kind of revocation you can
have it if you want some more
sophisticated kinds you can build that
too so that's why for instance
revocation isn't a fundamental in the
model because you can build it yourself
in the year 2012
what percentage of lines being written
do you think will be written in this
style 2 + or let's say 2 with 2 digits
of accuracy 0
the answer about 2020 I have no idea
predicting the future is hard right you
know to first order any new language
designing new languages is incredibly
low success probability event because
you most there are two orders of
magnitude more languages invented than
people can actually use now we hope that
maybe we can improve our odds because
we're working as a subset of Java so all
of your existing Java tools all of your
existing Java debuggers and development
environments you can use Joey in but the
really the core of this message is not
of this talk semester is not Joey it's
that you can use these ideas in any
language a language like Joey will help
enforce the discipline will help make it
easier for you to be confident that
you've applied the rule but you don't
need to program in Joey to get some of
the benefits that list in the second
line there there's a list of other
languages that are being built by
importing these ideas
so even if Joey doesn't take off there's
a decent chance that it's a risky
project but today I'm an academic I'm
supposed to take risky projects yes the
observation that was made was that in
addition these ideas are spreading and
it's been introduced into a whole suite
of other languages and other systems and
you can find some examples of some of
them and that's an incomplete list there
and if the question is just what
percentage of code will be written in a
dependency or in a capability style we
already have a lot of code at Google in
Java being written in this style as a
side-effect of our adoption of juice the
dependency injection framework to echo
the the comments that others made
previously the design of software to be
sort of referentially transparent in
terms of explicit dependencies is falls
naturally out of juice and we're already
finding security benefits as a
side-effect so I think the percentage
will be higher than you expect great
any other questions okay David and and
his group will be joining us for lunch
and after lunch were going to be meeting
the rest of the day in you have what's
named the room bank we thought we're
sorry in 43 143 first floor we've got a
conference room for the rest of the day
in which we're going to be doing Joey
design the purpose of this is not
introductory the purpose of this is to
sort of dive into the Joey design but
anybody wants to join us for that is is
welcome and let's thank our speaker</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>