<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GTAC 2015: How to Component Test Soup Dumplings | Coder Coacher - Coaching Coders</title><meta content="GTAC 2015: How to Component Test Soup Dumplings - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>GTAC 2015: How to Component Test Soup Dumplings</b></h2><h5 class="post__date">2015-11-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/OLesBZSd-cM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">how was lunch I hope everyone is full
and happy and in that spirit to make you
hungry again we have a cooking lesson
from Tony Chang on how to make soup
dumplings I hope we all had a good lunch
because I was told that my presentation
is put after lunch for a good reason so
my name is Tony Chang and I'm a foodie I
mean a test engineer from Google since
part of my work is to influence past
best practices I find myself having to
convince people with very different
backgrounds like engineers engineering
manager developer relationship manager
and product managers why we want to do a
component test after repeating the basic
test concept over and over again I
decided I want to make this more
interesting I'm gonna use soup dumpling
as an example to demonstrate creation of
end-to-end test case and then breaking
them down into component tests and did I
mention I'm a foodie a few years ago I
went to a really fancy restaurant and
ordered my favorite food the soup
dumpling expecting something soft and
juicy I got something tough and dry I
went to the waitress and asked what is
going on she shrugged her shoulders and
say sometimes good sometimes bad shocked
at her answered I went to the owner
doner is a lot more customer-centric
and told her we are hiding restaurant
and you need to make sure everything is
of high quality
before you serve for those that is new
to this food here's the anatomy of soup
dumpling it's got really thin delicate
skin with soup and meat wrapped inside
usually served warm
the waitress took a pass and said I
guess I can try one before I serve
each plate so each plate will need a
test sample for her to try before she
surf do you think this is gonna work at
least it won't be horrible but there are
limitations and I see at least three
first she won't know or the aspects to
look for so that's the lack of baseline
and then she's got limited stomach space
so if she serves I don't know I play
every five minutes she'll get full
really soon so this is not scalable at
all and then if she found something
that's not right with the dumpling the
customer would need to sit there and
wait for everything to be remade from
scratch so the turnaround time is way
too long fast forward a few years I'm
now it has engineer I exist the engineer
efficient and sustainable test how can I
help
using my learnings from software testing
let's see what I'm gonna do different
first of all I will consult the spec the
spec will spell out the different
requirement and criteria to look for
which will address limitation number one
in software we would have different
documentation x' we're varying different
level of detail like the first column
the one pager has the really high level
attribute of what a soup dumpling should
be like and then in the second column
you've got the PRD which spells out the
use cases and then in a third column
you'll have the functional spec which
has the actual implementation detail
let's use safe to eat as an example if
you would have been creating a manual
test case you can just go by the PRD
because you're made a human tester has
the cognitive ability to figure out
whether something is cooked or not
whereas if you're doing automation you
might need to spell out um what cook
means to define it just like when you're
testing software your human tester would
have the ability to figure out whether a
system has been booted successfully
whereas your automation will need to
look for something more space
civic like what events to look for what
event constitutes to a successful boot
in this case your functionals back has
deer define cooked as 180 Fahrenheit and
your automation will be happy so here is
how your automatable test case could
look like measure this dumpling when it
comes out of the steamer and make sure
that it is 180 Fahrenheit or above and
then your spec also says your dumpling
needs to look pretty and it spouts out
pretty as 18 folds at the top your
automatable test case could look like
validate that it has 18 count the folds
and validate that it is 18 as you can
see both of the test case no longer
require you to actually eat the dumpling
so it addresses the limitation challenge
I mean the scalability limitation
however some of this could be difficult
to validate say for example the softened
juicy criteria the perspex says it needs
to be 30 70 soup meet ratio in order to
automate that you need to first extract
or validate that you need to extract the
soup pull out the meat weight them
separately calculate the ratio before
you know that it has met that criteria
can we do something better probably not
without current understanding because
we've been looking at the dumpling as a
final product and have no insight into
its production process the best we know
is you've got some raw material do some
auto magic and then to him you have your
final soup dumpling but if we understand
the actual production process we might
actually be able to do better so let's
go through this briefly first you make a
chunk of dough divide it into little
pieces roll them into your skin and then
put some meat in there put some soup
jello in there wrap it up and then steam
it after your steam the soup jello will
melt to become soup that's where you get
your soup meat ratio
and if you fill in the detail that
you've just learned about in this
diagram you will see that you understand
the dumpling creation flow a lot more
does this resemble any of your software
architecture diagram and if you look
carefully you will see that there are
multiple there are a few major
components in there
the first one is divide it takes in a
input of a block of soup jello and
output the right amount for one dumpling
the divide component takes more than one
input types it also takes a meat and
I'll put the correct amount your next
component ticks in both the soup and
meat piece and mix it in to become
filling as you can see each of these
component have their independent input
and produce the output that is expected
from them and if you iterate through the
whole process you will see that this is
how the whole flow looks like they each
of the component has a clearly defined
input and a clearly defined output an
testable software design also looks like
this they have well-defined components
and you ask how does this help me well
remember that last test case where you
need to isolate the soup and the in the
meat and all that let's see if we can do
better with component level validation
now that you have your component
isolated you can see that the Y
component is really the only one that
contributes to this end result if you
can make sure that your device is
outputting the right amount of soup
jello and the right amount of me piece
it's really highly likely that your and
without ratio is going to be correct so
if you do a component level validation
all I need to do is validate that the
soup jello is off X graph and the meat
is off y gram the wrapping test case
remember earlier you were looking at
counting the faults after it was cooked
now that you have this diagram you can
easily see that wrapping the filling and
skin is really the only component that
has effect on this final result so it's
instead of waiting for the steam process
you can validate that it has ex-team
folds right after your wrapping
component is complete and as you can see
both of these test cases demonstrated
how component level tests can greatly
reduce the turnaround time and identify
issues earlier in the development cycle
and the last test case we remember the
test case where it needs to be a 180
Fahrenheit with the same diagram you
quickly identify that steam is the only
component that is affecting this end
without while you can validate that it
has been cooked to 180 Fahrenheit if you
look through it think through it a
little bit more your steamer is not
really your system under test if you
have a reliable steamer you should be
able to know that as long as you cook it
for 10 minutes
it will reach different temperature that
you desire so your test case can be
greatly simplified to make sure it has
been steamed for n minutes think about
it in software terms if you're able to
clearly define what your system under
test is and not conflate it with all
this dependency you can also simplify
your test case greatly to test for only
what you want to test for and not
anything else some people say it doesn't
work for my project my project is too
complicated for it to be divided up or
others days that's not really testing
the end-to-end scenario or they said if
I test all the entrance scenario in the
world I can cover my components anyways
well if you look around component
testing is actually everywhere even when
there before there is software when you
go to see how kids learn gymnastic you
will see that they repeatedly stick
their feet out just that and their
instructor would tell them to correct
every minor movement of theirs
after they got that part right they
would then connect it together to become
a routine if you play in an orchestra
for example all the individual
instrument will need to make sure that
their part is fluent before they combine
it to become a symphony or if you play
soccer your coach is going to ask you to
drill on independent skills like
dribbling running even though it's
covered as part of the game so I hope
you see a pattern here any product that
is of complexity be it a physical
product like a soup dumpling or an
experience like a symphony in order to
do it well you need to break it down why
do we think software is any different if
you are semi convinced and want to think
about implementing this there's a ton of
resource online about test-driven
development refactoring testable design
you just need to look around and find
what is right for you
and you ask am I done with really good
component level test unfortunately not
component test is really just a stepping
stone to a finer quality it is not a
replacement of your end-to-end tests
every once in a while you do want to eat
your soup dumpling and every once in a
while dal feed your own product maybe
just not every plate and not every
change that you make I hope this is
giving you a new perspective of seeing
your own product and next time when I
use it is sometimes good other times
also good thank you
so thank you Tony we have a few
questions for you is a component level
test the same as a unit test I would see
unit test as the type of component has
but usually if you want to define it
more clearly unit test is a little bit
smaller test than a component to what
extent is component testing dependent
upon service-oriented architecture can
you component test a monolithic
application
I think component testing is dependent
on a design that will allow you to be
able to test things in isolation so I
would say that it is highly dependent on
how the architecture is and how its the
sign
ah stop flipping sometimes your
components have unexpected consequences
say you change to a new decoration that
sometimes punctures the dumpling and
causes the soup to drain how can you
handle this I think
stuff like this will be captured in the
final validation in an to end test that
you're not skipping I think the point of
component test is really to make sure
that you're catching things early that
you can test in component level and not
replacing things that you absolutely
need need end-to-end tests to cover to
uncover light for your example how does
this compare to the ACC methodology in
the now abandoned Google test analytics
project I am actually not familiar with
the Google test analytic project so
sorry about that and I think we're gonna
call that blast question since you just
have a few seconds remaining so thank
you Tony thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>