<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Sensor Fusion on Android Devices: A Revolution in Motion Processing | Coder Coacher - Coaching Coders</title><meta content="Sensor Fusion on Android Devices: A Revolution in Motion Processing - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Sensor Fusion on Android Devices: A Revolution in Motion Processing</b></h2><h5 class="post__date">2010-08-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/C7JQ7Rpwn2k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone thank you for coming out my
guest today is David Sachs he began
developing motion sensing applications
at the MIT Media Lab and now he does
advanced application development at
InvenSense where he does a lot of
interesting things with compasses
accelerometer accelerometers and
gyroscopes including building them into
Android devices please join me in
welcoming David sacks so the purpose of
this talk is to learn about sensors that
are in consumer electronics
these include accelerometers gyroscopes
and compasses it's kind of a zoo having
all these different sensors out there
there's a big problem people don't
really know how to use them they don't
necessarily know what the sensors do or
what their strengths and weaknesses are
they don't know how to put the data
together there's also a lot of
misinformation out there about what's
actually in different devices and this
causes a lot of confusion so I'd like to
pay my respects to some non-existent
sensors which you'll you'll see in press
releases even though they don't exist
people write all sorts of interesting
stuff about them on forums these include
the six axis accelerometer which
apparently the Samsung epic has
according to Sprint the six axis
gyroscope the very mysterious gyroscopic
accelerometer and the gyros the gyro
compass I have to say actually does
exist there is such thing as a gyro
compass it's not shipping in any Android
devices today it looks kind of like that
maybe someday so this talk is going to
start by covering some examples of
applications we'll show you some demos
then we'll get into the more sciency
aspect of it will talk about the sensors
themselves accelerometers compasses and
gyroscopes then we'll talk about sensor
fusion how do you put this stuff
together
system integration and by that I mean
how did we make this so this is a
modified Nexus One
it has accelerometers compasses and
gyroscopes in it it does sensor fusion
and we wrote a bunch of applications on
top of it in order to put the extra
hardware in it we had to rip something
out first so I'll leave you guys to try
to guess what it is we ripped out and
you'll find out about halfway through
the talk and then of course you know
really no one cares about all of this
stuff they just want to use sensor
fusion most people just want to write
applications that use motion so you know
hopefully this technology can make life
easier for application developers so
they don't have to worry about what's an
accelerometer what's a gyroscope what's
a compass how do you put all this data
together they just want to know how to
use the information that comes out of it
so let's get started with some
application examples gaming gaming is
really fun this party started with with
Nintendo they did motion sensing gaming
now everybody's doing it so I'm just
going to jump right in and show you some
some motion sensing gaming demos so this
is not a game it's just a sword but you
can see it does what I do that's pretty
cool so this uses gyroscopes
accelerometers and compasses that
measures all sorts of orientation you
can see it's it's pretty stable and it
moves quickly when I move and it stops
when I stop the latency is very low on
this system but I'm not sure if that
will come through on the the VC system
but that's not a game I promised you a
game
here's a game I'm flying through a
tunnel
there's my tunnel I can go left right up
down
I can turn sideways I can fly upside
down if I want I have to fly through
these doors
that's tricky to do while talking on the
microphone yeah that's a motion-sensing
game pretty fun so we'll come back to
this game at the end of the talk and
I'll tell you how we did this moving on
so here's some more applications we have
a virtual reality and augmented reality
I've got virtual reality on the left
augmented reality on the right and
whatever the heck Street View is in the
middle I'm not sure sort of like real
virtual reality that's augmented or
something I don't know but all of these
use some motion sensing so I'll show you
this on the on our phone it'll be kind
of hard to see but I'll have a video I
can show you too so here's a here's our
virtual reality system I can look down I
can look up I can look forward turn
sideways pretty cool so the motion
sensing part of this is basically one
line of code once you have your output
of sensor fusion you just draw some 3d
stuff and put in your one line of code
so for those of you who can't see here's
a video of basically the same exact
thing this is an older system running on
a g1 but it's it's really the same
application so you can see so here turns
off the sensor fusion so now it's just
accelerometers and compasses and it
still works actually you can do all of
this stuff already right it's just a
little bit slow that's that's the main
thing that all the sensor fusion adds it
just sort of upgrades the motion sensing
capabilities alright so mouse this is an
example of a mouse that has gyroscopes
and accelerometers in it does some
sensor fusion and controls a cursor
here's a demo of that it's a gyro Mouse
pretty simple right it's very easy to do
once you have all your sensor fusion
done basically again it's just a couple
lines of code to do something like this
so it stops when I stop moves when I
move left/right up/down user interface
okay well user interface is kind of a
zoo there's all sorts of stuff you could
do in and call it user interface I'm
going to play a little video we also
have phones that run all of this stuff
you guys can play with it later on if
you want here's what we did we zoom in
using motion then you can the pan around
using motion also you can do a lot of
stuff that way using only one hand which
is kind of nice don't have to smudge
your screen and you know the
pinch-to-zoom thing is kind of tricky to
do with one hand this is a little bit
easier here's some more complicated
stuff so there's some gestures you can
draw a letter in the air and that
launches an application you can also
train a signature so here he's training
the letter M because his name is Mike
once he's trained his signature then you
know he can go to an authorization
application and then instead of typing
something in which would smudge the
screen he can draw his letter M in the
air and it unlocks it if you draw some
other pattern it doesn't work so these
are examples of things that are pretty
easy to do once all the sensor data has
been put together and you no longer have
to worry about what's an accelerometer
what's a compass what's a gyroscope
image stabilization we don't have a good
demo of that here today but it's
something that people have been doing
with these sensors for for decades and
navigation of course this is a talk in
its own this stuff is pretty hard we'll
touch on it a little bit but I you know
I won't get too deep into how navigation
algorithms work and of course all of
this stuff runs on a handset that's why
this is really interesting for for
Android once the sensors are abstracted
out of the system and you just have the
result of your sensor fusion data then
you can write apps and take advantage of
the stuff so let's jump right into the
science part talk about the sensors
accelerometers easiest to visualize as a
mass on a spring they're very simple
they sort of jiggle when you shake them
they pick up just about every kind of
movement that's the good news the bad
news is they pick up just about every
kind of movement usually you have no
idea what it is you're actually looking
at so here's some examples the mass will
will droop under gravity right so that's
pretty intuitive in a real accelerometer
of course you don't have these curly
Springs you have beams usually that flex
if you drop it it actually measures zero
that's kind of strange the first time
you've played with accelerometers that's
freefall and the reason why is because
gravity pulls both on the mass in the
middle and on the frame of the
accelerometer so there's no relative
movement between the mass and the frame
so how is it that you measure gravity
well there is this additional force
holding the structure up so when you
have that additional force holding the
structure up then the mass will droop
under gravity so this gives the kind of
surprising result if you've played with
accelerometers a little if you point in
accelerometer axis up it will actually
measure +1 G so you might have thought
it would measure a minus number because
gravity is pulling it down but that's
not the way it works it's actually
measuring the force of you holding the
accelerometer up so accelerometer just
exposed to gravity actually outputs 0 of
course it also measures sideways
movement you shake it side to side you
accelerate it the mass experiences a
reaction force and typically you get
something like this so this is usually
what you're looking at it's it's just a
big mess and you don't know what it is
exactly you're looking at so that's an
accelerometer here's one close up like I
said it's it's got beams that flex not
curly Springs this is using MEMS
technology pretty interesting you can
etch mechanical structures into silicon
so that makes it really cheap and you
can put logic next to it pretty easily
compasses so compasses no longer look
like that that's sort of what you
imagine compass is a magnetic field
sensor it picks up every possible
magnetic field that includes the
vibrating motor right next to it if this
isn't a phone it includes some stuff
from the blue to
chip it includes speakers microphones
anything on the circuit board that's
been magnetized and it's it's kind of a
train wreck actually I'm always
surprised that these work at all in
phones but they actually work pretty
well considering the noisy environment
why do you need a 3-axis compass I get
that question a lot
well if if you have your compass held
like this and my x and y axes are flat
then I really only need the X and y axis
to measure my heading but if I hold my
compass like this now my x and z axes
are flat and I need an X and a z-axis to
measure my heading so if you don't want
to tell the user how to hold the compass
and you want them to be able to hold it
any way they want then you need a three
axis compass and you also need an
accelerometer so you can't compass at
any orientation without an accelerometer
to tell you how you're holding the
device magnetic fields are kind of weird
the Earth's magnetic field doesn't point
exactly north so you need to know your
GPS location to know where North is if
you have magnetic north and there's also
something called magnetic inclination
the magnetic fields not actually
horizontal it's a it's somewhere between
horizontal and vertical here it's
actually more vertical than horizontal
it's like sixty degrees from horizontal
but there's enough of a horizontal
component to resolve your heading of
course when you get up to the North or
South Poles then you're screwed so how
do the compasses work well this this is
how the compasses with the biggest
market share work in consumer
electronics there's not a spinning
needle there's actually just current in
a wire and that current in a wire gets
deflected by the Hall effect if there's
a magnetic field present so you can
actually create a compass with just pure
silicon electronics you don't really
need ferromagnetic material for it and
that's a close up of a three axis
compass it has some Hall sensors and
some logic that's a compass so now we
get two gyroscopes so gyroscopes are the
the Newcomer gyroscopes sense angular
velocity so that's very different they
don't sense an external reference like
magnetic north or gravity gyroscopes
measure their
own rotation so how does that work they
use something called the Coriolis effect
so the Coriolis effect happens when you
have a mass that's moving and your frame
of reference is rotating so when that
happens you get the fictitious force on
the mass and you can pick up how your
frame of reference is rotating so the
earth is rotating so the Earth's
rotation has some impact on things for
example weather systems the way weather
systems spin in the northern or southern
hemisphere depends on the Coriolis
effect if anyone ever told you that
toilets spin one way in the northern
hemisphere and the other way in the
southern hemisphere because of the
Coriolis effect that's actually not true
unless your toilet is like miles long or
something like that or perfectly
polished anyway okay so how do you
actually pick up the Coriolis effect
well I said you have to move a mass so
you might as well move that mass back
and forth really really quickly so
that's what a gyroscope does it actually
oscillates
there's nothing spinning in a MEMS
gyroscope and it oscillates and you can
pick up the Coriolis effect from that
mass oscillating by looking at something
else that happens so the mass oscillates
there's a torque that's provided and
then you can look at these capacitive
sense combs picking up that signal so
these this is slow motion of course
typically these things oscillate at very
high frequencies maybe 25 to 30
kilohertz
so the actual frequency of oscillation
where you put that depends on what else
in the system you're trying to avoid so
if you're trying to avoid audio
frequencies or if there's another motor
in the system that's going at some
frequency you might want to be careful
about what frequencies you put your gyro
at and here's a close-up of a 3-axis
gyroscope so you can see these um these
mechanical structures in that cutaway
they these are the ones that vibrate and
the wiggle and sense and stuff and then
underneath is the the silicon that has
all the logic so the bigger chip
underneath does all the signal
conditioning and actually does the
sensor fusion so this chip has a three
axis gyro that actually does sensor
fusion it takes input from other sensors
so that brings us to sensor fusion so
how do you put all this data together so
let's start by putting accelerometer and
gyro data together here's an example of
accelerometers being used as a tilt
sensor so it basically works but it's
kind of noisy so what does everyone do
they filter it so here's a low-pass
filter
it works but it creates a delay so
that's why accelerometer tilt games are
always kind of slow because to get past
all of this noise you have to add a
low-pass filter
yeah so here's the gyro data so the gyro
data looks much nicer it's really smooth
doesn't have that weird spike but of
course gyro data isn't perfect either
right because gyro data first of all
doesn't actually measure gravity right
the whole point is to figure out your
tilt with respect to gravity gyroscopes
don't measure that accelerometers do so
you know we can put this data together
we get the nice dynamic response from
the gyroscope and we get the gravity
measurement from the accelerometer then
we have something that works well so
I'll give you a little demo of how that
works
okay so here's this a little
oscilloscope shot of a whole bunch of
data so if you look at the Y
accelerometer graph that's in the middle
on the right you're right again if I
point the y-axis up it measures 1g as I
point it down it goes to minus 1g so
it's measuring tilt that's that Y
accelerometer it looks kind of noisy
that's my handshake actually being
amplified a little bit because it's
adding in the linear acceleration of my
hand shaking and if I move quickly you
get these weird spikes see that should
get a square wave but instead I get this
strange spikes so now let's look at the
Z gyroscope data so the Z gyroscope is
this axis I'm rotating about now and you
get this nice big angular velocity
signal on the Z gyroscope but whenever I
stop it goes to zero gyroscopes don't
actually measure gravity they measure
rotation so however I stop it's zero so
I need to put this data together somehow
so on the Left we have a signal we call
gravity so this is one of the outputs of
sensor fusion that you might want in
your application if you compare why
gravity - why accelerometer you can see
they look really similar right the Y
gravity is much smoother because that
weird jittering thing is gone
if I move quickly the spike is present
in the accelerometer data but not in the
gravity signal so that gravity signal is
kind of strange it's actually mostly
gyroscope data but with the
accelerometer used to correct drift so
this gravity data is probably what you
you wish you had when you were writing
your accelerometer based game it's it's
what you really want is the output of
sensor fusion not just one sensor so to
summarize what you do is you take the
gyroscope you get your orientation from
it and then you use the accelerometer to
inject a correction term that keeps the
orientation correct with respect to
gravity and removes drift so how did we
get that orientation signal from the
gyroscope anyway so you have to do
something called integration right so
gyroscopes output angular velocity what
you really want is angle so you do
single integration integrations a little
weird the blue stuff is just noise that
I generated and the red stuff is the
integral and you can see that it has
very different properties so it looks
less noisy but more drifty so
intuitively integration turns noise into
drift and that's actually one reason why
the gyroscope signal is so clean it's
because it's integrated and here's the
math behind it
if you integrate a cosine you get a sine
but you also get this 1 over F that
comes out in front that means if you
have a hundred Hertz jittering on your
gyro data from noise when you integrate
that drops by a factor of a hundred so
you lose your noise but on the other
hand if you have a very low frequency
noise on the gyroscope when you
integrate it gets amplified so you have
you get rid of your noise and you add
drift so integration is kind of a mixed
blessing so in order to do this well you
have to do it quickly so
here's a very simplified equation you're
integrating angular velocity so you
multiply it by time and accumulate it
that gives you your angle now in order
to do this well the time has to be
really accurate so you're multiplying
your gyro data by time that means if
your time is off by five percent it's
it's just as bad as if your gyro data is
off by five percent it's the same impact
and you also want your time interval to
be really small so what we do is we do
it in hardware so you can do it at a
very fast rate basically you have your
sensors then you have a separate motion
processor then you have an application
processor and the sensors in the motion
processor in our case are on are on one
chip one piece of silicon so that sort
of abstract sout a lot of this high rate
integration stuff so let's let's move on
so now we're going to combine compass
and gyroscope data it's basically the
same story compass data gives you the
answer you want which is your heading
but it's noisy its noisy for two reasons
one reason is that it's picking up real
noise real signal so we live in an
environment that's magnetically very
noisy so and this compasses they pick up
everything that's magnetic the other
reason is that it's not integrated so it
doesn't have that benefit of dropping
the frequency component so compasses as
we said require tilt compensation you
can't figure out you're heading unless
you know where the horizontal plane is
relative to how you're holding a device
tilt compensation is done with
accelerometers but by themselves they
don't measure gravity well so you get
this strange sort of bootstrapping that
you have to do where you have to tilt
compensate the compass with
accelerometers and gyroscopes before you
can complete your sensor fusion so in
summary it looks like this again
gyroscopes provide orientation
accelerometers provide a correction due
to gravity and compasses provide a
correction due to magnetic north so I'll
show you a little demo of that
so here's my sword again this is using
all the sensors together
so let's say I just use accelerometers
and compasses so it still works gives me
the right answer it's just slow right
there's this delay
now let's say instead I use only
gyroscopes so gyroscopes have really
good dynamic response a perfect
gyroscope I could do this forever and it
would never drift of course real
gyroscopes drift so this thing won't
stay in the right place forever but it
looks pretty good in the short term
what you really want is all these
sensors together so now I have the
gyroscopes providing the good dynamic
response and I have the accelerometers
and compasses providing the correct
answer in the long term so that's my
fuse data so now we get to position so
accelerometers measure side-to-side
movement so can't you get position out
of them well it turns out it's really
really hard but let's let's talk about
how that would work so linear
acceleration which is what you want just
my side side up down and forward
backward movement you have to take the
accelerometer data and you have to
remove gravity this is called gravity
compensation so once I've removed
gravity whatever is left is my linear
movement then you have to integrate it
once to get velocity integrate it again
to get position that's your double
integral now if the first integral a
single integral creates drift double
integrals are really really nasty they
create horrible drift here's a graph of
it
the red stuff is a single integral you
can see that random walk we talked about
before it's sort of meanders off in some
direction and the green signal is the
double integral it's just taking off now
this is an integration of noise so you
can see this this is simulating an
accelerometer I'm holding it in my hand
not doing anything and it drifted off by
20 centimeters in one second so I don't
know is that good or bad actually I
think that's pretty good as you'll see
in a second but so one second of drift
twenty centimeters of error that's from
integrating noise but that's not the
problem here's the real problem the
problem is remember back at the
beginning of this slide when I removed
gravity well I probably didn't do that
exactly right that's pretty hard to do
that perfectly so let's say I got it
wrong let's say I thought I was holding
this thing at 37 degrees but I was
really holding it at 38 degrees so I
screwed up my estimate of gravity by one
degree well now I double integrate that
I get a parabola so I'm double
integrating a constant right here's what
that looks like so for comparison the
green line at the bottom is the same as
the green line in the
graph on the left now it just looks flat
right so the new error is this blue
curve that's eight and a half meters of
error in one second so I was holding
this for one second I screwed up my
orientation by one degree and I got
drift of eight and a half meters so you
can see why it's really really hard to
do any kind of linear movement so step
one is try to figure out how to avoid it
in your application just use orientation
you'll be happy you did there are some
ways to improve the linear movement
estimate but if you're going to do
linear movement any kind of orientation
error is really really important all
sorts of errors couple and including
things like cross access error between
the accelerometer and the gyroscope
everything matters so let's finish this
off I have my orientation estimate and I
add linear movement so the way you do
that is you first gravity compensate the
accelerometer using the gyroscope so in
order to make sure I have the best
possible estimate of which way down is I
need all of these sensors then once I
have the best possible estimate of which
way down is I subtract that whatever is
left is linear acceleration and then I
double integrate and pray it still
usually doesn't work that well so here's
some tricks well what we have is at
least better than a high-pass filter
that's what everybody's doing now they
want to make some game where you shake
it so the high-pass filter the
accelerometer data whatever is left they
pray as your shake signal and it really
doesn't work the reason why it doesn't
work is because you're assuming that
gravity changes slowly but it doesn't
gravity changes as quickly as I can do
this so gravity changes really fast
because it's the gravity with respect to
your device so high-pass filters don't
work that well this works a little
better if you know something about how
the device is moving you can do even
better by modeling your dynamics with
something called a common filter which
probably could be a completely different
talk so I'm not going to go into it in
too much detail but let's say these
sensors are in a car well the way cars
move is very constrained cars can't
accelerate in any possible direction
they're not going to go straight up for
example so you can constrain your error
using a model of how cars move and a
common filter is a pretty good way to do
that
that's for automotive navigation if
you're doing pedestrian navigation and
you want to walk around usually you use
a pedometer algorithm so you don't just
double integrate the person you you
watch for steps and you do an algorithm
based on steps so there's a two really
common trick tricks to avoid your your
double integral okay now before we move
on to the next section let's just cover
a little bit of terminology there's two
different coordinate systems that are
important one is the coordinate system
of the earth which includes gravity
includes magnetic north if you're
controlling a TV or a computer it would
include the TV or the computer and the
other is the coordinate system of the
device that you're holding so those are
usually called world coordinates for the
earth and body coordinates for the
device that you're holding and then you
know accelerometers and compasses
obviously measure relative to the earth
they measure gravity and magnetic north
gyroscopes are different they actually
measure in a different coordinate system
the gyroscopes measure in its own
coordinate system so it measures
rotation around itself and then though
just very quickly the difference between
degrees of freedom and axes you see this
thing a lot sixaxis something-or-other
what does that really mean well what
people really want is 6 degrees of
freedom that means I can move left and
right that's one forward and backward
that's 2 up and down that's 3 and then
you also have rotation around the three
axis that's we're going to call that
roll pitch in yah although we'll define
that a little better in a second those
are six degrees of freedom six axes
usually just refer to the axes of the
sensors so six axis can mean almost
anything which is why it gets abused a
lot in marketing I have a six axis
sensing device I have no idea what that
means you could have a one axis
accelerometer you could have six of them
in a row and call that a six axis sensor
so some people when they say six axis
they mean accelerometers and gyros some
people mean accelerometers and compasses
anyway so six degrees of freedom versus
six axes at least know what they mean
okay so now we get to system integration
so that's the part where we we built
this so what we ripped out was the
headphone jack that was probably the
most fun part then we we took a little
board and soldered it to the i2c bus and
then we started hacking Android so
here's here's what we did actually the
first thing we did is we just built our
own j'ni wrapper around our own library
using a standard Linux i2c driver so
that's not really um using the sensors
within Android that's sort of using the
sensors near Android or something like
that this is what we we did in our
second draft it's a little bit tricky
because right now there isn't really a
great way to do a whole bunch of math on
these sensors in post-processing so for
example we could put it in the kernel
but we don't really want to put our
stuff in the kernel we could put it in
the user space but then it gets copied
so if you put too much stuff in the
sensor manager you get all these copies
of the sensor manager so what we ended
up doing was actually hacking the sensor
service which is not really what you're
supposed to do but it actually worked
pretty well so we we put our our driver
in the sensor service it talks to our
sensors through a standard i2c driver
and then it sends data out to the sensor
manager we're not really thrilled with
it but it actually works pretty well
we're working on a new version of this
that will be a little more efficient but
this is sort of where we are right now
so maybe that doesn't matter to you you
just want to know how to use this data
so here's what comes out so you've got
your sensor manager right you want to
write an application that uses sensor
fusion here's what you have right now
you have some raw data and you also have
some compass and accelerometer functions
so we added a whole bunch of other
sensor fusion stuff so we have for
example a quaternion output which we use
to do a lot of stuff we also have
rotation matrices and Euler angles and
then we also added a bunch of higher
level algorithms on top of that so our
gesture pedometer stuff
the signature recognition we call glyph
that's somewhere we train characters
so this is our this is our entire
library that we exposed through the
sensormanager
we're not really sure where these
higher-level functions should go but we
stuck them in the sensor manager and it
worked for us and then of course all
that stuff just goes up to the
application okay
so here we get to the final section so
here's how you use sensor fusion well
first of all what comes out of sensor
fusion well we have a this gravity
vector we mentioned and a linear
acceleration so one way to think about
this is you have your accelerometer data
it's really the the sum of two things
that you wanted separately so sometimes
you want gravity sometimes you want your
linear acceleration but you what you
ended up with was the sum so a sensor
fusion basically helps you separate them
so then you have gravity separate from
linear acceleration if you added them
back together you get this raw
accelerometer data then we have
orientation well orientations kind of a
crazy zoo in itself so there's all these
different ways of expressing orientation
Euler angles rotation matrices axis and
angle quaternions maybe you just want
the change in your rotation so we're
going to cover all of these just a
little bit and talk about how you would
use them in an application and have a
couple lines of code for each and of
course the other thing that comes out of
sensor fusion is better raw data so all
of these sensors they have problems but
luckily they have different problems so
they all have since they all have
different problems they can it can
calibrate each other one sensor can make
another sensor better okay so very
quickly gravity well you know what that
is it's that thing everyone's using to
write their tilty games with right
except it doesn't work that well so it
should be easy to port your existing
accelerometer code basically you rip out
the accelerometer stuff and you put in
gravity it should just work better and
you can take out that low-pass filter
that you've been using because you don't
need it anymore so that's gravity that's
the probably the easiest one to know how
to use if you already know how to write
a tilt game with accelerometer data you
can just immediately do a better one
that uses all of the sensors
linear acceleration so that's um you
know for shaking games or something side
to side up and down again you've already
tried to do it with accelerometer data
it didn't work that well it should work
a little better just by putting in
linear acceleration data all you need to
do now is take out the high-pass filter
that you've been using which didn't
really work anyway I'm going to demo
that one quickly because that's not
completely intuitive okay so on the on
the Left we have linear acceleration on
the right we have raw accelerometer data
so you notice again the Y accelerometer
data measures gravity as I tilt back and
forth but the Y linear acceleration data
does not so it stays at zero because I'm
not moving sideways if I go up and down
both of them measure that right so the Y
accelerometer and the Y linear
acceleration both measure this
up-and-down movement but the Y
accelerometer has this bias error that's
because it's measuring the up-and-down
movement plus gravity so it's measuring
both of them whereas Y linear
acceleration has had the gravity removed
by the sensor fusion process yeah so if
I turn it upside down I get the bias in
the opposite direction
okay so now we get to the the the last
part of the talk which is how do you
express rotation expressing rotation is
actually really really hard so we have
to spend at least a couple minutes on it
so really the problem we're trying to
solve is how do I say what happened to
the green tea pot to make it the blue
tea pot something happened to it it
rotated but how do you write that down
turns out there's a few ways to do this
and all of them have some problems it's
good to understand how that how they
work if you want to use this stuff in an
application so let's compare it to
linear movement so for example let's say
I have some arbitrary linear movement I
want to express
that's that diagonal green line well I
can express that as the sum of a
vertical movement and a horizontal
movement so that's great that works
really well using vectors I can go the
other way too I can do the horizontal
movement then the vertical movement
works great so what if I try this with
rotation well it turns out it doesn't
work that well so let's say I take my
teapot
rotate it around the handle then rotate
it around the spout well here's where I
ended up let's try it again
take my teapot rotate it around the
spout then around the handle well I
ended up somewhere completely different
so rotation inherently is messy it
doesn't work as well as linear movement
so what are we going to do are we
screwed there's a couple ways of
expressing rotation that work pretty
well so we'll talk about those this
one's really cheating but I like it
let's forget about rotation and just
talk about the change in rotation so
from one point to the next how much did
I rotate around the y axis how much did
I rotate around the x axis if you do
this for a while you're not going to get
anything that accurate but it turns out
it works really well in the user
interface for example let's go back to
the gyro mouse so again I move
left/right up/down works pretty well
right well this is easy actually all I'm
doing is looking at the change in
rotation around one axis and mapping
that to a movement of pixels left and
right I can look at the change in
rotation around this axis and map it to
pixels moving up and down so it makes it
see
linear that's why it's nice for a user
interface so to summarize you you look
for your change in angle which really
should be between two rotation matrices
it's not that accurate it's easy to map
to stuff and you can do it in a couple
lines of code once you have it so if
your sensor fusion outputs what you what
you what you want which is angle change
then here's all the code you need so for
example we use this in a panning when we
pan in an image it's really simple just
accumulate your angle change in your pan
variables and then use a GL translate
three lines of code to to make a motion
based panning system okay so now we get
to Euler angles named after this guy
yes it's pronounced Euler not sure why
but everybody loves Euler angles even
though they actually don't work that
well will explain why they don't work
that well so again we want to get from
the green teapot to the blue teapot so
we can express that as a series of
rotations so we're going to rotate
around the vertical we'll call that yaw
we're going to rotate that around an
axis through the side of the teapot
we're going to call that pitch or
elevation and then we'll rotate through
the spout and we'll call that roll so um
you know if you look at my arm
this is yah that's also called heading
just which direction you're looking this
is pitch also called elevation and then
this is roll rotation around the axis
through my forearm now we have a problem
what if I point straight up and do this
is that yaw or is that roll well I'm
sort of changing my heading and I'm also
rotating around an axis through my
forearm and actually it turns out when
you point straight up with Euler angles
everything breaks and I'm going to demo
everything breaking it's really
important to understand that this
happens oiler angles work okay for these
guys so in a lot of navigation systems
they use Euler angles so is it a problem
that you can't point straight up or
straight down well it depends on your
application let's say your application
is a passenger jet or car or a submarine
the fact that you can't point straight
up or straight down is not really a
problem
if your pitch goes to 90 degrees or
minus 90 degrees really it'll be the
least of your worries that the Euler
angles aren't working so let's use it in
an application just be careful don't let
your pitch go to 90 degrees there's
tricks you can use to get around that
you can sort of change your definitions
on the fly so if this is my forward
direction as I start to point up I might
run into trouble because my pitch is
going to 90 degrees quick let's redefine
this is forward so now my pitch is zero
people play all these games they're
really messy personally I try to avoid
using Euler angles unless I have to
here's some code so once you've got some
Euler angles you can do a pitch in a
yawl rotation for example here's another
example sometimes you get lucky and
someone provides an API that takes pitch
and yaw so let's let's look at a demo of
that so of course I always go to the
Grand Canyon with Google Earth okay so I
got my yaw and let's call that pitch I
can turn sideways this is pretty fun so
with a very small amount of movement I
can control which way I'm looking I go
like this I can look down okay so where
do I run into trouble well let's say I
point straight up hey it works fine so
that's because I cheated this is
actually roll so I switched pitch and
roll to make it work that's another
messy game people play so I'll show you
pitch now as I turn sideways like this
eventually my pitch goes to minus 90
degrees and my Oyler angles should
explode there they go
okay so it's important to know that this
happens right if you're going to use
Euler's angles but it does work right it
worked great till I did the thing I
wasn't supposed to do so if you
constrain your application oiler angles
actually work just fine okay so now I
get to rotation matrix again we want to
go from the green teapot to the blue
teapot here's a rotation matrix
basically multiply it by any point on
the green teapot it gives you the point
on the blue teapot so
that definition is pretty simple it's
nine numbers
what are those nine numbers mean should
I just ignore them and just use it as a
matrix and multiply things by it
actually I like those nine numbers I
like to use them for things here's a
good way to visualize them if you
picture x y and z-axes sticking out of
the tea pot those axes twist around with
the teapot
you got three axes together that's nine
numbers by coincidence those are the
same nine numbers in your rotation
matrix so for example if you have a
rotation matrix and you want to know
what's the direction that stuff will
come out of the spout of the teapot you
actually already have that information
it's just a vector that you can pull
directly out of the rotation matrix so
sometimes you can just take numbers out
of the rotation matrix and map them to
things here's how you use a rotation
matrix you can use it to rotate stuff in
opengl so there you go there's one line
of code to to use your sensor fusion in
an application you just multiply by your
rotation matrix and you're basically
done we've got to be careful because
OpenGL actually defines their matrix
like that so you might have to add some
zeros on a1 and of course you can also
just like I said pull numbers directly
out of the rotation matrix and use them
for things just look at the numbers and
sometimes they're useful okay so a
couple more axis an angle well you can
express the rotation of the teapot from
green to blue as one rotation around
this axis by this angle so that's sort
of interesting any rotation no matter
how weird it seems you can write it down
as one rotation by one angle around one
axis so you need four numbers here the
angle and three numbers for your axis
we'll come back to that in a second but
first quaternions so these are my
favorite everyone hates them people are
scared of them they actually work really
well I think people are scared of them
because if you look them up you get
stuff like four-dimensional vector that
lies on a hypersphere
that's a hypersphere actually you can't
really draw a hypersphere so that i
think the picture said a two-dimensional
projection of three dimensional
projection of hyper sphere or something
like that anyway I don't really care
because quarter nians basically access
an angle you can use it like that if you
don't believe me that's a quaternion
look at the numbers
there's XY and Z it's your axis and
there's theta that's your angle so most
of the time that's how you use it so
here's how you use a quaternion in one
line of code gl rotate F there it is
this is how that sword worked this is
also how our little virtual reality demo
works there's really one line of code to
do all of the motion sensing in that
application and that's the line of code
so you pull out the angle from the first
component of your quaternion and then
the other three become your axis it's
pretty simple actually quaternion the
reason why people like them is because
you can do stuff like interpolate
between them don't try interpolating
between two rotation matrices because it
usually hurts oiler angles also hurt you
can do it with quaternions so let's say
I don't like my green and blue teapot I
want to find the one right in the middle
or I want to extrapolate and find the
next one that's pretty hard to do with
them with anything except quaternions
well and that's basically it I'm going
to show you one more demo so here's my
my flying game again
there's my tunnel so let's just
summarize everything that we did
so this flying game uses vectors from
the rotation matrix to figure out which
way I'm pointing it uses roll from the
Euler angles so you can use Euler angles
in this game right because I can't point
straight up anyway I'll bang into the
tunnel
so sometimes you can constrain your
application so Euler angles work we also
use linear acceleration in this game if
I punch forward it speeds up if I pull
back slows down and so there you go
there's your sensor fusion
okay that's all</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>