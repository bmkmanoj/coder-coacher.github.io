<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ZuriHac 2016: Generic (and type-level) Programming with Generics-sop | Coder Coacher - Coaching Coders</title><meta content="ZuriHac 2016: Generic (and type-level) Programming with Generics-sop - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>ZuriHac 2016: Generic (and type-level) Programming with Generics-sop</b></h2><h5 class="post__date">2016-09-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/sQxH349HOik" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so yes I will talk about generic and
type level programming which narrates
SOP and I just get a rough idea I would
like to know who has an idea what
datatype generic programming is uh-huh
okay great who has worked with generic
deriving before like it with the built
in GC deriving or generic deriving
construct okay that's quite a lot I'm
who has worked with scrap your
boilerplate before okay and who has just
to have a control group who has not
heard anything of any of these okay okay
great so I will I will try to give you
an introduction to to what generic
programming is all about both and I'll
try to give you a couple of examples and
and the basic idea of generic
programming or data type generic
programming to be more explicit is
actually this you want to define usually
an overloaded in the context of haskell
function that works for many different
data types and let's actually use mono
it's as a first example in this talk
imagine you like I mean Mahmud's extend
rather nicely over products right if you
if you have a mono I'd structure on a
bunch of of data types and you have a
single construct or record like data
type and every component of that data
type happens to be an instance of monoid
and you can relatively easily define by
hand an instance of Moet for that record
type and simply by saying the DM empty
so they did it a neutral element of the
mall it is the the neutral element in
every component and the the binary
operation
it's just through zipping the record two
records together where you apply the
binary operation
in every component but if you if you
would have to define that instance by
hand you still will have to write quite
a bit of code because um it's a
user-defined data type it's not sort of
a generic end Tuffle but it's a it's a
user-defined data type that you gave a
constructor and you define the fields
and to actually define instance monoid
of that thing you have to you have to
write code and so that's a typical
example where you might want to use
generic programming for tis I have a way
of sparing yourself this effort of
writing all this down by hand and rather
than nothing to give an instance for all
your thousands of different record types
that you might have in your application
and making them an instance of monoid
manually you would like to have one that
works once and for all
and by the way if you have questions
than interrupt me immediately don't wait
until the end so so rather what we're
going to do is rather than trying to
define our Monroy to operations for the
data type that we are actually
interested in which is the a in there
the data to have a directly we're going
to go over to a generic representation
of that data type that I'm calling rip a
and I'm not going to say yet what that
representation is only that after
applying this transformation all data
types in Haskell are suddenly going to
look rather similar and there is a
common structure and that common
structure you can exploit for defining
functions and then rather than defining
for example the monoi dependent
operation on A's as a function from a to
a to a we're going to try to define it
for rep A's for any type a that is in
this generic class we're going to try to
define an append operation that works on
these representations and produces a
representation again and this is
hopefully a simpler problem because
these representations as I said they
have common structure and you
and work on them more easily and then
like once we have that we can just use
these transformations that we also have
the Froman to function to go back to the
original basis hard right and then we
can basically give them a map end
operation that works for all types that
are in this generic class and and then
we have only the task left to make all
our record types an instance of this
generic class but if the compiler can do
this for us or template haskell or
whatever then then we're done right and
then we are more powerful as programmers
than before because rather than having
to build instances for quite a number of
different classes for quite a number of
different data files manually we just
have to derive this one generic class
and then we can program in Haskell
instances for other classes yes because
because the representation as you can
already see there is indexed by the type
that it is a representation from so it
still guarantees that you're putting
together two representations of the same
comment okay
indeed there are quite a few choices on
how to define rip and and this is a
simplified view that I've just given on
on the problem of generic programming
and if you'd ask other people they would
give you different definitions but but
even if you take this definition and you
look at all the the plenty of approaches
that are out there in like just in the
hospital world alone to do something
like generic programming the the most
significant difference and style and
flavor you get is by how exactly you
choose your representations and and for
example the built in representation that
GHC uses that I'm not going to talk
about in this talk is going to break
everything down and to essentially
binary pair ISM binary choice
like the either a later time so whenever
you have a choice between two
constructors and a datatype the GAC will
generate something like an either for
you and whenever you have multiple
fields and one constructor of a data
file guc will generate something like a
pair for you and unfamiliar other than
having to deal with all the different
data types you only have to deal with
binary choices and binary pairs and
that's it but then the GHC
representation makes it all more
complicated again by doing other stuff
as well but but that's one option and
and we're going to look at a slightly
different representation in this talk
which is implemented in this library
that's called generics SOP so let's look
at an example data for this expression
data type it's just an abstract syntax
or for a simple language you have it
doesn't really matter we're not going to
use that by the time very much
throughout its half of Tyria have
integer and boolean literals variables
that are strings you have an
if-then-else statement that takes three
expressions so these are untyped
expressions right I mean you can you can
go type in correct terms and you have an
addition that takes two expressions and
the greater or equals so if we want to
construct a value of type expression
what do I have to do first what's the
first thing I have to do if I want to
construct any value of type expression
that isn't undefined who is a
constructor right I have to choose a
constructor how many choices do I have
six different choices because there are
six constructors okay let's assume I
choose if which is the fourth
constructor right then what do I have to
do next choose three more expression
right and if I had chosen the fifth
constructor as then I would have how to
choose two more expressions so I have to
choose a constructor first which
essentially just falls down to choosing
a number
all right I know how many constructors
are are and it's simply just choosing a
number in the right range like I mean
we're usually starting to come from zero
so let's say from zero to five here
right and then depending on what number
I choose I have to choose values of a
number of additional data types and
which ones depends on on the choice I
made
okay and that's really more or less the
same for all high school data that I'm
even sort of simpler cases but if I have
this data type list hair okay that's
just one constructor still I mean if I
want to construct a value of this data
type I have to first choose a
constructor in this case that's simple I
choose the one constructor that's there
so it's choosing a number between zero
and zero and then depending on that
choice I have to still choose a list of
integers and a list of boolean's right
okay if I consider this maybe data
started out just like I I wanted to have
it in the code not commented out so
that's why I've appended Prime's
everywhere it's just the same as the
normal Navy data type and that's
parametrize but that doesn't change
anything right I mean again I mean I
have a choice between two constructors
here zero or one and then if I choose
the first I have to do nothing further
if I choose the second I have to pick
one more field so in general I can say
that whenever I have a data table
constructed value and a school it has
the form there's roughly a constructor
with a number attached to it which is in
the right range of numbers and then it's
followed by a in general heterogeneous
list because the different fields are
the data that can have different types
of the arguments of that constructor
right so it's a number and a list and
that's essentially the representation
that we are going to use in in generics
SOP so if I do from which is the
conversion from
from the original data type to a to a
generic representation on for example
let's say on a boolean literal true for
my expressions v then what I get can you
read this or is it too small apart from
the noise in the beginning you get this
SOP tag which is just a new type
constructor but you get successor of 0
which is an encoding of 1 right because
boolean literal is the the first like 0
1 like there has the number of one of
the constructors
alright and then again the is just noise
it stands for identity but you get a
heterogeneous list where the cons
operator is does : star and the nil is
to nil and that has one element in it
which is the true right ok so let us see
the the generic representation gives me
something like a thing that looks like a
number and it gives me something that
looks like a list but it's a it's a
heterogeneous list so let's let's do a
different example if I do from of
nothing right maybe had two constructors
nothing and just nothing is the first
constructor so it gets the number 0 and
the first constructor has no argument so
there is an empty list attached to it
whereas if I do just of X I get a
constructor with a number 1 again I get
a one element list with X again so now
let's as a final example yes right so
the problem must be a to a and then yeah
so it so the question is why isn't that
ambiguous if I don't know what the
element type is and that question is
related to what I wanted to show you
right now so I'll hopefully answer your
question together with the example that
I'm just going to give that's the
happens if you choose for example the
addition constructor for expressions
which is recursive right I mean there
are expressions back in there and if I
say from of add of side and numeric
literal 3 and variable foo I guess
5 which hopefully is right or is it 5 or
is it no it's for for it yeah but that's
right and then I get a two element list
but if you see that the the list
contains actual expressions right so
this encoding isn't recursive you only
really reveal the top layer structure
and if there is a new type in in there
it's always the original type and why is
that related to your question well
because that means that you can give a
generic definition for maybe of a
completely independent of all a is you
don't need to require that you also have
a as part of the generic class at that
point it really works because it's only
one layer it's never recursive ok yes
um that's uh that's a good question so
let's see so actually this is this is
basically the next thing that I want to
talk about if you so if you actually
want to get these generic instances for
today the fives then you have two
options within the generics SOP library
one has to use template haskell and then
you just right arriv generic and you get
the generic instance for free the other
is to piggyback on the built in derive
generic mechanism that is already n ghz
but for a different representation and
then use type level computation to
translate the generation that GFC
generates into the generation that into
the representation that we need here i'm
for because this one looks a bit more
simple even though i'm not a huge fan of
template haskell in general but for for
this talk i'm going to use the template
haskell deriving mechanisms okay so the
representation works as follows and this
is coming back to the from nothing type
signature the first determine a code of
a datatype and the code is is another
type and if you haven't seen that before
in in haskell these days you can
basically have arbitrary data structures
on the type level and and so code is a
type level function that takes a data
type like expression and gives you a
type level list of lists of types so if
you ask for the kind of code it is of
kind star to lists of lists of star so
it turns the data type into a table into
a two-dimensional table of times and the
two-dimensional table of types just
reflects the the components of the data
type
the outer list has as many elements as
there are constructors right and the
inner lists contain to feel both of the
constructors right so that sustain the
this is just eat the expression datatype
roped of all its names right I mean
there are no longer the names of the
Constructors and if you had any record
selector field labels they would also be
removed so it's only the bare minimum
structuralist
not a part of that this is still the
same okay and then it's going to
interpret the outer list of this code as
a what's called an NRI sum and the
Constructors of this enery some data so
I've just looked like piano Naturals so
in order to make a choice between M
elements you have to select one and you
do that exactly by saying I'm going to
take the first which is the zero
constructor or I'm going not to take the
first which is the success or
constructor and then you still have to
make a choice between the remaining ones
so that's what the sound structure is
and then the inner lists are going to be
interpreted as heterogeneous lists
essentially which are called enery
products in this scenario and then you
have a structure which is essentially
isomorphic to the original one and you
can convert back and forth with from n2
and SOP there stands for sum of products
and then it turns out that every every
one of these structures sums of products
enery products and enery sums there are
always because it turns out to be very
useful and places are always
parameterised by another type
constructor typically a functor that
wraps every element in there and in this
case very like we're getting back here
representation where the inner elements
are just like applications of the
identity area we're going to see more
I'm going to say to show you a couple of
examples first and I'm going to look
the like because I mean I want to like
show you there's not all that much time
in an hour I want to show you some
examples and and then like we'll spend
the remaining time looking a little bit
more at how it all works
so let's actually start by writing
something like a generic mono AIDS
definition for product types and let's
actually start by writing an empty thing
first and I'm going to give the
definition and then I'm going to walk
you through it
so GMT will have the following type it
will take it'll produce an A right
because um the neutral element is just
something but what are the constraints
well a has to be in the generic class
and we'll have further constraints that
is in order to construct a value of a
data table you have to make one further
constraint namely that there is at least
one constructor right and in fact we are
going to be even more restrictive here
because we are only we only want to
consider record types there is no real
sensible generic definition for for some
mono a definition for data that I was a
multiple constructor so we are going to
say we want to require that that the in
order to use this mmt function that the
data type has only one constructor now
we've seen that this code gives us a
table write a two-dimensional table and
when does a data type have exactly one
constructor well that is if the outer
list of the two-dimensional table has
exactly one element so we're going to
say the code of a should be a single
element list which contains some other
types XS okay and now we have to make
one more constraint because now
we produce um a neutral element for an
arbitrary record type new because all
the types that are in that constructor
they have to have have to be an instance
of mono atoms Falls right so for all
these types excess which is a list of
types we have to require that there are
an instance of mono
now how do we write that down we
typically like we know how to write
Mahmoud of a particular type but now we
want to essentially require the monoid
class for a whole list of types and
that's a construct that's also provided
by by the generics SOP library and it's
called all so you say all mono it of
excess and that just says for all the
types in that list we have to have an
instance of the Malloys class right this
is this is the type signature of GMT and
now we just have to write it and how do
we writer we are going to write a top
down so so we're going to start here and
now at this point we have a whole this
is unreadable but it's not so it's not
so bad I mean this is the this is a
thing of time aid right and basically
since we are in the generic class and
you want to produce something of the
generic representation the last thing
we're going to apply is to write because
well now we we no longer have to produce
something of type a we have to produce
something of type sum of product of a of
of the code of a and the code of a we
know is they as a single constructor
reflects a single constructor a later
time so in order to produce something of
this SOP representation we always need
to that's one of the more unfortunate
things of the library you always have to
insert this additional neuter
constructor SOP and then we have to make
a choice for a constructor right how but
now we have required that there is only
one constructor so there is only one
constructor we can choose and that is
zero
all right and now what do we have left
now now we have to produce I can make
that larger no no that is the wrong now
we have to produce an NP of I of excess
that's the type of that Howell so we
have to produce an NRI product of all
the types in there but what is the what
what do we know we know that every type
in there is an instance of the mono
eight class so what would we'd like to
do is to just apply mmt recursively for
all these types and that is a bit of you
if you look it's a bit like replicate on
lists or repeat on list and who of you
have seen the zip lists applicative
instance before right so if you if you
consider the zipless the applicative
instance for lists just treats lists
sort of vector operations right so
whenever you have pure you produce an
infinite list actually of things you
just repeat and whenever you use star
you basically point wise if two lists
together with function application and
and we're doing we're going to use
similar operations on heterogeneous
lists and so that's why why the
operation that we are going to use here
is called HC pure because it's slightly
similar to the pure operation of
opposite lists and we want to just use
HCP u're with MMD and the rest is noise
so so we would like to ideally oh sorry
okay so ideally we just like to write h
CP or mmm T that would be that would be
perfect if you could do that but
unfortunately we now have to help
various things I mean one thing is that
we have to wrap the MMT in an ie because
ultimately everything is is parametrized
by a functor and the representation we
have to produce every element as you can
see also for the GHC generated ones has
to be prefixed with an identity
application so that's one thing and the
other thing is that HC pure the c is for
constrains and that's the function that
allows us to to apply a function that is
itself in a tight gloss like mm T which
has the mode constrained but
unfortunately gh sees type checker or
type inference or is not clever enough
to figure out which constrains we
actually mean so even though the type
signature here is has all Molloy and
even though MMC is in the mono it flaws
do you see is still not clever enough to
line these two up so we have to use a
proxy argument which has no other
purpose except to tell JC that we want
to operate on the Malloys class and
that's the only that's the only point
and that's it
that's why checks okay
so let's let's see well let's see if we
if we can call GMM T or what was it a
list pair and that gives us an LP of
empty lists an empty list well it lists
there was a hat one constructor and I
had a list of integers and a list of
boolean's on that it gives us an empty
list and an empty list and let's let's
perhaps queue and say what is HC pure of
proxy proxy monoid of I mm T and if we
actually give the result up and say we
want an NRI product of identity things
of a
what was it here is a list of in and a
list of rules so that's essentially what
we're doing right and that gives us two
empty lists all right that's that's the
thing that happens in there and if you
had a data type that additionally was
also looking for I don't know a let's
see a first of Ind
or something like that then we would get
the internet neutral element of the
first mode is it's nothing so then we
would get that generated as well alright
so this HC pure is really it's taking
the result type and Jen basically driven
by the result type we want it's it's
inserting as many calls as we need to
that so that overloaded function and
interpreting them in the right way and
then we're just injecting it into the
first constructor and wrapping it and
yes OPN transforming back all right and
this is a very representative example of
what what programming in generics SOP
looks like because that's the that's the
nice thing let's say as opposed to
working with a built-in representation
that GHC has that by giving ourselves a
relatively rich structure of these
entries homes and NRA products the
library can supply you with quite a
number of really powerful higher-order
functions like HC pure and map like
functions and zip like functions that
you can really plug together nicely and
and write these things really as as
pipelines or function compositions of
simpler functions whereas if you have
ever seen a generic function definition
in the binary some is a product style as
given by the GHC itself you usually just
manually write down write out lots of
different a class instances so basically
do a big case statement on the type
level Android all these cases
individually and actually there's not
all that much abstraction and
programming when and reuse between
different generic functions so so that
that's one of the main arguments here
but obviously that also makes it harder
in a way to learn because these these
combinators have complicated types and
they all work on the type level and and
while the definitions are very short in
the end you first have to get familiar
with always so unless there are
questions now let let's perhaps do a
second example which is the independent
second one should hopefully get a bit
simpler the type is is very simple
similar so we have exactly the same
constraints and the type of course the M
type is a to a to a and now we have like
a whole wrapper where we say well in the
end we have an a again so we have to
apply to in the end and we have to apply
soap in the end again oh well actually
this lets perhaps not even go to that
level let's say we have to apply to in
the end and then we work on the
representation and and then we want to
do something with the from of X and the
form of Y where x and y are the two
arguments so this is the the mapping
between the the original types and the
anti representation right and now we
just have to take two somewhat sums of
products and and merge them into one and
that is essentially a form of of of
zipping right but we we have to rely on
the fact that we have a single
constructor again everywhere so what we
are going to do again is like the end
result is going to be of our single
constructor and here we are going
unpack the two things where there are
reverse function so we're going to do
unset of unsought of from X and on this
or on top or from Y right and then we
have just just did I put the right
number of parent users probably not no
not nearly enough that's it yeah okay
but now it's not no I should have put
more here yeah so there's one missing
here
it's Lisp okay this is good so uh and
then now we have to glue together two
enery products into one and i already
said it's a bit like is it with and
indeed there is a function that is
called HZ zip with which is which is
much like HC pure and it's a constraint
variant of the heterogeneous lists it
with where we again have to say we want
to do a proxy proxy Molloy's and then
the only thing that we need to say is
how to combine the two things and that's
essentially Emma penance right only that
everything is again wrapped in these
icon structures the two arguments are
wrapped in an I constructor and the
result has to be wrapped in an ally
constructor so we actually have to say
lambda I a I be - I of an append a be
okay
and up type checks oh I'm surprised
myself
Farren so if we do what was the type of
LP again LP was a list of int and a list
of pool so if we take LP of one two
three and all false
and if we GM append that to an LP which
just contains the four and contains true
true then we indeed get the one that we
expect okay all right questions okay so
if we wanted to make a mole annoyed
instance for list there we now can using
GM m TM g MF n we can do that relatively
straightforwardly because mono is
already defined in the library somewhere
we unfortunately cannot make it any
simpler than that
but if we are giving generic instances
for our own classes we can use a ght
language feature as called default
signatures to actually explain that if
there is a generic instance and if these
extra constraints are fulfilled and this
is a way to derive a generic definition
and then you can essentially use either
empty instance declarations or even with
derive any Clause but that still a
slightly fragile feature use a deriving
statement for these for these kinds of
classes and and that's it okay all right
I want to show you one more example and
then I'm going to talk a little bit more
only a little bit about the technical
details I have to defer most of the
technical details to to either offline
discussions or or appointing you to
papers okay so so here is a here's
another example which is building on the
maloik thing that they've seen so this
is another it's a small thing with it's
one that I've actually used generic
programming for a couple of times so
assume you have a simple enumeration
type in your program and black off a
better example I just took and then a
list of room numbers or where you might
want to schedule talks in and so you
have you have these four rooms and and
there there is a room
and this is typical instance of bounded
and also enum right and bound it is a
class that gives you I'm focusing on
bounded now it gives you a min bond and
a max bound min balance if you derive
that will give you our 101 and Max bound
will give you our 300 and and in
particular if you also derive in um and
you can nicely memorize all these values
but now I don't know somebody decides
that 101 is really much larger than all
the others so they're going to split
that room into two rooms and you're
building and you suddenly have a room
101 a and B and obviously what you can
do is just do this alright but there is
also something to be said for saying
like room 101 part and let the room 101
part be a or b because that keeps the
relation between the the actual physical
room within and the semantics only if
you do that suddenly GAC will start
complaining and why will it complain
it'll it'll say because our 101 part is
not an in scope oh that's because it's
separated by a template haskó of
declaration and that's why I don't like
I'll read that to you I can't make a
derive instance of bounded room any room
must be an enumeration type and
enumeration consists of one or more null
arene on G ADG constructors or room must
have precisely one constructor so none
of these conditions are fulfilled but
it's it's rather sad right I mean
clearly it it's both still bounded and
innumerable and and just Jaycees
deriving mechanism is too lazy to work
it out so perhaps we can we can fix it
and bye-bye
our own generic definition of mini
bounds and max bound instead that allows
us to use to use this scenario and so so
I'll remove the deriving bounded and I'm
going to ride team inbound and again
this is going to be generic of a and
ultimately we're going to produce an A
and it's very similar to the empty case
life we want to there to be at least one
constructor but in this case we really
want there to be at least one
constructor right and not exactly one
constructor so how are we going to say
that there should be at least one
constructor well we say the code of a
should be a a non-empty type level list
so it should be of the form X cons
excess or let's say because this is
still a list that let's let's say so XS
cons accesses and then we want at least
now we can be like I mean they're
different degrees to which we can we
want at least all the the elements on
the in the first list to be bounded all
bounded XS right we could also say all
elements everywhere should be bounded
that's that's possible as well and there
is a function that's called or a type
level function it's called all two and
then we can pass as a list of lists so
actually I'm going I'm going to go for
this one because it's it's slightly
easier to implement the max bound with
with this kind of requirement so let's
see again we're going to do two and soap
and HC pure and is basically the cyprox
ee of foxy of bounded and I am in bound
and that's it
Hank what's this about Oh completely
unrelated okay so um that's giving us
some imbalance oh let's see
demon bound of of type room ah okay so
that's cute I mean it's actually saying
oh there is no instance of founder
Darwin or not run for it
but our 101 part is easy to still make
an instance of bounded we don't have to
resort to GE min bound for that one
because that's still a simple
enumeration type so so now we get our
101 of a which is exactly the one that
we want now a different way of doing
this of of deriving the demon bone and
as I say this is like this makes it
slightly larger slightly easier to
derive the max and as well and it also
shows how you can do other generic
functions that generates like more
arbitrary values is to UM to use a
function that is called app injections
PRP so let's just focus on the last line
of the type it's it's taking something
that's called a product of products and
what's not that's actually a
two-dimensional table right that has as
many entries as there are constructors
and the data type and for each
constructor as many entries as there are
fields so that's a product of products
where both the inner list and the outer
lists are interpreted as heterogeneous
lists and and then it's going to apply
the first constructor of the data type
to the first row of the two-dimensional
table and the second constructor
off the data tab to the second row of
the table I'm a third constructor to the
third row and so on and the last
constructor to the last row and then
it's giving us a normal list back that
contains basically yielding from this
two-dimensional table elements of their
data so even in representation form one
of each one of each constructor and and
then we can then if we are so interested
in the first constructor we can just
take the first element out of that list
and we are interested in the last
constructor we can take the last
constructor out of that list so wrong so
let's actually rewrite teaming bound
using using this one that would look
like would look like this we are going
to do up injections P o P and we're
still going to use HCP fewer of coxy
bounded of Eamonn bond and and then we
are going to take the first element of
that list and then we're going to apply
to to the first element of that list
that's verify that that still works and
it gives us the same result so what are
we doing here compared to the upper
version we are calling HC pure at a
different type where rather than
generating just a single row just a
single lists we're actually generating
the entire two dimensional table right
there generating a product of products
using HC pure where there's been bound
everywhere but then ultimately we're
using this app injections top-2 general
get a list of constructors where min
bound is applied recursively everywhere
and then we are taking only the first
element that gives us the mini ball
we're interested in and correspondingly
max bound is very simple to write
in comparison because the only thing we
have to change is we have to take the
last element out of that list and we
have to call max Belmont recursively but
apart from that everything else is the
same
and then that's giving us our 300 which
is a large term plastron okay all right
so I'm hearing to to skip the part where
I'm going to show how to how to derive a
simple show function and how to get back
at information in such as constructor
names I just want to say that you can
and actually you can do so in a rather a
nice way that's another advantage of
this particular approach to generic
programming compared to others that the
the metadata of a data type like the
names of the constructor or the name of
the data type itself and the names of
the record selectors and so on is
available for you but it's a valid
available for you completely independent
of the original data type which is nice
because we don't have to worry about it
at all if we are not caring about it for
all the functions we've written so far
we didn't need to do any extra
complexity because of this metadata
whereas for example and the built-in
representation in GHC the metadata is
sprinkled all over the case I can
perhaps show that once just to show you
what I'm talking about if I'm saying
like for example if I if if I import a
seed generics
and if I say arrived generic and if I
say deriving GHC generic of the
expression 5 this is driving instance or
and then I need to enable standalone
deriding
sorry and if I ask for the
representation of this the GHC
representation not not the one that we
are using here of the expression this is
how it looks and you know you if you if
you squint a bit it's all basically it's
all metadata I mean that's why it looks
so horrible there there is all this
stuff about oh the constructor is
actually called deal it's and it's
actually a prefix constructor and oh
there is actually no record selector
here and this sort of stuff so this is
for what fields at all up right so it's
really nice to be able to separate all
that noise out and have it elsewhere but
at the same time it's still very tight
safe and generics SOP because the
metadata that you have is also indexed
over the code so you know that the
metadata is compatible and for example
that you have as many constructor names
available as you actually have in
entries and the outer list of your date
of perhaps code so so even though there
are they are separate they are they are
matching up and the type system comes
you can guarantee that your that you can
match them up properly ok so that's
let me let me close by by just showing
you how these how these types really
look and and and and give you a little
glimpse of how how the function is for
them we'll look at least like perhaps we
can we can define a map function over
over NRI products to us as one example
and there are many of these these
higher-order functions in the library so
the Emery product is essentially a list
right it has a dealer constructor and it
has a cons constructor and the newel
constructor does take no arguments it
just produces an NRI product and the
cons constructor takes two arguments one
which is the first element and one which
is again an NRI product which is the
tail so now about the in MVC so as I
said an enemy product is is parametrized
over two things
the second thing excess is what I
typically call the signature and that's
a type level list of things and I don't
care what these things are so this is
the kind polymorphic it's a list of
Kay's and and the functor that are
passed in here takes a K takes a thing
of table K and interprets it as a as a
type so in particular if that functor is
I then you get just a plain
heterogeneous list but another
interesting common case is if that
functor is K a constant functor then you
get essentially a homogeneous list but
the number of elements in that list are
still statically determined to be
compatible with with either the number
of constructors or the number of fields
so that is isomorphic to to sort of G
ADT vector like structure and so as we
often see all right so that's both
captured by this but as NP
another common case that is useful in
practice is if you instantiate F with an
applicative functor or a monarch and you
basically do an i/o action for every
element and your data type and you get
an NPI O of your things and then you can
apply a kind of sequence operator only
lifted to these heterogeneous tuples
where you say I want to execute all
these i/o operations and sequence and
get the uneri product of the results
back right so so that's that's another
common case so that's that's the NRI
product and how does the enery some look
well I've already said it's essentially
an index into into a choice between n
and different elements so again this is
indexed by by the same things as indexed
by a list of of k's and an
interpretation that takes the case two
stars and and the first thing to notice
is that there is no way to index into an
empty list I mean if you have a null
array
sum then there simply isn't an
inhabitant of the NS type except for
undefined right I mean if you have if
you have 0 elements to choose from
there is no choice you can make but if
you have at least one element to choose
from then you can pick the first element
which is what the 0 constructor does so
if you inject an f of X so basically it
gives you an access or like I mean
taking the pattern-matching perspective
if you pass on metal is that it gives
you access to the f of X which is the
first element in the aneurism if if the
list starts with an X right or um we
don't we decide to disregard the first
element and then we still have to choose
from the remaining elements and that
also requires there to be at least one
element and obviously if we have only
one element a single element and the
successor constructor is is
inhabited because we then have to
produce again a choice between zero
elements right so it's really the case
that for a one element list we have just
one choice and for a two-element list we
have just two choices it's perhaps
enlightening to look at the type of zero
which really say I can inject an a of X
into an NRI sums of a of ex-cons XS and
if I have success or after X I can
inject an a of X into the second
position of an NRI some that contains at
least two elements and if I do success
or after a successor of that I can
inject an a of X in the third position
of an NRI some contains at least three
elements and so on and so forth
can i still talk for five minutes is
that okay yeah okay okay so um here are
three examples of NRI products just to
get like slightly more familiar with
these I mean the first one is an NRI
product of identity things indexed by an
inch arbol so it contains an envelope by
a character followed by a pool the
second is an NRI product of constants
again indexed by the same list but it
contains an integer for each position so
but it has to contain exactly three
elements and the third one is and is
parametrized by maybe so it contains a
maybe in followed by a maybe character
followed by a maybe pool okay so these
are interesting things so let's not do
the h collapse but let's do the h map as
in order to show one function that one
can usefully define on such enery
products and also similar or such data
structures so if you want to if you want
to define H map the first big question
is like if we want to do a map over a
heterogeneous lists the it's already
unclear what the type even should be
right I mean what what kind of function
do we want to map over
and how should it look like and
obviously it has to be a relatively
polymorphic function because we don't
know what types we'll encounter right I
mean in just in the example there is an
integer and the character and the bool
so we have to have a function that is
able to somehow deal with them all and
it turns out that this is one of the
reasons why we parameterize over the
functor in the first place that it's
it's useful not to worry about changing
the signature at all but rather about
changing the factor so the H not
function over these products will take
an NP F of access to an NP G of X s and
we'll leave the access alone
so it never changes the signature it
never changes the length but it can
change the function so it can in
particular map an NP of eyes to another
envy of eyes which is a function that
may change every individual thing but it
doesn't change any of the types right it
can also map an NP of I to an NP of KS
which means it Maps all the different
types to the same target type it can in
theory also do the other way around they
go from from a common seed values to all
sorts of different types from k to i and
so on and so forth and in the simple
setting what what we need in order to do
that is we need a function that for all
element types X goes from FX - GX so
that death is rather is a rather strong
requirement but it's certainly enough so
if we have something that independent of
the element type always takes an FX - a
GX then we can implement it and that's
not the most useful version of the
function but that is at least really
simple to define because the code
despite all the the scary types is
exactly how map should look
huh all right um so yeah okay it warns
me that the F is on use so let's put an
anomalous coordinate right okay so the
coldest is just math I mean that's just
map on a list
it just has a has a much more fancy type
okay so so that that's an example and
and there are like somewhat useful
things we can do we can for example take
the example one list that's low to talk
to we can take the example one list and
H map just over it oh not quite because
the original list is wrapped in these
icon structures so we have to UM ie all
the things apply just to them so now
we've we just just after on I is indeed
the function that it has a sufficiently
polymorphic type but for all a takes an
eye of a to a maybe of a right and and
and that works right we can do it but
the more the more interesting case is is
HC map which which takes a constrained
function where we have a thing to map
over that is has a clasp on strain and
then we can do something like oh we
required that the original NR a product
that every element is in the show class
we can call the show methods on
everything and then we get a string for
and then we can turn on and view of
aizen's an NP of k strings by by
applying show to to every element and
the emory product and that deficit is a
typical useful application of this
function and so it also takes an NP F to
an NP g XS but here we need to do more
things because first of all as I told
you before GAC isn't clever enough to
figure out what the C is by taught in
so we have to use a proxy in order to
tell that to JC explicitly that's what
we have seen them the example calls and
also we need that all the XS are
instances of the C class so we need this
kind of all C access constraint okay I'm
almost there
all despite despite appearance is
actually rather simple to define all
it's just a type family that takes a k2
constraint and an axis which is a list
of case to a constraint where all of C
of the empty list so if you have no
elements on your list there is nothing
to require and that is a way to write
the empty constraint and Haskell and
we're in GHC I should say none of this
is haskell this is all JC and then if
you if you have a non-empty list then we
want at C of X holds and that all C of X
s holes so it's not it's not actually
that horrible and then actually the code
is almost the same again so I can even
start copying and I just have to like
take the proxy argument and pass that on
here but but the rest is still it still
looks like a map should look right okay
and and then I mean like you have zip
widths and Pure's and you have a number
of other functions for enery songs but
but this this is essentially these are
the techniques that play a role in there
you have these rank n types where you
you take polymorphic functions you have
type families but they are mostly just
use for these constrained combinators
you need unfortunately that's not that's
not really a good thing you need
unfortunately these proxies for the
constraints because the tough inference
isn't good enough what else I think that
that's that's essentially it I mean
those are those are the main ingredients
right and but yeah but that's that's the
library and and you can you can write
like arbitrary generic functions with it
and if you want to know more talk to me
offline there is also some summer school
lecture notes that I used at a summer
school in Oxford that are much more
detailed that's had like something like
25 or 30 pages of material which just us
all in a in a bit more detail and then
let me conclude with an advertisement
and thank
performance was bombs would like a
receipt like if I imagine you do the
same thing with template a school can't
generate things that are optimizing
events so yeah so the question is what
about performance and it's a it's a very
valid question to which I have no arms
or essentially and the sense that I I
don't I haven't even tested how horrible
it is I have used this library in
practice and situations or simply
performance isn't critical and and it's
quite convenient to use and there has
been significant performance testing for
generic programming these days but not
for this library so so the general thing
is that in some situations the GHC
inliner is actually rather clever and
can optimize quite many things away but
i think we have to be fair to say that
in general these are still relatively
fragile and if you really really really
want to squeeze the best performance out
of it then using template haskell at
some stage of the process seems
unavoidable but there are interesting
hybrid approaches like I mean for
structure boilerplate there are our T's
there is generally plate and another
related approach which is called
template your boilerplate which
basically gives you as you I be like
Combinator is in order to more
conveniently construct template Haskell
programs and in principle something
similar might be possible for such a for
such an approach as well
and then and the different technique
would be just to give you as a
programmer more and also more reliable
control perhaps over the GAC inliner
because there are certain recursive
functions that are involved and play
here that I would really like evaluated
statically and I'm willing to basically
as the library write her to take the
responsibility for the fact that they
should always terminate because they are
only invoked on sort of for example on a
conversion of one data type into another
and the data type their representation
of a data type itself is always finite
because there can be only finitely many
constructors and so on so if you could
if you could have a feature where you
could annotate certain functions as
being evaluated statically then one
might get sort of more reliable
performance out of these kinds of things
as well but but right now on I think you
have to be careful like I mean there is
a certain overhead involved it depends
on what you're using these things for in
the end I mean very many applications of
these sorts of things are not
performance critical at all but if they
are yeah I mean they're certainly an
overhead involved and you have to be
aware of that the main reason by the way
why we still and you see despite having
like generic programming mechanisms in
GHz for a while while the well deriving
EQ and Orton bounded and enum are still
implemented in an ad hoc fashion in
addition to the generic mechanism
because we cannot guarantee that the
generic versions are are always going to
be equal so the question if I understand
correctly is is whether there are
generic programming approaches that can
represent G ADT exactly so this is
something that I have glossed over in
this talk
which data types are represented I mean
I just saw you write the template has
two invocation derive generic on your
data type and then it always works but
in fact never it doesn't so there are
certain constraints and one major
constraint is that the right generic
does not work for 4G ADT's and that's
the same for the built in generic
mechanism so yes indeed type and type
changes the game a bit and also other
things changes I mean from already a
long time ago the the question is
actually not that much like how to
represent GA DTS at all because that is
doable how to make the resulting library
a library that is not too horrible to
use so you can see already here like I
mean I guess if you ask different people
in the room I would guess you get the
full range from this is really cool - oh
this is horrible I would never touch it
and like I mean they're like even for me
there is a point that can be reached
where I think I don't want to impose
that on users ever and and where you
have to basically like add proxy
arguments where the type annotations are
longer than the entire generic function
that you so but I did this is something
yeah I mean there are some papers on how
to represent dat T's in a few cases so
shows that Pedro Meghalaya has written a
paper on this a while ago but I I'm also
currently investigating new approaches
for encoding data types made possible by
type and type that will enable you to
represent a much larger class of data
type so there is hopefully more to come
in the future in that direction
but it's not there yet okay</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>