<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Nereus: Massively Parallel Computation in Java | Coder Coacher - Coaching Coders</title><meta content="Nereus: Massively Parallel Computation in Java - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Nereus: Massively Parallel Computation in Java</b></h2><h5 class="post__date">2008-05-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RwoFsJjIhos" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon and thank you for having
me here's my name is Rhys Newman and
this is chris dennis we've just come in
from oxford and the lights talk to you
about the reyes a global infrastructure
for massively parallel computing
something we've been working on for a
while and there are two parts to this
technology the Reyes is the main subject
of the talk today and we'll also talk a
bit about that JP c which is an emulator
that fits into this technology in the
way that the science will explain Chris
next time this is a simple equation I
want to propose we have loads and loads
of idle machines over in the left hand
side there then we put jpc in together
so at a cross-platform standardized PC
emulator add some distributed management
software and hey presto we get a global
infrastructure for computation in the
next one of course these machines have
been around for a long time and there
have been around there are a billion pcs
in the world what's the problem with
using them currently we've known there
been idle for a while and the problems
really are twofold I believe as
distribution of the data how to get the
data there the processing the end is
software software there to process and
then there's the security issues coming
back so you've got to make sure that
when you send your data to a remote
server or remote client that that data
is not left there and you're not worried
about privacy and but equally and
probably more importantly there's the
issue of the owners of those machines
being persuaded that your software is
safe to run and clearly with the many
malware Trojans and other things in the
in the world right now that's a very
difficult argument to make to people
unless they know you personally okay the
next line so there's a sort of an
approach you could take to my try and
make software secure for the purposes of
running on third-party resources you
could use some sort of sandbox or
virtualization to try and put to put the
software in a virtual machine and
therefore contain it and make the user
feel happier about the fact that it's
contained our virtual ization technology
is on the whole too close to the
hardware
suffers from various issues like support
issues various combinations of hardware
support and and software problems plus
in the case of certain hypervisors they
need to be quite close to the bare metal
and updates being impossibly difficult
to apply especially if you're not a
system administrator equally which one
of those solutions would you use if I
said to you that you're going to expose
your machine to anyone in the world
you're going to advertise the fact that
you were offering your machine for
execution to anyone in the world and you
essentially knew that the world's
hackers we're going to try and hack your
machine which container of those three
or indeed others would you trust well I
contend you probably wouldn't trust any
of them by themselves so one solution is
to use an emulator to try and get away
from the hardware of it so that you have
simple upgrade path you just just use a
process you don't need to worry about
administrative rights and so on and you
move away from that and you become a
little bit more secure because it's
emulation not closely into the hardware
so here the layers and I'm proposing a
two-layer step firstly emulators a
product so even the emulators don't have
bugs in them so you can't rely on them
alone either so why don't we start with
the most widely available and trusted
virtual machine the Java Virtual Machine
which was built to run dead body code
and that's what applets essentially are
and then we built an emulator for x86
execution in pure Java so not getting
around and outside the applet sandbox or
the Java sandbox provided by the JVM we
stay within it and if you put those two
together we have a possibility of
running unvetted software inside this
simulated hardware with two independent
layers of security between the
potentially hostile guest software and
your real data in real machine so this
is what jpc does is in its an emulator
so Chris you click the next one is the
stack we build it up we have the
hardware and the nut normal applications
but then we put the Java Virtual Machine
in and we have virtual hardware another
operating system and applications inside
there and the application is running
inside there are emulated they don't
know about the the fact they are an
emulated system and the amulet system is
isolated completely
software inside the emulator so if we
click the next bit we can change the
bottom stack there very easily go to a
different operating system the Java
Virtual Machine allows us to avoid
worrying about the platform specifics
and even different hardware we can then
absorb the idle time of set-top boxes
potentially all the while maintaining
the illusion for the guest software that
it's running on an x86 pc so from the
point of view of using all this
resources you don't have to keep calm
Bri compiling code for different targets
you just run to your favorite x86 and
run up like that and one final perhaps
frivolous use is the possibility of
running on a mobile phone and I can show
you Jake see running on that if anyone's
interested later on so now we're going
to do a demo of jpc it's going to flip
the slides away and then we're going to
boot up JP CSS is running inside a java
virtual machine here we go so this is
booting dos and this is unmodified
original dos so we haven't changed it
all we downloaded it from the free dos
rage and and this thinks has got an a
drive and it thinks it's got to see
drive and it's got some games there
because it's going to try run one of
them leming is okay so let's go and see
what lemmings has for us now the the bar
at the bottom of the screen there the
one that's going with backwards and
forwards is an estimate of the virtual
clock speed that jpc is achieving and
you can see that's actually quite slow
at the moment but you'll notice it drops
up and down quite a bit and what's
happening there is that we are doing
dynamic compilation in the background so
we decode the x86 instructions we then
work out what bytecodes need to actually
be run we turn them into a class load
them back into hotspot and let hotspot
going compilat so you can see when
you've been running for a little bit it
really ramps up and gets up to the sort
of the ten percent twenty percent type
of real-time speed so we say Jake you
see Peaks about twenty percent at the
moment and we have a very good idea how
we could double that speed but in cincy
play games
you can go to the JPC website and you
can play this online because it sits in
an applet so it's fine to run okay Chris
can we go back to the slides ok so the
hackers challenge now is as follows find
a bug in the JVM which enables the
security breach first first thing to do
hopefully very difficult then you find a
bug in jpc but that has to come inside
with the bug on the JVM you found in
step 1 and then finally work out what
code would need to be run in an x86
machine such that it hits the bug in JP
see that you found which also then
coincides with a bug in the JVM that you
found in order to get out of the
container and exploit some sort of
security hole you got working against
the huge patch site all for the JVM
vendors of course who for whom security
is a real a big issue and they are
constantly trying to address these
issues and the fact jpc is open source
means you can go and look at jpc or
build a clean version if you suspect
that's been tampered with so basically I
say well that's that's an impossible
challenge I think I would be happy
letting anyone load code into an
environment protected by these two
independent layers of security so now
we've got a solution for the security
issue now let's look at distribution
this is where no rice comes in so we
want to get the most out of the global
billion pcs and we can't use simple
client-server that's just no way there's
a server big enough in the world for
that so look at examples of other
systems that have scaled to that level
and come up with the idea that basically
we need a forest of trees click there we
are that's what we're going to do and
that's what the Reyes is so if we go to
the next slide it's an open source
massively parallel computations
infrastructure in Java it's also the
Greek god of the sea or a Greek god of
the sea and it's provides two things it
provides an applet sandbox so this is
not some an applet in the in the usual
sense of Java applet it's such an array
of service it's inside our security
sandbox that is provided by the Reyes
client coincidentally that is very
similar to the Java applets and walk
and we get java are only execution
within a standardized environment a
sandbox environment we get it either as
a standalone client which is the lower
image on the screen there or we get it
in an ordinary browser in the Java
plug-in actually embedded in an ordinary
applet and that's the upper big picture
and if you look carefully you'll see
there are differences in the UI but not
very many and the environment that the
programmer sees or the prime of the Naas
application developer currencies
secondly the same in both cases same
security restrictions same API available
importantly the newest client provides
the ability to create sandboxes within
sandboxes so once you've created one you
can then tell it to create a sandbox
underneath it and underneath that
underneath that and each of these
sandbox of boxes remains at the mercy of
its parent and so all authority delegate
sup words in a chain so you can sort of
delegate authority down and then the
software like sitting in the sandbox as
lower down has to abide by the rules
enforced by the parents and boxes so
there's a very nice way of sort of
delegating authority from the initial
download of a sandbox which is when the
owner of the machine the human being
actually says yes I'm going to give you
permission to use my cpu by pointing
their narae's client to that server and
then that authority delegates down to
subsequent downloads of software so
again the next slide system design Narae
espacially tries to turn the system into
a flat accessible network but we have a
few issues to deal with mostly related
to the fact that an applet stroke java
sandbox usual policy is to restrict the
network communications to the server
view came from so the neuritis server is
the server as far as the applet sandbox
is concerned that's the server you came
from and so the naraya server provides
various gateway functionalities to get
network communications in and out so we
have number of servers again these are
all trees in this forest they're not
they're not connected in any way they
just there we have laptop clients and
then enterprise clients there's applets
and the standalone program and then
hopefully lots of people put more
machines on so we also know we have web
serves as well they're just the ordinary
web servers out there in the world then
we have a load of other machines that
hopefully contribute to each no es
server a machine in the group up the top
left hand corner there knows about an
array of server number two but none of
those machines explicitly know about any
of the other machines anywhere else
there's nothing there's no rule that
says they have to understand that it's
just basically DNS lookup a URL and if
you happen to know that's like what
Google does for you if you want to find
something you go to google it knows
about it because it's been busily
indexing the system our design here it
expects that there'll be an indexing
system for the race as well the
communications go around through the
Neriah servers as i said the race server
acts like a proxy to get around the
security restrictions of sand boxes and
that goes two ways you can go in and out
of the racers to the clients sitting
underneath them and if we look at the
next overlay here we are there are some
clients software so the users server
which is in red can push software down
into the boxes into the sandbox is
created by the neurons clients either
applets or applications and and that
essentially allows them to have
installations of their software out in
the real world and then once they've got
them they can communicate with them in
logical terms via directly by the blue
arrows but in practice going through
each other promising systems if i get
rid of the plumbing it becomes a lot
more obvious and simpler basically it's
a flat network all these things can
communicate with anything they like
including the party web servers and
everyone's happy hopefully that works
really well so here's a demo as
animation grid so this is a website we
have this running currently over in
Oxford and the idea is here is we're
going to do some rendering for you so we
take an arbitrary image and before you
do that Chris this this is a scene
there's a selection of scenes here and
there's an image that Chris is uploaded
it was about to upload and that image
will be slotted into that scene in a
particular location so if you choose the
left-hand one there's a white wall on
the right hand side the image that Chris
uploads will be slaughtered in there and
then we'll do the rendering of that that
image of the advert scene so submit that
now Chris
now the reason why we do it this way is
we want to show you prove that we really
did do a lot of work so this is
high-quality ray-traced rendering each
frame at this scene would take
approximately 30 seconds on a single
machine running full pelt and we've got
approximately 50 machines sitting in
Oxford currently logged on doing work
for us so you see that as the system
gets going we get more greater and
greater chunks of frames coming in and
you know it's it's basically split the
frames up into individual jobs and
sprayed them out onto the grid and
they're all doing individual ones and
there cause different machines of
different speeds so that's why you get
sort of that's why i say frame to hasn't
come back yet because that's a slower
machine it hasn't come back and that
they'll just eventually come in and the
great thing about this is it's a sort of
read-only process you you do some
rendering you get the result you check
it back to the server and if for
whatever reason that client goes away or
doesn't finish in time the server can
resubmit that it's just a whole list of
independent jobs so a very nice and
simple greed application just to prove
the principle now this is slightly
different from your conventional grid or
multi-user system in that whereas if I
had a lot of clients I would go and
download some software and then I'll be
a rendering client that's not the way
this works at all we have a lot of
maria's clients who have connected to an
array of server and that's that's an
empty box what we then have is a system
that goes around installing these
animation software on each of these bits
of these empty empty naresse clients and
that's a completely separate process and
of course you can do animation you can
do lots of different things it's all
within control so i think we'll leave
that now go back to the presentation
we'll come back to that little have
finished all the bits another feature
that we get with JP see which other is
important for there as part of the way
the system I think should work is
hardware level checkpoints okay next one
yeah because we emulate everything in
the hardware and we can literally
stopped the CPU at a clock cycle if we
want
just freeze it and we can save the
entire state including the memory that
is state all the registers everything so
we could resume it later on we can just
stop and start but equally click the
next one we can resume on a completely
different machine just move the state
around we could also if we put the
storage of the state somewhere else some
third place we could then have thats
that state available just anywhere and
the machine that's currently executing
that virtual machine can just be
anywhere in the world crunch crunch
crunch crunch it becomes busy the user
needs to use their own machine they
decide to stop nor is working on that
machine then computations are stops the
storage is back at the original location
we just shift point a nooner ace client
at that machine at that storage and it
can computation continues from where it
left off so we get a very nice system
that is just a great way of getting lots
of throughput for lots of computation so
if we go to the next slide it's a
diagrammatically let me explain this is
basically what i'm going to say the
checkpoint store lots of images disk
images and state you then have a lot of
andreas servers and then a lot of noise
clients and then you've got these red
boxes which are the JPC instances
running the emulator inside the Maria's
clients and they have got well they've
got their hard this virtually pointed
back to the checkpoint store they're
right each one will be running a
particular hardware image at any one
time then you have a resource sweeper
that goes around the grid basically goes
around trying to find Reyes clients that
happen to come up you know when they
connect for the first time it then
sweeps around and says oh look there's
some more machines i'm going to put more
jvc clients on there so it just goes it
installs a software in more and more
places and it keeps going because
obviously is they'll be in a level of
which you want to achieve and as clients
drop off you want to create more and
those clients just then come alive and
say oh I need to do some processing I go
to a broker and then you know in detail
through the narrow server but in
logically they go to the broker broker
says checkpoint number four or PC number
four is currently not being worked on by
anyone
why don't you work on that and so it
connects that says offer young process
and there's a sort of sense in which you
incrementally checkpoint yourself as you
go along as if the process suddenly dies
you don't lose all the work you just go
back to the checkpoint you have
previously and you continue on so you
don't lose meses amount each time you a
client goes away so I think we're up to
the final demo sona reyes and jpc so
there's the combination of the two
together this is we're going to do this
locally for in the spirit of being quick
and not necessarily having to rely on
networks between here and Oxford but
Chris is now running a storage server so
that's where the disk image will reside
and then we've got to run an array
server there as well so there's an array
of servant doesn't do much interesting
but now we're going to go to the browser
and this becomes slightly more
interesting so we go to no rice no you
don't go to local host yes local itís
will be better so localize this is the
Neriah server running locally and he's
going to contribute in the system just
by clicking on the links so we're now
this is how easy it is to become a
member of the neurons grid you just
click on a link in a browser as long as
you got the java plugin it comes up with
a the applet version of the nice client
and we've downloaded this documents as
an ml document it describes things like
what class is needed to be loaded and
what the ID the name of the service is a
very simple document but net kristin is
now going to go back there's this the
total list of clients on this Neriah
server obviously only one at this point
but if anyone's here's gotta let with
network on me the firewall didn't
prevent us listening to connections you
could just go and join that but he's now
going to go to that container and tell
it to load a jpc NML structure so games
good let's do that one and if you go
back to the narase client on the other
side we've now got a local host sub
sandbox if you like and it's loaded a
jpc instance if you click there that's
the standard output standard error of
the JPC software running which is just
diagnostics and that's not intended to
be looked at really by anyone but
developer from the point of view of the
user who's running the JPC you want to
see the console output of jpc what's
what's the image and that served up by
the
the JPC instance itself so we now have
another applet now this applet is not
doing jpc that's not running the
emulation that's just looking at the
graphics card and taking the key presses
and send to get round the whole loop
round the narrator server and back again
and bringing this graphics updates back
to here so we can essentially do the
same thing as we did before but you see
it's slightly more jerky because what's
happening is we're going via proxy
server even though it's loopback it's
taking a little time and we're using a
PNG compression to get the images
backwards and forwards it's not
necessarily the best way of doing it but
it's what we've got to know so far the
application of course is not to play
games remotely that that's just for
example purposes the application is to
get a load of say Linux images that are
all set to do lots of processing for you
and you want say a million of these
images all to do the same processing bar
one input variable where you know one
per million different input files in
that sense all you do is you you you
just want to make sure every now and
then that they're still running so you
connect to the graphics output of one of
these instances every so often and say
oh yes that's still okay that's running
and you close down you don't really want
to look at it all the time so that's
fine for verifying that the system or
that particular instance of jpc or
emulated our PC is in fact running
accurately and all this is open source
and it's a fairly simple protocol so it
can be done automatically script it up
so there we go we now basically what
i've done is achieve what should be
impossible which is without the users
explicit authorization all they had to
do is click one link to go and low back
and regional nereis applet but by doing
that they have delegated authority and
I've come in separately loaded a PC
emulator into their little environment
and run some native dose in this case
dos games with some native x86
executable without the need to worry
about security without lying if that was
a virus or anything because it's
completely isolated and on top of that I
then maintain control in the sense that
I can now look at the greatest card and
interact with that virtue
the running machine from anywhere in the
world and I think there we go back to
the presentation one final slide which
once we get through that yeah here's the
conclusion of these two things running
concurrently and two technologies
complement each other we get a massively
parallel computation resource thank you
very much grab a couple of minutes for
questions but not not that many I'm
afraid so Chris George's pecker any
questions one we've got up to 700 on one
layer server that was nothing special in
terms of server women the design
requirements are for an average pc
should be able to manage a thousand
clients and the way it scales out
globally is you don't try and keep more
more clients in one server you have few
more servers into a thousand at a time
or ten thousand a time that sort of
number yeah yeah we had a few thoughts
about that there are various things you
can do of course but then ultimately you
can't give a cast-iron guarantee clearly
because the software is running on your
machine if you've got really low level
debuggers and after you could get in and
find it out so the best policy I've come
up with so far as to say you know hands
off yes it's hard it's not for the
average person but there is no guarantee
so if you're worried about the privacy
of your data object skated before you
send it out do the processing in some
obfuscator way and then dmap it on the
way back okay well great I'm sorry
description mentioned something yeah the
business model we looked at various
business models and the obvious one you
know and I evenly come up with is to say
well we'll pay them for every job they
do that doesn't work especially with an
open source project because you could
easily engineer it so it lied I think on
balance the best solution is essentially
a you know a we pay you 10 pounds a
month or ten dollars a month or whatever
the number is just flat rate and unless
you your system is unavailable below
some threshold you get that no matter
what and we just have to work out what
that level of pain is or benefit
depending on your point of view that
makes that viable but on the whole
getting the resource to run stuff is not
the problem people are very happy to
give you stuff particularly if they are
going to even a little bit of money it's
really making sure that it's not going
to compromise their other uses that's
the issue and then making it the whole
system attractive for users when they
come up against the issues of how they r
en genere software to be distributed in
the way that it needs to be no you can
UAS is is a separate product in the
sense that you can run Java processing
in the race without the pc bit so if you
wanted to not suffer the slowdown factor
of the pc emulations you could run java
processing the the one thing about that
though is to get bulletproof security in
a Java applet you can still if you
really want to be nasty you could use
lots of threads or and burn the CPU and
then get get in the way of people you
can use lots of memory or stuff like
that so there's no way currently in the
JVM for us to limit that words with jpc
we can because the threads the thread
that's running is the emulator threat
it's actually under control of the
software you it's not being it can't be
hijacked for any other purpose it just
runs the emulation indeed the same as
memory when you say the pcs got this
much RAM that's how much has got you
can't do anything about that so there
are there are balances about how
paranoid you are whether you'd like to
allow this Java processing or whether
you you just want to only have pc
emulator price
yeah yeah well we tried that out quite a
lot and at one point we did have a way
of changing things and manipulating the
user say only this time of day and that
sort of stuff but in the end it was way
too complicated and you put the Java
threads down at low priority and you
just don't notice you really don't we've
had it running in the department at
Oxford and people have forgotten it's
running even though technically if you
look at the CPU meter a hundred percent
all the time you just it doesn't affect
anything so we think that on balance the
modern scheduling software in the
operating system should be able to
manage that right well thanks very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>