<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Advanced Topics in Programming Languages Series: JSR 277... | Coder Coacher - Coaching Coders</title><meta content="Advanced Topics in Programming Languages Series: JSR 277... - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Advanced Topics in Programming Languages Series: JSR 277...</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Lbe8DA1bdC4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so as mija introduced on the jet our 277
specification elite and me how is also
one of the contributing member in the
2007 expert group and this afternoon we
are going to present the Java module
system so let's get started so here is
the go of this talk but what I would
really like to talk about first is what
exactly are the problems we are trying
to solve with the Java module system if
we look at the java SE platform today
the common standard packaging format is
what we call the java archive or the jar
file now it was first chosen by Netscape
as a way to package classes and
resources in Java applet in the browser
packs in the 1990s and later it was
adopted by sun in the jdk as the
standard packaging format in the Java
platform now if we look back the
decisions was rather arbitrarily it was
not because there are a lot of advantage
of the java file format it was mainly
because of the popularity is back in
that time but the decisions has worked
reasonably well and basically every
applications right now make use of the
jar files but as developers use more and
more of the jar formats in the last 10
years in all those showings is
deficiencies for example it is rather
difficult to express versions
informations in the jar files and if you
want to express version dependencies
between two jars there is no easy way to
achieve that and if we look at many java
applications today it consists of not
only one job but multiple jars and
sometimes even native libraries however
there is no standard packaging format to
group them all together and distribute
them as one unit and as a result many
developers are either being forced to
sip up everything's and distribute their
applications as a giant zip file and
hope that the end user will be
intelligent enough to
cebit and deploy properly or they may be
forced to create a custom your native
installer to fondle their applications
together for deployment and
distributions further if we look at how
the jar file formats it's being used in
the JVM it also served two different
role on one hand the jar file is a
distribution format on the other hand
the jar power is also being used as an
execution format in the JVM so one of
the implication is that whenever you try
to start up a java applications the JVM
has no choice but to scan all the
contents you're in the job of in your
class pass one by one the reason for
that is because there is no metadata in
all this jar files to tell the JVM what
it contains and it has significant
performance impact to every java
applications out there so all these
deficiency know can be summarized in
what I call three kinds of health the
classpath hell the jar hell and the
extension health I'm not going to go
into details here because I can you know
talk about it or date but you know they
are basically various problems related
to class loading packaging and
deployment in the Java platform that
every Java developers would have
encountered so the goal of the Java
module system LJ's out to you 77 is to
produce a module system that address all
these deficiencies and more the Java
module system is targeted for the next
versions of the Java SD platform it will
provide first-class modularity packaging
and deployment support that is built
into the platform there will be a new
versioning scheme that allows developers
to express versions in the modules as
well as versions dependencies between
the modules will also have a new
distribution format which is what we
call a gem file that enables developers
to package not only classes and
resources but also jar files and native
libraries together as a unit of
distributions the new gem file will also
contains metadata which has all the
modules informations in it and this
makes it easy for discovery and it also
makes the module self-describing and in
order to deploy such a modules we will
define a set of repository
infrastructure that enables developers
and deployers to put multiple versions
of the modules on the same system site
by site so different applications can
pull different versions of the modules
they like from the same repository
without any conflicts and all these
modules will be installed in the
repository in isolations and all this
will be supported by a comprehensive run
time that will be defined by the module
system now in order to make the module
system easier to use we would like to
integrate the development as well as the
deployment experience with the language
and the JVM through JSL 294 so for those
of you who are not familiar with gsl 294
it is a gsl that will define the
linguistic unit of modularity in the
java programming language and they also
deal with the problems of informations
hiding and separate compilations so
going forward developers will be able to
write a modules directly in the java
programming language compile it and turn
it and package all the classes and
resources etc together into a
deployments unit that can be used by the
module system we will also like to
integrate the module system with the
class of libraries in the java SD
platform as well as the jdk tues so in
the futures you will be able to leverage
the functionalities and features in the
module system transparently from your
program when you make API call
and things like that in the java SE
platform we also plan to make a search
of reflective AP is available for
programmers to use what that means is
that all the key abstractions in the
module system such as modules modules
definitions repository etc they were all
service at the API level so you will be
able to make use of those aps to build
something very powerful in your program
the architectures of the module system
is also designed to be a lockable and
extensible so let me explain explain
this a little bit what this means is
that third parties may provide their own
custom repository implementations using
whatever backend of underlying storage
more though they like and plug that into
the module system for it to be used so
third parties can you add values to the
module system this way and also the
architecture is extensible so some of
the existing module system such as
NetBeans osgar exageres they can also
plug into this framework and expose its
their modules directly as AJ's out 277
modules for interoperability and i'll
talk about it later and obviously there
are many existing systems out there that
are solving you know something similar
to what we are trying to do for example
don't net osgi NetBeans maven IV
exageres so in order to learn from the
experience of all these existing system
we have a fairly large expert group
which currently consists of 20 people
from various companies and developers in
the industry so we hope that we can draw
from the experience so we can build a
better module system now
let's go into more details a little bit
but before we get there so let me try to
clarify two distinct concepts when we
talk about modules on one hand there is
a concept of modules for development on
the other hand there's also a concepts
of modules for deployment the last talk
of our modules for development or the
development module first so the
development modules is basically a unit
of linguistic modularity and developers
would typically write such a modules
using the new super package construct
that will be defined in jay's out 294
and when you compile it and try to load
such a modules into the JVM the JVM will
make use of the informations in the
development modules to enforce the
modules level access control on the
other hand deployment modules is very
different as this name indicates it is
all about deployment it is a unit of
reuse versioning and packaging and it
also consists of metadata which makes
the module self-describing and in order
to deploy such a modules you will use
the repository infrastructure in the
module system so potentially you can
make use of this infrastructure for site
by site deployment and there will also
be extensive tools and library support
for the deployment modules so you may
ask what exactly is the relationship
between a development modules and the
deployment modules so developers would
typically write the modules using the
new super package construct and they
will compile it and turn it into various
kinds of artifact and one of the
artifacts is the metadata for the
deployment modules so developers can
simply package the metadata along with
the classes resources and other things
together into your deployment modules
for distributions
now let's look at an example of what a
development modules looks like so in
this case I have a calm dots under my
modules that is declared using the new
super package construct and inside
modules which is typical to have public
API as well as implementation classes
and both of them belongs to the modules
as the members so I could use the module
I could use the member package keyword
to declare what exactly are the classes
that belongs to be part of the modules
membership and even I have the public
API and the implementation classes
developers normally only wants the
public IP api's to be visible and
accessible outside the modules and to do
that you can use the export mechanisms
to specify in the construction and it is
also not uncommon to have modules that
depends on other modules and you express
such a dependency you can use the import
mechanisms to declare it in the control
as well and notice that the import in
the example is currently being
highlighted and the reason for that is
because the imported mechanism is
currently not defined in the two gs out
United for specifications right now and
this is something that we would still
need to sort it out with the expert
group now if you look at the modules
informations that is specified in the
super package construct it has the
modules name the membership Export
Import etc I mean they are pretty simple
and easy to specify but what happens if
i want to specify something like the
versions of the modules or the resources
that i would like to make visible and
accessible from the module class loader
etc now to do that
277 will provide a set of annotations
for developers to use so you could use
something like at versions to specify
the versions of the modules with the
super package or you can use the at
export resources annotations to
specified the resources that you would
like to make visible or accessible from
the module class loader etc so one
questions you may have is that so how
can some of the modules informations is
specified directly in the language
construction while some of the other
informations are specified using the
annotations now the quick answer is that
all the informations that is specified
in the super package construct they must
carriage semantic meaning in the
language and understood by the compiler
at Build time as well as by the JVM at
runtime while the informations specified
in the annotations they carry no
semantic meaning okay so once we have
specified all the modules informations
in the super package construct may be in
the form of annotations may be directly
in the contract itself what happens if i
compile such such a super package the
result is that there are two kinds of
artifact on one hand the first client of
the artifact is what we call the DA
super package files the DA super package
files is the authoritative binary
definitions of the modules it consists
of the modules named modules export
membership import exageres and at
runtime the JVM will make use of the
membership and the export informations
to enforce the access control and this
file can also be used as the metadata in
the deployment modules the second kind
of the artifact is what we are familiar
which is that
our class file now if you take a Java
class that belongs to its super package
and compile it the result will be a dark
class files except that in this dark
class file it will have some special
attributes which indicate which modules
it belongs and when social class file is
being loaded by the JVM the JVM will
look at the attributes in the dark class
file and cross-checked the membership
informations in the dossier per package
files and this is done for obvious
security reason now if we look at the
entire development models and start back
a little bit what we are trying to do
here is to enable a years of use
experience for development and
deployment developers would typically
start writing their modules using the
super package construct and all the
modules informations will be specified
or in one single source files then they
can compile it and it will automatically
generate some artifacts which can be
used as the metadata of deployment so
every time when you try to make use of
or when you try to update the modules
informations in the super package files
all you need to do is simply become part
and the metadata will be automatically
synced up and this also this model also
make it possible for tues to combine the
compilation as well as the packaging
into one step so some tools can take a
super package source file along with the
Java classes compile it package it or in
one step and turn it into a deployment
modules for actual distributions now
let's look at what a Java module looks
like at the logical level so in the
modules it has the metadata data which
consists of the modules name etc and it
is what makes the module self-describing
it also has the closet and resources
that are part of the modules
and in addition to that the modules can
also have jobs and better in it as well
as native libraries so if you look at
some of the standard extensions today
such as Java 3d they consist of multiple
jar files and native libraries and the
way we currently distribu it is to
deliver them as a native installer for
installations and going forward this
kind of standard package standard
extensions can be packaged together in
one single Java modules and this makes
software you're much more easy to
distribute and deployed now let's look
at some of the informations in the
modules metadata in more details so ish
modules consists of a modules name which
has five different spot the major number
the minor number the micro number the
update number as well as a qualifier
strange and developers are expected to
increment or change each of the part
depending on the degree of changes that
they are making in their software and in
case there's no versions numbers declare
in the modules the module system will
automatically provide a default versions
for you now as I thought a modules
typically consists of public API as well
as implementation classes now to make
the public API accessible and visibles
outside the modules you can use the
export mechanisms and there are two
notions of export that we support in the
module system the first notions is
export closet and to declare that you
could simply use the export keyword in
the super package construct and this
will be recognized and supported by the
compiler as well as by the JVM at
runtime so when you try to compile
certain classes that are modules private
in some other modules the come
color can make use of the export
information and cash these kinds of
earth now the second notions of export
is what we call export resources so
export resources are the resources that
are visible and accessible when you call
a certain message in the module
classloader such as get resource
getresource a stream or get resources
and they can be declared using the add
export resources annotations that can be
attached with the super package
construct now we have just talked about
exports so how about input now import is
the mechanism that allows developers to
express dependencies between smuggles
and the dependency is basically
expressed using a module name so in the
first example the XML modules simply
import the sub modules and at runtime
the module system would interpret it as
importing the highest versions of the
modules available from the repository so
what happened if I don't want the
highest versions and in this case you
can express it in the second example
using the add versions constraint by
specifying the versioning requirements
that you want and the module system will
be able to honor that and the import can
also be make optionals as well as in
some cases you may also wants to
re-export the import modules from your
modules as well and they are also
polymer by the module system
at this point yes are currently it does
not have semantic meaning but just if
there's something that you're with you
working on with the expert book to to
find it out yeah so so why why is the re
export carry no semantic meaning yeah
and you're as I Daniel this is currently
just know what we have defined in the
2007 specifications and this is
something that we will still need to
work with the 294 expect group to figure
out what the right semantic meaning
should be in your language okay now I've
just talked about know how you would
write a modules using the super package
construct and generate it and turn it
into some your modules metadata and once
you have that then you can package the
metadata along with classes resources
maybe even jar files on native libraries
and group them together into a
distribution format for actual
deployment now the module system defined
a digital version format which is what
we call the gem files the gem file is
basically based on the popular your jar
file format except that it has metadata
as well as it has the ability to carry
jars and native libraries and because
the format is based on the jar format
the gem files can be digitally signed in
using gel diners as well as verified in
similar way it can also be further
compress with pack to hundreds so I
don't know how many of you are familiar
with pack 200 is a hyper compressions
technologies defined in JSL 200 that
will give you a very high compression
ratio such as you know 128 or 129
compressions rate and this will make the
size of the gem files much much smaller
and make it easier for distributions on
the web
and the module system have built-in
support for path to hundreds so if you
have a package m-files provide you the
module system the module system will be
able to automatically unpack and deploy
for you now let's look at an example of
what a gem files looks like in this case
I have a ought to examine modules with
version 10 free and as the filename
indicate the modules name and the
modules versions are all part of the
file naming conventions of the German
path and this files also end with the
doctor extensions now if we look at the
content of the jump-off you may find
something more interesting in the first
entry I have the manifest MF well no
surprise no it is typical in any new jar
files in the second entry it is more
interesting is the entry is the module
store metadata this is the fast that
gets generated when you compile the
possible package and this is also the
metadata that makes the entire empire
self-describing and inside the gem files
as you can see in the next few entries I
could also put native libraries and jar
files and they're all being stored in
some special locations and for the rest
of the classes and resources they are
simply stored at the root of the gem
file which is similar to how classes and
resources are being stored in the jar
format today now once you have package
everything's together as a gem files you
can now distribute it to other system
and deployed and the way to do that is
through the repository mechanisms and
I'm not handing over to me home to talk
about that
you want to heard from Stanley the
rationale and motivation for having
repositories but let me just quickly
recap what are the benefits of this new
mechanism so the repository is the black
box implementation of how class how
models are stored on a system and they
basically follow the standard API
developed by the module system and there
are multiple benefits of this first of
all you can store multiple versions of
the same module in a repository for
across multiple repositories and grant
environment an algorithm that I've
described later that basically chooses
which of the virgins is being used
satisfied which import but furthermore
this is a mechanism that we will use to
make it possible for other module
systems to be plugged in into the jsr
2707 module system so i might imagine
repository that helps the netbeans are
always di module systems be implemented
and deployed side by side with the rest
of the module system but another benefit
that hasn't been mentioned yet is that
because the implementation is a black
box you can imagine whatever
optimizations and implementation of
actual storage as you wish so you could
have some database back-end or whatever
you want they can be just a passive
implementation of a repository and all
this will be supported by the module
system so with all the specs ability you
might have already imagine that there
were multiple repositories present at
the site on the system at the same time
and some of them of course we cannot
even visually exactly what they would be
but that will give you three examples of
those that we already know will probably
be present on many systems and I can
described roughly the differences
between them so that boost of repository
is the first one that you will see
everywhere this is the most privileged
repository that contains all the core
packages from the java SE platform so
anything any package this touch with
java dot has to be stored in this
repository it is not consider secured
storage in another repository there is
also there will be multiple kinds of
global repositories we envision for
example them could be one system-wide
global repository that would be under
control of the administrator in which
some things some modules can be stored
and can be used by various users it can
be also a global / user repository they
can be used by enough
applications of the same user only and
no other users will be impacted an
application repository is the one that
will be created automatically by the
system if you wanted to quickly deploy
an application that wasn't actually
installed in any of the repositories it
would be created on the fly an
application startup and we will have all
the right properties of repositories
there are two kinds of NC you can see on
my slide the local annual report URL
repositories a little bit different than
the previous ones in the sense that they
make it easier to share and to deploy
modules in the local repository you can
basically drop a module file into some
chosen directory is called the module
interchange directory and it will just
be picked up from there so what follows
is that first of all of course it's
easier to deploy but also some
optimizations that are possible because
you know exactly what is installed I
would not be so easy to do in this
repository this is also the one that can
be used to share modules across multiple
implemented with JR is that you may have
implemented on your system because
there's one single directory that would
be basically specify this as the base of
this repository a you are you are at it
was very similar but it's further
optimized for a network download that we
potentially go over low bandwidth
connections and there would be a way to
quickly get the metadata without
downloading the whole jump file enough
of the metadata to resolve the imports
and to to reason about what is actually
in a module so all this leads me to this
optimization bullet at the bottom we
don't know exactly what will be
implemented but given this mechanism you
can imagine that many operations that
are today performed at runtime can be
actually done earlier so anything from
say class verification to indexing all
these other files or maybe even to
native code generated cogeneration can
be done early because there's a single
point in time when modules are installed
and uninstalled and the whole system can
reason about it and it's hard to say
what exactly we supported by with
Jerry's but this is the freedom to make
it possible that is not quite there
today with a standard class search
mechanism
so with others depositories your course
probably have already guessed that
there's some way to connect them at
runtime and if you are familiar with a
java class loaders it is somewhat
similar to this there's a delegation
process going on so there's always some
repository in which you start your
search for modules and if the supposed
order is a parent depository it quiz the
parent first to find out if there are
some other modules will present their
and some of the combined set of all
modules has been taken into account I to
explain how this works I would take this
more general picture you see here summer
poster is connected into this diagram
I've made it simpler and take a specific
example so imagine a simple application
that has a global repository the parent
and this one has the book stripper
poster is apparent and let us imagine
that in this application there are two
modules the application module a and
some library module B and they those two
versions 10 for both of them to currency
now further imagine to build it
interesting that there are more versions
of the B module installed on the system
so they see some other versions one dot
4 and 2 point 0 another question is if a
imports be which version of B would be
input to be imported and what the
mechanism produces so this is what the
example will illustrate so imagine that
module a that we want to resolve it
imports for has the following version
constrained you have seen already and
every side a simpler version constraint
there's a specific version here you see
a range of versions that is there is the
constraint I if you look carefully see
that there's a square bracket on the
left and they run parenthesis on the
right which is supposed to be similar to
the standard mathematical notation so
the left ranges in closing this example
the right end is not so it means that
any where animals will be a virgin one
of inclusive to to point out not
inclusive would be a valid input for
module a as specified by module eight so
there are few of those in the system
that satisfy this distance train right
so what would actually happen because a
comes from the application repository
better possibly we queried to resolve
the import and it would delegate it to
his parent which will delay to its
parent and the booster repository will
look at what it what it contains and
turn the highest version that meets the
virgin constraint which in this case is
1 point 1 point 4 if 2 point 0 is too
high doesn't meet right and so the one
part 4 is passed down to the global
repository which look at it contains
itself and finds now the highest version
between what it saw in a parent would it
has itself in this example you see
they're actually the same same version
number 1 dot 4 so the module system
which would enforce the property that is
that is important to us that every it's
always it is that parent is trusted at
least as much as a dividend positively
so there's always the preference given
to modulus loaded from the parent so in
this case the one that fall from the
booster report study will be the one
returned by the global repository so now
this will be compared with what's in the
application repository there is no
higher version there so the version 1
dot 4 is the one that this will be used
and as the input here let's play super
example but it explained a few concepts
here now whenever we talked about import
mechanisms sooner or later someone who
asked us what happened in the case I'd
fix and so I will always draw a diagram
kind of like this so let me explain what
the problem here's imagine we have some
module module in this example that has
to imports B and C 2 modules and both
BNC import the same module d so what
people would like to see is that the
same version of D would be wired wire to
both modules be and modulus e and this
is this is a desirable property so to
the state to navigate a graphic explain
a little bit legend to watch their
server bots is every node in the graph
is the module is a version and name for
it every edge is a version is that is it
imported dependency and the label next
to an edge is the version constraint so
you will see actually a new syntax here
that I haven't shown before input from A
to C is basically with a plus sign it
means its version 0 or higher which
specifically intended version because
every version has to be at least version
0 so in this example we see we see this
sharing and this is multiple benefits
the first one is a performance if you
have only one copy of every module that
is ever reference of course this less of
a memory footprint and this is this is a
good thing but it's also correctness if
any of the public API is of B and C
use classes for module d if you're
different versions there will be
actually a mismatch so if say and method
from module hbu to turn something of
some classroom from module d they were
supposed to be passed into modules c by
there were different versions there will
be a classcastexception that would
basically failure and runtime so those
are the two reasons why you would like
the module sharing now why do you ever
not get the module sharing so this is
where the next slide illustrates the
version constraints on for other inputs
of module d in different in the all of
the graph of the application were
different you might end up with a
situation right here but what will be
cannot use the version 1 dot one because
it's too high for the urgent constraint
but from what you see this is the
highest compatible version so it can
indeed use this one and two different
versions that I used here certainly do
clearly the person who wrote the code
and created a module don't do much about
it because BNC can be deployed by
someone else potentially this completely
could be outside of the control so it's
not an Indian do but once you deployed
everything the system there are some
things you can do because you know all
the repositories you know they start the
content that you can tweak somehow how
the inputs are being are being resolved
and this will lead me to the next slide
which shows some advanced features of
how you can control what inputs are
being provided so the first feature is a
custom import policy this is actually
this can be actually this actually
embedded inside a bottle and it gives
you more power than a standard version
control it's actually a piece of code as
a class that for some standard API that
has been invoked by the module system to
find out which versions of modules
satisfied particular import so this is a
fairly powerful mechanism it's movie
best if it was never used because of
course is better to is declarative
approach in general then imperative but
in some cases for example for different
module systems it may actually be
required to provide more more more
functionality now the other two
mechanism the overhead mechanisms are
the ones that can be actually applied to
solve the problem from the previous
slide so let me describe them briefly
first and that I will show you the graph
again and show you how how they address
the problem the visibility policy can be
applied to a different system to
determine what
which modules are visible for any
resolution action that ever happens in
which are not visible and the input
override policy is a specifically
targeted particular one import so it is
consulted whenever an input is dissolved
and it can say something like if this
import if this class inputs the other
class I just want to narrow down the
constraint to only use some versions
rather than the more wide constraint of
the original specification so let me go
one by one start with visibility policy
so imma do the same graph we have this
unfortunate situation that there is no
sharing of module d and you would like
to fix it so the visibility policy would
let me look at the situation and say but
I know that the problem here is that
module d version one that one is visible
i would like to admit it just not
visible so you install this disability
policy that this is what it does makes
it invisible and therefore now then you
it may look at the better constraint for
input from C to D there's only one
version that satisfies it which happens
to be the same as the one for module be
so get to the same sharing program
solution and the administrator for
example or maybe the user yeah yeah so
say that would be the question question
is who makes who makes connected
invisible so not the magis- so those the
other backgrounds I mentioned earlier
that custom import policy that could do
this but we dread would and discourage
people from doing this because the
modules other modules that you see on
system can be another surly yours so say
in this example that a B and C are
deployed by different people so you
don't a and I would be somewhere else
wrote see you have not controlled by the
impulse of C so there's no before you to
influence this only the end user the
administrator has the has all the pset
pieces at the same time and tomatoes
decision but if you wanted to be
somebody to guess it rather custom
policy that says oh it happens to be me
house version of B then do this and
modify the console you could do this if
you want to do bodies we don't be that
this would be right particular
so the question is what if the user is
not intelligent enough to make this this
this mechanism work and of course this
is an inherently hard problem so I have
to say that there's no magic bullet
we're dealing with an extremely complex
system some are somehow determines all
these versions incompatible it has to be
highly skilled person so unfortunately
we don't solve the problem of people who
don't have to do it no please no please
so the next mechanism is this input
override which is a little bit different
in the sense that module d version one
that one is still visible in the system
for some other applications perhaps that
are they want to use it but we know the
dispatch your application can dispatch
the application cannot deal with this so
just attack this one input for module C
to D and listen override says well let's
let's narrow down the veteran constraint
so that now it's 110 201 and therefore
will not use one at one even though it
is still visible for other applications
and it has the same properties before
it's only for advanced users but this
why my cycles could add advanced
mechanisms we don't anticipate an
average user will be able to use this
but there are welcome existence in
practice that people do demand the sort
of power and we have specific requests
from some companies that would like to
have this ability and they basically
couldn't live couldn't live without some
mechanism like this so so it is provided
it is valid it is provided by many other
module systems as well some way of
overriding what's the motive system
where it has been used in practice often
either follow-up question it's makes it
impossible to
for module 2 ever rely on the person
above one plate off another puzzle this
problem keeps coming up in 25 years yeah
so I don't have it so I don't think we
claim that this summer solve source
ourselves everything's but so what
specifically would you would you suggest
but it does some persuasion assume that
you are a consultant you know highly
paid person who would like to fix an
application that doesn't work on some
system now even mechanism to mate to
make make it happen you just write you
learn at writers policies and easy to
write them and it by the man-made
reputation work there's a standard I'd
standardized way of doing this and I'm
not saying that it's easy but is it is
possible look at it from a kind of here
the person who writes module see a new
version month plus a 1 point 2 of module
Deakin round right module see wants to
use one by two of the that he can never
use it yes SSO right Hickey realize and
one point to be the final give the
duplication of the store user's machine
can be so the saying that ok the users
magnifier consultant so the question to
repeat for people who couldn't hear the
question is that if the person who wrote
what you'll see would actually like to
is a higher version of what you'll be
say one point to that it becomes
available there's no way here to use it
some acid this is that in this but your
scheme there is to butt in but there was
a solvent so for example module beak
will be deployed with hybrid written
handle higher versions of D or some such
thing such thing could happen yeah yeah
let's not very strong but I wrote this
letter solid lead it should because I
got a tight on time let's pick the
attention of line and can do stress it
more but I I admit that we have not
solved all you know we don't provide a
solution that would make some magic
happen this is an inherently hard
problem now if you have some by the
researchers have to fix it we're still
probably open to it to the changes would
love to hear them so now briefly about a
life cycles so there are two kinds of
life cycle i would like to mention in
this talk once the repositories is very
simple can initialize one and then you
can shut it down and their support for
this we define what happens when you
shall deposit orion and sound boots
modules are being used and
it's all defined and then four modules
what happens for module so I've also
have to be first found is this
resolution process this thing up what I
described in the previous slides howdy
hi how you decide which version is being
used for import after resolution happens
there's this process tool validation
that you two times of validations that
we define the shallow and deep one the
shower one is always fun is required for
require for correctness and all it looks
as is the metadata of the module and it
looks whether there's for every module
looking at all its imports if there's
exactly one class provided for every
class that is be required by by this
module if is either zero or more than
one then there's an error and again you
cannot use the particular import deep
validation does does more checks and I
don't want to go into details but it's
expensive enough that we anticipated we
use for debugging only not in a normal
use then if everything is a right a what
is in the in the ready state and can go
into error state as you can imagine if
something goes wrong on the way so now
at runtime now what happens at random so
typically you would see a one-to-one
correspondence in the implementation
between a module and a class loader this
is needed to have separate by six
separate lines places in a way for
classes of the same name otherwise and
you see here from some graph of class
service of the connected and we have
used class noticed in the past we
probably would see something round here
because in the today's model there is no
idea of cycles in the class loader a
derogation system but will leverage the
new support for class loaders that will
be available java 7 and we do require
these four modules because modules do
have slightly dependencies and the
shallow validation I mentioned in the
previous slide is actually key to making
this work because we know that forever
import we are divided it best exactly
one class provided by provided by one of
the imports the satisfies satisfies this
this particular reference who know that
this will be a always resolve in in a
finite time it can be implemented
relatively efficiently
so this is about what we thought of to
ease migration from legacy systems into
the new module world there are two
special modules are automatically being
created by the system what sorta
matically don't worry about Java it will
be expected to always exist java dot s
ii is the module that contains all the
existing core s ii packages and it's a
central module that is imported by
default by our application so if you
don't change the center line of coating
application you will still see
everything you are able to sleep in the
past it is by the way we do anticipate
the SE core platform will be further
modularized in this finer grain modules
and they'll be a way to rely on you in a
subset of se but if you don't do
anything specific you input this big
module that potentially inputs many
small ones and we export all of them all
of them so you will see all of the SE
platform they probably would prefer to
bottom but ability right but on the lawn
so the question was would you see things
act like like from from a combat some
design stuff and probably initially they
would and the long term path would like
to maybe delivered from this and the
other module is the java class both
module which is automatically created
and everything's on the classpath at the
time of the applications that will be
automatically added to this module so
then without having to do anything
special if you just want to use access
legacy drove easily you can you can you
can do it wireless patterns so this
concludes the main part of the todd and
i will now let's Stanley finish by
saying what's the current status and if
you find our comments
okay so so I hope you know we have
provided enough information for YouTube
you understand the high level of the jar
module system so what is the current
status of GSR 277 that your early draft
review have always been published and it
is available today if you're interested
you can go to the JCP website you
download with and you know since it has
been published we have received many
valuable feedback from people in the
Java communities so we've been working
on the revised specifications in the
expert group and it is currently under
review and discussions you're inside the
expert group your mailing list and we
hope that you know we will be able to
make these versions of the specification
available near later this year now one
issues that we are going to tackle in
the next few months in the expert group
is the issues around interop abilities
with GSR 291 or osgi the goal here is to
provide some kinds of interoperability
to allow GSR 277 modules to make me vaca
views of the osgi modules or vice versa
however the design and the constraint in
jail 2007 the jar module system as well
as the GSR 291 the osgi module system no
there difference so what we are trying
to achieve here is not perfect in her
ability but we would like to achieve a
degree of interpret of abilities with
minimum restrictions our fear is a
modularity framework you're defined by
the osgi alliance and you know it
kearney's you're also runs on the Java
platform yes okay so how exactly do we
do we get there in terms of
interoperability solutions so we plan to
develop and in top abilities proposals
in the jetta 2007 expert group in
the next few months then we will flow
that proposals to the 291 expert group
for review and discussions and there are
many implementations options currently
under considerations and we are still
exploring all the options that we have
so in summary just up 2007 aim to new
address various problems in the jar
platforms today including your packaging
problem deployment problem modularity
problem and it will produce a module
system that will address me all these
issues in the next generations of the
java api platform it will provide
first-class modularity packaging and
deployments support that are built into
the underlying platform and it will also
provide a seamless end-to-end
development and deployment experience by
integrating it with the language and the
vm Fugees out to 94 which is the super
package dear sir we also plan to
integrate seamlessly with the classes
libraries in the existing platforms and
adjudicators so you can make use of the
features and functionalities in the
module system transparently in your
applications and we are also trying to
design the architectures to be pluggable
and extensible so third parties can
provide their own custom repository
implementations on top of the modules
system to act values or your other
existing module system such as NetBeans
osgi etc they can also plug into this
framework to expose their modules as a
tower 277 modules for interoperability
and hopefully you know the classpath
hell the jar hell and the extension how
we'll find out will finally go away and
if you are interested in more
information you can check out the early
drafts specifications it is currently
available on JCP website one thing you
know to notice is that near all the
contents that we cover us today in this
presentations
is based on the revised specifications
there is not currently available so when
you check out the early job
specifications you may see a huge
difference between them you know just to
give you a heads up and if you're
interested in observing the expert group
discussions you can subscribe to the
mailing list and if your language in if
you are interested in the super package
you know language chairs are there is
currently a strong and proposal
available that you can check it out and
you can also be a subscriber to the ug
mailing list as well and lastly at
javaone yo well two weeks ago our son
hair has announced that we will make the
reference implementations of jay's out
to 77 as well as gsl 294 available in
open source form later this year and we
have currently set up a project on the
oven jdk website and this also will be
available new in an experiment so if you
are interested you can keep track of
your order status and changes from the
openjdk project
why did you not simply intersect the
word constraints and community questions
why why don't you not end at that that
we were changing levels yeah I asked him
at the language level when this module
discovery hmm you have version
constraints right why didn't you simply
intersect all the constraints on
particular module and pick one
intersection so the whole API you take
my repository is where i show this
derogation module right yeah so the
question is why wouldn't use a simple
mechanism that simply doesn't but runs
the intersection of all restrictions in
all the repositories everywhere we still
have to know which ones are connected in
the delegation module so you just have
create a list of them i guess and do it
it's an intersection there right so in a
way this what happens so that two
possible systems there's the model
system itself which measure the
decisions relegations each module the
provides an implementation that is by
someone else potentially it only returns
what it contains itself and then a
module itself that Perkins busy
intersection i just type in a sequential
way because this is easier for me to
describe but basically she was going on
every module says this is what i had
word matches the constraint and then
some module framework is part of the JRE
but from intersection basically and fix
the highest version you know
International Union I guess sorry I
Union intersection would it work science
i'm not sure why intersection it very
much the intersection you mean you
renovate a union right of all the
modules is there because you had this
example on one daughter was in the
intersection of all the constraints
right so everybody's are happy with one
of my lord oh no no no it's a
no-pressure call now for questioning
yeah all right so sometimes they're
actually cases in which you do want to
put different versions sometimes it's a
private use of something and you want to
make sure you don't use a higher version
you want to just say i only tested my
with specified you one that wondered one
I know that anything else may break I
really preservative I promise I will not
expose anything of this and then a
public API and please don't bring him by
giving me a better user experience so I
smell import the same butter and says
well either to don't care about it is
I'm free I'm pretty good even the latest
and greatest because I want to pick up
the newest features is actually very
valid you stays so put
to do what you would sell us in some
cases but not in all of them anyway so
this was extra capacity is necessary the
system anyway but maybe you write it for
some some places we could use your
systems in person and also note the
repository and things like that they can
be added and changed dynamically at
runtime right so you cannot really just
new figure out the intersections you
know as startup come and use their
forever in the JVM sessions nah it seems
like it could be vested in the syntax of
that attribute so the longer author
could say it's going to be better if we
don't blow two copies of this so we're
going to so you know to tell the
repository system work as long as I get
something in this rainy
the job so soon where ever you need to
do to prevent so this edition is to have
an extra bit on every import statement
that says basically I'm willing to take
a lower version that they were then that
was hot what the highest one of mr.
constraints if this will help me
ensuring uh I don't know that's nice we
have not considered as I guess yeah we
can probably just yeah yeah it's a very
good point Oh soaking model dependencies
he resolved sir downward in the chain so
if there's a module in depository can
that resolve it import against like the
application no no questions is it if
there's an input in a higher positive in
the booster booster for example
bootstrap repository can it be result
from it from a lover repository so yeah
the answer is no one yeah at the antes
no look answers now in the reason is
because the because of his trust model
you also see me they going down in the
graph that you trust the poster is less
so you don't want this to happen just
about the model simple so you don't want
to it might well you status might work
but that's the Madrid easy to reason
about you don't never allow you to
resolve things down using assisted in
the regular web applications if I have a
problem where like you put one thing and
like vulnerable fastener pride in your
push everything up there
give away now I'm sorry one could
certainly imagine ways of doing this but
to make the security model simple and
easy to understand we will just opted
for a simple solution yeah I can't think
of the jsr numbers now but for
implementing inter module protections
some degree of separation the security
sense between bottles how does your
house look Jason 77 interact with these
busted at all so the question is about
some proposals that have to do with
security in inter module dependencies
image or solution I'm not at all do you
know the jsr number two you know but I
don't this is what about his point are
you are you talking about the isolation
avi or come yeah
okay we can probably take that offline
so lucky that you're sure yeah right so
this is a question about the 294 syntax
and the questions that earlier versions
of the of the of the same syntax had
super packages two words we see using
existing keywords of the Java language
and have no member keyword and now
that's assigned to this a new keyword
member and there's a new single word
super package so there's an early
Strummer voted by andreas and Alex maybe
four weeks ago and it has all the new
changes none of the experts said the 294
minutes which is published which we can
all see haven't had a lot of deep
discussions most leaders of java one
coming up and then exposing these busy
with this I can expect this one of the
issues that will be will be debated i
also have a signatory question but i
didn't want to where is it you're on a
mailing list so i don't have any answer
do have the answers in yeah I absolutely
right I i I'll ever since I think
there's both changes are necessary in
done by us and it can I do this here in
the resources why
outside of us
the questions if the resources the
exported by module can be certain to be
specified outside of the source code
that's a good question right sure yeah
yeah but by thanking you i love you you
package all these resources at the end
right into india djemba as one unit and
deploy it that way then then we don't
really care where the origin and
resource so info let me be more specific
so that does yeah right so they have to
live in j-stars from the point of view
of what we talked about today the 277
jsr it's totally irrelevant to us we
just want to get those files one path of
getting those files is by using the Java
C compiler and what specified in Jays at
294 one might imagine that you actually
write code in some other language maybe
no and Python whatever and you compile
java bytecodes i use your own tools and
we don't we don't care what those files
come from some pro our point of view
what do you say it's totally possible to
some tools wherever little bit ly
possible and I didn't matter matter of
tooling maybe this way to use jaisa 294
compiler first and add some things or we
suddenly thought of the industries are
I don't think that's right you're Moses
you cast flats as I expected something
I'm shut up what a fool I guess right so
this person is about cutting an
interested in you were right there early
so I said earlier that is possible that
if in my examples of modules ABC and
multiples of d if B and C shirts in the
api's module d that we sound class class
class caste error this is actually
impress as an incorrect there are two
things that might happen one is that add
validation time we would detect an error
and we not not actually do we no
exception raise class description or the
other place what happens thats about
someone one of those motors much would
be for example except something of type
object and then it expects that is
really some type of class d.end as a
cast and then we random exception so
you've got this is optional absolutely
loose with mobile technology i wanted to
be come back
okay am I supposed to compile one module
that time Mecca can put across matters
if I'm propelling quote across modules
might the compiler embassy one version
people were here in different different
strings right so the question is what
happens if i compile across different
modules and because there are different
version constraints i would see
different versions so the answer is that
from the JC 294 point of view version
doesn't really exist so it is indeed
even without that complex necessity that
is specified it's already possible the
dr i compile again subversion of modular
depend on and then later deployment time
I did a newer version the hamster have
say not have some class defined it's
already possible right can I can see in
an incompatible version and the fact
that the Java compiler team doesn't
doesn't Lee think the diversion is to be
part of the language it's kind of at the
root of this problem you can argue that
for the doctor level whether it makes
sense or not but once made a decision
that the java java language and that our
compiler doesn't reason about virginian
you have all sort of problems including
the one that you mentioned and i don't
have a good answer this is morbid is rj
that's a 94 problem right
yeah and he also goes back to the
question about the exports there are
many things that the compiler could be
aware of and the current proposal from
the 294 it is not aware I were off and
then it could cause lots of problems
wheres also the directive for
deliberation just started so no we
definitely I have a way to impact the
294 proposal so I will definitely know
if you have you know please now send
email to me or like directly related to
the spectre ease and we can definitely
try to work on some cases is essential
for versioning to work correctly try to
make them the same really very fit
so all the things by the way we're
discussed at length in the expert groups
of 2 77 and there are basically there's
now a central uniform answer that
everyone would agreed on so this is what
kind of why we are where we are
you allow
the person is whether we allow two
different versions Leslie modules to be
loaded to the same time a drunk on the
answer is yes my slides about sharing
with so basically we're trying to say
that it is usually the desirable thing
to share the same version of module for
performance reasons and to avoid those
different types of class caste and
resolution errors that you and
validation errors that you laid yet but
in sometimes it is indeed what you want
and we will support so you can have
multiple copies of the same module saris
suppresses the requirement of places to
the to the jvm the answer is yes but not
for the reason that you mentioned the
question before every module started in
its own class loader so even that class
of the same name in two different
modules throw at the same time because
they all have their own class loaders
today say the incident is already
support this separation so this is
actually already subject to today's JDM
semantics but for other reasons for
enforcing information hiding we will
have some support in the jedge idea so I
think that's it thank you very much for
coming I'll enjoy it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>