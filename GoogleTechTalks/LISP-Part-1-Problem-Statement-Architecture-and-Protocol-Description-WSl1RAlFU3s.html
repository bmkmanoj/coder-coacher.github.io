<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>LISP Part 1: Problem Statement, Architecture and Protocol Description | Coder Coacher - Coaching Coders</title><meta content="LISP Part 1: Problem Statement, Architecture and Protocol Description - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>LISP Part 1: Problem Statement, Architecture and Protocol Description</b></h2><h5 class="post__date">2010-03-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WSl1RAlFU3s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you for coming I'll give you the
man who needs no introduction so I'm not
going to give them one you know hello
everyone this is the first of a
three-part series and we're going to
talk about Lisp not the programming
language but the network architecture
and set of protocols like to introduce
my co-authors Dave Darrel and Vince are
sitting back there in gray green and
black okay so I think we're going to be
able to fit this in in one hour and so
please go ahead and ask questions at any
time okay so this is going to be part
one next Wednesday we do part two
mapping database infrastructure and
interworking since we are doing this
address split we have to map for one
address space to another that's going to
be referred to affectionately as the
mapping database infrastructure and of
course we want interworking we don't
call it transition but interwork and we
want nan with sites to talk to list
sites and we'll talk about that next
Wednesday part three is the most
exciting part because we'll talk about
the deployed network we have where we're
running approximately 60 boxes in ten
countries now and this is kind of a
pilot test modelled network that we
could possibly put in to production
later we're going to describe the
deployed network and the experiments we
ran over it and report on what our
findings were and it continued to be and
then we're going to go through a bunch
of use cases that's probably the most
exciting part on how this can be used in
branch offices in saving address space
switching service providers moving
virtual machines moving roaming mobile
nodes there's all kinds of use cases
that we will talk about so we'll start
off with a basic problem statement and
what we're going to do is change the
semantics of an IP address and we'll
we're not changing the values of it
necessarily but just how you look at it
and how you view it and where it where
it's routable where it's not where you
need it to dynamically assign in where
you don't and then what is list let
stands for the locator ID separation
protocol will give you a unicast packet
forwarding example a multicast packet
forwarding example and then will talk to
you about talk about the standardization
status of list and then tell you what
more specifically we're we're going to
talk in the second parts second and
third parts okay so this the problem
statement was actually defined at the IV
routing workshop in the fall of 2006
this is really when the the IBD internet
architectures board got together and
said we have to take a look at route
scaling on the Internet
so the IB the problem statement I'm
defining here is what the IB thinks the
problem is and what we wanted to do as a
solution provider is to not only solve
this problem but actually give features
to customers new features that basically
don't exist today that are bate that are
allowing us to use the Internet in
different ways so what the problem
statement is from the IB specifically is
that the rate of routing table growth is
of concern and has scaling impact on the
Internet can we reduce the size of the
routing tables in an accelerated way in
the short term and can the current
routing architecture support newer
services like mobility voice video
gaming virtualization and those URL
references can give you more information
now this is to be extremely clear this
is not something to keep ipv4 alive
forever this is not something only for
ipv6 this can't this solution can be
used to transition ipv4 to ipv6 but the
way we view it is that the routing
architecture is exactly the same for
both address families you really all you
have as long as match routing to do any
kind of traffic engineering so to us
ipv4 and ipv6 is just a different packet
format with different sized addresses
but everything else in the routing
architecture is exactly the same so the
same bugs and features are actually in
both okay
so basically this is a routing table
growth chart back dating back since 1989
I'm going to just as of six months ago
as you can see it's up and to the right
it was linear at some point it's turns
exponential but the key is routing table
growth is continuing is this good or bad
well as a hardware vendor we can keep
throwing hard you know again we love to
sell line cards to our customers but at
some point we want to give a value
proposition to our customers and so we
have to be able to say smaller tables
helps everybody at help Cisco or juniper
give new features without memory
upgrades we could download FIPS faster
we can bring up bgp peers faster we can
do mid blocks faster so small tables
help everybody so one of the problems we
have is just not new subscribers coming
onto the internet that makes the routing
tables grow but people that actually
pollute it for their own local purposes
people want to inject more specific
routes into the routing system because
they want to be able to control which
way packets come in when they're
multihomed in this case right in both of
these cases right here really routings
only tool is this blunt instrument
called longest match routing and if you
send it if a routing a router has a
slash 24 inutes slash 8 and the
destination is routing to matches the
slash 24 you will use it over the slash
a slash 8 is only used when the slash 24
is removed from the routing table so
what happens here on the left hand side
we have a site that's multi-home it has
addresses that are signed out of
provider assigned space in this case
provider a may a provider AIDS block is
10/8 so usually the addresses out of
here are more specific now what happens
is if the if this slash 24 is advertised
into the system and then this provider
just advertises 10/8 all packets that
are just to any systems that are in 10 1
1 will come in through this link here
and what we find is these links are
getting hot hundred percent utilization
and these are completely idle so for
this system for this AAS to be able to
get packets on both paths it has to
inject the slash 24 here
to an area of the network that can't
aggregate that / 24 so which means a /
24 has to go and everybody's routing
table there's a local benefit here at
global cost okay and not only that you
inject the route this way and we review
just injected the route this way then
packets will come in on this link and
not from provider a so you actually have
to inject the slash 24 in both
directions and the provider has to
inject a more specific from his
aggregate and this is adding to the
routing table size now if you come over
to the right hand side this is a
provider independent prefix which means
this site went to a registry and said
give me a prefix that's independent of
the service providers I'm connected to
I'm not going to ever have to renumber
again and I'm just going to inject 15/8
through both of my providers and both of
my private providers are going to
propagate it okay
the default ipv6 allocation policy is to
give UPI prefixes which means we're
going to have a flat routing table and
the capital I internet because
everybody's going to have addresses that
don't map the topology and therefore we
can't have aggregation 'el hierarchy and
scaling so this is a real problem and we
want to be able to bring back the
aggregation of addresses again so tables
stay small questions
so what we want to do is we want to
separate ID from location for the IP
address today an ipv6 and ipv4 address
have this overloaded semantics the the
128-bit address here means both ID and
location so if I'm going to send an
email message safe to Scott at Google I
open up a TCP connection the address is
already determined on where Scott is
because where he attaches to the network
defines what his address is okay that's
actually his location topologically now
if Scott goes home and I want to and he
stops at Starbucks and I want to send up
an email message now I have to send it
to Scott at Starbucks his location
change but the person I'm talking to has
not changed so since the location
changed the ID must also change
I must reset my TCP connection and then
we establish it to get to him and then
when he moves home I have to do it again
would it be nice if we can separate the
ID and the location one way you could do
it is take the lower door bits of the
ipv6 address and call it an ID and if
TCP would do the pseudo header checksum
only on the Lord or bits we can make
this work but it does not
when ipv6 was invented it said use the
entire 128 bits the high-order bits can
be used to say where you tap into the
topology and there's enough bits there
where you can do enough aggregation at
multiple levels you want enough bits on
both sides you want it on the ID side so
you can have enough connections or
opening up to a server millions of
connections and you want enough bits on
the left-hand side because you want to
do aggregation but per ipv4 we don't
have enough bits for either one so what
we want to do is we want to add another
address we can't change the ipv4 header
format or that's a non-starter so what
we'll do is we'll use encapsulation and
when we put another header onto a packet
the addresses that are in the outer
header will be locators and the
addresses on the inner header will be
these things called a IDs so since we
can't separate it like this what we do
for Lisp is we say that endpoint IDs we
call these addresses a IDs that are
signed to hosts and routers and switches
that are at the site are basically 32
bits in length and
eight bits in length now what's nice
about that is we know ipv4 and ipv6
addresses our power of two entities and
therefore we can aggregate even
eid-prefixes so if we have a mapping
database that maps from a IDs to
locators
we can do that in a scalable way as well
and of course the locators are still 32
bits and 128 bits but those are the
things BGP will write down in the core
ok that's the idea so this is how that I
addressing would kind of break up well
in the last example we said this was 10
100 1/24 that site still keeps that same
prefix we'll just call it an e ID prefix
and it does not get injected into the
core as you see throughout this
presentation
whenever you see a green address it
means it's from the Eid space when you
see a red address it's from the locator
space but here what we're showing is
that 1000 one is the locator or the IP
address of r1 that's attached to
provider a so this address this locator
just comes out of provider ASA
allocation and this address on our to
comes out of provider B's allocation so
it's already these are covering routes
so you can see that the provider a and
provider B only has to advertise its
aggregates right and then the the
address is here never appear in a
destination address of a packet that's
flowing throughout this network ok now
I'll be here if you come to the 15 /a
where it was P I same thing goes ok and
we'll explain how this works in a second
so that's the fundamental idea of
breaking up the address space now if you
keep a IDs fixed you don't have to
renumber ever again if you change from
provider D to provider F or whatever all
you're changing is the point-to-point
link and the IP address and the PE C
interface the only thing that has to
change and guess what if you had these
PA addresses that service providers were
giving out they could actually reclaim
all of them because now that they only
have to address is that point-to-point
link on the other side on the c ii side
so now there's more addresses more ipv4
addresses to address sites not devices
at sites so now the address space could
be used more efficiently and that's why
we get the reaction from people like oh
you won't need it to go to ipv6 because
of that well that's not so
certainly true because we want ipv6 to
still number all the devices in the
world and that will exceed two to the 32
real soon now
okay now by not having to renumber you
can actually change service providers of
a stationary slight changes service
providers it's actually changing its
location because it's tapping into a new
part of the topology where the address
dictates where it is in the topology so
you can change service providers or you
can take a virtual machine or a server
or a laptop from one site and move it to
another site keep the exact same IP
address we call it an e ID and the only
thing that changes now is the locator so
we have all this movements you can
actually take large topologies VLANs the
IP subnet addressing of a data center
and move it into a cloud and the only
thing that has to change are the
locators that are associated with that
Eid prefix so just remember that
eid-prefixes and e IDs that are assigned
to hosts don't change they're static you
can even turn off DHCP if you want to
for assignment so you have a name you
know
Scott Google Commons is DNS name that's
what people use but illa it'll map to an
e ID which is a network address that he
will keep for the rest of his life and
it's what we're doing here with IP is
the same what the cell phone industry
did with cellphone number portability
this is IP number portability now so
change service providers you can roam
have roaming handsets you can move
virtual machines you can relocate
infrastructure in the cloud and we can
do all this while keeping the core clean
and reducing the size of the routing
table that's the dream that's the hope
so
Lisp it has some recursive properties
like the programming language but it
doesn't have as many parenthesis but it
has some network layer headers that you
can put on it but it's a basically a
network based solution no changes to
hosts whatsoever we mean that and we've
proved that and we can we'll continue to
prove that no new addressing changes to
sight devices we don't want you to have
to renumber your subnets and all the
addresses at your site we want those to
be used and those are going to be called
eid-prefixes that are used in your IGP
your IGP doesn't have to change
very few configure configuration file
changes that means
we think the sweet spot for Lisp is to
put it on the CP routers at the site and
what we're trying to do with the is our
product line at Cisco is say you just
have to load a new software version and
we can then do Lisp encapsulation and
nothing has to change on the site side
and nothing has to change on the course
site to make this happen because
incremental deployability is imperative
that's all there's to it we really want
this to be deployed and you can do v4
and v4 six and six six and four four and
six all four combinations need to work
more more to the point maybe three out
of the four need to work so this is how
it would look like the packet format on
the left hand side basically is showing
you four and four encapsulation but what
you'll see over on the right hand side
is the the host will build this packet
right here and put an IP header on it
and when it inserts addresses there
we're just going to call me IDs it's the
same 32-bit values it puts in today the
source address is from either DHCP or
and ifconfig command the destination
address you got from DNS we just call it
any ID but the values are exactly the
same the packet then makes its way to
the edge and then there's a list broader
in the edge and adds another header on
it and those are locators so you see the
locators are out on the outer header in
the e IDs or in the inner header and
this is the list encapsulation we use
UDP encapsulation because we want
link aggregation groups that exist
between two quarter to two core routers
in the core to be able to load split
traffic along member links so it's
really important that we use UDP because
the destination ports a well-known port
but the source port will always vary
based on a five tuple hash of the inner
header okay note that you can have ipv6
a IDs over ipv4 arlok's and then when we
show you a use case I will show you how
at my house which is a list light I
could connect to ipv6 Google com which
is a non list site and there's no ipv6
connectivity between my house through
Comcast and my house through AT&amp;amp;T to
Google but that we were able to get that
to work so you have to wait two weeks
for that so let's look at a unicast
packet forwarding example
so here we have two sites they're both
multi-home kind of a mirror image of
each other there let's say they both
have P I prefixes VII prefixes out of
1/8 + 2 / 8 respectively and we call
these things ITRs are the encapsulator
x' and the ETRS are the d caps later
they stand for ingress and egress and
into and out of the tunnel okay we're
going to show an example here that s is
going to send a packet to D okay and
what we show here is that the only thing
that has to change to make this work is
that s 1 s 2 D 1 D 2 are modified to do
list but everything else stays the same
so s will send a packet to D first does
d dot abc.com gets a single a record
back could get a quad a bat record back
doesn't matter
and then injects this packet - 2 0 0 -
it puts in source address 1 0 0 - out of
its Eid space just like we mentioned
before let's say it's a TCP syn packet
because it wants an open connection
let's say that this source site has an
egress policy of shortest exit and let's
say s is closer to s - say s 1 and s 2
are injecting the default route and so s
is going to find its packets going to
make it to s 2 we introduced this new
data structure called a mapping entry or
a map cache entry this is an entry that
sits in a data structure can be
implemented many different ways but it's
a longest match lookup as well but this
let's say this entry is already cached
well wait till next week to say what
happens when it's not cached ok but for
now let's just say it's already cached
so the 2/8 is basically saying this site
has two locators 1200 - and 1300 - where
1200 - is its pece connection - provider
X and 1300 - its connection to provider
y
note that the priority and waits are
your only two parameters that you'll use
tab policy it's these ETRS that are
authoritative for this mapping okay
everybody's authoritative for their own
mapping the mapping database is
completely distributed across the entire
internet in the sites where they need to
be kind of like a DNS server for your
domain name okay now this site has
decided that priority one and one for
each route locator means that it wants
active active on ingress this guy's
paying for those two lengths he wants to
control which way packets come in so
what he says is I wanted to be active
active and I want the late weights to be
50/50 so anybody who's encapsulating to
me will you take your flows and fifty
percent of them send it to this locator
another 50 percent send it to thirteen
okay yes question yeah the question was
this is looking a little bit like MPLS
and the label kind of looks like the
locator and the private address looks
like the ID so it's a little bit
different in MPLS because it's done end
to end typically MPLS is done in one
administrative control which is within
an AAS and the labels are reese whopped
hop-by-hop where here you would argue
that the locator is a label but it's an
outer IP destination address that's put
on at the edge and d capsulate at the
other edge so the cord just thinks it's
this IP packet that it needs to forward
its forwarding it from site s to site D
once we inject the packet into the
center you'll find out that the routing
because of the level of indirection the
guys in the center are not routing a
packet to D their routing a packet to
the site of D okay yes so the question
was it looks like the locators are
globally routable and that's a true
statement and it looks like that they
the eid s are not so how do you
distribute them to the rest of the world
that's what the mapping database
infrastructure will be used for and
we'll talk about that in part two next
Wednesday so please show up so what if
this guy wants a different policy
depending on who's where the source
packets are coming from let's say D ones
in Europe and D 2's in the US say a map
request for a source that's in Europe
comes in these ETRS can say if there's a
European source send it one and two
where 12 is the higher priority one and
13 is the lower priority one and it's
active back up or if the source is
coming from the US then make D to be the
primary path in D 1 be the secondary
path or if it's coming from the source
and you care about this segment the
destination is in Europe versus you can
also do it based on destination as well
this is what's in the mapping database
from the ETRS point of view but when
they send a map reply back
so the ITRs will cash they can cash they
can reply back with any value of
priority and wait now this is really
hard to do today with BGP you need to
have a PhD in BGP to do this
these are simple rudimentary parameters
here where you can do multihoming quite
easily with Lisp okay so now what's
going to happen the guy's going to do
along is the s2 is going to do a longest
matchup longest match look up on 2 0 0 2
it's going to find this entry it's going
to see that priorities are equal so it's
going to do a five tuple hash on the
inner header so 1 0 0 2 2 0 0 2 protocol
number and UDP and TCP port numbers if
those if it's a TCP or UDP packet and
then it's going to select let's say 1200
2 so it goes ahead and prepends the
header the destination address is set to
1200 to the source address it's the
address
it's locator address on the PE see link
which is 11 0 0 1 then the package
basically injected into the core what
happens is B gets the packet and says
where am i routing this packet I'm
rounding this packet to a customer of
provider X not to D to a customer
provider X if I'm running my BGP best
path selection the policy now is based
on how do I route to that last hop a s
that's directly connected to the client
so the short so the policy to provide RX
will still be used but the policy to the
endpoint will not that's either a
benefit or a cost of level indirection
you be the judge to that well what
happens is the packet will then be sent
on the shortest path sure to say is have
to provide our X provider X will have a
more specific route because it's a
customer and will route it through it's
a s and
Paquette will appear on that link of
course d capsulation is simple it's just
like a GRE tunnel or IPSec tunnel is
that d1 says that it's addressed to me I
stripped the outer header and then I do
a route lookup on the inner header my
eye GP says it's one of my internal
facing links send a packet all the way
the D so this is basically a tunnel it's
not a tunnel that you either love or
hate in iOS we say interface tunnel 0
this is the sources destination these
are dynamic and capsule aiding tunnels
where there's a routing table so to
speak that's used to put on the outer
header and then this mapping between a
ID prefix and our locator set is done in
the mapping database infrastructure ok
this locator set stays pretty much
static which means if 1200 to 1500 down
or the path from s 2 goes down they're
not removed from the mapping entry
because we don't want large churn on the
mapping database so locator reach
ability is kept out of the mapping
database and we have mechanisms to do
that which I'll talk about in a couple
more slides questions on this example
the router s2 s1 and s2 prepend the
header they are the list broader x' that
put the header on and take it off the
host don't change if the host had to do
it we would have to modify the kernel to
be able to put do new list encapsulation
we can't do that
questioning does the mapping entries
have TTL as the answer is yes they of
TTL s they're defaulting to 24 hours now
we think if you implement an ITR
functionality on a mobile know that
they'll have to be much smaller but
there's also mechanism to say that now
if this guy at a d3 to a third service
provider he would add a locator that
there's a mechanism to do mapping
updates to all the cashiers and we'll
definitely talk about that as well
next question
yeah good point the question is is why
can't the source choose which locator it
uses versus having the destination it
turns out that if you have enough
locators you can set a lot of high
priority ones and that could allow the
source to decide within the high
priority ones which ones they would want
to use and the low priority ones are
there because of only all the high
priority ones go down then you switch
over but we want to be able to the list
specification says we really want to
give the ultimate control to the
receiver site but within a certain
bounds there's some flexibility for the
source site to be able to select a
locator yes yes question I'm a software
load on the ICR I don't really want to
date they won't be ATS they'll be the
site that connected a TMJ okay so the
question was is even though the protocol
specification and tell me if I
characterize her the protocol
specification says the ITRs will obey
the mapping on any implementation could
do whatever it's one and actually
disobey it
now this is true this could happens with
a lot of protocols DNS is a very prime
example how tt ELLs are ignored right
what we want to do is first and foremost
from a protocol designer's point of view
we say this is how we want it to work
and this is a well-behaved system let's
document it that way and let's have
conformance testing that the
implementations do that way then entropy
sets in and practicality sets in and
what you say is going to happen so let's
hope that we don't get there for a while
but let's see what happens no question
to you yes you hear me go ahead just
like many times less higher layer
architecture and questions are you get
more slides I definitely have more
slides is it related to data forwarding
ask the question enough
our world up I just by the way can you I
don't know if you can see me
this is ji I need mobile IP back in
1990-91 this end up and other stuff as
well so this this looks like the Eid the
the greenboxes i really care of
addresses and/or this looks like i don't
know the IP address encapsulation from
the circa 92 93 from one of the next
generation i P&amp;amp;G efforts or it looks
like 8 plus 8 if you remember that so
can i can I respond or do you have a
question yes the the quantity the I'm
trying what the question I'm trying to
ask is what's important here is not
really the packet form V the the packet
format this is encapsulation I think
what's important here and maybe I don't
know why but may you haven't put enough
emphasis on it the important thing is
how you do the lookups whether you do it
with some particular kind of a
capsulation this is not particularly
relevant this for a week here this can
be cheering familes the important thing
is how you select the the right
addresses and how you prevent some other
attacks that suddenly become become
feasible here all right I'll shut up now
right so I have many responses the first
one is take any technology and it always
repeats itself every 10 years so this
isn't this is not supposed to be
necessarily innovative we're using
techniques that are well known and safe
and being conservative this is yes an
encapsulation proposal the d1 and d2
addresses in mobile IP terms are called
in care of addresses yeah but those yeah
that's fine they are really a care of
address basically says when a mobile
node moves to a certain topological
location that
we'll have to get packets to it it has
to get it to that part of the topology
so yes it's just another name we call
them locators because it's locating
where the ID is where the device is with
the curse of the concept of locator
versus ID splayed has been around for a
t4 agreement for as long as I have been
doing networks and that's definite on
time yes you're right and nobody has
built an engineering solution based on
it not Jia was working with us he's
arguably one of the inventors of it and
we are just doing the engineering effort
to make it happen I don't think if
you're assuming that we're telling you
this as a brand new innovative thing we
are basically saying we're taking the
ideas of past and putting it into
engineering and trying to build real
protocols and to explain how the
protocols work the devil is definitely
in the details so the packet formats are
really important okay so I think that
what may be a Mason but what you didn't
emphasize in your talk which i think is
the really important part is that this
is a very concrete engineering effort
with particular goals in mind as opposed
to oh here's another networking
architecture let's set it to Singh Kham
ji right what I've read about in the
past and these are some some questions
right all right I'll shut up now
sorry you stay through if you stay
through the three hours I will answer
all your questions I promise
and if I don't I'm sure you'll tell me
I'll be here okay so in fact you should
tune in for part three because we talked
about how this mobile node is quite
different than mobile ipv4 and mobile
ipv6 and it has very interesting
properties and features that have never
been implemented before so we will talk
about that and by using locator ID
separation that's the only way you can
achieve these um these sort of features
any other questions on unicast packet
forwarding before we go to multicast
Stephan okay there's that there's
another question which is a little bit
of security related which a
we've had a very hard time convinced
wait a minute hold on you are second in
line there's somebody ahead of you in
the queue Stephen right so the question
was is does the ITRs the encapsulator
keeper flow state and how do you
maintain packet ordering so it's just
like doing a nice EMP lookup or ether
Channel the five tuple hash will always
pick the same locator all the time in
packets are always encapsulated to the
same place it's a must in the
specification so if we if you do some of
the things that were we were talking
about over here and violate that you're
going to pay for the nonce spec
compliance stuff any other questions on
unicast forwarding before we go to
something even harder okay - my other
question now oh yeah sorry I forgot you
got a slip so we've had we've had about
ten years worth of trouble convincing
ISPs to fill their source addresses from
against the customer facing ISPs of
Sabah ISPs to filter source addresses
that should not be appearing in the VIP
packets and some unis here we're sending
an authenticated packet to an EPR and
with some unauthenticated source source
e ID that is just going to go in can you
comment on that
um what you're referring to
okay the question is is what happens if
you send packets in the network with
unauthenticated sources be it a source
locator or source ID ID is that the
correct question yeah and there there is
nothing there's authentication that they
can see here unless some more is coming
later on right so
most service providers use something
called unicast RPF where they check to
see if the source address is in the
routing table and that a particular
sub-site should be able to source that
that will still happen on the locator
address and still will be used in terms
of authentication how do you know that
the who enforces that AZ the ATR or the
the I guys that come here the PE router
on provider a will make sure that
packets only come from 1000 one that
come over that link but what is the ITR
of the router S one for example is a
compromised router or is a black hat is
being Russia that's trying to standing
that the answer is you're Sol ok so we
don't change from when from when we were
yes we if we put in all those security
hooks we will not get this deployed to
quote Dave Meyer the the personally I'm
not it or whatever yes I didn't hear the
question yes I'm going to talk about
that in two slides the question was what
about packet efficiency and that's how
do you handle larger MTU size packets
we'll cover that in two slides last
question hold on a second Darrell one of
the co-authors wants to make a point and
you will not get captured unless you
come up here and speak in the microphone
okay okay Darrell says that you are PF
is specked out in the list
specifications please refer to them and
you'll get all the details you need okay
thanks but huh
Steven says go to next slide and he's
the boss and that's what we're doing
okay so what happens if there's no map
cache entry in that ITR and that
encapsulator wait till next week
that's the mapping database
infrastructure stop and it's very
interesting so let's talk about
multicast forwarding and we'll go
through this pretty quickly but what's
important to note here is if you want to
do multicast inter domain multicast or
even if you want to do multicast over
Lisp in an enterprise network if that's
your infrastructure you can't have the
multicast design goals counter what the
design goals were for unicast so you
can't put a ID comma G state in the core
because that e ID unicast State is not
in the core okay so we just have these
two different types of multicast states
where we prepend these trees together
the SE ID comma G the SE ID is the
source host so if you join to a host
that would be that G has no the group
address has no ID or location semantics
it's really an opaque value so we can
actually use G in both cases and when
the state is in the core we call it s is
the R Lok which means it's the going to
be the encapsulator and I'll show you
how that works in a second so we have
these two sites on the bottom which are
receiver sites we have receivers 1 2 &amp;amp; 3
the site out to the right is not a
receiver we want to show you that data
packets don't go there because they're
not joined to the group s is going to be
a multicast source you see it's IP
address is 1 0 0 1 out of eid space the
green boxes are pim routers at the site
and the blue ones are pim routers that
are in the core ok sorry about this but
I'm going to have to use many so what
happens is r1 will send a regular join
like it does today since it's an
external source it will make its way to
the EGR our 11 our 11 will then say I
need to do a mapping day snapping
database lookup on the Eid just like we
did when we wanted to send a unicast
packet I'm going to get a locator set
then I decide which way to propagate a
new-type enjoin called our local AG 2 s2
I could hash on the sourcing group to
decide which one to send
and the fan-out could be inside the
source the source site or it could be
the fan-out could be in the court
depending on how routing for the locator
takes you what you have to do over the
top is send an SD ID comma G unicast it
from our 11 to s 2 because you want the
tree to be set up in the source site so
you have that sort of that happen then
the same thing happens in the other site
down here on the right-hand side
oops and then you see that the other s
to our low comedy is sent hop-by-hop all
the way into s 2 you see where the merge
point is that's going to be a
replication point in the core
unfortunately the next is not working
and then what happens is that guy does
the same thing it turns he sends a se ID
comma G over the top - s - s - is
already built - treated us so it knows
that now it has two external requesters
because if one of them gets the prune
you still have to keep that branch there
and then what happens is packets get
forwarded down the first tree from s to
s - through the locator comma G tree in
the core - each of the trees down at the
bottom and that's how its work so what
you use the locator set for in the
mapping entry is to send him join
messages - we melt the way unicast works
as I send you a route you return a
unicast data packet this way but in in
multicast is I give you you give me a
route I'll give you a join you return a
multicast packet so to three-step
process okay and then the packet comes
to the edge s 2 then encapsulated by
putting its source our lok the 1100 one
on the outer header it copies the energy
to the outer G which we know there
stayed in the core for that and then the
routers in the core replicate the packet
to the sites where they need to go to
and then each of the sites will then
replicate to their internal trees
there's the left one and there's the
right one any questions on multicast
that was the quickest multicast
presentation ever gave no no the the
question was is a replication happening
in the core if you look at that red
arrow that replication is happening
right here and the reason it's happening
right there is because both of the guys
joined into the same converging core
router if if this guy over here decided
that the shortest path to s was through
s 1 then the replication would have
happened in the source site it depends
on which way unicast routing is
converging you if the two joins came in
from a different path and converged into
the site at s1 and s2 that's where the
replication happens in fact the
replication would happen right your
joint even this way in this way the
replication so not in question here yes
go ahead
yeah is they sending just to make sure
that under 10 days is this any different
from what if there were just one one
receiver at Deeksha each little cloud
and this was just ordinary pain the
question is is this different if there
was one receiver teach cloud just
running pim how it's gonna solve the
over big cloud from so one packet gets
sent into the core since it's being
encapsulated with 11001 as its outer
source address all the pim routers in
the core half state for 1100 1 comma G
because it only has unicast State for
1100 1 and therefore the pin the pin
joins created the state based on that
and so the replication happens ok on a
locator command G all right I get it
any other questions to the extent that
anyone gets multi
yes yeah that's a good point
the question was none of those core
routers know anything about Lisp period
let alone multicast versus unicast and
the answer is correct all they're doing
is they're getting joint messages in for
an s where s is not the multicast source
it's the ITR that's going to be
encapsulating
so you're absolutely right they can run
without any changes remember we set the
beginning a presentation we want no
changes to core routers or sight routers
we've been able to maintain it here by
doing this in we're encapsulating an IP
mode yes packet in another IP multicast
packet okay good observation other
questions
what do we do about MTU there's a
question about that so what happens is
we are putting additional header bytes
on and we're going to make the packet
larger so there's the specification says
that there's three ways of dealing with
this we really don't care because
there's enough MTU sized links and the
MTU the excess MTU is greater than the
or that I should say the core MTU is
always greater than the access MTU so
there's plenty of room for tunnel
headers most of the infrastructure links
are 44 70 or 9k giggy and 10 giegi are
becoming more ubiquitous and more cheap
paas has is MTU lists the only time
there's a problem is you connect two
large MTU things with a dumbbell through
100 megabit Ethernet and that's probably
not going to happen if it does happen it
might be at the edges and if that is a
problem we have two mechanisms a
stateless mechanism and a stateful the
stateless mechanism says if a packet
comes to an encapsulator and it's going
to add these bytes what's going to
violate the MTU of the outgoing link
that it will first fragment the packet
then encapsulate so the decap slater
decap sleights the fragments forwards
the fragments to the host and the host
reassembles routers don't reassemble
packets very well and no hardware today
any vendor can support that so we want
to avoid assem reassembly in the d
capsule ater in the router okay yeah the
question was when I say core I mean
service provider interior edge in what
you mean is assuming that there's a luff
MTU sized links in those areas yeah
of your examples when provider excellent
provider why agent we fear with each
other across some fabric like packs
actually smart enough to turn on jumbo
frames to set the MTU on their
interfaces so that the capsule
unfragmented yes so the the statement
that Steven made was if two service
providers are say peering over packs you
have to assume that they turn packs turn
on jumbo frames and that the routers are
configured appropriately to use those
larger MT use and the answer is yes we
are looking forward not backwards it's
going to be more cost-effective to go to
Giggy and jumbo frames and more of the
products that vendors are shipping or
defaulting to the larger MT use now will
the host send packets with our gem to
use that varies on your host
implementation and that could as far as
we can tell most hosts are sending
packets with 1500 bytes that leaves
plenty of room if they start sending
with 4470 then we can use number three
to address your problem or the large
host problem where we want to avoid
fragmentation at all cost and we use
path MTU discovery between the
encapsulator and D caps later we keep
the effect of MTU state per map cache
entry so when we get packet do big
messages to the encapsulator we
propagate it to the host and we tell the
host to lower the MTU so if there's a
path going through 100 megabit between a
source and destination that source has
to send smaller packets if it takes
another path through larger one that
source or another source can send larger
packets so that's basically a stateful
solution did I address the question
about him to you 180 other questions
what about locator liveness well you can
use the routing table when you can if
bgp is running on the encapsulator and
you know that you want to use a
particular locator and you have a route
that matches the routing table you can
assume that the destination is reachable
I mean just because a BGP route is in
the routing table doesn't mean you're
gonna get the packet to the destination
all it means that you think if you send
it to the next hop it might be able to
do the same thing
so you really don't know that the
locator is up you might know if it's not
there that it may be down but that's not
clear either
now if the BGP routes there it could be
an aggregate where the more specific
that this destination is going to match
is going to be down somewhere further
down right so you could just send and
pray and see what happens you could also
use ICMP but ICMP doesn't tell you when
a path is up only tells you in a path is
down and how do you find out when a path
is up you got to try again and if you
try again with data packets and you're
wrong you drop packets this is bad okay
another thing with ICMP is routers are
starting to default it to not sending
ICMP s there's a lot of filtering boxes
that will filter ICMP so you can't even
depend on it so the top two you can't
even depend on so we brought up we built
for algorithms and lists that happened
in either the data plane or the control
plane that is outside the mapping
database that will allow you to try some
reach ability but as you find out that
you get less scalable as you go down
but you solve more cases okay the
locator status bits are bits that are in
the encapsulation header and it allows a
set of ITRs when they encapsulate data
to say my up two other brothers are up
and they're running because I know I'm
hearing from the IGP that they're up and
running those are hints saying that the
boxes are up but if this site is trying
to talk to one of them and that's like
stalking we have no idea what the if the
path is reachable or not so this will
tell you right away when something goes
down but when you set the bit saying
it's up you don't know if the path is up
so again it's a hint it doesn't handle
all the situations if you have
bi-directional flow between two locators
then you can do this thing called echo
announcing well we can do is we can put
a nonce in the data packet and I can
request if my ETR is Stephen I could say
Stephen please echo back this nonce and
if he sends me caps lates packets back
to me he can repeat the nonce that I
sent and that could tell me that I have
a forward path to him I actually don't
know if he has a forward path back to me
because he could have taken an
asymmetric path back to me but all I
know is that he's echoing in my packets
are we seeing my my packets he's d caps
awaiting but that only works when
there's a bi-directional data between
the two loci
what if there's not bi-directional
there's bi-directional data between the
two sites but the packet goes this way
from this encapsulated app decap sir and
packets return from this encapsulator
that d capsule later in that asymmetric
case we can't use either one of these
okay so we have this thing called TCP
counts which could be used which
basically does a deep packet inspection
from the concatenate er the encapsulator
will look at a syn packet going out and
if the syn ack came back through another
router and the host then send the act to
the syn ack through me again since his
packets that are coming this way I can
count the acts and count the sins and if
they're the same or within the threshold
I know that there's bi-directional
connectivity to the site and that I
could still keep using that locator that
assumes that TCP is used that assumes
that TCP connections are going up and
down so it's not totally reliable either
and now you have per flow state um no
you do not have per flow State we just
count the total number of sins and acts
per locator per map cache I did it with
two thirty two bit counters and that's
it no flow state flow state is bad you
know that so the best solution and the
worst solution is our load probing what
we can do is we can send map request
from a I TR cap Slater to an e TR a D
cap Slater I can send a map request with
a probe bit saying just respond back to
me I can measure our TT I could find out
if it's up I can use different locators
but the problem is is I have to send on
our load probe for every single locator
of every single map cache entry that's
where the ultimate scalability problem
comes in so well so what the
implementations do right now is have
this all turned off by default and we
send in prey and say hey the Internet is
robust it usually gets packets to the
destination I'm probably going to be
able to reach the locator on the other
side and if there's some failure in the
middle we're going to trust rerouting at
BGP in the middle to get the packet
there that's a good place to start
you know modulo all this complexity now
the other thing we could do is we can
turn on a combination of these that kind
of work pretty well we can turn on our
look probing and try to suppress the
probes whenever we have an opportunity
to suppress them that allow us to scale
better so if echo not seeing is saying
it's up that means I don't have to send
probes of those guys okay if
economically not working then I'm only
using our log probing for the asymmetric
case so we're doing a lot of
experimentation see should we use two
out of the four all of them and see what
happens
comments yes that was a good observation
the observation was it's different than
regular IP routing is because the edges
are doing it where if you injected a PI
prefix into the core right where the
failure point is is you can do a reroute
and the guys just keep sending packets
into this buffered pipe called the
network
yes great observation the level of
indirection buys you something but it
cost you something as well Scott did you
have a question can you the question was
can you infer liveness from the mapping
I can tell you that I'm connected to
Sprint and AT&amp;amp;T right now but everybody
who wants to send packets to me have a
different path and we don't know unless
they try it if it's up or down so the
answer is no you can't infer it straight
from the mapping yes it's path for me
and encapsulator to you another addy
Capps later and the packets that I
encapsulate to you is your locator
that's why we call locator liveness ETR
liveness D Capps later liveness it's all
the same thing
yeah questions now what's nice about our
look probing that I really like is that
if I'm going to be probing with map
requests if you decide to add a new
locator to your mapping entry the map
reply comes back and I just get an
update so if I decide I want to send it
every minute I can get mapping updates
on minute granularity at the expense of
probing yeah how often are you going to
change
yeah so I think the comment was is yes
you can use this to update your mapping
but as you increase the number of probes
you have to send and you want it to
scale and I use your bandwidth and all
your queues you have to spread it over
time and spreading it over time means
those upping yet mapping updates won't
be as quickly as you one would hope
you're absolutely right that's one in
the same thing the question was do you
have to probe per hour loco per ETR each
ETR has a locator address and you have
to probe each one a mult if I'm an ITR
in a multi homey TR and I want to talk
to your site that has four locators for
D caps laters that I may use I have to
probe each one if you want to find the
liveness for each one right right so the
question is is when are we going to talk
about authenticating map replies so you
can't inject a mapping into the system
and redirect traffic for a legitimate
site to an illegitimate slide that'll be
next week for sure
if you want to know more about any of
those one specific details we have slide
where and we could show you some results
is this something people like to know
more about next week there's a lot of
material for Nick because the mapping
database infrastructure is important if
you don't want to wait you can look at
the list working group presentation
slides from Stockholm which was summer
last year where we gave a presentation
on locator liveness and the problems
with it and how you should not do our
load probing and then we followed it up
with a slide set on you should need to
do our load probing ok standardization
status of Lisp well we started in kind
of started in 2006
I mean arguably locator ID split was
done pretty early we're going to give
credit to Knoll Chiappa because he's the
one who really made it part of a real
architecture called nimrod which was one
of the IP ng candidates did not which
did not occur and so we've been working
with know quite a bit he's the kind of
our our conscience of this and wants to
be able to build this overlaid type
system so if we could actually have to
consult consenting sites implement
something completely new like IP v10 it
could run over a lisp infrastructure
because what runs in the core and what
runs on the site can be completely
different I'm Dave Clark said that this
is nice because it decouples the core
protocols from the site protocols so
maybe this is something where we can
move into the future and actually
introduce new routing architectures
we'll see so most of 2008 2000 2007-2008
this work was done in the routing
research group of the IRT F and that's
where some of these specifications came
out the second set of drafts are the
database mapping algorithms some that we
believe will have more of a success rate
than other ones I left one out actually
and then we built the interworking spec
the end of 2007 last year in 2008 we had
two bops a start in a restart supposedly
and then in 2009 we had three working
group the plan is
by fall of this year to have these
specifications that are listed on the on
the bottom side other than list mobile
node to be experimental RFC's and close
the working group okay
the local reach algorithms as we talked
about on the last slide we're done on
mid last year implementation and
presentation to the ITF now what's
really important is everything is done
in the open all the work has been done
in the I RTF and IETF so that proves
that it's open cisco people have worked
on it Cisco engineers have worked on it
but we have no IPR on it whatsoever our
lawyers are going to stay off our back
it's an open effort we're trying to help
the internet we're trying to scale to a
next-generation and MIT and leave a good
legacy so we've talked to other we
specifically Cisco have talked to other
vendors like Juniper Arista huawei xkl
and we've talked they're researchers who
are actually working looking on things
like lookup time packet loss different
mapping database algorithms how to enter
work should the mapping system do
caching like DNS should it not we've
talking to map many service vendors
we'll talk about this more next week but
now that we have this mapping service
we're going to have these MSPs mapping
service providers that can be that
Verisign other word the gold daddies of
the world is see Google MSN though these
are guys could actually sell mapping
services if they wish to and they could
sell it at like the DNS hosting guys
they could sell this as a monetize
service low cost high-volume sort of
business and who will actually put up
proxy encapsulator so anonymous sites
can talk to list sites will talk about
interworking next week one important
thing to note at this point is that
people will always say when you build a
new technologies like why should I be
the first one to go to it and will 50%
need to be converted before I get
benefit that's not going to happen with
Lisp if you're the very first list site
you will get multihoming benefits day
one because all the non list traffic
will go to infrastructure boxes we
believe service providers will want to
deploy because they want to attract
traffic and those proxy and caps leaders
will obey your policies and encapsulate
to your locators as you specify and you
can
active/active multihoming day 1 so
that's a really important point we hope
and of course we've talked Cisco has a
huge customer base so we've talked to
customers that may want to do this
inside an enterprise that want to do
data center use cases mobile nodes sort
of use cases we'll talk about all those
in a couple of weeks most elections
I'm sure go ahead this is a good time so
this actually does not address so to
speak the address exhaustion problem
right which i think is a feature I don't
think it's a bug I would just want to
make sure that that we're in the same
page yeah at the beginning of the
presentation I said okay so first of all
the question was is this trying to solve
the address exhaustion problem the
answer is no but you may get more
addresses based on the solutions we're
using but that's not our goal I said at
the beginning of the presentation is
that this is not keeping ipv4 alive this
is not keeping gnats alive this is not
obsoleting Nats this is not pushing you
to ipv6 there are situations where this
can make it easier for two ipv6 hosts to
talk to each other when they don't have
connectivity to each other and we will
talk about that in a use case as well
yes god yes so the question is is since
these e IDs are going to be in in ur
headers how will these infrastructure
components I'd like to look at packets
do it do their thing right that
so the question was how's that the the
verbatim question was how does
geolocation work nice with Lisp and
could you be specific on what you mean
yes right exactly all referrals will be
done on e IDs so anything that's done
it's talking about hosts or referring
things even if you want to refer to
something that's a router device or a
firewall device it's all based on e IDs
and then the underlying routing system
will map that to a locator to get the
packet to its current location so we can
actually build a GRE tunnel between me
and you me is Dino you is Scott
those are IDs and if that tunnel has to
be rehome somewhere else the underlying
lisp infrastructure will say now the
tunnels going to endpoint at Google
because that's where Scott is but now
that he's in Starbucks the tunnel will
just automatically go to a new place so
all referrals are based on e IDs because
we want to still maintain the level of
indirection okay question yeah good
question the question was is you the
original goal was to save routing table
space and therefore save memory space
and possibly CPU in router boxes and at
the expense of any more overhead per
packet and the question is is that a
justifiable cost to do it and the answer
is we you know the designs made up of
trade-offs we want to be able to put the
mapping database in an alternate
infrastructure where there is cheap
memory and more plentiful CPU and more
commodity prices
okay and we by making by moving the
problem somewhere else and adding
bandwidth and header overhead to the
salute to the solution space we think is
a good trade-off there's lots of
protocols today not only at the network
layer but the application layer that put
extra headers on and do tunneling in
this game so we're not really
introducing anything that's new or out
of whack the Lisp encapsulation you know
if you're going to encapsulate an ipv6
it's a larger header but there's eight
bytes of UDP and eight bytes of of Lisp
you can do pointer arithmetic to get you
into the inter header so if firewalls
need to filter or do any policy based on
Eid they can do that yes those devices
will have to change to do that but now
you can filter an identity and your
access list can be either based on
identity and it doesn't matter where
something has moved because the Eid will
always be fixed
okay the other question you can get one
more question go ahead you can't I don't
hearing my voice yes we you can hear you
go ahead yeah okay so in the first let's
say that these kids these stuffs getting
deployed and some large from some large
firms sign up and get the get the
listening routers connect them through
providers through sorry probe
not their own IP address space when they
provide the individual providers are
connected to wait you know to the rest
oh wait wait wait let me interrupt
because let me set the question up so
you can ask the question and then I'll
explain how this it gets all set up from
a site's point of view and then to make
it clear to everybody what happens is
your site and let's say you already have
a PI address well let's say you don't
okay that's more important let's say you
want to go get a new PI address and
you're in the in your in Amsterdam okay
what you do is you call up ripe and you
say I want to provider independent
address I never want to renumber again
that's my prerogative I'm buying from
you the registries will be happy because
they're selling address space so that
will become the Eid prefix for that site
then they'll go shopping around for
service providers they will get a single
IP address from each service provider
assign it to their PE see link on their
CP router and that will be the binding
the Eid prefix from the registry and the
locator set from all of the service
provider IP addresses and then they will
decide what the priorities are for what
policy they want to use that means that
by well let me finish let me finish
because this kind of sets a good stage
for next week then what happens is those
et hours at the site will then register
those mappings to the mapping database
system on securely and now that map
request will flow to that site they will
they will be able to get to this site
and be authoritative Lee responded to by
those etrs that's how we would envision
subscribing to the system or or
provisioning the system go ahead with
your question ok so the question is
about not using the system until a fair
fraction of the internet or at least of
a comparable consumer-facing ISPs and
large corporations star buying base why
why do you have to wait what wait wait
wait wait let me finish the question so
until this happens let's say I want to
buy into this and I get I get these
boxes and I deploy them I still have to
announce my provider independent rest
pace so the rest of the world can reach
me that is not true you have to wait
till next week to hear about
interworking if you are non list sites
to talk to you
you do not have to inject a more
specific route from the Lisp site okay
my name's Leslie thank you any other
questions at this time
it's an encapsulation protocol it seems
to be designed to solve one of the
problems that I think Lisp is going to
solve has this train already left the
station or
that's a that's a really good insightful
question
I'm putting Cisco strategy together no
no no no you you are not this okay so
the question was is there's this
architecture called overlay transport
virtualization or OTV for short yeah
it's it's it's going to be available in
the beginning of April I believe in the
nexus product line what it's trying to
do is to have a more general a more
general VPN strategy where you can do l3
or l2 VPNs
over an infrastructure and the paradigm
there is that you have these edge boxes
that actually run the eius eius protocol
at layer 2 advertising MAC addresses so
you can actually have routers peer
across this overlay infrastructure or
build l2 VPNs
without having to do MPLS at the site
you do MPLS at the core of course but
this is a many-to-many sort of
connectivity it's not a set of
point-to-point pseudo wires and the
reason it's there today is because
protocols like vMotion VMware's via
motion and hyper-v and those sorts of
things and other type of protocols
assume that there's layer 2 connectivity
that layer 2 adjacencies are important
because they send broadcast for
discovery protocols they use link-local
multicast they assume that the IP
addresses don't change now IP address
doesn't have to change if you cross
subnets and that's where list comes in
and that's where your insightfulness
came through so we do believe Lisp could
help in this scenario but there is a
problem and I'm going to explain this in
the third week on a datacenter use case
is that if a server is talking to a
server or two VMs are talking to each
other on the same subnet and they move
to a different cloud that server still
thinks it's directly connected from an
IP subnet point of view and still will
send packets to the MAC address of that
VM and if the Mac if those packets can't
be addressed to a lisp encapsulating
router there's no way for list to solve
that problem so we will show you in week
3 where Lisp is used whereas o TVs use
and where both have to be used at the
same time specifically this later case
resolving the layer two yeah I would say
that Lisp is going to make the OTV
solution more robust we're just having
vm communication among data centers if
you have clients talking to VMs that are
moving that's the case where Lisp has to
be used to complement the functionality
we write so VMware is doing this thing
called long distance V motion and they
want to move something anywhere in the
world which means across sub yeah and
unless we and we have this solution
called list VM the vm mobility solution
that will will help solve this so we'll
we'll talk about that in two weeks and
in great depth yep any other questions
student Steven please comment open flow
I will do that when the tape stops
rolling I don't know are you asking the
question about open flow relative to
this scope or well we've yeah we
definitely have looked at what they're
doing but not with respect to movement
or locator ID separation I mean there's
lots of there's lots of solutions that
can allow VMs to move they all do it a
different way we want to solve a certain
set of problems a locator ID separation
and all these other use cases just turn
out to come up and work pretty simply
because the level of indirection helps
you know it every computer science
problem can be solved at a level in the
direction so but we will if you think
it's important we should we we could
certainly take a look at how they're
doing movements so well show you what
the design goals for a very large
mapping database system is and we have
four proposals three of them that are
kind of obsoleted or documented as
probably not good
Solutions and the alt is the one will go
into detail with that will be presented
next week in part 2 right exactly
actually the cons proposal has two types
of boxes I think I presented in April of
2007 but cons have content access
routers or cars and content distribution
routers are okay there's some old people
there that are in the audience that's
good so those are basically built-in
functions in the list programming
language if the young people care to
know about that don't always bring
cycles on that one then we will also
show that the mapping database system is
actually modular you could actually pull
out alt it maybe put in a DHT or some
your favorite mapping system and since
the site's access the mapping database
system through map resolvers and map
servers we have this separation where we
can plug take one out and put it in and
we don't have to change the sites just
have to change the map servers and map
resolvers to interface with the new
system so that's that will be
interesting so we can see over time as
people get experience with this mapping
database if this is the right trade-offs
that we made or is the economic models
or business models changing where we
have to use a different type of
algorithm then we will definitely talk
about interworking when we introduce the
concept of a proxy ITRs and proxy ETRS
and that allows non list sites to talk
to list sites and will address ji
question about how do you do that
without injecting a route from the site
and then security and tools that we have
we have we believe we have just enough
security and not too much security to
shoot this to shoot ourselves in the
head and we like you to judge that when
we present it next week part 3 we're
going to put it all together we'll
demonstrate if we can we'll show you the
live network we can do some pings and
some trace routes and show you some
mapping databases if you'd like we we
have a dual stack mapping database
infrastructure that runs both ipv4 and
ipv6 so you can run ipv6 a ids and ipv4
a IDs over either locator and we're
running it across some
ten countries and we are modeling it as
the top-level are the different
registries and then they map out to
mapping service providers and then
there's proxy boxes that are at the
service providers drawing data and
sending them to little sites we're on
our third generation of the list network
design we started building it in the
summer of 2007 and we're now we not we
just cranked the third generation we're
getting a lot of good support from Asia
and we see that growing out in time well
we can show the content and applications
that run on on this will validate and
test economic and service models that's
the plan for the network we're learning
so much from the network we have real
implementations running on it we have
basically three implementations running
on it we have a nx-os Cisco
implementation an iOS Cisco
implementation and a public domain
implementation we will talk about lists
mobile node where Dave and and some
engineers are working on a list mobile
node implementation on Android thanks to
Steven for giving us hardware and we
will talk about that as part of the use
cases as well that's the third bullet
there we have four data center use cases
that we'll talk about and VM mobility is
the hot topic today but cloud sort of
applications are also interesting as
well and the multihoming is what you
pretty much heard about but we could
talk more about pros and cons of that
here's the internet draft material wws
fournette is the external website that
is turns out to be a lisp a lisp site a
University of Oregon I'm Dave
administers it and you can connect to it
now and it shows that you at Google or
anomalous site you can connect to it and
open up a TCP connection you will see
that the DNS name is a 153 dot 16/16
prefix that is a donated prefix that we
use on this test network as the Eid
prefix we went to Ayana and we have 26
10.0 as the slash 32 we got from I Anna
to use it as the ipv6 a ID prefix so we
can do either one this list for dot
cisco comm is actually an HTTP server at
Cisco
that has to is ours in front of it
running the iOS implementation and we're
going to put content up on that to show
you that interworking and lists of lists
of works as well and I think that's it
for today questions comments Tomatoes I
haven't seen Edie crab in 15 years and
you look just as young as you always
have
man can I round this on my little homely
nooks residential gateway that I put
together no not the one thing I can buy
from Linksys but the one that I put
together myself it what was the question
can you run Lisp on it but the answer
the answer is oh my I have a a little
residential gateway that I built out of
an old computer instead of buying one
from lynxes because I want to control
what runs on it can I run a lisp and
build on it it's rather else yeah you'll
have to talk to thee so there's an
effort called open list that has done
work on FreeBSD Dave's working on a
Linux implementation that will be part
of mobile node the mobile node effort
and the links this effort as well but I
think there's some information on wws
for net Dave guys yeah
so dave says they'll be kind of a host
type implementation of Lisp on Linux and
it could be available it will be
available in the public domain to put on
a residential gateway type box and
presumably patches are welcome yeah I
presume so yeah yeah send over your
patches okay thanks a lot and see you
next week</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>