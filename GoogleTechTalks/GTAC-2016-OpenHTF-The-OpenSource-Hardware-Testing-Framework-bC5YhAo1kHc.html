<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GTAC 2016: OpenHTF - The Open-Source Hardware Testing Framework | Coder Coacher - Coaching Coders</title><meta content="GTAC 2016: OpenHTF - The Open-Source Hardware Testing Framework - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>GTAC 2016: OpenHTF - The Open-Source Hardware Testing Framework</b></h2><h5 class="post__date">2016-12-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bC5YhAo1kHc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so we
oh my notes we have Joe and John will be
talking today about open HTF yes so I
will hand it over and let them take it
away okay hi guys I'm Joe my colleague
John is on the way hopefully he'll his
parts don't really start till the second
slide or so so maybe we'll make it I'm
one of the current maintainer zuv open
HTF John is one of the authors of the
original internal testing framework that
open HTF sort of evolved from open HTF
is one of the libraries we use at Google
to facilitate hardware testing in
addition to talking about open HTF I
want to touch a little bit on general
approaches to hardware testing at Google
how that kind of shaped open HTF and
also one I mentioned as the name
suggests open HTF is open source
software the URL is up there github comm
slash Google sash open HTF so you can go
check it out if you do that we have at
the top level of our repo we have an
examples directory I recommend starting
there in particular there is a script in
there called hello world PI check that
out there's a lot of inline
documentation that shows you what's
going on that's kind of the basic
example of a test script that you would
create with open HTF okay so the needs
motivating open HTF are sound pretty
similar to the needs that would motivate
any other framework that you might use
for hardware testing so you want to
exercise a piece of hardware you have
whether it's like a phone or a
head-mounted display or some other
device consumer electronics or part of
some bigger assembly like a server or
piece of networking gear you want to
exercise that hardware you want to take
some measurements you want to record
those measurements into a log or a
record as you go
and then at the end you want to do
something useful with that record like
save it to a file on disk upload it to a
server somewhere something like that and
the whole point of having using a
testing framework to do this is to make
life easier for the folks authoring
tests so in our case that's mostly
Hardware test engineers but I think
that's I want to dig into that a little
bit because I think it's subtle but
important a lot of the stuff a lot of
the pre-existing tools at Google were
kind of oriented towards a more software
engineering heavy audience even though
they were ostensibly catering to
Hardware testing so but we wanted
explicitly to make something that we
could use to partner with contract
manufacturers vendors hardware engineers
and hardware test engineers and that
would give these folks all an easy
interface to focus on the parts they
care about which is test logic okay so
consider that for a long time Google had
been could build itself as a software
company and kind of still does in many
ways - one notable exception being the
platform's team at Google which is the
team that does designs the like data
center infrastructure servers and
networking gear
but now of course things have changed we
do a lot more hardware there's a couple
examples up there we have a glass
daydream
we have self-driving cars all sorts of
different consumer hardware with the
newly formed consumer hardware group and
so with all these new types of hardware
testing we found that all these
different teams started forming their
own tools and they were all catering to
different purposes and we really wanted
something that would be general enough
to capture most of the use cases so open
HTF came out of a team that included
both hardware engineers hardware test
engineers and software engineers all
working closely together it was written
and rewritten with some non software
engineers in mind as the primary
consumers specifically we wanted to make
something that would cater to Hardware
test engineers electrical engineers
contract manufacturers and vendors and
then over the course of a few iterations
it became more lightweight more focused
and platform agnostic welcome sorry run
it a little late I missed the
introduction I'm John Hawley
I was a member of the team that wrote
the initial version of open HTF before
it was open source and all that so I
still sort of Co maintain mojo and run
late to meetings and yeah so I can give
a little bit more context of some of the
sort of original motivation behind some
of the decisions that were made
I'll let Joe continue cool so yeah main
takeaway here is proliferation of
hardware projects at Google open HTF
came specifically out of the glass team
and it came out of a team that was that
had software engineers and hardware test
engineers working together which allowed
us to create
something that looks a little bit
different than some of the other test
frameworks available and notably the the
need at the time was actually driven
primarily by manufacturing we were doing
manufacturing locally in the States and
we're trying to be pretty scrappy about
in doing a lot of things ourselves and
we there weren't really any internal
test frameworks that ported well to the
manufacturing floor okay so the solution
we came up with is a Python library
we chose Python because most of our
hardware test engineers write Python
scripts already to do things like kick
off tests analyze data etc and we made
it a library because we wanted it to be
a straightforward import just like any
of the other tools that were are
commonly already used in hardware
testing like numpy pandas matplotlib and
things that hardware testing folks are
already using in their day to day work
and like most python libraries it's PIP
installable so if you have an internet
connection you can just pip install open
HTF and start using it also as a library
it makes it easy to integrate with other
frameworks in terms of deployment
scheduling and things like that
we don't really provide solutions for
those things out of the box we're
focused just on the hardware test
authoring interface so with your test
script being just a straight Python
script that imports our framework you
can do all sorts of things with it
embedded and other frameworks use it in
any scheduling system you want deploy it
any way you wanted to play it yeah it's
a little bit more about that the
decision originally obviously if we're
just running our own manufacturing floor
we did have you know a full execution
environment it was the only thread that
was running weak we controlled
everything about what was going on
including deployment to the Machine
scheduling all this kind of stuff we can
talk about that a little more later but
when we decided to open source the the
code we decided to make it more of a
library because that integrates a lot
better with what other people are doing
right we don't really want to have to
take over and say ok this is you know
you have to sub process call to invoke
this or something like that right so
this is actually a lot of work in fact
Joe did a lot of the work on sort of
tearing out some of the specific process
specific stuff and making it actually
work as a library so hopefully we're
hoping that this actually makes it a lot
easier for other people to make use of
it okay so I kind of mentioned our oh
yeah that's right so I already talked
about this a little bit the
manufacturing floor sort of the original
use case some of the constraints there
that were really driving us or that we
had operators using the station's not
you know test engineers which is pretty
common internally usually have like test
engineers overseeing things but we did
have test engineers writing tests so not
software engineers so we don't wanna go
to complex it was kind of a sweet spot
that we really needed to hit they're in
an automated lab we typically have test
engineers writing the tests and running
them so you don't usually actually build
a more comfortable with command-line
interfaces and things like that so I
forgot to mention manufacturing floor to
that end we actually have a an HTML
based graphical friend so you don't have
to use fully command-line tests the
automated lab typically you'll have more
of a command-line interface you'll have
jobs getting kicked off automatically by
something and you'll be outputting to
some sort of data store or something
like that that varies sort of I use
benchtop is a little bit more you have
engineers writing tests right and that's
when the code gets really bad but yeah
that's usually something you wouldn't
have to type control you typically have
a version control over your tests even
is just like I built some hardware I
need to test it or something now the
last one we don't really expect open HTF
to be have a huge value add you could
just as easily write a little python
script that you know talks over at eg
blind does your thing but if you know
you get used to using it or something
you could design an output module that
outputs in the format that you like or
something like that and then get the you
know some code reusability there so the
main abstractions of Open HTF the top
level thing that we care about is a test
we have a class called test open HTF
test the what you do is you instantiate
a test object and then you execute it by
calling its execute method
those tests are broken down into phases
which are kind of similar to test cases
phases can be as simple as just a Python
function they're kind of the atomic unit
of testing and then within phases you've
set measurements which are exactly what
they sound like individual pieces of
data collected during the course of the
test sometimes you want to save an
artifact like a JPEG or a WAV file or
something that was generated during the
test and we have an abstraction called
attachments to do that finally we have
something called plugs which are the
interfaces to hardware and we'll talk in
a little bit more detail about plugs in
a little bit and then output callbacks
let you do something useful with the
test results once the test run is
complete like save it to disk or upload
to a server so notably here the pieces
that are up to the test author to
implement are typically just the phases
normally you would have also some test
engineers that are a little more
comfortable with Python writing things
like output callbacks if you're
outputting to some local data store or
you could even have you know upload via
HTTP HTTP whatever and then plugs or
interfaces to various hardware we have a
little bit a small set of base plugs
we'll talk a little bit more about them
later but typically you end up having an
engineer also have to write you know a
Python interface to whatever hardware it
is you're talking to a lot of things
come with Python interfaces already
though
okay so while with text I know so this
is kind of a distilled example of an
open HTF test script so aside from the
fact the fact that widget plugs is a
fake module that I made up for this this
test would actually run this is pretty
much all you need in order to create and
run an open HTF test main stuff here to
look at is you import a bunch of stuff
at the top you define some phases phases
or functions the first one is a very
simple one the second one is a little
more complicated you can decorate those
phases to declare what their inputs and
outputs will be and then finally at the
very last line of the text you'd call
test I execute to run the test and that
called the test to execute blocks until
the test is complete and the output
module is run yeah so the general
approach here is we use decorators a lot
in over hgf it kind of makes it a little
bit more declarative about what what
exactly you're gonna be measuring in any
given phase the original motivation for
this was we liked having and we'll talk
a little more about config later but we
actually have a key value mapping and a
config file it's a sort of a yamo file
and let's it lets you have some
declarative stuff but we found that
putting a lot of declarative things
they're actually decouples it from the
code a lot it makes it really hard to
sort of you know visually track what's
what's getting measured where and
whether than what's going on so over the
course of one of the iterations we move
that to decorators and now I actually
really like how this turned out we have
you know pretty clear inputs and outputs
although here I guess they're in the
other order their outputs then inputs
but they can go in any order there's
just decorators and they're right next
to the phase is doing it so it's still
sort of on the test author to write you
know just split their tests up into
phases that sort of makes sense you
could obviously just put all your
outputs and all your inputs on one phase
and have a thousand line Python file
I've seen plenty of those in hardware
testing but the hope is that this sort
of enables you to break it up a little
bit more sensibly and make it so that
you know the next guy who comes and
reads your tests can say okay I
understand exactly what these chunks are
so plugs this is actually one area where
we need some help from you guys the
testing community at large
so plugs are what open HTF uses to
interface with hardware we called them
plugs because plugins was we felt was
too indicative of pure software
extensions and we liked how the term
plugs called to mind physical hardware
our desire is to have a large collection
of these plugs available to interact
with like tons of different
off-the-shelf test equipment so anything
from power supplies to oh scopes to
logic analyzers to sensors whatever you
might use in a test fixture when you're
testing a piece of hardware right now
our collection is pretty thin we have
some Android related stuff we have an
ADB plug and we have some generic USB
stuff in there but mainly we've been
focused on writing the framework itself
and also a lot of the plugs we use
internally are wrapping proprietary
internal hardware or otherwise not
things that we can share but we do want
to increase the collection of plugs that
we have to share so calling on you guys
to make contributions to our github repo
and when you write plugs to wrap your
test equipment please consider
contributing them back to us yes so this
is has evolved a lot actually over the
course of the this is probably the
single thing that's changed the most
number of times in the the many
iterations of the project I kind of like
the the plugged thing that we've settled
on I think it's pretty good we're sort
of centering it around building up
building from the bottom up right so we
have plugs that support you know USB
serial some low-level interfaces like
that more complex fixtures that may have
a few serial ports we have a couple
one-off instances of those it's we're
still working out sort of exactly what
the best way to use plugs together and
how they play knives like that but we
are slowly building up a library of
useful plugs and also I mean it's a
pretty small
rapper basically you have to inherit
from base plug for internal sanity
checking purposes but a lot of hardware
I'll actually have a Python library
ready to talk to them so it's this ends
up typically for being a pretty thin
layer this is one more thing we want to
show you before we open it up for
questions and that's the web GUI so
knowing that we were going to deploy
this to things like places like a
manufacturing floor we're gonna have to
have operators interacting with it that
don't necessarily aren't necessarily
familiar with the command line interface
or the test script itself we wanted to
provide it an off-the-shelf user
oriented experience so when you run
these tests in a separate terminal from
where your tests are running you can
invoke this web GUI as a runnable module
with Python - M that starts up a web
server that will automatically discover
any open HTF test that's running on
local machines on your local network and
will give you a visual representation of
them with color coded test phases and
measurements and it updates in real time
so you can follow the test as it goes
along and this one I have a test with a
ID of foo bar Baz and then there's a
couple of phases and I've expanded the
hello world phase so you can see the
measurements inside the face yeah so
kudos to Joe on this actually the
internal version had a sort of google
internal front-end and all that and was
not portable at all so he actually
completely rewrote this the the
front-end aspect of the project to
open-source it it does do some some
really neat stuff around like discovery
is just multicast based discovery for a
local network these are things that
actually come in real handy on a
manufacturing floor when you've got a
lot of testers out there and manually
Manning you're managing a config file of
what all their IP addresses are gets to
be a lot of overhead actually so yeah
this is a pretty awesome awesome thing
this is still sort of evolving a little
bit we make minor tweaks to it to it all
the time and get a lot of internal
requests they should probably start
forwarding people more to the external
mailing list so there's more visibility
but yeah this is still growing a lot so
there's definitely feature requests are
welcome and encouraged
around this yeah yeah so the the test
authoring API like that wall of text
slide we showed is pretty is all pretty
solid and shouldn't change too much the
web GUI is still being tweaked a little
bit and we want to add more plugs and
we're still figuring out some of the
nuances around plugs to the main test
authoring API should be pretty stable I
hope so it's changed I think like four
times I think we got the good version
this time in about as many years yeah
okay so that's kind of we had prepped so
let's open up the floor for questions
yes thank you
Joe and John and to be fair by Google
and California Standards John was not
actually late right I'm early for the
next meeting can this be used to test
mobile devices battery consumption
during an application over a period you
even talk about monitors maybe that
sounds like a good application ah yeah
sure so we have a little bit of an
addition to measurements that we call
monitors and we found it something that
comes up a lot actually where you just
sort of periodically want to want to
check something and and store you know
those values in some sort of list or
something and so there is a mechanism
yes monitors that will allow you to
basically say you tell the framework how
to take the measurement and then it will
just periodically it do that so you just
want you write the code to talk to the
device and grab the battery level then
yeah it's pretty easy after that yeah
and it keeps running through the
entirety of the test right not as
monitors are currently just the phase
we're actually talking about making a
mechanism for doing so over the course
of a test yeah okay my question is have
you had any exposure to a National
Instruments LabVIEW product have you
seen how they do it and was that part of
the evolution to where you got
yeah LabVIEW I have unfortunately been
personally tasked with porting a handful
of drivers I guess you might call them
for LabVIEW over to the open HTF yeah
LabVIEW is is an interesting
way of sort of making hardware/software
play nice right it's people who don't
have a lot of software experience right
tests really is sort of the target there
I found that it starts to blow up real
fast and you get two big tests though
you get the lines everywhere and lots of
stuff to follow so there's a place for
each of them right I think they can
definitely coexist LabVIEW is great for
like spinning up quick little little
things unfortunately we don't really
have any sort of way to automatically
use LabVIEW drivers which would be
awesome there's a lot of there's a lot
of national women's test equipment out
there yeah but we are working on it yeah
we kind of wanted to be agnostic as to
which test equipment you were able to
use - so didn't want to like bias you
towards national instrument stuff or
whatever or when I say you what I really
mean is our audience of hardware test
engineers at Google who use these tools
wanted to let them go to whatever
vendors they want to get whatever test
equipment they want really there's
nothing precluding you from running an
open HTF in tests with in LabVIEW
actually you could write a block that
would run an open ATF test right which
is sort of a neat part of about removing
the execution framework from opening
Schieffelin to do stuff like that
good are there any plans to support
gaming consoles ps4 Xbox one etc that's
an interesting one I actually don't know
what that would involve I'm sure
somebody out there got really bored and
wrote a python interpreter to run on
these things so you you've probably
cared yeah the other approach would
actually be to run the actual Python
test off device which typically is more
what you see for mobile things you want
to run the test off the device because
device dies you don't get any logs and
then you just really need a way to talk
to it which I'm personally don't know
much about the hardware testing of these
platforms but I would assume there's you
know a TTY header inside or something
like that for testing purposes yeah so I
guess there's kind of two questions
inside that one was can we execute open
HTF tests on those platforms and the
other is can we use open H do you have
to test those kind of different answers
but someone wants to write plugs to wrap
those for testing those devices that
would be awesome
I mean I'd like to commend you on your
use of different interfaces for
different personas different end users
for the tool I wondered how much you've
done in the way of usability or user
experience design in designing those
interfaces what process you'd gone
through for that yeah so internally we
did have a UX designer sort of consult
with us he didn't necessarily design the
whole front end per se it was kind of
borrowing some of his cycles so we
haven't had dedicated UX resources on it
but we did have we have had input from
the 1ux guy who was helping out and we
do actually have a couple teams actually
using the web GUI right I think you're
completely yeah so we do have a fair
number of users out there that have
given feedback so this is was I think
the second third iteration of the the
web GUI yeah so we have gone through a
couple iterations and headed some rounds
of like user feedback and
like that and some some pretty big
features history actually on there is it
was a lot of work to do because we
weren't internally tracking previous
runs of tests but it turns out for the
web GUI experience to really work right
you kind of need to be able to see the
last couple that ran so we actually put
a lot of effort into adding that in so
we've gone through a couple iterations
of sort of user feedback but we're
definitely open to more feedback to so
if you have like that particular point
is evolving still a lot yeah it's I mean
submit pull requests to us or just even
file issues with your suggestions and
we'll definitely take a look good can
you give a concrete example where your
framework was used and how it improved
over earlier versions if any this one
I'm happy to say we actually don't have
enough time to go through all the
examples of this originally on glass we
had our contract manufacturer writing
manufacturing tests and this was was
very very early on and they had many
hundreds of lines of script files of
their proprietary internal language that
for some reason they made up because
there aren't enough languages out there
so I was at that was actually the
formation of the team that created the
original framework was I was asked as a
software engineer to come in and help
out and I looked at it and I was like oh
my god what's going on so I was actually
given a couple people to work with and
we came up with a framework and had I
guess the most quantifiable improvement
there is turnaround time on fixes it
used to take them at least two and this
is keep in mind local take them at least
two weeks to fix any issue no matter how
small
with our by implementing the ourselves
and doing it in Python we could we had
turnaround times of roughly less than 24
hours on issues it was a pretty really
big improvement trying to think I'm sure
there's plenty of other yeah I think the
self-driving cars is another another
good example of where they had a bunch
of different disparate like internal
tools and cobbled together scripts and
stuff maybe some LabVIEW thrown in the
mix to even and they've started moving
stuff and standardizing on
open HTF so I think the main benefit
they're getting from that is having the
consistent output format for everything
so every test outputs a record that's in
a consistent format you can upload it to
the same data system yeah the history
that the two teams actually used to live
really close together in X class and
show fairness so they saw what we're
doing we're like hey let's do that and
we're actually getting a lot of value
add from it so much so that they
actually grabbed her and the guys from
the the glass team who used to work on
open HTF or the internal version of open
HTF and he's now over there you know
helping them out so it's it is spreading
a lot is with internally within Google
there are actually quite a few teams
using it all right and I think we have
time for one more how does the framework
communicate with the device what are the
requirements of the API that the
framework drives yeah so plugs are very
open-ended in that sense so most of the
plugs that we use internally tend to be
wrapping like a thin wrapper around some
third party or vendor code that either
comes with the device or is some
third-party library that already exists
within Python for doing the hardware
communications and then the plug is the
layer of abstraction you put around that
interface to just pull out the
functionality you want and make it easy
for for for test flow to look clean and
yeah we spent a lot of time especially
in previous versions actually trying to
get this to be a nice clean interface
and be you know uniform across all
different types of hardware that you
want to talk to it turns out the
hardware world it's an absolute mess
when it comes to interfacing with it and
how you talk to things if you're writing
a low-level board level test you've got
I squared C you probably want to talk
you know serial I actually ported a vxi
11 driver over I don't know how many of
you've ever ever seen or heard of that
there are a lot of things out there so
the idea is by having just a base class
that you have to subclass you key kind
of leaves a pretty open-ended that's
basically only constraint so I guess the
second half here is where the
requirements of the API the
framework drives there are no real
requirements except that you subclass
that base class and that's mostly for
sanity checking purposes so you don't
accidentally do crazy things
otherwise it's if you can read it in
Python you can you can make it work and
that may even actually mean writing a a
Python extension in C which I have also
had to do to get because it vendor had a
seed library but not a Python libraries
so you can shell out two binaries yeah
there you can do some pretty ugly things
I don't really want to admit to having
done some of them but yeah you kind of
do what you need to do great well yeah
thank you John John all right thanks
guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>