<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ZuriHac 2015 - Distributed Programming in Haskell | Coder Coacher - Coaching Coders</title><meta content="ZuriHac 2015 - Distributed Programming in Haskell - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>ZuriHac 2015 - Distributed Programming in Haskell</b></h2><h5 class="post__date">2015-07-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qlnU73a3Cw0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">the title of my talk was distributors
programming in Haskell
that's a blog topic to say the least and
so actually during this time I'm going
to talk about distributor programming in
general but I'm going to focus on one
particular use case one particular sub
part of a distribution in the console
and before I do that I so the plan here
is that we're good you know I'm going to
make some general points first and then
I'm going to talk about a good framework
that's been existing for a while in NASA
land that we've used with good success
in several industrial applications and
you know let's say giving you a little
bit of planer considering this framework
I'm going to with any luck I will be
able to do the cleaning and you know
he'll be just a really very simple
example close to hello world for just
gaming but it'd be really funny if you
guys could actually try what I'm trying
and participate in what I'm trying it
but never block rates while I'm doing
that so you know but you know by the
time I get to that point you guys
should've not Kentucky you should have
planned Ascalon your systems so I'll
show you the instructions to make that
happen
so your computers are all going to get
warm and start making noise while I'm
doing the rested its presentation so I
have an example oops actually have to do
this
cool that um all right so what are we
talking about really we were saying just
a great program well we're talking about
two things and the first thing is that
so when you build a system you can no
longer really afford to have had system
just running on a single note they might
need for more resources than part of it
and are available on us and the other or
you know might need more storage than
can be directly connected system will
notice all the other views the other
thing that people understand when they
say industry programming is building in
a number of services being that a
seriousness comes out of a number of
services that are each very
self-contained and loosely coupled as to
each other and it's just that the system
of the building as a whole depends on
all of these services together to work
in order to provide some say um and so
but what I'm talking about today is more
the first week space where where we just
don't have enough compute resources in
some blood and we're starting from from
some node in a cluster we'll want to
branch out our computations to arrange
the full of other nodes in the cluster
to to do their computations so I really
you know going into a little bit more
detail about what I said when we're
talking about building say a number of
services do you want those services to
be loosely coupled you know you're
you're basically assemble than your
service oriented orientation and you
know what we do is that you have a
diversity
I appreciate services and you have a
closed set of words or actions or things
that you can do that this API allows you
to do and the reason you do that is
because you don't really trust the
outside world you don't even trust
necessarily need other services if I can
say the system and you know you juice
HTTP request responses for as you know
the basic mechanism for communication
and because these services are loosely
coupled you're often going to either not
specify any scheme at birth
try to be a very least extensible and
permissive and what you know in the
inputs that you accept and so in order
to support that you were basically using
JSON as an interchange format or
excellent so the important point is that
there you're in a you're building a sets
of things that are loosely coupled there
are an anti-static force and sometimes
you can afford to do better than just
having a couple sometimes you know you
have an applicant you want to build an
application the monolithic application
that you just want to distribute and you
want to build it in very much the same
way that you would build an application
your runs in just one computer and even
if that application is running them on
just one computer yeah that application
obviously not in business building
trivial applications hey so you're going
to have a number of modules number of
components a number of things that are
there that you want you have to do you
might have say several multiple threads
of communication you're right this exact
same idea that you want and the
distributors saying and one crucial
thing that we want to have
to a distribution site is that we don't
want to shoehorn the communication
saying that would happen between spreads
and in a single note saying we don't
want to shrew one that through some
fixed API that tells you that tells you
you know once and for all all of the
different ways in which you can
communicate between that's alright
because then if you do that you lose
modularity so what I'm going to focus on
in this one is the second is the use
case where you can afford to build three
were you building a distributed
application we have tight coupling
between the code that is running on all
of the nodes new system and using
message passing instead of HTTP request
responses to to communicate and you can
even say well you know what I'm going to
have a shared understanding of the data
types that I'm using to communicate you
know he's alright now the other thing
that we want to sort of white but then
the end of the day why use Haskell for
this for the first three states well I I
would argue that Haskell was really good
actually we've a strong library support
you for the second news case we by now
also have pretty good library support in
the form of cloud Haskell and if you had
their libraries anything easier and
quality bindings that we're doing just
basic message console compared to other
languages some even languages that tell
themselves as languages that you really
do want to be using if you want to be
doing anything distributed well Haskell
has the advantage of a very mature
compiler
state of the art compiler that's been
built over a period of
five years now at least it's a you know
a very good performance compiler so you
can get distributed programming without
having to give up on the promise of
native scheme for all the code that you
write and you know for a lot of
applications is to make you increase
your um the of course we are notoriously
difficult to build if you thought that
building a system I'm sorry an app that
runs on just one note it's difficult
we'll try doing that on multiple nodes
at once and trying to do that in a way
that's robust in the face of all that
can happen when you're doing that and so
anything that can help you and get a
better view of SMS any particular types
and ensure that your your processes are
sending messages to other processes of
the processes expect is great videos
again Haskell was a high promise here or
other languages will basically say we
can't guarantee you much and of course I
guess the most the strongest point for
us was the breadth of composition
mechanisms that we have I know in the
form of stream streaming libraries
arrows all basically all of you the
abstractions doesn't come up with over
the years to come composedly stitched
together systems that systems I think
you so for example if you look at
MapReduce which is you know the
prototypical example of a data parallel
framework that that people use to run
computations on multiple machines just
as a reminder with MapReduce you know
the idea is that you have
the basic functions it to map a pair of
a key and a value to two set of keys and
values and then you have a reduction
operation and the the reality is that I
mean this is a very simple framework and
the reality is that it can practice if
you want to get go you do anything
beyond just work count which is hello
world Map Reduce you're going to end up
having to implement multiple obsess and
line up those steps in front of a very
deep pipeline and you know that state of
people used to do is to essentially just
have a so for each of the maps and
reduce their corresponds a class in Java
or in C++ and so if you have you know 21
steps in your pipeline then you know
you're talking about swimming classes
which is it a lot of water a place so
ideally we'd like to have we'd like to
do the same thing but with much less
just to show you an idea of just how
much boilerplate this is this is a bit
hello world MapReduce and syphilis plus
and if you want to do this in spark
where you know they try to say well you
know we're gonna try to reduce by a
factor five in intent
they might upload they have to write if
you want to do something using MapReduce
framework if you want to do this in Java
it's shorter but you'll notice that
you're essentially there's so lot
acquittal plate and what this where the
plate is doing is essentially trying to
emulate response functions it's
important and you know using generics
have a very verbose way of expressing
polymorphism look at this you should be
able to recognize the structure that's
going on here and say well I mean I can
I can do these X and things
it's just like my lord of Hereford fewer
that seems absolutely okay so one of the
as I said in the beginning where the
frameworks that your basic you gives you
the nuts and bolts to build this kind of
system from for example a data parallel
model for communion with large data sets
this is possible and so what's the idea
behind this framework well when you
first install the system and you know
you have so you have so many pianists
that they're available to communicate
and these these a peak essentially we at
least have is BSD sockets but this is
just a stream oriented API and I mean
Christian with a limited Datagram a link
to the API but what you really want the
first thing that you really want is just
basic ability to say I want to send a
message to someone no matter how large
and I don't care what that message means
doesn't necessarily have to mean they
don't necessarily intend structure to
that message but I want to be able to
send others
okay and this is the first thing that
contacts with music it's an
implementation of basically message
customizer and you know for performance
will say that messages are basically
just of a bunch of segments so that you
can build these some these messages
besides cloud Haskell is built on top of
a library called network transport and
it presents a possibility that roundup
approach to give you a better feel of
what it's doing under the hood because
of the way they imagined so Network
transport is that the underlying labor
the library beneath I'm a school that
does all of this that influence that the
message counseling in it
and
a bit more essentially you can think of
an inch for transport as a general
purpose network to migrate that you want
to be using even in other contexts not
just possible whenever you think you're
in a model of many process communication
so in machines of the future in fact
today we're already in a many port where
you have dozens to hundreds of course
per system and you you know in order to
keep these port busy they'll typically
be having hundreds thousands of
processes now imagine that you have
hundreds thousands of machines each with
that many cores may need to have that
many processes and the big you know if
the old-line communicates less then
you're talking about a lot of
connections between machines so one
thing that you want to do is because
these processes want to communicate
they'll for simplicity it's really nice
to be able to say for future processes
to be able to communicate does have
ordering guarantees over the messages
that they send the to mention and of
course getting order during guarantees
implies that you have some kind of
connection it's some kind of session
Kenichi processes and but if each
process opens its own connection to each
other process like each other then we're
talking about a gigantic number of
connections and a gigantic number of
send buffers receipt buffers all of that
you could be eating up all of your
memory in your note just with some MC
motors so what Network transport gives
you is the ability to pretend that
you're opening an individual connection
between two processes so you're
absolutely in the states associated with
you know making
order communication between these two
processes but under the hood it's going
to be multiplexing all of these
connections between your processes into
one single transport level of connection
I transport auto connection Amy for
example in the case of TCP if you have
100 processes on one node and elaborate
processes and another node then all of
the processes will be communicating with
all other processes on the other node
using one TCP connection all right so in
network transported the bait you know if
you care the basic abstractions that you
have you have so never transport is
generic in the notion of transport we
have many several transports out there
right I now we have a TCP transport we
have the 0q base transport that gives
you the Nikesh encryption there's
various proprietary ones that are out
there that then developed by various
people and so you can create an endpoint
and give it an endpoint you can ask for
this address and then you can say well
I'm going to connect to that to the
point and once I'm connected to it then
you know I want to receive messages and
the sender recent messages and
everything that's why the signature for
it represent whenever I call connects
like again this multiplexing will be
happening and so I can safely call
connect as many times of the lake
even if I'm always calling connect to
the same endpoints I won't be creating a
new transport level connection thank you
ok so how is that that the address
function gives as well that's and we
don't have to give the address with
James me so why is it like that that we
don't have to specify the address but
the endpoint specifies the rest to me so
when I want to conduct to someone that
shouldn't I be able to say who to
connect to
and point you become contains the
address but that that is in which
function to a specified address yes but
the only way to get a 9-point address is
to call that structure right that's
right so there are actually multiple
ways of getting the endpoint address the
I mean the endpoint address is its
transfer specific I mean in practice
you'll you know you know the fan you
know that you're communicating over TCP
so you can either constructs that and
address or B or B given that one
absolutely these functions right
some other function which you don't see
I mean xx I mean obviously this is not
the full API this is a tiny fraction of
it okay and if you know it's just to say
that you you have this endpoints and the
endpoint captures encapsulate to the
states and then if you want to identify
that endpoints then you use the endpoint
address and that's what you think to
connect thanks okay so now that we have
a way of saying well we have this notion
of connection between processes and
these connections are lightweight now we
can start talking about what are the
processes and how we communicate between
the processes so a process is really
just on the I Oman it with some extra
structure and you know this extra
structure is what's going to allow me to
identify processes you can remote
processes and to send messages directly
to those remote processes ok so you can
think of the i/o is right you can think
of the process mana as exact as moral
equal to the i/o mana and as processes
as just friends and in the i/o mind you
can ask for the way you can fork a new
friend
and when you for candy Fred you get back
to Freddie it's exactly the same thing
and the process one it you can fork a
new process and when you fork the new
process you you you get a process a
mouth which you can use to talk to that
process so why aren't we just for using
Fred's well as resurrect really local
motion whereas the processes are
generalization because they give Fred's
to local or remote so far so good good
so yeah you know once I have people to
talk to
I mean they're so alone in life and I
can start sending information to these
guys and of course so I have this
generic send operation that allows me to
send any message in cloud possible
through the notion of message is
slightly higher level than the notion of
message at the network transport layer
and metric transport just gives you the
basic mechanism to send bits of us wire
and to do it in a resource efficient way
but at the level of cloud hospital you
want to say well when I sent the message
I I want that message to be say an
algebraic data type and you know I want
to speak in terms of this house
radiation instead of the instead of the
serialized form of other value which we
just get sequence of bytes they're just
not very interesting to look at so I can
send an I can expect and of course
there's this strange serializable
because they I need some form well under
the hood someone needs to be able to
take that value and turn it into
sequence of place with these primitives
in place we can write it very simple
example imagine that we have a data type
of arithmetic operations plus a
multiplying we gate you'll notice that I
mean we can very straightforwardly right
see realize we haven't written the
instance that you can give me a faith
that very easily sterilized any
operation in your breath and just your
sequence of fights and therefore I can
say so if I have some server that just
responds to any message that I send it
by printing on the screen the results of
evaluating the message they send it and
if I if I some kind of have the process
ID for the server on my on the local
append and the local end here is what's
in purple on the local end I can call
some function that says let's do some
math and you know that function will
basically just send a bunch of messages
the server will see these messages
evaluates the arithmetic operation and
print something on the string um this is
all a nice but here we've done the exact
same thing as we would do if we were
building were saying you know a REST API
Anna one of those loosely coupled
systems that was something about before
and basically if this is my only if this
is the only means with which I can
communicate in my whole cluster then it
means that essentially I need to have
one global data type for all of the
operations that I want to be able to do
remotely and I need to define that one
data type in one central place and so
I'm going to be breaking my modularity
so maybe we can do better than us so of
course and the world of threads if
everything is just local I can instead
of you know if I have a bunch of friends
floating around I don't have to I don't
have this restriction I can
I can spawn new threads and and then I
can in fact when I spawn friends I can
decide which computation needs to be run
as part of that thread so because I can
decide on the fly which computation
needs to be run as part of that thread I
essentially have an open set of things
actions that I can swap them so someone
else doing some work for me I could get
that someone else to do the work for me
the work that someone else can do for me
is is open
whereas before it was a pride orifice
this is the crucial difference but okay
and so in cloud Haskell we have spawn
local that that allows just spawn press
locally but and and you know the
arguments first one local will be a some
action but now we want to write spawn
and remote and it's fun remote in class
what we call it Swann how are you going
to do that um there is a fundamental
problem here right the arguments just
fun upon local was process a process a
process fantasy but process a is an
arbitrary action so how are we going to
sterilize it over the wire or some
arbitrary action that we have no way no
way how that actually been constructed
no idea um so one thing that we can do
is that we can say hmm actually we're
going to track in the type system those
actions that are serializable
and we're goodness distinguish in the
type system those actions they're a a
priori statically known to be
serializable and those that are not but
if you don't tell your lives and for
reasons they're gonna make them clear
later I'm gonna call all those actions
that are can be serialized
I'm going to call them closures so
essentially we're gonna change the type
that's a spawn that's when I have a
slightly different type compared to
spawn local we're going to take a
closure processing
instead of just a process process that's
our instead of just a fantastic now
what's happened here if we go back to
spawn local um so what's the idea why I
suppose you're going to help us well um
you can get a lot done in high school
it's just applicative forms and if we
write these applicative forms and a more
explicit form in the ascent you know in
the implied identity implicit function
console then any of liquid form that you
write in the form of the top in this if
you write it within the identity
function you would write it we using the
pure function and the the apply function
that start when you start are greater um
and the idea is that with closure we're
going to take the exact same structure
we're going to say if somehow we have a
way of injecting something of type a
some type eight into a closure then we
ought to know how to so now that is oh
sure we don't necessarily like that and
we want it and of course if we if you
don't have to serialize something that's
like closure eight and if you know how
to sterilize something of type closure a
arrow B then we know how to serialize a
closure type B that was constructed by
applying the closure of the closure a B
to the closure eight okay so long as
we're building our closures using this
fixed set of operators we will always
have something that we know have
serialized
the ROM here
is that closure isn't a and it
can't be and there's something going
something really funny happening with
this pure operation it's saying I can
take anything whatsoever that's digging
into closure and then what once it's a
closure we can sterilize them but what
if any of them Sam cheated to for
example int arrow int how do i serialize
a function of terror in it I can't
so we're going to say that cured is
restricted to those types that are
serializable but then we're going to
have to find some other contraption or
sending functions across so because you
know I can't reuse the the names from
the applicative class tech class because
closure is not it's close to function
but it's not technically a functor
because we have this extra constraint in
in jerk I'm going to introduce these new
operators and we're going to call a
little bit differently they're called
secure and CI and for sending functions
I'm going to say it was the following
restriction to to my cluster I love to
say well what if yeah I'm I'm an
application and I want to talk to a
machine some other machine I can assume
for that machine is running the same
binary it's the same application ism and
therefore if that's the case then I
don't actually need to send any code
across the wire all I need to do is send
an address
there's symbolic name for that code is
it morally if I have a portable notion
of a code function and I just send that
pointer across the wire and so if and
that's what static pointers of course is
this is a new extension in there's a new
section gc7
attend that a lot attic pointer four
four four four expressions under certain
conditions okay once you have a stack
pointer so you know include pointer what
a quick pointer is very easy to
serialize because it's just a names just
a string Marlee so clearly we can inject
that into closure so now that means that
we can say for example that we can have
a plus pointer that's the pointer to the
plus function top level plus mention
that if it meant at the top and the mole
pointer and these are both static
butchers will type int arrow int arrow
process and so with with the X with the
stack pointers extension I have a new
keyword and the keyword is static and
basically this vacuum where it basically
just gives me the static pointer of
course one for the expression that's
given is an argument about that yes okay
so that way I don't need to write these
these names for quote
okay so now that I have this mechanism
in place I can do better than just
assuming that there's some monolithic
server that answers all of my queries
all of the possible queries that can
happen that could possibly happen
between two machines in the cluster now
I have a way of having the local machine
known a on arbitrary computations on
node B so long as nobody is running the
same binary and the way I do that is
much in the same way that I would have
that I would spawn the new thread with
circus bottom base to run an action in a
new thread
locally I take the static pointer to the
the expression that I want to send I'm
allowed to do that so long as the
expression is closed and
and I lift that into closure which I can
do with this assignment your
serializable and then when I want I
could call spawn I'm basically just
giving this serializable closure instead
of the action itself directly all right
so this is a bit of magic that's going
on here and there's a strong condition
that we impose that it's the same binary
that's running everywhere but if if that
condition is satisfied that it means
that we can have the illusion of just
sending code to the other side without
actually figuring out legend had to do
the hard part
ok cool so I'm gonna skip over this
because I'm wearing an 10 but of course
in the Swedish system you just say a few
words and a distributive system you have
failures all kinds of things that you
have in them so fantastical you know a
lot of functions - a lot of that allow
you to linked processes together
monitored processes and all that stuff
ok so I'll show you an example of this
in practice
all right so um I have a really simple
example and what I meant to do with this
example is to emulate some graph or
graph processing applications so they
imagine imagine they have your really
really large graph and this graph is so
large that you can't have it sort in a
single machine but you don't have it so
you'll have it distributed across at the
number of nodes and so the problem with
graph processing is that it's very
difficult to get any kind of date data
locality so you know you get to if you
end up at any opportunity a node in the
graph you could point us to an arbitrary
you know you can try to follow the edges
you'll end up in an arbitrary other node
and in the graph and the stories for
that node might be story sorted anywhere
in the cluster ok so if you want to
follow for example if you want to do
like a depth-first search then compute
later trace paths then you're going to
have to jump around the cluster all the
time so there's two ways to do them you
can say oh well I'm going to have a
master the client is the make queries to
all of the machines that's for each node
in the graph right and then you know
some information is going to come back
and say oh well there's some edges here
that you can explore and by the way edge
number one well if you want to follow
that all the way to its target you're
gonna have to talk to this other machine
um but this is really small
um and so something that we can do
instead is to say let's have the
computation itself that we're trying to
do follow the structure of the graph
that we're exploring so we're
essentially having the the computation
that were you know that analysis over
time
we're gonna have is travel now I was
hoping to have you guys run run this as
part of this session and if if we had
them I usually broadcast them you could
actually see them where everyone is a
slave and I'm the master so just yeah
you just have to well you can try
absolutely on your own machines but the
idea here is that we are going to
compute all the numbers and a collapse
and the costumers all heard of that rate
there's a conjecture that says that so
the call that sequence is the sequence
that says if you start with a some
arbitrary number that numbers even you /
- if it's not even then you multiply it
by three and then you add one and
somehow actually if you if you hydrate
this process you always end up with the
number one at the end um we don't know
this for a fact but we think we think
that's true for all in the plan for all
numbers I don't know what I'm going to
do here so now is just a beta version of
class right there say well I'm gonna
start with a with a number and then I'm
going to say I'm going to compute the
next number in that sequence starting
from that number and then once I've done
that I'm going to decide I'm not going
to continue all of compute all of the
numbers in that sequence locally because
that's just boring so I'm going to
decide who of my neighbors so it just
does one oh sorry yeah I actually bring
music
so this function the way I've written it
is just the set well then I can say data
table saw hydrates for example okay so
now I'm gonna say once I've computed any
number I'm going to come up with if I
have a set of neighbors I'm going to
arbitrarily decide that some of the
neighbors going to compute the next
number in sequence and the way I'm going
to do that is I'm going to spawn a
closure on the other side and and
closure is going to capture the number
that I know if you look at this you'll
notice some weird Kabbalistic high
school going on there and that's not
what I showed you in the previous slides
and the reason it's that way is because
I stay alive in the fan festival does
not as of yet official version release
on package does not use the static
pointers extension that's the ship's was
GAC same acquaintance yes it just about
an hour ago
that's ght 7:10 support in the sense of
piles was just seven points in and we
have several people who were actually
actively working this weekend on this
hackathon on morning v hospital to use
the stack pointer extension and I should
you guys in the slides so hopefully by
the end of the weekend we can take this
example this is toy example and write it
much in a simpler form without all this
template Haskell bus transit somehow
fake
just to summarize what we've done here
we've captured a useful notion of remote
code execution we've done so on the
cheap without actually sending any kind
of code just record sister code
in order to do that we had to impose
that everyone shares the same idea of
what could is and so one pertinent
question to ask is how relevance is that
notion of remote code execution you know
we thought we got away for cheap but is
this really so and there's various
complications in practice let me erase
it and you know um we have no good story
for heterogeneous clusters and by that I
mean what if you have part of the
cluster that's using one version of your
application and the other part that's
using another version because you're in
the middle of rolling out an upgrade how
do these two parts of the cluster
communicate and this is a story but you
know and there's lots of good ideas to
sum that problem but you know any
questions and the last thing is that
what I talk about in this presentation
this is just the beginning this is just
the nuts and bolts this is just the
basic mechanism that I would submit is
very nice mechanism thinking you could
use to build arbitrary distributed
applications but also to layer on top of
this frameworks for distributed
computation in particular frameworks
that implements nice data parallel
models and MapReduce in one such model
just there was some was research
projects some while ago to generalize
the basic agent about me MapReduce to
nested data parallelism and no one
really cracked making nested data
parallelism work in a distributed say so
the at least in high school we only had
a single node implementation event um or
and this is something that I believe you
could play nice and that's not possible
and this closure
it's nice enclosure that we have
represented here or or indeed you know
decide that you want users to express
basically like that a graph of
transformations and and then the inertia
should ship that room and this is
essentially what sparked us so you know
if any of you is interested in
influencing like a mini Sparkle hassle
all right
so this is the part that I climbed the
time and I think it's a very interesting
time so glad I just interjected and said
just use Erlang and be done with it
right but actually in early doing what
having a good answer to your question I
said that would be quite hard and so in
early today
you basically have one transport and
when you want to communicate between two
processes on two different machines you
have to use that one transport and you
know in practice today darling it's a
stone with CCP now the problem is Erlang
is built around the actors model and
cloud Haskell there's a subset of
classical that corresponds exactly to
early it's just a straight
implementation of the actress model and
the actors model makes the following
trade-off that says I'm going to assign
identities to processes and so long as I
have identities to prop up for processes
I don't need to talk about the medium to
communicate with these processes
explicitly in the examples that I showed
you I just said oh you see that process
over there it's
called foo send a message to write I'm
not there's no medium involved here but
to answer your question better I'm sorry
to to address your problem better
ideally what I would be able to do is to
say I'm Matthew I want to say something
to gladden and he's all over there but
what I have but I want to say the lab is
not that important
so I'd like to have a channel available
to communicate with blood and I'm going
to say this is an unreliable Channel and
I'm gonna stuck a message on that
channel and if it doesn't end up on the
other end and glad never hears about my
message so BA but then you know I might
want to talk to Ed right in front of me
and on the other head with Edie I'm
having this really important
conversation and I really really want
him to know what I'm saying and if I see
something once breaking out let's say
we're bidding we're kind of a negotiated
contract listen then I would like to
know that you know she gets my my
messages in the state in order because
that's been a great really the Jews in
this negotiation so I want to have if we
have a notion of channel an explicit
notion of channel then I'm able to say
I'm gonna use a reliable channel to
communicate with that and unreliable she
don't want to communicate with club but
you can't do that in the pure doctor's
mom in cloud Haskell you have both you
have pure actors well but you also have
snails and in practice having channels
gives you two things that allows you to
say I'm gonna say you know I'm gonna
choose the reliability that I need I'm
gonna choose the ordering guarantees
that they need and it gives me a way to
to say well the channel is only good for
communicating messages of type
it's hype war so I can type my
communication which is another thing
that I do with this is also yeah so
there's an intense and actually that
semantics is a copy of the an attempt to
do the same for Ireland but but no one
knows whether that attempt is even means
the model as with every model does of
course not reality is it just a view of
the mind no I agree so the reason I have
this here is because I don't want to lie
about the current state of classical
today and the classical today has the
following limitation and that is that
whenever you send a message it includes
as a header of that message a
fingerprint for the tie prep of the
message and then on the remote end you
can say oh did I get a message to type
in they got a message to poison the
tight prep depends on the name of the
the type the module in which it was
defined and the package including the
package version so this means that if
you if you have two versions the
application
then you're going to be incredible have
the Cabal package version number
incremented and so even for int sorry
yeah actually even for int the time
perhaps going to be different so you
might send a message of taken and to me
I'm never going to notice if you sent
something so part of the problem is that
I don't think this having the tech rep
as part of the message is what you want
once this time and you know something
that would be really nice is it's a
leverage that you that the work that
Duncan was presenting yesterday with
self describing instances for binary and
so you know when you send an interesting
well I'm sending you a message that says
but it's an int and and you know there's
a stable notion of what a message that
has an int as a payload means right it's
you it's so stable that's defined in the
RFC this is quite different from the
notion again today that's completely
unstable
in fact it's so unstable that it changes
every time you commit the person that's
part of the answer that's for the rest
I'm not sure I recognize my thoughts on
that so we should talk about that
immigrations I just have a comment I was
trying to do your example for the first
hour of the market I'm almost given up
and the trick is you have the
requirement for days at least 4.8
indicating that it should be combined
with this seven times eh see the best
shape isn't very perfect compiles
perfectly the third seven eight yeah so
just remove they come straight on base
and it will comply with its subject so
Alexander may release the three variants
before the the track so will will check
them out and Alexander's yeah so well
we'll check with Alexander the release
and try to push any witnesses we find it
was the right thing yeah</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>