<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How to Write Clean, Testable Code | Coder Coacher - Coaching Coders</title><meta content="How to Write Clean, Testable Code - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>How to Write Clean, Testable Code</b></h2><h5 class="post__date">2011-01-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XcT4yYu_TTs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">open-source projects recently as
interest in test-driven development
turned into testability Explorer and
jstestdriver with which he hopes to
change the testing culture of the
open-source community for everyone can
put you hands together and welcome Mitch
go Harry Howard you're too kind of
Awards here so thank you all for coming
we're gonna talk about something
different today hold it about psychology
of this event and talking about how to
do the testing we're interested in what
is actually going through our heads when
we are confronted with with writing a
test and how we look at this particular
thing so hopeful is going to be a little
bit of different I love questions so
please ask as many as you want and to
encourage questions we have a little bit
of schwag that Igor over here will help
to hand out so for good questions will
give schwag so do ask don't wait for the
Q&amp;amp;A session at the big at the end okay
let's get started so I like to rather my
boss always like to say testing is not
like frosting meaning that you can't
bake a cake without sugar and then
decide that you're just gonna frost the
cake on me after the fact like it just
doesn't paste right right you got to put
the sugar in the process of baking and
so it works the same way for testing as
well you can't just build your project
that then assume that after the fact
you're going to like sprinkle on some
tests and then everything is gonna be
nice and fine because it doesn't work it
just doesn't work after the fact so
let's look at how we actually build code
and I think whether you do testing or
not this is basically how everybody does
it right the red area is where you put
the bugs in and then the green areas
where you take the bugs out right that's
kind of how it works and it's an endless
cycle like whether you do test-driven or
whether you do manual you code for a bit
and then you try it like you can maybe
code for half an hour max but after that
like you got to try whatever you caught
it up because sooner or later or like
you're just gonna get yourself lost like
it's an iterative process whether they
like it or not and at some point you
decide yet it's a good thing and I'm
gonna check it in right but the thing is
is the green box and that is that we do
it manually a lot of us do it manually
like the transition to do it
automatically and so the difference is
writing your test or rather deciding
what you about to implement and then
writing a little scenario a little story
about it and then implementing and we'll
talk about that later the whole trick is
how do we transition from us doing the
test to a machine doing the test for us
and so the way most people kind of look
at it is they kind of do this
so they say well put the bugs in over
here and then we expect that be gonna
have some kind of a QA folks that it's
not our problem right it's like software
engineers we write the code and then
somebody else's problem is to kind of
make finer bugs after us uh and then at
some point people will say well the gold
QA manual QA doesn't really work out so
we gotta have some kind of automated
tests and so at this level people are
always looking for some kind of magic
like ooh if only we bought some software
X and all of our testing problems will
go away and there's lots and lots of
companies that do this and it never
works and the reason it's too late at
that particular point in time there's
another problem with this picture and
then is that the people who put the bugs
in are not the people who feel the pain
and unless you have the closed circle
unless you feel your own misery you're
never going to learn and get better at
this particular thing so the magic to
testing is not here it's up here it has
to happen up there if you do this right
everything else will just pull
automatically in place and so we'll talk
about this a little more so the funny
thing is you come to engineer and you
say why don't you write a test and they
always have some kind of a beautiful
excuse for you and usually it goes you
know long list I'm not going to go into
individual details as to what all these
excuses are but one thing that nobody
ever says is I don't know how that's the
valid excuse you know just say I don't
know how it's perfectly valid right I
mean I come to you and say do you know
JavaScript you can say no and you know
it's not shameful to say that I don't
know a particular language but somehow
it is shameful to say I don't know how
to write a test now why is that it's a
skill like any other thing right you
could say do you know how to ski
it's not shameful to say no I don't ski
but somehow as engineers is kind of
programming into our head of course I
know how to write a test nobody ever
says they don't know how and really this
is the reason why most tests don't get
written is that writing test is a skill
like any other skill and you have to
learn it like you learn all other skills
it's not innate to the whole process so
let me demonstrate this thing this is my
favorite interview question when I do
interviews at Google I say suppose
you're an evil engineer and you want to
make hard to write code
I'm sorry hard to test code what do you
do it's an operon question to all of you
guys what do you do yes okay so you've
been reading my blog good yes you said
put Singleton's everywhere a global
state in other words what about so I've
give the gentleman some schwag to
motivate yes yes but new operators
everywhere okay hard code dependencies
it's a different way of saying put news
everywhere yeah lots of static methods
this cannot be overridden yeah this
general just complexity right right so
that's an interesting statement so you
could a lot of people say that on an
interview that's all just make it really
complicated and while it is true that
that makes it hard to test it doesn't
that in itself doesn't fundamentally
prevent testing it just makes it
miserable difficult right whereas yes it
makes it miserable difficult yes yes
whereas new operators fundamentally make
it impossible right that's the kind of
the difference that I'm going here but
excellent I mean you guys know a lot of
good points
um I get a lot of blank stares people
not quite sure what they're what do I
mean by this pretty cool question but I
figured it if you know how to write hard
to test code then you probably know how
to avoid
it right so let's talk about little s
theory a little more hands-on so I'm
gonna have some examples to go through
and yeah this is kind of hard to see but
I was kind of hoping that some of you
would have computers and you can just go
to this URL and actually see the code
but it doesn't matter what will go
through them in more in depth in
particular thing so usually an interview
I present the candidate with a piece of
code something similar to this and I say
pretend you have to write a test and
specifically I'm interested in what
would you change about this code in
order to make this testable and you're
squinting and there's going to be slides
that are zoomed in a little more so
don't worry about it just yet
the interesting thing about this
question is that everybody immediately
takes the piece of paper and you know
sticks their nose into it and tries to
understand what the code does and it is
interesting because why would you think
that knowing how to write a test is
related to knowing what the code do does
in other words whether or not a piece of
code is easy to test is a function of
structure of that code it's not a
function of what the code does and this
is something that people don't seem to
understand you're going to say something
yes right right
so the message I'm trying to say here is
that when you're presented with a piece
of code and you're trying to say how can
I test this don't try to understand what
the code does that's really a secondary
problem rather look for how the code is
structured and it's something that you
can train your eye to do over time and
I'm going to show you what I look for
when I see a piece of code and how I
really don't think that what the code
actually does is relevant to this
question so this particular code is
designed to slap you around it's the
most easy evil piece of code I could
think of and from really inspired over
years of looking other people's code and
also mine especially if I go back in
history so they're comfortable all red
flags that I look for and I think you
know we should learn to recognize as a
software engineering industry is global
state and singleton somebody already
pointed that out love the mirror
violations and I'll have an examples of
why that's a problem global references
good time because really time is a
global function that changes underneath
you all the time
hard coded new operators and just the
general lack of dependency injection or
really dependency management so let's do
an exercise that is assume the code is
fixed right this is where most people
when when they first come to testing
they have this assumption all code is
already written I've done all my work
and now I'm going to go and try to write
a test right and so I take this attitude
that the code is perfect I'm just trying
to write some tests on top of it right
and it well I'm trying to say is that
really just the wrong attitude to look
at when it comes to writing code so but
it for this exercise let's just assume
for a second that the code is fixed and
we're going to try to do our best effort
in writing a test for it and the process
we're gonna identify problems with it
and then maybe hopefully on the end will
suggest some refactoring so hopefully
this is a little more zoomed in the part
on the left is is the code that I'm
looking for and then the part on the
right is the test case I'm going to try
to write a test keep in mind that this
is what would the world look like if we
assume that the code is fixed and we're
just trying to write a test and this
code is specifically badly written to
make testing a little bit difficult so
the first thing I look for is the static
keyword because that tells me that
there's global state now what does it
mean what it means in test is if there
is a static keyword here that means I
only get a single chance of
instantiating this thing in my test
system right because it's a once the in
box in tourism instantiated I can make a
new one because it's final right so good
old singleton which means my pist
setup will have to have some kind of
like if you're not initialized
initialize it and the trouble with that
is you really don't know
when that class gets initialized you're
hoping that you are the first class to
reference this thing but you have no
idea so this is a big assumption whether
we can even do this in our test but
nevertheless it will kind of break down
to this thing let's see what is the next
piece over there
referencing to more global State over
here the next thing I look at is a
constructor and I say well looks like I
need a certificate but I need to read it
from looks like some config object that
I have to pass some path property that I
have to indirect lookup and then read
the certificate from the file system so
the equivalent on the other side from
the test point of view is well you've
got to generate a certificate
you got to create a temporary file you
got to write the file somewhere close
the output stream and then you're hoping
that the configuration object is
writable now given that this whoever
wrote this piece of code was paranoid
chances are he was also paranoid here
which means this assumption I'm making
that I can actually modify the
configuration object might be outside of
the scope of what's actually possible in
that code base so that might be
troublesome as well so here in the next
piece is you know I'm getting a user
username and password in order to do
this I'm going to have to let's see
create a user object and here's another
big question mark is can you actually
instantiate a user without any arguments
like it could be that the user requires
a whole bunch of other things for
example the person could have decided
the users constructor takes a servlet in
order to get ahold of the cookie in
order to initialize itself from the
cookie right if that was the case then
instantiating the user would get really
really difficult so here I'm making a
big assumption that user is going to be
actually easy to instantiate I'm going
to put the user name and password in
there and I'm going to be able to set it
under config again these are all
assumptions that one would have to make
in order to write this test and these
are really tough assumptions to swallow
what else is in there so then when you
do all this the next piece of code I
look for is these are your true
dependencies almost usually not always
but usually the true dependencies are
the fields that you have stored in your
object and therefore those are the
things that you should that you will
want to mock and inject but that's not
actually what you're asking for inside
of the constructor in other words you're
pretending that what you need in order
to get your work done is the
configuration object but the reality is
you need all this other stuff and you
are actually going to go look for stuff
right so I always like to say ask for
what you need don't look for things this
is what I mean by that like you should
be really asking for the certificate
username and password directly rather
than looking for all these things so
look at all the code that we have
written over here that's actually quite
a lot of code to just get through the
constructor and a constructor is
something that we need to do all the
time when we're testing so let's go
further so now here's the sink method we
want to test and again there's new
operators here but this is a tough one
it's gonna say make something called op
connector doesn't matter what it is and
it's just gonna connect to and
disconnect which means we'll probably
have some socket communication going on
so in our setup method we'll probably
gonna have to create a server because
there is no way to give you a fake
connector over here because there's a
new operator here right so I can't
instantiate something else for you over
there so in order to test this I
actually have to have a kind of a fake
server which gonna have real you know
tcp/ip stack to get it up and running
and then hopefully and teardown I will
be able to shut it down which is also
usually a big question with servers
whether you can actually shut them down
so I think these are just assumption
after assumption after assumption on
making that if everything else is
written in a correct way then maybe I
can test this untestable piece of code
if I just jump through all these hoops
right but the reality is if this piece
of code is not written well chances are
the rest of the system isn't written
well either which means many of these
assumptions I've made over here probably
false and will probably require a lot
more code to get this thing tested right
so paying attention did you forget
anything
No well we haven't written the test yet
this is just a setup right we're just
trying to get through the new operator
so that we actually get an instance of
this thing so when you survive that
crazy setup we just went through then
maybe you can write a test that actually
does something and what's interesting
when people write tests after the fact
I'll usually say test sink
it's usually a dead giveaway what
exactly does that mean does this tell
you a story of what you're trying to do
like doesn't only tell a story here
right you just you were told by somebody
got that test that class you saw that
that class had a single method called
sink so you made a testicle test sink
and then you hacked at it until you were
able to get something to execute and
then you said well I'm executing stuff
and looks like I've got some coverage so
ship it so there's another mental
exercise now that you have written this
test which is a little scary
could you reconstruct your project if I
deleted your source code that is I you
get to keep your tests but the
production code is gone we'll be able to
do would you be able to reconstruct your
codebase and I'm gonna say you're gonna
have a really really hard time and the
reason for that is tests like these they
don't tell a story they say if you do
all the set of crazy things then
following sort of crazy things should be
true but like they don't seem to be
related why is it that I have to be
writing certificates to this for special
file and setting these global variables
and like it's not there's no rhyme or
reason to this thing so uh let's see if
we can flip it around so before we can
flip it around I'm gonna say tests are
so yesterday it's all about the
executable specs an executable specs are
just tests with syntactic sugar sugar is
always good makes the things taste
better so how many of you guys have
heard about specs all right good
you like them really what language are
you familiar with the specs in ah I
don't mean that kind of specs I mean
like specs as an executable pests that
are specs well I'll show you an example
in a second who else Ray Ray's there
and do you like specs over tests yes
your office okay so we're talking the
same language yes yes BDD is another
fancy word for this stuff it's just that
people laugh the BDD is really just
testing them right so let's change our
assumptions here and then is assume the
code we're about to test is yet to be
written right and the other thing
assumption I want to do is that you want
to demonstrate a single behavior per
spec right to put it differently you
want each test to tell a story right
imagine I try to explain to you what a
particular product does what I'm gonna
do is I'm gonna tell you a lot of give
you a lot of examples like you say oh if
you do this this and then and this is
gonna happen and then if you do this
other set of things and there's other
things is gonna happen and I want you
what humans are really good for is that
if I give you a series of examples of
how something works humans are really
good about generalizing so if I say you
know it does the following set of things
in the follow of the things with an
following then you say ah it's a car
right but it the other way around it
doesn't work so well if I come to you
and I say you know it's a sinker for
email and you're like it's too general
of abstract thing I don't really know
what it means concretely so what what
means to tell a story is that I give you
a whole bunch of examples that
demonstrate how the piece of code work
let me show you that so the biggest
difference and this is Java and Java BDD
is little not not as good as for example
Ruby's BDD or in JavaScript there is
Jasmine that has pretty good BDD syntax
but the basic idea is that you want to
tell a story and so you're saying it
should sing messages from pop since last
sink ah that's a story like I understand
what it means it's much better than
saying test sink it should close the
connection even when an exception
happens I understand what that means and
I understand how to code that right it
should sink message only when not
already in an inbox right so these are
the specifications of what the
particular code should do and then we
fill in those specifications with little
stories to demence
trade this particular scenario so let me
give you an example so it should think
message from pop really wing means
something like that I'm going to create
a pop class I'm going to add two
messages to it then I'm going to create
my sinker whatever that means I'm going
to pass in all the dependencies like pop
inbox filter when was last time I sync
and then I'm going to say sync now and
then I'm going to assert that the
particular message actually got copied
but there's two messages I put in but
only one got copied because one was
already sync as it was after a
particular date right the test like this
tells a story and the other thing that
this test does is notice that it's much
easier to follow there isn't all this
distraction about writing creating
certificates and writing them to
temporary locations and then cleaning
them up and starting servers and you
know all this all just distractions to
begin telling a story so you want to
make sure that these are short you know
they fit on a page and they're easy to
read and to me that's really what specs
are little stories like that so maybe
another story would be a you know test
that it should close a connection even
when exception happens so here again I
can create a filter that throws an
exception and I can simulate an
exception throwing because when I try to
sync
I expect to catch it again I'm telling
the story and something like this
wouldn't be possible if we already have
written our implementation and had new
operators everywhere which most people
have so notice another thing that if you
do this right there usually isn't a
setup method right there is really no
setup method is needed because you need
to execute some complicated piece of
code right which maybe has some if
statements loops or something like that
all we're doing here is we instantiate
an object and wiring them together and
as a result your setup is essentially
just declaring your fields and these
fields actually become part of your
language that become kind of like a DSL
right so now your test reads nicely
because you can say
let's see right you have these things
like long ago passed now future in box
filter long ago message passed message
current message and then if you're
trying to write a test let me back up a
second
like over here notice that you could say
add message long ago add message passed
message and then when I do a sync I say
sync now or our last time I sing was
long ago so that it reads more like a
child great do you know what this all
stands for dynamic mind specific
language tutor Sen I'm trying to get at
so you want to make sure that you really
tell a story with these things now I can
do all of this is because none of the
code was actually written it I'm just
making it up and it's easy to make stuff
up and the other thing is if I'm making
this stuff up nobody really in the right
mind will start making crazy things up
like oh let me start a server let me
write a bunch of things to a file system
let me create some obscure global
variable that I said right you don't
think that way you create the most
simple scenario that you can think of
because creating complicated scenarios
it's a lot of effort right and nobody
really wants to do that so writing the
test before the code is written it
really allows you to just think about it
in really pure form and worry about how
this pieces get together wired up later
so given these specs let's write an
implementation and so here's an example
of what an implementation would look
like and the first thing what do you
notice what's the difference between the
previous one maybe it's about the same I
think but more importantly with the
exception of the new date
there is really no no new operators here
data is kind of an exception because
it's kind of a value object like
concatenating strings it doesn't only
count and I'm really not creating a date
from global timer I'm really passing in
the date because it's being passed in so
it's kind of an exception here but in
general you don't have new operators so
for example the most important is that
the pop connector which was actually the
thing that connected the server is now
passed
from the outside so that I can pass in a
fake implementation if I choose to so
when you look at code like this the
thing that I always look for is I either
want to see a whole bunch of new
operators and know if statements or
loops or a whole bunch of if statements
but no new operators because I'm either
wanna see code that's a factory which
case I'm wiring things together and I'm
not doing any work or I'm doing work in
which case somebody else is responsible
for wiring process because if I mix the
two together then I'm gonna have a
really hard time writing a test the
other thing you're going to notice is
that a good constructor looks like this
and that is list your dependencies
unfortunately Java we have to do this
three times we have to list your
dependencies once here then once over
here and then once copying over
I think Scala has fixed this but this is
what a good constructor looks like you
know you just say I need whole bunch of
these things it's somebody else's
problem how do you get there
so whatever you learned we learned that
the new operators are really the thing
that gets you if you need it then you
must interact with it so what does that
mean um I don't have a slide the slide
was too far back ago but in in the
original code there was we were asking
for example for config and we really
weren't interacting with the config all
we're doing is we're getting stuff out
of it right
ah and so the rule is to do not be
violating a law of the matter you must
be sending a message for to other object
to do something rather than sending it a
getter right that doesn't count so
passing in a config and then having the
other objects a config table get user
dot get username just so I can take the
user name and pass it to the the the
Popkin Ector so the pop connector can
connect to for my behalf is kind of very
convoluted rather you should just say
look I just need a pop connector and
it's not really my problem how you
construct one in somebody else's
business and that whoever constructs it
should be passing in the username and
password and certificate as well
ah the factory's valid enemies and you
can be basically more lenient with them
right because they're sorry the question
was do factories violate law of the
matter because you don't really interact
with them and to some degree I mean you
the factory shouldn't because you're
just insane shooting a whole bunch of
things and passing it back in but
sometimes you really have to say well
get that object from over there and pass
it over here so to some degree you can
be lenient about law of demand
violations in factory code but not too
lenient even there it just looks kind of
suspicious this was a second question
over there no okay
oh yeah and lastly doing work in
constructor is just bad idea because
constructor is one method that I cannot
override it's the method that I
absolutely have to call every time I
wanna call instantiate any call any
method on an object and so if you put
work in the constructor you're basically
saying that every time you want to do
something with this object you better be
prepared to go through whatever that
constructor wants to do and if that
constructor wants to read certificates
or wants to you know send emails well
then you're stuck here you're sending
emails and reading certificates so the
last piece is that what we talked about
is we talked about unit testing which is
an individual levels all the way at the
bottom but the same rules also apply for
end-to-end tests to give you an idea a
unit test is to end-to-end test as
classes are two components so if my
classes follow proper dependency
injections so that I can instantiate
individual classes then I should also be
able to do the same thing for components
so if I have an application I don't know
I'm going to use Gmail as an example if
I have an application like Gmail I
should be able to say in the end to end
test I am going to remove the
authentication component and then
replace it with a fake always
authenticated component so when they my
end-to-end test run I don't have to
worry about logging in and that's
another form of dependency injection but
really just slightly higher level so
just like your individual classes need
to be properly managed and you can
replace them from depend
Injection the same rule really has to
apply to components and it turns out
that if you do a class injection
properly then you get the component
injection kind of for free so if you do
your unit testing properly then your
end-to-end test should just kind of fall
into place
so what are components well just
well-defined boundaries like I just
pointed out like being able to replace
the Authenticator was something else or
maybe the persistent engine with
something else or something like that
your app should really be global state
free because global state is going to
hunt you whether it's with unit tests or
end-to-end tests or at any level you
really don't want to have any and last
piece is that when you are testing unit
tests you know we kind of went to the
idea of creating a DSL out of your
variables so that you can easily write
sentences that is even more important
with end-to-end tests because when in
end-to-end tests usually you want to
tell a very complicated story well in a
unit test you might say something very
simple like if I have an account and I
deposit five bucks to it and the account
should have now you know if you have
start with five dollars I deposit five
dollars I should have ten dollars in
there now that's an easy story to tell
but if you have a end-to-end test the
stories you're gonna tell are much much
more complicated you're probably gonna
say a story along the lines of oh the
user logs in as you know into his gmail
account and then he checks the inbox and
then if he sees an unread message he
clicks on it and then that unread
message then when he goes back to the
induction log will be showing as unread
but he should be showing us red and then
he should be able to own it I it's a
very complicated story and unless you
have a very good DSL a good
domain-specific language of telling the
stories you're going to get lost in the
process of building your end-to-end
tests ah last thing is I often times
demo how I do test-driven development
and so I usually show up at a meeting
and you know I have a clips going or
whatever your favorite ID is and I start
typing I hit save and all sort of my
tests run and what that really means is
you really have to spend time and making
an environment easy for you so that it
doesn't fight you right and I often
times forget
that I have maybe spend you know four
hours trying to get Eclipse to behave
properly so that when I do a demo to the
students or whoever I can give me the
demo too
they kind of see oh look if you hit save
it just magically runs right but that
magical part is actually the hard part
when we talking about being able to
write tests it's not just being able to
write pissed it's also being able to set
up your whole environment that the
Ratterman doesn't fight you every step
of the way in writing those tests ah and
that's the kind of the tricky parts of
the whole business so that when you set
everything up of course it's easy right
if you come to a project where everybody
does this thing and you're a new kid on
the block and they just say look how
easy to write a test and then you say
well it takes me three lines of code to
write a test or I can start a server it
takes 30 seconds and then I can go and
log in which takes another 30 seconds
then I go to inbox and I click on
message and I can verify that you know
the the message is no longer on red but
it's red or I can just line run three
lines of code of course the person's
gonna write three lines of code because
it's easier right but getting to that
point is something that there is a lot
of effort in it's not on know-how so a
lot of times when you're talking about
having
doing test-driven development it's this
unspoken thing that nobody talks about
which is that how do you get your
environment set up so that these things
are natural so that it's the easiest
thing for you to do and that's not
exactly simple or easy and sometimes
finding the right tools is tricky so
when I talk about one last thing which I
call the theory of bugs yes yes
right so you're asking an open-ended
question of you know we were in the
situation where it's hard to test what
do you do unfortunately there isn't one
magical answer I can give you it's um
it's basically fighting it the
environment trying to figure out some
kind of a harness or something to make
your life easy and there aren't really
easy answers to it it just has to be
this goal and this vision in that you
have to have that is if I somehow solve
all these problems and for every project
these set of problems are different then
and I get to this happy place then it
life makes sense and it's easy but
getting there is always that the tricky
part and unfortunately I don't know or
can't really help you on an individual
basis yes
so the thing you're bringing up is that
the cost of making a mistake
in hardware world and in anything but
software is just so expensive that
people have no choice but to test
unfortunately in the software world cost
of making mistake is that feeling you
get like oh if I just fix this
everything's gonna work and then you
just iterate on it for three months
right
case yes no there isn't a clue yes yes
yeah it's yeah it's there's no cliffy
right that's a good way of putting it
yes which is always so why it's so hard
to saw somebody any idea of testing
because there's this mountain in front
of you and I'm saying look if you just
climb the mountain on the other side
there's a paradise
yes absolutely
testing is something that has to be
baked in from the moment you start
writing a first line of code you have to
think about what am I gonna do to test
this thing and really better yet you
need to have the harness ready before
you write the first line of code because
then you don't have to say well I'm sure
that this design is actually testable
you know it because you wrote the test
first and then you're writing
implementations they are very much
interconnected and that's something that
people fail to acknowledge especially
when they have this attitude that you
can just sprinkle the test after the
fact to the codebase and you just can't
do that
yes so let me finish couple of slides
and then we can throw this into an
open-ended conversation I promise
someone have about five or so more
slides ah so I call this the theory of
testing and that is I think there are
three different kinds of bugs so one
what kind of bug is what I call the
scorpion which is you thought about the
problem and you thought wrong and so
it's a thinking mistake
right the other kind of problem is you
got the pieces right but you miss wired
it like you got yourself a stereo system
and you got yourself a TV but you plug
the input to the output I wouldn't call
it really as a thinking mistake it's
just you happen to miss wire the pieces
together and that happens sometimes
that's a that's a it's a wiring problem
and finally the ladybug problem which is
you put it together it just looks funny
and this is your UI right like you put
it together they just a doesn't quite
look right and and why do we what we
talk about these three different tests
is because each one of these kinds of
bugs can be caught by a different kinds
of tests the thinking problem is really
your if statements and your loops and
that's where unit testing is really
wonderful at which is I have a class and
there's a whole bunch of complicated if
statements and loops and logic and I
want to make sure that I test those
particular things and so unit testing
over there is what is what the doctor
has ordered once you know that
individual pieces work together you
could have very well misfired the
factories write unit tests don't help
with that which you need is in kind of
an end-to-end or at least medium level
test that the test to make sure that the
pieces work together and so this is
where end-to-end comes in and the
basically where if eyes that the at
least the happy paths work because if I
can get the system up like I like to use
the example of a car you know if you put
the car together and on the end of the
line if they put the key in and they
start on the driver to the parking lot
chances are they got the right parts in
the right places right I mean for the
most part you know the battery is there
the fuels they're hooked up properly the
engines there the brakes there so for
the most part looks like nothing got
forgotten you don't know whether the car
will perform at some really cold
temperatures or will we perform you know
on what the ABS were all the other stuff
but hopefully there are other unit tests
that kind of proved that yes the brake
system works when it's minus ten degrees
or something like that and so really
we're just interested if the pieces got
put together properly and so that's what
unit tests are for they're really not
meant to make sure that every single
scenario works they're merely meant to
be that the basic flow works because
that proves to us that we got wired this
thing together properly
the last one I don't have an answer for
you because that's like the font color
is off or you know it looks weird when
it's on some weird angle monitor or
maybe when you translate it to a
different language it doesn't look right
and so unfortunately there is no test
for this this is still humans we can
totally automate this thing but there's
a good news and that is the probability
of finding a particular bug of a
particular category and the cost of
fixing this particular bug is different
so logical bugs then really really are
the probability of you finding a logical
bug is really high you make lots of them
everyday you fix lots of them every day
you probably want to think about it
because you as you changing the code
around the difficulty of finding it is
actually hard like if something doesn't
work and only under some corner cases
it's really difficult to find this thing
and then when you find it and fix it the
probability that you introduced the new
bug is actually quite high so luckily
for these set of bugs the logical set of
bugs you know we have unit this and
that's what verifies us that everything
is kind of working and we're not
regressing the wiring bugs this is the
end-to-end test right
chances are usually they're kind of
easier to find because if you misfired
usually the whole system just crashes
spectacularly you're like it's not like
a logical bug we're only on leap year on
the end of the year
at 12 o'clock the system doesn't work
right the wiring problem if usually if
you have one the system just doesn't
come up the throws an exception one in
the main method or something crazy like
that and so fixing those is much easier
finding them is much easier and when you
fix the chances that of you introducing
a new bug is actually quite low the
rendering bugs are the easiest to kind
of the spot to fix but there is no real
way of making sure that we don't
reintroduce them right it's kind of the
end of it but when I explain that people
say what my code is different you know I
have a super bug that's because you
mixed all the concerns right the reason
I could have three different kinds of
tests is because Michael was either
responsible for wiring oh it was
responsible for logic and then mix it
together or I had you know the rendering
UI whatever the view template system you
have haven't
I don't mix the pieces together when you
mix the pieces together all bets are off
right you have the superbug where it's a
rendering and a wiring problem and a
logical problem all tied together okay
that's everything
ah so I open to questions if you have
any yes yes I saw what the question
always comes up ah so the best way that
I can come up with is that you separate
it into two problems one is there is a
problem of being the traffic up making
sure your threads don't deadlock and
making sure the right stuff is happening
at the right moment that's a deadlock
problem or the trafficker problem and
then the second problem is the actual
work that you have to do so you need to
structure your code in such a way that
these you can schedule the threads in
any point in time so that you can
simulate what happens if this thing runs
first and that thing runs first and that
really means that you have to separate
the scheduling from the actual logic
that is happening is out of the schedule
blocks mm-hmm mm-hmm
something like that there is really no
good easy answer yes and it's Garrett
what you're doing is you're you're
you're having flakiness right because
even if you you test sometimes works
sometimes doesn't it doesn't prove
anything
so threads are hard and there is no a
hard question but to digress a little
bit I think the answer to that your
problem might be something like node.js
how many people are familiar with
node.js and interesting there is you
have a single threaded system therefore
these problems don't exist and instead
of scheduling you have callbacks that
execute this event that system and you
guarantee that each callback happens by
itself exclusively so you don't really
have any thread locking issue and so
there you can you know
we have this particular problem but
that's digressing so the answer the
question is looking to know Jess maybe
that's what you're looking for
yes so you can have a little micro
benchmark test in your code
those are trickier so I usually have a
separate test suite that runs them so
they don't pollute the but there's no
reason why you can't say you know I
should be able to run ten thousand
operations in a second and then just run
it for ten thousand our predictions
measure at the time yeah it might be
flaky because if you set the threshold
to early right but the other thing that
you might want to do is you might want
to collect these numbers so one thing is
to fail a test outright the other thing
which you can do is you collect these
numbers and then you put them on your
continuous build and you make a chart if
you use Hudson it's actually there's a
plugin for Hudson that allows you to
collect these things and and enjoy so as
long as your tests produce some kind of
a properties file that has all these
numbers of performance then you can
chart them and you can see us as commits
go in to see if any of them a regression
test yeah it's kind of a visual so
there's really no 100% guaranteed way
I think you were first other prefer
marks or objects ah that's always a
religious debate I I guess you can say
that I I'm the kind of a guy who likes
State Bates testing to some degree I
think marks are good and you should use
them I have it almost these rules that
if you're gonna have user marks you
should never have more than two mocks
involved in a in a test and then if you
gonna have expectations on these marks
and you shouldn't have more like and
three expectations per mark if you're
doing anything more complicated than
that you're doing it wrong and if a
mockery turns mock if you train a mock
to return another mark you're doing it
wrong again but in general I find that I
don't really use mocks that often I much
rather prefer to do state-based testing
which is that I put the state in the
mills situation like oh the account has
ten dollars and then I perform a story
on it which is you know add some money
to add subtract and add interest or
whatever and then I assert that now the
account has a particular amount of money
on today I don't know whether it's like
a personal preference or it's actually
better or not so I mean I heard
arguments both ways that's just what I
do
I'm sorry test factor okay yep I think
you had a question of the right
really what team are you on yes it is in
the way like that so business analysis
and all these things are important and
it's really outside of the scope or of a
discussion the discussion we starts with
when a PM or whoever knows whoever knows
what needs to be built comes to you and
says we need to build an email program
right and it should have the following
set of features then you can turn those
features into specs or stories and then
the stories is what you end up writing
and it turns out that as you're writing
the spec you're indirectly designing the
code because you're saying well this
class needs to do X in order to do X
means to collaborate with this other
concept over here and so I'm
instantiating these concepts and wiring
it together and in the process of it
you're really doing a design because
you're looking at it like what is the
API look like you starting from the user
point of view like what is the the API
look like and then I'm going to
backtrack and do the implementation
which is very different than doing the
implementation and then really having
accidental or incidental API is what
most of the code has it's all mixed in
together like I don't really see
boundaries for it it's like you write a
little code you write a little test you
run some tests you something breaks you
fix it it's just a continuous iterative
process I have no idea I'm really the
wrong person to ask about that but I'm
assuming you're referring to Android I
believe that there is a company called
the pivotal and they have a testing
framework for Android called something
robot electric robot electric sheep
something I can't remember what it is
but
did some whole bunch of interesting work
around the around testing Android stuff
I can't remember the name though is
something about electric and something
about a robot robolectric there you go
robot electric it's called yes yes
what I do I still have somebody for
somebody was interning in quality
assurance testing I don't have a
specific advice but my general advice is
that good way to learn all these things
is to be part of some open source
project and the reason for that is
because you can try all kinds of
different things you can come experiment
and you know the worst thing that's
gonna happen is they're not going to
accept your patch and you don't really
have some time pressure or anything like
that like which happens in most
companies so where I learn most of my
stuff and I see the people that I talk
to where they learn more so their stuff
is really an open source projects when
they try different things and try to add
that stability to it so my general
advice is be part of open source and try
to do something and in the process of
doing so you probably discover and learn
from other people yes you know I want to
make a more general statement about what
you just said it is that there's
something interesting about engineers in
general and that is that they're really
I don't know if they're afraid or
there's something about saying I don't
know that they're having troubles with
right and there's nothing wrong with
saying that because there's so much
information out there like you don't
know most of it and you just have to
accept that so a lot of times when I
actually especially with with interns
and younger people who are new to work I
always find is that they are really
having a hard time asking for in saying
look I just don't know I need some help
and that's really the best way to learn
you swallow your pride and said yeah I
need to help me out and you'll learn all
kinds of stuff from there
ah that's a tough one because you now
your aleene's not I what you're asking
is not an engineering question so the
question was how do you inject a process
into an organization and that's not an
engineering problem that's a people
problem um on a technical side it's easy
get it some time dependence injection
system if you're working in Java I like
juice but there's other ones spring and
I can't think of the name right now take
a container thank you both are very good
about all about the same in terms of
capabilities so we can't go wrong with
any of them
and just start at one location of the
code base and slowly grow it and then
people will slowly see added piece of
code base looks much nicer it's more
testable and just slowly as you need
more and more things just grow it from
there from a people sign a point of view
for a while what I was doing at Google
is actually there was a group called
test mercenaries which we went from
group to group and we try to inject
these practices as you say into the
theme it's very very difficult it's very
project specific because each team has
different kinds of hangups or different
things different problems that they're
faced with but in general what works is
that pairing with people works
tremendously just you know instead of
arguing about some arbitrary not real
thing sit behind a keyboard sometimes
you have to trick them and see two
people behind one keyboard solving one
problem and just a word kind of our
problem together in the process of
working this out all kinds of questions
come up and instead of talking about in
general things you can talk about it in
concrete things that you're actually
doing in a code base that is by far the
only thing that I know hope that works
and expect it to take a long time yes
if you if you must call it that
yes but it's sometimes a dirty word
especially in corporations yes it is you
can actually get two keyboards and USB
keyboards they work together then you
can fight over the mouse yes you can
call extreme programming sometimes or a
gel again so you're asking this general
open-ended question and it's very
specific to what you're doing what
you're building so what is will be my
advice is choose a framework that what
they thought about the stability right
so will be an example of extremes so for
example Ruby and I'm not saying group is
the answer I'm just saying Ruby and
rails they spend a lot of time making
sure that they have a testability story
so rails I think part of the success of
rails is the very fact that not only do
they give you a language and a framework
but they also give you the whole
methodology so you know if you're
building a rails application this is
where you put the controller this is
where you put your tests this is how you
run the test this is how the whole thing
is broken up and it's all laid out for
you so that you can just kind of go
ahead and start it on the other hand if
you choose a different framework let me
think of one what was the thing popular
in Java for a while a long time ago so I
want struts for example Jones didn't
ever really came with any testability
story like it was just a framework by
itself right and so already you know
it's harder for you because if that's
what you're introducing to the company
not only the people have to learn struts
but now we also have to introduce some
kind of a testability story and given
that struts was not written with proper
testability in mind you're gonna have a
much harder time doing it so my advice
is just choose pieces that that that
have already testability story in there
so I'm hoping is that as as the industry
evolves basically we realized that when
frameworks are being done the
testability story of that framework
really is just featured just like
anything else and so I'm hoping that
when when people are going to be
choosing
or a over Fame and be one of the
features would be hey does the framework
have tests what's the coverage and do
they have a story for both unit testing
and end-to-end testing oh that make sure
you have a testability story part of the
framework that you're building should
really be how do I test different pieces
like you should think about it from day
one it's not something that you really
your users should be figuring out you
need to deliver to them not just a
framework but also a story of how you're
going to test this thing
I'm sorry can you speak up I'm having a
hard time and there's a mall there's a
microphone coming your way check check
um application that a cross-platform how
would you test for that if you have
environments that cross-platform ah you
mean like a the chip tester multiple
browsers multiples or even that new
application that allows you to develop
one application that will work on
multiple phones yeah I think it really
comes down to the same story I'm sorry
I'm gonna sound like a broken record and
that is that you need to have a
testability story with it so if you have
a choice between two frameworks you know
one is promising that they have a
testability story and the other one
isn't that makes that should be part of
your decision-making process and if you
wanna choose a framework that doesn't
have it
you really should part of the whole
design process you figure out like how
am I going to test this thing if it's a
web browser maybe you can use something
like selenium front and this and then
can I write my classes for that
particular framework in such a way so
that there is a testing story
involvements as well maybe you if you
for example choose a framework that you
absolutely have to use but it doesn't
have a good testability story for
example servlets are a perfect example
of that testing a servlet is next to
impossible part of the reason is because
the server the method for example do get
or do post takes HTTP requests an HTTP
response and I'm instantiating that
class is next to impossible and that
requires other things and it's cascading
things like pulling on sweaters the band
never comes on a thread in the sweater
right so in that case what you need to
do is you need to build a tiny layer
between yourself and the frame world it
presents the testability for you so if
you're going for example the side that
servlets are the answer and the first
thing you need to do is build a really
thin layer almost like a veneer between
your code and the servlet so that your
code never talks to these offending
objects like HTTP requests an HTP
response because those things will be
causing troubles for you later on
Deb data oh I see what you're saying
you're saying that if you want to do an
end-to-end testing you probably want to
have some data sets together yeah sorry
that's kind of a little out of my what I
focus on because my focus really is on
unit test and you really ask in an
internal question then don't don't
really have a good story for you there
sorry
wisdom request/response mm-hmm I can
create like default constructor for
server and instance aid with is it
reasonable to use that right um yes and
no um it is reasonable because it's
better than what you had but in a long
term you don't want to be mocking out or
stubbing out HTTP requests interesting
response right because good back to this
example we had over here if I had a user
class and suppose a user asks for a
cookie as the constructor and so Spring
Framework comes along and says don't no
worries
we got a cookie fake cookie for you that
you can make now it becomes this trouble
something because you got to make the
fake cookie and then you have to compute
the Q key because Q is just a string you
got to put the string into the cookie
instantiate the user and then hope that
the user reads the cookie and then
probably talks to the database in order
to get the user data right is this
convoluted way like it's testable but
it's not clean so a much better design
is to say in FML user class is just a
value object it is not responsible for
reading its fate
right put that information somewhere
else and then have the user simply take
a string which is the user name so now
if you have a third class called
Authenticator and it says I need a user
it's piece of cake to instantiate
because you just make a user set the
user name and you're done
so these these patches that we have it
allows you to instantiate how to test
objects like servers and cookies etc the
nothing but really they're not going to
solve the save you from death by a
thousand cuts because yeah it's a little
less miserable but it's still miserable
bitch could we have a question over here
yes hi my kiss is a bit surprising maybe
it's I hardly have specs or requirements
or cases and my application is like a
software for emergency departments in
the hospitals and they used to hire like
clinical nurses who have smart enough
who are smart enough technically
eligible so now they want an automation
application so that's why they hired me
so it's not exactly an automation they
want an outer magic so they want me to
perform everything you know they hardly
have specs or x/r test case so what do
you suggest or which frame up do you
want me to follow do you want me to
write a test cases first or no so the
scenarios so you have a bootstrapping
problem right like how do I get myself
going over here and in a situation like
that you know test first meg has no
meaning it really comes down to is step
one I need to figure out a way to write
and automate it whatever right and that
might be a really hard thing and maybe
maybe it might be something as if it's a
web app maybe you can look into selenium
which means the only thing you have is
into Xcode application or desktop
application so desktop application and
I'm sure there is some kind of robots
that will pretend to be user clickers ah
it's a horrible security people record
and replay thing but that doesn't work
it right so that doesn't really work and
the reason for that is because you don't
want to do record and replay what you
want to do is you want to build up a DSL
you want to save yourself like you want
to say go click on patient details right
and that method should go figure out
where the button is and do the right
stuff etc it's it's not the best
solution because really what you want to
do is you want to be a layer below it
which is that you want to say forget the
you are I'm just talking directly to the
controller object and calling the pride
method I have to verify that the right
data is being loaded but given the fact
that probably was written without the
stability in mind it might be the only
option that you have
there were notices before it was
Fox propagation and they are upgrading
to dotnet and it's all like cut and
paste like patches all over it's like a
help for me I've been working there for
many years so there is no magic like I
said earlier like there is no magical
answer for you right it's just you know
one miserable step after another like
figuring out how I can put some kind of
a test framework on it how I can build
some kind of a domain-specific language
around what I'm about to test because
doing clicks will simply drown I will
drive myself to too early you know in
the whole mess of things
so just abstract away from it and just
accept the fact that this will probably
never be the sexy superfast application
that you can on every save verify
everything but it is possible through a
lot of blood and sweat to get there yeah
right now I'm automating in the
scenario-based like you know they have a
test case for like you know issuing an
order completing an order yeah so that's
important to have stories like I said
earlier all right thank you yes um I was
just gonna say more about how I got into
testing I mean I'm sure most everyone in
the room has done this where you're
running some piece of code and you're
looking at the console you're looking at
web page and you put some sort of print
line system probably also know that and
you're looking for a value so you were
doing a test there you're expecting some
kind of value so if you run that even
once or and certainly if you've run it
more than once you might as well write
the same amount of code as a test where
you say instead of expecting to see this
on the screen
you're just in a test you say this is
the value I expect when I put this value
into a method and I got started in a
very small way just we're just testing a
handful of tiny methods are really
simple and it's gradually built up and
built up on the project I'm doing I have
hundreds of tests now and it to me
that's a much better kind of metric for
how successful the project is and how
much progress I've made because I've
actually each one of those tests test
something real which I really want to
happen in the system if and the other
thing I'd say is always to try it when
you start off it's quite easy to end up
testing things that isn't your code so
you end up testing libraries and things
like that so really think about it it's
where your own logic is is what is it
that your code should be doing rather
than
so testing whether it'll get something
out with a database because hopefully
your RM is well tested well that's a
great story if anybody else has a story
like that the show yes if you have a
story yes the question was do you have
any texts or papers or books that you
would recommend that expound upon the
subject well and you're promising as I
asked that ah there are a good books
Yegor thing can you suggest something
yeah I think that's were just available
if you're doing JavaScript there was
another one growing object-oriented
software through tests I think it was
called there's always my blog also
another Googler James Whittaker is
written here yes would it go with two
t's that's right yeah google's java
reviews guy yes
so I personally found the Google gel
reverse guide very useful so I really
recommend that one I have this bug in my
Mac that if it wakes up sometimes I
don't have a keyboard but if I put it to
sleep and wake it up again the kibo
comes back yes I work at a age encima we
do a lot of web development server side
and front end and our automated builds
are really good at testing every time
there's a check-in however we have
problems with the front-end and the
JavaScript code is there anything that
you know of or Google might use to
emulate a web browser or Dom or a
JavaScript rendering engine so we can
actually tester right see a couple of
Justice one is something like selenium
right that's an excellent runner world
web driver selenium kind of would use
for end to end it depends what you
wanted to assert right do you want to
assert that the page looks renders
properly or do you want to assert that
the when I click a button right stuff
happens right so they're different
extremes over there so a good framework
would help with rendering again a little
shameless plugs I'm working on the
project called angularjs there we focus
quite a lot on testability and also
making sure that rendering is easy so
again it's just a choice of your
framework that helps a lot in that in
that situation
that's the URL I'm not sure why my
Internet's not working but s0 I thought
I have but you know why it's not running
yes let's see what's going on with my
network sorry I'm gonna try to debug in
other questions yes back there oh you
just wanting or is there at least a
design pattern for sandboxing that so
that yeah so the general answer that is
it's always the everybody has a like a
you know I showed you the super bug on
the end right everybody's like yeah
Michael's different I got this big
problem and usually what it comes down
to is you're doing too many things and
you need to decompose it right so break
this down into smaller problems and then
the smaller problems usually are
testable and these very specific
questions it really comes down to you
know somebody on a team really caring
about it and spending a lot of time
trying to figure out like how can I
break this thing down so that different
concerns are separated so that I can
test these things in pieces so we've got
some we've got a question over the other
side of the room go ahead as well hi I'm
a TDD new I'm a veteran of the cowboy
camp of coding and I have a project up
I'm right over here
I've got a project upcoming which is
just me and it's about two weeks long
it's an ideal candidate to they sort of
do this for the first time it's in
Python and I'm planning on using Django
for it and is there anybody out here who
who's built it or built a lot of TDD
stuff with Django or Python they could
suggest maybe a quick start path
something I could look into to actually
running and learning during the course
this two-week project anybody's other
suggestions I'm not a Python guy when
I'm trying to learn new languages or
anything like that I usually try the arm
like they call them like a like Python
challenges or you have to code to fix
what they looking for you can look them
up on Google Python challenge on they
give you a scenario where you have to
decode something and you had to write a
Python code to fix it or to decode their
code um there's a lot of them like that
like um when I was learning about um
security I want to hack the site that
work and it will show you how to write
how things are hacked so that way you
don't have to secure it I mean they got
different levels and stuff like that I
did the Python one where you had to
decode a layer of um coded um and you
have to translate it back to English to
know how it worked and you got to use
Python to fix that problem is called the
Python challenge so to add that this
might not be obvious is that it a lot of
people when they start to do unit
testing they somehow come to it from the
point of view I gotta test the whole
system end-to-end right and try to give
up on that idea and rather say start
small and say hey look there's this tiny
little method it almost does nothing
sorts people by age right can I write it
small little test that basically asserts
that that method works from a B this is
part of a larger web application that
allows you manipulating your address
book and that's one of the features to
sort of by birth date and that's a
method right let's start small start
saying hey can I write a test for such a
utility method and then maybe you can
grow from there and say well can I write
a test to read from the database and can
I write a test for a controller such
that I can replace the real database
with fake database and that really would
really will force you to restructure the
code so that you can decouple the
controller or the behavior of a page
from the persistent storage all along
what you're doing is you're not really
doing any kind of assertions about the
UI because as I said UI is really
difficult to test and it's hard right so
don't try to pretend to be the truth the
user and writing an end-to-end test
usually that's more than then it's worth
fighting for rather start small and
slowly build up experience and get
better at it and grow it and then over
time when you have this experience
you'll be able to say well this is worth
this thing and maybe this one is more
effort than it's worth or I can do some
Trados or maybe that's just a UI or
something like that and maybe have an
end-to-end test framework added to the
mix so it really is a continuous process
that you just simply get better at it
over time it's not just a magical thing
that just happens right we've got time
for maybe two more questions
and as you good and Iseult try to push
the limits and get sorry the question
was he's saying start with the most
trivial methods and then grow from there
to get methods that are more and more
complicated the answer is yes that's
exactly how you learn you just get
better and better at it you know stuff
that even the most trivial method to
test will require you to have some kind
of a test harness require you to have
ability to run this thing in a
continuous fashion to run it maybe on
regular basis to manage your tests and
as the tests grow to have some kind of a
strategy for it and all of these are
learnings that you're going to gather as
you're as you're doing this and all of
these are unspoken things that in the
background that you just have to know
how to manage this process and you can
learn it whether it's something
complicated or something simple so it
starts small and just grow with from
there so two more questions I think you
already asked you guys all had a lens
and chance to speak okay sorry I thought
you did little bit this thing was just
QA testing yes so my thought is that
developers absolutely have to write
tests and their job is to write unit
tests the second level would be the QA
so there's two kinds of QA there is a
what I would call exploratory QA which
is that you have a system and nobody
really wants to be that guy who reads
the script and goes clicks on it right
if you want to automate they don't want
to have them but but it is useful to
have people and especially some people
are better than other that's really
twisted about hey can I enter some crazy
value into this thing this is
exploratory testing right and when they
discover something ideally you want to
turn that into another story inside of
your reservoir of tests it's one kind of
testing the other kind of thing is well
at least in Google we call SCT software
engineer and test and their job is to
worry more about the end-to-end
harnesses and the frameworks right so as
an engineer as a software engineer my
responsibility is to write the unit
tests I think a good engineer should
also worry about how the influent
framework should work but in this
situation it is used useful to have
specialists to basically come in and say
okay if you've done your unit testing
properly then let me help you write a
end-to-end story and then it's
everybody's responsible to add to the
reservoir of the end-to-end test but
it's really a different kind of a thing
so that's kind of how the breakdown
should happen in theory in practice you
know things are slightly different
always and one last question thank you
for the talk
my question is based on this lot of
legacy code right now existing in Oracle
PL sequel do you have any advice on
setting up a test harness for that and
testing that PL sequel ah well if I was
faced with that right the first thing I
would try to figure out is read set of
scripts so that I can bring up a
database when the resets and a reset its
state into a known state probably an
empty state and then have some kind of a
harness that can go and write and read
into the database and then build up
scenarios from there this what you're
describing is very much an end-to-end
test right and it comes down to I need
to build some way of executing a set of
sequels so that I can create scenarios
and once I have scenarios I'm going to
drown because it's nothing but a whole
bunch of sequels so I need some kind of
a domain-specific language so I can tell
stories so it really is kind of a
progression can I execute sequel if so
can I turn it into stories next level up
I think we're out of time Howard yeah
exactly so please everyone please help
me thank visco for coming out</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>