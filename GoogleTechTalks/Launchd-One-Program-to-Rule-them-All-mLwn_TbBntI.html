<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Launchd: One Program to Rule them All | Coder Coacher - Coaching Coders</title><meta content="Launchd: One Program to Rule them All - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Launchd: One Program to Rule them All</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mLwn_TbBntI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi so thinks things get complex in early
Unix the the init program was like three
four hundred bytes and what happened
over the next few decades you know like
there's in the ad there's RCD there's RC
there's AI net DXi net D system starter
at the carrandi watchdog D this D that D
and then Apple did something cool in OS
10 which is that they they consolidated
a lot of these and they just had one D
called launch T and most people know
what it is if you use Mac OS 10 if he
was tiger or leopard or if you use an
iPhone launch D is running most of the
time and who better to talk about launch
D than the person who created it so I'm
very glad and happy to have Dave's
Darvish key amongst us today
he's the guy who wrote launch D he works
at Apple and he would tell us about you
know what launch D is why he did it or
you know whatever else you might want to
know so let's welcome Dave all right
thank you very much I'm glad to be here
so I'm going to talk about launch T and
managing processes with it but first I
want to talk about the big picture and
kind of what led to launched at Apple so
we're Apple we've got some goals we have
a culture we try and create products
that people want to use and we've got a
wide spectrum of products we're not just
looking to create computers like what we
have here you know they're
general-purpose can do it with just
about anything you want we have very
embedded devices we have the phone we
have the TV and to that point only one
of these has terminal well two out of
these have a shell but in the long run
probably the computer is going to be
only thing left with a terminal in a
shell the rest of these are much tighter
knit a much more controlled circumstance
but you really got to begin to ask
yourself what's a UNIX and what's an
operating system if
you know how do you define it is it the
api's is it the user experience who
knows you can call this all UNIX or you
can call one of them UNIX but I'm gonna
talk about how long he plays into all of
them so we have some design goals we
have some very interesting design goals
design goals that weren't like your old
mainframes namely we don't want to
restart any application or any computer
after a configuration change yeah UNIX
people like now you've got a server it
never reboots not at Apple we got a plan
on applications dying and we need to be
able to deal with that plus you know you
change IP addresses not such a scary
concept these days but you know 10 years
ago a lot of software would have to be
rebooted if you change an IP address not
so much these days we have some other
goals though in particular we're always
pushing everybody at Apple to write more
dynamic software we have hot plug
hardware these days we have wireless
hotspots and we we all want them to be
user friendly and I picked the airport
Express one of our products to exemplify
this this is both a wireless base
station and it's a device as far as the
iTunes mp3 player is concerned I iTunes
finds it and allows you to play audio
through it but it all doesn't seamlessly
through the UI but another thing that we
have to worry about
we have multi-core CPUs we're trying to
figure out how to best take advantage of
them and some of it will be done at a
very academic CS level but a lot of what
we deal with is an academic and we're
trying to design a system that can deal
with the actual functional things that
operating system does and deal with add
more concurrency there another challenge
that we have and I'm gonna pull up one
of our web pages here is we need to work
in low memory scenarios this may seem
like a lot 512 megabytes but what you
need to realize is there a few thousand
developers at Apple
there are thousands upon thousands of
Ella pers outside of Apple and we have
to share all that and when you start
doing the math you're like wow okay each
one of us gets a little section to play
with and if we don't want a page well
launch D helps improve the situation too
by only running software when you need
it we'll talk about that more later
now what are some obstacles we face and
trying to make much more dynamic and
robust system well the same goal that we
have is actually a challenge life is
more dynamic the problem with a lot of
the software that people have written in
the past is they make assumptions
and for some people make them
pervasively and we continue to push
people inside the company and outside
the company to make less assumptions and
when you make less assumptions you
software a more reliable and your
customers are happier now we also push
people to be more event-driven this not
only improves concurrency but this
improves our button robustness you can't
always anticipate what order events will
occur in so if you could just respond to
them as they come in your software will
behave much nicer and this is what we
push people to do at the Apple and
outside the company and this is how it's
going we also encourage people to be
more flexible and error make better
error recovery again on that assumption
theme if you build up assumptions you're
building up a house of cards and with
the house of cards all it takes is like
a little puff of air or something bad to
happen and the whole thing collapses
nobody wants that but it also improves
the user experience more flexible your
software is the more you can deal with
potentially unanticipated scenarios your
customers may encounter but more than
anything we want to avoid this scenario
nobody likes it when their computer goes
down especially catastrophic ly so what
do we do to accomplish our design goals
well one thing we did was this launch
new project which I'm going to talk
about going into more depth launching is
actually really simple I have two
pictures to show you what I mean it's a
life guard it watches a process if it
had crashes or restarts it it's also a
telephone operator what it does is help
processes find each other and
communicate with each other that's
really it and two things this is what
launch D does now
there's a lot of details in this and you
know monitoring processes help them
respond acting as an arbiter and of
inter process communication but this is
it in a nutshell
now in leopard our operating system
soon-to-be-released launched he's been
very successfully adopted there are 166
launch day jobs in
leopard and this isn't even talking
about the phone or the TV or potentially
other projects we have of the company or
the server product wash T is actually
very well received and this is
understating how well it's been received
at the company in fact it's being used
in all layers of the operating system
from basic airport functionality which
many of you may think of as a driver all
the way up to x-ray which is our one of
our debugging tools for introspecting
the behavior of an application all of
them are using launch T at some level
now why are we doing this why launch T
what is it getting us
well it's getting us false isolation and
error recovery
what launch T allows us to do is divide
more of the tasks that a computer's
trying to accomplish in two separate
address spaces the more separate address
spaces you have the more fault isolation
you can have and the error recovery side
launched deep like I said with life
guard analogy monitor is a process and
if it dies it restarts it that's huge if
you look at system starter barsy or a
lot of these things it's fire-and-forget
hope for the best and if something goes
wrong hopefully someone will get paged
and reboot the computer launch deep yeah
we'll just monitor them we'll restart it
but going back to that multi-core theme
launch he's also getting us fully
asynchronous bootstrap way more than the
parallel start if you've seen with
scripts launched he launches any process
in any order it doesn't matter actually
with launch T and we'll go into why
later but this is huge on the multi-core
systems we can launch as much as
possible and let the hardware and some
of the lower level software sort out
what needs to run and when on the flip
side launch the encourages pay as you go
I'll demonstrate this later what it
watch T allows us to do is only run
software when we need it nobody likes
paying for bloat nobody wants to see
that stuff in there either their process
output or their memory usage why should
you pay for a feature you're not using
launch T makes it easy to pay as you go
and finally on security this is
something I'm really happy about
we at Apple are using launch D to get
rid of set UID the whole concept gone it
isn't completely gone yet but we've stem
the tide of new set UID binaries and the
way we're doing this is through
privileged separation
and the way we do that in launched is
you can have a process running an
unprivileged space and via launch D and
through the inter process communication
that telephone analogy we're making it
possible for the unprivileged program to
find the privileged program and have it
do a special task you could this is
really neat now we're allowing for
privileged tasks to not necessarily be
the kernel it could be some daemon and
through inter process communication we
can do privileged operations so let's
start going to depth less of these big
pictures things masti is open source
apple really values what is doing for
the company so much so that we actually
put it under the apache license and made
it open source if any open source
operating system would like to get some
of the same benefits we're happy to work
with you and integrate launch the end of
your product there's a URL right here
where you can track the CVR SVN commits
as they come there's a few mailing lists
I'm pretty low traffic but if you have
any questions or curiosities that's the
place to go so what are we going to
cover tit tape well we're gonna cover
some things for developers like where
does my code fit in or when does my code
get invoked or how does my code resolve
dependencies or how does my code check
in with launch t4 sis admins we're going
to cover why launched he's a good thing
for you because it's not just all about
developers it's sometimes sis Edmunds do
need to get involved so fitting into Mac
OS 10 we have three basic layers in the
operating system now we have a per
machine layer a per session layer and
inside the per session layer you'll find
basic applications like Safari our web
browser or iTunes our mp3 player or some
processes you may not realize like the
system UI server which presents things
like in the upper right-hand menu or the
you have those many links we also have
some per machine concepts things like
our disc arbitration daemon for doing
mounts when a disc is plugged in or
kekstee when new hardware shows up it
finds the driver and loads it up into
the kernel or config D which monitors
networking changes and configures the
network for you
but we've added a new layer in leopard
and we're calling the per machine
context and in this permission context
we are anticipating processes that fit
in between here so we have G SSD which
helps manage Kerberos credentials and
get them in the kernel but it acts on
behalf of the user we have the C cache
agent which manages and caches Kerberos
credentials or we have things like the
SSH agent which is a another credential
caching mechanism and I'll get into more
what these layers mean later these
layers though have a relationship in
particular when it comes to inter
process communication here's what can
happen we have applications we have
agents we have demons these applications
can talk to each other either way a to
BB today agents can talk to each other
and Damons can talk to each other the
other thing that can happen is
applications can talk to agents or
demons or agents can talk to demons and
there's a good reason for this and I'd
like to go into Y so Y only downward IPC
well we have this machine layer like we
talked about we have sessions oh wait we
can have multiple sorry per user context
we have Bob's background context and
Sally's there's more than one in fact we
can have multiple sessions too we have
GUI sessions we have maybe command-line
sessions we have yet untold sessions
maybe there are FTP maybe there x11 and
what you see is the downward only IPC
encourages well layering the problem is
if you're at a background layer not a
background if you're at any one of these
lower layers and you're trying to
communicate upwards you have a question
of which one thing you want to talk to
do you want to talk to Sally's
background program or Sally's Finder
process or web browser or Bob's well if
people arrange their designs and their
inter process communication so they only
communicate downward when they're asking
for requests or help
it's very implicit which program you
need to talk to so that's why we
encourage in the product so to go into
depth on these container
we have per session every process that
lives in here should or probably
interact with the user and these are
programs to come and go with a session
so when you log in the finder gets
launched our that's our file browser and
you probably want it to go away when you
log out so this is our per session
context so we like to talk about we also
have the per user context we've been
describing this is for programs that
don't need to interact with the user and
probably want to transcend login and
logout so let's say you wrote your own
little personal web server and it's
running on 8080 well you don't want that
to go away when you log out but it's not
necessarily the web server for everybody
on the machine what you can do is place
this program in our per user context and
that's where to live I'll get all the
support services it needs and you don't
need to worry about login and logout and
finally per machine what we're really
encouraging developers to do is run as
little code in this layer as possible it
should be code that is only required to
arbitrate or share Hardware between
users and most developers seem to be
buying off on this concept they
understand the risk of operating at that
layer and they're trying to move their
code upward on the stack so let's get
started how would you use launch D it's
actually really simple Apple has a
property list concept it's a standard
way of representing basic CS types be it
integers or dictionaries or arrays or
strings and you're gonna place one of
these configuration files in a
well-known location Apple has a pretty
standard schema for that I'm gonna go
into some of the examples of that we
have library launch damon's and these
are per machine jobs installed by the
sysadmin or we have system library
launch damon's these are machine wine
programs supplied by apple now in your
home directory you can have library
launch agents
this is programs you want run for you
either as a part of your session or your
background session and they just apply
to you in your context
but let's say you're a sysadmin and you
want every machine on the network to
have maybe iTunes launch
you could install a property list in
Network library launch agents and now
every machine on the network will pick
that up and get that program running or
maybe you want to limp with the scope as
the sysadmin you could install a
property list in library launch agents
which is just the local disk these
configuration files will just be loaded
up for each user on that machine
and finally Apple of course supplies
some launch agents and you can find them
on Leopard and those are installed in
system library launch agents now what
does this configuration file look like
it's actually really simple there's
three basic keys you have a label which
is a unique identifier for a job and
it's permanent so unlike a pit which is
ephemeral a label like com dot a poll
dot config de won't change even though
config D may crash and be restarted you
also need program arguments and here's
where I need to give a apology this is
more confusing than it needs to be it is
a I'm gonna just read this off because
it's the best I could do a pre tokenized
array of strings that corresponds to the
second argument of Maine including Arg
b0 that part trips people up so maybe I
should say that differently this is the
second argument of exec V if you know
UNIX the first argument will be inferred
if it's not supplied via the program key
I'm really sorry this is more confusing
than it needs to be you can see the
launch D and exec and man pages for more
information and finally one last key on
demand setting this to in false implies
that the program should be kept alive
indefinitely and this tells launch e to
restarted that's it that's all you need
to do to have a program on Mac os10 be
kept alive as long as you want so what
does that look like in the real world
well this is what one of our property
list looks like it's a twist on XML we
have a dictionary and inside the
dictionary we have a label and the key
the value of this key in this example is
comm dot example dot hello d this is the
name we've given it we have the program
arguments in this case it's user s been
hello d and finally on demand false this
simple configuration file will keep
hello d alive on macros 10
now let's talking more about the schema
there are more keys than I could
possibly talk about and I don't want to
put you to sleep but to give you a few
examples of other things you can do
let's look at you can set the current
working directory you can set
environment variables you can set the
program this is to skip path traversal
or do funky tricks if you're a UNIX
expert there's a username key there's a
start interval and start calendar animal
keys and for there's a limit load
accession type if you only want the
program scoped to different kinds of
contexts so be it the you know when
you're logged in at the GUI that's the
aqua context you can say background for
the if you wanted to transcend your
session and for those of you doing
really funky things and you want a
program to be running with the login
prompt you can say login window and when
I bring all this up as a sysadmin you
should be saying yourself wow this is
actually kind of cool
we have a standard schema now for
representing all the attributes of all
the processes that are running that I
might care about so unlike a shell
script where I might just have to grep
for maybe the nice key you know nice
command and hope for the best or you
know CD and hope that you know that
isn't a part of some setup but it's
actually the ultimate working directory
that's just you know hodgepodge with
launch D now you have standard
configuration file representing all the
process attributes in a standard schema
makes it very easy to search and change
things systematically now dependencies
dependencies is a topic that has come up
time and time again I'd like to go into
them in depth right now and explain
apples perspective on how they work
dependencies at its basic layer a heart
contract programmers work with contracts
that's how we get our jobs done there
are two kinds of contracts one
programmatic and one the most people are
familiar with and they think about when
they program because the programmers and
these are every API you've ever used but
the one that we sometimes forget or the
data during contracts in fact this is
what launched these all about every
configuration file is a contract with
launch T about what behavior you can
accept
and how does it start manifesting itself
well let's talk about resolving some
issues at average Damon right or my face
if you're worried about networking state
like when the network gets plugged and
unplugged or what the IP address is when
you boot up we have an API framework
library called the system configuration
framework you can use that you can
register api's and find out when
networking changes or what the current
IP address is or is on resultant respond
to these events and for dis changes we
have the disc arbitration framework you
there you can find out when volumes are
mounted unmounted and maybe do things
with them or let's say device discovery
the goal here is again the i/o kit
framework if you want to find out when
the USB device is plugged in or a
FireWire device or whatever
io kit is the way to go to figure out
when those devices show up and deal with
them accordingly so there's a trend here
if you want to find out what the state
of the system is when you boot up use a
framework that framework will not only
tell you what the state is but it'll
tell you when the state changes in fact
let's look at this even further when a
program in the old UNIX world booted up
they declared what other programs they
need well that's really not the reality
of the matter what we have is of course
a one to one correspondence between
frameworks and processes so on Mac OS 10
a GUI app might use something called
core services and as a part of the
implementation details of core services
they have a daemon called core services
D you could again look at the disk
arbitration framework it's not the a
program that you write needs disk
arbitration D it doesn't what it needs
is a disk arbitration framework to
figure out when these events happen and
respond to them accordingly we can keep
going down the list some of these are
slightly less obvious our core graphics
library uses the process called the
Windows Server some core foundation uses
dis no D and the list goes on and on the
chief point here is that processes are
in implementation detail when what we
encourage people to do is use frameworks
or write them so let's say you're
writing one of these frameworks
all right well how do you find your
daemon now if we're gonna start
processes up fully asynchronously let's
deal with a case example going back to
the 70s classic API get PW name or name
or however you want to pronounce it
takes the log in and it returns a
structure to represent that login well
in the old days it previously read Etsy
password and that file was there just
read it directly and got the results and
gave it back to the application
but in Mac OS 10 we've changed it so
this API talks to directory services via
inter-process communication so the
question is how did we avoid a race
between a program calling that API and
the directory services daemon being
running and answering those queries it's
actually really simple if we look at
that standard plist again except this
time for directory services they added a
simple key value pair declaring what
mock services they've end they declared
their name in the namespace and the
value in this case is true because
that's all that's needed but this is all
I did I said hey I'm directory services
put my entry into the phonebook if you
will and that's the name in the phone
book and the way this works out is a
contract contract between launch D and
your program and what we promise is race
free IPC setup the way we do that is
that all the jobs were given context
let's say a daemon will be loaded up and
in to launch D before any one of them
starts running what that means is this
works for each layer we works at the
agent layer the log on window aqua or
standard i/o or works for background
jobs or the daemon jobs each layer is
configured atomically and once that's
done that means that a sorry once that
Sun that means that any process starts
up can find any other process even if
it's not running yet it can find the IPC
handle start sending it messages those
will get queued up until the daemon
actually comes online and starts
draining the messages well on the flip
side what is launching not promise you
well this goes back to that framework
conversation we don't promise any
networking is configured
we don't promise any file systems are
mounted fact not we don't even promise
that all the hardware is being done
probed yet your daemon might be running
before that point in fact nothing beyond
the ability to do IPC is done so what
does this mean use frameworks and make
less assumptions you know even servers
these days are being more dynamic people
are maintaining thousands of servers all
at once and they don't necessarily want
to configure a file on them they'd
rather just assign them via DHCP if you
want to change that you'd ideally just
like to be able to go to your DHCP
server and say this servers new IP
address is this and if the demons on
that machine can't handle that that'd be
really disappointing because you need to
restart them manually so oK we've been
talking about IPC a lot how do you
actually talk with launch T to get your
IPC handles so that you can actually
start answering a queries it's actually
really simple we have a basic boxed
object api's to start with the first
example we have the ability to box up a
C string into an object and we can
extract it if we want and we build on
this we have a checking API so you can
get your descriptors or your mock ports
from launch T and start answering your
queries from your customers or your
framework in this case and this is how
you do it you create a new string with a
magic or well-known he called check in
and then you lob it over at launch T via
launch message and launch T gives a
response if it gives null then there was
an communication failure with launch T
and that's it send a message over get a
message back from launch T and let's
build on this a little bit more and how
do you tear apart that response and
start communicating with your frameworks
well first we need to see if there's any
secondary failures maybe we were able to
talk to launch D but maybe there was a
failure and the requests that we made so
we'll check at the type of the response
if it's an error no then we extracted
and explain why something went wrong and
let's go to stage three how do we
actually iterate the data and get our
descriptors well we have a dictionary
lookup API we have a basic dictionary
type so we can take the response and say
hey was there a time out key in there an
advisory idle time out if the Damon's
not doing anything okay great let's use
it let's see if there were any mock
services oh great the dictionary lookup
succeeded let's iterate the results with
a callback based API and the same with
sockets we can look it up we have a
callback based API that you can use the
launch data dictator aid and let's show
what that looks like
Dictionary iteration is really simple
you're gonna get your callback called
for each object in the dictionary you'll
get the key for the object and you'll
get the cookie passed in or the context
or parameter or whatever you know
something so you don't lose track your
state and this just happens to print out
the key the pointer to the value and the
cookie and with these basic API is you
can start building the check in so you
can find your descriptors and find your
mach ports and then start servicing them
as a part of your event loop so talking
to launch team okay this is great we've
been describing the data driven
interface so far but we haven't been
talking about how you interface with it
as a developer is a sysadmin we have a
sub we have a command for doing that
it's called launch CTL and you can as a
list of subcommands you can say list for
example just list loaded jobs it has
load and unload for loading an
individual configuration file or
unloading it manually and most of the
time you won't need to do that but
because the system loads them for you
but if you wanted to manually load and
unload them you can do that you can
tweak the level of verbosity that launch
d cents to syslog via the log command so
log level debug is a very frequent
example for just getting launch to be
very noisy about what it's up to you can
manually kickstart a job if you don't
want to wait for your on demand criteria
to fire and you can stop a job which
sends the sig what ever the pit happens
to be at the moment and finally you can
say export to get the environment
variables that are loaded up in launch d
and last but not least there's help to
show you these and a few other oddball
commands
now things we've added for leopard
things that we're very happy about
mostly because we use them but we have
mock IPC now so it doesn't matter
whether your program your daemon your
agent
whatever uses mock or unix both of them
work with launch D now and either event
can cause the program to run this whole
agent and background context we've added
that so now you can have these programs
work at more than just the daemon layer
and finally we've added conditional
keepalive logic that some of you may
appreciate and will give us three
examples so keep alive as a simple key
you can add to your dictionary it's the
opposite of the on-demand true commit
one and in fact it replaces it so if you
say keep alive true that's the same as
on-demand false but given this is a
boxed object type system we can change
the value from a boolean to a dictionary
and start doing interesting things so in
this case with keepalive we have a few
examples we have successful exit maybe
you want a program to run as long as it
keeps failing but the second is succeeds
we want to stop running it so this is
what that says you can read it like so
keep alive as long as the program
successful exit state is false so that
means that as long as the program keeps
failing we'll keep running it you can do
the inverse by setting successful exit
to true which means as long as this
program exits zero will keep it alive
but the minute it crashes will stop
respawning it
another example is network state mind
you network state's fairly ambiguous so
I don't necessarily advise using this
key but you can still play with it
Network state keeps the program alive in
this case as long as the network is up
for some definition of up if you want to
do the inverse maybe if the network goes
down which means essentially no
interfaces that are configured you could
say a network state false and finally
one that people actually are using and I
encourage people to use at Apple is the
past state example what this allows us
to do is dynamically on the fly as the
file system changes keep programs alive
or based on whether a file
is there or not a file a path a path
exists or is missing so in this case
what this says is please keep this
program alive as long as the following
path state Etsy example.com f-- exists
maybe and this is a common paradigm
that's showing up in Leopard now so we
can have Damon's that are configured to
run when and if their configuration file
exists and this is very handy it means
that the minute the user configures
something maybe via GUI and the file
gets dropped down on the system launched
he notices and fires the daemon that
reads that configuration file and takes
action on it you can also do the inverse
if you want to do some kind of a
semaphore mechanism maybe you can have
one program run when a files missing and
another run when it exists so these are
three basic examples of conditional keep
wise now assumptions we talked about
these at the beginning sometimes you
need to work around them I'm going to
show you a basic example using shell
inter positioning with Apache so Apache
doesn't use the disk arbitration
framework to find out when disk come on
inline or not and it probably doesn't
use the system configuration framework
to find out when networking changes so
there are a few commands on the system
to wait for interesting conditions to
happen the system configuration
framework team has been kind enough to
provide a command that provide called IP
config and they have a weight all sub
command and what that does is it makes a
best effort for some semblance of
networking to be up and then it returns
now mind you a laptop like that can have
networking come and go all the time so
we'd still encourage the use of the
system configuration framework to
monitor for those events another example
of a quickie k-q command is wait for
path and what that does is monitor from
mount table updates and essentially
monitors the file system to figure out
when that path comes online once it does
it returns so at this point if we were
working with Apache and trying to work
around some of the assumptions that made
you could use these two commands to wait
for networking to be up for some
definition of up and you could wait for
the document route to be online once
that's true then we exact Apache with
whatever arguments are
to us so to rehash some our goals and
then get into a demo we would like
program authors to recover from errors
more often and lost you will help you
even if your program catastrophic Lee
dies we'd like you to use some of our
frameworks to monitor for events and
preferably if you can launch on demand
and the way that's done is via the IPC
that we've talked about if you're a
framework author please write a back-end
helper process and use the IPC features
we provided this is what will allow you
to launch on demand and pay-as-you-go
and now I'd like to get into some
demonstrations about how we've
integrated basic UNIX technologies with
summit with launch D and launching on
demand so let's see
I need to turn on mirroring just
all right
so to demo what's going on here I'm
gonna show off ssh agent very common ssh
command launching after ssh so if we
look we see that the agent is not
running but if we just type well ssh add
for example ssh add we'll find an
environment variable the this one right
here and it'll connect to it and it'll
start sending it data and by virtue of
doing that launched you will notice that
because it's helping hold the IPC handle
for the agent and launch the agent on
demand so if I dive S is a Chad and do
the quick PS again we noticed that the
agent is now running that - L says talk
to launch D and now the agents running
on demand what's great about this is
that environment variables now pass to
every app within your session so even if
you're running xcode for example you
could just open up terminal type ssh add
in your keys and then in xcode our
development environment your SBN commits
will now start using your keys so we've
got all that wired up for you another
example is the display variable this is
for x11 if we notice right now x11 is
not running and what we do is if we run
I don't know X logo it's going to start
up x11 on demand just by talking to the
x11 port oh well I'm running a
development build I'm terribly sorry yes
yes yes ignore yeah we're not quite done
yet but and for example
yes
I hopes of a temper right all right to
show you some of the examples of things
being respond on demand let me take the
what's a spotlight menu so that's
managed by launch T so I'm gonna see the
system library launch agents and so
there's a configuration file here for a
spotlight and it's real simple
keep spotlight alive and what this
program corresponds to is actually a
little icon in the upper right hand
corner so if we unload it you'll notice
that it's gone now
and we can reload it and now it's back
we could also so we noticed that well
375 is the pit 375 is spotlight we can
kill it Massey already started and and
if you look very closely you would have
seen it blink in the upper right hand
corner so the example of that mechanism
SSH agent demos how using I PC can
launch things on demand and I'll show
you some few other things for debugging
so you can say list these are all the
jobs loaded into launch deep this is
your launch t2
each user has their own launch D and
that's a part of the security that we've
talked about so there's about sixty
eight jobs loaded up into the users
launch team and if we do there's about a
hundred and one loss of jobs loaded up
into the system context and this is
really powerful since of course we're
restarting things when they die launch
CTL export
so these are the environment variables
that every job gets loaded up with and
launched t some of them are vented by
the jobs themselves like SSH ah sock and
the display variable from the x11 job
and let's see I think that's it for
demos of course I could be really mean
and kill all login window and the whole
session will be blown away and login
window will get restarted by launch T
and auto log me in again so this is what
launched on demand and error recovery
can do for you it's really powerful and
I think with that I'm going to jump back
to the slides
oops
all right and oops so we have some more
information if you want to rehash we
have the open source website and if you
need some documentation a lot of this
was covered at WDC our developer
conference and you can go there and
finally let's I thought I'd clean that
slight up but it's going to Q&amp;amp;A so
thanks a bunch if you start a process on
your own and will launch the monitor
that and restart or it will be our only
if I start the process through launch T
so launch the only monitors processes
that it knows about so it's all that
data driven configuration files so if
you at the shell run a program it's not
going to restart it for you since things
yeah
on the right here there's a lot of
cross-pollination it seems now between
opensolaris and Mac OS X and I was
wondering if SMF is in any way
influential and launched to your if
there's any cross-pollination of ideas
there I actually had the opportunity to
run into one of the authors of SMF at a
different open-source conference and
we've both laughed because we developed
these independently and they came out
about the same time a couple years ago a
lot of similarities actually there are
yeah there are yes so one of the
questions I had then is in terms of
launching a job through a script does
the launch D know that the children
launched by the scripts are to be
watched and restarted or does it at like
how does it keep track and know when to
restart that the philosophy would launch
T is a delegation of responsibility so
launch D babysits the process it
launched and however the implementer of
that process wishes to solve their
design be it as a script with sub
processes or a fork and exec model with
like Apache that's up to them
and that's none of launch t's business
and we assert that by saying look we'll
monitor this process if it exits or
started so we don't we didn't do what
Solaris did which was rewrite the kernel
to babysit random processes so if it's a
script in the script exits then our
restarted would be started which may not
be what you want see we'd want to
probably not have the script to exit
write it we discourage for can forget is
there any other question and back with
the microphone yeah I was wondering if
there's some way that you could specify
that if a program is crashing on boot
repeatedly to not continually restart it
for example x11 there is a throttle
interval and that's actually why the
dialog box was coming up about every 10
seconds what surprised me though is that
I killed X logo so that I PC should have
drained the queue because but it didn't
so that's something I can look into but
that throttle interval controls how many
times want the process will be spawned
so it's not in the default 10 seconds so
it's not 10 seconds since it exited it's
the process needs to live at least 10
seconds so if it lives 3 and dies will
throttle it for 7 more seconds and then
respond it so will spawn it any more
frequently than 10 seconds and you can
configure that it's just another
parameter in the property list okay oh
and there is one knob say I believe the
security server uses it on Mac OS 10 to
say launch only once so if it exits
launch T promises never to restart it
I'm the right again when you showed the
environment that's exposed is that
cumulative or is there a way to have
like private environment variables so
that I could have maybe the same process
look differently in like two separate
instances so if I understand your
question correctly each job can have its
own list of supplemental environment
variables that can either add to or
override what they inherit so if you
wanted to have to process you know two
copies of X Emacs running each one a
different environment
we can do that with two different jobs
anybody else
thanks for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>