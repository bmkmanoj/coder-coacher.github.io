<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Factor: an extensible interactive language | Coder Coacher - Coaching Coders</title><meta content="Factor: an extensible interactive language - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Factor: an extensible interactive language</b></h2><h5 class="post__date">2008-10-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/f_0QlhYlS8g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody I'm saw a best-of and
I'm here to talk about the factory
programming language factor is an open
source project that I've been working on
for five years now and first of all to
give credit where credit is due
factor borrows from three other
languages fourth Lisp and small talk
fourth places an emphasis on short
definitions code reuse and meta
programming Lisp of course is famous for
the code is data macros simple syntax
all of that and small talk has an
interactive development environment and
factor borås features from all three of
those for this tech talk I wanted to do
something a little different than the
talks I usually give about factor
instead of explaining all the language
features in excruciating detail
I'm trying more to focus on examples and
of course if something doesn't make
sense you can ask questions but mostly
this is about getting the big picture
out rather than the details of the
syntax and so on just to keep things
more interesting first I'll give an
overview of what the language is all
about and then we'll dive right into
looking at some real code so factors a
stack language which means that
functions which we call words they take
inputs from an operand stack and they
push the results back on the stack and
at first this may seem a bit strange but
during the course of the talk you'll see
all kinds of neat idioms and code
examples where this works out really
well factor supports functional
programming which for me mostly this is
about functions as first-class values
and anonymous code blocks which can be
passed around and we also do emphasize
immutability but we don't enforce it
there is still mutable States so it's
not purely functional but it supports
functional programming factor also
supports object-oriented programming and
for me this is mostly about runtime
dispatch and polymorphism factor has a
very rich library of data structures we
call them collections and often you can
use collections such as sequences and
associations in fact
in other languages you would define new
classes and this is very nice sometimes
because there are many words in the
library for working on collections which
are very powerful finally we have a we
have a very powerful input-output
library and a lot of the language
features make it easy to interoperate
with other languages other programs and
stuff like that
for the cases we're using the stack
isn't so nice
we have named local variables and this
feature is implemented as a library and
that's just one example of a common
theme and factor where language
functionality is implemented in the
library and this keeps the core very
simple and easy to implement and of
course the syntax can be extended
because of that the first example I'll
show you is probably the least realistic
program that you'll see in the stock and
it's the classical not quite hello world
but almost a simple factorial and a
factorial of an integer is just the
product of all the integers which are
less than or equal to that integer so if
you look at this code example the first
line just tells factor that I'll be
using a library called math dot ranges
and this defines a datatype for a range
of integers a colon begins a word
definition then the word name follows
and the thing in parentheses that's
called a stack comment or a stack effect
declaration and that just tells factor
how many values this word takes from the
stack and how many values that pushes
back then the definition follows and the
semicolon terminates the definition if I
click on the code example then it is
copied into the listener and the
listener is a tool where I can evaluate
factor code interactively so now let me
press ENTER and the factorial definition
has been evaluated okay I can invoke
factorial now and I push 100 on the
stack
then I execute the factorial word and
then I execute the dot word and the dot
word just prints the object at the top
of the stack so let me press ENTER and
this is a factorial of 100 it's a pretty
large number now let's go through this
definition of factorial here in a little
bit of detail just so you get the idea
of what the stack is all about I'm going
to press ctrl W which instead of
evaluating the code immediately it opens
it in a tool called the Walker and the
Walker steps through the code okay so I
press s now it pushes 100 on the stack
now I press I and it enters the
definition of factorial I press s again
and it pushes 1 on the stack and this
word here a comma B in square brackets
you can see it's a funny name for a word
and in Factor we allow almost any
characters to be used in word names the
idea is that you can kind of think of
nice conventions and you have freedom to
write your code in whatever way you want
now this a comma B word constructs a
range object from the number 1 and 100
and now we have a range on the stack and
finally the product where it takes any
kind of abstract sequence of which
arrange is just one example and it
multiplies all the numbers in that
sequence and now we have the result in
the stack and the dot word prints it out
okay so that's the single step or which
shows you what's on the stack at each
point now the next example it's a little
bit more complicated and this example
uses our SMTP library to send an email
the first line here just sets a global
variable with a default SMTP server and
this is the interesting part I'm going
to send it to my friend Doug who is
sitting in the audience there this
creates an email object
and I'll talk more about the object
system in a little while but basically
at this stage all you need to know is
that a word whose name is in angle
brackets is a constructor word and
that's again that's just the naming
convention for words that create objects
then after we have an email on the stack
we push the list of recipients this is
an array which contains a string and
then we call this word and this word
stores that array in the slot name two
of the email object and then similarly
we set the source address the subject
and the body and then we send the email
and this word takes the email from the
stack and sends it out that's just my
text editor I like to not have white
space at the end of Alliance or I have a
feature that does that okay and I'm
going to copy and paste this code into
the listener and in a few seconds it
should hopefully send the email
okay well I'll open a new window because
it looks like it's taking a little while
maybe the wireless here isn't so great
okay now before we can look in more
examples I have to talk about some
language features so as I said earlier
factor supports functional programming
and essentially code is data in factor
using this syntax with square brackets
you can surround any piece of code and
what that does is instead of executing
it immediately it pushes it on the stack
as a single object and we call these
quotations and they're similar to
lambdas or code blocks in other
languages words that take quotations as
input we call them Combinator's let me
see if the email got sent no it's
okay it worked earlier today yeah I'm a
member of the audience just said that
Google blocks port 25 okay yeah here we
go a time dad never mind about that
if port 25 was not blocked then the
email would have been sent
okay back to this so where does it take
quotations if what I call Combinator's
and in fact ER we don't have any
hard-coded control structures in the
syntax and all control floor is done
using Combinator's here I have three
examples the first example is a
conditional let me click on that
transport it in the listener the keyword
here is if now the if Combinator I can
press control shift H to look at the
documentation this Combinator takes a
boolean and a pair of quotations on the
stack and depending on whether the
boolean is true or false it executes one
of the two quotations so this is how you
do conditional execution and factor and
in this code example we start with 10 on
the stack then we duplicate it we check
if it's negative and of course 10 is not
negative so now this is going to be
false and the if Combinator will execute
the false branch which adds 1 to the
stack and finally dot prints it out so
we should see 11 and that's what happens
the second example we use the x
Combinator and this is another control
structure it takes an integer and a
quotation and it executes the quotation
that many number of times so this code
example should print a little message 10
times there you go
this example it's more complicated than
the others
so let's take a look at it before we
execute it first of all we have an array
of strings tomato orange banana and then
using the each Combinator we iterate
through the strings and we convert them
all to uppercase and we print the
into a file so how does this work well
the width file writer Combinator it
opens a file it calls the quotation and
then it closes a file and this is how we
do all input and output in factor using
Combinator's like this and it's a lot
more robust than the typical approach
found in Java for example where you have
to open a stream and then close it
manually
because here there's no chance of a
resource leak even if the quotation
throws an exception the with file writer
Combinator will always close a stream
and we have Combinator's like that for
all kinds of operations on files and
sockets and so on the using line here
that just brings in a couple of
libraries that we need for converting a
string to upper case and ascii encoding
so let me execute that and now the file
should have been created
oops
there you go okay so these are three
little examples where we're using
Combinator's as opposed to hard-coded
control structures that other languages
have now talked about the object system
there are many different ways of
defining what object orientation really
is but as far as I'm concerned the three
key ideas is encapsulation polymorphism
and inheritance in factor encapsulation
is handled by a different set of
language features this is called the
vocabulary system where words are
organized into vocabularies and the
object system does an enforcing
encapsulation the vocabulary system does
however the object system does implement
polymorphism and inheritance and the
Java Smalltalk Python Ruby Objective C
their approach to polymorphism is that
you have methods inside classes and they
use this metaphor of sending a message
to an object where you invoke a method
on an object and the object decides what
to do with this message and it acts on
it
and here's an example where I have this
is just pseudocode in some kind of Java
like language or I have two classes with
instance variables and methods inside
those classes and I can send an area
message to a rectangle and it tells me
what its area is or I can send an area
message to a circle and it tells me what
the area is functional languages like ml
they take a different approach and they
use something that's called algebraic
data types and the approach there is
that instead of having each data type
define its operations you define
operations on the data types so I define
a shape which is either rectangle or a
circle and then I say the area of a
shape is this if it's a rectangle or
it's this if it's a circle and the
perimeter
similarly we dispatch we switch on the
type
and we do different things depending on
the type and both of these approaches
have problems because with the
message-passing small talk style object
orientation it's hard to add new
operations to existing types so for
example if I want to add a draw method
to rectangles and circles unless I have
access to the source code some languages
will give me a feature like open classes
which is quite a hack but if you don't
have that type of feature then you're
out of luck but the second approach that
has problems too because with this code
example if I define a new type of shape
such as a triangle then I'd have to
again I'd have to go back to the
original source code where area and
perimeter are defined and add a new case
to these type switches and neither
approach appeal to me however Common
Lisp did have a solution of this and
it's really quite nice so what common
list does and what factor does is that
we decouple methods from classes
completely a class it does not have
behavior it is just state and
user-defined classes which hold named
values are called tuples in factor there
are other types of classes too and I'll
mention a couple of them later on but
tuples are the most fundamental type of
class so here I define two tuple classes
rectangles and circles rectangles have a
width and a height and circles have a
radius and the way this declaration is
written here it means that the width the
height and the radius can be any
datatype factor also supports declaring
the types of these slots but I won't
talk about that in this presentation
because it's a more advanced feature so
now we have these two data types well
what can we do with them you can create
new instances for sure so to create a
new instance of a class there are two
fundamental words that are used there's
new and there's boa if I say rectangle
new then I get a rectangle
object on the stack where all these all
the slots are set to F and F it's like
factors null value or empty absence of
something okay if I say rectangle bar
then well boa stands for by order of
arguments so you can call it a bar
constructor and it fills in the slots
from the stack okay so with rectangle
bar I have to put the width and the
height on the stack and now I have a
rectangle with these slots already
filled in well what if I want to change
the width of a rectangle you do
something similar to the email example
where you call a word with this name the
two arrows and then width and now I've
changed the width or I can change the
height okay and if you create a
rectangle with new then you pretty much
have to fill in the width and the height
how do you find all the places
okay so the question was that if using
boa constructors and then later on you
redefine the tuple class to add a new
field how do you find all the places
where you have to update the code and
potentially add a new stack parameter
well you can certainly ask the system
for usages of that class and if you
actually have words that call boa on
them we don't have words we've just been
calling boa in the listener it will tell
you but mostly if you have a class with
a lot of slots and a lot of them are
optional then you use new and you fill
them in using these setter words you
would use boa for very small tuples for
example if you have a datatype for
points with an X and a y slot or you
have a datatype for colors or red green
blue it's not likely that you'll be
adding a new slot and calling the
setters by hand will be more verbose
than just having the values on the stack
yes
can you repeat the question sorry okay
well the question was what are these EPS
here let me clear the stock when I say
rectangle new then it makes a new
rectangle object and it doesn't take
anything from the stack Oh y3 okay
that's just a funny bit of syntax where
if the the first F can be something else
and then it you can look it up in the
reference documentation if you're
interested okay but usually we
encapsulate constructors in words so you
don't ever call new and boa
unless it's inside a constructor word
and like I said before the naming
convention for constructor words it has
these angle brackets around the word
name so here I've defined two words
rectangle constructor and circle
constructor and they basically do what I
was doing here where you put the width
and the height on the stack and then you
can create a rectangle or you put a
radius on the stack and you can create a
circle and once you've defined
constructor words it's easier to find if
you use them in a disciplined manner
it's easier to find all the locations
which you might need to change if you
add a slot so that's another answer for
an earlier question there okay well
that's all very well but so we can
create these objects and get the slots
set the slots but what can we do with
them other than that a factor has this
thing called generic word and a generic
word is a word whose behavior depends on
the type on the stack generic words are
defined by saying generic : then a name
and then a stack effect but there's no
body because you'll have multiple bodies
depending on the type okay and a method
in factor it associates a class and a
generic word with a specific behavior
but methods they don't live inside
classes in the same way that they do
in Java or Python so here I'm going to
define two methods on the area generic
word and the first one is specialized on
the rectangle class the second on is
specialized in the circle class and the
definition might look kind of funny so
I'll talk about it a little bit see the
area generic word it takes a shape on
the stack and it outputs the area of
that shape the area of a rectangle is
the width multiplied by the height so if
we have a rectangle on the stack we have
to get the width and the height and then
we multiply them to get the width and
the height we use the by Combinator and
the by Combinator and factor it takes an
object and do quotations and it applies
each quotation to the object in this
case the first quotation extracts the
width the second quotation extracts the
height and now that we have the width
and the height on the stack we multiply
them and the way you read this chord is
get the width get the height multiply
them and for the circle it's simpler you
just get the radius you square it and
the sq word just takes a number and
multiplies it by itself and then you
have to multiply that by PI ok PI R
squared is a formula for the area of a
circle and now that we've defined these
methods we can compute the areas of
rectangles and circles
okay so the question was what happens if
you get a the stack discipline wrong in
the rectangle code it depends on whether
the code is in a source file or you're
entering an and listener if you enter in
a listener then you pretty much won't
find out until you run the code if you
enter in a source file you get a compile
error so the compiler checks your stack
usage and if anything is wrong then you
get a compile time error okay all right
moving along now let's define a new
operation on existing data types so here
we have a generic word called perimeter
which takes the shape and outputs the
number and it has two methods a
rectangle method and a circle method the
perimeter of a rectangle we take the
width and the height we add them and
then we multiply that by two the
perimeter of a circle is the radius
times two times pi and now we can
compute perimeters of rectangles and
circles okay but what about defining a
new data type and implementing existing
operations on it well you can do that
too using this model here I have a
triangle data type with a slot for the
base and a slot for the height so this
is just a right triangle where the angle
is 90 degrees then we have a constructor
word as usual and we put a method on the
area generic word that we define earlier
which multiplies the base by the height
and divides that by two so let's try
that out okay that looks correct
and again this is another method for the
perimeter generic word the perimeter of
a triangle is a little bit trickier you
have to compute the mm the diagonal line
the hypotenuse and I guess a picture
would have helped but basically the
hypotenuse is the square of each side
you add it together and then you take
the square root okay and once you have
the hypotenuse word then you get the
base you get the height now they're both
on the stack and what to buy does is
it's like buy except now it takes two
objects and two quotations and applies
each quotation to both objects okay so
here we add the base in the height and
here we compute the hypotenuse and
finally we add those two together so
that's a little fun piece of code and
there's your perimeter okay and you get
a decimal number because there's a
square root in there okay so using
generic words and methods you can define
new operations over existing types or
you can define a new data type with
existing operations and that gives you
more flexibility than the
message-passing approach or the
algebraic data type approach and the
next feature i'll talk about is it's
called mixin classes and to motivate
mixin classes let's look at this every
class you define has a word which tells
you if the object at the top of the
stack is an instance of that class and
here we're checking if a rectangle is a
rectangle of course this is true but a
circle it's not a rectangle but what if
we want to have a word which tells us if
something is a shape in the general
sense well you could define a word which
checks if it's a rectangle or a circle
but that's not exactly what you
because what if someone comes along and
defines a triangle datatype with methods
on area and perimeter and then your word
won't work it's not general enough so
what we do is we define a mixin class
called shape and we say the rectangles
are shapes circles or shapes and
triangles are also shapes and once we've
done that we can ask a circle if it's a
shape and it says true however a
floating-point number it's not a shape
because we didn't declare it an instance
of the mixin now the nice thing about
mix-ins is we can define methods on
mixin classes so here's a generic work
will tell me and if you give it a shape
it prints the area of the shape using
the dot word that we looked at earlier
if you give it an integer it prints a
message telling you whether it's even or
odd so if you pass a circle you get the
area if you pass a rectangle you get the
area of that and if you pass an integer
it just tells you that it's odd and this
integer class here it's not a tuple
class so we defined it's called a
built-in class and factor has built-in
classes for integers arrays strings and
all the other stuff that you would
expect to find in a language and you can
add methods on those so you're not
limited to working of tuple classes you
can extend the integer class with custom
methods or the string class of custom
methods and back to our shape example
now that we have these two generic words
and we have that shape mix and anyone
can come along and define a new tuple
class for shapes make it an instance of
the mix and give it these two methods
and then they can pass it to a word such
as this okay so
a mixin lets you inherit methods but not
state the object system has other
features you can actually inherit state
as well by sub classing tuple classes
you can declare types you can make slots
read-only and there's more types of
classes than just tuple classes built-in
classes and mix in classes we have this
one feature for example called predicate
classes where you can say define the
class of all strings with length equal
to 5 and then you can put a method on
that and the method will only be called
if the string has a length of 5 and the
object system is implemented in factor
and it's only two thousand lines of code
and that's a recurring theme where large
chunks of functionality are not part of
the core language they're just in the
library and this makes the course
smaller and simpler ok and the question
was what happens if more than one method
is applicable yes that can come up when
you have multiple inheritance of mix-ins
and the answer is that we have a
linearization algorithm which determines
an order for methods and you can ask a
generic word for the precise
linearization of its methods if you're
ever confused about the applicable
method so it's not ambiguous ok
now functional programming and
object-oriented programming they both
come together in factors collections
library we have many types of
collections the one that's most commonly
used the sequences and a sequence is a
linearly ordered set of elements and
this includes arrays which are just
fixed length sequences of objects
vectors which are resizable arrays and
strings the factor also supports the soy
seed of mappings and the most common
example there is a hash table and there
are others like red black trees which
are more obscure and we have a lot more
collections
Dex heaps disjoint sets but I won't talk
about them except for mentioning that if
you look in the vocabulary browser for
the vocabularies which are tagged with
the collections tag then you'll get a
list of vocabularies which are either
implementations of collections or
algorithms on collections okay let's
talk about sequences so sequences does
this thing called a sequence protocol
which is a set of generic words which
for example get the length of a sequence
set the length of a sequence for
resizable sequences get elements and set
elements and anybody can define their
own type of sequence which has methods
on these generic words and as soon as
you do that you have all these
Combinator's you can use and you can
iterate over a sequence you can map over
a sequence you can remove elements which
do not satisfy certain predicates and
you also have utility words which you
can use and the way that works is that
these Combinator's and utility words
they simply call the generic words on
the object that you pass in and as long
as that object is any data type which
implements methods on these generic
words is going to work so here you have
functional programming an
object-oriented programming coming
together because iterating over a
sequence with a Combinator that's a very
functional idiom you know where you have
a sequence of numbers and I add 3 to
each number and I map over it but in
fact err this is actually invoking
methods under the hood so you can define
a new sequence type and here's an
example that we're going to look at it
implements the solution to the bin
packing problem where you have m objects
and n bins and we want to distribute
these objects as evenly as possible but
M might not divide into n
okay so here's an example we have 20
objects and 13 bins and what the
algorithm does is it puts two in the
first bin one in the second bin to win
the third bin and so on so let's look at
how this is implemented okay and this is
a typical factory source file where you
have one two three four five word
definitions and each one is just the
one-liner that calls a bunch of other
words okay there's a lot of code reuse
going on here and it's all very concise
and mostly we rely on sequence words to
solve our problem so the first word
percentages it takes a number and then
it gives you a sequence of numbers from
between zero and one such that they're
evenly distributed between 0 &amp;amp; 1 and
there's 13 of them ok the second word is
called steps it takes two numbers and
here it gives you a sequence between 0
and the first number with the number of
elements and it's evenly distributed so
2013 whoops
2013 steps okay here you have numbers
between 0 and 20 and there's 13 of them
and they're evenly distributed and these
two words the way they're implemented is
the first one makes a range object and
divides each element by n the second one
uses the first one and multiplies each
element by M okay and these are all
sequence words which are combined in an
interesting way and there's no explicit
looping here or iteration the third word
called rounded it just rounds each
element of a sequence up to the nearest
integer so let's apply that to the
output of the steps word
okay now you have just integers and
finally the differences where it takes a
sequence and subtracts each element from
the next one and we've solved the bin
packing problem and we can for example
step through the differences word and
see what it does so let's put the result
of rounded on the stack right
differences in press control w I press
control I to step inside the first thing
it does is duplicates the sequence then
a prefixes it was zero and then it calls
this word which subtracts one sequence
from another component-wise and there's
your result okay and the interesting
thing about this program is it processes
your data in lots of little steps
there's no big loop or anything and you
can step through it and even if you
don't understand what a word like this
means you can look it up in the help so
as I mentioned earlier this word takes a
sequence of numbers and divides each
element by another number okay so this
is a example it uses sequences it's
pretty complicated but it solves an
interesting problem now I'll talk a bit
about strings these days ASCII it's
really not sufficient for what people
want to do with computers so most
languages support Unicode instead and in
Unicode each character is 21 bits okay
in Java for example they use 16 bit
characters and that's a really bad
design decision because they end up
having to encode certain characters as
two bits two bytes so you really need
more than 16 bits and facture supports
the complete Unicode standard
but the implementation is quite clever
because if you dedicate 21 bits to every
character you'll be wasting a lot of
memory for the common case of ASCII
strings so what we do internally is that
a string is an ASCII string unless it
has character is greater than 127 as
soon as it does another vector is
allocated while 16-bit values where each
value contains the remaining bits from
each character okay and all of our
string operations are Unicoi to where
for example case conversion there's a
German character where the uppercase
variant of it is actually two characters
and we support that correctly and we
also support character classes and
sorting and so on in a Unicode aware way
so our strings or sequences but they're
quite a complicated implementation of
sequences but operating system input and
output deals of bytes so for a language
like factor where strings the Unicode
internally you have to deal with
encoding and decoding and we support all
the common encodings such as ASCII utf-8
even the old IBM mainframe Epke dick
encoding and the way this is implemented
is that words that perform I or they
take encoding symbols as input for
example here I'm opening a text file for
reading and I read a single line and I
do it with the utf-8 encoding I don't
think the file exists so I'm going to
create it first hello world
let's see document txt and let me put a
funny character here
there we go copyright sign and I'll make
it a utf-8 file it's already utf-8 save
the file and now when I read it in
there's a string with a copyright sign
in it okay and of course we also support
binary input and output and if using
binary input and output then instead of
string objects you get byte arrays so we
separate the two which is quite
important when you do this type of thing
yes
okay the question was that with
filereader appears to change the
behavior of read line and in the earlier
code we had here with file writer
appears to change the behavior of print
and that's exactly what's happening
factor supports a feature called dynamic
score which I wasn't going to talk about
in this presentation and basically a
dynamic scorp you can define a variable
which whose value can be set not
lexically but dynamically meaning that
you can redefine the variable and then
all callers of all words that you call
see the new value okay so that's how
with file reader does it redefines the
input stream variable and then any words
that the quotation calls they see the
new value of the input stream variable
and they read from that input stream
okay I think the new buzzword name for
that is context oriented programming but
it's really just called dynamic scope
and it's been around since the 60s but
not many languages have it okay so
that's enough about sequences
associative mapping is a similar
situation there's a protocol with
generic words that you can define
methods on and of course hash tables and
other built-in types they already have
methods on these generic words and then
there are combinators and utility words
and you get those for free so you're
defining you can define a new type of
hash table with a different collision
strategy for example and you get all the
functionality for free
okay the next feature I'll talk about is
named local variables and lexical scope
and most the time factor is very nice to
programming but sometimes there's no
good solution to solving a problem on
the stack or maybe you're just porting
existing code and you don't want to
rethink it in the factors style you just
want to do a quick and dirty and for
this situation we support named
parameters named local values which are
very similar to
most other programming languages and
again we can implement this in factored
as an embedded language as a syntax
extension and our implementation of
lexical scope is influenced by a scheme
and Lisp and instead of using colon
you use colon colon to define words of
named parameters and you can establish
new bindings of let and you can also
have quotations of named inputs using
this type of syntax where you have a
list of named values and then you can
refer to them in the body and this
supports full closure semantics so you
can return a closure from a function
pass it around
it also supports mutable bindings and a
lot of languages they get the subtleties
of mutable bindings wrong for example in
Python you cannot assign to an outer
scope
without extra work but in Ruby every
function is just one single scope so
even if you assign inside a block it
will set the value in the outer scope
and that's kind of ironic because those
languages have local variables is a
built-in feature but in Factor they're
just a library and we can still manage
to do it correctly and I'll show two
examples the first example is the
quadratic formula and the quadratic
formula it's kind of tricky because you
have three values and then you have to
compute different stuff using those
values and just keeping everything on
the stack can be a bit complicated but
if you use some named parameters then
it's very simple so first we define a
word called plus minus which uses this
Combinator that I talked about earlier
which takes two values and two
quotations and applies the quotations to
both values and plus minus adds the two
values and then it subtracts the two
values and leaves both in the stack and
incidentally this is a nice example of
multiple return values with stack
programming and multiple return values
are very easy to work with in a stack
language there's no backing in
backing into tuples for example if you
just want to return to values this word
here it uses : : and this means that
these parameters are not just
annotations for the programmer they're
actually semantic names and we refer to
the names in the body and when you refer
to a name like that it's pushed on the
stack and this word here again it has
name parameters and it returns two
values and those are the two solutions
to your quadratic equation so this is
just a little math formula example that
uses locals the next example uses
lexical closures and there's only one
word here and there's no inputs it just
returns one quotation as an output and
what it does is it defines a variable
called X whose initial value is zero and
the exclamation mark means that the
variable is immutable so you can change
it and then it pushes a quotation on the
stack but the interesting thing is that
the quotation refers to the variable X
and it even changes it and what it does
is it gets the value of X this should
really be plus it adds one and then it
stores it back in the lexical variable
so let's see what happens when we call
that word closures example
so that's called the counter word and
now pushes this quotation on the stack
and every time I call the quotation is
going to I made that change but I forgot
to reload it sorry about that okay every
time we call the quotation that it
returns it increments the variable X but
if I call it again then I get a new
closure which has its own value of X
which is independent of the previous
value of X okay and some languages have
trouble with closures of this form for
example but it's very easy in Factor as
I said already locals are just a factual
library of four hundred and seventy
seven lines of code and they use compile
time metaprogramming so there's no
performance penalty whether you decide
to use locals or the stack so it comes
down a matter of coding style and very
often using the stack is more concise
and easier to refactor and so on and in
our basic library there's only fifty
nine words that use named parameters but
sometimes you do need to use them and
it's nice that we didn't have to add
this feature to the core language we
just have a library that doesn't ok now
I'll talk a bit about the parser you've
seen this before already where I can
input an array just by using this curly
bracket syntax and of course I can input
quotations using square brackets and all
data types in fact or have a literal
syntax hash tables for example here's a
hash table with two keys and two values
and this is very nice for data-driven
code where instead of writing a big
switch statement and like you would in
Java for
example you can just put a hash table in
the middle of your definition or you can
also use factory source files for
configuration in your application you
don't have to write a separate
configuration parser or use XML and then
you know there's marshalling and on
marshaling of the data you just load a
factory source file which itself can
contain lists and cache tables and stuff
like that but even more importantly
libraries can extend the parser with
what is called parsing words and the
example I'll show you is the URLs
library it defines the data type for
URLs and a URL has several components as
a protocol hostname port number query
parameters and this library parses URLs
it can manipulate URLs and it can
convert them back into strings but also
extends the syntax to language so you
can have a URL in the middle of your
program so I can evaluate this and push
it on the stack and the stack display
now tells me there's a URL there and
this differs from a string in that the
URL has been parsed and it has these
component parts okay so there's a query
with ID 81 so that's an example of a
library which extends the syntax the
core language doesn't have a notion of
URLs of course that would be silly now
another example where parsing words is
use are useful is for getting rid of
boilerplate so here's a silly little
Fibonacci sequence function and the
Fibonacci sequence every element is a
sum of the previous two elements and the
first two elements are 0 and 1
ok but this implementation is very slow
for example if I do 30 for Fibonacci
then that takes half a second but it's
only the 34th element like what if you
want element 1000 or something
and this is because if you profile it I
press ctrl R to profile it it calls
itself like a billion times or something
or no 18 million times because every
time you call Fibonacci it calls itself
twice and each one of those calls calls
itself twice and it does this until it
reaches zero and it would be a lot
faster if it didn't have to recompute
all these values redundantly and we can
use a library called memoization for
that and the idea behind memorization is
that before you actually perform your
expensive computation you check if you
already saved the result in a hash table
and if you don't you do the computation
and then you save it in the hash table
and this pattern comes up again and
again in all kinds of programs but in
fact er it's very easy to use this
pattern because all you do is you change
colon to memo : and as soon as you do
that then Fibonacci becomes a lot faster
ok zero and milliseconds because once it
computes a Fibonacci 34 it computes 33
and that computes 32 but then after
returns next time it computes the
minashi 32 it's already been computed
it's in the hash table and all we have
to do is change one token we use memo :
instead of : and memo : is a parsing
word define in a library now this is
similar to decorators in Python I
believe but it's a bit more general
because the parsing word can really do
anything at once and we use memorization
all over the place instead of
maintaining explicit hash tables for
caches and so on it's it's a lot nicer
than writing all that code out by hand
every time okay so as I said memo is
just the library word but
so is : this : syntax that we've been
using to define words all along there's
nothing special about it it's just a
function on the library and you can even
look at its definition it calls two
other words and factors parser is
written in factor and all the syntax
that you've been seeing in this
presentation is just library
functionality for example square bracket
that's not part of the language grammar
when I say hello world to uppercase map
then these curly brackets and these
square brackets they're not inherently
part of the language they're just
library functions which happen to extend
the parser to construct quotations
arrays even the quotation mark word here
the court that's a parsing word which
creates a string for you but of course
the question is if if colon is a library
word then how can you use it to define
itself like here I'm saying colon colon
and then giving the definition the
answer is that factor basically compiles
the parser to an intermediate form and
then you have to do this using an
existing instance of factor the first
version of factor was written in Java
and then I used that Java version to
re-implement factor in itself so now you
use factor to compile itself in the same
way that GCC is written in C and not
assembly for example and you need
another installation of GCC before you
can compile GCC this is called meta
circularity and it's nice because I'd
rather write the parser and the object
system and everything else in factor
then write it in C because factor is
higher-level okay so the parsing words
I've shown you so far have been very
simple they either implement literal
syntax for data types or they just
decorate a word with additional
functionality such as
memoire : does but some parsing words
are more complicated and they embed
entire languages with different
semantics inside factor for example
parsing expression grammars is the
library that we have which allows you to
specify a parser for your own language
declaratively and embedded in you factor
program and using this you can parse
strings and it's much nicer than writing
a parser by hand the example I'll use is
a factor implementation of printf and if
you program and see then you're all
familiar with printf the idea is that
you have a string and you pass it to
printf and it prints the string but it
also interprets certain character
sequences in the string in a special way
for example if you have % s then it
splices another string there instead of
printing out % s ok so let's let's look
at this this thing here
EB and F : that's a parsing word which
delimits a declarative grammar ok and
the declarative grammar roughly says
that a string formatting directive is %
s and the action to take is to write the
top of the stack when you see % s a
literal is 1 or more characters they're
not equal to % and the action to take
there is you convert the literal to a
string and you splice it into an
existing quotation which writes that
literal and a printf format directive is
a sequence of 0 or more strings or
literals ok
so let's test out this ebn F word parse
printf
okay so it parsed our printf format
string and it gave us a sequence of
quotations but what we really want to do
is get one quotation that just does the
effect of all of these in order and I
can join them together because
quotations are just sequences so the
result of parsing this format string is
this quotation and you can see that they
both do the same thing where if in C you
pass hello a comma % s newline to printf
then it's just going to write hello then
it's going to write a parameter string
and then it's going to write a newline
okay and once you've defined a parser
like that you can make a macro called
printf and a macro it's something that
it runs a compile time and that's what
we want for printf because the format
string is not going to change the
parameters are going to change so we
parse the format string at compile time
and we join the quotations together as I
do in the listener and then you have a
printf word so let's try it out let's
let me clear the stack because I have
these ridiculous Fibonacci numbers there
I'll push a parameter on the stack and
I'll say hello % s printf and it says
hello Google OK and the interesting
thing about this implementation of
printf is first of all we didn't have to
write a parser for the format string by
hand and the second thing is that it
expands into a factor code at compile
time so there's no performance penalty
to using printf in your factor program
instead of just writing the code out by
hand and for such a simple syntax where
the only special thing is % s it's
probably not worth using pegs but where
pegs shine is being able to extend your
declarative parser very easily for
example what if we
want to support percent D as a format
directive to print a number we can do
that very easily here I'm saying when
you see percent D the action to take is
to convert the top of the stack to a
string and then write it out so if you
have a number on the stack and you say
number to string right is just going to
write the number out and now I just need
to add this as one of the cases in the
format string syntax and here's another
nice factor feature when I change a
source file that I've loaded previously
all I have to do is press f2 and factor
detects that that file has changed along
with any other files that have changed
and it reloads it and
now we can test it out so 42 Googlers
hello Googlers my favorite number is 42
okay so pegs are a very nice factual
library which extends a factor syntax to
allow you to specify declarative
grammars and there are some extremely
complicated Begg parsers that we have
that you really do not want to write out
by hand for example we have a JavaScript
parser that uses pegs and as anyone is
written a JavaScript parser by hand
knows I haven't but I'm sure it must be
very tricky compared to just specifying
the grammar declaratively okay so that's
pegs oh I had two examples here that I
was supposed to show you instead of the
42 stuff but it's basically the same
thing
as just
yeah well printf okay so the question
was how do I pass printf around is a
first-class value
unlike Lisp where there are some
limitations as to what you can do with
macros and you cannot pass them around
as parameters in factor that's not a
problem so I have a number on the stack
and I have an array with two format
strings in it and then I map over it
with printf and the width tells me that
to pass the five on each iteration
sorry I'll use each instead of map then
it just it works like I have this
quotation here that contains printf and
the problem with this type of code is
that it's a little bit slower than
something like this because here the
string if you if you provide the format
string as a literal then the compiler
will expand printf at compile time but
if you don't it will still work it will
just have to parse these format strings
every time it iterates through the array
so there's no problem there it's just
more of a matter of performance versus
being dynamic I know it doesn't always
check the stack signature and it depends
like for some types of code it cannot
infer the stack signature if the code is
too dynamic
okay so I mentioned earlier that factor
has a very powerful input/output library
and let's see we're sort of running out
of time so I'm not going to I was going
to give examples for all of these but
I'll just move on now I'll give an
example of the i/o dot monitors library
which is really quite nice and I haven't
seen many languages which implement this
functionality in a cross-platform way
and the functionality is monitoring the
file system for changes without polling
the modification date of the file so
let's look at this program first the
last two lines of the most interesting
we create a monitor object on the slash
TMP directory and t-true tells it to
monitor sub directories recursively and
then we do this forever and what we do
is we wait for the next change to come
in and this word takes a monitor and
outputs the path name that changed and
some kind of descriptor explaining what
changed and the forever word it's not
part of the library but I define it here
and I define it using another word
called loop loop takes a quotation which
outputs a boolean and it continues
looping as long as the quotation up
what's true and what forever does is it
makes it so that the quotation always
returns T by just saying call the
quotation then push T and then pass that
to loop so let's try out this code
example and now when I create something
under TMP I get a message in fact are
saying that this changed okay
and this uses platform-specific api's
but we abstract over those api's and
give you a cross-platform interface to
this functionality and it's a very nice
feature it's very useful in a lot of
ways like the the f2 command that checks
for file modification in your source
tree that uses monitors and it's very
fast because instead of having to look
at every file and compare the
modification date it just sits around in
the background with a monitor that's
just one example of a cross-platform IO
feature that factor provides that many
other languages do not have and you have
to roll yourself or tie yourself to
platform specific functionality here's
another example this is a time server
where every time a client connects it
sends the current time to the client and
the key word here is handle time client
and what that does gets the current time
converts it to a string and a print set
and if I just do that on the listener I
get an idea of the kind of output that
the time server provides and the rest is
pretty much just configuration and you
see there's very little code to write if
you want to implement a tcp/ip server
there's a library that handles all the
mechanics of starting new threads
logging connections listening on the
socket all you have to do is say I want
a server it has this name it listens on
the sport number and when a client
connects it runs this quotation and by
the way here I'm listening on a standard
insecure port but if you want to do SSL
you just change two characters so let's
start the time server
and connect to it with telnet and
doesn't seem to work oh sorry yes and
here's the current time I just got the
port number wrong there's a typo okay so
doing something like this in most other
languages you're looking at a page of
code unless use twisted Python for
example so what we have is similar to
that but it's built into the i/o library
it's not a third party project here's
another example this is a web
application and it's a really simple web
application all it does is it gets the
IP address of the client and it displays
it in the web browser and again it's a
very short piece of code and it
leverages a lot of existing
functionalities such as HTTP server and
the web framework let's start the web
application
I forgot to write a little bit of code
here there we go
now when I connect to localhost 888 it
tells me what is my IP address okay and
this is not very interesting if someone
had connected from a remote machine it
would actually show their real IP
address and I guess it's interesting
that's using ipv6 and not ipv4 sorry
yeah the the question was shouldn't that
be calling : 1 well : : 1 is just ipv6
shorthand for for the same thing with
lots of zeros okay so this web
application it's not oops it's not as
fancy as it could be and it has one
other file which is an XML file and this
is just the HTML template where this
part is the dynamic content that gets
inserted so our web framework separates
the markup from the logic and it always
produces well-formed XHTML and it
supports a lot more features which I'm
not going to have time for today such as
SSL and session management and basically
everything you would expect in a web
framework ok the next example it's a
client for the Yahoo search web service
and I would use Google search except you
guys don't have a public API anymore and
the main word here is search Yahoo and
this is very typical stack code it looks
like a pipeline where you construct
something you perform an HTTP query you
parse the XML and then you do more
processing on it so let me do a yahoo
search the input is a search object and
I can search for factor
use Yahoo
oops
okay the search word takes the query as
a parameter my bad okay there's a yahoo
search and the result is like a sequence
of tuples this is the right one
see we're number one on Google but only
number nine on Yahoo yeah and this
example it demonstrates the XML parser
because when Yahoo gives you the search
results you get a string with XML in it
and then you parse it and now you get an
XML object but to get that nice sequence
of results you have to do some more
processing and we have all kinds of XML
API s for that
okay here's a pretty cool example it's a
simple web browser and it uses the cocoa
binding that we have to call the WebKit
API and again this is extending the
factor syntax for a domain specific task
and that is interacting of cocoa
I'm not going to talk about the syntax
here because I'm running out of time but
basically we create instances of
objective-c classes we send messages to
them we load objective-c frameworks and
this is all done with factory code and
furthermore I'll demonstrate the
deployment tool you're not always
limited to running your code inside the
factory environment you can actually
generate standalone executables so I'm
going to deploy here
we'll see the question was how big as a
result and it's actually hmm it's 764
kilobytes let's run it first and then
we'll look inside the package ok I just
did this as a joke live search and with
live search I think it's even worse if
you search for factor then while the
Wikipedia page is number 4 but the main
factor website is not even in the first
page of results oh there there right
there yeah hmm ok so Google has the best
search placement for my project and if
you look inside the executable that was
generated by this deploy tool I lost the
original file so I'm going to just
deploy it again instead of searching for
it
okay sure package contents contents this
is a factor virtual machine and its 176
kilobytes is pretty small this is the
main launcher executable and that's even
smaller and the only substantial content
here is the image file which contains
serialized factor data as well as
compiled machine code and that's 572
kilobytes which is a fair bit for a
trivial application of one page of code
but you have to consider that this is a
very high level very dynamic language
with garbage collection and so on and
it's also a 64-bit binary I'm writing
factor in 64-bit mode here so that's
pretty good if you look at Lisp systems
out there then they'll give you a the
twenty megabyte binary for a hello world
and other languages such as Java they
don't even generate standalone binaries
you have to ship the Java VM which can
be quite large so the deploy tool is
pretty neat
I'm going to skip this example and I'll
just talk about the implementation now
so factor it mostly it's written itself
but there is a part a factor in C and
that's pretty much the garbage collector
and other low-level services like that
the core library is nine thousand lines
of factor and that includes arrays hash
tables the parser the object system
stuff like that and we also have the
basis library and that is other
libraries which are pretty much
essential these days but they're not
fundamental to the language itself this
includes parsing XML the GUI toolkit
that I'm using here local variables
the web framework stuff like that and
factor is fully compiled there's no
interpreter even when you type stuff in
the listener in here it becomes machine
code so I type two two plus
and it actually compiles it very quickly
and runs it and I don't know if I have
time to go into the compiler I mean how
are we doing for time
five minutes okay well I'll just give
you a very quick tour of the compiler I
have this benchmark here
and this benchmark render is a fractal
so let's run it press ctrl T 330
milliseconds
okay that's the output and this
benchmark here uses all kinds of crazy
language features such as complex
numbers and all the arithmetic and
Factor is generic meaning that in theory
there's runtime dispatch on the types it
constructs quotations on the fly for
example but it's very fast and see when
I did open there it try to open
OpenOffice and it's very fast because
the compiler performs a lot of advanced
optimizations it eliminates memory
allocation and it eliminates runtime
dispatch and it eliminates redundancy in
the low-level code and basically the way
it's implemented is a converts your
factor code into something called SSA
single static assignment form and the
idea with single static assignment is
that every value has a unique internal
name and this lets you implement all
kinds of optimizations very easily
there's a high level optimizer with
twelve different passes and let's see
I'm just going through this very quickly
because there's no time we infer types
we infer the ranges of values lengths of
arrays if they're known it does some
constraint analysis where for example
you can have a piece of code like this
where you're saying is the top of the
stack an array and if so give me the
first element and it knows that inside
this quotation you have an array on the
stack because the only way the result of
this could be true is if you had an
array on the stack and if the optimized
dot word tells you how a piece of code
is going to be compiled approximately
and in this case you can see all this
crazy stuff got in lined and expanded
and these are all low-level primitives
which will map directly to machine code
so on the mandelbrot benchmark it
eliminates a lot of the generic dispatch
in this pass the next pass is called
escape analysis and here we identify
tuples which are allocated inside a word
but are never returned from that word
and there are a lot of these tuples and
factor because we encourage a high level
programming style with rich data types
and being able to eliminate these
allocations really helps with
performance for example complex numbers
are represented as tuples of two
components but if you can eliminate that
allocation then your complex number
arithmetic will be a lot faster another
example where tuples can be eliminated
as virtual sequences for example if you
want to iterate a sequence backwards
then you can wrap it inside a reversed
sequence and this is called a virtual
sequence because the length and enth
methods on this sequence will delegate
to the underlying sequence but they'll
present the elements in a reversed way
so here is three to one but it would be
annoying if every time you called
reversed and then did each on it it
would allocate a new object of the
reverse type because here it's not being
returned or anything and we're not
holding an instance of it we're just
creating it using it and then discarding
it and in fact the optimizer when it in
lines everything and expands everything
out there's no allocation here and after
those after type inference and escape
analysis it just cleans up the code a
little eliminates some unused generality
branches where the the condition is now
a constant boolean okay and the next
step is it converts your code into
register based code and at first it does
it's in a very naive way for example
stack operations will always expand into
memory rights so if you're pushing five
on the stack then then the compiler
loads five in a register and stores it
on the stack or if you have a swap in
your coid which swaps stack elements
then it becomes two memory reads and two
memory writes if you just have calls to
words then they're just calls but once
it expands your code into this register
form it does further optimization and
some of these are quite advanced for
example this word to array it makes an
array with the top two stack elements
and if you look at the definition is
very general there's a lot of generic
dispatch going on and the high-level
optimizer gets rid of the generic
dispatch but there's still a lot of
redundancy because the inlining gives
you stack shuffles and the semantics of
the array constructor are such that you
have to fill in the array with the
initial element but then you're
overriding all the elements anyway so
there's redundancy there but the
low-level optimizer eliminates all that
redundancy and the machine code is
generated for this constructor is pretty
much as optimal as possible there's no
stack operations at all except for
loading the two inputs it also does
something called value numbering which
identifies redundant computations along
the same control flow path and in the
case of Mandelbrot for example there's a
lot of boxing and unboxing of
floating-point values where because of
the dynamic typing in factor you have to
do a memory allocation for each
floating-point number but if you can
prove that all values of floating-point
numbers you can eliminate the boxing and
that's what value numbering does and
again there's some dead code elimination
to clean it up and the last step is
register allocation
we're the intermediate form used by the
compiler assumes you have an infinite
number of registers but in a real CPU
you only have finitely many and in
general it's a hard problem to allocate
the registers optimally but we use a
relatively decent algorithm collinear
scan and I'm going to skip the details
here so on the end if you look at the
inner loop of the Mandelbrot benchmark
it's very tight you have just
floating-point operations and these run
as fast as your CPU will allow okay the
garbage collector is pretty good as well
it it's a generational collector which
means that short-lived objects even
though those which are not eliminated by
the compiler they're still very cheap to
allocate and deallocate and it's also
precise which means that it can always
differentiate a pointer from an integer
which is not the case in some language
implementations and the next thing is
that our project infrastructure like all
the websites that we have like factor
code org and our wiki they're all
written in factor and they use our web
framework and we also have a build farm
which compiles factor on 12 platforms so
you can see we support three different
CPU architectures and a range of
operating systems and all of these
binaries they get generated every time
somebody pushes a patch and all the
tests pass so if you push a patch and
something breaks then you get an email
but if all the tests passed is a new
binary so we don't have to make releases
of course we do have to make sure that
test coverage is very good but in
general this works really well and
finally well the fact
community mostly people hang out on the
IRC channel on the mailing list and boys
are pretty active and a number of people
have also contributed code to factor is
about 30 people that have contributed
code to factor itself and more people
have used factor for their personal
projects and it's easy to learn there's
a lot of documentation if you look at
the documentation in the environment
there's a cookbook and a tutorial and
they go through things very slowly much
more slowly in a lot more detail than
I've been doing in this talk because I
really wanted to demonstrate some more
advanced features and finally I'll talk
about the future direction we haven't
released 1.0 yet but we will at some
point in the near future and for 1.0
basically we'll be doing what we've been
doing with polishing the language and
I'm always improving its stability in
the performance and then 2.0 that's
going to be a release where we rewrite
everything for concurrency and native
threading and we also want to have a
syntax aware factor editor and finally
we want to explore embedded programming
and using factor as a scripting language
inside other applications so this is
maybe a year or two away and that's it
again it's hard to cover everything in a
single talk because it's just so much in
Factor and also it's it's hard to find a
balance between going through all the
language features in great detail and
giving many examples but I hope that
I've generate some interest and maybe
you'll want to check out vector and I
encourage you to do so any questions
yes the question was what's the
stability of the core language so
there's two forms of stability that
stability in terms of how quickly is the
language changing and also stability as
far as crashes and stuff like that so
the first form of stability the language
we're still tweaking things here and
there and last year was a period of many
many language changes this year we've
made some changes but lately it seems to
be stabilizing and we finally have
something we're pretty much happy with
and anybody who contributes code to the
factor repository will refactor that
code if the language changes if people
have their own factor code then they'll
need to stay up to date because every
once in a while the core language does
change but it's becoming more and more
rare now mostly now is just API changes
in the more peripheral libraries and
even those is starting to stabilize and
as far as bugs and crashes well it
didn't crash during my presentation and
in general it's very stable because of
our continuous integration and our build
farm which runs tests all the time
I have websites running on factor and
they've been running non-stop for months
on end I mean the last time I remember
restarting the factory HCP server was
actually a problem with the Linux that
was running the website and not factor
itself so it's very robust and very
stable in that regard yes
my name is happiest home
okay so the question was what types of
problems and application domains do I
see being factors happy home so to say
right now our main focus has been on
developer productivity which means we
want to design a language that people
can write a lot of code in very quickly
and a language which doesn't get in your
way a language which you can extend a
language with a robust implementation so
any kind of general purpose programming
tasks I think is a good fit for factor
but we're always on the lookout for
problem domains where it's a really
really good fit and I think so far the
most interesting one has been just
anything where you need to extend the
syntax to express your problem for
example writing parsers with pegs is a
really nice factored application and
yeah we have a set of features that very
few other languages have because we have
a dynamic language but it can also
generate standalone executables and it's
very fast last time I did some
benchmarks I think was about 50 times
faster than Python and floating-point
code so it's almost as fast to see on
many things and we also have very
flexible language features that you
would find in Lisp and scheme for
example but on the other hand we also
have a lot of libraries and a robust
implementation so it's not just a
research language it's something that
can be used for production yes you
developed any
means of collaborating or
because I've heard the criticism made of
high productivity complex compact
languages that they're right only for a
single person okay so the question was
that have we had any problems working as
a team with a language that's as
extensible as factor and the questioner
commented that such languages of a
reputation for being right only see I
think when you're looking at a piece of
code in any language sometimes it can be
hard to figure out what the code is
doing if you're not familiar with the
problem domain and the algorithm is used
in the cord but the nice thing about
factor is that it has very powerful code
browsing capabilities for example I can
type the name of a word and I can say
hey factor who calls this word and it
tells me that all these words use the
append word for example or you can look
at the definition of a word and then you
can see what its definition is without
having to you know like hunt around for
a new text editor you can click on a
word that it calls and read about that
word you can right-click on something
and look for usages so I think the way
to make a language that's useful for a
team programming is to make it easier to
explore the code base using tools in the
language and also have just you know
unique coding conventions of course but
tools are the major solution of that I
think
yes
what does the backslash word do that's a
good question backslash is a parsing
word which reads the next word that you
type but instead of executing it like
like if I just say plus that executes
plus right if I say backslash Plus it
puts backslash on the stack so you're
just escaping a word sort of so for
example I can say backslash plus add it
and then it opens the plus word in my
text editor and this is where it's
defined this is like a file in core core
math and backslash that's a word as well
like I can say backslash backslash C and
it shows me the definition of backslash
any more questions
okay well thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>