<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Nighttime Story: Learning From Early Success of One Thousand and One Rails Ap... | Coder Coacher - Coaching Coders</title><meta content="Nighttime Story: Learning From Early Success of One Thousand and One Rails Ap... - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Nighttime Story: Learning From Early Success of One Thousand and One Rails Ap...</b></h2><h5 class="post__date">2008-07-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mRf4bpEtI6I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everybody my name is Beth ho I'm the
group leader for Silicon Valley web
builder also I do a lot of web community
work for the Ruby and rails community so
I really like to take a chance to thank
Google and Googlers to help and support
this event
without them this would not happen so
quickly and so I would like to
personally thank Jon woody and I say for
helping out tonight
thank you I do like to make announcement
of so tonight we are covering rails in
about two weeks last Wednesday of this
month we also invited Jerry spool he's
the principal and founder of user
interface engineering group and he's one
of the world crowned expert in user
interface so if you're interested in
that please you know go check out the
web site from Silicon Valley web builder
which is HTTP WWSD web guru calm I have
some cards over there that I'm gonna
pass out later if you wanted to find the
keep website address in August we also
have a meeting about celebration of web
2.0 cultures and trends and September we
have a very exciting meeting on web 2.0
actually its UI 2.0 and it's a very
interesting discussion panel that we
invite you know the top UI designer
engineer from friends feed me bowl
another very popular startup to join the
discussion panel it will be at AOL
campus October we have another important
discussion on html5 and reverse Ajax
which is called comment and we're going
to go over some standard like WebSocket
so all these information you will find
on our website so I just want to get
some sense on how many people are here
to support Ruby like a ruby developer
raise your hand
how about rels all right how about first
timer and trying to explore Ruby on
Rails the first time all right welcome
okay so I'm gonna let John to do the
intro and he's our emcee and event
coordinator tonight yeah I'd like to
also thank Jason Jason for being here
Issac tracks and best oh of course for
putting all this together so I'm John
Weddell and I actually work on the rails
apps inside Google here
Jason's actually one of my favorite
speakers because he makes talking about
load balancers and dtrace so exciting so
I hope he's going to share some that
with this one his talk Ruby and scalable
architecture so let's welcome Jason
thank you
hey well good evening everybody let me
move that bottle down to so we have
about a sixtieth slide 45 minute ish
type of talk about Ruby and scalable
architectures quite honestly not too
much of it is about Ruby meaning that
most of it is in fact applicable to
everything else that's out there it just
so happens that we're probably writing a
ruby app you're probably writing a rails
app I mean for example how many people
here are writing a ruby app that is not
in rails okay how many people are
writing a ruby app that's not invert
okay so what are you guys using your own
stuff just a ruby app that's nice so I I
first found Ruby myself when I was still
doing academic things I was down at UCSD
in San Diego and a lot of the
infrastructure we're playing with his
time was basically being built on top of
the BSD kernel just to give you a little
quick history of how I found Ruby and
the interesting about FreeBSD is that
the guy that became the sort of
architect of the port system at that
time and as Twitter username is knu if
you want to follow what he Twitter's
about it's typically beer and music in
Japanese also became the sort of release
manager CVS manager guy of a new
scripting language called Ruby and in
2001 he released like the first
quote-unquote killer of Ruby application
and that was port upgrade on FreeBSD so
roughly at the time nine hundred lines
of Ruby became about a twelve hundred
lines of Ruby of basically a nice fast
script that managed all the software
that you have installed on a freebsd
system and that's in fact how most
people at that time found out about ruby
was it
behold a lot of the management tools in
FreeBSD were Ruby based so then at least
from my history is that you know we were
playing around with a lot of scripting
inside Ruby and started getting more
into the bio Ruby after being in the bio
Python project a lot and we were doing
some sort of side things in Ruby and
then for me at the time I was also using
a piece of software internally called
the copper project which is a piece of
project management software and God
asked to beta-test a new sort of online
piece of project management software
that was called Basecamp just because I
was on the endorsement page for this
other thing so I asked the single guy
running Basecamp like well this is
actually pretty cool what what's it
written in just out of curiosity they
said well you know I hired this sort of
Danish kid in college as sort of a
contract basis to sort of write a lot of
the backend for like you know three
foreground type of contract gig so
that's that's pretty cool which is email
address and I'd like to hear what he's
doing and reached out and started
talking to David Hanna Mayer Hanson at
that time and he was like well I'm
thinking about actually coming out with
a ruby framework I'm gonna call it rails
yeah at the time we talked a lot about
licensing issues and some other things
that were pretty neat and then the funny
thing about rails is that when it was
released it was like July 24th or 26th
in 2004 you know you can sort of go back
to the old sort of Ruby language list
and you see a lot of a lot of things
where the initial feedback is that this
kids done too much PHP and Java in his
life this looks nothing like Ruby and
rails was an interesting thing because
it was in basically being pushed by a
smart guy who looked like a gap model
and it became synonymous with the
language Ruby to a lot of people
and in fact even a lot of ruby
applications that people are writing now
look like rails they don't look like
what Ruby looked like four years ago
seven years ago eight years ago they
look completely different
follow sort of completely different law
so so that's a little bit of how I got
onto the Ruby stuff and in the rails
stuff there's also a shameless plug for
myself and that I was interviewed by Q
by there's like eight pages of of how I
think about stuff and a bio there if you
want to go back to the old January
edition and read it and then as far as
rails involvement goes I was at least
lucky enough to be the first change sent
in rails which I checked in as root and
it just has initial test and the second
change set was actually done by Jason
and that was just as it says the setup
of the initial repository structure and
then since then after sort of getting
involved in doing some some other things
with my own company Joyent we started
building a pretty large rails
application ourselves that is open
source the ability to run rails
applications in the desktop application
called slingshot and then I wrote all
the DTrace providers inside Ruby
one-eight-five and 1-86 and at least
some of those ended up on Mac OS 10
Leopard now and/or is basically shipping
with Solaris now I thought I would talk
actually a little bit what most of us
are really concerned about and that is
that is scaling and what are some terms
around scaling and what are some sort of
special considerations for Ruby
applications is this other mic on do can
you guys still hear me yeah okay so I
don't I don't have to stand there with
that thing so scaling for a lot of terms
you typically see is we'll see words
like scalability throughput performance
we'll talk about some basic limits of it
what the sort of rules of tens are and
at least for us that are writing web
applications or any sort of application
that talks over sort of an open protocol
we typically keep these types of web
applications and they're perfect
permutation as being a stateless
application so we maintain States
somewhere else a data store of some kind
so scalability is not throughput
throughput is exactly as the word says
how quickly you can put something
through a system that's all scalability
is also not performance the performance
of a language how quickly it does a
given function or not has nothing to do
with scalability either and scalability
is also not about language choice so
this conversation at least in the rails
community was pretty you know was
something we had to say sort of a lot in
the beginning around the sort of rails
don't doesn't scale type of idea in that
scalability is taking something like an
entire sort of application
infrastructure that you have to do and
realize that you know out of say you
know this list actually goes on but it
doesn't fit on the slide that you know
out of 30-plus components that are
required to say run and operate a
clinical scalable application two of
these components are written in rails
they're written in Ruby the rest of them
are a bunch of other stuff now that
doesn't mean that the performance of a
language is not important it is and the
performance of an application is also
important and how it utilizes Hardware
resources is also very important but it
doesn't impact scalability will see
scale abilities like just taking Legos
and saying that well if I have ten Legos
and I stick ten of them together it's
ten times in size those are that's a
scalable system and if I take nine away
its one in size but the nature of the
Lego itself and how quickly that Lego
does something doesn't quite matter so
when we look at the performance of of
Ruby and since a lot of us have max you
can go ahead and do something like use
Ruby dtrace that's inside leopard and as
you can see basically that says there
you know dtrace is a comprehensive
dynamic tracing framework as they like
to say but the basic idea behind
it's got enough hooks throughout the
language that you can probe what an
application is doing while it's running
in production and hopefully not have an
impact on it outside of noise so it's
not meant to be the same thing as
basically trusting an application now
the typical types of probes that you see
inside Ruby are things like function
entry return when garbage collection
begins and ends looking at a given line
of code when objects are created or
started or freed when exceptions are
raised
something's rescued and then sort of a
custom probe and what you can do it on a
Mac at least is go ahead and even use
instruments as an example where we see
all the same sort of probes being inside
of there in Ruby and you can go ahead
and fire up just a basic rails
application on your Mac and then go
there and say ok DTrace - l grep ruby
and you can see all the sort of Ruby
probes that are available inside of that
system that would be something like this
so the fact there is a mongrel running
and these are all the types of things
that are available inside of there we
can see that the same things exist
inside PHP and so on and in fact when
you go through and you say well let's go
ahead and write some very simple scripts
and DTrace to sort of see you know how
long say object creation occurs inside
Ruby then the typical sort of thing as
Brendan wrote here in a nice example
that we wrote a measured average of 677
nanoseconds is basically the object
creation time inside a ruby app so for
some things that Ruby does like creating
and destroying objects it's
exceptionally fast it's one of the
fastest things are doing that and that's
sort of a nice thing to see now when
you're exploring what dtrace is doing
for you in the case of a ruby
application there's going to be just
sort of four key area as you look for
one is going to be like odd deep
interactions with the system meaning
that you have a single rails application
or Ruby application that's
running and then you sort of say well
let's just go ahead and look at say the
system calls that it's doing it's a real
sort of simple thing
so one bug that we found inside rails
for example doing this with a with a
with a with a certain rail site was that
every time an exception was raised in
side rails you would basically drill all
the way down through the Ruby stack and
back out again
so you'd be going through over 400 stack
frames per exception per error the
result of basically fixing that bug
meant that an application with a
reasonable amount of errors not actually
an unreasonable affairs but something
that's now doing say you know where you
you sort of see them come along and
single-digit percent of these exceptions
being raised some kind you know that was
doing things like adding eighty percent
more CPU time and CPU load for that
application just because it was drilling
down through that so you know the fixes
one goes to rails and says well don't
don't do that you don't have to drill
all the way down the stack inside Ruby
and all the way back out again to make
to make that that kind of exception for
that that that's sort of well all it
basically produces is a page that says
hey it's broken and sends you an email
it's it's a bit silly the other thing
that you look for and these are very
sort of simple scripts to write is
variability in object creation times as
being greater than say 10% so I tell
people as they're sort of getting more
experienced with DTrace where you can
write say twelve lines of you know how
quickly is or my objects being created
and then say destroyed and you run that
in your application one doesn't have
much traffic you've run out when it has
a lot of traffic you trace it at various
sorts of time you do it before and after
deployments and a typical trigger we
like to use is say things like when
things are taking greater than 10
percent longer and creating them or
getting rid of them that ray
a red flag and you can probe object
creation time the other thing that comes
out very often is you can take advantage
of the thing in Ruby that you can and a
lot of other languages or say written
and see and that is just that you sort
of go through and you say well what
lines of code or what modules are using
the most CPU time and you sort based on
CPU time as the applications running and
you can go through like for example if
you're using the pure Ruby based my
sequel connector or the pure Ruby based
memcache client then under load you'll
see these using you know like 80% of the
time the application spins on CPU is
that module the memcache client my
sequel client or something you've
written yourself that's in pure Ruby and
the nice thing about Ruby is that you
can say well okay so we need to actually
write that as a C module inside Ruby so
now that functionality moves out from a
pure Ruby to something written in C to
something that even breaks out of the
Ruby interpreter itself eventually
becomes its own little C base kind of
app doing the functionality that you
need and you have that type of migration
path available to you and you identify
those those functions inside your
application by saying well let me go
ahead and see what things within my code
is using the most CPU and track that
over time also something you can do with
Ruby D trace and then garbage collection
ends up being one of the biggest
problems that pop up and a lot of
long-running Ruby applications so you
can probe whether things are being
garbage collected or not whether you
should force them where they should use
a different garbage collector and so on
but if you decide that you're going to
go onto your Mac is one of the great
places to sort of start playing with
Ruby dtrace and then go to the D trace
toolkit which is actually installed on
there too and has some basic sort of
scripts around these to identify it's
going to be like these four things
they're going to look at for your
application now one thing that's become
somewhat funny with
rails becoming popular is it's starting
to be a valid question what is Ruby and
in fact the guys that run the Ruby
project do a very poor job of release
management in my opinion meaning that
currently right now in the case of that
sentence isn't finished currently right
now in the case of real Ruby the
sea-based Ruby there's actually four
versions out in the wild of one point
eight point six so and they're not
called one point eight point six point
one one point eight six so there's
actually one where one point eight point
six the real one point eight one point
eight point six is the Christmas edition
and then there became patch set 74 patch
set 111 and then with a lot of the
recent sort of security issues that came
up they said well go ahead and pick
patch set two to three or to 87 or three
twelve as one of those three that might
work for you and not break your app but
they should be secure so a lot of people
for example bump it up to like patch two
to two so the problem is is a very often
you and you'll see this like if you go
to your Mac and write Ruby - V it'll
have some patch level number after it
now the funny thing about it and I'll
give you a great thing from having done
the Ruby dtrace stuff is it for Ruby one
point eight point six between all four
of those patches had to rewrite the
DTrace stuff each single one so the fact
that a patch against one point eight
point six doesn't cleanly apply to one
point eight point six or one point eight
point six or one point eight point six
this poor release management in my
opinion it gets even worse when you
looked
No
yeah the stuff is the same guys that are
doing clove mod rails so yeah there's
people out there then I'll have sea
based Ruby that they say is an
enterprise Ruby which means that they're
doing the patch management for you and
rhe numbering the versions so one point
eight point six patch level 111 the June
edition is you know passenger to one or
something like that I forget so the
thing that you have to keep in mind with
Ruby especially if you're really hacking
inside Ruby and really doing stuff with
Ruby apps is you cannot get away from
having to operate your application and
you cannot get away from having to pay
attention to the language it's not as
simple as just writing the rails
application a lot of the time it gets
worse when you look at ruby 1.9 and ruby
to the development version so ruby
one-ninth
but what they basically did was back
port so many of the new features from
Ruby to into Ruby one eight now that
became Ruby one nine and there's not
even a clean upgrade path from one eight
two one nine because there's so many
things that are different so like for
example when I was recently looking at
one nine about how to pour all the
DTrace stuff into one nine there were
entire files that weren't there anymore
or integrated over here or that kind of
thing so again going from one eight six
two one nine for somebody like myself
who's modifying the Ruby code so that it
can be instrumented they had to write at
five times to do that even though it's
only two versions
maybe maybe Ruby runs rails okay one
eight six one runs rails one nine runs
the latest rails one eight five runs
some rails with some patches applied to
the Ruby so real Ruby C based Ruby still
runs rails maglev is basically now
closer to a small talk implementation of
Ruby from the gemstone guys it does not
run rails yet it does some Ruby stuff
and you know so on rubinius is now
getting to the point where it does run
rails but it runs rails like fifteen
times slower than the real C based Ruby
does so that's meant to now be closer to
bootstrapping Ruby in Ruby where the C
based core of Ruby has now been
minimized to the point where eventually
more and more of writing Ruby will be in
Ruby that doesn't currently quite run
rails yet and actually to be quite
honest in my opinion and it's it's one
of the greatest ironies is that the best
version of Ruby out there right now is
actually JRuby and I feel really bad for
guys like you know Charles Nutter
because they love Ruby so much that
they've gone out and helped write a spec
for Ruby because Ruby by the way doesn't
have a spec it's just a language that
appears there's no respect to it so
there's a spec that's been written for
Ruby as a result of the JRuby and the
Rubinius projects JRuby in a lot of
cases implements certain things in that
spec better than real Ruby does and
faster it very reliably runs rails in
fact rails inside something like Tomcat
or GlassFish and half a gigabyte of RAM
can do 1500 requests per second on a
HelloWorld application and one mongrel
running in a hundred Meg's of RAM inside
sea based Ruby can do maybe 100 requests
per second so even when you do the mem
calculations that are required they're
basically half a gig of JRuby can do you
know basically what two gigs of sea
based Ruby can do in terms of throughput
and performance and JRuby has become
pretty attractive in my opinion for some
of our customers that are using it
because JRuby opens up JDBC it opens up
a lot of sort of distributed object
stores it opens up a lot of the sort of
interesting back-end type of things that
one can do in other worlds that you
can't do inside Ruby and you actually
can't do inside rails at all one example
would be things like database connection
pooling and caching doesn't exist in
rails and there's no middleware you can
talk to to have rails do that so if you
would like to go ahead and run 4,000
rails processes then you better have
database servers that can handle 4,000
connections from these 4,000 things and
it's quite inefficient as it gets bigger
and bigger so and here's the other funny
thing not to go on about Ruby a lot but
since we're talking about a ruby group
is that none of these are actually forts
so Ruby's never been in fort there's not
a group that's come along and said hey
you know what I don't like the way that
you guys are doing like the Ruby project
we're gonna fork it all right cause
something else no there's actually been
three entirely separate implementations
of Ruby's syntax a syntax that's only
present in soso documentation of the
language itself and in the absence of a
spec so V yeah well I ought to say too
much more about that yeah
and the unit test suite for JRuby in
terms of what Ruby should be and
Rubinius has done this as well as like
what ruby is should be the unit testing
for JRuby is larger than the unit tests
that are available for C base Ruby it's
just that these poor guys they like Ruby
so much they have to spend all day
writing Java yeah which is
that suffer its monthly picks more than
confident I make for basically
at the intent on forming at the time on
giving back to the king - well they
won't be I mean I came back the betray
stuff the Ruby guys who develop on
Solaris on boxes at Sun donated to them
and they won't take DTrace patches so
that is technically a fork but but real
rubies at least open source and
available to me maglev isn't rubinius is
G Ruby is I don't want to write things
in now what's a proprietary fork of a
language is it yeah yeah just not is
that interesting to people I mean like
for me 80 Meg's of memory versus 100
Meg's of memory don't care
yeah that argues for the mess doesn't it
so so in my opinion ruby release
management a lot of the stuff that's out
there is odd because there's currently
multiple implementations of an unspent
ax that's floating around some better
than others and most of the release
management around it's not very good
Oh depends it's I'm just saying that you
know we end up running rails apps where
we have to do say what these passenger
guys have done where end up with our own
internal repository of Ruby where things
get fixed faster and or set up a certain
way that just don't occur and and things
they get pushed back I mean all you have
to do is go and read the whole history
of the recent security problem with Ruby
and just see that these holes were
identified on the mailing list 14 months
ago
and it took a patch from Apple showing
up to really sort of push it so so
that's the state of Ruby meaning good
luck good luck you you still have to
sort of tool around with the language
it's it's it's just it's not done and
you you can't always rely on even a
version number it's got to be a patch
set so scalability then to go back to
that is architectural and in fact that's
probably one of my my biggest beefs with
even most sort of frameworks out there
whether it be a rails or anything else
like that is that not enough of them out
on the public space have architectural
concepts or the idea that you have to
operate an application or that it's
supposed to be scalable sort of built
into them from the beginning so there
isn't really the concept of architecture
there's the concept of writing in the
case of say rails a single application
that four people are going to use using
my sequel on a single little box it's
fine for that so scale is relatively
simple you take a stack of one Legos as
one Legos in size you take ten Legos as
ten Legos in size that is purely the
criteria for scale and honestly rails in
that sense is scalable and as we'll talk
about it a little bit
it's been called scalable since mongrel
was done and it really wasn't and
necessarily until then but we have to
sort of qualify what we mean by
scalability because the load based thing
is honestly pretty easy for most people
like how to fix load base scale how do I
take a lot more people and follow them
through an application is on a sort of
specialized all in-house people thinking
about it is an approachable sort of
problem the geographic scale where
you're actually now sort of load
balancing across sites there's another
type of scale that's different from load
based scale and takes a different type
of sort of thinking about it and then
the most common thing that I actually
run across especially for a lot of
startups is administrative scale so
meaning that you're gonna have to
actually scale development team scale
operations scale your data stores scale
your front-end write an application that
doesn't inhibit that and do it in a way
that everybody buys into it and quite
honestly when you sort of go through and
you say well you know why did sort of
application wet it's sort of you know
why site X always down or slow or weird
or they died or a bunch of people left
them you know why did that sort of
happen it's not because they failed the
load scale problem it's not because they
didn't geographically load balance it
it's very often because they failed at
the administrative scale work of it
they're not doing proper release
management they're not testing anything
they're not actually sort of figuring
out how this thing is going to operate
and function they're not necessarily
sitting and thinking about how they're
going to store data even it's all going
to be ad hoc and reactive when something
bad goes wrong so that's the most that's
the typical type of scale that most
people have problems with so the general
rules of scale right now as a first one
is
virtualization of some kind and the only
reason I suggest virtualization of some
kind is because to this day if you take
something like Apache and put it on
FreeBSD 4.9 on a Pentium 1.8 gigahertz
chip with 2 gigs of RAM that Apache will
be faster in terms of requests per
second than it is on a quad core 16 gig
of ram box it'll simply put out more
requests per second inside of that so
the truth is is that when you look at
the way that an individual piece of
hardware has scaled nowadays and they'll
both what we call a server is that a lot
of software that's still available to it
is not written to take advantage of that
so very often with virtualization you
sort of say well oddly enough if I take
16 gigs of ram and 8 CPUs and I divided
into 16 virtual machines with 16 Apache
instances I get more out of that than I
would with 1 Apache instance running in
one machine with 8 cores and 16 gigs
around so virtualization of some type or
just keeping your components small is
important the guys that are building
things like you know the big sort of
larger cell machines at IBM are taking
this on a hardware level where you have
a blade that's got 16 little servers
inside of it that are that big you know
2 gigs of ram one little cpu 1 2 3 4 5 6
and that's how a blade sort of fits in
so of course we separate Hardware
components you try to keep it simple so
if you're building your own stuff you
know pick a chip pick a type of RAM pick
a type of box pick a type of switch pick
a type of cable things should basically
add up and that's sort of a constant
question you should be asking yourself
that if traffic's coming in here and
going out the back then and it's a
hundred in the front should be a hundred
in the back real simple should always be
sort of something like that you will end
up sort of having to manage
configurations you will have to sort of
do distributed control of things as
you're sort of scaling up you should
constantly be sort of thinking about the
concept really maybe well
a bit more from like comet Oriole
chemistry if you will but how am I going
to consistently pull and split my
architecture what services can be pulled
together both logically or physically
what things should be split
I should always pool and split and
basically sit down and understand what
each sort of component can do as a
maximum and I'll give you just a perfect
example of this for when you want to
right-size an application so if you sit
and you take for example again just like
a little 2 gigabyte server with a cpu in
it just a standard sort of 3 gigahertz
old CPU and you take lighting and you
tell lighty fire up 10 fast CGI's for
ruby and connect to the database and
then all of a sudden you do that and you
say well we're getting like 240 requests
per second into that lighting and the
app isn't working anymore no response
times are junk but then on the very same
exact web server if I sit there and say
well can it serve up a static file
no problem can it still serve a static
file very quickly even though it's
clunky look under load no problem so
light e10 fast CGI's that are say
running Ruby behind them or mongrels
proxy them however you want you say well
that can still do 2,000 requests per
second of a static file while it cannot
do 200 requests per second of a rails
app yeah lighting lig httpd it's a
little webserver little webserver pick a
web server lighty nginx apache whatever
you want so you can sit there and say
well i'm not getting the throughput I
would expect but the server seems to be
working fine because it still serves up
a static file just fine I can access the
database fine
doesn't look particularly overloaded and
then you start drilling through and you
realize that well inside this stack
there's a module interface for
interacting with a fast CGI module and
guess what that interface
can only do 200 requests per second so
that becomes the fundamental bottleneck
inside that stack and determines how
many of those that you run you see this
all the time if you decide well I'm
going to take Ruby I'm going to fire up
20 mongrels I'm going to fire up Apache
and put 20 mongrels inside the virtual
host for this and then all of a sudden
you're doing 180 requests per second on
that Apache on other virtual hosts that
still say serving static files very
quickly no problem yet for some reason
you can't get more than 150 requests per
second to this back-end rails
application yeah you hit each one of
these 20 mongrels and each one is doing
50 each so it should be 50 times 20 you
should get a thousand requests per
second out of this we're getting 150 and
it's because you started digging in and
you realize that the mod proxy balancer
inside a patch is a fully blocking
module it is capable of doing 150
requests per second period so that
becomes then the fundamental limit and
your stack so as you sort of drill
through you say what are each components
and what are their interfaces what are
they capable of doing in every single
interface as you drill down
what are they capable of doing and what
that basically means is that when you
when people say things like well but I'm
running 20 my can run 20 mongrels on
this piece of hardware and they can do
50 requests per second each and 20 times
50 is a thousand how can I have them how
can I have them all doing it when only
three fit behind the pachi I said well
you got to run seven Apaches - how do I
run seven Apaches exactly and I need a
load balancer that's a load balancer and
then it just keeps on sort of moving up
and then you say well why do you have a
patch you there at all well - proxy -
all these things well it's not all it's
three of them so it's really sort of
starting at the front and saying what's
every sort of thing capable of doing as
a component and as an interface between
components that's a general sort of rule
virtualized virtualized virtualize keep
things simple that's the kiss things
should add up you want to basically pull
and split you really want to sort of
understand what your component
do and break them out that way yep no
thin has no rack
she's not big
two layers as an individual thing but if
you convert from mongrel to thin and
you're running a hundred and eighty
requests per second and you're behind
Apache you cannot do it so the speed of
thin versus mongrel actually does not
matter because that's not the limiting
factor so like for example the better
way of doing it as I'm going to say is
it if you have something like a web
server in front of your Ruby app to
serve static files and static files
should always come from static dot app
comm or something because eventually
it's supposed to come off of a content
delivery network that's supposed to be
coming from application servers so I'll
typically do things like run 4000
mongrels or say 4,000 thins and they sit
right behind hardware load balancers and
that's all they do is that there's no
layers in between nothing funny you're
keeping it simple you're keeping your
layers as low as you can and you're just
doing it that way now there are
fundamental limits to scale first ones
money second ones time because if you
have a lot of money and a lot of time
you can scale anything if you have
people that can do it with the right
experience you can scale anything if you
can power it you can scale it if you can
serve it bandwidth wise you can scale it
so the fundamental limits to how you can
sort of scale an app out there right now
is again not language choice not a bunch
of other stuff but fundamentally it's
how much money do you have how much time
do you have do you have the right people
and if you're compensating by putting a
lot of hardware behind it you have the
power the power that hardware it's a lot
there's stories of Google running
hundred megawatt data centers right big
data centers yeah maybe who knows it's
in the eighth or something but big big
hundred megawatt data centers down by
the river now a hundred isn't sound like
a very big number cuz is 100 mega so
it's a hundred million
which is a big number and 100 mega watch
is like what Seattle uses for power 100
megawatts is actually when you look at
active power 100 megawatts is I think
yeah almost 25 megawatts more than what
a tier 1 Network like level 3 has across
80 facilities right so it's a lot in a
given spot so let's let's power 200,000
things to scale our stuff can we do that
so you can do some very sort of simple
math and it's it's always a great thing
to do because a pretty common sort of
question I get is you know hey I'm doing
application why it's going to be huge
it's kind of a million people using it
tomorrow 10 million people using it a
week all of America using it two months
and there will be a billion people on my
application by 2009 how much bandwidth
is that going to use so you know you can
do some very simple math and say well
usually when nowadays when I'm pulling
up a page a small page nowadays a small
page is 120 kilobytes like Facebook app
small page the average page and now they
said is weighing in it like a Meg so if
you do a 120 kilobyte page we'll say 20
objects so there's like 19 images and
the thing of the thing coming up itself
and you just pick sort of a requests per
second constant then the math you do the
8.6 comes from 86,400 seconds is that
you're going to do eight point six
million pageviews per day so the general
sort of rule of thumb is that for a
hundred megawatts of bandwidth you will
do between five and ten million daily
pageviews so 100 megawatts of bandwidth
is what things like a 300 million page
view per month wordpress.com a year ago
did for the pages themselves not to say
static assets so you can pretty reliably
say that well most of that most of the
stuff 100 megabits per second is going
to give me five to ten million daily
pageviews now that's a nice thing
because from daily pageviews that become
CPMs and however else you're thinking
about sort of monetizing your business
and it's amazing when a lot of times you
look you say well this site is say very
popular and they say that a lot of
people do it and a lot of people go and
and you know talk to each other on it do
a lot of great things and then you look
and they're doing 40 megabits per second
of traffic at peak and it's because well
you know having a site that's doing 3 or
million pageviews per month is in fact
like a top 200 web property so that's
the sort of general limit for bandwidth
you want to do 10 million pageviews
you're going to buy one to two hundred
megabits of bandwidth 200 kilowatts
nowadays is going to give you about 400
servers I pick 200 kilowatts because if
you go down somewhere and say I want an
office here and downstairs it's dry
let's put a data center downstairs and
you called the building and the utility
and say I want to power a data center
downstairs at the most they'll give you
200 kilowatts a sort of industrial power
and a site that's about 4 node server
somewhere and you see a sort of general
rules that come out of this again - that
I mentioned earlier sort of the rule of
10 and that is that it's always nice to
sort of sit down and say I'm gonna tear
out my app there actually is going to be
sort of a front like the Apache in front
of a mongrels or something like that
tears are functionally different and I
always say that tears should be 10x
different throughput or better but at a
minimum now if you put if you can only
put say 2 app servers in front of one
database server there's something wrong
so when you decide that you're going to
put like a caching infrastructure in
front of your app then 1:1 caching
server should push out the same
throughput of at least 10 of those app
servers otherwise you have work to do on
this thing you call cache cost generally
for a free-standing application very
often end up being less than 10
revenue you look at things like the
capital expenditures on quote-unquote
infrastructure of saying eBay it's
something like six and a half percent
you look at say what Google says their
capex expenditure on data centers and
infrastructure - people is it's like 8%
so time and time again you look at it
say even large web properties are
smaller web properties and you say well
it's going to make clunk well this much
in revenue or take this much in
financing if you now think of say
raising VC is the revenue on your
balance sheet or money of some kind well
if you got a million dollars in the bank
over a year then you should really sit
and say that all the infrastructure to
put that together should be less than
100k and that's something you see time
and time and time again in capacity
planning now there's some fundamental
ways to scale as well and it's basically
just vertical or horizontal and there's
a lot of noise made about this for
example of one should one should always
horizontally scale your applications one
should always get rid of all vertical
scale that you possibly can but you
actually can't because the fundamental
distinction between these things is that
things that maintain state have to be
vertically scaled and things that are
stateless have to be horizontally scaled
fundamental rules can't ever get away
from so let me tell you like what state
is state would be like /home so I'm
gonna have storage and everything's
gonna live under slash home single name
space slash home under a given host name
and then everything underneath there
it's got state things inside databases
state an IP address state right now when
you think about how do I take something
that is normally vertically scaled like
a file system and make it so that I can
horizontally scale it fundamentally what
occurs fundamentally you remove state
and you put it somewhere else
you can't ever get rid of it because
otherwise you wouldn't know where
anything is so like for example let's
take a real simple thing out there in
the open source world like mobile FS so
the idea that I'm just going to go ahead
and store files all over the place on a
bunch of disparate storage and then
they're gonna get served up well where
all of those things are is tracked any
my sequel database how to find all of
them comes out of a my sequel database
so you've taken the idea of state like a
hostname in a path and you've put that
into a single spot over here and that
allows you to horizontally scale this
other aspect of it you have the same
thing every time you want to build a
large cluster filesystem so that all of
a sudden when you're doing things like
lustre you say what are these dual
metadata servers that are so important
well it's because instead of doing like
on a Mac where you have a file and then
a dot file name that contains all the
metadata for that file we say if we yank
all the metadata out of file systems and
store them in one spot then I can
horizontally scale all these files out
however I want but you can never get
away from vertically scaling that
metadata servers so time and time again
you see things where it's like you know
when we seduce a big petabyte you know
big petabyte you know petabyte used to
be really big like 2001 2002 type of
stuff and it's like oh my god we can't
we can't back up the metadata servers
within 24 hours what are we going to do
we start getting storage where
everything's on non-volatile Ram get RAM
sans that's what the metadata servers
become ten thousand bucks a gig because
you can't ever get away from vertically
scaling certain things so when you do
that you say well what's got state what
doesn't have state and sort of
acknowledge the fact that you're always
gonna have to horizontally scale some
things if you're lucky you're always
gonna have to vertically scale the
things that have state and whenever you
have a problem vertically scaling it you
try to take as much data out of that
possible by taking the things away and
separating the state from the actual
stuff vertical of course means
or stuff in a box which means buying
bigger and bigger boxes which is why you
know IBM can still sell large mainframes
and my son can still son sell son fires
and then horizontals got something
that's somewhat a bit more interesting
and that is that all of a sudden and
things that are horizontally scaled
above a certain size then a whole
different thing comes into play that you
haven't seen before and that is it
because in a vertically scaled system
it's all about like bus speed and
components talking to each other as
quickly as possible not a horizontally
scalable system that's also economic it
all becomes about the network so if you
have to do things like move things
around at very low latency and with very
sort of high throughput
then the network becomes the bottleneck
for you not the sort of nodes that
you're doing so what that actually means
is we're going to see in a sec is like
in the case of web applications web
applications are stateless every time
you basically write a ruby app or rails
app is that the worst thing you can ever
do is do things like store sessions on
disk
these session files they used to be the
default for rails that I wrote all
sessions to temp and that used to be the
case for a bunch of stuff and then you
have to go through load balancers that
have sticky sessions and then the big
thing with rails 2.0 that came out was
well all session data is now in a cookie
so we've taken that and pushed it down
to cookies and people are maintaining
their own state information and now
we've actually made our rails
application stateless so it should be a
piece of cake to scale at that point and
that's always the sort of idea stateless
apps are easy to scale and they are the
problem those at the front has state
meaning how do you sort of scale when
you have to connect to an IP address so
you go to your computer and you type
host Google comm and three IP addresses
come out but that's probably not three
IP addresses on three servers in the
world right so how do we take something
like a small set of IP addresses and
address them to a lot of sort of things
in the back end the application of
course does an eff state what all sort
of data stores have state and there's a
big question around how to
jail files databases and everything else
and that becomes the typical problem
that I see time and time again
especially in sort of the rails world is
the web development not networking web
developments not data management and as
you're starting to build more and more
sort of external web service
applications and that would even be
something like a Facebook application
that feeds into Facebook then it turns
out that the network is number one how
quickly things can talk to each other
becomes the limiting factor and you see
this even in things that you're doing
like let's go ahead and do a measurement
like I'm going to take a server that's a
my sequel master server and then I'm
going to make another my sequel master
and then another master then another
master and I'm going to make each one of
these the master and slave of the other
until I close that into a chain of
masters and then you ask yourself will
on a gigabit network how large can that
circle get before I make an update to
number one and go all the way around the
ring and the replication speed is slower
than the insert or whatever change
you're occurring is now on a gig network
it's about sixteen notes so it's to
better ring that big that's it so the
network becomes limiting at that point
the network happens to not be free of
course especially if you're talking
between stuff you know so time and time
again it's sort of funny because you
know we've had like in the case of say a
lot of social networking apps we did
around OpenSocial apps and Facebook apps
where until we set up peered connections
with some of these other providers you
know a guy would have a facebook app go
from no users to ten million users and
in ninety days and to be like hey you're
pushing a gigabit and a half per second
the Facebook all the time they're like
that's awesome that's awesome and you
say that's $112,000 please huh
yeah yeah a little your little stealing
panties from each other and put them on
the little image head that's one hundred
200 thousand dollars in bandwidth
Oh oops monetize yeah well you guys
don't even it's amazing I should have
built a Facebook app I know it sounds
funny but or guys at some of these
Facebook apps do so many page views
they're doing three to ten million
dollars a year in like ads stuff just
based on the CPM that they have and it's
two guys working in a garage nuts
could've been me all I had to do is come
up with something I poke you I poke you
so I would be more clever though I would
have done stuff like if I was gonna go
through and steal panties or give
panties as gifts I'd calm like
Victoria's Secret Wonder Bra something
and then ten million users later call
Victoria's Secret and say that'll be two
million dollars please so what are the
common problems for all Ruby
applications turns out to be very little
things with Ruby and there's certain
Ruby and certain Rails applications that
I've seen where they've managed to do
all of these things wrong so let's go
ahead and pick an application server
that's a bit crappy let's do something
like take the number of objects surf per
page like a great idea like I never
would think that somebody would have
eight thousand friends but the original
sort of design is to show a thousand
avatars on your page so lo and behold
every time somebody loads that page and
if they're loading it a lot because
they're curious what's going on in their
life that's 8,000 requests every time
you click the reload button or better
yet you've put a Java Script inside that
page that forces it to reload every two
seconds because you want it to be
real-time so it's a bad idea to serve
10,000 images on a page I mean there's a
reason why you can only have 5,000
Facebook friends
there's a reason why when you used to
belong to like the UCLA Network you
belong to the UCLA Network you have long
other people it's because they used
artificial or sort of social limits to
limit how many things they have to deal
with you know it's it's the same thing
with something like warcraft 5,000
people on a server and servers are in
battle groups so let's take the game and
make the game sort of reflect a certain
thing but what that certain thing is
we're only going to be able to scale to
this point so battle groups will be
twenty servers and servers will be 5,000
people each that's it it helps the game
but it's really about how many objects
you're serving in a given spot
application switching becomes actually
incredibly important meaning how do I
present
one two three four IP addresses to a
whole lot of backends statics file
serving becomes important because like a
rails application should never do it
people consistently have problems with
uploading and how one sort of store its
files and data the little sort of story
about this was you know again there was
a one site I remember dealing with where
they're loading up all these images like
per page and then fix that so you
paginated so maybe a couple hundred come
up but then every time one would do say
a snapshot at night to sort of back this
up and this is a like a real-time
snapshot on a copy-on-write filesystem
the site would pause for half an hour
that's not supposed to happen unless
there's some weird bug and a net app or
something like that so it's like well
let's take you off of this sort of file
system we'll put you on waffle and net
apps and big fat net app and do that
kind of thing because no one can ever
complain about the performance of a net
app you start copying all the sort of
stuff over and all of a sudden you know
a few hours later NetApp throws this big
error saying you cannot have more than a
hundred thousand directories in a
directory that's the hard limit waffle
set because they don't want you never
slowed it down so it's like what how do
we how do we hit that error do an LS of
home slash
/ public / images please and a day and a
half later that LS finished and there
was a million and half directories in it
with one image each and out of that
million in half directories 1.2 million
of them were some variation of the word
test and then it's like why do you have
one point two million directories with
the word tests somewhere in the name
like a weird like md5 hash with tests
and they're like oh one at the end
why are you randomizing strings around
the word test and it's like well yeah
after the first time we did a deployment
the unit tests started failing so I just
sort of randomized the name around the
directory so I'll run tests and it'll
just and it's like well when you make a
test directory you get rid of the test
directory that's a great idea okay okay
I got you
so you generated from unit test 1.2
million directories in a single
directory and that's what's making your
application exceedingly slow and and not
capable of being on a million-dollar
piece of storage and you can't do
anything so storing files and data they
don't go on home / app / images should
never be that strapped not on production
infrastructure
not on production infrastructure so your
application servers right now is for
rails and Ruby something like mongrel
there's other stuff out there mod rails
thin then being sort of a event based
type of mongrel it's fine
longer lap happens to be good enough for
most stuff JRuby plus your preferred app
server you know stuff like Apache PHP
these are real sort of simple types of
app servers now in the case of Ruby when
mongrel came along mongrel actually in
fact saved rails and saved rails
deployments because it went ahead and
made an explicit choice for the Ruby
community see the way that you typically
do
things as you know you can take
something like my brand bacon see the
board you can take something like Java
and say I'm gonna have something like
the JVM and then I'm gonna have all
these things and I'm going to call now
threads within them and they're all
going to sort of have this shared heap
so that's heap and that's a VM and these
are a quote unquote threads now
initially the JVM said I'm going to
manage threads and then they said well
that's actually a bad idea that in fact
there's this operating system that lives
above it that's actually pretty good
so why don't you make these threads
kernel threads and then we'll all be
okay and then you have now a vm like say
Erlang where you have real sort of
things that aren't threads but they're
real sort of lightweight processes they
don't have a shared heap each one has
their own heap like that and that's sort
of the next step up and then what does
Erlang do erling basically fundamentally
does process management and it's
exceptionally good at it because this
language is sometimes a meant to be put
on metal or a real minimalist OS they
didn't do good process management now
it's funny because a lot of people were
like Ruby needs to do threads Ruby needs
to have this or have that or do this
kind of thing the VM needs to be better
or worse or anything like that and they
ended up in some weird amalgamation
inside the middle when really what you
want is you basically want an operating
system doing Process Management and you
want now not lightweight processes not
threads you want real processes each one
with their own sort of shared heap and
go ahead and let the thing call the
operating system which is in the case of
say UNIX been evolving for a long time
around process management so mongrel
basically said and you have the same
concept between say Apache and fast cgi
in processes right we're in the case of
that you know what was something like
Apache supposed to be Apache was
supposed to be this big thing here they
use a fast CGI interface to sort of take
persistent processes within
each one of them ends up sort of sharing
memory and some sort of bits but each
one is fundamentally now a process being
managed by Apache and Apache sort of
being managed by the OS and you've got
some sort of oddities like is the module
interface limiting or where is a problem
sort of occurring so mongrel said let's
take a ruby process and minimalize it
down to something very small and we are
going to explicitly say that this Ruby
process will speak HTTP that's it so do
that and you take a single process its
own heap and you let great operating
systems with a great process management
manage them and that's all and in the
case of say mongrel is you know and
variations that came after that it said
now let's go from this whole idea that
the Ruby VM even matters to the fact
that maybe it doesn't matter that all
the Ruby VM now becomes is something
that's managing the size of heap and
what that interpreters doing but it's a
process being nestled within an OS and
regulated that way and that really sort
of simplified the model for Ruby
applications and a lot of the times when
you hear people talk about the way that
VM should or shouldn't be designed the
way the interpreter should behave the
way app server should behave they're
trying to sort of not take one stand or
the other you have to pick the way the
JVM has done it for a reason the way
erlangs done it for the reason way
mongrel has sort of implemented ruby
apps for a reason that these are in fact
Quantum's one two three let's not do
things in between and a lot of the stuff
is in fact in-between so mod rails for
example isn't in between let's
complicate the stack even more let's add
in something now called Apache that's
managing processes and other stuff and
there's a more interfaces and more
components when in fact it should be
nice and simple so that's why monitor
was nice nice and simple the stuff on a
page is sort of funny
look stuff on a page is something like
TechCrunch for example is the
prototypical modern web page one point
four two megabytes in size 125 objects
per page as it sort of serves up and
JavaScript fakes a whole bunch of stuff
and by the time it's done faking it
takes 32 seconds for that page to come
up once everything's all been faked
something seems snappy but they're not
Facebook 105 requests 260 kilobytes the
interface is minimis for a reason
because they wanted to come up in 10
seconds now Yahoo does a better job
42 requests 209 kilobytes 5 seconds
Google News pushes it down to 51 keeps
the requests small as possible so you
want to sort of minimize all the stuff
that pops up on a page as far as objects
go you want to decide at some point that
if you're going to have to switch more
than 100 megabits per second of traffic
you do actually have to buy hardware
that does that for you so the best thing
for Ruby applications in mongrel
applications you get to a given point is
you buy a big IP that's that's in fact
the best thing at it the reason that's
really great
you know this isn't an f5 pitch or
anything is that you can actually it's
one of the few Hardware load balancers
you can buy or you can pack in like
10,000 backends things like the Juniper
load balancers you buy the integrate and
the switches are limited to 64 backends
on a configuration file net scalars
don't scale a lot of disparate backends
like that in the case of rails
applications that are doing one request
per second each and you need to do 5,000
you got to run 5,000 of them to do that
to sort of compensate for it you know
full sort of load balancing and then
great test so this for example is saying
if a mongrel ever gives me a 500 error
redirect the traffic to another mongrel
and don't ever talk to that one again so
that you get rid of all those types of
you know problems inside of them and
then as we're going to see if you're not
quite able to do fancier stuff you can
go layer 7 sorts of things so the idea
being that layer 7 says anything that
comes after the URI
login a slash calendar a slash list of
slash mail that that traffic direction
can occur to different servers depending
on what comes after the URI to solve the
how many things am i serving per page
you use things like asset 1 join com
asset to join com asset for join comm
and you take that infrastructure and you
serve it separately and when it comes to
sort of storing files
you know Jamis from 37signals a couple
years ago I wrote a real great it sort
of thing he calls it ID partitioning for
some reason but it's a hashed directory
structure and it's saying that well the
file system they're using you can only
put 32,000 files in a given directory so
even though you're storing stuff you
have to basically space them out
yeah and it's a very sort of old solved
problem let's take the path name and
make it something that sort of logical
will store in a database and will come
up with rules around there and what's
funny is that people even still talk
about the sort of web app database type
of structure anymore when in fact the
sort of web app database type of
structure has been dead for a long time
in that what you generally make is you
make load balancers caching of some kind
application caching of some time data
and then you silo these off as different
services and you just sort of repeat
them like that where you stick the cache
depends in the case of some load
balancers there's a cache at the back of
it in the case of some applications they
cache some data in the case of some
applications interacting with the cache
the caches with the app or the caches
say a memcache type of cache or it's a
cache that sits in between the app in
the database or it sits in the database
so meaning that load balancers
application data and then caching layers
in between where you're sort of building
the cache fluctuates from say load
balancer to its own entity to the front
of the app to back of the app its own
entity front of the sort of data store
and you sort of have all these caches
you worry about
yep
it entirely depends and that's the
problem is that people don't talk about
the depends enough and the depends
aren't accounted for by frameworks
meaning that and I'll give you some
examples of this I mean that very often
if you're doing a very sort of simple
query with a rails application against
my sequel my seek will be will be faster
at doing that then accessing that data
has a small array out of memcache so if
you're writing a little rails app and
you got my sequel and you throw memcache
in just to see how things are going
you're sort of developing and testing
accessing the database directly will be
faster for most stuff but now of what
you have is say 2,000 friends that need
to live and they sort of predetermined
array of some kind and you want to cache
it and you don't have a lot of people
using it and pulling that out of a cache
is faster so it depends sometimes
sticking things in one terabyte size
binary files that you sort of rearrange
it and you put an index on the top and
you occasionally vacu them and you sit
them down and you do various sorts of
things as faster than accessing a
relational database so what doesn't
occur and we'll sort of see this in a
bit is it there isn't very often
discussion of what tape what type of
data
do I have where should I put it how
should I serve it how quickly does it
need to be served is it really has to
have a hundred millisecond latency or
not and that sort of things not baked in
to save frameworks I can't go through
say you know my rails app and say oh
this data here this objects created it's
very important I want it done four times
across for physically
distinct things here's the IDs for the
four physically distinct things and if
somebody generates it they need to see
it immediately if somebody who has never
been to the site wants to see this
content they need to see it immediately
but their friends can see it within ten
minutes and their friends can get an
email about it within an hour and I'm
going to put all the metrics in place so
that I can make sure these things are
occurring 99.9 percent of the time like
that thing not baked into rails or
anything or Ruby or nothing right so
there's also the concept now for a lot
of stuff of cashing up getting like in
the case of say Facebook Applications
you can preload all the stuff into say a
social networking app and then write
something in tickle you know TCL inside
say a load balancer and say hey if
they're asking for this URI just serve
it yourself yeah
at defense no you can dominate give me
money or you can in most web servers per
second for a static file that say less
than 20 kilobytes so yeah absolutely
but those things aren't explicitly baked
in
I don't know actually and I'm not so
sure that it is always faster depending
on what you're doing for a hello world
application JRuby and most app servers
is faster than most c-bass ruby app
servers so tears and silos is typically
the thing that you basically sort of
structure it out and you pay attention
as we said earlier to all the sort of
connections in between a tiered and silo
application is to say that well I'm
going to make DNS entries in I'm going
to have things like static domain com
dynamic domain calm and I'm going to sit
down on the side that I'm going to silo
out my data depending on what's
important you already do this if you're
like storing files differently from a
database without necessarily thinking
about it you actually have a static file
silo and like a database silo but what
you end up doing for example very often
is people will say things like oh you
know what actually our user database now
is so big it shouldn't be with all the
data data let's break it out to its own
database you've siloed it now it's on
its own sort of thing you've made a
service out of it so that when you sit
down and say from the very beginning I'm
going to write Ruby on Rails application
that's sort of scalable then I'm going
to make sure that I at least have sort
of a domain.com is an explicit idea
there from the very beginning I'm going
to decide that I'm going to write a set
dot something dot com as sort of a
static silo that all statics go through
I'm going to sit down and decide that
uploads have to be authenticated I'm
gonna break out an authentication system
I'm gonna break out the uploading
eventually I'm going to write my own
uploading and queuing application that
takes care of it it's not responsible
for page load time I'm going to take
downloads some downloads have to be
authenticated some don't I'm going to go
ahead and say that I'm going to
administer things an administration
needs to fundamentally be eventually
sometimes its own app so a lot of times
you sit down and you say well from the
very beginning it could be like one app
could be one little rails after Ruby app
you're writing
but there will be the idea that there's
the main app itself there's static
assets on that page there's things that
might be uploaded there's things that
might be downloaded and the app might
have to be administered and from the
very beginning those are at least
different DNS entries and they can
eventually sort of become their own
sorts of other things
so I'll give you a I'll give you a great
way to do that as we go I don't have it
but so let's say for example that it
becomes Jason my opcom William mayakam
so there's a few ways of doing that one
is that of course a wild card doesn't
fly because you can't wild card that
that defeats the purpose
so Jason dot app calm and william wright
AFRICOM has to have their own a records
going to an IP address that may or may
not be different well but there's two
ways of doing it with a DNS service so
one way is like the idea that I'm going
to have a zone file like a single zone
that contains maybe a million different
a records inside of it which becomes
impossible to update within a reasonable
amount of time so what you do is you end
up writing zone files or zones in a
database even for like a DNS based
system where each one is treated as if
it's its own domain name so instead of
having like zone for domain calm and
then having an entry for JSON domain
calm William dot domain now if
everything else its zone Jason domain
calm zone william of domain calm zone
domain calm zone wildcard and so on like
that so that each individual entries you
move down the sort of fully qualified
domain name chain becomes their own zone
entry not their own entry in a zone and
that is a scalable way of doing
so as I was saying earlier just on the
last sort of two problems is for the
administrative scale this is where teams
building any kind of that fail when a
lot of the sort of app stuff comes out
bad so the thing just to keep in mind is
that administrative scale business scale
Tim's team scale is in fact a valid type
of scale to think about that the way
that you're going to operate an
application has to be a consideration
there actually has to be things and it
seems funny sometimes if you're in a
very structured development environment
there actually has to be things like
release engineering and rollback plans
and maintenance that's scheduled so you
have to be proactive not reactive and it
becomes a very much sort of cultural
thing and time and time again it's like
I sit there and you sit there with like
you know a customer or somebody else and
you're like these guys are having a real
problem
scaling none of it turns out to be
technological for technical it all
except being things like all the ops guy
and the lead developer they hate each
other and the data problem is actually
not even remotely solved so meaning you
know how do i from the very beginning
have an application or a framework where
I can make decisions about how the data
is stored how it should be served how it
should be replicated or not and what the
sort of requisite backends for those
things would be how I can make sort of
different choices between them and how
those backends can scale for
applications how can I have a back-end
that scales a lot for writes one that
scales a lot for reads one that stores
objects that are precompiled ones that
do not things that are object based
things that are relational things that
are on disk things that are in memory
how do I sit there and start tearing and
siloing out my data beyond just a that
should be a file that should be in a
database type of idea but there there
really is no
Solutions for that it's not baked into
languages like Ruby and it shouldn't be
but it's also not really existent in
most frameworks now and if anything ends
up being sort of the next big frontier
if you will in terms of of what sort of
solve scale is give me a great either
multi purpose or multi siloed data store
as backends that I can write a normal
web application to and they can go from
one user to a billion users in one site
to twenty sites and one continent the
four continents without a rewrite and
nothing exists it allows you to do that
and that's it thanks everybody yeah if
you have any other questions if people
like to come up to the mic then that way
you'll get on the video okay so I guess
now we're gonna head downstairs and try
to get some food question you can
alright you can also say the question I
can repeat it
Oh which is who's that repeat questions
on the back for me yeah and actually one
other thing I were to throw in olivine
II actually came here and gave a talk on
JRuby and it's on YouTube and he
actually is a pretty good book called
practical JRuby on Rails yeah you should
read yep just wondering for those of us
who didn't quite catch all of it and and
just for future reference do you can you
recommend any articles or books or sites
well so yeah if there's if there's
anything that becomes I most people
refer to either Theo's book scalable
internet architectures or Cal's book ok
I guess I'll I'm gonna say I'm it'll be
a public video on the Cal's book is yeah
it's ok I mean it's it's mainly like how
do you use my sequel and do replication
and that kind of stuff
Theo's book is at least a bit more how
do you sort of sit down and
think about architecture and quite
honestly that's really the only book
that's sort of out there there's a few
good articles as well they're pretty
much all in use Nick's presentations
which is probably one of the more
interesting things to me about computer
science is that conference proceedings a
still a valid place to publish things
it's not like that in other sciences
anymore
there's a few but not too many yeah yeah
second question I have is just the last
thing you said seemed a bit surprising
because it seems like there are there
are some things to help you with scaling
your app massively right there's joinin
offers some things you've got Amazon Web
Services and now you've got Google App
Engine I mean what you know sort of
missing from these what's what's missing
is that all of those things and you know
we're a perfect example of that is that
fundamentally we end up having to scale
my sequel for people and save some cases
the real question is why are they using
that in the first place
and it's because of ease of access not
because it was the best choice and
Google App engines great as well and
BigTable straight it's great for reads I
mean so you have a thing where I can
read stuff really fast but what if what
I'm doing now is something that's really
closer to like a real time gaming
application and 50 to 60 percent of what
I'm doing is a lot of really small
writes that's in fact a different type
of thing
than a very fast read sort of you know
datastore and the thing time and time
again is I would just love it so that if
five 10 years from now we would all look
and ideally things would be advanced in
our field and an advancement for me
would be that architecture and
operations becomes baked as sort of the
default way that frameworks operate that
the default right now for rails is to
say use
my sequel and that's all that's it so
it's great for an app that for people
use but to go beyond that which means
doing things very often like I mean it's
funny when you say okay so we wrote a
rails app now let's break it out and
write them as a custom mongrel handler
and then let's take that custom mongrel
handler and push it down to even another
thing that's a see extension didn't
being its own little C app doing it well
is that really the sort of framework
progression that a rails app should go
should have really go from a rails app
to a custom mongrel handler to a C
extension to an app and see maybe you
know I mean it's not it's that sort of
things not quite baked in and then you
know when it's like okay so now guess
what it's time to use more than one my
sequel database okay so where's that
concept in rails it's not there
where's concepts around data
partitioning or developer having an easy
way of deciding what's important data or
not not not there and it's not there and
really any framework so any else yeah
traits like luxury that the same
decrease that things like ten or that a
different implementation they can it
over is different so that the question
is is DTrace in solaris the same as
DTrace in leopard and the answer that
would be that they're different
so dtrace as far as a how do you
implement a dynamic tracing framework
for a given kernel and for userland
software is DTrace but those
implementations and those two different
kernels are different but they have the
same api the same interface and
everything else so it's the same kind of
thing where even though it's linux is
different and from solaris is different
from these various other things they all
have a C API as being a fundamental
feature of Unix
so the implementations are different but
the sort of front end that you interact
with is the same is demonstrated with
the leopard with those Dame
functionality with that functionality
still be available as lass
yes I have case example I wanted resent
that would be when you start getting
into deeper things like memory leaks and
that sort of thing you do right platform
specific things to probe that because
they're different yeah
yeah but so I don't I don't work at
Twitter can I add them as a customer for
two years so yeah a lot of the examples
I gave could plug stuff in if you want
maybe maybe not I mean yeah I mean
pragmatic realistic I think Ruby's great
they all languages are great just think
that if you ever do something because
you're gonna do it in Ruby you're
actually just a hobbyist who wants to
play around with a given type of hammer
and not really interested in building a
house
so Ruby's a tool just like a lot of
other tools are and talking about tools
are fine but fundamentally we should be
talking about what we're building and
how we're building it and the truth is
is that the community is never served by
being negative or mean that's also never
served by being very optimistic about it
and you know so the fact is is that Ruby
release management is unprofessional
sorry nothing no not from the language
itself every app I have sinned Ruby got
lots of Ruby stuff but you know there's
also things that you know I think that
one sort of looks and says what you want
to do and if Ruby isn't right you can
make it right or do something else but
it's the you know it's what you're doing
that matters so the Ruby's great I've
loved it for a long time
I would call it pearls prettier younger
sister so anything else okay there's
food so thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>