<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Seattle Conference on Scalability: SCTPs Reliability and... | Coder Coacher - Coaching Coders</title><meta content="Seattle Conference on Scalability: SCTPs Reliability and... - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Seattle Conference on Scalability: SCTPs Reliability and...</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7tN7xhw1zE8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon everyone welcome back
from
keynote I've got a couple of people down
from the University British Columbia
bread pan off and Alan Wagner are going
to talk to us along with Mike's I about
s I always get this acronym wrong sctp a
it's a transmission control protocol
alternative so an alternative tcp for
moving data around our data centers
between them there are a lot of
interesting scalability and reliability
trade-offs and I hope they'll enlighten
us on what those are and what they look
like Brad noun Nona hi thank you so
thanks for coming my name is Alan Wagner
I'm a faculty member at the University
of British Columbia and this will do
this talk in sort of three acts act 1
i'll talk about an introduction to to
the talk Brad who's a PhD student at UBC
will come up and talk about some of the
details of sctp and then I'll come back
and talk a little bit about some of what
we've applied sctp to so this talks a
little bit different maybe in two ways
one we're coming from University so no I
don't have a hundred thousand machines
or ten thousand machines I'm afraid and
the second thing I guess we're this talk
is more going to be at a lower level in
the sense that we're going to talk about
the most more from the networking side
of course for any machine you know
there's really the processors there's
really the disks and the i/o but there's
that third part at the networking and
that's what the focus of this talk is so
I think my whoops
oops sorry so the first question I guess
has already been answered what is sctp
the acronym stands for stream control
transmission protocol it's an ietf
standardized transport protocol for IP
what does that mean that means basically
it sits alongside TCP and UDP as a
transport protocol ok it in fact can be
used in the same way that you DP and TCP
can be used ok it's a standardized
protocol that's available you can go out
and read the rfcs for it and you can
download implementations of it it's a
relatively new transport protocol and
it's for reliable and the keywords are
reliable and message oriented data
transfer and the third point is that
it's really the only reliable IETF
standardized protocol has been
introduced in 30 years I mean TCP of
course and UDP have been around for a
long time they all sort of show in their
age a little bit and one of the reasons
for setp was sort of to address some of
those some of those features that that
you would like to have say in in a
transport protocol so why should you
care well I guess I've said a little bit
there's new future features in there
right new things that you're going to be
able that means new opportunities new
things you can exploit and the purpose
of this talk of course is talk about a
little bit how it adds or can add
robustness and reliability and some of
this comes about because of new
challenges that are appearing in the
internet and perhaps one of those
challenges are things like multi-homing
where for example machines typically
these days have multiple ip's not just
one so so hopefully that's the that's
why you might be interested in hearing
the rest of this talk who are we as I
said there's myself we have we have a
group at at UBC we've been working for
probably three or four years now there's
myself there's Brad and Mike who are
here today Brad
their mics all in the front row Carl is
up he's working for us for the summer
and humaira another PhD student will be
joining us again she was at UBC before
she'll be coming back to do her PhD with
us in the fall I should say that this
this research is funded by a cisco
university grant and also by the
canadian government through our end
search who are our collaborators the one
of our key ones is Randall Stewart he's
from Cisco he's a co-inventor of sctp
he's the IETF lead on setp and he's the
and he along with Peter Lee are the main
implementers of the stack for freebsd
and for cisco we also work with
pavillion and Michael both both like max
so they've both taken basically the
FreeBSD stack and need done what is
necessary to get that to work in Mac OS
X so if you're on a Macintosh you can
also download in and run sctp and
finally we work as well with with Jana
who's a recent graduate from University
of Delaware University of Delaware also
has a number of people who've worked in
related areas on sctp what are our
interests so as I said we're a little
bit users of sctp in the sense our main
interest was using setp over to sorry to
put setp underneath MPI which is MPI is
a message passing interface it's a
standardized well people say it's the de
facto standard for parallel programming
for scientific computation what that
means is of course there's lots of lots
of programs out there that are written
in MPI probably some of the largest I'll
perhaps you couldn't say on the most
machines but certainly some of the
largest most high-performance codes that
are out there in fact are implemented in
MPI so it has MPI has been an extremely
successful library what we were
interested in doing was seeing how this
could run mostly in a wide area network
we looked at implementing and we looked
at putting a CDP underneath MPI rather
than using TCP and what would be the
potential Vantage's of that we've
implemented an M pitch to sctp channel
what that means now if you go to Argonne
National Labs you download em pitch to
our code is contained in that you can
turn on the module and run if you have
the stack turned on you can run your MPI
programs on over sctp and again this
isn't you don't have to change your
program to do that we've done the work
in the middle where to support it we're
currently supporting a module for open
mpi open mpi again these are both em
pitch to and open mpi they're both open
source projects the open mpi is a
consortium companies headed by Cisco but
both of these are open source versions
of MPI that you can download and for the
vast majority I think they're the two
most widely used implementations we also
do a lot of testing evaluating of our
programs of course and we've done things
like task farming and scientific
computations some stuff and
bioinformatics and what we're interested
in is seeing how maybe to exploit some
of these advantages that we see an sctp
for clusters and how we can take
advantage of it with respect to
scalability and in particular fault
tolerance so the rest of this talk is
really has two goals the first goal
hopefully is to introduce you to a
little bit of the features of st to be
that you might not be aware of so i hope
that that's a new material we haven't
the the protocol itself is quite large
there's a number of features we're just
going to focus on the ones that we feel
add the most for reliability and fault
tolerance and then we'll come back and
i'll talk a little bit about task
farming and how we can make use of these
features so let me ask Brad to come up
and he'll give the other part of this
talk
the liver loop so thanks Alan so yeah as
Alan mentioned I'm going to focus on
some of SCT piece features so it is in
some respects similar to TCP its
connection oriented it offers services
like congestion control and flow control
it's also reliable and available on most
major operating systems but that's not
really the focus of what we're going to
be talking about here what we're going
to be talking about here is looking at
some of the newer features and how it's
not like TCP so these are the six that
will eventually chug through here the
first one that we want to focus on is is
multihoming so first off what does it
mean to be multi-home a multi-homed on a
multi-homed toast is a host that has
more than one Nick on it and you might
think that that's not very happening
very often well I mean in a cluster it
may happen because you'll have your your
management network your storage network
etc so that in that case those nodes are
multihomed I mean even this laptop that
I'm giving the presentation on comes
with wireless and then standard wired
Ethernet so I mean it's multihomed as
well so that's what it means for a host
to be multihomed in order for a
transport protocol to support
multi-homing that just means that the
connection between two endpoints is
aware of the multiple paths between so
when you traditionally when you say
connection you generally are specifying
a path to so an sctp they use the term
association to talk about the connection
between the set of Nick's on one end
point to the set of Nick's on another so
now that if looks so okay great you have
multihoming what what can you actually
do that with that how can you use that
for some additional fault tolerance and
I'll just walk through a few of the uses
so say you're sending some data upon one
of the paths so we're sending the data
across
and for whatever reason that data is
dropped so an sctp alternative paths are
used by retransmission so in that in
other words retransmissions are pests on
the alternative path so that's more for
like a one-off you know sort of air
let's let's say that you know maybe
we'll have a more catastrophic error in
the network not just a packet dropped
here there so setp when it's doing its
transfers will initially send all its
data upon what it deems to be the
primary path but if if like we said a
catastrophe happens in this path you
know a switch dies or you know router
goes down for example sctp has the
ability to failover its data transfer so
from then on out the data transfer will
it has a new primary path more or less
this happens transparent to the
application so that anyway it makes
applications and that respect somewhat
simpler because they don't have to worry
about that but the transport protocol
does naturally since there's multiple
independent paths between various
endpoints you might as an administrator
be thinking well I'd like to take
advantage of all that bandwidth like I
mean there's just a whole other one
being wasted therefore fault tolerance
so there's there's been work at the
University of Delaware call for as an
extension for sctp work and not just
using that the paths for fault tolerance
but also but you and failover but using
all of them simultaneously to transfer
data pads in between this is an
extension that it is actually available
on freebsd 7 that you can just turn on
with a system control command there's a
lot of interesting research issues there
with respect to scheduling messages and
and how how it all happens isn't a simp
but as a feature it's there and so and
as a user you can use it so that sort of
gets us to pass multi-homing the more
simpler feature is the fact that sctp is
message based so will just illustrate
what maybe that entails with a really
simple example where we have an
application where we're sending three
messages from endpoint wide to X so yeah
we write the right system call occurs
and then in that you know they're passed
through the network and they arrive in
the kernel and their queued up in the
kernel a 10 point X so in TCP what
happens here the application asks for
the data read read system co-occurs boom
some data is passed to the application
so what what is interesting about this
data is that there's no boundary between
the messages that were sent and also
you're getting data from potentially
getting data from future messages so
what what this means is that the
application itself it has to be made
somewhat more complex because it has to
do the message framing it has to buffer
these extra portions it has to parse
data you know be it via de limiters or
you know have been having some knowledge
either in data or a priori of size in
which to look for these boundaries so on
the contrary sctp like UDP when I read
occurs the boundaries are actually
preserved so the the feature here is
that message framing isn't inside the
application and therefore if some
applications can that that are that are
not streamed stream based in inherently
are simplified because they don't have
to do the message framing themselves a
third feature that that is interesting
and sctp is their multi streaming
feature sort of to motivate this feature
and we'll go first by motivating the
future and then describing the solution
and showing it in action so to motivate
this feature say we're sending the same
33 messages from Y to X all these
messages
are independent and so we send them
across they're all in the network and
the thing that a problem occurs message
a is dropped for whatever reason in the
network we're using commodity switches
say okay so the the next two messages
are queued up in the kernel and your sit
so let's say that application on X is
like all right I'm ready give me some
give me what you got it see the problem
the head of line blocking problem here
well this is what hell I'm blocking is
is that B and C cannot even though
they're independent of a even though a
BSC are all independent of each other
they're made dependent upon each other
just because of TCP semantics so so so
that's sort of the motivation for you
know this problem the solution that came
up that the designers of sctp came up
with was within an association there are
independent streams going and orders
only maintained on a given direction on
a given stream that's that's the only
thing guaranteed so just to see this in
action say say we wanted to send
messages ABCD and E and our only
ordering constraints ordering
constraints are that message a has to be
arrived before C and CS arrive before d
that's what the colors are supposed to
indicate so what we can do as an sctp
application developer is put messages a
C and D on one stream put be on another
stream put ee on another stream so
that's what we do we send it across and
then okay this is where we start to talk
about catastrophe and for whatever
reason once again in the network maybe
and C are dropped so what do you do on
the applications as it being looking at
it from X's standpoint it sees these as
three independent streams so so what
what but what still happens in sctp is
it can still deliver x e sorry you can
still deliver
message e to the application thereby
avoiding the head of line blocking
problem that was present in TCP so then
once a B and C are retransmitted you
still can't deliver d to the application
until the end this is then this is
because order is only maintained within
a particular stream so so on to the
fourth feature the fourth feature is
actually has its roots in TCP it's
called selective acknowledgement it was
an extension brought up by Sally Floyd
and her team in the early 90s which and
just to sort of review what that is so
will just illustrate with an example so
say say we're sending messages a three
once again I like my alphabet so and
we're going from Y to X and for whatever
reason every other message is is dropped
and so looking at it from from what will
happen next so what happens next is what
sac is is sac is more descriptive it's
able to tell why exactly what was lost
and so what this means is that when
retransmissions occur the actual number
of retransmissions is is less okay in
this example it's not as substantially
less but but this is a simple example so
that's what sac is in general so why is
it interesting for sctp like because
okay that's that's present in TCP I can
just turn that on so what how it's
unique in TC in sctp is OA it's built
into the protocols you don't have to
worry about basically implementation
specific issues it is built into the
protocol because it is built into the
protocol and it's not an extension when
s when it's implemented in TCP it's
actually implemented in TCP options that
limits since TC the TCP header is a fine
you know a certain set of bytes of bits
you can only express so many
so I think then the actual upper bound
is expressing for gaps so setp can
express more gaps than TCP so like I
said in this simple example you only
express to but in more complex examples
it's been shown that so that in high
loss situations larger express more
expressiveness in sac has been shown
tremendous benefit so the fifth feature
that will look at is se teepees stronger
checksum so like TCP there is a check
soon so okay so so how's that so let's
break that down it there's several
different checksums along the stack but
when you're actually when you're looking
at on the end-to-end pneus certain
portions of the of this of the checksums
like for example Ethernet is only on a
per hop basis so the only thing
guaranteeing your actual into end
reliability is TCPS 16-bit checksum so
research has shown that on the order of
1 and 10 million packets arrives
corrupted to the endpoint and but is
what passes the checksum and it's sort
of integrated into the data of the
application as valid so so that's that
mate you might say okay that's not a
problem i have my application i've never
seen a single I've never seen this
before well yeah a lot of applications
smaller applications don't ever run
enough to the point where this is
observed but for large-scale
applications this number starts to take
on a little bit more meaning that the
amount of zeros is important so the
designers of sctp were given a lot of
input from the telephony community where
its roots are primarily from but also
from the i/o community and in the end
they decided to use a stronger 32-bit
checksum called the CRC 30
you see so on the upside it is more it's
it's stronger so but on the downside
it's also also more computationally
intensive typically in TCP we don't have
to worry about the computational
intensity of a checksum because its tip
it's usually available for offloaded on
the neck but s currently crc32 c is not
commonly available for offload on the
neck this is changing there are there r
io processors available that do offload
this computation and even if you're not
using them maybe this cost is actually
worth it if you if if you're concerned
about the reliability of your
large-scale data applications so the
final feature that will look at is a SE
tepees choice of socket API so sort of
it might be deemed as uninteresting but
ok so setp supports something looking
like Berkeley sockets so that just means
that if I wanted to write an sctp
program tcp style I can do it if I
wanted to write an sctp a program UDP
style I can do it but probably most
interesting is if I already have an
application that's used that I want to
maybe try out with sctp porting it is
actually quite simple all it is is
changing the parameters to the socket
call more or less so but what this will
do is it'll you know give you some of
the the free features like multihoming
or a stronger checksum but in order to
access some of the more advanced
features of sctp there is also defined
an extended sockets API so what this
does is allow you to utilize newer
features newer features like multi
streaming and then there's also several
different socket options that unlock and
let you tune various sctp runtime
parameters
so we've walked through so far six
features there's several other that
we're not really going to go into here
these are just sort of listed here for
completeness so in summary these are the
six features that we did review and in
terms of this talk what's going to
happen next is Alan's going to come up
and he's going to discuss how these
features can be used in cluster
computing Thanks thanks Brett so let let
me discuss some of our experience in
using it for task farming I guess task
farming you've heard a lot about it
today it's course an extremely common
strategy for work distribution the
picture i have up is a task farm that
that we've often used as you can see
actually the task farm there's a manager
on the on the right it of course creates
tasks it ships them off to workers
workers work and do all the tasks and
then perhaps the results get returned to
some other process often when we've
implemented processor farms we actually
have the workers request the tasks
rather than simply ship all the tasks
out to the worker one of the reasons for
doing this is because if you make
requests and if you have a slow worker
then that worker just doesn't get as
much and doesn't do as much so of course
you know this also known as a map
function you have a thing you know have
a function you would like to you know
some computation you'd like to apply
that over a set of data items those data
items are all independent in the sense
that that function could be applied in
any order over those data items and
that's you know gained as as the
MapReduce system shows I mean that can
be a pretty effective way to make use of
a lot of processors
but let's go so given this basic setup
let's go back to some of these some of
these features that that Brad was
talking about and see how maybe some
aspects of that could could help us one
of the things well let me back up and
just say that I mean the best thing that
you can hope for in a task farming I
mean at least one of the main issues
load balance and I don't have up there
that's another one of course but is you
want to keep everything busy right you'd
like to get as much work tossed over
your shoulder as you can what does that
mean well that means that you're
probably going to be buffering tasks
inside the inside the workers so that
you know minute of worker goes idle bang
he just you know switches buffers and
starts working on the next task you want
to have you know in our case we want to
have requests going out on the lake
because you know especially if you're
using an IP transport protocol it takes
maybe you know 80 milliseconds so you
want to make sure you're making requests
out there early you want to make sure
that the tasks are flowing in because
they might take some time so you want to
basically keep as much stuff active in
the system as you can and that's how
you're going to keep those workers
really really busy and know and there's
not going to be any slackers so so it's
buffering overlapping communication
computation this is where we feel sctp
can help us so those again are the
features that Brad talked about so what
about let's so let me turn to feature to
in six first if you look over on the
left you know requests tasks results
these are all messages and you know this
isn't streaming data these are basically
Bessie's paths the fact that setp is a
message passed a transport protocol
helps us at this that simplify some
things you know a lot of people have
developed similar type systems using UDP
but if you do that using UDP you have a
choice either you're not very friendly
and the network right mean you don't
mind swapping everybody or you end up
having to rebuild all the things that
TCP have inside your your UDP based
application setp has done that why do
why do it over again so that's one thing
message pad based for these types of
systems it was true for mpi as well it's
just more natural
the other thing that's maybe not is
obvious and if you go to the one-to-many
a style of and that's the UDP like style
of sockets is for example a manager
basically to talk to a lot of workers
only opens up one socket so it acts like
UDP that is if a worker wants to send me
a message they just send it to the
single socket comes in i read it off the
socket and I and I do what I have to do
with it right what this means is if you
can imagine a system now with many
managers and many workers is you don't
have this huge number of sockets that
can begin to explode on you right you
have at least an MPI you sometimes get
this sort of N squared every processor
has to open up n sockets we're in for a
large system could be a thousand ten
thousand or its opening and closing its
managing all the state right this
simplifies it simplifies by just having
a single socket or a few sockets if
necessary so that's another advantage
multi streaming and selective acts again
the picture on the left where does multi
streaming help us well again it helps us
remember we want to throw as much stuff
over a shoulder we want to keep as many
requests on the sit on in the network we
want to keep as many task flowing in the
network so of course what happens if we
lose a request or we lose a task well we
don't want to be delayed we don't want
to have that task in front these are all
independent we want that task behind to
be able to jump ahead so if we arrange
things by putting requests and tasks on
separate streams which we do right what
this means is that if we see a loss then
it's okay the the the task coming after
will get delivered so we can keep those
buffers full a little bit easier the
other one and we've done some
experiments with this to see try to see
what the potential saving would be in
exactly this these types of scenarios
and you do have to you know in MPI at
least you have to make sure I mean one
of the things of course you need in a
system like that is you need a
non-blocking communication you have to
be able to do a lot of sense
non-blocking and you have to be able to
do a lot of receives right non-blocking
in the sense that you're putting out
requests right receive requests right
that way things are happening behind you
as things come and go
headline blocking does occur does help
to have things in separate streams and
the other one that as again you get
basically for free is the sack
processing and we've seen occasions in a
game this is admittedly in fairly high
loss situations but its weak you can see
a huge benefit for the extra sack
processing an sctp and it really
basically it punches through when TCP
links are in fact dying okay so it's
going to go a lot longer and still be
able to deliver data when when your tcp
lake would basically be be host the last
two multi-homing stronger checksum and
again I these basically come for free
because these are implemented in the
transport protocol multihoming uh it
just adds that additional reliability
right that means if you if if a path
goes down it's going to reconfigure its
going to flip over to a backup path and
it's going to continue you're not going
to see the difference you can I say that
you're not going to see the difference
you can request to see the difference
right you can get a notification which
isn't a bad thing to get because if you
get the notification that one of your
primary passes failed that probably
means something's going on in the
network and maybe you want to do other
things like move some work off of that
worker or move some things off that
machine so there is some some so if you
like it's giving you a little bit of a
forewarning of trouble that might happen
stronger message reliability I think you
know Brad sort of told you the basic
argument as to why you want stronger
real liability if you're pushing along
around lots of data in your large on
large machines and you want things to
keep going so what do we believe so we
believe that if you want it to you could
go out and you could buy a bunch of
small commodity processors you can go
out and buy a bunch of real cheap
gigabit nics right slap a few of them
inside a processor you can go out and
buy a bunch of cheap gigabit commodity
networking pieces right slap them all
together right build a system according
to how much money you had made me go out
in
you know pick your favorite parallel
algorithm may be like search or
something like that maybe even form a
company maybe even make some money right
so an sctp is going to help well it's
going to make things maybe a little bit
cheaper it's going to make things a
little bit more effective at the network
level so maybe you don't need to over
provision the network maybe you don't
have to buy quite as much cheap
networking gear okay well this is a this
is a google scalability so so maybe I
should at least mention MapReduce here
right how might this help MapReduce
better congestion avoidance right if you
if you're using IP switches you have a
lot of machines you have congestion
right you have hotspots no one's going
to have the network by section so large
sufficiently large that if one half of
your machines decide all of a sudden to
talk to the other half of your machines
there's going to be some congestion
along okay congestion is does happen and
that's of course where you get lost
right that's where things like saks
going to come into play head of line
blocking all these other techniques sctp
we didn't talk about this but I noticed
at least in the MapReduce paper that you
know MapReduce uses heartbeats between
workers I just wanted to mention as well
at sctp that mean one of the ways it
knows whether or not a link fails or not
is it has a heartbeat system between the
between the either ends of the
association so it actually has a
mechanism to ensure that things are up
and going again you might not have to
put that recreate that again at the
higher level another perhaps more subtle
thing that we investigated is that you
know there's there's something that
happens in processor farms that actually
I noticed quite a long time ago when I
was we're doing some other work is and
and I think would came up here as well
is that you know when things are sort of
at the end in the sense that you know
sort of the end game of processor farm
where you don't want things to be
finished as soon as possible one of the
good things of course to do that is you
don't want to have some person some
worker out there who's basically
overloaded right has huge buffers and
everyone else is finishing and he's got
oh you know he's got
piles of work left to do right of course
that means the the it's not going to
finish on time so if you're a little bit
smarter you can do things like like try
to reduce the buffers reducing the
buffers as well means that you'd like to
get by in something so that you'd like
to reduce those buffers so you can use
as little buffering as possible right
little states good right make those
buffers as small as possible and I think
some of the things in sctp like like its
sack processing it means we see at least
try to minimize and i'll call it jitter
for lack of a better word is that means
just how much delay there is between
when the tasks are coming in because of
course if we have huge delay then we run
the risk of of our buffer running out
and then of course you know the worker
won't be working terrible thing right so
we hope that you know but of course if
you make your buffers to large there's a
possibility that there's too much work
and that one's going to end up delaying
you in the end so it's nice to be able
to perhaps sort of you know reduce what
I'll call jitter conclusion so just I
hope and one of the primary reasons for
this talk is I hope I've encouraged you
to take a look at this this is all
software you can go download look at all
the source you can change to your
heart's desire sctp is available on most
os's as as brad said probably the most
feature-rich one is the one that Randall
produces the came stack kami stack it's
a game for you freely downloadable it's
going to become it's part of freebsd 7
you'll have made me have to turn it on
it's part of linux as an experimental
stack you have to turn it if you want to
turn it on there's solaris versions of
it and as I said the Mac OS one is
basically the the freebsd one if you
want and I hope I've encouraged you to
find out a little bit more about this
you can go to randall site at sctp org
you can go to a michael tux ensighten in
in Germany there you'll get the mac OS
version of it
as it said we have implemented this an M
pitch too so you can take your MP I
programs or you can write your MP I
programs you can download em pitch to
from Ariane National Labs you can turn
on the sctp and it will work there as
well and and finally there's a link to
to our papers and projects that we've
done over the years on sctp and so I
really encourage you as I said download
it try it out it's it's pretty basic
clustering tools thank you very much and
if you want to find us Google us at SCT
PMP I thank you we've got a few minutes
for questions if anyone has any no no
well as do you know if any either
commercial or large-scale
implementations who choose I see well PP
yeah so let me mention I mean I don't I
don't I mean I don't work for Cisco so I
don't know but Randall works for cisco
and I end and sctp is in it is in the
Cisco's iOS so it's in all the router
products and it's used i believe it's
used as part of their data centers so so
yeah there you know this is a serious
technology that that cisco has certainly
been developing and supporting over the
last four or five years and i'll just
add one thing since its roots are from
telephony it's also a part of this ss7 i
don't know exactly what it is but it's a
standard for voice over IP and it all
admission and it's been adapted by the
in the IETF for the sigtran group as
well which is a signaling group my
question is what gets back to TCP you've
been talking a lot about congestion
avoidance right and so if i have a lossy
line this acts help other things help
but the real problem I've seen with TCP
is as soon as you get up to speed and
you get to 60 miles an hour you hit a
little road bump and you get that slow
start back down to how do you deal with
that well so you know
there's sctp didn't didn't didn't
recreate the I mean well let me say sctp
basically uses the same congestion
control mechanism as TCP so there's no
new invention there or no new insight in
inside sctp for congestion control it
and having said that the same you know
the same problems with TCP also would be
true for sctp and as well the same
solutions that people have been
investigating with TCP will also be can
be applied in a straightforward manner
to to sctp now there are a few places
where this changes a little bit and and
particularly this gets to things like
the concurrent multipath there are
things become a little bit more
interesting in terms of congestion
control and I should mention that sctp
is sort of entirely friendly in that
sense right so unlike UDP it won't hog
out a link right it will basically share
the link among all the different streams
and things or setp sessions I actually
have two questions um over here sorry
yes like the when you set up these
multipath channels between two
applications how do you I thought think
they were called associations how do you
so c 8 is it done at the application
level to sort of declare that these five
IP addresses are actually one host how
are those associations maintained so in
setp so this the call is the same as in
TCP right you open up a socket you and
you bind to it by default what happens
when you bind to it you will actually
get all the interfaces on the machine so
by default it will it will open up it
will create one of those multi and multi
and associations now there is a there is
a special call called bind X which
allows you to sort of selectively pick
which ones you want to be as part of
that association so you can so there's a
way to do either if you like but by
default what you get is all of them and
then the question that we're sort of
interested in is any idea when windows
would ever adopt I would love to know is
that everything I want end of our
connections is as Len
everything on the other end is winning
yeah maybe there's somebody from
Microsoft who could say when when
windows could could implement this I
should say that there is a there is a
project that a person at the University
of Delaware which in fact I think
creates a little shim layer that will in
fact I i believe let a TCP connection
setp connection talk to a TCP connection
or switch so I'm not I'm not absolutely
sure about that but yeah absolutely i
mean like any new protocol i mean the
big question here is of course how do
you get widespread adoption and it's a
it's a classic chicken and egg problem
right it's not going to be adopted until
more people use it and people aren't
going to use it until it's widely
adopted so it's it's always that problem
so we'll take one more question and then
afterward if you want to talk to Brad or
Mike or Alan I'm sure they'll be
available over coffee hi I was wondering
if there's any allowance in the multiple
links with the Association to try to
avoid the Thundering Herd problem that
you get sometimes so if you're sending
an RPC out to like 50 machines if
they're doing similar tasks they're
going to respond at about the same time
and you'll tend to overflow the buffer
on your switch and drop packets and
stuff like that and so is there any
allowance in there to try to randomize
which link it goes over to try to cut
that damage interesting question i mean
again I think once you go I mean the the
initial sctp proposal of course used use
this in a very simple way right simply
as primary and failover but you're
absolutely right i mean and in fact
Jana's work at delaware when he looked
at concurrent multipath just looked at
basically trying to share the bandwidth
as best but but you're quite right i
mean you could think of other ways that
you might want to be a little bit more
clever as to how you could schedule
schedule paths like that right so it's a
it's an interesting interesting question
all right let's think the speakers one
more time
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>