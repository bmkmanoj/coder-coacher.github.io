<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GTAC 2010: Flexible Design? Testable Design? You Don't Have To Choose! | Coder Coacher - Coaching Coders</title><meta content="GTAC 2010: Flexible Design? Testable Design? You Don't Have To Choose! - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>GTAC 2010: Flexible Design? Testable Design? You Don't Have To Choose!</b></h2><h5 class="post__date">2010-12-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/K3q_y8H1ZTo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so just to quickly define some
terms when we're talking about flexible
design here we're talking about code
that's easy to modify and extend pieces
of behavior in the code you want to be
able to reuse elsewhere and in order to
extend your system easily you need to be
able to understand it when you make
changes in the system you don't want
those changes to be intrusive changes
and as you expand the system you don't
want to explode complexity any number of
reasons why flexible design matters but
a few that we usually like to focus on
our when you're expanding teams you need
to be able to onboard developers quickly
so they have to come up to speed on the
code when market conditions change
you're going to have to respond quickly
with unanticipated feature changes when
you introduce new functionality you need
to be able to do so safely without
introducing a bunch of bugs so when
we're talking about testable design
during this talk will be talking about
unit testing some of the ideas do extend
two components and subsystems that will
focus on unit testable code so what does
it mean to be unit testable we need to
be able to instantiate a class and its
collaborators in an easy manner we want
to be able to set it up into the desired
state and then drive the code through
each of the execution paths and then
witness the effects to ensure that the
code is behaving the way that we expect
it to so what makes a unit test good
well we want them to run quickly and in
parallel whenever we'd like them to do
that we'd like them to be hermetic
meaning they need to be isolated one
from the other when we have an error
we'd like to be able to find exactly
what causes that error we don't just
want to know there's a regression we
want to be able to pinpoint the code
that's causing the problem good unit
tests are easy to write and to read and
they validate not just the happy paths
but also corner cases exceptional
conditions and error cases so I think
we're here among our fellow test
engineers and people who are interested
to testability but the reason that it's
important is we want to isolate pieces
of behavior for validation when a test
breaks we want to see exactly what went
wrong and we don't want to have to jump
into the debugger to try to solve the
problem of why do this test break at
Google we have a motto which is
debugging sucks and testing rocks so
brief aside we're not trying to say that
end-to-end testing isn't important it
absolutely is we love unit tests but we
also understand the need for end-to-end
tests so as we proceed here what we're
going to do is look at a series of
common design choices that need to be
made for each one will introduce a
situation we'll take a look at one
possible design alternative that has
poor flexibility and for testability
we'll explore why and then we'll
introduce a second design alternative
that improves both of these
characteristics so we'll start off with
a running example this is a hypothetical
application the Google cacophony is a
way for people to collaborate on musical
compositions and it needs to do a lot of
things we need to process music change
requests parse trees or preferenced
files apply some audio filters turn this
into MIDI files that are playable and
send results to the users so the first
common situation we have to answer the
question how large should our classes be
we often deal with developers who asked
who say I really don't want to introduce
a lot of little tiny classes into my
system unless there's value for doing
that so our first design is the not
recommended design and that is to put
several behaviors in a huge class we've
got a music server and you can see by
this comment it does thank you
you could say purpose come it it does
all kinds of things it's processing
music change requests parsing preference
files everything that we have under the
Sun is in this piece of code so this
isn't a really good choice in terms of
flexibility reuse is inhibited because
any piece of behavior in the system is
tucked away inside this one big class if
you'd like to use it anywhere else it's
unavailable also suppose were wildly
successful and we branch on beyond MIDI
files we want to start adding mp3's
waves our parsing is going to get more
complex we've got audio filters that
we're adding every day new instruments
that complexity has to go somewhere and
if we've got multiple responsibilities
in the same class that's where they're
all going also conditional complexity is
likely to explode inside this one large
class let me before I move on to some
other flexibility concerns for this
design let me just take a brief aside to
say global data is bad do we all agree
we'd like to minimize the use of mutable
global data in our system I see some
hands up okay yes reduce the use of
global mutable data but but what's the
problem with global mutable data the
problem is what Michael feathers calls a
spooky action at a distance if any code
throughout our system has access to be
modifying this data then it means the
code that depends on the data is
difficult to understand because the data
is going to be shifting underneath it
and it's difficult to tell who did that
shifting where did the change come from
why am i bringing it up because if we've
got multiple responsibilities housed in
a single class then we've really created
a system where the fields in that class
are essentially global or maybe it's
just a portion of our system but for
every responsibility
that has access to every piece of data
in this class any method could change
any field so we're in kind of the same
situation as with global data we were in
the large we've lost application within
this space that we've created it's the
same situation for private methods if
any method in this large class can call
any private method we have to ask
ourselves how private is private we also
have to face that the testability of the
system isn't very good either just
imagine your input is a change encoded
in an RPC and your output is an mp3 file
so trying to unit test this is really
essentially an end-to-end test and we
have this input coming in various things
are happening inside this large class
the output is an mp3 file how do we
validate that we're probably going to
make some golden files some well-known
files that are good we're going to have
to compare these two files to say is
this the right answer and anytime we
have a regression it's really tough to
tell where do we go we go right into the
debugger where did the problem happen
well let's whip up the debugger and
we'll find out where it is also if you
make intentional changes that should
alter the final mp3 files you have to
create new versions of your golden files
and if you have to change a lot of those
that's going to be a real pain another
thing is the notion of safety when we
are changing our code we want to just
change the code and we like the test to
be a safety net if we have to change
both the code the production code and
the test code together then we've lost
that that safety net aspect we may make
mistakes in doing these changes in two
places okay so let's look at a second
design alternative instead of one large
class let's define crisp small classes
with distinct behaviors request handler
or preference reader pressure ends
parser a music mixer each doing just one
thing sometimes this is called single
responsibility principle sometimes it's
called separation of concern
we've improved flexibility with this
design each of the classes is easy to
step back and understand as one
conceptual unit in the larger class
where we had all these behaviors mixed
we lost the power of object-oriented
programming when we split the behaviors
up into crisp distinct units we get that
power back object-oriented languages
generally provide us with natural
features for encapsulation and
polymorphism it lets us when we have
variable behavior to accommodate which
is a always the case with flexibility it
allows us to further subdivide our
behavior into siblings in an inheritance
hierarchy that we can install or even
swap dynamically our testability is also
improved now with our smaller classes
the test can be more focused on each
individual class it's much easier to
test unusual or exceptional behavior we
can drive our small classes through the
various paths and we don't have to go
that kind of big end to end the input
for each unit test is really easy to
supply we don't have to start with a
change request and then our outputs are
an mp3 file that we have to check
against a golden file will have smaller
targeted focused tests an example would
be how would we test the audio filter
selection is always correct with the
first design with a large class with a
lot of behavior we would need to
construct golden files for every
different kind of audio filter selection
it's going to be difficult to do and
it's much easier in our second case
where we have these smaller classes you
can just test one piece of it we can
test that a filter selector is returning
an appropriate filter depending on the
filter specification okay let's move on
to a second common situation classes
need configuration data that's true of
just about every system right the
question though is how should we supply
this information
each of the classes that need it so in
this case we're going to have a user
that directly reads data from a file so
internally the user is reading the file
parsing it and creating either a
configuration object or some kind of
data structure from that information and
a user has other responsibilities this
isn't the core responsibility of it so
this is a smaller violation of single
responsibility principle but we see this
so often that we wanted to call it out
specifically and you've probably all
seen this kind of code we've got a user
it has preferences field we take the
preference file we parse it and then we
store the resulting data into the
Preferences object later on we do
something with the preferences okay so
this gives us some flexibility concerns
if you want to change this file format
how do you how do you change it you have
to go into the user code and make
intrusive changes there if you want to
move on and supply support multiple
versions of preference files you're
going to be adding conditional logic
into your user user is tied to the file
system suppose that our cacophony
service becomes wildly popular many
users and we need to offload preferences
to a preference server we want to
communicate with the preference server
via our pcs again we're going to be
going into user we're going to be making
intrusive changes so that it can depend
upon the RPC mechanism for its
preferences instead of the filesystem
and suppose that elsewhere in the system
these preferences would be useful well
we've buried the reading parsing
validation inside the user code and
inhibited reuse with this design this
design also has poor testability we
wanted our tests to run fast but we know
that tests that hit the file system are
slow and to set up our tests we're going
to have to have properly formatted files
one for every kind of preference or
every combination that we'd like to have
and then if the file format changes
let's say we have to have a new piece of
required data
we have to go to every test file and
modify it okay so prefer design for this
instead of having user tied directly to
files we have dedicated code elsewhere
that reads purses and validates the file
and we install the constructed
preferences into the user direct
injection now so far all we've done is
we've moved the problem from user
somewhere else and later in the talk
will be explaining that somewhere else
and how to solve that azz problem we've
improved our flexibility though if we
have changes to the file format user is
insulated from that because it only sees
the constructed preferences if
preferences come in from another source
user is insulated from that it remains
stable and now with our new design where
we don't have to go to the file system
our tests are going to run a lot faster
it's much easier to construct a
preferences object and create different
variations for testing in memory and
also our tests are no longer tied to
that file format so if the file format
changes or tests don't actually have to
change as an aside this is true for
general kinds of input the same
reasoning applies for files as for raw
sockets and RPC mechanisms etc okay
let's move on to yet another extremely
common situation we have stateless
services and utilities throughout our
server and classes throughout the server
that need access to those the question
is how does a class that needs the
service get access to that behavior one
choice that we often see be made is to
access the service via a static method
it often seems like a good idea at first
hey that's really easy the service is
globally available we just can call the
static method we don't have to create an
instance and that's going to be really
easy to test right
in this example we have a musical score
and when the score is changed we'd like
to inform authors via email so we came
up with this great idea to have an email
sender and it'll have a static send
method we can just easily call that and
give it the message okay we've got a
flexibility concern what happens as we
want to support additional ways of
notifying an author we were notifying by
email before but now some users want
text messages others want a google buzz
or a Twitter tweet here's typical code
that we see feature developers write to
solve this problem we're switching on
the preference of the author of the
musical author whether they want text
message sent to them whether they want
eel mail sent to them and for each of
these different possibilities we're
hard-coding a connection to a different
static service so this isn't really a
good choice because we've increased the
flix we've increased the complexity and
there's really no easy way to use
polymorphism to solve the problem what
we'd like to do is we'd like to have
just a single interchangeable way of
doing send notifications this design
also has poor testability implications
so naive testers might think this
improves the testability you don't have
to instantiate the service you can just
test it but the problem is the consumer
of the service can now not be tested in
isolation it's directly tied to that
service and often these services are
complex are expensive and we don't want
to do that in unit test we said we want
our test to run fast also trying to
prevent an email from actually being
sent in this first example takes extra
work typically we'd have to put some
code inside the email sender that's for
testing will have a little flag that
says if
don't actually send an email that's
pretty bad and we'd like to brief aside
to have a caveat here we're not talking
about simple stateless utilities there
are things that are fine to have like
math absolute is totally fine as a
static utility we're talking about more
heavyweight services okay so instead of
having these brittle static connections
our preferred design is to make the
service in stantial or at least to have
a class that we can instantiate that
accesses the service on behalf of the
consumer this allows us to take
advantage of an inheritance hierarchy to
unify the variant pave yrs and we can
inject a subclass of a sender interface
into the musical score the code looks
like this somewhere else dedicated to
understanding and authors preference we
collect we construct a sender subclass
and then musical score is very simple it
just takes a sender it doesn't care
which kind of Center is installed send
update no longer has the conditional
logic that we saw before it just
whatever Center was installed in its
constructor when it's time to send an
update it sends the message through that
Center and again at this point it just
looks like we're moving the problem one
level up but we'll be talking about that
in minute so flexibility has improved
now musical score doesn't know every
different way in the system that an
author might want a notification sent to
them as I said conditional logic has
been removed and adding new center types
is not going to make us go and make
intrusive changes in the musical score
it remains stable to that kind of change
our testability is also improved now now
we have a scene where we can insert
fakes or mocks where we would like to
this helps us avoid those expensive
operations that we had been statically
tied to things that may take up a lot of
time or memory or have avoid undesirable
side effects like actually sending an
email every time we run our tests we
also can simulate exceptional cases and
error cases when we have fakes or mocks
instead of just depending on the service
to maybe fail for us sometime we can
inject a fake that simulates a failure
okay on to another very common situation
getting data to consumers so we have
classes throughout the system that needs
some kind of data often it comes from
command lines initialization files may
be directly from a request or anything
drivable from those sources may be via
data store and each of the classes in
the system really only needs to work
with one or a few maybe 0 kinds of this
data so what happens when we very first
start with the system we might just
weave one data item from Maine down to
the classes that need it but then our
system gets larger and now we've got
second and third and fourth parameters
and we need to weave those all the way
down into our various classes as the
system starts using more data we start
tacking on additional parameters and it
gets pretty ugly pretty fast we don't
want to have to pass you know 50
parameters in every method call so there
are a few designs that people tend to
use for this and we don't recommend any
of these as the system's grow we see
sometimes people will bundle their data
into a context object that passed
throughout the system or chunks of data
are packaged together into classes that
are already widely known in the system
and then the other is the bucket of
static data which is a problem that
we've already discussed in terms of
global data okay so design 1a is the
context object it's a big collection of
data
that we end up passing throughout the
whole system often we have in if we
think of our system is a large aggregate
structure this context is passed from
parent to child to grandchild down
through the system many of the nodes
touching it only need to touch it to
pass it around others receive it this
context object and they reach into the
context to grab the data that they need
the there's some flexibility concerns
with this design so the context object
is so widely known throughout the system
that it might as well be global data all
the problems that we said we had with
global data are also problems with this
extremely widely known context object
we'd also like to build our system in
such a way that we can look at a class
look at its constructor and public
methods and be able to understand who
what other parts of the system it
collaborates with and what kinds of data
that class makes use of when we're
passing around this large context object
we've lost some of that you don't know
whether class receiving this context
object uses it at all just takes it so
that it can pass it down to a child
class and if it does use it you don't
know why just by looking at the the
surface of the class you don't know
whether it needs access to a country
code or not we've also inhibited reused
severely because if we've got classes
that depend on this particular context
object that maybe would be useful
elsewhere or in other systems it's
really difficult to reuse them there
because those other systems aren't going
to use the same context object that the
class that we're passing this through is
brutally tied to
so the other choice is what we're
calling holders and basically it's
overloading a well-known class to carry
extra bags of data we often see this
with something like a user where this
user object is needed in a lot of the
system and we pass the this data clumped
up with the user and what happens is we
add a little bit of data to the user and
then that starts to get pretty big so
then we split that off and we say okay
well now a user has some preferences and
that starts to get pretty big and so
we'd say well let's let's have a
location data and then inside of that
well you know that's pretty big let's
let's have it have the country code so
then when we have this user being passed
around classes like a count that require
country code have to dig it out of the
user and what this looks like in
practice is an account takes a user it
wants a country code but it goes to the
user and it gets the Preferences out
then it takes the preferences and it
gets the location data out and then it
takes that location data and it finally
gets the country code and that's the
piece that it really wanted does anyone
seen this code okay everyone in the room
has seen this code okay this code has
flexibility concerns I already said
public methods don't really reveal
what's going on also we've got this code
that Tracy just discussed that digs down
into the structure that we're passing
around it's often duplicated if we've
got two places in the system that need
the country code we often see the same
dotted dotted dotted code to dig it out
and this digging code also locks the
structure in place so if we were to
decide that our system would be better
factored if country code were stored in
another way or somewhere else we've got
maybe 50 places in the system that are
hard-coded to this dotted representation
of the structure that it's currently in
refactoring is going to be severely
inhibited this is also a problem for
testability in both of the cases with
the context object and these hold
our tests are unnecessarily complicated
we have to do a whole lot of setup to
get these pieces of data into this
nested location only for the purposes of
allowing the the class under test to
basically dig it all out what that looks
in practice is we've got a test where
we've got an account and it needs the
country code but it also needs to get it
out of the user so we have to make a
country code a location data install the
country code in the location data then
we have to make the preferences because
the location data is part of the
preferences then we have to make the
user and install the preferences in the
user finally we can give the the user to
the account and all of this just so it
can do that dotted digging out of this
data to get the country code and we tend
to see this kind of code written tests
repeated over and over again so there's
a preferred design instead of nesting
the country code way down in this
structure we're going to say we should
just pass the country code directly to
the class that needs it in this case the
accounts and that may sound like I'm
just being flippant but at several
points we've said we're going to get to
something later and the time for later
is now so we're going to talk about
system assembly and we're going to use a
different example than our Google
cacophony server because this one is
something that people understand how
things are put together so if we're
going to try to construct a car and it
needs a windshield and an engine and an
engine needs spark plugs we're going to
look at two ways to assemble the system
one will be top-down and one will be
bottom up so the earlier design choices
were poor and the reason that we ended
up with these is due to this following
structure and it's the top-down assembly
where we say okay we're going to make a
car and inside the cars constructor it's
going to construct its own collaborators
it's going to New up an engine stored in
a field it's going to New up a
windshield in stored in a field what
happens when we say new engine well
engines need spark plugs
so in the engines constructor it's going
to conveniently make its own spark plugs
put them into a set of spark plugs now
constructing a car is really easy right
all I have to do is say new car and I
get a fully assembled car get the full
object graph but the problem is that
changing the parts inside the car are
really hard okay so this is a brutal way
to assemble our system suppose that we
decide that we want a high-performance
spark plug instead of a standard spark
plug where do we have to make that
change we have to go directly into the
engine the engine needs to know there
are two kinds of spark plugs it's going
to have to have conditional logic in
this case in its own constructor to make
a spark plug selection and in some cases
it has to do even more work to
additionally configure its own
collaborators just moving spark plugs
one level up to car doesn't help because
then car needs to know about both kinds
of spark plugs to be able to pass those
down into an engine as you can imagine
this also in has an implication for
testability when we want to use a car in
our tests we get the entire object graph
we don't have any choice that's what you
get and that might be expensive to make
and so every test is going to have to
create this entire object graph even
though we maybe don't really want that
if we want to have test versions of our
collaborators there's no seam there's no
way to get those in there everything is
taken care of under the covers we're
stuck with the standard windshield
engine and the spark plugs okay so
designed to which we prefer is bottom-up
assembly instead of having every class
construct its own collaborators we'll
have dedicated creation mechanisms off
to the side in a manual situation this
implies a collection of builders and
factories you may be fortunate enough to
be able to use an automated framework
like Google's juice or spring but the
idea behind it is instead of
creating a parent that creates a child
that creates the grandchild we're going
to create the grandchild first we're
going to start from the leaves and once
we've created spark plugs then we can
create an engine that we just pass the
spark plugs into if we have a dedicated
spark plug factory that knows how to
decide whether we're using standard or
high-performance spark plugs then it
creates the kind of spark plugs we need
and can install those into the engine no
conditional logic in the engine it just
uses birth plugs once we've created the
engine we can create the windshield off
to the side and now it's easy to
construct a car just passing in the
already created and populated engine and
windshield so flexibility is improved
because now we don't have to make
intrusive changes in two classes like
engine and car when we have variant
behavior to support in their children
it's also not easy to test our pieces in
isolation we're not stuck with that big
object graph we can create the pieces as
we like it's really easy to create fakes
and mock collaborators and inject them
into our system under test so we can
make a car with a fake engine that
refuses to start and we can test out
that behavior we can make spark plugs
that actually validate if it was asked
to fire by the engine this lets us push
through all the different conditions
which is what we want for our tests okay
let's move on to net another extremely
common situation we have clusters of
behavior that change together and
multiple sites throughout the system
perhaps in the same class perhaps spread
across classes that use these clusters
of behavior an example to make this
clear in the company server we have
different account types free basic and
premium and depending on what kind of
account we're working with a music mixer
may need to place some limits maybe for
a free account we can only afford to
provide the collaborators with the users
out there with a 10 second duration clip
a basic account they can get a minute
maybe it's an unlimited music clip for a
premium account we may contract with
third parties who provide filters and
instruments for us and depending on
whether your free basic or premium it
could limit either access to or maybe
the quality of a filter or an instrument
that will use so the first design choice
is again are not recommended choice we
have a director class and it has a music
mixer and an account type as fields and
when we want to have each of these
features we go and we do some
conditional logic for deciding what the
account type is and then what the
behavior is so if the account type is
free we'll ask the mixer to truncate the
audio short if the account type is basic
we'll ask the misc ask the mixer to
truncate the audio in the longer section
and if it's a premium account we won't
ask your trunk truncation at all we also
still inside the director will have set
up for instruments free and basic and
such and similarly for applying our echo
filters ok so this design choice is poor
in terms of flexibility anytime we want
to make a change to add an account type
we're going to be extremely intrusive
because for each clause we're going to
have to go and add new conditional
statement for how we handle mega premium
accounts the logic for how we handle a
given kind of account is scattered
around so if we wanted to step back and
understand how does our system respond
to
when we're working with a premium user
you can't just look in one place you
have to look at behavior that's dotted
throughout the conditional clauses and
this kind of code invites bugs when
you're making a similar decision over
and over and over again and switching on
that decision you're asking for a
mistake to be made in fact we just got a
call from hypothetical support on our
hypothetical server and they tell us
that we've just been charged by our
third-party vendor for a hypothetical
extra million uses of premium echo
filtering let me back up here and say
here's what happened in one of these
conditional clauses we said if account
type equals premium we're going to apply
the free echo filter and the last fall
through case which should be free is
applying premium echoes so we made the
same decision in multiple places in one
place we got it wrong testability is
also impacted when we want to validate
that we're doing the right thing the
director has to call each correct mixer
method and we have to make sure that we
do that for every account type at every
feature otherwise we'll have these bugs
that like we just found so we need a
mock mixer to expect the free or the
basic or the premium versions of every
single feature what that means is a
combinatorial explosion of tests we've
got a cross product of features and
account types we've got free basic and
premium and then we have to cross that
with truncation filtering etc so a
three-way decision at each of five
features means 15 tests as soon as we
add a new account type we have another
test for every feature or if we add a
new feature we need another test for
every account type for that feature so
we have a preferred design decision for
this and that's isolate the free the
basic and the premium behaviors each
into a separate class and create an
inheritance hierarchy
to unify the interface to those classes
in this case a music mixer interface
with one method / feature it looks like
this so off to the side we're making a
selection of which mixer to use that
selection is made just a single time in
one place instead of repeating our
conditional logic over and over for each
feature and then when it's time to use a
feature we get to delegate to the
properly selected mixer or cluster of
behavior this makes it really easy to
support new account types because again
we've eliminated the conditional logic
from inside our director all we have to
do is create a new kind of music mixer
and pass it in we also with this design
have addressed the consideration of the
logic that was scattered about now we
have a single place we can look and say
how do premium account works the
directors become simple and the bug that
we saw a few slides ago is almost never
gonna cur this also helps us with
testability we've now eliminated the
combinatorial explosion of tests we
don't need multiple tests to ensure that
the director is calling the appropriate
music mixer method because now we've
consolidated that into single methods /
feature we may end up writing a test
that validates when we have a premium
account we get the appropriate mixer but
it may already be tested by our
end-to-end tests so we'd like to go from
the specific to the general why does
this work there are three foundational
pillars of object-oriented code
encapsulation loose coupling and high
cohesion and as an aside a strong use of
polymorphism supports both cohesion and
encapsulation so let's go back through
each of our examples we had the music
server with most of the code in one
class
we said that wasn't very encapsulated at
all as soon as we split that into
multiple classes now we have better
encapsulation and we have high cohesion
if we've made good choices for splitting
up that behavior into the appropriate
classes when we had a user reading the
preferences file directly we weren't
encapsulating our file parsing or the
format of the file and so we had a high
coupling between the user and the file
and its format when we instead inject
the Preferences data right to the user
we've now encapsulated the file parsing
and format somewhere else into a file
parser and we've decoupled the user from
the file and its format we have the
musical score where we were using the
static sender service and we ended up
with some very tight coupling between
the musical score and all of the sender
services the musical score had to know
the concrete type of all of these
centers that's not what we want we'd
really like things to be loose and so we
can easily inject a different kind of
sender we can create new centers we want
loose coupling between our musical score
and our sender we want only to know
about the sender via the interface we
talked about a context object and a
holder for bringing data to the various
kinds of classes throughout our system
the problem with the context object and
the holder is there isn't any
encapsulation we're digging into all of
these pieces ripping out the parts that
we want we also end up with tight
coupling we have all of these classes
throughout the system weaving this
context object through they're all
dependent on either the context object
or in the other case the user and we end
up with low cohesion the context in the
user are basically dumping grounds for
information the things don't necessarily
go together it's just convenient to put
it there instead when we inject exactly
what the class uses we don't violate
encapsulation anymore we're not digging
into the user to get the preferences to
get the location and we also have loose
coupling we only tie classes to the
collaborators and the data that they
actually use we talked about system
assembly and the preference for bottom
up when we have top-down assemble
with the car creating the engine and
newing up all the pieces behind the
scenes the assembly logic is distributed
throughout the system and we also have
some very tight coupling the a car has
to know about all the concrete engine
types because it's going to be creating
them similarly for the engine and the
sparkplug types when we go bottom up and
we have factories and builders to help
us out we separate the the way that we
build the system from the business logic
and we also end up with much looser
coupling a car only knows the engine by
its interface it doesn't know all the
concrete types of engine and in the
music mixer we had the director with the
music mixer and three accounts the
behavior for a given account type isn't
cohesive it's scattered throughout the
director and it's also sort of scattered
throughout the music mixer as we shot
saw there were different methods for
each feature when we instead go with the
three mixer subclasses we end up with
encapsulation the director doesn't even
know about the account all it knows is
it knows the mixer by the interface and
somewhere else is making the decision of
which mixer to use we also have much
higher cohesion because the behavior for
an account type is together in one of
these mixer classes so the common themes
here are encapsulation coupling and
cohesion and if we optimize for these we
we get a increase in both flexibility
and testability we end up with units of
behavior that we can exchange we can
vary we can reuse throughout other parts
of the system and our testing is much
easier we can have small focused unit
tests we can push our code through the
various paths we can easily substitute
collaborators we can do fakes and mocks
it's working with many people many teams
is that you can't just have a single
canned argument or prepared speech
that's going to convince everyone every
case is unique people care about
different things they're in different
situations you have to tap into the
unique situation you're working with in
order to actually influence and
engineers design habits there are many
right convincing arguments and not every
argument is going to work in every case
with every engineer you need to
understand the developer or the team
what their motivations are you have to
understand something about the context
that they're working in what has worked
well or poorly in the past for them what
kind of challenges they have in front of
them the first thing you want to
understand is what motivates the
individual some feature developers they
care about testing and you're going to
be able to make a strong argument just
in terms of how they can improve their
ability to write the tests that they
want some developers well you know maybe
they'll write a test if they're kind of
product to by you or their colleagues
but they don't want to think about
testability when they're designing code
but they are motivated by producing code
that's flexible so you want to
understand that and tailor your argument
to the individual you also want to know
something about the particular code that
they're actually working on you want to
take into account how a specific
individual learns some people are really
good with theoretical explanations and
some really especially a lot of
Engineers want to see something very
concrete they want an example and
they'll generalize themselves if you're
working with a theoretical learner you
might need to first establish some
common ground like we did introducing
the notion of global mutable data that
then allowed us to discuss related cases
like multiple behaviors housed in a
single class if it's an individual that
learns best by example you're going to
want to look in their code base
hopefully the code that that individual
has written and find an example where
you can point out the kind of design
situation that you're talking about and
make your points using their code then
you want to select a strategy if it's
someone who can be influenced by
testability arguments look through the
code and find a test that they can agree
they'd like to write but is inhibited
with the current design show how the
alternate design that you'd like to
propose solves that problem maybe you
even work together toward the solution
so that they have that sense of
discovery instead of just being told if
it's someone motivated by flexibility
find a feature that is currently
inhibited in terms of flexibility maybe
something that was already implemented
but is really awkward or a feature on
the backlog that is going to cause
problems that you can show the
difference between two design choices
and how the one that you suggest will
allow that flexibility to be implemented
easily so in conclusion we hope that
you'll take these ideas and
generalizations to analyze your own code
and to apply flexible and testable
design and influence with your teams to
do likewise so we have some time for Q&amp;amp;A
hi lesson Tracy I have a question with
respect to with respect to encapsulation
and its impact on testability because
with encapsulation was one of the common
threads in your discussion through the
PPD so encapsulation itself makes only a
subset
of the methods or the properties
available as a part of the contractual
interface thereby limiting the
testability so how do we deal with
encapsulated classes how do we test them
thoroughly so often when people talk
about encapsulation they're really
talking about taking a large part of the
system and and hiding it behind a narrow
interface and what we were showing with
the leading example is that's not really
encapsulation when when we talk about
encapsulation we have to talk about
encapsulation of one set of code or data
with respect to other pieces of code and
data and if what's happened is we've
walled off a large portion of the system
behind a narrow interface and there
aren't seams between those individual
pieces that we can use to at maybe it
represented as classes that we can
instantiate separately and exercise
separately in tests then within that
large circle containing all that
behavior it's really not encapsulated so
it's it's a false claim that that's true
encapsulation because so much code is
sitting in that area not encapsulated
from its from itself multiple
responsibilities that have access
between themselves that they shouldn't
have
private methods as well
right so the question is the moment you
mark a test private now there's a
question of testability so what we would
like to do is test our classes solely
through the public interface and why is
that because as soon as we mark
something private we're saying the
details of how this works is not
important to the outside world and we
should feel free to change private
methods without regard to testability
because we shouldn't be testing those
right we want to only drive our classes
using tests as another client right so
we've got collaborating classes and we
don't want to have two classes in the
production system basically knowing the
details of the private structure
similarly for our tests we'd really like
to only test through the public
interface as much as possible now
sometimes what happens is you end up
with a class and it's got a private
method and it's doing something very
complicated right and gosh would really
like to test that sometimes what that's
what that ends up telling you is we
should take that pull that out into a
class and you know it's okay to have
small classes and have that
responsibility be something that we can
test and use collaboration here to to
pull that piece out if it's really
important to test and it's sort of
tucked away behind a private barrier
yeah in general if you're feeling like
you need to test something that's a
private method that almost always means
that your class is doing multiple things
and one of those things is that private
method or you know a cluster of behavior
underneath that private method good
class decomposition says isolate that
behavior in its own class in this case
maybe we're talking about the Gang of
Four strategy pattern hi this is
question regarding the country code
example which had taken so we basically
move the country code out of which was
designed as the proper high key to a
place where it was being referenced to
so is that a right solution or should we
most look at implementing a global kind
of class or function which
whines me that hierarchy access like the
suppose on the user level i am going to
five higher keys down i can take that
whole hierarchical access and moving
into us a global function which I could
then use that way I not only solve the
problem of in case I change the
structure I change it only in one place
while also sticking to that design which
we had created because maybe sometime
down the line the same country code
might now be required by some other
class where we had initially designed it
for right so so you're proposing a way
of trying to reduce the duplication of
how we dig in and retrieve something
like the country code but that doesn't
solve all our problems for instance
Tracy discussed the code that we're
going to have to write in our tests just
to create the structure that eventually
inside the test will be digging the
country code out of so we can add extra
code extra complexity to reduce some of
our problems but we can eliminate the
problem by inserting the country code
directly into a class like our account
and and in fact the other the other
flexibility problem that we discussed
was we want to be able to look at a
class like account and and from the
surface from its public interfaces say
we know something important about an
account it works with country code if we
just pass it the user even if now we've
we've got this function that makes it
easier to retrieve the country code from
the user we've still hidden what the
actual interaction for account is hello
hey so first of all I agree viz
ninety-nine point nine percent of what
you were talking about one it which is a
lot if it for people who know me still
there is one thing right in the
beginning when you were talking about
the user preferences and you made your
argument right it would be pulled out I
suddenly stopped and I made a note so
this flexibility pulling out the
preferences isn't that encouraging
people to do speculative design and
speculative coding so you think a lot of
what if they're changes and what if that
happens and what if there are but net
might introduce unnecessary complexity
of your design I'm really glad you asked
ok so it's pleasure so the term
speculative generality and and in fact
we're big fans of trying to suppress
speculative generality throughout our
systems at Google but there are two
different kinds of generalization one is
when you look out into the future and
you say maybe we should implement some
fancy specific mechanism for a change
that we're concerned will occur and
often that change never comes and you've
you've written a complex mechanism that
you didn't really need now you're
carrying the extra complexity in your
code it's bad for any number of reasons
but what we're really talking about here
are general design habits that we like
developers to have throughout their
development we as engineers where and
end managers were tragically bad at
predicting the future for some specific
change but we can at least in the
companies that we've worked with we can
be pretty sure change will come
somewhere and that means trying to build
your systems with a general level of
flexibility so that when that an
unanticipated change comes you'll be
able to accommodate it
wherever it is now there may be some
cases where you don't want one of these
designs that we suggested is better for
flexibility maybe you don't implement
that right away but you have it in mind
for when the flexibility comes and part
of our part of what we're trying to
describe here with this correspondence
between flexibility and testability is
that when you're trying to influence
developers for how they should build a
system if the person you're trying to
reach cares about one and not the other
you want to be able to apply arguments
for both and if you're trying to
motivate a developer to to go with a
design that's more testable and you can
also help them see that it's going to
assist with flexibility they're going to
be and if they're resistant to
testability itself as a reason to modify
the design that may be what it takes to
get them over the hump and and use the
design technique that's probably best
for both a greasy and Russ discreet talk
thanks one query I have is like when you
create a in class exposes its service
interface right and so one of the one of
the assumptions there is the semantics
of the parameters is constant I mean
what if if and this is a query from more
from the test design perspective that
what if the semantics of that class
interface is changing and not the actual
actual actual variables themselves
because if I if that changes my test
case kind kind of changes and if I try
to understand or learn more about the
semantics I will be going on and
violating the piloting basically
encapsulation which is the fundamental
of oops so if I
so let me see if I can rephrase your
question and see if this is what you're
asking so we we took a bit of artistic
license with the sender interface and we
said jeez sending emails and sending
text messages and sending buzzes well
we'll just send this message is that
your question that if we we may not have
the same kind of data that's actually
needed for sending an email versus
sending a text message and how do we
then have a common interface for doing
so right I mean just to like take the
car analogy which you which you provided
so if you if you have the spark plugs
and the engines which make a car and
what if the sparklers plugs and the
engine they do things differently than
they were doing earlier so if that is
changing without changing the interface
itself my test case kind of changes and
from a business perspective so how do I
capture that without knowing about the
implementation of the class itself is
there any way to incorporate that oh is
that someone else trying to jump in so
yeah so if we had so the other the
following question is if we had spark
plugs and these two different kind of
spark plugs and they needed to behave
differently yeah we're kind of in a bad
situation we really if we're using
inheritance we really need to have these
a unified interface and have that work
for everything and so if we can't make
them identical as much as possible we
would try to do that otherwise yeah
we're stuck with sort of this well now
we're going to have to have conditional
logic to say well it's this one kind or
this other kind but it's so so in the
sparkplug case they have different
behaviors but they probably have the
same contract through which you use the
behavior and that's what you can
establish in the interface really you
only need a common method that unifies
the the two sibling types of spark plug
I think the the other case with the
sender's is a little bit more
interesting and the question of if
different kind of senators need
different kind of information to do
they're sending how do they get it so
there's a couple different ways one is
and and this isn't typically preferred
but you could pass a collection of
parameters to each of the senders that
was long enough that each of the Centers
had what it needed and some received
parameters that they just didn't use
second option is the director could pass
the director music musical score could
pass an instance of itself in along with
the message and allow each of the
centers to come back and get whatever
extra piece of information they need a
third option is the musical score could
bundle up some generally useful
information and supply that along with
the message and it really depends on you
know situation by situation which one of
those is is the one to go with but in my
experience usually you can find one of
these ways to if the utility the
behavior that varies really is similar
you can usually find a way to provide a
common interface
is that it a real time okay okay Alec it
is telling me we're out of time but it's
been great talking at gtech today and
thank you very much
you
Oh</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>