<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Silicon Valley JUG: Applying the Asynchronous Web | Coder Coacher - Coaching Coders</title><meta content="Silicon Valley JUG: Applying the Asynchronous Web - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Silicon Valley JUG: Applying the Asynchronous Web</b></h2><h5 class="post__date">2008-11-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zLycb-Vyz8Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right well welcome everyone to the
meeting thanks for coming out one thing
that google did ask me to remind you
they're a little low on the security
guard so the the restroom is just to the
left over there they don't have anybody
over there so don't go wandering by the
cubes or anything they wanted me to tell
you that I also don't forget to turn off
your cell phones you know so we don't
have to fans like I make them vibrate
right that's always fun and we've got
applying the asynchronous web icefaces
in glassfish kind of I guess partnered
up but I did very thankful for the ice
faces for you know helping me organize
this event so work with them and then
they work with the Sun and jf two to get
to talk to one today we also have one
announcement about what is it a you want
to come up and give announcements I'll
be teaching a flex specifically i'll be
teaching flex 3d class november 20th and
we will be using back in job of course
and actually the last part of it last
part of the class will use a comment so
if you if you're interested in flex and
3d like game like or cover flow kind of
user interfaces like you see on xbox 360
the website is called projet calm it's a
a little bit of a stealth kind of a
thing but we do use open standards so
please remember projet calm and we'll
probably have a raffle for the class at
the end of it for a free class at the
end of at the end of this great thanks
thank you and finally we want to thank
Jeremy for being our host google so
thank him in google for the the pizza
and the meeting place as well oh you
want me to do else ok so i just want to
let everybody know that next month third
Tuesday will be back here we have sin
I'm going to butcher the name pages he's
going to be giving a Grail
talk he's actually a contributor to
grails and he also runs the Grails
podcast so we'll be sending out
information about that soon we're also
we have the google group meeting a one
week earlier of a sudden odd in that
information out to but Charles jolly who
leads the sprout core project which is a
JavaScript library for doing very rich
client-side applications it's used very
heavily in the apple community they're
doing some work with Google about
running on Chrome and running an open
social context and so our google group
also meeting the week earlier is going
to be in the same room approximate the
same time covering that so i just want
to let people know about that and we say
on information about it and then of
course we have the raffle and oh yeah i
forget that co-champs coming up if you
haven't actually how many people are
signed up for code camp what's wrong
with the rest day no no seriously we
have over there's plenty of time yet
yeah you kind of missed out on the
opportunity to speak because anyone
could that's one of the big things about
co campus it's a developer event by
developers for developers it's a free
event thanks to our many corporate
sponsors and the generosity of Foothill
College which we're going to where we're
going to be meeting it's a weekend event
that's the negative it's on your weekend
but there's over 700 developers signed
up already based on last year we're
expecting over a thousand people because
we get a lot of registrations once we
publish the schedule we just closed
session submission we have over 100
sessions signed up on just about
anything you can think of there's a lot
of microsoft stuff because microsoft's
the major sponsor there's also a lot of
job of this year that's over 30 java
sessions out of the 100 plus sessions
this year i really encourage you to
check it out douglas Crockfords gonna be
back again if you haven't seen his talk
about javascript programming and you
like me as a java developer who does web
stuff that needs to know javascript it's
a great talk if you haven't seen it
before it's a great way to get you into
the meteor features like closures in
javascript anyway enough about that a
tennis anything very good alright thanks
a lot and go ahead and let Ted Jeff
begin with the applying the asynchronous
web okay thank you
okay so my name is Jeff Afghans i'm
working for sun microsystems so mainly
I'm working on the Grizzly framework
which we which on which we build an HTTP
webserver on top of it in eventually
that web server ends up into the glass
fish application server and I'm also
working on a new project called
atmosphere i'm going to give more detail
later during the talk but it's really a
commit framework so but yeah more
detailed to come my name is Ted Goddard
and I'm the architect of ice faces I
spaces is an AJAX extension for
javaserver faces so we're show you some
demos of that and how to develop
applications with it as well as a
variety of other environments now we
have a certain screen configuration here
it's fairly high tech so we're going to
start with the demo then we can switch
it back to the the big screen
we're going to show you is Ajax push to
the iphone course you don't have to use
an iPhone you could also use a desktop
browser but we're going to illustrate
here is that as the desktop user you can
see on the left I advance the slides for
the desktop user that slide change event
is pushed to the iphone as well now we
can do other things in this application
we can chat and that was visible you can
see that now as well the iphone user can
chat
with the desktop user no imagine that
you're in a train station or something
like that all you have is is your iphone
but you have an audio feed from from the
conference and now you're able to
participate in whatever your company is
doing as a presentation just by using a
purely mobile device now the technique
that lies behind this is Ajax push or
comment that's the the web based
technique that we use the specific
application is used implemented using
ice basis there's different ways to
implement it well now we're going to
explain how all of this works and end on
the wire on the server and so you can
understand the sort of revolutionary
changes we can make on the web with
capabilities like this so if we go back
to the big screen we can go into the
bulk of the presentation what was
interesting here is as you can see that
and with the iphone you didn't have you
didn't I need to refresh the page so the
page updated by themself so it's not
like when you go to to ebay and when you
bid on ebay you know the last maybe
three or four minutes everybody is like
refreshing to see if the if the bid is
going up so that's really what Ajax push
it is for to rate it makes web page much
more like real time or interactive it
gives us a new communication mechanism
on the web and we look at a lot of the
important innovations over time a lot of
them center around allowing people to
communicate with each other in new and
different ways think of a telephone
television radio these are all
inventions that transform how we can
communicate with each other well if we
can communicate with each other through
the web in new ways then that's a
tremendously powerful thing and we think
that that's very revolutionary on slide
two
to switch yeah we just want the computer
display their push doesn't work yet yeah
or we could complete the demo just go I
can just hold this up only you can read
it so jessica is so waiting for thats
how many of you have work would come in
yeah ori jack's push okay how about java
okay and the web yeah oh no so only a
small number of people are using the web
but more people use job hmm ok PHP okay
what the same so how many of you have
shoes JT for their commit the petition
ok Tom cap and in glassfish okay right
okay yeah Ted will talk about prison Oh
grizzly no reason Oh resin yeah yeah all
right we'll be back online in a moment
okay here we are okay so what's the
agenda first of all well set the whole
context web two point oh is that just an
a Riley marketing term or is it
something that we can really derive some
useful information out from and maybe
think about our own applications in a
new way then we'll have the multi-user
Ajax demo well no wait we did that
already that was the beginning where we
showed the two different users the
desktop user and the iphone user and
they were able to interact with each
other through this push technique so
we've seen that demo then we'll go how
did this have work on the wire is that
this is when you think about HTTP the
HTTP you normally think of the web as
being this big document repository and
you fetch a document it's like print out
on your screen so the ability to make
changes to that document after it's been
loaded well that's maybe something a
little bit different from the way we
usually think of how HTTP is used so
we'll see how that works well how do you
how do you implement this on the server
and then
develop applications that use this new
capability for the web that's what we'll
talk about so we'll look at it and to
end now I said that this is a revolution
it's a revolution for the web because it
fundamentally changes the way that we
can build web applications it changes
the way that people can communicate with
each other through the web but what kind
of revolution is it is it like the
American Revolution where you had to
dump your favorite beverage into the bay
hopefully you don't have to do that with
Java that was t back then no you can you
can keep your favorite beverage is it
like the French Revolution where we have
this great obstacle to overcome some
giant thing that we have to learn in
order to understand how to how to create
these new types of applications no I say
this is more like the Scientific
Revolution where we have just a little
change in perspective on the way that we
do things on the web now will allow us
to see further and do some tremendously
different things now I said we'd talk
about web two point O in order to derive
a useful definition of web 2.0 rather
than trying to come up with the
definition just of what we think it
should be we should look at the web
right now things that are considered to
be web two point O applications and
derive a useful definition from that
well what are these what is thought of
as web two point or a placental feature
is that the applications are created by
the users of the applications what's
interesting about ebay is not that ebay
has a bunch of stuff to sell you it's
that using the ebay application all of
us can interact with each other and sell
things to each other so what's valuable
in ebay is the interaction between the
people perhaps a one of the more
interesting collaborative applications
is google itself if we weren't all
creating web pages to be indexed google
wouldn't be a very interesting
application at all they wouldn't have
anything to search so we're moving out
of the information age and into the
participation age more and more
applications on the web the interesting
things that we do on the web are all
about what we can contribute and what
other people can find
they're okay so I think we've
established that the world wide web is
is turning into a collaborative system
as a whole people are writing blogs
they're uploading pictures they're
creating auctions but now let's drill
down into the individual eBay page that
you're looking at and you're thinking
about buying that item and it's the last
few moments of the auction and you don't
know what amount to bid because you
don't actually have real-time
information about that that item really
you're it's like you're looking at a
printout on your screen so what we need
what we described at the beginning is
the ability to change the page after
it's loaded and push those new values
for the bid into the page Ajax by itself
doesn't doesn't give us this Ajax
doesn't give us an asynchronous
communication mechanism from the server
to the client HX improves the user
experience by decoupling the network
protocol from the the user interaction
but it only does it part way it means
that we don't do a full page refresh
anymore but we still don't have the
fully asynchronous capability where
you'd think that the server at any time
should be able to issue changes to the
page that would be a fully asynchronous
version of Ajax and we would actually
finally satisfy that capital a in Ajax
so what I'm saying is that the
conventional usage of Ajax is still
synchronized with the user event stream
even though we're sending a message to
the server getting updates back and
updating the page without doing a full
page refresh it's still synchronized to
what the user does well if we have the
ability to push changes from the server
and the various names for this technique
Ajax push comet reverse Ajax will have
what it could legitimately call be
called Ajax now how did how did that
application work this is this schematic
of the of that slideshow application in
the moderator here i am on the left just
a regular forum post we send that to the
server but now if we had a push
mechanism we can send a change
down to the other user on the ipod so by
interacting through the server these
users are able to communicate with each
other of course the these events don't
just have to come from users that's one
of the very interesting aspects is
creating a multi user application that
lets people communicate with each other
but maybe we have an external system it
doesn't have to be a computer that large
it could be a sensor somewhere then we
could display the the temperature in the
room or maybe a device in your home
whether you left the light bulb on or
something like that and that could be
pushed out to the browser as well so
there are a lot of interesting
applications for this once we have this
ability to push from the server to the
client I can't possibly list the types
of applications that you can that you
can do with this what what I what I
invite you to do is think about the
application that you're working on now
and reflect on it how could you enhance
that application by it just by adding
communication capability between users
in that application in some application
specific way for instance when we look
at a lot of the stuff that's going on on
the web it's all it's all based around
blogging and commenting in one form or
another well imagine if you had a push
capability there so that as users could
make comments on your blog you could
reply to them well then that would
transform that application into a type
of chat application and it would
encourage people to make comments on
your blog because they would know well
if you happen to be there that you would
reply and you could have a conversation
that would be recorded would it increase
flame worse I don't know but it would
certainly increase the amount of human
connection that's within that
application and now that's just one
example of applying this push capability
I think that every application is all
about people interacting with each other
in some way well if we improve the way
that people can communicate with each
other in an application-specific way we
can do something very interesting but
you just have to reflect on the
particular application that you're
working on
now this was the demo we demonstrated
this those running on glassfish with
grizzly and we'll explain why that's
significant and ice faces in that case
if you want to download the source code
for that demo this is actually a public
server where you can use that demo for
presentations on your own if you go to
icefaces org there's a project and you
can download the source code for for the
demo well how does this work on the wire
because back in say 2006 when we really
started to promote this then one of the
main comments we got was well that's
impossible so okay so ah yeah so what we
really are looking for it's really our
even driven browser application because
what we wants to do now because we have
the power I would say like five years
ago it was still difficult so the
internet was wasn't ready and it was and
i'm going to give an example using like
a real like showing like how much memory
it was because how much memory was
needed to have to simulate a comment
based application let's say five years
ago because you your your you were able
to do such application five years ago or
ten years ago but it was requiring a lot
of resources on the server side and what
I'm going to explain why actually but
mainly it was the thing that we call at
least in Java it was called like one
trade per connection we're actually
every time somebody was connecting you
had the tread on the server side
representing that connection so if you
have 10,000 user it means that on the
server side you are having 10,000 trip
and tread costs memory can take space as
well so it was more complicated to do
commit based application so of course so
the pros so we wants to have lower
latency because we no longer have to
wait come at you no longer have to pull
for for getting an answer so let's let's
use a simple application like a mail
application so five years ago what you
were doing is you were loading the web
page and what what the browser was doing
for maybe every five second he was just
pulling the remote server say or he does
that user has some email available and
what the server was doing it was just
saying no
there is no email so and then five
second after it was doing the same thing
again so it was the pooling was really
so if you if you wanted to have
something really real time you know you
you you you needed to reduce or have a
really small amount of time between pole
like one second or two second so again
it was tough on the server side because
let's say you have 10,000 user that told
you every to second that means that you
know you're getting those requests every
two seconds and most of the time maybe
like 75 percent of those requests you
just respond with an empty respond
saying oh I don't have anything for you
so here is the blank response so it was
it was it was tough on on the server it
was tough on the network as well because
it was like all those connections so
because you always able with especially
with HTTP when you initiate that that
that that connection so you have the
browser has to open the connection and
do some transaction before it's ready to
do like two straight to effectively send
the request so now let's say in the last
five years or maybe maybe a little more
we have seen more and more application
that are that have started to appear so
of course the one the most famous one is
j mail so when you when you when you log
into gmail right now under the hood it
doesn't pull the server every five
seconds so what it does a tree it really
use a an HTTP streaming technique I'm
going to talk about that technique later
but mainly so what you do now with
cometh is you in the case of email is
you connect to the server and you say
okay tell me when I have email instead
of do I have email you just said okay as
soon as you get an email from me just
push it back to me so other kind of
application that exists of course it's
like meebo jut lies know how I think
meebo there is one in the group here
that goes bankruptcy so I don't remember
which one is it so so yeah and the one
that I like it's for immediate cam so
just go there to see it's really amazing
what they did is actually they put a
setup box inside your home and every
time there is an even
that happened inside your your house so
so it the setup box will push that
information to your cell phone or your
browser so that's kind of really
interesting in the sense of a commit
based application I didn't expect that
people will use the glass dish
government for doing that okay so just
to explain the different technique so
why don't we just do that okay live so
can I ask you a really tough question oh
because we just have election in Canada
so we both from Canada but let me ask a
question for hotel so do you think
quebec should split from canada so we're
doing polling yeah I don't know so I
actually I'm gonna repo because those
guys never listen to us so do you think
a bag should split from Canada I don't
know so as you can see here we're doing
polling so I have so you will always
answer the same response over and over
so now let's simulate the long pole no
wait a minute I mean I might have
figured it out no no you always say no
so do you think I should slick from
Canada no ok so now let's let let me
make the long polling now so ok so do
you think a bag should spit from Canada
it has been like that since 20 years do
you think about it but they already know
no I don't think so so this is the wrong
polling so now for I the streaming
approach now I'm going to ask the
question only once because for the long
pole I have asked the question I got my
response when i do i need to do another
request so now let's let's do this
streaming now so do you think avec will
eventually split from canada so
eventually we'll say something that I
want but well now i'm having trouble
with phrasing this in this streaming
example ok so should
actually so we could do D which was how
about ask me to name some provinces in
Canada yeah so name a province in Canada
ok so I'm going to stream the results so
there's British Columbia Alberta and
Saskatchewan and Quebec unfortunately so
the like the difference was in polling
he kept asking me there's all this
network traffic going on well I'm still
thinking I didn't know the answer and
yet we're consuming server resources and
network resources and then finally I
provide the answer he saw with long
polling he asked me i was able to go and
think arrived at my answer we're not
using up any network resources at that
time no network traffic and then i could
respond the streaming that was efficient
as well i can provide a bunch of data as
I produced it but there's pros and cons
to these different approaches still so
just to just to recap so when you do
Paul so most of the application right
now you do Paul so this Center requests
like every X second and most of the time
they get an empty response like like the
email example that I've said with long
pole it's interesting because you just
do a request and you're going to get a
response only when there is a response
for you so in terms of of the browser
and how the browser react this is
interesting because even with JavaScript
you don't necessarily have to change
anything on the application side or on
the client side because what the browser
things went when he does long pole
connection it just thinks that the
server is slow so when the server takes
time and then it will eventually you
know send you back a response but we're
using a slow server for good exactly oh
and and and finally it so for HTTP
streaming of course you sent a request
and as soon as there is an even on the
server could be one could be too could
be unlimited then you get you get a
response and you never had to redo the
request so there is of course with HTTP
streaming there is some issue there is
more and more people that find solution
for it but
no sometimes if you have a proxy in
between your browser should we try that
doing a volunteer to be the client and
you can we can do the same test and
should i do be the proxy okay okay I'll
be the server you'll be in between and
so we can do the same provinces of
Canada question okay so he relays that
request to me i got that what are the
provinces of Canada but I'm going to
open this long response Alberta
Saskatchewan Quebec but I'm not closing
the response so when can he send it he
might want to send it only when it's
done so that's what that's what happens
sometimes when you have a proxy
configured in a particular way I guess I
wasn't very fun was it because you just
stood there consuming consuming their
response yea rather good the connection
clothes in building or actually when the
response was complete like when we wrote
chunk 0 then he could send it off so
mainly what she wants to do is he wants
to deliver data over like like an
already open connection and you wants to
keep that connection are open so
actually you don't want to send back an
empty response in the case of coming and
of course streaming it's an option but
like I said it doesn't work all the time
so some configuration it doesn't work
okay so let's look at closer on the wire
with these individual techniques look
like now I think the problem with
polling is that it's always slow either
you choose your poll interval to be long
and then the application seems slow
because you have to wait a long time to
find out if you get your update or you
choose your poll interval to be short so
that you'll get the update supposedly
when it occurs but now with this short
polling interval you overwhelm the
server the server bogs down and your
application is slow so we really don't
have a good choice here of course what's
good about it it's very easy to
implement there it is the polling
implementation from JavaScript we just
use the set time 0 function and we can
repeat the query the server so i guess
if your job you know
have half a day and you're supposed to
implement an AJAX push or a comet
application and you have to do it
yourself well this might be the approach
you choose but we're really trying to
build an event-driven system here so we
should have a mechanism for actually
sending events rather than just a
pooling system streaming you watch the
slide this is how streaming works what
was kind of fun about this let's flash
back to nineteen ninety nine when
Netscape came out with those original
push kinds of applications this was
basically how it worked now in those
days we weren't using XML so much we
were using multi-part my messages so
you'd you'd write the HTTP response and
it would have a say multi-part replace
or it had a bunch of images separated by
their mime headers and then the browser
knew that oh here's a new image new set
of mime headers would render that in
place in the image tag so that's that's
an interesting historical technique now
one of the difficulties with using
streaming from JavaScript we talked
about the proxy buffering aspect well
there's not a socket API not yet in
JavaScript so when we read from a stream
may tend to buffer itself in memory and
it's effectively a memory leak so well
how do you deal with that well you close
it and you open it again and refresh it
but that's maybe some awkwardness there
so in the case of long polling or we
call ajax push we're going to use a slow
server or an apparently slow server to
our advantage for instance in that
slideshow application the first thing
that it does when the JavaScript starts
up is it says you have any page updates
for me now the server waits on that
message because nothing interesting has
happened in the application but then
maybe one of the users chats types in a
chat message and that's pushed out to
the users so by introducing this time
delay we're able to add something very
interesting to the HTTP protocol we're
able to invert the message flow and send
messages from the server to the client
you're perfectly allowed to do this
because
it's just like a slow server and you're
not prohibited from having a slow server
on the web that's funny because it's
dumb gap right now so yeah I like when
you say slow server yeah and not only
that this is an authentic HTTP request
and response brought back to you from
2006 so you can save that if you want
and maybe sell it on ebay but can this
scale right so like I said at the
beginning so the problem that you were
seeing and again there is nothing there
is nothing new with coming because push
solution were already available five
years ago but the problem was like I
said it was it was a at least for java
because let's say I cannot speak about
other platform or other language but for
java the problem that you were having is
that for every user connected you would
have a tread on the server side and
everybody that that has used Tom cap by
default the tum kab connector use a
blocking approach so if she wants to
support two thousand user you have to
use some technique to make sure that
because you cannot have two thousand
trip available so usually you have 500
thread and if you look inside the Tomcat
blog sometimes you have like this this
nice message saying oops we run out of
thread so increased number of thread or
lobe dial and some cap so so so in order
to get the virtual machine to be able to
scale like up to 10,000 user it was
really our 10,000 tread it was really a
challenge because first it's not only
Java that you have or the web server
that you are using it you have to
configure but it's the US as well so and
it's really because it was a blocking
approach meaning that you open the
connection you have a tread and what the
tread is is doing so it's just listening
for browser requests so that was the
technique before the advent of GD k 1
dot 4 which has an i/o which was which
i'm going to talk more in the next slide
but with NIU you break that approach
meaning you no longer have four for
having one connection you have one
connection but you no longer need
the tram to monitor that connection
because if you're familiar with the
servlet API how would you implement this
blocking on a on a response while you go
into the service method you have your
request in your response there and then
you would wait until you got notified by
something well that thread can't emerge
from the service method until you're
done so that means that the threat is
blocked there so the servlet API needs
to change in order for us to do this yes
availably now and so I've led to the
five is an example of a blocking
technology because like if you do
request a get input stream inside a
servlet so if no death call will block
until the bites are available so if it
was non blocking so you would have
called get input stream three and if no
bites were there then you will you will
not block and then later on you would
have received an even say oh now there
is some bites available for you so
meaning so what happened if you if you
implement come in right now with the
blocking technology so if you don't use
like Tomcat aio or are or grizzly
comment so what happened is you will
have like Ted said you will have one
tread per user and then so here let's
say it's your server will not but like
that but if you say you have only four
tread available so now here all your for
trade are waiting for an even to happen
on the server side and only when someone
free a thread that are get to respond
then you can you can serve the other
that you know the upcoming request this
is bad for the environment all these
threads running use more energy create
more greenhouse gases so you have to do
something about this so hearing is a bad
example but let's say if you want so the
more tread that you have on the server
side you know you know it needs you need
you need a lot of memory on the server
side as well and of course I'm not
saying you were you're not able to do
that now but you only it not only needs
to tune you know the application you
have to tune the web server and the
Machine it sale so what is the solution
so so come it has big
popular actually on with the java-based
web server so i'm going to use like the
tree more more most-popular which is our
of course tomcat it would is the first
is one of the most popular but JD came
first we come at support and that was
because you are able to use an eye you
for doing that and how it works within I
oh it's really non-blocking psyche yet
so you no longer have that problem of
one user represented on our one
connection represented on the server
side with one trade so how it works with
non-blocking i/o is is that so to
simplify it so when a user to do a
request so if you can always on the
server side if you don't have anything
ready for that user you can always state
that what we present that user which is
in NIU term it's a selection key so it's
a file descriptor mainly at the OS level
and you take that that file descriptor
and put it into a queue or a pool and
only when you have something for that
user you can get back that file
descriptor and write on it so with with
with blocking i/o before you were not
able to do that because you really
needed to have a tread for listening for
even on what's happening on the wire so
within I owe you no longer need that so
which is quite good because now you can
have let's say you know your needs one
thread per connection so like if I go
and if you give an example with
glassfish by default you can scale
glassfish easily with 10,000 connection
and we only have five trades because we
only use the treads to process the
request when we know we have something
to process now the basic idea here is
you have a select API you have all of
your connections that are that are
present and rather than sitting there or
the blocking read on all of these
different connections you select and you
say let me know when anything
interesting happens on any of my
connections and then you can respond to
that and then you can read the bites
maybe write some more bites on one of
the other connections so a small thread
pool is able to handle in an event-based
way all of these different connections
that you have so so until recently so
like tomcat by default user blocking
technology but of course you
you have alternative so you can switch
the term cap connector to use the niño
connector or they have another one that
that use a PR which is the Apache
runtime and this is non blocking as well
but yeah traditional web server were
blocking glass dish were blocking Jacob
was blocking as well so it was more
difficult to write a comment application
because like Ted explain it usually
before what you are doing is inside your
services method you are just blocking
let's say on a queue of even and waiting
for that you to have one message added
to it so you are able to read it and
resume the request so it's important to
know that there is nothing new again
with comment you can do that with
blocking server but don't expect or it
will be a challenge to support 10,000
simultaneous user ok so now so now you
have all those web server that's used in
i/o so they are able to support to
better support comment so so what are
you looking for when you look when you
want to write a comment application so
we try to so what I'm going to do now
I'm going I'm going to describe so what
what can be our tools that are quite
useful when you write comment
application and I'm going to compare the
web server that support commit and see
if they have they have such tool
available so I'm not saying that you
cannot do that with those we have
servers so the tool or the API or the
object that you need but you're going to
have to write those eti so the first
thing is you of course you would like to
have like a synchronous content handler
or mainly it's a synchronous read and
write yeah
its net is that what it was almost like
a filter right then you owe our iPad
conecuh know exactly because I already
all of them web servers all the web
servers now they are working mostly with
the thread in order to maintain that I
mean number especially for the handling
the socket connection HTTP socket
everything out all the side every HTTP
request is said to wonder that's how
they trace it and then they you know
handle the thread completely on it's a
completely bound so how do you handle
that in the new it it's not very clear
to me no but actually let's say if we
speak about servlet so you don't see any
difference with servlet right now right
so wretched at five if you use a
blocking connector or a non-blocking
what you don't see it because we don't
expose so left to dot five don't expose
any blocking operation and servlet
fraternity row will not expose any non
blocking operation yeah I think it's
going to come later yeah but because of
another question is about the session
hope um how you in the new hope you will
be handling the session halls yeah so I
think it's it's technically what you do
so what tom cat does is just when
instead of pulling the the file
descriptor so it Paul the file
descriptor associated with like the
session does that help you don't notice
any difference when they when the
request is you know after the suspend is
completed you just access the session as
you always did so the second thread that
picks up the request has access I mean
you know that it passes all the
substrate and information with that
request they still have the request and
the response object available to you
there and so you could call the Gator on
the request to get the session
associated with that
now I'm not sure or are you asking how
do you handle a large number of sessions
on an application server now that's
still going to be a problem you're going
to need enough memory to handle all of
those sessions no that is the problem
for any web server you know maximum 500
is our 500 is best if one server can
handle a big application but when you're
talking about the neo it's kind of you
know you when you are saying that you
need not have to worry about the thread
and blocking it so I I really don't get
it how exactly it works how I mean show
you how you how the complete socket um
in the background of how the comet is
better and the whole framework I don't
understand how that that's happen at the
GDK level actually so they the JDK make
sure that when something happened on the
servlet on the sake up sorry so it will
advise you it will bring you that
information so your java application
that run on top of it they will just
advise you saying ok that socket has
some activities so it could be a read
operation or a write operation or
disconnect something like that if I
could sort of paraphrase which might be
what he's trying to say how do you
manage the sessions when you you've got
a file descriptor associated with each
thread what do you do with the sessions
do you persist them so it's not
associated with the thread it's in a
data structure in the server yeah so let
me just try to clarify I'm Rajiv I'm the
737 especially and an iOS is really a
lower layer API to do non-blocking i/o
for you on which the HTTP servers
implement their layer on top of that to
make sure they can use channels day it's
a handler it's a headache ok well no no
no it's like a RS i believe the writers
yeah when the reco sconce HTTP records
comes is this is the first term code
that's going to handle what is the
request is and then it's going to split
well that's the stream you read that's
the stream on which are the channel on
which it's coming it's it's the servlet
implementation on top of it is what does
the session management
you and that's that's that's basically
handled by the HTTP server HTTP
connector layer on top of that niño and
I usually a lower level that actually
enables you to avoid having many it
basically gives you non-blocking i/o app
t let's bring up the GlassFish source
code you talk about me well okay so so
what you would like would like to be
able to do say of course you know if she
wants a pure commit based application
what she wants to be able to do is to
once he wants to be able to do a
synchronous three and a synchronous
right because let's say you want to
upload you write an application and that
application is just you want to update
it's just you just sharing picture among
your your coming up your commit yeah or
maybe video something something even
larger right so so when you read you
know the video that is coming you don't
want that tread to block because on the
other side the client is not sending
what you're asking for so what she wants
to do is read only when you have bites
so that's where you don't have a tread
that block again same thing for right
exhibit if I have a thousand users all
uploading video I shouldn't have to have
a thread that sits there until that
several megabytes of video have been
transferred I should be able to sit
there with one thread and go oh here's
some data from this one store it here
has some data from this one store it
there so a small thread pool can
multiplex across all of the different
sources of data and just copy the bytes
to where they're necessary so the second
thing you're looking for is really you
want to be able to suspend and resume
the request like because if we take the
chap a chat application what you really
wants to do is all you're connected user
to a chat room so you want to suspend
them when there is no communication
among them and as soon as someone push
or write a message to the chat room what
she wants to do it you wants to resume
although all those those connection and
write byte on it so you need an API in
order to be able to do that and the
third thing is and it's quite important
actually it's it's kind of you also
support delivery Gary
because now you know you have switched
the way your application works because
let's say you have 10,000 suspended
connection and now you have to push it
let's let's use it let's say it's a chat
and you want to push one message to on
that check on that chat room so if you
don't have any strategy to push the data
back to your client so if you use basic
strategy which is to use one trade and
that trade bureau chief for one to ten
thousand write the message so the lucky
guy that is that his amongst the 500
first will be the application will be
quite real time but the guy that he's
like the 10,000 user he might get the
message like maybe 10 minutes after all
the other so it's not really real time
so same thing for stock quote you know
you might have user that get especially
right now you know all your user wants
to have the update at the same time and
you need to be able to predict okay
would would I be able to push the
information fast enough and if not so
what what what what solution do I have
an example of such solution it's like
you might want to say okay there is high
traffic on the network or I cannot catch
up with the push operation because let's
say I have 100 trade allocated for that
and they are all swamp trying to push
the information really fast so what do
you want to do is you might want to
aggregate sum miss agents okay I'm going
to wait to have 55 message i'm going to
start five message and instead of
sending one by one I'm going to send a
chunk of five mistake so you want to be
able to do that you might also want to
to filter the information because let's
say you want your under load again
10,000 user you need to update you might
decide a key that information is not
that important like for a chat you might
decide to not send or you don't want to
update all the years old saying okay
that queues are just disconnected so of
course there are some application where
you cannot discard information like that
but some application you can just decide
okay I'm swamp right now I'm not able to
push that information you might want
also to transform the push operation
other message because like that
is always my favorite one where someone
you know hey guys put some javascript
inside the chat so if you don't filter
the message so you're going to what
you're going to do is going to kind of
produce a JavaScript attack on all the
browser because if you send like alert
or something like that if you don't
filter the information that goes that
get push then you're going to you can
push like all kinds of strange things to
your browser you have to make sure you
you transfer our look at the data but of
course transforming the information is
really what your application is doing
every user has their own view so the
application is naturally going to
transform it in its own unique way for
each user so here is an example of who
support what and again and of course I
work on glassfish but it what's it's
important to note here is that it's not
you can do everything like that with
every web server that are listed here
the idea with last issues you have some
object or some too that's are already
available so so JD support suspend the
request and the response tomcat has a
synchronous i/o and and suspend so glass
dish has the tree of them resign as
suspend and weblogic has suspend and
resume so just to recap the asynchronous
i/o is what we need in order to support
a scalable file upload type operation
suspend and resume is what we need to do
a comet or ajax push application and
delivery guarantee is what you need to
ensure the quality of service that you
provide to your push users
yeah no bite I think that was what i was
talking here the last bullet where you
aggregate our filter or transform the
data yeah perhaps assigning priority to
certain messages if you have a ticking
clock in your page that you're pushing
out that's not as important as like
showing the amount of time remaining in
the auction isn't as important as
showing the actual bids that are
occurring so the that time display would
be a lower priority than than the
bidding and you could use the deliver
guarantees for that so right now all of
those web server here as specific API so
that means we'll explain these api is in
that in the slides yeah and we're going
to talk about what sorry 20 will support
as well right so y actually I'm good
yeah we're going to have one slide that
that explain those so let's let's talk
about the different API is that we have
available on these various servers and
there as we'll see they're similar in
some ways and different in others well
jetty with one of the original ones we
use this idea something called a
continuation now it's not a full java
language continuation whether you'd
imagine that to be almost like a
serializable thread it doesn't it
doesn't do that this is just a
continuation for a connection the way
that you use it is you call suspend in
the service method then it kicks out an
exception which causes the service
method to exit but jetty notices it and
says oh this continuation is now
associated with this service call then
later let's say somebody types in a chat
message you can call continuation resume
and what jetty will do is it will call
that service method with that same
request and response again as long as in
the body of that service method you
detect me say ah I've seen this request
in response before now after my suspend
I'll actually write out a response so
it's it's nice in that it preserves the
servlet API it's not so nice in that you
have this double invocation and a
reentrant see thing so
maybe we should look at some of the
other AP is tom cat 6 API is maybe
closest to the niño concepts concepts
themselves because it's it's very
event-based you see that we get a comet
event and then the event can fall into
those four types it could the beginning
of a connection maybe we should read
maybe it's the end or maybe it's an
error well how do we actually use this
in terms of an ajax push or a comet
application i'll go enter in some chat
text write it out and then we call event
close that's when the servlet container
actually writes out that last chunk and
indicates a final HTTP response we have
access to the response from outside this
event call it's not like a service
method at all it's simply telling us
that while there is there is a new
servlet request available so we have
access to all of the the objects outside
the resin your favorite one yeah
everyone there we did this presentation
and we both thought that this was the
other guys slide now of course we both
learned how our resin works what resin
does is it splits this into two separate
methods and we have a boolean that's let
it's like a service method in a servlet
but it splits that service method into
to wear when we return true we say resin
suspend this what do we mean by suspend
we mean allow me to have access to it
from outside that service method so if
we return false there then it would
write out the response and it would be
done but if we return true then later we
can call see we obtain a reference to
this comment controller later we can
call comic controller wake and that will
cause the resume method to be called and
at which case we'll probably write out a
response and return false to say yeah
now we're finally done although we could
continue to suspend it and if we return
true in the resume we're probably doing
streaming so that's how you would use
that API what's weblogic just like resin
but the opposite
ok so again we split it into these two
methods now we return false to indicate
that we should not suspend and we can we
can write to the response from the
outside when we return false from the do
request how do we get it going again why
instead of calling wake we call notify
we can pass in some user data if we want
but maybe that's just it is it's may or
may not be necessary depending on how
you implement your application and now
that will cause do response to be called
and then we can write out the final
response and it continues so we see the
similarity with resin there glassfish ok
so with glassfish the way it works is
that you create a commit context where
actually every time you wants to push
something so it's really a topic it's
like a JMS queue we're actually so once
you so usually you create one context
let's see first servlet or / / path or
per topic that you wants to share and
when when when your servlet when you
wants to suspend the connection so you
just call that commit context and soak
it had come at handler so what it
doesn't do the hood is it's just there
klassische ok so don't don't don't close
that connection or suspend that
connection and and inside you're
suspended ball handler well it works is
every time so if someone put like
message that said value and when you
call commit can't commit context that
notify so all the connection that were
suspended by calling the head command
handler so all the suspender ball
handler associated with those will get
the even so it's it's in it's
interesting because it was we use Kermit
event as well like tom cat but actually
that was created before don't gap and in
that case you get the response gets the
writer and depending on which technique
you wants to use then if she wants to
use your own polling so you're just
going to tell ok that the commit context
ok so just resume that command handler
so that's here at the example it's long
polling if you were wanted to use HTTP
streaming then what you're going to do
here you're not going to call reason
come at handler so so meaning that their
response will stay open for for
streaming forever
now with I spaces we use these different
api's when we integrate with these
various application servers so what
we've found is that we like the
GlassFish API because it can its
presence can be detected at runtime we
don't need to implement any specific
interface on our front-end servlet if
you look back at the tomcat 6 api the
servlet has to implement that particular
interface so what it means is that it's
difficult for you to create a single jar
file that runs portably on those think
we have to implement comet processor and
this has to be actually the servlet
that's handling the requests that means
that you have to have this
pre-configured whereas with glassfish
were able to say I'm I'm handling a
request I would like to use the comet
engine then I can then use suspend and
resume from the outside detected
dynamically that oh here i am on gaas
fish I can use that okay so and and what
I've learned because we did come up in
glassfish in 2006 and what I've learned
is a lot of people they were it was
still not complicated the people wanted
to have like pojo based application and
our pojo based way of doing comment so
what I came with was like grizzly which
is really there was just an interface
that your object has to implement and
and under the hood of course it's used
grizzly comment so the thing that I have
demonstrated the slides before but it
makes it really really easy to write to
write comment based application let's do
another survey how many people are
asleep raise your hand okay that's good
now let's do another question how many
people have written a servlet how many
people are writing servlets today so
that that's what we see that it's these
are these are fundamental underpinnings
that are being used by the frameworks
that you are using and you're writing a
servlet a question okay
how about very old all the differences
in the comment implement implementations
by the various containers yeah do you
know what the servlet three little speck
which one is going to be the closest to
respect well it's being discussed right
now maybe in in the servlet expert group
there's been a lot of discussion and the
first proposal that came at in the 73
total expert group was from Greg from
Greg Wilkins of the jetty server which
is what you'll see in the early draft
today however the as we as we as we
review the proposal a lot more we tend
to follow we found that there were quite
a few issues which are not handle and so
what which what we're doing right now is
trying to see what the best approach is
and as part of that we are refining it
it's pretty similar to what i would say
is suspend and resume except i hate
those names because what would you
expect to suspend to do now when you
call suspend what do you expect to
happen synchronous wait no that's not
what happens in jetty that's not what
happens in any of those servers that
call when you call suspend you said call
suspend that only means a connection is
open you still go through your entire
service method and your filter chains
then inequalities IAM the request is
read this patch to the container and you
replay all the requests again so you
through the filter chain again on the
resume yes right now right the way jetty
is implemented yes so what we what
you're trying to do is call it more like
start a sink and done is in kind of
methods which really indicate what it is
i used it it doesn't it doesn't stop
that thread there you still go through
the threat but you have the option of
using the request and response the
connection is kept open there are still
some discussions that are happening so
the basic idea is you have the ability
to keep a connection
right to the response asynchronously
from outside the service method what the
API looks like what if what it should do
and what it shouldn't do Lester a lot of
discussion and it's good it's good to
have discussion it's good to have a have
a good expert group that participates
especially when you have people who have
been implemented use servlets out there
so in a way it's good but at the same
time it takes some time to come to
conclusion on that could you give us the
weather report as the one it's expected
the timelines so in terms of timeline so
it's tight to java ee 6 specifications
and we're looking at completing them
sometime next year there will be a
public review fairly soon I hope we can
I think we're slowly converging or at
this point and there are a few issues
which we need to close on and I'm hoping
sometime early next month you'll have a
public review of the spec so do read it
do provide feedback it's an important
it's an important area and this is the
first real Rev I think of the servlets
back even though there are not many
people writing servlets today directly
but all the frameworks build on servlet
so if people provide feedback that's
always good so yeah a public review
early next month hopefully sometime and
that should have all the async stuff in
there
okay now back to our demo yeah so that's
good because the demo wasn't working on
tango anyway what it was working we were
just giving it a chance to explain okay
so let me describe here here its use
it's used it's just is just to show you
so it's demonstrated HTTP streaming and
how how real time and application can be
so but it's really it's just like so i
type a word here and eventually he will
come back so what it does it goes to
flickr and get supposed to go it's based
on the network let it go will it anyway
thank you I can demonstrate it so mainly
what i'm doing here is every time i move
something on one browser it moves on the
other one as well and it uses HTTP
streaming for doing that so so that was
just to show you is really small demo
about how it can be
what's that we don't have a blank slide
oh that's the wrong presentation yeah
thank you that's the deleted slides from
this presentation you didn't see those
well I think we discussed serve the
three-point oh yeah do it do you
everything to add I think that it's
there yeah so one thing that we didn't
add for servlet shot.0 is is a
synchronous i/o it will not be there in
so ventured l0 and the reason I so at
the time that we wrote that slide it was
still consider consider but now it's not
going to go there for the reason that
without going into the details so the
GDK seven will have a new feature called
asynchronous i/o so it's it's not niño
it's called NIU to a synchronous i/o and
it greatly simplify the way you can
handle like really a synchronous i/o so
it makes it because with niño one its
rise it was really difficult to write
like a server based application so a lot
of people never wanted to use in i/o so
they used a framework like grizzly or
mina but with NIU to its it's like it's
another it's a really good step in the
right direction so what we decided to do
is to not have a synchronous i/o to the
servlet 3 dot 0 because it would have
forced us to use jdk 7 which which
doesn't make any sense so we're going to
wait to see so far the next revision of
the spec to see if we can have a
synchronous i/o you're saying new I oh
isn't new anymore right exactly okay so
now you have seen all those those API
and and so if she wants to write so
right now the problem is that if you
write an application a comment
application that runs on tomcat it
doesn't work on glassfish if you use
jetty doesn't work on glass dish as well
so what I did is I started the new
project called atmosphere and it's
really based on what I have learned from
the user of grizzly commit and its
really in it's really based on the
grease let approach which was like a
POJO object that that you don't have to
too let's make it really simple so so
the idea here is that we wants to be
able to use everything that is available
right now like JD Tomcat we don't want
to wait for servlet treated 02 right
portable application so the goal here is
to use to have like again type o Joe to
use inversion of control and to really
bring a comment to everybody so make it
more simple because like ted says
earlier if you if she wants to have a
portable application right now it's
quite a challenge because you need to
learn all those those private epi and
not only that and you still have to
understand to write so depending on what
you're working on how to do the push
because it's not working so some like
Tom cap doesn't have any mechanism to do
the push for you like then they don't
have any notify emitter like like we
have demonstrated so if you write a chat
in Tomcats you're going to have to spank
your own thread and that tread will will
block on the queue and every time there
is something inside the queue make sure
that it resume all the suspended
connection and push that information now
you notice we didn't mention websphere
the reason is because we don't know what
they're doing they have some big kind of
pages where they talk about comet but we
couldn't find any documentation on what
really the mechanics are in webster so
if anybody knows we'd like to like to
add it to our presentation yeah so the
idea here is really to evolve the grease
let approach and make it because the at
least with the Grizzly community what
was happening is a lot of people were
using the grease left but the their
favorites request was can I run it on
tomcat so so I was like yeah but now I
think I think it's time so I think I met
is more and more popular so the idea
here with atmosphere is you're going to
write against the framework the
framework and different work will take
take care under the hood to make sure
that it works so if you deploy in tomcat
he will use the private epi of tom cat
if you use jelly it will do it for you
as well so how will it work so i don't
know if you people how many of you knows
Jersey so jerseys is the the new rest
based application that son just push so
version 10 so it's really based on on
the rest technique and and the idea with
Jersey they wrote they wrote a lot of
code that can be reused and they have a
lot there
really good annotation processor so all
the things that she wants to do with
with with with grins left slightly you
don't have to rewrite it so what we're
planning to do is to take Jersey and
wrap it properly so add the Grizzly a
concept into it so because Jersey
already run on our platform so what
what's needed actually is we just have
to to make sure that we implement like
JD commit support of course grizzly
commit tomcat commit and even blocking
web server will be supported because
like I said at the beginning you can
always block on the trip of course
performance wise it will not be good but
people that don't have access to server
so people that still use some get fired
let's say there is tons of people that
use tomcat five at least they're going
to be able to write comment based
application and so we lost the example
oh okay so I was I was I was so if she
wants to see an example of a grease lab
in atmosphere go to my blog and yeah
just type arc and blood and Google and
you will see there is an example there
to show how easy it is to use it because
i think this light disappear right yeah
that does seem strange okay so we'll
find the slide perhaps but let's let's
move on to application development
because as the survey showed a lot of us
aren't writing servlets today we're
using some sort of higher-level
framework well what what are the
examples of some of the higher level
frameworks that we can use in order to
write these applications well perhaps
the highest level framework would be
just pulling directly from JavaScript
well no that wouldn't be a high level
framework but it would be a technique
that you could use and in fact there's
maybe the source code for it right on
that slide as we said though polling
isn't particularly efficient so let's
take a look at some of the other
approaches comet d is interesting
because it's sweet spot is the
JavaScript developer what do you get
with comet d you get essentially a
reflector on the server this reflector
will take messages from the browsers and
reflect them
to each other so we can publish them
subscribe on various channels typically
from JavaScript so you can have a chat
message sent from one user over here it
will be reflected off the server and
picked up by a chat subscriber in
another browser in some ways that might
be scary a little bit browsers sending
json so in other words javascript
notation messages back and forth to each
other you want to make sure that you
don't do an eval on that message you
want to parse it in in JavaScript itself
because if you do an eval than perhaps
you're picking up some sort of script
that the other browser user has has
inserted in there maybe not a good idea
what's interesting about this idea of
being a reflector is it really doesn't
matter what the server is running it
could be implemented in C++ and it's
simply reflecting messages so but of
course there is a Java API as well so if
you want to insert some sort of
transformation on the server so that you
can modify these messages as they go by
or perhaps capture them and then publish
them again on another channel you would
use that Java API on the server
fundamentally comedy is based around
publish and subscribe of JavaScript
messages yeah one quick comment is that
the Java API is not part of this thing
the values that they call so like it
what it will work with JT but a tomcat I
think I'm cat support it as well but
glassfish has a different one so so
eventually everybody will have the will
use the same API but so far it's not so
we want to move to something that's a
little more relevant to the java
developer we could look at DW our basic
idea here is an RPC mechanism that
allows us to invoke methods from the
server application in the browser we
have this idea of a script session so we
have all of our browsers connected and
we have script sessions for all of them
what we can do is we can take a chunk of
JavaScript from the server and we could
say i want you to execute on each of
these connected users but in essence
what we're doing is we're pushing
executable javascript out to all of
those browser sessions means that you
have to have knowledge of what's in the
page because you want that javascript to
be able to find the kinds of
it's looking for in that case but that's
a powerful API now if you don't want to
just push down script you can actually
call DOM setvalue methods from the
server in other words I can call this
the set value on on all of the book
Dom's on my connected browsers to this
to this new text so that's how we would
implement a chat application there
icefaces what we intend to provide here
is yet a higher level of abstraction so
based on javaserver faces or you
partition your application into a model
and a view model is implemented in Java
beans and the view is declarative almost
like markup that's bound by expression
language back into the view into the
model rather what what we find is that
developers and designers are happy with
this partition and in fact you can take
jsf syntax markup give it to designers
and they'll work with it in Dreamweaver
or perhaps other tools and they can
customize the CSS and manipulate it as
they are used to manipulating HTML
slightly different tags in this case for
instance we have h colon input.text
rather than just an input but designers
are comfortable working with this so you
have a good way of preserving roles now
you should be wondering as I'm putting
this the slide up here where is the Ajax
application because there's nothing here
about Ajax this is just like a dynamic
web application is what I'm showing well
isn't it the job of the framework that
you're using to translate something like
this into an AJAX application because
what have you what have you said you've
you've said what your model is these are
your business logic is now you've said
what's in the view you've said what
components are on the page and you've
said how those components relate to the
model well that is a sufficient
description for an AJAX application as
well it's just a matter of taking that
description of those components
rendering them in such a way with the
appropriate JavaScript handlers so that
you get an AJAX application okay so that
allows us to develop an AJAX application
with icefaces what about a push up like
well we're only two lines of code away
from a push application with this as
well we're going to use the session
render let's let's concentrate on how we
keep track of groups of users so what we
do is we add the sessions that the users
are in to various groups perhaps a group
named chat maybe you need them after
that after the chat topic and then we
have all of these these groups of users
mark maybe I have two groups of users
chat 1 and chat two when somebody types
in a message over here in this group
I'll update the value in the beam and
then I'll call session or ender ender
chat what that's going to do is on the
server I have access to all of those
users pages it will render each of these
users pages determine the changes to
those pages and push the changes down to
each of those browsers if something
interesting happens over here in this
group then I'll call session render
render chat 2 and the updates for all of
these users will be pushed down to them
so that's our vision of a simple API for
adding push capabilities to a javaserver
faces application now there's some some
aspects of this the session render that
are worth noting you don't have to do
any book keeping yourself a sessions go
away through the natural expiry they're
removed from the group's automatically
for you nobody's in the group or the
group doesn't exist when you when you
first reference it it will be created
for you and it will have a lifetime
really as determined by how long the
members are in there so there's a lot of
garbage collection that happens for you
automatically but with this API well for
all of these these usability benefits of
the API itself maybe there's a bit of a
trade-off here in that I said that
you're working with sessions well what
happens if the user has multiple windows
open in one session well the way that
this works is we simply render the
changes to all of the windows that the
user has open often that'll be a good
thing if something interesting has
happened in the application it will
probably have some sort of impact on all
the windows that the user has open by
there's a bit of inefficiency there in
that if that user has 10 windows open
and your change to the model should only
affect one of the windows maybe you
would like to just send a push to that
one window well then we have a more
complex API for that as well if you need
that more fine-grained level of control
but I think in most cases people don't
need to take that extra step and in fact
here is really useless a lot about since
we don't have a lot of time let alone oh
that's right yeah okay so amazing so uh
so what I was talking about actually so
here what would what what we wanted to
have is really to use annotation as most
as far as possible so that way you don't
have to to to have like to call like the
API de that we have shown where you call
the nutty file method when you wants to
push some some some information so here
what did what we are doing we just said
okay on a gaap request so just suspend
for so here is for 60 minutes again so
so 6 60 seconds sorry and on a get and
and and in what and in what what the mid
the on get metal return so we want that
to push it so we want the frameworks to
push it to all the connection that has
been suspended so an unwanted ooh here
is that so if if someone is doing a post
so what you what what she wants to do
here is that when the post comes in you
want to have access to the request and
the response and so we hear what you
just said you just you just set the
statues to 200 you get the writer and
you write something into it and then
what she wants to do you return the chat
message that was sent by the browser and
what the framework will do under the
hood since again you use the push
annotation it will push that information
to any to all the application that were
that were are the connection that were
suspended and I didn't talk about it but
at the path at the above the public
class my Graceland you have the path
which is which which I call here my
agrees that it's really a topic or where
the information will be shared so every
time you push so all the
Oh Joe object after that that has been
annotated with pat my Grizz death will
get the notification well we are running
a bit of time so that's just hmm Oh 20
more minutes okay okay well then let's
take another half hour okay so let me
then we can talk about this because this
is an interesting issue and it will
present itself to you if you go and
implement a push-up location yourself
and this is the browser to connection
limit this is the bane of our of our
whole life in implementing these these
push applications and what happens is
occurring the HTT respect it was
recommended that a user agent should
open no more than two connections to a
give and host of course it's debatable
what a user agent is when you have
multiple windows open in a web browser
perhaps each of those is an individual
user agent that would have simplified
things a lot but that's not the decision
that various browser developers made you
know prior to the most recent ones that
are coming out now but what we have in
this situation is a given browser will
only open two connections to give and
host so when you consume one of those
connections for your push communication
and then you open up another window and
that other window wants to consume
another connection for push now you've
suddenly used up all of your connections
and you're not able not only are you not
able to send push down to the browser
effectively in fact the whole browser
you interface user interface will lock
up and the user will force quit so
that's not that's not good feature
tonight I should say that that's one of
the the most frequent mistake that
people are doing like the download you
know the right the right there come out
application and they wants to try it
then or test it and they open more than
one tab so they open one tab so you did
we lose the connection another tab they
lose the connection then they open the
third tab and try to do something
request and nothing happened the problem
is it's not it's not the
server it has trouble it's just a
browser that just don't send a request
yeah because it's going to delay any
requests that it sends until it finds an
available connection but there's only
two okay so what do we have to do we
have to somehow share that single
connection that we should use for push
notification across multiple browser
windows that's actually a bit complex
because it's difficult to communicate
between the JavaScript environments of
those different windows but we do have
available to us as a cookie so we can
share a cookie across those different
windows and manipulate the cookie in
order to send notifications okay so i
won't go into too much more detail but
let's say we've solved that in
javascript but now we have a similar
kind of problem on the server because
the user could be connecting to multiple
different web applications on that same
server and now those different web
applications are in separate memory
spaces on the server so they also even
though they're in separate memory spaces
need to share that single push
connection hmm yeah for the same host
because what I was describing is a
scenario where you have multiple
different web applications on the same
app server well what we provided with
icefaces and integrated with glassfish
is our Ajax push server where your
separate web applications can use JMS to
coordinate their push notifications with
each other and send that over a common
push connection to the given browser so
that's sort of the the magnitude of the
problem that you need to solve at both
ends both on the browser and the server
in order to share this single push
connection what do we have in the future
and I think isn't it the future is
October 29th is that is that in the
future yeah okay so okay but yeah so
that there's there's there's a bit of
light at the end of the tunnel I said
browsers up up until recently well what
are they doing in Firefox and ie 8 well
they're increasing the number of
connections that you're allowed a lot
helps a bit but it's sort of like
increasing the heap size to fix a memory
leak because now it means instead of
opening two windows I can open up four
and then the then the browser will lock
up so
that's not the answer it'll help and it
will help in a lot of cases but it's not
the answer i did say that it's difficult
to communicate between these windows in
javascript what will help there is this
html5 post message now I like it that
it's cross window gives me cross window
communication what scares me a little
bit is it's also cross domain
communication so I guess that's a good
way for the hacker website to copy your
address book out well you're using it
and have that open in another window we
want to look at what people are doing
very carefully in html5 and see if
that's a secure design for that API
personally I would like to be able to
just turn off the cross domain aspect of
it and use same domain for for that
would make me more comfortable well now
in terms of this this blocking
connection to the server but what could
we possibly use there well there's some
options that are coming up web socket is
definitely interesting and that's what
we'll be talking about here in october
twenty ninth for the panel maybe server
sent Dom events but there's there's some
other possibilities to when you look at
what we get with xml httprequest it's
really not a modern implementation or it
doesn't expose modern HTTP it doesn't
really expose HTTP 11 HTTP 11 has
pipelining and well I'm chunking those
are those are two interesting things but
where we are really interesting in here
is the pipelining capability of HTTP
because if we could control which
connection and use pipelining for
requests we could very easily fit
multiple requests on to a single
connection so we wouldn't have to do so
much coordination across the multiple
windows that that would mean a simple
change to the xmlhttprequest API sola
that should be another option that the
people should look at in conclusion I
hope we've demonstrated that the
asynchronous web will revolutionize what
you can do on the web because now every
web application can be a new type of
communication technology in some
interesting application specific weight
we've shown that it can scale we don't
have to use a thread per connection
and we've demonstrated the capabilities
of ice faces and glass fish and grizzly
and you and as well as a variety of
other application techniques but of
course i'm most excited about the ice
faces and and grizzly portions and now
servlet three-point oh is coming up
which will give us a standard solid
foundation on which we can build all of
these different applications in a
portable way there are some links thank
you i know we do take more questions or
let's take a few more it's question and
then we'll do the raffle the web socket
um you were saying all october 29th you
will be discussing and in a panel you
wanted to yeah so on october 29th a
Silicon Valley web builder is hosting an
event and basically what is to talk
about is to talk about comment kind of
what we're doing today and then to push
forward into the future html5 spec which
is adding web sockets which kind of
really standardizes doing a browser push
and for that I'll be the panel moderator
we've got Ted Goddard we got Deion from
a Jackson com we've got Michael Carter
who is a committer to the html5 spec for
web sockets we've also got John follows
who's with cos in which is a start up
here in Mountain View that specializes
in comet and did I dress well and Alex
Russell from the dojo foundation and
he's pushing the comet d kind of the
reference implementation and jetty
partner with Greg Wilkins that they had
mentioned so unfortunately greg was in
Australia otherwise he'd be on the panel
to
but no location will be here on october
29th yes yeah originally i think it
might have been someone fremont yeah the
location has been changed to here so
it'll be a really good and then
following the panel discussion i'll be
doing some kind of a mini workshop on
comedy so i'm doing basically using
jetty to to show you know how to have it
what they were showing earlier with the
bay you implementation make more
questions yeah a couple of questions
about atmosphere about the license
number of jars and then does that handle
the half duplex issue of the two
connections ok so the license is lgpl so
that's the CDL so that's the the Sun
license actually the same as as glass
fish which is a dual license CDL and
lgpl and I'm working to add apache2 to
that to that set because if I want it to
be shipped with thumb cap or with any
Apache project I have to to use a proper
license so for the two connection limits
so at the beginning we don't we don't
have any solution for that first but
that of course that will that will come
it will actually I'm trying to build a
community around the framework now so
once i have the community then I can
start like like like solving such such
issue how many jars write it i will
support written so far it's just one jar
that includes the jersey yes a door to
dependency jars yo so I so the design is
not finalized for sure but the idea is
to reuse Jersey has as much as we can
and grab like only the jars that we need
from from Jersey so all the jars that
are dependent right for Jersey will also
be dependent for the atmosphere the idea
my idea was to have an osgi package so a
single jar and since Jersey doesn't have
any ways GI support right now is to read
package there there one so you have like
a single jar you don't care about
getting all those dependency because I'm
doing that for grizzly right now commit
and it's really popular you know because
it's much more easier to code against
one John a little bit is armed and then
the next version I think they're working
on the restful Java APA's yeah the JDK
it's already there right so why would we
should you use the Jersey versus because
you have look at the jacks are respect
they have it they use a lot of
annotation so they did a lot of work
that I that I need for atmosphere like
the example that I gave so and their
approach is really modular so I don't
need the rest part of jersey so far I
just grab some part of it but it's
important to see where those part are
coming from so I'm reusing if we the
good thing that did it so for the rest
part of course Jersey wants to have
comment so i have worked with the jersey
team to help commit to them saudi but
the idea then there is we face the same
problem is so it was working on grizzly
comment but how do we support Tom cap so
what we are doing for Jersey so once we
have atmosphere Saudi will build their
commit solution on top of it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>