<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>BayPIGgies Meeting - SF Bay Area Python Interest Group - Python Callbacks | Coder Coacher - Coaching Coders</title><meta content="BayPIGgies Meeting - SF Bay Area Python Interest Group - Python Callbacks - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>BayPIGgies Meeting - SF Bay Area Python Interest Group - Python Callbacks</b></h2><h5 class="post__date">2008-09-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fzQ00f1oETs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to Bay piggies you know I went
on an audition for a commercial a few
weeks back and they said don't call us
we'll call you and they never called but
apparently pythons more reliable than
that so I'm here to introduce Alex
martelli's talk Alex Martelli is a rock
star a few years ago he was an Italian
rock star he's the author of Python in a
nutshell and is the curator of the
Python cookbook and if you ever get in
an argument a language lawyer arguing a
language loitering argument you don't
want this guy on the other side of it so
Alex Martelli okay welcome everybody to
this monthly meeting of babies so just
in case you've gotta run that the one
thing that matters in the talk because
it's where you can get and download is
where you can download the PDF which has
all all my slides so the audience for
this talk is meant to be pretty broad
I'm trying to talk to almost everybody
if you don't know any Python if you're
the very beginning of the journey it
will probably be above your head if you
know a bit more Python than I do like my
friend Valentina right here you'll
probably get bored but he's a friend so
it'll it'll be patient about that but
for most of us the talk should i hope
the appropriate and interesting so let's
get started what's the general concept
of a cold back white back what what does
it refer to well once upon a time the
concept was of writing libraries which
was invented in the 50s within the
fortran community and then others was
well I make a lot of useful functions
and procedures put them together in a
library in your ugly
asian code cold thin to them so I can do
some computation for you and give you
the result so that was the normal way of
doing things it's still pretty much is
if you look at the documentation of some
application programming interface is an
API it's mostly gonna consist of what do
you call to make certain things happen
or to get some computations done on your
behalf or data stored or send somewhere
but once in a while there is i use for
something that's exactly flipped
backwards instead of you calling well in
addition to you calling entry points in
the library or framework you arrange
things so that the framework calls entry
point in your application code indeed
the very term framework as opposed to
the most more traditional one library
was introduced in the late 70s early 80s
to try and describe this kind of
arrangement or basically instead of
giving you a series of bricks to build
your house with you are being given the
blueprint and and just requested to
supply some bricks to fill in the
outline this has been cold for over 20
years now it's kind of I looked up they
the exact date of the reference got a
kind of scared of my account it was more
than 20 years ago I remember when I read
this first it must be in the original
publication and I wasn't exactly a
spring chicken even then it's been
called the Hollywood principle exactly
because of what JJ was explaining that
is you go and try out for something and
well thank you very much just don't call
us we'll call you meaning or implying
that well actually prolly they won't
bother to if they find anybody was more
appropriate or more suitable for the
role but in mesa
was not necessarily the first language
introducing the concept but it was the
one in which the nickname Hollywood
principle was coined the call actually
happens reliably and it's still funny to
call it the Hollywood principle anyway
so why would we do that I mean it's
pretty easy to see why we would want to
call into the library because the
library may have funky algorithms and
very optimized staff to do work on our
behalf but why would we want the library
to call back to our application code
what what is it we gain that way there's
essentially two groups of users which
will see one is customization the
traditional approach to customize
details of the behavior of some piece of
code is basically by giving that piece
of code certain parameters configuration
values configuration settings flags
golden as you will the problem is that
those get past once and need to stay
essentially fixed throughout the
execution in which you've passed them
the callback principle basically let's
the piece of code you're customizing
call back into your code to get the
parameter it must use and that parameter
may change from moment to moment
depending on your exact need so there's
no more flexible way of arranging a
customization architecture than by
callbacks the other large area is what I
call event-driven architectures and I'll
split that later in the talk between
actual events which is where actually
something happens there's an event and
pseudo events which are just a way to
structure elegantly inflexibly the
control flow of a whole program but
let's not get too far ahead of our
thread um so how is a callback
implemented it's pretty easy to
recognize it you've seen a lot well will
point out in some cases but anytime you
hand a callable
over to somebody some function or method
the somebody may as needed store that
call back or a reference to that call
back somewhere into container or maybe
just as a local variable as long as it
persists long enough and when
appropriate which is of course what
distinguishes various callback situation
it calls that callable for example it
does it when the framework calls your
McCulloch bull you originally pass to it
when it needs some specific
functionality that is the customization
case alternatively it calls it when
appropriate events have occurred and
then what's an appropriate event
depending on the use cases and we'll get
into a lot of details it can mean a
change of state some change state has
changed or the user a human being
unfortunately we we still have those we
have not perfected the system yet the
computers mostly talk to each other but
once in a while they still have to do to
those slow unreliable external systems
so that they end up clicking the mouse
why are they clicking the mouse I don't
know but we have to do something about
it or more normally when you're
interacting with other computers are the
pieces of hardware network event on
other I Oh like the discus finished
spinning time out as in we've been
waiting for too long in this thing which
was supposed to happen has it happened a
system event this the cpu is on fire and
other useful alert or when no actual
event occur we make something out
because otherwise would be too worried
we'd never use our powerful call back so
we make up some events in structure
control flow will we'll get to that
let's first examine customization which
is something that doesn't happen often
today in the sartorial world that
happens a lot in the software so not in
the fine where but in the software let's
take one of the simplest examples that
you're probably using every day whenever
you're
in Python when you are sorting some
sequence almost always you want to sort
it in a specific way occasionally it
happens that the natural sort
lexicographical sort with small numbers
and an early alphabetic letters Arthur
stand and bigger ones or later suits
your purposes more often than not you
want to do something slightly different
and the best way to tell sort exactly
what you want to do in terms of sorting
is to pass a key parameter to the sort
method or they sorted built-in function
if that's what you're using before
Raymond Hechinger introduced this little
callback trick this is how we used to
perform this task unfortunately many
people did it the wrong way bypassing
the CMP parameter which was a design
error iterated from C into Python and I
stuck around far too long don't use it
it's a bad design because basically it
ends up being called n log n times that
is a lot of times in this approach your
your function gets called on the end
times which makes a substantial
difference so when we had to call what
we what I nicknamed decorate sort and
decorate or DSU pattern basically we
take list as input and are callable key
and we prepare an auxiliary list of
tuples each of them has the index and
the value which I get an emerging list
but preceded by the result obtained by
applying the key callable to the value
and then I sort not the original list
but rather this auxiliary list of tuples
and finally I extract
I use only and set them as the new
content of the distorted when you call
minus that sort key equal something this
is basically what is going to do inside
although it's gonna do it much faster
and smoother than it could be possible
in Python because it's all built in as
part of the internal so sort so
basically tanks every value with this
key only and it also guarantees the two
values which correspond to the same
result for key remain stable so they
don't get swapped the here I had to
basically add the index as part of the
of what I was sorting to make sure that
there was not a swab so we want to sort
a list of strings in a case-insensitive
way but a simple way is upper case of
restraint in terms of sorting order so
I'm calling str to upper the two upper
method of the string type and that gets
applies to each and every string this is
kind of a weird way to do things if you
think in object-oriented terms because
in object-oriented terms you normally
want to call a certain method on each
item not on a type passing it the item
unfortunately there's no way to express
that in a Python callable except the
incredibly clumsy lambda which I never
recommend is so essentially this is a
start of an indication that callback
although it was introduced in mesa which
to some extent was an object-oriented
language is more of a functional idiom
than an object-oriented idiom now Python
those both functional and
object-oriented but there's a certain
impedance mismatch between the two and
this is one of the cases in which it
shows through just a little bit what
would be the object-oriented approach to
customizing if callbacks fit only up to
a point in a thoroughly object-oriented
view of the world the answer is what I
have presented at length these URLs give
you the video and the PDF as probably
the single most significant design
pattern the template method design
pattern in the template method design
pattern you put the framework
functionality in a class that is
intended to act as parent and that has a
method called the template method with
the organizing method which in turn
calls hook methods on the self object
and the customization is by inheritance
and overriding it's perfectly
object-oriented its hand it's compact
it's incredibly rigid sometimes it's
what you want but as you'll see if you
follow this presentation it takes all
the dynamism of Python and then psalm to
make it really usable in the real world
in most cases callbacks on the other
hand are inherently maximally flexible
so that's the trade-off if you want to
be on or purist to go ahead and use and
use a template method if you want to get
things done in the real world consider
all the advanced versions of of template
method that I present here or go with
callbacks and live happily ever after
another example is the concept of
scheduling scheduling means to being
able to register things that must be
done at certain times and making sure
they get down in the proper order the
Python standard library offers a module
for that is called scared and probably
the most natural way to design it would
be to hard code the measurement of time
by calling time to time to find out what
time it is timed up sleep to do nothing
and for a certain period of time you
have nothing scheduled for and so on
however the designers of the Scared
module considered and easily found
a way to achieve much higher flexibility
in the exact functionality of their
module instead of knowing by basically
reaching into the time module how you
tell what time it is and how you just
sleep for a certain number of seconds
you instantiate scheduler objects by
passing them callbacks for that purpose
the way scared is actually designed is
the flood is the functional programming
way the more flexible one where you pass
two separate callbacks one to tell what
time it is and one to just let time pass
the object-oriented way in this case
would be to to pass the object which has
those methods but this is more flexible
and the designers of scared well for
flexibility why is it important to be
able to pass a fake way to measure time
well because this increases the users of
scared enormously also makes it much
easier to test decently if you are unit
testing a piece of code that at some
point does a time sleep 99 you don't
really want to wait 99 seconds every
time you're on a test what they use you
need to fake out the time sleep one
approach is so called monkey patching
very popular in the Ruby world which is
basically reaching to the time module
and and set a fake sleep function there
that kind of works almost except for the
global repercussions of it or else there
is the elegant way no known as the
dependency injection design pattern
which is basically let the thing that
needs to sleep take the sleep call back
as an argument which is what we do here
and also there's many cases in which
your concept of time is actually just
something that goes linearly but it
could be demak ated but network events
for example there's never
the need to have anything up and unless
something is happening on the network
with sked you're basically just using a
in phenix sleep in this case four times
deep which does absolutely nothing until
something happens on the network and for
the measurement of time just anything
that gets woken up by a network event
and so on and so forth there's a normal
flexibility in how you customize so this
is the whole part of the talk regarding
the use of callbacks for customization
purposes other questions on this part
specifically you're talking about list
sort in passing function for the key key
word parameter and you were saying that
it was not an object oriented and that's
a painful thing can't you pass a unbound
method and won't that work out okay
could you pass what an unbound method so
class that's what I'm doing at solara
and then and so if I have a mix of
objects which are for example plane and
unicode strings it breaks because it
needs I have just constrained the thing
if I have a subclass of string that
other rides the upper case it do
varieties doesn't take because I music
there's also i wouldn't call it
object-oriented if it doesn't support
inheritance anything else no show me
move on anybody recognize why i choose
this to to represent events i'm actually
an engineer that has pretty close as a
ref addition thank you very much ok
what's an event there's basically two
classes or categories or kinds there's
proper games things that actually happen
in the real world and they're soo do
events that I'm essentially using for
the purpose of structuring execution of
my program so what's a proper event well
GUI frameworks are plenty of those
because things happen
people move the mouse clicking buttons
click on the keyboard spilled coffee on
the keyboard or the cast walk across it
each of this is probably a number of
events particularly the cat and that
need to be dealt with possibly by
yelling at the cart and chasing him out
of the room that's that's up to the
application then there's the observer or
more completely observer observable
design pattern which is basically all
about state changes as we'll see then
there's a synchronous or also known as
event-driven I Oh mostly network but it
works for a lot of kinds of i/o and then
there are what I deem system events
which are well we'll we'll see them in
detail in the course of the presentation
and then there's food events so once you
start doing event-driven programming
because typically because you're dealing
with real event you originally may have
a little bit of difficulty adapting your
wrapping your mind drow to it instead of
you calling things and making things
happen things just happen to you and you
could get calls to deal with it it seems
the world in Reverse but after a while
you know the Stockholm Syndrome have you
ever heard about this you get used to it
and you crave more and so instead of
just limiting yourself to the events
that actually happen in the real world
you start simulating events just so you
can respond to them the best example
actually joking apart is the
event-driven parsing the first time I
heard the sentence I thought it was a
mark of model generator of text to run
amok I know parsing there's like
recursive top-down descent and bottom-up
I noo yawk I know recur what
seven driven about parsing and then I
found out and you know it actually works
then the scheduled call back we've
already mentioned scared in terms of
customization that in the end the whole
purpose of scared is basically making
events up on your request to call you
back as we'll see and then there's
concurrency frierson the like and
finally there's timing the debugging and
like which will see at the very end so
what about the GUI frameworks well those
are the most classic basically the whole
invention of even driven programming or
at the very least they're spread like
wildfire starting maybe 30 years ago or
a bit later was due to the emergency of
graphical user interfaces because you
know programming a graphical user
interface in any other way and people
have tried absolutely the wrong way
sucks hard rocks you never want to I
don't know if you you can probably still
find some old and rusty GUI framework
that tries to not work in event-driven
way that don't even try using it TK
inter has are two classes of callbacks
one is for the most elementary kind
which are event so basically boil down
to their very essence of a button gets
clicked a button meaning of a mouse
button but a simulated button in the GUI
painted on screen well in this case it's
a simple click and there's one thing
happened no parameters to it no nothing
you get a call back and that's the
command equal parameter in in button and
similarly for other something has been
chosen in a combo box that kind of thing
very simple from the programmatic point
of view representing a series of action
by the user response by the graphical
user interface and then there's a bind
call which is a complete other ball
walks is basically
The Binding of a handler to a class of
events either in a window or in a widget
or in a class of widgets it's actually i
think the k inter goes a bit over
boarding that you can do a lot of things
which much simpler ways but basically
here the event is taken as a string in a
language which actually describes the
event so for example it could be a quote
less than key greater than this means
any key on the keyboard or it could be
quote a quote which means just the a key
on the keyboard or it could be enter or
leave the mouse pointer entering or
exiting a certain rectangular area and
so on and so forth it's a tiny and very
simple language that gets interpreted
when you bind something and then the
handler is where the callback happens
and the it's a callable that takes the
event argument as the only parameter and
then the event argument has a lot of
attributes with x and y for the mouse
the type of event widget what widget it
happened on and you can also bind by
class you can buy my route window the
the event and what object you call you
call the bind on or are basically even
too flexible but basically you can deal
with any user behavior and happenings as
events in this way another classic which
has possibly been the first way to after
the model-view-controller framework the
observer observable has been a
generalization that still lets you build
MVC on top of it but it's more general
because basically an observer is a
target object sorry an observable is a
target object that lets you add
observers which in the general case
could be callable so though often
because it's expressed in an
object-oriented way they
they'd rather need to be objects but the
point is that whenever the target state
changes the target knows and reacts to
the change by treating it as an event
which is a reasonable thing and calling
back to all the observers so this means
that there is no one to one tie because
any number of observers can be at a
given time observing any given
observable so you could have for example
a temperature sensor which when the
temperature changes tells an observer
which is going to draw a pretty graph
and another observer which is going to
to spray anti-fire fluid if the
temperature has gone above 400 degrees
and the two things are not mutually
exclusive I hope they spray or has
precedence but that's the does that or
at least happen pretty soon so there's a
lot of design choices in an observer DP
implementation I think if you read up
the treatment of it in the classic Ganga
for design patterns book it's really
very good as is all of the book but
essentially your choices you can have
general observer specific observers or
grouped observers a general observer is
essentially an observer that is asking
commune any state change it works but
typically you don't really want to do
something in front of any state change
but only some of them the state changes
off for example a temperature sensor
could be any temperature change most of
them will be totally irrelevant for the
fire prevention system or you could have
an event which is when the temperature
goes above 400 that is very relevant to
the fire prevention system
so the general Observer has a lot of
work to do typically to select after
having been alerted okay I'm really
interested in this alert or not a a
specific observer is a callback on on on
specific state changes may be a bit
harder to design because basically you
need to be able when you set the
observer to specify with reasonable
precision exactly what events are of
interest how specific are you being
which maver I and then we have grouped
observers which may in some cases be an
external complements these are typically
objects with several methods different
methods can be called for different
events for different kinds of chase
changes and in Python in particular
given good introspection is pretty easy
to make that selectively so you could
have class of temperature sensor
observers which implement method any
change and fire risk change in the ne D
any change method if implemented gets
called every time the temperature
changes and the fire risk one get lonely
cold above 400 for a night of course
this is kind of rigid in that you need
to do the design time except in Python
you can actually bend that rigidity a
bit because the introspection and
diversity together can be very powerful
but it's again kind of you need to
define a language in a very restricted
sense of the world language of events
that may be of interest to some
observers and others with general
observers you don't have that problem at
design time you have to basically code
at runtime I mean execute at runtime the
code but it is more flexible what are
you going to tell the callback I mean
what arguments are going to be used at
coltons the first and simple stories
arguments
arguments we're quiet people we don't
like to argue no arguments and that's
what decay inter does with the comment
equal scholar bowl of buttons does what
argument you want it's been clicked what
argument can there be no it hasn't yes
it has no it hasn't that's not an
argument that's contradiction in honor
of Monty Python for which are below the
languages me that only really works at
all in the very simple scale in observer
the natural choice is to pass an
argument the target object who stayed
just changed this way you can have a
sensor oh sorry I'm an observer observe
many observables say the fire alarm
could be observing 20 temperature
sensors when one temperature sensor goes
above 400 it alerts it calls back into
the the observer in passes itself as an
object to the one argument in the call
so but basically the fire alarm system
knows where to direct the flow of high
pressure water or for what warehouse to
call the fire department and so on so
that it is a natural choice it gives
plenty of flexibility it basically may
require the observer to engage in a
dialogue to find out exactly how did the
state change because basically the only
information it gets at all time is the
status change and it was my state okay
was it the temperature know who was it
the pressure does it sound like pressure
it's it can be kind of bus those round
trips so in some cases it makes much
more sense to define
what kind of to summarize the state
changes for example if an observer has
many state very many attributes that
considered estate it could be useful to
send a dictionary of attribute old value
new value sometimes that is all that's
needed on the other hand you say the
round trips which may be very relevant
if you're talking about network
communication because a round trip can
take me the second but you are sending a
bigger bunch of stuff which may not be
of interest at all so the as usual those
trade-offs the point of the stalk is
being aware of the trade-offs so that
when you do your design you can even
make the trade of appropriately and when
you're using somebody elses design you
can whine about how they miss design fix
all right and it seems like there's but
there's one other I think possible case
which is what if you had a callback for
every state change so for example you
had one for temperature 14 pressure or
14 that's the other service about for
the other things it's a great web server
right but what you do this is because
that method immediately doesn't any
requiring additional parsing it doesn't
require any additional grouping well
they still requires to know okay the
temperature changes from where to where
and when did you last measure it so the
fact that you know that out of the many
characteristic would change it is the
temperature still may require to
understand the proper response one or
more interactions with the object what
was your previous temperature what is
your current temperature at what time
did you take the latest temperature
measurement what time have you taken the
previous one it's not necessarily all
that you need to know and yes the
grouped observers do basically pass it
that way and also make things a bit
easier because at particularly in Python
it's pretty easy to just not if you
don't care about pressure you just don't
implement the pressure changed method
and don't
get a cold by roald which saves time on
the other hand for these cases you do
need to know in advance exactly what
parameters can possibly be observed or
again you can use it pythons
introspection and and dynamis City to
kind of update it but sending a
dictionary is a pretty general way
except that the dictionary can grow a
bit large as I said particularly if you
are measuring maybe rate of change as
well as value so I'm focusing for this
very apathetic example on physical
objects like a temperature sensor and so
on but I hope you realize this applies
to even completely abstract object in
exactly the same way just may be easier
to visualize the the sensor okay another
typically useful it's not a description
of the state changes they may not be
necessarily they may not be necessarily
continuous values so that such things as
rate of change and so on may not make
any sense but there may still be
possible to basically construct and
identify a description of the event
which may be sufficient to the observer
saving a round trip the event may or may
not be conceptualized at a state change
in terms of observer observable I always
start thinking in terms of state change
but it can actually apply to other
events they can always be kind of put
false mustache on and say hello I'm
estate of a change of state whether it
is or not but there's another group of
arguments which are very easy to forget
some arguments are related to the target
or the event but others may be related
to the column now you can always say for
example take the trivial example of the
common d equals something which doesn't
take any argument well what if I
actually want
arm to attach basically the same
response to 10 different buttons except
I need to know which button it is and
the thing is not passing me or basically
I need to attach different pre-decided
argument that was basically the kind of
problem we were discussing you buzz if
you want to pass the same thing but with
different pre-decided arguments which
don't really depend on the event they
depend on the collarbone at least this
is how we're conceptualizing that and
this is the Python architected way to do
it given any callable you can
predetermine some of its argument
positional in keyword by calling thanks
tools partial on it phantom partial
returns and our caller boulware some
arguments are already solved and you
can't pass them again and this is
extremely general or in a very useful I
used to know it as currying in
functional programming but i'm told that
carrying isn't really the appropriate
verbiage not nothing to do with indian
cuisine however notice how different it
is to call a set call back if you could
pass the function and the prebound
arguments versus if you have to wrap
those infantile partial yes the first
one is more general but how much more
elegant in smooth is the second idea or
almost as if you just passed a and KW
without the stars just the tuple of
arguments and the dictionary off of
keywords it's far neater some callback
systems in Python have noticed this and
support this but not all unfortunately
so what I'm telling you is when you're
designing a callback system please do
support this approach because it's so
much neater when you're using one you're
not familiar with check if by any chance
that is
we're good designers and are supporting
it so you don't need to to use
functional partials now we come to the
interesting problem of dispatching for
example it is typical for observable and
in some other coba cases we are we may
have set more than one call back we may
want to set more than one call back what
do we do if multiple callbacks get set
if you're familiar with the I Donal
hardware interrupts for example the
typical situation is the CPU is a little
table with like 256 addresses one per
level of intro from 0 to 255 when you
set an interrupt handler there well
whatever was said there isn't there
anymore and so what the latest one will
be remembered in some people
particularly in the early days of
colbeck system design well they worked
this way I when interrupt 24 happens I
want this to be handling it or when the
event happens I want disco back singular
it's simple it's particularly simple for
to implement because basically only need
to have your who am I going to call back
attribute no but it's very rough it's as
soon as you want to become a little bit
more general you have to start making
some decisions if you remember all the
callbacks that have heaven been set for
that event and the idea is you want to
call them all well in what order are you
going to call them last in first out
first in first out oh and by the way
don't forget to you will have to have a
specific method to remove a call back
from that is because if there was only
one call back it's pretty obvious that
if you set it to none or zero or
something like that it means forget it I
don't want the scroll back anymore but
if you're if you can set any number well
then you are better be able to remove
some as well as on some to this list and
if you do have a specified order do you
let one
call back along the chain decide I have
really completely handled this event I
don't want any of those coming
downstream for me to even get disturbed
so basically blocking the thing in
pre-empting others vice versa in single
callback systems a typical idiom is to
set a new callback you gettin saved
somewhere the previous one and the last
thing the the new callback does when
it's finished is chained to a previous
callback which is clunky but anybody
who's programmed for Microsoft DOS in da
tis know what I'm talking about that was
the typical typical approach then also
it's the only one only way you can
really do multiple interrupt handling
gifts if you're programming at on the
bare metal essential also can you
somehow group the events of the state
changes this is a different way of
seeing they grouped callbacks the point
being instead of a single color ball
kind of use an object with many methods
that will receive calls and how does
that inter interact with dispatching
it's this is a pretty difficult design
decision another sense in which you
could group it I would use the word
batch if actually performing the
callback function is costly you may want
to not do the cold back instantly that
only basically applies to the Metro
situation something that happens in
certain in certain cases is that the
data is arriving I want to give it
immediately except that each act of
giving is heavy because for example I
have to take maybe this two bites and
wrap them in in 45 bites of headers and
in packet well Connie waits two
milliseconds because more data is likely
to arrive Oh binds together so instead
of doing 10 x 2 x + 45 each time i sent
the 20 bytes only once but that's more
of an optimization for
all time performance a to be perfectly
honest they are likely to be to be
realizing that invite them although it's
not impossible then actually something
sometimes happens in gooey situations to
where you're you're having a painting or
something that you're you're
manipulating with DSP algorithms to find
things in you actually got me click the
button a number of times or and you you
can't do the whole thing part of it to
make it look like it's happening oh yeah
beautiful thing yeah very good part you
don't really want it to happen in
stuttering fashion you want a smooth
transformation to have plus if you're
designing a dispatch system you need
also to decide whether an error or
anomaly or exception isn't it then just
like any other or is really deserving of
different treatment for which is kind of
like the choice in UNIX of using
standard output for normal results
versus standard error for anomalous
results so that anybody who's like in a
pipeline just computing normal result
doesn't have to start worrying what if
or if it was a an error instead so for
the best solution or at least one very
well-thought-out solution to all of this
problem I strongly suggest this paper
this paper from many years ago actually
introduced it datatype known as they
deferred type as part of the crystal
matrix system but you don't have to be
into a synchronous network programming
although everybody should be as
valentino who's one of the core
developers of this no doubt would argue
but it can be used on its own just to
structure your callback the idea is
basically you have to change one is a
chain of callbacks for success cases one
is a chain of coal but let's call them
for error cases and you can go from one
to the other if an exception gets raised
or gets handled and it works like a UNIX
pipelining that
basically they forgetting the errors the
result of every callback is the argument
of the next one and you also get you
also get the ability to pre bind
arguments so it's really very well
designed now another popular class of
events are system events for example one
system events is dead death meaning
program termination or exit it's pretty
of pretty common to want a call back
when the program is exiting because you
need to do some cleanup for example
there are in some cases and depending on
the system you may not want to delete
all the temporary files you may be
leaving around until you know you're
done with them and you only know for
sure you're done with them when the
whole program is exiting well where do
you put the cleanup or do you put the
removal of all these temporary files
that are needed anymore you put them in
a callable and register it with the at
exit math module of the standard library
all day callable that you've recorded
with an exit register are going to be
cold I think last in first out but I
don't really remember but just before
the program is about to terminate no
other application code is going to be
called a signal is a quirky historically
based on on unix way to get almost a
synchronous calls smacking to your
handlers and this is a typical example
of very old design for callbacks for
each signal number you have one handler
not 0 not to what what happens is that
when you install a callable for a
certain signal number you get the
callable that was previously installed
as a result so you can do chaining like
you could induce indeed this is a
nineteen seventy design and it
it's basically from the very earliest
unix other examples unfortunately
there's some um so display hook and
accept hook are things that you can set
so you say sis top display hook equals
my display function and this means that
every time the interactive interpreter
wants to display something instead of
just the doing wrapper on that thing and
putting it on screen it will call my
display function with that thing except
hook similarly is how the interactive
interpreter what interactive interpreter
displays exceptions typically trace back
and so on but you can do it every what
but if you want to set a trace function
or a profile function that you do in a
more Java way sort of a saying sis
stopped trace equal blah you have to do
sister set trace of blador's no real
reason it's so historical junk he is the
complexity of this a trace callable bit
but the point is that so for example
citrus events are I'm about to execute a
line of Python code so for the system
the battle system is a relevant event
it's important that you are able to
actually do something in this case or
I'm about to call the following function
or the function has returned with the
result of so and so our set profile is
called it's in a similar set of
situation is not called for the single
line but it's also called for C coded
function and an extension module can
define social system events for example
a red line has among many other events a
startup event that is basically I'm
starting a bread line about to accept
input for the first time this is i'm
about to accept input once more pre
input hook this is the user as hit a tab
and is asking for completion of the
string so they're all events in this
case you
are there user interface although not
graphical they're still user interface
events but I'm treating them as a part
of system events because there's they're
basically handled in very much the same
way it's not an in tiny event-driven
system it just that once in a while in
the middle of doing something so you are
you call raw input give me a line that
the user types and you have redrawn
installed well that will cause a call
back to your pre input hook maybe 2 the
complete or maybe two other call back so
that the red line module dolls
eventually your main line of code gets
again control because raw input returns
and there's a string ready for you and
finally if you really get addicted to
event you will find yourself using sudo
events eventually make up because
there's such a nice way to structure or
execution parsing is possibly the best
example scheduling we've seen half of it
will will see the completion and then
there's concurrency that's timing
there's debugging and many others you
want so even read in parsing the best
example is sax so lots of people can
stand it and really want to use Dom or
something lighter weight better designed
and down like a lemon tree but the
concept of sax is that at least for XML
parsing can be seen as a sequence of
events if you squint the right way the
events are basically attacked is opened
these are this is the tag name these are
the attributes there is text content
here it comes and a time is closed and
this is the tack that was close and
that's all there is to it there's
nothing else you read from the beginning
to the end well there's processing
instructions and
tomlinson junk but why is this good
because the XML document is sometime
huge any sometimes coming at you
gradually from a disk a few megabytes at
a time and I'm not joking when I say can
be really you to a few megabytes at a
time you don't have to wait until you've
seen it all to do it and driven passing
you can start generating the event to
the application code as soon as you've
seen the tags and a in the piece of tax
and other piece of tags and the closing
tag and meanwhile the document keeps
calling it may even coming be coming
through a pipeline or a network in which
case it could be it is or even driven
parsing means you don't have to have it
all and it means even if you're handling
a 50 gigabyte file you don't need 500
gigabyte of RAM to build a complete
model you just do it a little at a time
because from the point of view of the
application it probably will not care at
all about most ants or at least that's a
pretty typical application when you're
parsing XML so the XML is a say a
library which is a sequence of books and
books have tag which says the title in
the older and the content which is the
whole book for example which is a bit
big so you only want to know the title
of books by Isaac Asimov but the only
way you can do it is from this 50
gigabytes tree doing it with the Dom
would be suicide doing with the sax is
reasonable you basically notice ok a
book is starting and start keeping note
and this is the title and the other is
Robert leamon I don't care woof I just
write until I get the closed book and
then Oh Isaac Asimov ok rustic or the
title in a tiny structure on
side and then ignore the rest until the
book is closed so they parsing by event
is actually as performant as XML itself
lets it be because you can you cannot
take okay fine I don't care skip ahead
you have to sit through the whole things
like one of my talk you can fast forward
if your present hearing person but still
you don't have to listen until an event
happens maybe I move on to a more
interesting sign or something and so
even driven following of Tech Talks is
is kind of like heaven driven parsing
yeah the other extreme of course is the
Dom there's also aid intermediate system
invented by our own poll fresco which is
a pool Dom which makes me wish I had
another hour which I don't I'm almost
finished because instead of doing
callbacks it does streaming which is the
duality which is so how they ever
recognized instead of calling you for
the tags it gives you a stream of the
tags and the reason is called the pool
DOM is that when you find a time you're
really interested in you can tell pulled
on Oh fill out that little branch of the
Dom tree so that you can then play it at
your art content is probably going to be
very localized the callbacks and streams
and iterators in in Python terms are
kind of dual there's a lot of situation
in which you can use both if you think
of Ruby iterators they're based on
callbacks Python iterator surveys on
screaming this Python iterator gets the
items out acts your code while in in
Ruby your code gets called back for each
item so I have more sympathy for the
streams of course but
even though this talk is about callbacks
another example of manufactured event is
scheduled we all have schedules and we
all know they're pretty much made up I
mean there's nothing the meeting starts
at nine sharp why what happens after
that it make yours right no nothing but
it's still we have this event at nine
that's a manufactured event well we'd
better do that if we want to be
basically all in the same place at the
same time and that's what's scary is for
actually so you you call it with the
time and delay function and then you can
enter in the schedule of our after this
much time with this priority this please
call this caller bowl with this argument
or at this absolute time with this
priority must be the same thing except
counting from zero instead of from from
right now you get any event to talk in a
as a return which you can cancel at some
point is like oh I can't make it to the
meeting that kind of thing when you have
done preparing the first version of your
schedule you called s run we just keeps
running events in with the recommended
timing and so on so basically sold one
call back after the other up specified
times and if you ever get an exception
from from one of the color balls that
basically ends up propagating but you
can catch it outside of run and then the
it is guaranteed by the semantics of
sched the the queue of events after that
will not have been disturbed so you can
basically catch exceptions from outside
the disc a jeweler and risk and continue
the schedule from there it's a really
really well designed module I use it a
lot I much prefer it to crawl in by the
way if I can ever keep my own demon
running I don't want to depend on cron
we're dishes then this concurrency
writing is a most popular form although
we could talk Longley and bitterly about
it but it's still very popular and the
basic okay you can do it the
object-oriented way by subclassing
thread and be a nice java like
programmer or you can do it the
practical way and pass a callable to the
target keyword and this is the Python
way really and then it calls target and
they key point of course is it calls it
in a separate thread that's the whole
point in 10 it's really only useful if
you're going to do blocking are you a
lot and yes twisted is a better way to
arrange things even in this case I
entirely agree with you however in some
cases where you want very cooperative
threading and you want really really
want to have hundreds of thousands of
right around then even twisted wood on a
single CPU because even multi-core be
kind of but you can use the stakus
Python approach where you basically have
stack lights and tackle it has task
let's it's all very very cutesy and the
casket is a callable and the depending
on the set up everything is called back
if it's active in front of Q which pure
round-robin very very simple and it's
basically up to the task elite to
suspend itself to avoid taking up too
much it can use channels to communicate
with other other task lights or a
schedule that it's a very elaborate
pseudo concurrent I believe there is
some real concurrency if you have a
multi-core now but I haven't actually
look into that but it's very cool on the
other hand if you just have something
written with threading but it's not
heavy weight enough for you status is
the other way around it's incredibly
lightweight wonderfully fast but
sometimes you really want to use all of
your 16 cores or 32 cores or however
many and then you should use it used to
be a third party module called
processing there's now a
standard library version called
multi-processing starting with 26 which
I believe has just been released in beta
so I suggest you try it out and he's
basically does with processes worth
reading those with threats and then
there's network spaces which is a
completely different approach it's they
used to be called Linda spaces a long
time ago is still alive and it's got a
great implementation for Python in a
decent one for our which is a very
quirky statistical language if you ever
need to do distributed programming with
Python and are which is a pretty narrow
niche but if that's what you need you
should really look into that in timing
and debugging is so for example if you
if you look at the time it module it
doesn't take callable it takes a string
but that string is to something it
compiles and execute so it's a call back
in an indirect and then kind of dynamic
language e-way but oh we are a dynamic
language not nevermind so the event is
kind of very made up the event for the
setup string is once at the beginning
that's actually pretty typical even in
real event system 12 and we're just
starting event but the event for
statement is one more case in which I'm
trying to measure your performance so
it's pretty you know the point of time
it is find out exactly how many micro
second a fraction of micro second it
takes to do a particularly tiny idiom so
you can pick the right one so this is
timing precious time it module the PDB
debugger also works by either string or
callable because you have PDB run and
you have run evolve which do exactly
ball respectively and you have pd beer
on coal which takes a callable and
arguments but they're both called back
except essentially that PDB run does a
compile in addition so you pass it a
string that there's no real constraint
up and
we are finished almost in time and we're
ready for official Q&amp;amp;A and I also have
my URL again they're just for
entertainment you were bringing up um QE
libraries that don't rely on callbacks
java 1.0 awt you would have a single
function with the loop that would take
it that would get the current event and
then do inspection on the event to do
some code no callbacks involved and
thankfully they got rid of that in 1.1
things aj for making my point so well I
didn't remember I and that's when I use
Java back in 10 time but then I got post
Java stress disorder any answers well
then I'm all done thank you oh one more
so when you were talking about XML
parsing with the Dom sax and then pulled
all my thing mm-hmm which so which one
is more scalable I'm sorry which ones
are and aren't scalable you know Vinny
Dom any form of real tom is not scalable
it will take up all your memory and then
shake you down and take the pennies out
of your pocket to go buy more sacks is
the most scalable pull down because
basically it keeps calling you it takes
a linear time with a you cannot take
less than linear time with it whither
the document right you have to look at
all of it even if it's boring and pull
DOM is an interesting compromise which
is almost as fast as sax but almost as
handy you don't actually have to build
your own data structures because when
you reach a point close enough today the
leaves of the tree you tell it ok expand
this node and all these children of
course if you do that and you're wrong
in believing you're close to the leaf
whoops you're in trouble but differ from
any kind of XML files you kind of can do
that and afford to do that
well then we nor don't thank you very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>