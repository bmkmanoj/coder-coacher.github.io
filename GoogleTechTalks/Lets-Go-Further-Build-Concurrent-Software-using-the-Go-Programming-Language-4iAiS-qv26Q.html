<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Let's Go Further: Build Concurrent Software using the Go Programming Language | Coder Coacher - Coaching Coders</title><meta content="Let's Go Further: Build Concurrent Software using the Go Programming Language - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Let's Go Further: Build Concurrent Software using the Go Programming Language</b></h2><h5 class="post__date">2012-05-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4iAiS-qv26Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">without further ado I want to hand it
over to Samir Samir as a member of our
engineering team here at Google been at
Google for a long time
Samir so-sorry said I've been at Google
for a while
joined Google in 2004 and I joined the
NGO team formerly relatively recently in
January but I've been using go for a
little over two years I'm a systems
infrastructure type developer I work
primarily on distributed systems storage
infrastructure networking infrastructure
RPC layer all that sort of thing and the
thing that really attracted to me to go
or the concurrency primitives and so
about half this talk is going to focus
on gos concurrency but the first half is
going to really start with the basics
walk you through a bit of the syntax and
talk about and particularly goes
alternative to the traditional
object-oriented programming model go has
an interesting way of providing methods
and interfaces on types but let's start
with some background first
so I'm gonna try to keep the fonts
bigger on the slides up can afford it
but it's going to get tight a little
later there's a lot of code in this talk
why bother with a new language static
statically typed languages and as of
2007 which is when the go project began
we had a lot of juice of Java and C++
and Google and there were other very set
of languages that have been popular but
the statically typed languages tend to
get more and more bureaucratic and while
they provided you a lot of efficiency
and a lot of safety with compile time
checking they seem to just get more and
more complex over time and there seem to
be a reaction in the programming
community to switch back to dynamic
language dynamically typed languages
where you had less checking a lot more
freedom a lot more rapid programming in
iteration but you lost so much of the
safety you tend to make errors you don't
detect on runtime and you pay a high
runtime cost these languages tend to be
have worse runtime performance than the
static languages and the biggest problem
tends to be when you write one write big
programs big collaborative projects
these dynamic languages just and the
model just tends to break down
another big trend we've all heard it
year after year is that you know instead
of processors getting fast you're going
to have concurrent programming you know
multi processors you want to do more in
parallel more concurrently there's a bit
of a distinction between concurrency and
parallelism I'll get into later but
historically concurrent programming has
been hard
there's thread models there's event
models there's locking and condition
variables and there's generally a lot of
headache because it's hard to map those
models to your brain and go adopt a
particular concurrency model that we'll
get into that I find much easier to map
and I hope you will too the classic
trade-off has been speed or reliability
or simplicity pick two or sometimes one
goes trying to hit a sweet spot in that
space so go started in 2007 and the
quote that you'll see here and there is
from Rob Pike consensus drove the design
nothing went into the language until ken
Thompson Robert Grissom ER and Rob Pike
all agreed that it was right some
features didn't get resolved until after
a year or more of discussion and you'll
see as I go through go there are things
that are missing there are things that
your favorite language feature may not
be there and it's probably not there for
a reason
with a couple of exceptions and that's
something we could probably offer in QA
you are interested the first release of
go was in November 2009 so that's two
years later and just last month we've
had the version one and this is intended
to be a stable release of the language
for years meaning programs you write
today should be usable for years and
this is the intent here is to allow
companies and people who write
programming books and you know people
who want to build a program and just
have it work and run to be able to start
with go on and make good progress so
what is go it's an open source
programming language golang.org is the
home page and there's all sorts of
information you can find the entire
source for the compiler runtime
everything and there's a huge standard
library all the sources there it's a
general-purpose language initially it
was really targeted at systems
programming but it you know as people
gained experience with it we realized it
really there's a lot more general than
that
it's concise expressive and readable now
you can get concise without readable if
you think about pearl and you can get
expressive with a lot of typing unko
syntax allows you to omit a lot of the
things that you already know or don't
need to know but the critical elements
are there and you're gonna see a lot of
go code in this talk go statically type
so the compiler does you know we'll
check for dumb errors and you know for
the most part big programs hanging
together can hang together really well
but gos interface model is a little
different and it gives you a bit of the
feel of duck typing you'll find in
Python or other dynamic languages and
that actually allows you program to be
much more modular and I'll go into that
as well
goes garbage-collected and that's tends
to be very important especially when
you're dealing with concurrent programs
yeah there's a lot of there would be a
lot of bookkeeping otherwise it's
compiled a native machine code it runs
fast and it also compiles really fast
gos syntax and you know overall language
design is one of its goals was to
compile big programs quickly it has a
strict dependency model and if you
actually go and play with some of the go
p-- and source tools you can compile
entirely from source know make files at
all because of the way goes the go
languages design and again goes
especially good for concurrent
programming so if you deal with
distributed systems or you deal with
systems that you want to take advantage
of parallelism in your machine take a
look at go alright let's start with
hello world
so here's hello world written in go go
programs are unicode so you can write
world however you like and shift-enter
that was a compile and run here's the
output down at the bottom i can edit my
program in the browser I can type to
really compile and run there's hello
again
this is running a modified version of
the go tour which is hosted at tor dot
golang.org that's an excellent
introduction to the language it all runs
in your browser that is running compiles
on a compiled form that we host and
therefore has some restrictions I'm
running this locally and therefore I can
do anything I want tell the world 2.0 so
let's take hello world and you know make
it web enabled this
right here is I'll zoom in and zoom out
just to try to make it readable but
here's your main you've got your let me
start at the beginning
package main every Co programming's and
begins a package main we're importing
two packages a formatting package and
the net HTTP package and func main is
the entry point of the program HTTP dot
that's referencing a function from PAC
the package HTTP the last component this
path name is a package name locally by
default you can give it a local name if
you want handle func says handle the
root URL with the local function Handler
and listen and serve means block and
serve they should be requests on local
port 8080 my handler function it's
taking two arguments a response writer
which allows us to write data back to
the client and the oral and the HTTP
requests I'm going to extract the name
as the firt as the URL path - the first
component and call pumped-up f printf to
write my response just hello comma
whatever that first component is so I
start that running we're gonna block
here
yeah allow that to connect let's pull
this up at a tab here is hello world if
I change it to hello world well - hello
world - so I've got a little locally
running web server in rather few lines
of code this is showing off a bit of the
design of goes core packages they really
are the we've done a lot of work to make
the core packages useful and allow you
to get a lot done pretty quickly so
let's see import mesh be in for some
actor named HTTP in handler what was the
type of name notice right here I didn't
write any types and look this gets to a
lot of what helps makes go make go
concise go as a simple type system it's
statically typed but you get a lot of
type inference and that saves a lot of
repetition we take some examples you
know in Java if I have a date I have to
I can still have to say what type now
has it's a date now and that's a new
date and C or C++ you know I'm still
providing the types and go
I can just say now : equals time now and
that has a type the type is time time
it's the type time in the time package I
: equals 1 that's an integer pi is math
dot pi well I don't know what exactly
type that is but I can use it because
it's hot greeting Kalinka hello that's a
string and essentially at the program
level to declare a variable at the top
level you just say var and then the
variable name and then the type by
default at 0 you get 0 initialized
memory I can define a there's a blocks
in text for variables for you know large
sets of declarations and they infer
right so X X is declared to be a
variable initialize to one y and z or
two and three when you have multiple
initializations you initialize each one
and separately within a function you can
use the same var syntax but you also get
this shorthand Python Java colon equals
false combine oh and then I can pass
those off all too pumped out print line
and get 0 1 2 3 true false no right so
pumped is doing the right thing for each
type and that's also part of the
strength of that package all right types
and functions to declare a new type I'm
using the type keyword here this is a
type vertex that is a structure that
contains two members x and y each of
type float 64 I'm going to find a
function func vertex to string it takes
a vertex returns a string and it's just
doing the Sprint tough call to format it
with parens around VX and V Y in my main
I'll declare a vertex I'll initialize x
and y 2 3 and 4 and I'll print it out 3
4 but we can do better go syntax makes
this easier
first of all go has excellent composite
literals now what are composite literals
so go as a set of composite types
including Struck's
built-in maps arrays slices which you
could think of as a sub section of an
array so those are the basic composite
types and of course you can nest you
have struck some nesting stress nesting
other Struck's and maps and so on and
you can declare these entirely you can
declare these values and valuable values
in your program and this really saves a
lot of
it saves oftentimes saves having to
write even in a constructor for your
type if all you're doing is dealing with
a plain old data type and you want to
just initialize it your structured value
so here all I've done is replaced VAR v
vertex VX b y34 with v : equals vertex 3
comma 4 this is using positional
initialization so I get the same 3 4 if
I remove this and instead say Y colon 3
I get 0 initialization for the X and 3
for the Y the 0 using 0 values as
sensible defaults is very common and go
right you know Bulls default to false so
it tends to be that if you have a type
like this that has a bunch of fields you
want the zeros to be sensible and then
you just initialize what you need and
the type is usable just like that
for example the mutex in the sync
package it defaults to an unlocked mutex
right sort of how you expect so you can
just declare a mutex on the stack it's
unlocked you can lock it and unlock it
and it all just works methods right so
going from vertex to string that's of
course we typically don't write
something like vertex to string we just
want to say V dot string well you can
define methods and go and you can attach
a method to any type you define right so
all that changed here is that I replaced
vertex to string pret with a parameter
vertex with a function that has a
receiver veto vertex and the receiver
looks like an argument list that appears
before the method name it only contains
one thing within this method alright you
know I gave a receiver a name I gave it
the name V so the actually the method
definition is exactly the same you can
call the receiver whatever you want it's
conventional to give it a short name
from your type and this of course works
just the same as a previous program
alright so we can do more we're gonna
get a little tight here but I'll zoom in
again I can attach methods to any type I
define and types don't have to be
Struck's
I can define a Celsius and Fahrenheit
types that are each float 32s those are
distinct types and I'll get in I'll show
you an example of what that means I can
attach to the Celsius type a string
method you know and it's going to print
whatever the flow
to precision degrees Celsius same for
Fahrenheit degrees Fahrenheit and I can
define define a conversion that takes a
Celsius value and returns a Fahrenheit
value doing the standard conversion and
in my main program I'm going to define a
Celsius value in print C equals its
Fahrenheit value and 100 equals 212
Fahrenheit great seems to work if I try
and mix Celsius and Fahrenheit values
and computation to get a compiler error
and I was gonna that was a reasonably
fast compile in my opinion invalid
operation C you know this expression
mismatch type Celsius and Fahrenheit
useful compile compile errors is another
thing that the go team really strived
hard to do now you might have noticed
that I didn't type dot string anywhere
it just worked here's where we get into
goes the interface model model the func
package defines an interface called
stringer and it looks like this it has
one method which is a string and it
returns a you know method called string
that returns a string that's the
signature of the method in this
interface all it interfaces and go is a
set of methods and a type implements an
interface if it implements that set of
methods signatures that's it you don't
have to say implements anywhere there's
no explicit declaration of an intent to
declare an interface this is huge for
decoupling your code and providing
modularity right let's go into a little
more detail I can also create a value
that's an interface right so I can say a
VAR s which is a stringer I can create a
vertex in Celsius which is what you've
seen before I can put a vertex in a
stringer I can put a cell against a sign
of Celsius to stringer either one works
because those are all valid assignments
and we're checking at compile time that
those are valid assignments if I print
this out I get the vertex I gave the
Celsius and I get whatever was in the
stringer the last thing I put in there
was Celsius so that's what I get the
rest of this is what you've seen before
let me see so one example that I like to
point out for why having interfaces that
no one else has to see is useful well
for one thing this stringer interface I
here is in my package main it's not the
stringer that was defined up
format it still works because vertex is
defining the right method that pumped
expects right if you like testing your
code you'll like these interfaces
because if you have a module that
depends on say a number of incoming
types and it calls certain methods on
those types often if you want to write a
unit test you end up writing mocks or
fakes for all those types and sometimes
you just care about a fraction of the
methods on the types you'll receive it's
a it's a database handle you might only
be calling query or read you might not
be opening and closing database
connections you might just need some
restricted access and go you can within
your package define just the interface
that you depend on and in your test you
just mock that part out
now you've isolated exactly the code you
care about whoever define that database
type didn't doesn't know about the
interface you defined yet everything
still hangs together properly all right
HelloWorld 2.1 so here this is again
that web server serving hello world
but i'm going to emphasize on the
interfaces i'm using in the HTTP package
I've got a handler interface and it has
all of the right line wrapping a serve
HTTP method with the response writer a
request so any type that implements that
interface can serve HTTP via this
package and the foam package the pub
printf can write to any value that
implements IO dot writer and a writer
can take a slice of bytes and it returns
how many were written in an air alright
so I'm showing off a few things here go
has multiple return values and this is
often how we signal errors and go has
slices which is kind of like an array
there's no I'm not going to get into
slices very much in this talk you'll see
them used I was to give you references
where you can find out more later so in
my code I'm going to find that type
hello which has it just struct with a
greeting string in it
hello serve HTTP method it's going to
take that first almond of the slice of a
URL path and it's going to print to the
response writer the greeting comma the
name in my main I'm going to say I'm
gonna create an instance of a hello and
set the greeting tuna must a and let's
start that server running
open a new tab I must stay world
fantastic and so this is all still
statically checked right the fact that
Hello is implementing the right thing is
what makes it work if I delete the P
from HTTP I get a compiler error cannot
use H type hello as a handler in this
argument it's missing the serve HTTP
method I find that pretty informative
right so just because you're getting
this power doesn't mean you're losing
clarity all right we're gonna switch to
my favorite topic concurrency this is
what made me fall in love with go gos
concurrency models based on
communicating sequential processes also
in the CSP towards I described in 70s by
CR whore the idea here is that you have
multiple concurrent executing processes
that are exchanging data and in UNIX we
see this quite a bit we have service you
can have streams of tools that are
communicating via pipes processing via
pipes so here I'm finding some files I'm
sending that output to grab to look for
certain files meet matching a pattern
and I'm sending that output to count the
words and the lines in each file each of
these tools find xrs and WC is designed
to do one thing and do it well and it's
the composition of these it gives us the
power in the real world we see this
pattern quite a bit and I think this is
one of the important points about why
thinking about good concurrency and go
is a little easier because it does map
to how we really think about concurrency
in the real worlds that you assign
individual tasks to individuals and we
connect them with communication or
transfer of goods and services factory
assembly lines is a big one right this
was a huge deal that to get a car and a
Model T produced quickly you wanted all
these stations working each on their own
small job and they're each proceeding as
fast as they can go on the inputs
they're receiving and send the outputs
down the line right so they're all
working concurrently while working in
parallel and they're passing data namely
those very stages a car down the line
but it doesn't have to be a linear
connection right you can have a tree of
connections so if you think of a phone
tree this is the way a family might
disseminate some news in the old days
you know mom calls you know her sisters
their sisters call you know the brothers
and sisters and it sort of spreads out
recursively and Nelson everyone knows
this is pre Twitter and software
projects which are all know and love you
know the big task you break it up into
teams the teams break it up across
individuals things proceed concurrently
with various synchronization in terms of
information passed between them the go
analog go routines connected by channels
go routines they're like threads in that
they share memory but they're much much
cheaper you can have programs with
thousands or hundreds of thousands of
these go routines have smaller segments
to stack's that means that they start
off in the current implementation at say
4k so a fork a stack you can have a lot
of those and the stack grows dynamically
as needed you can have many go routines
per operating system thread even a go
program that's using a single thread to
multiplex go routines can get huge
amounts of i/o parallelism and if you
have more if you if you give the go
runtime more CPUs it'll use them it'll
multiplex the go teams over those CPUs
this is all managed by the go runtime
all right so we start a new go I'm going
to talk do this and I'll zoom out on the
code you start a new go routine with a
go keyword right take just take a
function invocation like F X Y Z and put
go in front of it that just starts that
invocation running in a new girl routine
so the evaluation of these various
symbols F X Y &amp;amp; Z happens in the current
girl routine and then the execution
starts in the new go team go routines
all run in the same address space they
share memory just like threads do and so
if you want them to actually have
synchronized access you need to
synchronize properly and there's a sync
package standard package that provides
mutexes and condition variables but we
can do better and we will with channels
let's go into this example real quick we
have a function main I'm going to give
it a random seed and I'm going to launch
one go routine it that calls this
function say with the parameter world
and in the main routine I'm going to
call say as well with parameter hello
with the arc hello
takes a string it loops five times it
sleeps for a random duration and it
prints the string so heck run that I get
some random sequence of world in hello
if I run it again different random seed
I get a different sequence well that's
fine and good but you know unless we can
know say once a completed and what it
produced that's not terribly useful that
says where channels come in a channel is
a typed conduit through which you can
send and receive values there's an
operator for this in the language the
channel operator so if I have CH is a is
a channel value I can send a value of e
to it with well with this syntax
similarly the expression received from
channel is that's a typed expression it
gives me you know it gives me a value of
the type of that channel right so here's
how I can receive a value and assign it
to V my data always flows into the
direction of the arrow channels must be
created using the built use the built-in
function make so I would say make Chan
int that's a channel of integers by
default channels provide not only data
transfer but also synchronization a
sender and receiver a send will block
until some other girl routine is ready
to receive similarly a receivable block
until a value is ready to be sent once
that happens once those two meet up then
H then the communication happens in the
you can make progress again so let's see
how that works let's take this slice of
integers and some it but some it in
parallel with two Grove it seems we're
going to make a channel of integers and
assign it to C we're going to start to
go routines and give half the slice to
each and then we're going to receive
from the channel twice we started to go
routines we expect two results and then
we're going to print the prints what we
received from each go routine and the
final sum alright so this this slice
syntax it is roughly what you'd expect
from other languages you know if I omit
it this is 0-2 halfway this is half way
to the end right
our folks um is going to take a slice of
integers and slices know their own
length so you know I made er a ting over
this slice it's just the part that we
gave some and this C is channel of
integers so this sum the job of sum is
to sum up the integers that in the slice
we gave it and send it on C so it's just
gonna loop in the normal way accumulate
those into some and send it to C so if I
send that out I get 17 minus 5 and 12
why this part is 17 this part is minus 5
and the overall sum is 12 right so you
can imagine distributing the job more
widely right you can imagine deciding
how many go routines to create at
runtime what a loop and we'll get into
example to do exactly that what really
helps here is that I'm writing
essentially straight line code I'm not
using any mutexes or condition variables
that's all the synchronization and all
the data exchange is implicit in these
communication operators all right
channels can be buffered which
essentially is a way of instead of
having blocking sends and receives they
can they can sends can proceed freely if
they're spaced in the buffer and
receives can proceed if there's elements
in the buffer so sends to a buffered
channel block only when the buffer is
full receives block or the buffer is
empty
so here I'm making a channel of integers
that's space for two elements I send to
it twice and receive from it twice so I
get I get 1 and 2 out of channel it's a
FIFO order right if I decrease if I
remove the buffer what do I get
all goroutines are asleep deadlock dead
locks in other languages are really a
pain point but and go routine they're
actually pretty easy to deal with
because you get a nice error message it
says hey on line 7 is where this girl
routine is stuck and stuck trying to
send on this channel in fact it says
it's stuck trying to send on a channel
so what happened well I have a channel
that has no buffer and I only have this
one go routine there's no receiver and
as I said before you know a non buffered
channel sends our gonna block so let's
give it a buffer but we're gonna give it
one buffer
happens then another deadlock but wait
it made it a line further there to eight
because the one proceeded and went to
the buffer and two made it but then two
got stuck because no one's receiving
give the two buffers or three then it
works so buffers really provide a way to
sort of grease the wheels and allow you
know goroutines to say producing a lot
of data to push data into a buffer and
then have one or possibly a bunch of go
routines feeding off that channel and
actually this idea of having many to one
or one to many are many to many
communication through a single channel
is something that often comes up and
gives you a lot of power range in
clothes these are really just
conveniences and syntax if you have a
channel that you're using you have say a
producer or generator of values you have
a consumer that wants to consume until
the producer says I'm done range and
close your friend so you can close the
channel it's basically a way of
indicating no more values will be sent
this only makes sense in the one-to-many
or the 1 to 1 case of generating data so
I have a Fibonacci function it's going
to generate n values from Fibonacci
sequence and send them on this channel
and then close the channel here right so
I start with 1 1 each number in around
the iteration I said my X I do the
Fibonacci update I loop I'm showing off
here a bit of parallel assignment X
comma Y gets y comma X plus y this works
you can use it to swap X and Y you know
parallel assignment as atomic semantics
so in my main I'm creating a channel
with a buffer of size 10 I'm asking for
10 but the first 10 values of Fibonacci
capacity of C is just that's just
evaluating 210 which is the size of the
buffer of C and I'm using this range
primitive range works for a bunch of our
built-in types rain you can range over
slices you can range of our maps you can
range over any go range of our channels
and in the case of channels that means
couldn't continue in sold channels
closed so here I'm consuming the values
from the channel and then main exits
when I get all time the thing to me the
key thing that makes this all really
work is a select statement because this
is how you deal with programs that need
to deal with communicating to multiple
other entities
either multiplexing or D muxing or
pulling together information from
multiple sources dealing with ticks from
a clock and at the same time dealing
with communication select is the key
component here that sort of wraps it all
up a select statement looks like a
switch it's a switch that blocks until
some kingdom communication can proceed
right so each case as a communication
right you can have a case that's a send
a case that's a receive and you could
also optionally have a default case if
you don't want to block right and the
default will proceed if none of the
other communications are ready right so
without a default the Select statement
will just block until one of the cases
can proceed and exactly one will proceed
if more than one could proceed then
selected proper random right and that's
important for scheduling properties so
my example I'm just gonna use the same
Fibonacci example but instead of telling
the Fibonacci function how many numbers
to generate I'm gonna pass it two
channels one is the channel on which I
want it to send the values the other is
a quit channel which I'm really just
using as a signal right when when I want
the to stop any Fibonacci values I'm
gonna give it something over this quit
channel and so Fibonacci is gonna loop
it's gonna select and see can SM send
the receiver a value if so update and
loop again if I get quit print quit and
return so here in my main I'm making the
two channels
I'm calling go Fibonacci I'm looping ten
times you know I'm choosing how often
how much loop I can keep going for as
long as I want receiving that value and
then telling it to quit hey look at that
alright there we go so here's my output
something's missing I didn't see quit
and yet
main exited what happened well detail
the go program ends when main ends so if
you wanted to see quit you'd have to
make sure that main waited for it so
that's important for just making sure
your program lists forever as an earlier
earlier HTTP server examples often main
ends with blocking on say serving
something if you wanted to just block at
the end of your main when my other go
routines run you can just have an empty
select statement as I said it's like
select statement blocks until some case
received
cases it blocks forever let's go into a
real Wow send me a real example at least
one that illustrates how you put a lot
of these techniques together to really
handle a systems problem that I found
hard and was something that I've used go
to solve so what does Google search do
well given a query returned a page of
search results and maybe some ads how do
we get the search results well it's
really happening here is we're sending a
query to a bunch of backends in parallel
and then mixing the results were sending
it to web and to image into YouTube in
the maps and to news into various other
places well how would you implement this
so think for a moment about your
favorite language and how you would
actually implement this then I'll show
it to you and go 1.0 all right Google
search 1.0 let's define a couple types
let's say our result from a search
back-end is just a string obviously we
can define that to something fancier
later and a search a back-end search is
just a function that takes a query
string and returns a result all right so
let's create a couple fake stubs for web
searches for our searches so we have a
web search image search video search
they're all just fake searches that have
these various names and then our Google
function is going to take a query and
return a bunch of results in a slice and
here we're just going to issue these
requests in serial so we're going to
issue web image and video we're gonna
append them to this result slice in
return all fake search is doing is it's
taking some name for our fake search and
returning a search function so this is
showing off go has first-class functions
and closures I could say fake search
with kind string I can declare here a
closure using a function literal that
closes on that kind here and all this is
doing is sleeping for a random duration
and then returning the result string the
string that says you know web result for
some query in main let's start with a
random seed let's record our start time
time that now get our results return our
elapsed time time not since start this
is all standard time package methods
and functions rather well printer result
and printer elapsed time okay we got a
web result an image result in a video
results in 123 milliseconds we run again
under 54 milliseconds 163 Oh 33 we got a
fast result great Oh 213 bad luck this
does not beat the Google bar this is too
slow how do we go faster
well Google search I missed 2.0 I
skipped ahead to 2.1 let's invoke these
concurrently this is where I get we get
to show off the syntax I'm going to zoom
out just so I can flip back and forth a
bit and show you the difference keep
your eye on this ball right here where
I'm invoking web and query we're going
from invoking web image video like this
it's invoking it like this right where I
create a channel to receive 3 results I
say go and this is another little
closure invoke web and send this result
in this channel invoke image and video
then I'm going to loop three times
receive three results in a pendent to my
results back turn return the rest is
unchanged right I just changed this a
little bit here and what happened to our
performance eighty four milliseconds
fantastic notice the order is no longer
deterministic right because they're each
sleeping for a random time they could
take different times to respond and
therefore we're getting them in whatever
order they came back 79 milliseconds 80
6897 okay and the reason we're capped at
100 here is because my random sleep is
up to 100 here all right no locks no
condition variables and no callbacks I
find this code very easy to read with
experience you will too and in
particular think again about how you
would make this change in your favorite
language if it's not go Google search
2.2 we don't want to wait too long for
these results and you know let's let's
let's say that 80 milliseconds is as
long as you want to wait so again look
right here I'm going to flip back and
forth all I'm changing here is I'm
adding this timeout I'm using another
standard time package they
time after 80 milliseconds what that's
doing is it's returning a channel time
out as a channel and that channel is
going to emit a value after 80
milliseconds great so in my loop I'm
going to receive results and append on
the results just like I did before and
I'm gonna have another case of my select
which is did the timeout fire if so I'll
print timed out and return immediately
so this is capping my search to 80
milliseconds let's see
56 milliseconds 81 seconds Oh timed out
and we got a short result set right when
we video was too slow it didn't make the
bar we don't get it you can imagine
doing this for ads or various other
backends and you'll see that if as I go
along we get some timeouts sometimes we
get the results sometimes we're really
unlucky trying to get one which fires
the empty result it does happen every
now and then anyway alright but losing
results is bad right so how do we deal
with this problem
well we throw money at the problem is
how we do it however you boy time you
got two requests to slow backends we
replicate and we send requests to
multiple replicas and use the first
response let's see how that looks so
this is a different bit of code but with
some of the same types we've got a
resultant search type and I have this
new function called first first is going
to take a query string and any number of
reps urges as replicas now I've got a
new bit of new syntax here which is this
dot dot dot search that's our syntax for
very otic functions like printf right so
this is give me any number of searches
and inside this function that's just
available as a slice I can range over it
I can call land and cat land and so on
so what is first is doing is I'm
creating a channel of results as big as
the number of replicas I have a little
closure here which is search a replica
it takes you know the index I and issues
and invokes the query on search and MRI
and sends the results on a channel in my
loop I just fire off that number of go
routines one free triplica and then I
return the first result what about the
other girl routines well those other
global teams are going to go ahead and
do their job and they'll eventually
return and they'll dump their data in
this channel and when they're all done
there won't be any references to this
channel and
garbage collector I'll get it everything
will just clean up right that is one of
the reasons buffer channels are also
important is you want to make sure if
you're gonna teens do exit go doesn't
garbage like all I go routines they have
to exit on their own so you do have to
know when your functions are going to
stop right so now we can take this first
function and put it together with our
Google example all right so here's our
replicated back ends we've got web 1 web
2 image 1 image 2 and so on now look how
much our function changed not a whole
lot right we still have these three goes
so we're still certainly a channel and
just instead of saying web of query we
have first query web 1 web 2 and first
of this not a lot changed and if we run
this if I run this really there we go
all right here we got our results will
occasionally still see a time out but
for the most part you'll see we've
brought the latency tail and actually
forgot to show you earlier on the first
example that you could get quite fast
but you can see here we're seeing fewer
we have one here at 80 but we're seeing
fewer at the long tail and you can bring
your tail in this way by using my just
sending to the multiple backends the
really the point here is composition
that I define this first function and
it's just from the point of view of this
code it's just a regular function
something in votes synchronously I don't
have to know all the business that's
doing in the background I don't have to
know that it's got go routines and
channels going on and using this
parallelism and most go api's are
synchronous like you know here my Google
search blocks and returns these results
right the only exposed channels and
stuff if you need to mostly you want
simple API so our our PR if you look at
the ghost editor packages the RPC
interfaces and things like HTTP GET I'll
just block if you need asynchrony you
use concurrency primitives and this
makes your code simpler it really does
it really helps you deal with
concurrency in a very natural way all
right
there's a lot more to the language that
I'm that I haven't gone into as I said
I'm running off the go tour here and
this is all online at toward outgoing
org there are these other built-in types
arrays Maps and slices that give you
sort of common data structures and they
have a lot of nice primitives built in
struct an interface embedding is an
important feature this is sort of goes
answer to inheritance go doesn't have
classes and inheritance
it has types but a struct type can embed
another one and interfaces as well in
that essentially provides some automatic
delegation of the methods on that type
while still keeping their state separate
go see the go Docs for details on that
defer panic and recover this is really
the stuff around goes error handling
model you can within your function defer
a function to be valued when the
function exits a little bit like scope
stuff in C or C++ but it's really tied
to when the function exits and this is
how you might close a file or unlock a
mutex and that plays particularly well
with panic and recovery which in other
parts of the error-handling story and go
type switches and reflection go has
full-blown reflections and it also you
can as runtime type in for eight in
information you can look at you can ask
whether a particular value implements a
given type you can also have a switch
statement on that and that gives you
some new ways to program as well finally
it is the go tool which is really part
of the build system but it's also the
package fetching system it's really nice
try it download go I think you'll be
impressed with just how easy it is to
get get up and running some references
I'll leave these up going that order is
the home page the language spec is
surprisingly readable it's pretty short
actually and gives you a good sense of
how the language hangs together the
package documentation we did a lot of
work to try and make that very readable
the packages are pretty thorough but I
think each one is pretty easy to
understand on its own there are a couple
of nice code walks share memory about
communicating talks more about the
concurrency model first-class functions
talks about the function types and then
the blog has a lot of great articles in
particular one about defer panic and
recover and
thank you Samir can you flip back to 17
please certainly right so I go back yep
that's fine
the syntax for a slice his beginning
position length uh this syntax here no
go down two lines 17 and 18 yes so what
this is doing if I had said so that
begins at 0 for a length a length of a
divided by 2 entries yes ok I wasn't
well if it's either that or there's a
typo by one no no it's it's correct but
it's you're right the question is you
know is that the index or is it the like
yes yes I think it's actually the index
but it can't be the index because then
you would be double summing one of my
middle term way to tell because we have
code we can use it is uh type it in
right so if I say zero I don't get
anything right right yes well my comment
was simple it's either the length or
it's the two lines are inconsistent okay
hi so I think one of the biggest hurdles
to people switching to a new language is
always the availability of standard
libraries and other tools that they you
know currently they might be relying on
a huge array of Java libraries or
something else's what can you tell us
about the availability of libraries ago
at the moment and also what
interoperability if any there is with
other languages so in terms of
availability of libraries there is a
packaged dashboard which provides
information on the various packages
available and where I can try and find
that maybe after the after Q&amp;amp;A and in
terms of interoperability go works great
with see there's a Segoe a function that
allows you to interface with those
that's great for numerical libraries and
such internal interoperability with
other languages is a little harder
typically I end up doing things like RPC
but I don't know what sort of support
there is for swig and other sort of
interfacing typically you want to go
runtime to be able manage itself so you
know the talents as soon as you start
interfacing with other languages is that
they they want to have threads and
signals - thank you oh yes I made a
request for the Q&amp;amp;A session yes I'd like
ask two questions if I can
or the first is like if I have a program
that fires off a bunch of go routines
and they may be recursively fire off a
bunch of other go routines is deep up
what's your kind of pattern for
canceling all of them at once do you
have like a multicast channel or yeah so
cancellation you need to be explicit is
not it's not a language thing but
channels provide a lot a lot of help
there so you can have a channel that's
then possibly the same Channel I'll pass
down to everyone and then if when you're
not interesting or you can just close
the channel and that provides a simple
signal to everyone that if that channel
is closed okay it's select on that you
know just give up an exit if you don't
wanna use closed you do end up you'd
have to manage it a little more
explicitly about keeping track of how
many children you're creating at each
level in sending them a explicit closed
signal on a channel that may be better
in some cases to any what you're trying
to do okay I guess my second question is
a little harder from the estate I'm
gonna try though um let's say I was a
function that received a vertex as you
defined it and I just hand it off to
somebody else and I'm using one of these
method receives you talked about so am I
gonna get this this object and somehow
when I hand it to the next guy is he
gonna see my version of string rather
than the one I was handed your version
of strength well I was imagining I had
used a method receiver to like override
within the same program you'll both be
talking about the same type yes yeah
right so if he's using your vertex type
then you both agree that it's the vertex
type with that okay so right
if it's a a channel of interface types
right stringers right he'll still get
the right thing because you're sending
him that value and your vertex has your
string method has its string method and
receiver if he just knows he's getting
stringers you can call string on it and
it will dispatch properly to the vertex
matter yeah I was I guess I was a little
confused about the Cenex the the fact
that my stringer
you know definition was in my file does
that effect kind of the whole program or
does it affect sort of like I think I
know the question you're getting at you
the question is can you attach a method
to someone else's type yeah no you you
you can attach you touch methods to type
in your own package right so you know
the definition of a type is still local
but what you can do is this embedding
stuff which I haven't gotten into too
much so let me let me just skip back to
that to make a little clearer so here
I'm I'm just defining vertex and I'm
giving it a method I can't go and attach
a method to something defined and pumped
but what I can do if when we came up
with a better example say I have an
image to RGB value and want to talk to
the method is that I can't add something
image to already RGB directly so that
some third party can see that method but
I can to find my own type that embeds
image to RGB right and therefore will
get all of its methods and then I can
add my own method to top that wouldn't
override its methods as well yeah that's
quite helpful I think just if to make it
clearer for me like if there were like a
second file that was in package main
that tried to do what you have in lines
to 9 through 11 that's a compiler error
is what so that's if there were second
file that also did was package main that
also defined main yeah they'll be legal
but the main it defined this function in
Lorance 9 through 11 oh this is this one
here know if it's in the same package is
all compiled together if it's in the
same package and it's together right so
then you can distribute the package
definition over several files go goes
you know files really are just scoping
for your import statements and but you
could duplicate definition if in lines
and enter 11 appear twice in this bar if
it applies of course yeah yeah perfect
thank you oh right
I hash wag for those who ask questions I
forgot so thank you sorry do you have a
question you just want strike yes all of
a sudden we get more questions fantastic
I should take my kids because that Club
this question still go ahead - firstly I
really like the structure if you talk
gratulations just nice to have a
straight to the code kind of talk very
enjoyable yeah so my question is kind of
multi-pronged it's the core of what I
want to get at it is how much does
Google use go but sort of around that is
like and different people will say
different things on this but garbage
collector languages have a bit of a
stigma for the heart attack
and I've heard some people go on about
sea and sea based languages being the
best for web serving for that reason so
where is the I mean I think there's a
lot of sweet spots but a still garbage
collected so how much is it used and how
does that fit in with the garbage
collects illan questions I mean
certainly there are people inside and
outside of Google opera Hensen about
using garbage collected languages for
assistance program so the first question
of how much it's used in Google I can
only speak to it a bit the biggest sort
of we have a big use within YouTube as a
database proxy they've actually open
sourced their code so let me see if I
can pull that up it's a system called
Vitesse
and they are serving pretty much some
large fraction of YouTube's database
queries go through a go program right so
if it says scaling my sequel databases
for the web you can go look at the
source so they at least have managed to
make this work at scale garbage
collection is of course a challenge and
there's been a lot of work to improve
garbage collection speed one of the
critical things about goal is that it
gives you a fair amount of control of
our memory layout and so you can avoid
allocating in a lot of cases and that's
something you don't always have the
option to do another languages other
techniques for managing your garbage
like recycling also of course apply to
go
so you do need to be aware that got the
garbage collector in any run time as a
service and you can overload that
service so you can either tune the
service which you know they're working
to improve it and you can also reduce
the load and go gives you a fair amount
of control over that yeah it's way of
the convention or IR methods upper case
ah I didn't get into this so Rob Pike
had a great talk called public static
final void you'll notice none of this
yes none of those appear and go goes
visibility restrictions are based
entirely on whether your method starts
in uppercase or lowercase letter or type
or symbol yes everything's essentially a
package visibility like you would be
used to in Java within a package you
could see everything outside of the
package you can see things that have
exported names like capital string or
capital vertex this sounds odd it turns
out to be really nice it's you know your
brain starts to map that really fast and
it saves you a lot of typing so again
this is one of those try it and see it's
you know people people were upset about
pythons and pythons indentation which
came out we got over it pretty quick go
is one of those languages you really the
best way to know if you're gonna like it
is to try it and the tour is a good way
to get started or build something simple
go is one of those language that has
actually gotten smaller in my experience
over time that it's I make the
comparison to Edward Tufte ease
perspective on you know visual
information erase as much as you can and
leave what's essential
I think the go designers really did a
lot for that all right
I want to get a stack dump of a running
go program with a bunch of guru teens I
don't get it you call run time not stack
and in some package and it will put
everything all the lower teens yeah
actually I can even show off a bit of a
documentation because that's actually
you've given me a good opportunity here
so package documentation no this is
gonna get tiny isn't it alright I'll
zoom in package run time method stack
with a boolean all you want the one
you're in or do you want all of them oh
good then you set that to true thanks
that's stack doesn't take a writer
because it wants you to it wants us
buffer of a particular size yeah he was
asking what why doesn't take I or writer
I think it's also that even I'm
speculating here they probably didn't
want the runs a bagger depend on the IO
package right so you'd have to run to
find a run time dot writer which happens
to look the same as IO dot writer so
goes dependency model is strict and this
is important to have the fast build
times as well
no cyclic dependencies in packages but
interfaces are how you decouple right
but yes you do you will run into
something like this if it was important
to have sort of streaming stack traces
will just to find a you know an
interface for that here what's the
difference between parallelism and
concurrency oh yay good question
parallelism is things that happen at the
same time in real time concurrency is
things essentially that could happen at
the same time so the difference is if I
have I could have a single-threaded
program that's making a bunch of say web
requests right and how that's actually
executed is you know each of those
requests might you know write to the
socket and then yield to the next one
these are all go routines that are
executing and then the runtime will then
schedule you know each of them to resume
when their responses arrive and in a
sense the web requests
having really in parallel but the way I
program is purely concurrency right I
can write things that may not actually
happen really in parallel say that
parallel some that's only gonna be
really imperil if I have two CPUs to run
on if I will have a single CPU PLL some
will run serially but I don't have to
know that I just blew your mind
I know go isn't really intended for
embedded systems development but is that
something that it could be applied to in
future maybe with a restricted subset of
the language I don't know I don't have a
good answer
so repeat the question questions
it's go useful for embedded programming
or could it be a restricted subset well
yeah restricted subset I really I really
don't know I'm not it's it's hard for me
to for me an answer I mean right now go
works really well for servers the
embedded programming domain is different
set of constraints I'm not sure what
would get in the way but I'm not
familiar enough with the embedded domain
to be able to comment intelligently
about it I know the idea is to have a
debugger named ogle but when you're
writing packages for go you're typically
writing them and say see and using the
go findings now is there are there any
plans to create a a module or create
symbols for gdb to help with debugging
those packages
I think offline but I think we do we you
can use gdb with go it may be that you
have to use the GCC compiler instead of
the 6g compiler
just some housekeeping maybe last three
last four questions last five questions
I'm in the back that six and then we'll
know you said I'm a threat could have
multiple go routines is it possible for
a go routine how do you is it possible
to preempt a go routine with what some
like you were gonna ask two different
questions well undergo routine BR
multiple threads and the interests no no
no weather because they're multiple go
routines in a thread how do you prevent
birds think the cursor the current
implementation is a cooperative
scheduler but the language doesn't
constrain to that so you could instead
have a pre-emptive scheduler right so
you need to write your code as though
you could be preempted current
implementation is cooperatives your go
routine will run until it blocks or
yields or something how would you get
preemption we do need some sort of
operating system support well you could
I would have to speculate on the details
of how that could actually work yeah all
right question about the syntax could
you explain the lack of line terminating
semicolons and the importance of
whitespace ah sure
essentially semicolons can be implicit
with our new lines okay so like in the
for loop you saw I did have semicolons
separating it there and you can have
semicolons at the end of lines you can
just omit them there employment are
there potential like in the case of
JavaScript any pitfalls I'm not sure
what pitfalls you're referring to
returns breaks and continues not
typically no I mean I can screw with the
indentation stuff and things still work
but uh it's one cut so I put this there
are no pitfalls around whitespace but go
does provide standard formatting there's
a go foam to tool that formats go
programs in a standard way
and that is
that's part of sort of the buildin
written run sorry it's part of the
environment of building build programs
is one of the things that helps a get
rid of a lot of confusion and annoying
it's about style because they at least
remove sort of the consistency question
what's a like consistent formatting of
how you former a program and be it Meeks
means that programs that tools that
manipulate programs like there's a go
fix tool that helps for people to new
api's that can work with minimal
disruption to your program thank you
well I should have two questions one is
regarding in the example when you pass
an object through this channel right to
pass really the value it mean you're
civilizing and this you're right on the
other end or you really pass a point or
within your own time you are passing the
value but so often what you might do is
actually pass a pointer so go has
pointers I didn't really go into that
here so you could actually pass you pass
a pointer down the channel if you wanted
to pass something they live has a
pointer okay and I are still excessive
within still within the same scope
shared memory yeah so you can just let
you can easily mess that up they go to
the language doesn't prevent you from
doing that though I still have to use
amnio taxi stands for to ensure enoksen
its convention is that when you pass
someone a pointer or something of our
channel you're transferring ownership
and it's very easy not to make that
mistake if you really want to like
spread ownership I'll often what you're
doing is you're constructing these
things from the same value right if you
when I have a knob value that's truly
shared right so you have to know whether
you're transferring ownership or you're
sharing ownership when you program a
second question is you know you know in
the web us on Wikipedia also described
this is this a CSP kind of parent Harold
on it sort of like a deal of this active
object active object actor actor you
know like an actor right yeah yeah
you're like in the a CEO framework they
have this active object kind of actor
they have a class called actor
so actor really take full control of
these all these asynchronous processing
and so what do you think of this
approach and cons of is to approach it
other than program is
please sit I don't have a lot of
experience using the actor model myself
I know it's pretty popular
I think Scala and Erlang are both actor
based languages and they've certainly
gained in popularity I'm going to talk
about what I think I know about the
actor model and you can tell me if I'm
wrong which is that essentially an actor
has a set of messages it can receive
actions based on those messages and it
can spawn some finite number of new
actors and some point find a number of
new messages in a sense what you've done
is said that information you know you've
got these concurrently executing actors
and they're communicating by passing
messages but you've lost sort of the
fact that you have exploit these
explicit channels that can be say shared
among many centers and receivers you'd
have to model that as a separate actor
presumably right and go has certain
other things like I can pass a channel
over a channel and this is really useful
in request/response protocols right I
have some goroutine that's a server of
some data right and I'm sending it a
request with some parameters and I'm
sending it a channel on which it'll send
the response this is very much analogous
to what you do in a distributed system
when sending an RPC I send the RPC and I
expect the response back on my channel
oh my stalker so go lets you build
programs like that I don't know how easy
it is to do that in actors I also never
had it say inherit from actor in my
program I just said go hey honestly I'm
not familiar enough deeply with the
actor programming I haven't programmed
with an actor framework so I can't
comment well on the distinction but you
know for me I find that Keira channels
and go routines actually let you build a
lot of different kinds of concurrency
arrangements well I'm sure actor does
too but I don't know if it comes as
naturally it just seems to me that you
know it people whenever there is a
simply snow program in people there is a
very the flipside of the simplicity is
it tend to be abused so it seems to me
we can easily create tons of coal
routines and I think the wrong hands
still have to flip through this logical
unit so you can't we'll do some
localities or something that could be
done more optimal if you write more code
you can write simple code
but somehow you lose some kind of
control that's certainly a trade-off
right it's certainly a true goroutines
encourage you to write you know seal
code simple code but for example in my
parallel sum if I had done it sort of
like merge sort and split and split and
split until I had just two things to
someone I sum them together and I sum of
those two again you're right I would
have had you know however many number of
go routines you know recursively summing
this thing and then merging them all
passing that Oliver channels that's a
lot of overhead to do something I can do
as a straight line loop so you do have
to be intelligent about how you split up
your problems now where I find that I'm
introducing a goroutine is primarily
when I start needing a select when I
have some thread of execution that needs
to take two different kinds of inputs
say requests and at a time ticker or it
needs to manage requests to some byte
set of backends and requests from
clients like I have I tend to end up
structuring my goal programs a lot like
small distributed systems but they hang
together really nicely right because
I've got type checking throughout I know
that it's gonna hook hold together and
it's very easy to reason about that code
so yes you have to be careful about how
you structure your program and you know
not overuse these concurrency primitives
I certainly did at the beginning when I
first are playing with the go I was
channel crazy I wanted to use it for
everything I swear I had to relearn that
okay there's a trade-off between when
you want to use these primitives and
when you don't I do a lot of programs
that you do a lot of i/o so clearly if
we're gonna have something that's gonna
block an i/o throw it in a girl routine
so I can get on with our work right if
you're doing CPU bound stuff you have to
be careful and you have to think about
how you're just ripping a work over your
CPUs to the extent that you don't want
to part it you want to create reasonable
chunks of work so that then you get
those scheduling you know the
opportunity to scheduler that's me I
think there's opportunity for sort of
research that are in the future which is
how do we automatically break up a
problem using this and I think a
language like go is a good substrate on
which to do investigations of that kind
hi so shared memory is really nice and
convenient what kinds of primitives or
library support is go currently have for
distributed memory programming
I mean distribute memory like message
passing interview mean multiple
processes on the same machine or just in
just separate separate nodes you know
like like I've got my MPI program and I
want to port it okay there used to be a
net chain package which provided a
channel abstraction to the network and
Rob wasn't happy with it so I think he
plans to look at this again because so
you know obviously there's like RPC
packages and stuff but those aren't
really getting where you're talking
about the fundamental thing you'd like
to have is the ability to say pass a
channel over a channel and the receiver
is on a different machine and when it
writes to the channel I gave it it comes
back to me right and just looks
transparently yeah that doesn't exist
yet right but it's certainly one of
those things where we're very interested
in making it work and work well because
we think it can give you a new way to
program distributive systems in a really
nice way okay which is more around
direction having used the software where
one or two key things do you think it's
missing what's coming up next in the
next revision you talked about goal one
and and then kind of the release cycle
there people could see from that um goal
one is intended to be stable for some
time I don't think the language is gonna
change a lot for at least a year or two
you know certainly the biggest ask from
people in the community is where are the
generics and I'll refer you to all the
discussions there off both in the FAQ
and in the discussion groups because
it's been discussed extensively is that
something that you want to see in the in
the language I have been very productive
with the language as it stands right
writing infrastructure within Google so
I certainly I'm happy with it you know
there are cases where I could imagine
introducing a generic type but often I
found I don't need it and so I think the
focus should be right now on being
productive with the language it stands
and using that to identify what's any
deficiencies that are there right and in
particular with running and using
programs on the language running them in
production you know obviously garbage
collection is a concern that many people
share so before the language changes
more we want to see how well it runs
right and see if it really generalizes
the way we think it does
thank you thanks everybody</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>