<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Drop-in JavaScript Performance | Coder Coacher - Coaching Coders</title><meta content="Drop-in JavaScript Performance - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Drop-in JavaScript Performance</b></h2><h5 class="post__date">2009-02-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bsad6dr8Kzo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm very excited to have John Rezac here
today he lives in Boston but works for
Mozilla so everyone's well he's out here
and I asked him a few months ago to let
me know when he was coming out so we
could get him to come to Google and do a
tech talk for people who don't know John
is the creator of jQuery he works at
Mozilla as a javascript evangelist he's
an author he wrote pro JavaScript
techniques and now he's working on
secrets of the JavaScript ninja and
everyone's while I get these basking in
the warm glow moments at conferences
because I'm surrounded by people like
John who are at the forefront of web
development today and you can really see
how much they're personally putting into
the work that they do and so in addition
to his work with Mozilla and firefox and
jquery John also works on fire bug is
pretty much leading the Mozilla
contributions to Firebug he I think just
is fire unit released fire unit just
came out and so we're all in good hands
with people like John in the lead so
John I wanted to present you with this
bag of Google goodies thank you okay and
then I'll take that away from you so you
don't have to hold it and without any
further ado please help me welcome John
Reza
so I want to thank you all for coming
out today I really appreciate it so I
wanted to talk about a couple things
today specifically I wanted to talk
about pretty much all the new things
that are coming in browsers in the the
latest releases abroad and wanted to
look at all the performance improvements
especially related to JavaScript and the
DOM and all the new AP is that are
starting to land I'll trickle down from
like html5 and new w3c specs so a lot of
my time lately at least with Mozilla has
been spent working on this performance
suite called Romeo and this is a test
suite for doing a performance analysis
on JavaScript and Dom within a browser
and doing this has really opened my eyes
to the issues that browser developers
and nail implementers face when they
deal with all these you know minutiae in
these api's so it's really i find to be
really interesting so I wanted to talk
about some of the upcoming browsers here
that are on their way out and should be
you know hitting the streets here
relatively soon so there's Firefox a 3-1
it's coming out here in just a little
bit and sprite for I ate opera 10 and
then the next release of chrome but the
big thing that is common amongst all
these browsers is that they are all
actively iterating and rapidly improving
their performance and this is this is
really huge it's really exciting it's a
great time to be developing so I wanted
to just quickly draw through some of the
new big things that are going to be in
these browsers coming up and as I talk
about some of these api's please if you
have a question raise your hand so we
can cover a little bit more in depth but
um so far walks 31 it's currently
scheduled
coming out here pretty soon beta 3 is
going to be coming out I think within
just next couple weeks and but a lot of
big things is that it's going to be much
much faster for our prog 3 there's a
whole new JavaScript engine landing
there's the new video and audio tags but
just been in the news recently and a
private browsing private browsing is
another feature that's sort of just all
browsers are implementing it pretty much
simultaneously now Safari form the
actual release date isn't quite public
yet but it's pretty much assumed that
has to be coming out whenever 10.6 comes
out big things are that it's going to be
completely asset 3 compliant it's going
to be much much faster even faster than
before and it's going to have this new
concept of being able to deploy web
applications to your desktop you can
show it a little menu up here where you
can now do a save as web application it
can take a web page and save it to your
desktop and then load it up again and
sort of quasi offline mode a lot of this
is going to be made possible by the new
html5 offline a portion of the
specification and that's a really great
in and of itself ie8 is uh this one is
also coming out here real soon they just
released the new release candidate but
even while the performance of I ate
doesn't really say compared to you know
what's happening in firefox and chrome
and WebKit it's a dramatically faster
than their previous release value 7 and
at the same time they are now doing what
what's called a process per tab and this
in chrome as well but the the concept
that each individual tab is running in a
separate process rather than in a thread
like what happens in of in Firefox and a
WebKit or Safari look yes
okay so the question was is when Steve
looked at it looked like it was two
processes one for Chrome one for all
tabs I'm not sure exactly at least from
what Microsoft has said that they were
splitting it up maybe by splitting up
was only splitting twice I know at least
within the case of Chrome it's
definitely split per tab so yeah I would
not be surprised as only split twice
I'll pretend the release date for
opportune isn't solid yet they haven't
made any big announcements a beta just
came out recently another big they are
as well are sitting for full s3
compliance and a video and audio tag
amongst some other api's and hopefully a
new UI skin as well and then Google
Chrome sure everyone here is well
familiar with it but as the new release
here's should be coming out relatively
soon but the big things the big thing
that it really popularized was this
process per tab and this has really
helped to change how developers are able
to look at web applications because
right now browsers generally these they
have everything in just a single process
everything each you know tab is split up
amongst multiple threads and they're all
handling different things one might be
handling rendering or doing networking
or in the problem with that is there's a
tendency for a lot of coalition to occur
and if one tab is slowing down consuming
a lot of resources one page is consuming
a lot of resources your other tabs will
be blocked so with this new process per
tab model you start to confine
everything extremely so what you end up
having to do is you sacrifice memory of
for the benefit of performance
um but the so at the very least it's
it's resulting in some you can wants
really heavy-duty web applications
without interfering with whatever else
is going on one thing that I really
liked about chrome though was the fact
that you could monitor each individual
tab and see how much memory and
resources each tab was consuming they
included this this view is almost like a
windows task manager but within chrome
itself and that that was very
eye-opening because most of web
developers have no idea how much their
website of what their web sites are
actually you know affecting the outside
world you know they have no idea if
their websites you know met you know
considering forty megabytes of RAM or
you know 140 and it's really important
to know that if you want to do something
a web application that is actually going
to be deployed you know widely a couple
of other changes that happen here with
chrome and they changed it such that
timers can now run at rates faster than
normal I know Mike Bell she is here and
he is uh he was responsible for this and
but this is very interesting because
typically browsers have a floor for how
quickly a timer can run it's usually
around 13 milliseconds or so how quickly
it can be called over and over again
what that means is that it's limiting
the number of times let's say your frame
rate for an animation or you know number
times to query a particular object or
what have you but what happened is is
that now that they've moved into a
process per tab model you can now give
it to have the ability to just check as
frequently as a nice or update the page
frequently as it needs to and without
fear of it blocking the resources of the
other tabs so this is really nice
because now you can get insanely high
frame rates in in in chrome for example
and where you can just do animations at
you know many hundreds of our frames per
second
which is really quite exciting so I
wanted to talk a little bit about the
new JavaScript engines so there's three
new JavaScript engines that are coming
out here in our various stages of
release in WebKit WebKit safari and
firefox and chrome and they're so
Firefox has oh well I just say that all
of them are competing very very heavily
at this point but this is a really
fantastic in my opinion because when
these browser vendors all compete and
all try to one-up each other and for a
performance the end result is that users
just get a better experience the users
you have the pay their users the pages
load faster yet developers their
applications will run faster you know
everyone wins so it's really great I
hope they keep battling it out
indefinitely but all these engines have
a couple common features at this point
they all have virtual machines of some
sort so that they can run some sort of
optimized bytecode a representation of
the JavaScript and additionally they
also almost all at this point do some
sort of shaping so looking at objects to
determine their general feel and
structure and being able to do a be able
to do things based upon that so here's
this a sort of rough structure of how
the engines currently break down I mean
when you write your JavaScript code you
end up having to you it ends up going
through multiple steps before finally
and eventually executing but um the
result is though is that when these
engines are breaking down into this
lower you know bytecode layer they're
able to optimize their engines much more
dramatically and you know make tweaks
that just unleash performance
I wanted to talk about this a little bit
because I just a given example here in
just my pseudo bytecode this is not one
hundred percent accurate just getting an
idea so like if you have a very simple
operation you know adding two variables
together the problem is that in
JavaScript there is a lot of ambiguity
you know when you add two variables
together you may be concatenated if one
of them is string or you know if their
numbers if they're both numbers then
you'll be adding them so and you need to
like underneath the hood all these
options are you know all these checks
are occurring I was checking if each
variable is a string and if so can
counting them together if it's neither
number string then it's going to add
them together and then within each
concatenate there's a whole other set of
options that have to be executed but the
nice thing is that they're starting to
do some optimization here so what what's
ruffa college shaping so that they can
determine if an object is uh you know if
it looks like a string and if it
probably is a string that make some
assumptions and remove some of these
checks so like even even here so like if
we were trying to get the the method
property of of an object there are a
huge number of checks that have to be
done simply before we can even get the
the property and that's even before
actually executing it but if we if we do
some sort of shaping what all this code
ends up boiling down to a simple you
know couple pieces of by code operation
rather than you know dozens and dozens
execution jutta just 2x just to access a
single property so all of this
optimization is dramatically improving
the performance of of web pages and
honest n on test weeds so just wanted to
talk about a little bit about some of
the engines in particular there is a
trace monkey this is the new engine
release by Mozilla replacing the old
engine
spider monkey it's a variation of spider
monkey and this one is uses what was
called tracing technology to optimize
commonly repeating patterns like things
that happened again and again so for
example if you had some loop that was
iterating a thousand times and it was
calling some function within that loop
what it might do is remove some of the
costly byte code checks they need to
occur and that making sure that you know
that a for example the letter you know
the variable I making it's probably
going to continue to be a number
throughout the lifespan of this loop so
removing is you know just making
assumptions assuming that I is going to
remain a number that you know optimizing
adding one to the letter to the variable
I you know all of these things and so
that when these loops start to occur and
when it starts to go through and iterate
back and forth back and forth it can
start to remove that and optimize it
down especially within lining some of
the function calls so taking these
external functions pulling the code out
of them and essentially in line them
into a single blog so that way it ends
up being just so much faster you know a
empty loop I remember seeing some
numbers for that an empty loop running
in trace monkey was comparable to the
other end googling and see of course
that means pretty much nothing since
you're just doing a nap you loop but the
important part here is that it's trying
to strip away as much extraneous stuff
as possible which is really good so
squirrel fish um the the WebKit team did
all sorts of work to get good
just-in-time compilation working for
their JavaScript engine and they did a
lot of work on their under bytecode and
optimizing their by code and you can
especially see this in there and the
performance on regular expressions the
regular expression performance is is
pretty much insane and they visited all
sorts of optimization there and making
that fast and then a chrome VA they
uh in this and their engine they did a
lot of work in doing more shaping which
I talked about earlier but that allowed
them to do just really fast our property
look up some objects is it's really
quite impressive when it was released so
there's a lot of difficulty in trying to
get an accurate measure of performance
trying to understand what exactly makes
a piece of job you know peace javascript
code accurate and representative of
JavaScript code as a whole and
especially so what you know that you
know does optimizing for this piece of
code will it actually help users so
there are a couple test Suites right now
each release by the different vendors
and there's the the SunSpider test suite
released by web kit that includes a
number of different tests for testing
pure JavaScript the v8 benchmark which
is released at the same time as v8 that
also includes a number of pure
JavaScript tests then the drumeo tests
that I wrote and release and this one
contains a mix of JavaScript tests and
Dom test and it actually includes both
the SunSpider and v8 benchmarks as well
just shows some some numbers these are
outdated at this point I don't think it
would be possible to give you numbers
that were even up to date since
everything changes every single night
but the important part here is that the
waveform performance of all browsers
used to be like ie7 level of performance
and like I mean if you look at the
difference between these couple browsers
on the left it's miniscule in comparison
um I think yeah I think these numbers
actually a couple months out of date at
this point but the I mean everything is
just gotten so dramatically faster in
the last couple months even that it's
it's really just blowing away so this is
on the chrome benchmark you it's not
completely clear if the the chrome guys
just happen to be really really good at
the benchmark or if they optimized for
the benchmark but regardless they do
really good on their benchmark
and then on drumeo as well in this one
again this one tests the mixture of
JavaScript and Dom alright so I wanted
to talk about some of the new
improvements that are coming outside of
JavaScript engines in particular Steve
suitors released a sitting right there
released an excellent tool for helping
browser developers determine what
exactly is going on at the four aneta
for loading items over the network and
browsers and it is a UAE tool provide
the URL there but this is a rough
breakdown of the number of features yeah
he breaks it down into a number of
different categories which I'll go to
here in a second and shows how well each
browser passes that for example for
simultaneous connections some meaning
that if you have a number of images in
your page how many you know images can
be downloaded simultaneously so the
number the higher that number is you
know theoretically the faster or page is
going to be able to load and you can see
the the steps and improvement here so
older browsers firefox to ie6 ie7 they
all have a maximum connection number of
two but as browsers you know start to
increase here you see it goes up to four
and Safari and then other browsers new
firefox 3 and opera all have six to
seven connections simultaneous
connections and i should say somewhat
Stanek that simultaneous connections per
domain a maximum number of connections
is so that you know if you have images
being loaded from multiple domains you
know how many can you be doing at a time
and that that's really high so we're
talking anywhere from 25 to 60
simultaneous connections another big
thing is being able to download scripts
and parallel so that if you have two
scripts on up
and you know they both take you know 200
milliseconds to download over the
network that it won't take 400 seconds
total instead it will just take 200
seconds early started 200 milliseconds
since they downloaded the simultaneously
and then execute back-to-back there's
another thing that's starting to be
implemented more widely there's the
scald the first script and this is good
actually give me an ow Firefox 31 it's
an internet explorer and it's also an
opera and it allows you to say that that
given this script to load it you know
asynchronously then execute it again you
know at a later time it doesn't matter
when the script executes but
additionally there's some properties of
a deferred script like it can still
document right and when to document
right still does it in the correct
location in the document things like
that so but when browsers start to
implement this you're going to be able
to put this to first script on things
like ads and the ads will be loaded you
know will be deferred loaded and then
inject into the document you know when
they're finished loading as opposed to
blocking the entire document load
another big thing is that our browser is
getting better at is a redirect caching
so every time you access a website if
there are redirects occur from you know
adding in slashes are going to a
different document page this can you
know it adds up it's another network
requests and some browsers are getting a
better that's like chrome and firefox
they're cashing these redirects so they
don't have to be done over and over
again it's it's it's a tiny is it seems
really tiny but it's little things like
this that really add up and optimizing
these and fixing them can really improve
the performance of a web application so
this is a nice thing to link prefetching
and it allows you to preload resources
on your site so that you can say you
know that at some point later on I'm
going to use this image you know you
tell me the browser that load this ahead
of time so that the user doesn't have to
watch it yeah load whenever I cross in
so this is something relatively new and
right now it's only implemented in
Firefox but it's it's generally a much
better way of managing this as opposed
to having good to go through JavaScript
and use using javascript to manage all
this downloading and prefetching in the
background alright any questions before
I keep going on yes so my question was
how is the poor performance of
JavaScript parse time increased so right
now the test Suites I should say so out
of the different tests we it's currently
only SunSpider tests parse time but they
don't test it separate from actual
execution time it's all clumped together
so it's the currently totally no sweet
analyze just parse time versus the total
you know execution time that is
absolutely something that should be
analyzed since you have that affects the
initial load you want to make sure that
you know when that first hit occurs he
got 200k a JavaScript that you know get
sparse really fast so it's not
completely clear what the best way is
analyzing that are simply because it's
not something that can prob that can be
easily done in a browser context you
might have to move to a command-line
context and at that point you know if
you're measuring on the command line you
know is that really a realistic test
since you're not in a browser anymore
it's there's a lot of questions but I
you great there's not a good test their
yeah yes
execution and unable to cash those jets
so that the page so it is repeated so is
this you know jetting this it you know
slow down this initial load arm and yeah
this is cast so but in my experience
looking at the numbers the the gitam did
not significantly slow down a
performance at least not in a way that
the browser vendors concerned about
because ultimately wins much much more
later on but the as far as caching as I
understand it the most cash within a
page but not from page to page you know
it once you leave a page you're pretty
much done it depends how much sharing of
a you know execution context there is
simply because you know I guess that
might be a case where you know the a
threaded environment might work better
since they could all don't know what's
going on with other processes yeah so
that so that's another question is you
know if you're polling and obviously
something that's obviously an identical
piece of code every single time you know
Jake were your dojo Yui you know it's um
you know if there was a way to send down
there's a straight bytecode you know to
say hey here's the lowest level you can
get but at the same time that would
require that all the browsers haunting
you standardized in a single byte code
and having a hundred of time
standardizing on JavaScript so I mean
we'll see
I I couldn't say I wouldn't feel
comfortable giving a good estimate um
until I had good data I mean at least
you know this part time is you know at
least right now at best it's clumped in
with execution so yeah so the question
was you know if it's found out that no
part time is a significant burden you
know that that's something that should
be optimized you know I I assume that if
there if some solid numbers come out for
all the major JavaScript engines you
better believe that you know the
browsers are going to be working to
optimize that number four for developers
I'm not sure I mean it again that that's
another case where a better tooling
would help you know to answer those
questions yes
could you repeat the question for the
remote sites yeah yeah well when he's
done
okay so just repeat so the vest at this
point with the new engines the vast
majority of time isn't spent parsing in
fact very little time spent parsing and
that these new engines are trying to be
as just fundamentally lazy as possible
to try and break parsing out later and
worry about everything later and so I
mean there may be an initial hit but it
definitely isn't a you know a massive
hit at least not comparing to comparison
to old engines
so just that uh that you know it yet
right so the initial parsing and you
know it in and you know enchanting it
isn't a free but you know the ultimate
when you get is you know I'm pretty
awesome so okay questions all right all
right so I want to talk a little bit
about the communication layer some new
communication api's that are landing um
one the once is actually being
implemented quite widely is a post
message this method allows you to it
exists on a windows and allows you to
communicate a from a wind one window to
another so like from a page to an iframe
oh you know I frame to a parent page
from yo things of that nature but what's
so good about it is that it works
cross-domain it doesn't matter you know
if the frames are owned by different
domains so for example if you had an
iframe endure page you can send it a
text message you know test or what have
you and a URL the URL specifies you're
saying send this message to this iframe
only if you know it matches this this
URL the the iframe then would then
listen for messages that get passed into
it from post message and so listens for
a message event and then verifies the
origin of the incoming message you'll
make sure that the message is coming
from a domain that it trusts and if not
you know just stops doing whatever it
was going to do but otherwise you know
use the data that's coming in so using
using post message you can implement all
sorts of interesting things in some
personal experiments of mind I've used
post message to implement you know a
cross-domain xmlhttprequest because you
just insert a little iframe you start
doing communication back and forth and
it becomes you know very usable so if
this is I think a very interesting new
API there's there's there's true cross
domain xmlhttprequest this is using the
w3c act
control api and if on so what we do is
you use xml HTTP requests as normal and
you try to request a remote document it
verifies if certain headers are in place
that will allow this Pat you know a
piece of you know XML HTML what have you
to be requested so in the case of the
access control you can specify for
example access control allow origin and
then you can specify a single URL so say
you know only allow things to come from
google only a lot requests to come from
google or in this case star over our
requests that come from everywhere and
you can even really ill filter down this
way so what's interesting is that this
do access control specification is
starting to be used like everywhere
within you know within the
specifications that within html5 and
it's very likely that or there's still a
bit i should say over whether or not
this should be specified for like audio
and video tags so that if you want to
include a remote video that it doesn't
have to have these headers to allow you
to access that video it's not really
clear at this point so yeah this is this
this is the response header correct so
in this case yeah if you had a HTML page
on remote domain and you tacked on that
extra header you would be able to add
any any browser that supported this
pasta main xhr would be able to request
it there's some decent improvements
coming in Dom navigation one of the
early ones the land was a get elements
by class name you know allowing you to
find all sorts of you know find elements
on page that have a specified class this
is in some current browser Safari 31
firefox 3 and upper 96 we just found a
bug just the other day and operas
implementation it's unable to find
actually this example here doesn't work
496 it's not able to find the second
class in a class name for whatever
reason they can only find the first one
so yeah it's still work in progress yeah
but at the very least it's very fast
it's way way faster just to show you so
like on the left on the right here we
have some old-school methods just pure
JavaScript Dom we have an XPath
invitation but then there's the native
get a little class name and it's a tiny
tiny fraction of the normal cost and so
because of that you know JavaScript
frameworks that take advantage of it are
instantly sped up and you know using in
your code is it's a huge win one of the
things I'm really excited about now is
the new selectors API this is the w3c
specification selectors api
specification and it gives you new
methods for finding elements on a page
using CSS selectors and so it is good
because you get the best of both worlds
you get an intuitive syntax you know
developers already familiar with CSS
rules you know for how they match
elements and you know at the same time
you get this you know crazy crazy speed
hey but i'm really excited by the fact
that it's everyone's implementing it
it's implemented ie8 upper ten it's
going to be in Firefox 31 and safari for
it's it's it's everywhere I'm really
excited by that this is show you some
performance on the left here we have
some traditional JavaScript libraries
that are just using regular you know
JavaScript queer JavaScript on and then
the right is no query selector all and
it's a tenth you know take it's ten
times faster than the next closest
library of course all the libraries now
or adopting query selector all since it
makes a ton of sense too so that's going
to be really great one of the new ones
specifications that are that's just
finishing off and starting to land in
browsers it's called the traversal API
this is again this is a w3c
vacation it's implemented in Firefox 31
but it gives you a couple methods that
you can use to make navigating around a
dom document easier roughly it makes it
so that you can access element siblings
and because traditionally if there's if
you accessing a first child or last
powder you know what have you you'll get
you can get a comment node you can get a
text node you get any number of these
things and when a lot of the time
developers just want to get the elements
that are there since that that's what's
usually what's visible so those four
things are in specification they just
landed in Firefox 31 but one of the
things that's unrelated to that
specification um is dot children this
was something that was originally an
internet explorer but it is it is now
implemented in every browser every
browser now implement and allows you to
get only the child elements of a parent
element and so in a lot of ways you know
having got children around kind of
removes the need for this new
specification but the nice thing is that
in Firefox 31 they actually implement
not children so now it'll be absolutely
everywhere all right so drag and drop
there's uh some browsers are actually
starting to implement the html5 style of
drag and drop there's you get all sorts
of messages to indicate events to
indicate when dragging is occurring
starting and stopping and you can you
can hook into this and transfer data
from you know different points in the
document it's pretty cool and something
that really should have been done a long
time ago so we're starting to see this
now start to land and browsers but in
the meantime we're kind of stuck since
not everyone implements yet but in the
meantime we can use a get bounding
client wrecked this is a method that is
starting to get implement amor this is
an internet explorer method historically
and starting to get implemented more in
more browsers and what allows you to do
is
to find get a pretty accurate
representation of the position of an
element in a document and when you're
doing drag and drop you need to
determine pretty accurately where that
element is currently located so that you
can move it accurately and so that you
can position it well and so this is you
it's really fast and it's starting to
get implemented more which is awesome
another great thing that's that I'm
really excited about is the inclusion of
threading in JavaScript this is just
starting to come out here and it's
really really exciting to see this land
so what would what is this call it is
called um it's called a web workers and
it's not threading in the true sense but
what you can do is you can spawn scripts
that can run in the background and you
can communicate with them uh and you
know i'm using a message passing so just
to show you a simple example here we
have a script being loaded in externally
so in this case and loads into my worker
javascript file and execute in the
background then at the same time
whenever that whenever the worker is
done executing a message will get past
back to the on message call back so that
you so you can start to communicate back
and forth with these scripts that are
getting loaded in these workers just
wanted to show an example so this is
done uh by Oliver hunt he's on the
WebKit squirrel fish team and he built a
ray tracer in JavaScript so I want to
disable this so right now is it's using
the canvas element to draw if we run
this we can see it truck along this so
this is just you know regular JavaScript
communicating with canvas you know doing
all the calculation and drawing
everything out it takes it takes a while
it is even even in this right here this
is a
Safari nightly um I mean it's still
going to take I'd say about you know 15
20 seconds to run so once that finishes
okay 27 seconds alright so let's reload
and let's add in a couple worker threads
so what that's going to do is going to
break apart different portions of the
image to render send it to each of the
workers and then when they're done it
will report back and draw them so let's
run this now there we go now all the
worker threads is to it and it in three
and a half seconds so almost ten times
faster and that was where the only
before worker threads we could probably
up that a little bit figure figure out a
sweet spot so what I don't know it was
asking is it because of a set timeout or
something not sure I i'm not i'm not
sure what the like i was talking before
about his implementation about why you
know uh I guess I hear I guess we could
go down to one worker thread why we
can't really see it that's not exciting
hand so yeah my guess maybe just the
other implementation here was just bad
maybe but I mean but so even so using
one worker thread you know it took six
and a half seconds for border threads
was able to speed it up to you know
three and a half so I mean there's
there's a definite room for speed up
their unfortunate there are a lot of
gotchas with this new worker thread
stuff one a bit which is that when you
pass messages to one of these workers it
has to be as a string a nice thing
though is I'm glad they'd started to do
this so that if you pass in a JavaScript
object it'll serialize it as JSON and
then deserialize it again so the
important thing here is that you the one
make sure that they're you know
there could be no information leak you
know it no no access to external you
know windows or you know anything that
an inner threat shouldn't have access to
and additionally these inner threads
have a really limited existence let's
say you think they only have access to
basic JavaScript they don't have access
to the Dom they don't have access to
canvas they don't have access to any of
this stuff so in the case of these these
threads here what's really happening is
the pride is pushing around you know
matrices of numbers um and then the the
main thread the one in the window is
just you know is the one that's actually
doing the rendering to the canvas so I
hope I definitely hope that some at some
point will be able to pass around a
canvas objects you know as a canvas
object to a thread a worker and then I
have to come back with us some results
that'd be really awesome any questions
on the worker thread stuff okay so there
are a lot of different I guess CSS
related things that have started to get
implemented and these are differences
stylings and effects you can apply to
your site but the while they don't
provide you know an immediate obvious
you know JavaScript the performance
boost what what they do is the allow you
to dramatically simplify your markup and
remove all sorts of you know Croft the
you won't have to deal with anymore one
of the popular ones is one once I was
implemented really early was the ability
to do rounded corners traditionally in
order to do rounded corners either
required loading in extra images to
represent the corners or doing all sorts
of really nasty hacks or lots of little
dibs you know being spaced around and in
either way the old methods were not good
but with the new CSS properties you can
just add in quarters
as part of the stylesheet there's also
the concept of shadows both having
shadows on text so a drop shadow but
being able to have shadows around
arbitrary elements so you know if you
have a div that's supposed to be
hovering somewhere on the page you can
actually put a drop shadow behind it now
and how you give that extra appearance
and this is implemented both are not
WebKit in Firefox so I'm going to show
I'll jump back to the examples here in
real quick but the there's also the
ability to load in custom fonts so right
now most solutions for loading and fonts
are usually you know flash base like a
sort of like there's a zipper and other
ones that nature and they load in a font
file and render it in a flash context
but what's starting to happen is
actually getting some good fonts custom
font support in CSS we say oh and then
before I jump to the demo the there's
also new transformations and animations
starting to land so WebKit has been
really pushing forward here starting to
land all sorts of new ways to do
animations from CSS so no JavaScript
involved whatsoever and it's really
quite exciting so let me show some of
these demos here this is example of the
box shadow so these are just normal
little divs you know you can resize it
and the shadows persist and these are
all dis styled with this box shadow
property here we have text shadow so
this guy made a hilarious demo page of
things that you should not do a tech
shadow and so he animated the text
shadows and so added a fire style I like
that one and then you know he showed all
sorts of ways you know using shadows you
can get things that look like they've
been you know embossed or things of that
nature
there's also the concept of
transformations so in this case these
are set to animate when I move my mouse
over a fence start to transform an
element so it transformed by position
this is all CSS there's no JavaScript
rotate grow in size and then you can
also combine properties so in this case
it's actually animating rounded-corners
color and size all the same time yes so
it can get pretty exciting I'm sure
that'll be abused in many many ways then
here's an example using a custom loaded
fonts so you can see this is actual you
know real text here and it's all being
styled using a true type fonts that
we're dynamically loaded in let me see
if I can hardly load here so you can see
the oh yeah so yeah it's all pulled in
there okay one of the things that I've
been most excited about lately that's
been getting really good support and
browsers has been the new html5 canvas
element and this new element allows
essentially gives you a 2d this box in
which you can draw you know arbitrary
you know shapes and you know pixels and
what have you but it gives you a ton of
power to be able to actually draw on a
web page and the number of the things
that people been doing with it are
really quite fantastic there's also a
library that was produced here at Google
call X canvas that allows you to use
canvas and other browsers all right
sorry use canvas in processors support
it like Internet Explorer unfortunately
it doesn't support some of the new API
is like being able to do work with a
matrices of pixels and things of that
nature I wanted to show a quick demo I
released a last year something i ported
the the processing of visualization
language that was it's a java
template in Java and allows you to do
all sorts of visualizations i ported it
to javascript running inside of canvas I
wanted to show some examples here this
is a simple one so this is I'll just
doing some its basic collision detection
and multiple objects being rendered is
all in real time in a canvas element you
know using javascript let's see so this
one is actually it's scanning the pixels
of an image in rendering out the
different it's going by pixel by pixel
through an image that's loaded into a
canvas and drawing out the pixels of it
let's see and we get you can actually
see where exactly in the image it's
currently polling from let's see here I
like this one this is a flock of birds
so this is you can really start to see
the performance of these JavaScript
engines so it's doing all the
computation to figure out how the birds
should be flocking together and then
rendering them simultaneously to the
canvas I like this one too this is a
sort of a blobby shape that you can play
around with yeah that's have way too
much fun with this stuff but I love
canvas I think I think it's definitely
one of the best things to come out in
web development as a whole just shown to
some examples of what things you can do
with canvas it gives you the important
thing to realize that canvas is not SVG
you're not dealing with vectors and you
can't you know mutate shapes once you
draw them everything it's you think of
it like Microsoft Paint you put it down
it's there and the only way to get rid
of it is to draw on top of it so you're
constantly just you know you have a
basic primitives and drawing at
rectangles and circles and you know
things of that nature and then when you
draw you can you're given a series
of phil's and stroke so you can fill a
rectangle with the color set a stroke on
the outline things like that yes yep
okay so the thing that's nice about
campus though is that it behaves just
like a normal HTML element you can embed
it straight in line you know it it
handles Z and X properly opacity it
behaves completely normal so I've seen
cases where people have used canvases to
do things like drop shadows or rounded
corners you know it for browsers that
don't have them being able to draw a
custom backgrounds and all sorts of
things dynamically I've even seen cases
where someone has drawn custom UI
widgets using canvas elements there's a
really a lot of possibilities canvases
themselves can consume images so you can
port an image into a canvas in
additionally in firefox 3 in safari 4
which have the video element you'll be
able to take a frame of the video and
put it in a canvas element and
manipulate it so that'll be pretty
exciting one of the things that's also
seeing a lot of play is the ability to
have better control over data on the
client side and one of the big things
has been the introduction of some sort
of sequel storage on the client side and
this is this was just html5 and it was
implemented in WebKit it gives you a
full database so you can create a
database for a website and then run
sequel queries against it it's actually
just a sequel light implementation
running in the background wanted to show
an example just the other day Brandon
Aaron contributor to jQuery he wrote a
little API browser there's actually for
the iPhone but you so you can browse
through the API and you can view methods
and whatnot but all this information was
actually loaded up in the background and
it was actually stored in a database so
if you look here so this is in the
console you can see the database and
here's a say here we go yeah I mean it's
a sequel database so I mean and you can
you can go through and see everything
that's powering the website additionally
this is so this actually works on the
iphone as well so in this case when you
first load to the application on the
iphone it would download all the data
store it in a sequel database on the
iphone so that it would be able to load
faster in the future and then uh then
also there's the native Jason a support
is starting to land in JavaScript
engines so this is giving you the
ability to parse JSON and be able to
convert JSON or a JavaScript object to a
string you know just very very quickly
so i want to show you the performance
breakdown we with the yellow and purple
lines are traditional all types of
parsing JSON encoding and then decoding
the red line with the one that has you
know virtually no you know spike to it
is is the native one so it's
dramatically faster it's really quite
excellent so I think I'm running out of
time so I just want to quickly open up
for questions at this point if anyone
has any questions about what I talked
about today
so the question was you know is it
doesn't make sense to provide a you know
a strict mode that will make it easier
for you know interpreters to analyze
it's especially in the context of
JavaScript libraries um I'm not
completely sold on it I mean the the
whole reason for like a lot of the old
acma script for stuff was that there was
a huge assumption that you weren't going
to be able to make JavaScript fast
because JavaScript was you know it's a
weird language it isn't stat you know
statically typed you know it's um and
because of those in so the added things
like classes and types and all sorts of
things and then they found out that hey
we can make JavaScript pass in fact we
can make JavaScript really fast so I'm
not really sold on there being
restrictions to the language especially
since you know current browser seem to
be doing just fine anyway I think it
will only just limit what you can do
yeah another question
so so he was saying that you know
there's that the performance is getting
much faster but the tools that we have
for understanding it just aren't there
yet so what's available so I mean it's
yeah it's incredibly difficult at this
moment I think one of the big things
going forward is that we have to be able
to give developers more information
about start how much CPU and memory
their sites are using in all browsers
not just a chrome or whatever processors
are particularly blessed I would say
it's much more important that browsers
and browsers that leak memory badly and
so it you'll be able to have good tools
there so that we can better understand
how to write let's say acceptable web
applications right we'll be able to
we'll be able to i think expand a lot
better from there so the question is you
know how much canis I really start using
these so I the ones that I pick today
are all ones that can be used in some
contexts I mean obviously it it isn't an
all-or-nothing situation so for example
the worker thread you know the web
workers yo you can you can write one
that works now you know it draws it
drops very slowly but it draws or you
can you just you it's literally just a
drop in and you can just start to use
threads and get a better performance and
so I think there's a lot of cases of
workers he'll get elements by class
name being able to do you know the query
selector all all that stuff not only
doesn't make yourself faster in a very
simple way but since this is JavaScript
can just detect see if it exists it
exists do your fast thing if not do your
soul thing so i think i think there's
there's absolutely room for being able
to do all this now and I think it's
really important for developers to be
able to start to do that because if
they're able to show that you know newer
browsers not only are faster but just
you know wait years ahead in performance
um you don't know but be able to get
users of you know ie6 and older browsers
to be able to move and an upgrade so I
think I think that's all the time we
have I'll be around for a little bit so
if you have any questions feel free to
ask so thanks for having me thank you
very much secrets of the JavaScript
ninja what do you think it'll be out
this year let's say</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>