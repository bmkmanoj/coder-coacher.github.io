<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GTAC 2013: Espresso: Fresh Start to Android UI Testing | Coder Coacher - Coaching Coders</title><meta content="GTAC 2013: Espresso: Fresh Start to Android UI Testing - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>GTAC 2013: Espresso: Fresh Start to Android UI Testing</b></h2><h5 class="post__date">2013-04-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/T7ugmCuNxDU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">next up we have Valera who's coming back
up to join us some fun facts about him
he was born in Soviet Russia and he says
where you don't test Android Android
test you and so with that he's going to
talk to us about expresso thank you
doing so it's a pretty nice day out
there I guess we got the slides up Oh
click it yeah hey that works great so I
think Ari you know again I'm coming back
to what Ari said because it was such a
great keynote are we you know we're
gonna have beer we're gonna have coffee
you know I want to agree with him and I
want to say that we're gonna have coffee
so my name is neo I mean sorry Valera
and I guess if you missed the
presentation earlier today I work in
Google on making the lives of Android
developers easier at least when they're
at work outside of that you know that's
not our area of expertise so and one of
the recurring themes that we've seen all
over GTECH this time is that developers
need to write the test and I'm really
great I mean we've been talking about
this for years right and I'm really
happy to hear that I think everybody is
on board now but in order for developers
to write the tests the benefits of
testing have to outweigh the costs and I
think Eduardo's presentation was just a
perfect lead-in there and unfortunately
in the Android land especially in the
area of UI testing this has not always
been the case so as I said earlier in
the talk we analyzed why this was
happening and we decided to you know
that it needs to be solved and that we
need a fresh start
and then we identified these three
important characteristics of what the
test should be like if the developers
are going to write them but before I get
into that I think there there's kind of
an important point to be made and that
is that at Google at least I don't know
in your organization's the we support
you know a bunch of different API levels
and I think Simon actually showed a
great image yesterday from the Android
website
and you can see the majority of users
actually still in Gingerbread and still
in ICS and as the next five billion
people come in you know to join us in
the mobile revolution you know what
there's actually high likelihood that
they will be running low-end gingerbread
devices so I mean are we gonna just kind
of like leave those people behind no we
can't do that and you know at Google a
lot of our apps actually run as far as
back as Froyo and Eclair there's still a
significant amount of users there but
you know let's let's get back to on
track and yeah so actually the point I
was trying to make there is that yes
whatever solutions we come up with and
whatever tests our developers are going
to write they need to work a clock
across all of these platforms so easy it
sounds easy right when we talk about
easy I think we talked about two things
first of all it's the ease of deployment
when a dev sits down and starts writing
a test they don't want to install
complicated tools you know they don't
want to learn new things they just want
to write a test right and and we've seen
a great example I think the the Twitter
talk yesterday was awesome like when you
make it easy for developers they're
gonna do it and so with espresso we
wanted to maintain that and I think most
of the Android developers out there they
are familiar with instrumentation and we
wanted it to be the same exact setup so
expresso is just a thin layer just 600
lines of code on top of instrumentation
so it is really actually easy to set up
but the next part is the API and the API
you know really needs to feel intuitive
and it needs to feel familiar to the
developers we don't want them to have a
very large learning curve and when we
started thinking about the API you know
we just since we were starting from
scratch and that was you know really
sometimes it's really useful
we just thought what what does the
tester you know in this case the
developer who's writing the test what do
they want to do and they want to do what
the user does right we're talking about
UI user interface and the user really
just wants to do three things they want
to find an element you know they don't
really know that it's an Android view
but it's some kind of a UI element
they want to do stuff with it like lick
and type and then they want to maybe not
all users but manual testers they want
to check some states and I think users
actually implicitly check state you know
if something crashes they're unhappy so
what if you know our framework just did
this and nothing else I mean that would
be pretty cool right but just as
important as what the API does is what
it actually does not do you know we
wants you to do the right thing and we
want to prevent you from doing the wrong
thing so what is the device user not to
device user has no idea about the
internals of the application they don't
care about the fact that there's some
activity running right now or you know
views and it's you know in our
experience actually getting these
internal objects is kind of dangerous
because the state of the application is
constantly changing and if you're
holding on to this object it may get
stale it in fact it will get stale so we
left out this API that some of the other
frameworks include and so far we have
not seen the use case where actually
where we need it and then of course the
other thing is for the test authors what
do they not want to do and you know the
first thing is we we kind of talked
about flaky tests and how we solve that
and a lot of the frameworks out there
almost all of them that I've seen
provide this nice method called wait
until some time out and let's just do a
little poll after I click on a button
you know any button on Android and it
transitions to the next screen what's
the right time to wait two seconds do I
hear ten five okay five it goes to the
highest bidder five seconds that's the
right answer actually you know what I
don't think that's true I actually
cannot make that that choice myself I
mean I'm not the operating system and I
have no idea what's happening on the UI
thread right now so I'm not qualified to
make it so why are we asking test
authors to make that decision you know
that's just unfair so we left that out
of espresso awesome and then the last
thing is boilerplate right there there
are actually solutions for guarding
against these concurrency issues and
philetus flakiness but they require a
lot of boilerplate
so you know what let's remove that also
so this is how our API looks like and I
mentioned it I showed it slide earlier
today you want the spine stuff and the
way that we do this is our entry point
to testing is on view it's a static
method and you pass us a matcher for the
view so you just specify exactly how you
want to find the view and UI Automator
actually has kind of a similar pattern
you would have recognized that what we
did also is that we decided not to write
our own stuff and we reuse the wonderful
hamcrest matcher library no those guys
are really awesome we you know hamcrest
at first it just looks like it's too
good to be true
you know then it actually works really
well and so I have some simple measures
here with ID with text but amcrest
allows you to write all sorts of crazy
stuff so you can just find that one view
that you're gonna work with and then you
can do stuff and you can check so that's
it that's our API so you know tests just
framework authors that's that's what
they they have but we know that we're
not going to get the API right in the
first you know first try and that we're
going to leave out some things that
people are gonna want so we provide
three main extension and extensibility
points first of all as I already
mentioned the on view method takes a
handcraft matcher so that's really easy
you know you go and you look at how to
implement that it's not that much code
and so we have already some pre can
mattress for you there is a lot more
than that but as I said if you really
want to write your own go ahead I mean
all power to you same thing for you view
actions we provide you with a collection
right now and you know if you want to
write your own once again it's easy just
implement a few action interface same
thing for view assertion but in this
case actually most of the assertions
that you're going to do are actually
kind of like a new mattress you're just
gonna say oh is this view does it have
this property right now in this current
you know state and so we provide you
with this generic mattress method where
you pass a view assertion or sometimes
you actually want to assert that if you
does not exist in the current view
hierarchy so we give you that method
once again you can write it wrong so
that's it
for API reliability I mean that's the
other theme that we hear all over G tag
this year right and once again Eduardo's
talk you know there it's better to not
have test and have flaky tests causes a
lot of pain and you know we've seen the
Merry Christmas slide right so
unfortunately there's this assumption
out there that UI tests are flaky right
and there's nothing that can be done
about this so how does this press to
address this at this point here well
first of all let me take a step back and
ask you know how most test authors solve
this by the way I did not make this up I
took this from the awesome Google
codebase you know or maybe you're
smarter than that right maybe you wrote
an awesome like wait until method that
loops and retries and maybe has an
exponential back-off or maybe you even
got as far as this and this is actually
getting close to the real solution but
imagine if you had to do this for every
single test action right I mean talk
about boilerplate so espresso you know
we we had this idea that we can actually
solve this for the framework authors and
so we started out by synchronizing with
the UI thread and all of the UI events
and the choreographer in the new API is
and all of the stuff you guys don't
wanna hear about and all of that is
actually isolated in a level that you
know neither the framework authors nor
the the test authors will have to worry
about but then you know we discovered we
started testing it on real applications
like for example Google Shopper and we
discovered hey real applications they do
things like talk to the internet and
they write to disk and the primary way
of doing that you know is to background
your tasks and use async tasks so we
went ahead and we added synchronization
with a default async task thread pool so
you get that for free and then we were
like oh well we're done right and then
we discovered more apps within Google
and I won't mention any apps but they
implement crazy stuff like they go out
and just reimplemented road all in the
sake of performance and and in that case
like we were we didn't know what to do
so we added an interface where we allow
you to actually register with espresso a
resource and then you know you can
actually
tell us when your application or your
resources going idle an espresso will
wait to run the next test operation I
won't have time to get into the nitty
gritty details so here's a simple recipe
and you know what so you know for each
test action we wait until the
application is idle and then we do an
amazing thing we get on the UI thread
why do we do that because while we are
on the UI thread just like I'm on stage
nobody else can be on the UI thread
well maybe until Tony kicks me out and
then we you know we find the view using
the matter that you provide it to us
we run your action or assertion or
whatever you gave us and then also a
very important thing is as we saw
earlier today some actions like for
example the click action result in
multiple events being placed on the UI
thread so we actually wait until those
events get processed and only at that
time we get off and then if there is any
crash you know it happens once in a
while we don't want to crash the UI
thread it's not a good experience so we
catch all of the exceptions and we
propagate these in a user-friendly
format to the test author so with with
this approach you know it everything
really runs reliably and we've seen we
have teams that actually run substantial
amount of UI tests right now and their
tab builds are not flaky at all so I
mean their continuous integration builds
are not flaky at all but there's
actually an extra bonus and we didn't
really set out to make our framework
super fast but it turns out that when
you remove all those sleeps and wait
until from your tests and you actually
run the millisecond that your app
becomes idle things move really fast and
so perhaps you've seen the demos today
that we showed all of those UI tests
that are you know just flashing on the
screen those were running espresso and I
mean sometimes the tests run so fast
that they just flash on the screen and
we don't even like we don't see anything
so speed is always nice right and
finally this point on this is kind of
understated and what do I mean by
durability you know durability is the
the antenna of fragile you know fragile
tests
and here you know we didn't have to
invent anything instrumentation already
provides us a great way of dealing with
this issue and the problem here is that
as I said most of our application errors
are in this really fast development
cycle like Eduardo mentioned in his talk
and it would be really really painful if
every time a string change happened you
know your tests also broke and ideally
we want that to not never happen or if
it happens maybe it will happen at
compile time and so the nice thing about
instrumentation tests is that they are
actually compiled in with your
application so there you know there is
this you know this connection that you
can maintain so you can actually refer
to elements by resource IDs versus
versus just content descriptions so
originally I was going to do a demo but
you know obviously I'm running out of
time already so there's no way that's
gonna happen and also you know it's kind
of boring to watch somebody else code
it's fun to do it yourself so here's a
go link for a screencast that I did for
espresso and I also shared this on my
Google+ public stream so you guys can go
check it out and I hope that you do so a
lot of the Google teams out there
already using espresso we have several
more that are onboarding and perhaps you
may be wondering in this talk whether
you can also enjoy some espresso
yourself and so after this talk I'll be
out on the micro kitchen and I'll be
making espresso for everyone well bummer
bummer okay well I don't know then I'll
figure out something else yeah but but
so since I'm running out of time I'm
going to stop that so seriously we would
really really like to make espresso
available to people because we really
like using it ourselves and we're just
working out through some technical
details right now and hopefully in the
near future we'll be possible so with
that and I you know when we do I'm and
even right now before we do I just want
to say we're really looking forward to
your feedback you know do you think
we're on the right track you think we're
completely off track it would be great
to hear your thoughts unfortunately I
think we're not going to have time for
quite
but I'm gonna be around and you know be
happy to chat with you thank you great
thank you thank you Laura it was awesome
that was a good movie to put some boots
or a nice movie I'd probably give this
guy just</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>