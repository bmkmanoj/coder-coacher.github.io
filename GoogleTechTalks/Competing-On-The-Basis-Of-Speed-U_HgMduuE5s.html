<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Competing On The Basis Of Speed | Coder Coacher - Coaching Coders</title><meta content="Competing On The Basis Of Speed - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Competing On The Basis Of Speed</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/U_HgMduuE5s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">no I I really do have to set the record
I started out life as a programmer and
the kind of thing I did would be called
development today but kind of
programming I did wasn't Google kind of
programming it's true I was a process
control programmer so most of the stuff
I did was make big machines move around
today it would be called embedded
programming but you know we didn't embed
our computers back then because like
they were this big so it was also IT
manager in a plant and we did some lean
and but I'll just tool on a half past
that I just had to make sure that i have
a few credentials I do know how to prote
make computers do stuff so competing on
the basis of speed I'm going to just
dive right in and talk about this
concept of fast company's interesting
fast company is Dell they compete on the
basis of speed and one of the most
interesting things about speed is that
you have a significantly lower cost
structure than slower companies Dell
claims a 50-percent cost advantage
relative to its peers now that's not
common from the components and the
computers clearly there the their pain
as much for their components as anybody
else it's the underlying infrastructure
needed to support all that other stuff
that happens that gives them a
significant cost advantage in a market
where it matters and it also gives them
a significant time to market where
people care about having the latest
gizmo another company that competes on
the basis of speed in product
development as opposed to manufacturing
is Toyota Toyota brought the Prius to
market in a 15 month cycle from the time
that it chose to put the Prius on the
market from the time the concept was
approved until it was actually
introduced in Japan now you think that
doesn't have anything to do with
software development the fact is this
kind of a car is a computer on wheels
there's probably more code in a Prius
than a lot of companies have code in any
of their computers this is a very very
software intensive kind of a development
process and the amount that they did in
15 months to develop a completely
computer-driven engine
is amazing and then there's this company
called Google that competes on the basis
of speed and a software development area
one of the larger ones I know that does
so I know a few others too but it's an
example i often use when people say oh I
don't hear about little companies Ellen
hear about big companies I say okay try
google so perhaps you do you do compete
on the basis of speed competing on the
basis of speed gives you and other
companies that do it a significant
competitive advantage not just cost
advantage but the time to market gives
you a lead into the a potential customer
base and it also gives a large barrier
to entry any company that competes on
the basis of speed is really hard to
catch and it's really hard for them they
have a good basis to maintain in a
leadership position on the long run when
speed matters in a market that's rapidly
changing that's when it matters you
don't want to be left behind you want to
be the company that is in front in the
speed and stays there so what keeps you
from being able to compete on the basis
of speed I mean there's lots of startup
companies that started fast and slowed
down to a crawl it's kind of the history
I mean if you think about windows 95
versus vista windows 95 took 300
developed 350 developers ten years ago
and vistas taking 3500 developers and
it's a pretty slow so you want to watch
out of the kinds of things that kill
speed our complexity and in lean we have
three kinds of ways of looking at
complexity this is from a really good
book on innovation by Matthew make all
the elegant solution anyway on talk
about the three phases of complexity
that he talks about the first is waste
waste is anything that depletes
resources of time effort space or money
without adding customer value that's
what waste is it's a really actually
kind of a high hurdle and it's something
you want to be particularly careful
about not doing anything
that gets in your way of spending your
time doing nothing but adding customer
value keep it simple that's kind of the
forget waste keep it simple the second
big killer of speed is complexity is
inconsistency anything that is uneven
irregular unbalanced if you look into
lean manufacturing one of the first
things you have to do is have a level
line I will talk about what that means
in software but I will I will say on the
front its make it flawless okay and the
last one is overload excessive or
unreasonable burden something that just
is too much to really be expected let it
flow so those are the three things I'm
going to talk about today keep it simple
make it flawless and let it flow okay
simplicity so Jim Collins who wrote good
to great says it's the discipline to
discard what does not fit that marks the
ideal piece of work or Matthew may in
the book here elegant solution lean
requires a precise understanding of what
value is the who what when where how and
why of the customer need our Fred Brooks
who wrote the the mythical man Mont
basically said write less code less code
better okay now I don't really need to
say whole lie about keeping it simple
here because this is my example of keep
it simple okay so you guys get this but
there's more to simplicity than what you
see in the product so I'm going to talk
about a few other areas of simplicity
simplicity also talks means a common
underlying infrastructure things like
common architecture naming common
conventions of the way things are named
coding logging your user interaction
security configuration management common
tools does it mean you have to always
use the same tool or always have the
same standards but if you start having
myriads of these you will have a very
complex rather than a simple
infrastructure and it will slow you
down in another area of simplicity is
what I'm going to call refactoring
you've all heard of refactoring okay so
keep your code base clean keep
simplifying the design of the code
because you don't want to have to have
this great big massive think of
everything on the front end you
absolutely want to be able to add stuff
as it strikes the users that they want
it and in order to do that you have to
have a simple code base as you add stuff
you have two choices either it's going
to get more and more complex or you will
keep it from getting more and more
complex and there you have to
consciously clean up and remove
duplication and cleanup code as you add
more and more features so that's another
set of aspects of simplicity and then
one more long thing sustainable
simplicity comes from change tolerance
in the code because you know you want to
remodel what you do all the time the
stuff you put out today is not the stuff
that's going to be there tomorrow people
who used to think that was the case if
discovered that it just can't be the
case in the area software software is
there to be changed it's going to change
in fact sixty to eighty percent of all
software is developed after first
release to production and a development
process that anticipates change will
result in software that tolerates change
and if your process does not anticipate
change you are going to have change
intolerant process I want to interrupt
here and say that anybody has any
questions don't wait just you know do a
skit because it's actually more fun to
answer questions and talk about stuff
that interests you than to just sort of
talk at you so please yes
if I could do examples of include
manufacturing oh okay I can I almost
always do and I get you know run out of
the place cuz I'm gonna hear what I
manufacturing oh I don't hear about this
up it software um so i'll do that next
okay when toyota designs cars for me
actually i preferred product development
instead of manufacturing when toyota
designs cars they have an interesting
development process that i'm going to
challenge you with it's called set based
design and set based design says don't
just do one thing do a set of thing so
let's talk about that Prius again the
prius is now got 15 months from product
concept approved until it's out there
they've been playing around in research
with all these various types of hybrid
engines but they don't actually know
exactly what it's going to look like for
the first four or so months of that 15
month cycle they maintain 10 active
engines under development in detail and
they have decided that they're going to
decide about 10 9 10 months before
actual production which one of those 10
is the best they don't just do one and
keep making it better they have multiple
options and in fact this not only makes
up go faster it makes stuff simpler
doesn't sound exactly right to you so
what happens is I talked about this
concept of deferring commitment in
product development Toyota to first
commitment as long as they possibly can
and makes the decision about what
they're going to do as late as they
possibly can so they don't have to
change it and especially so that they
have the most information when the
decision is being made just like we
deferred commitment and manufacturing as
to what we were going to really
manufacture until we knew exactly what
customers are going to order the concept
of ordering what has been bullet has
been asked for at what is being bought
instead of manufacturing what you think
is going to be bought gives you much
more accurate inventory so a development
process
that anticipates change is good what
does that actually mean the first thing
it means is to make decisions reversible
whenever possible okay so the first
thing you want to do is have an
architecture in the development process
and the development of attitude which
says I'm not going to make absolutely
permanent hard to change decisions I'm
going to be able to refactor i'm going
to put stuff out early i'm going to get
a lot of feedback that's fine but there
are a few decisions that are
irreversible and i'm going to make those
as few as possible i'm going to make
every decision i possibly can reversible
and maintaining set based design which
I'll talk about in a minute is one of
those approaches when you have
irreversible decisions and there are
some of those you you actually have to
have user interface in the end and it's
harder to change than anything else
there's a lots of stuff that's hard to
change maybe it's your security policy
maybe it's languages that you use when
you have decisions that are going to be
constantly inexpensive to change you
want to make them as late as you
possibly can so when irreversible
decisions are made they should be made
as late as possible with the most
information and that's called set based
development or set based engineering in
Toyota and it works like this this is
point based I have a design solution my
design solution is I'm going to do
whatever I've chosen to do i send it out
for analysis critique feedback I modify
it I go in a circle and I can go in a
circle forever or you can take the
Toyota approaches explore all of the
available design spaces keep ten options
open instead of just one or whatever you
have a range of sight technical
capabilities a range of logic a range of
interaction approaches you see which
one's work and you gradually narrow the
acceptable capabilities until you come
up with a solution that's set based
design it works like this
irreversible decisions are scheduled to
be made at the last responsible moment
not later okay it's not like you don't
make decisions is that you know enough
about what it is you're trying to do to
know how long you can wait until you
decide just like a pilot flying into a
foggy airport they know at a certain
point if they can't see the ground they
have to pull up now don't decide until
that point but if they can't see the
ground when that point comes they had
better pull up or they're going to be in
trouble same concept irreversible
decisions are pre scheduled to be
happening at the last responsible moment
so the interesting thing here is you
don't have to change these hard
decisions you haven't made them so if
you haven't made a decision you don't
have to change toyo didn't have to
change which engine it was putting into
the Prius because it hadn't decided yet
if you decide as late as possible you
can't judge change your mind after that
and you don't need to change your mind
before that schedule tough decisions to
the last responsible moment multiple
options have to be prepared for this
decision point why because if you don't
have multiple options you've already
decided yes okay so multiple options
have to be brought to the decision point
and one of them at least has to always
work by the time that decision point has
arrived at otherwise you can't go
forward and this was remember the last
responsible moment beyond this you're
late actually this is also strategy for
never being late if you have multiple
options maybe one of them actually
doesn't make it on time but the other
ones do then you are guaranteed to have
a solution the paradox is this isn't
waste you have a lot of redundant
solutions but you're not wasting that
development you are actually on the
overall view of the whole system doing
doing the whole system a favor so for
example because Toyota was able to get
that Prius out on time with the
manufacturing plant prepared and
everything meeting all of the overall
market objectives being ready when the
marketing people already save the
be much more money than only doing one
engine which could have delayed things
in fact the other thing the Toyota got
was so much experience in making hybrid
engines that now they're going to put a
hybrid engine into all the cars that
they make as an option so it's a it's
not a really bad thing to take the
really tough decisions and have multiple
options it's not waste it's it allows
you to be faster it allows you to have
the best alternative here is a case
study I was here in the Bay Area I was
given a talk at st west on this very
topic and somebody who it was at a
company that made printers came up to me
and said I got this problem my marketing
people say I can sell a hundred thousand
more printers if only I will give them
red eye reduction now at the time red
eye reduction was a solved problem but a
computer actually recognizing that red
eye reduction was necessary and then
doing it was not a self problem and the
marketing people said that they could do
an automatic red eye reduction with this
printer as a feature they'd sell a
hundred thousand more but he had only 12
weeks okay so he had two options there
was a simple algorithm wasn't very good
one but it would work and then there was
a complex algorithm but he wasn't really
sure he could make the date what should
he do there you go you got it you got
the concept in this case of course you
would do both I said to him well
obviously you would do both and he was
really stunned and he said well am I
gonna tell my managers no he didn't say
that he said where am I going to get the
resources and I says you're telling me
you can sell a hundred thousand more
printers and you're asking me where
you're gonna get the resources from oh
yeah he says I guess you're right well
what am I gonna tell my manager I'm said
well what you're gonna tell them is not
to worry don't lose any sleep gonna have
the red-eye reduction on release date no
problem and you know what couple months
downstream we might even have a better
one otherwise it might even be ready on
time they'll love it that you know just
because you develop two things doesn't
mean it's wasted and even if it does the
whole idea
hitting that market window is much more
important than having a few extra people
that are developing two different
options and so if that poor algorithm
doesn't make it you know those guys were
rooting for the ones with a better
algorithm anyway because they wanted
that one to go so do both is cheaper and
the big picture than doing just one and
that's a concept of set based
development that really works in
software development especially for the
hard irreversible decisions and you want
as few of those as possible so any
questions on that before I move from
simplicity and to make it flawless I'm
done with simplicity I I think you you
understand it you'll want to do it and
this is a this is a technique that is
rarely used but actually it turns out to
be a very interesting and effective one
okay so now let's talk about make it
flawless so back when the Toyota
Production system was started up started
up by TG uh no and he had a couple of
concepts one was just in time flow which
we'll talk about next but the other was
a stop the line culture this came from
the fact that when Toyota started up it
made looms and the looms had the warp
and in the West and the idea was that
they wanted multiple machines to be
managed by a single person but the
minute one of those threads broke they
got a defect in the clock soon as you
got a defect in the cloth you couldn't
sell it and that was pretty expensive so
typically at that time power I'm talking
early 1900s power looms were staffed
with one person per loom in fact some of
the earliest power looms were staffed
with little kids watching each lumen and
stop it as soon as something goes wrong
so the brilliance behind to Tsukiji
Toyota's invention that he patented and
then actually this invention was sold
the Loom the patents for the looms were
sold to fund the automotive business
another story was that the minute that
that loom had a broken thread the little
metal thing would flip down because it
be resting on the thread may come it
will contact and stop the loom
the Loom would be stopped or if the
wharf redwood ran out another one would
come in and it would automatically
shuttle back and forth another one would
drop in but if ever anything went wrong
there the Loom would stop the minute
something goes wrong you stop the loom
that is the concept of stop the line or
make it flawless that actually allows
you to go faster so then they could have
like 20 looms with one person because it
would stop when something went wrong the
idea of stop the line is one of the
fundamental concepts of lean this is
shakia Shengo who was one of the
consultants and lean both at toyota and
alpha soil in the united states and he
wrote the book that we used in our plant
when we started up just-in-time
production and he says in that book that
there are two kinds of inspection
inspection to find defects which is
waste how many here are like in QA and
do this kind of stuff okay you've got
friends though right so I'm telling you
that what they do is waste is that right
so inspection to find defects is waste
but inspection to prevent defects is
essential when he started up in our
plant we had people in QA that used to
try to find defects in their product and
we move them all out onto the production
line to figure out how to make stuff
without defects in the first place and
this is the game you need to play with
lean in order to go fast you would be
amazed at how much faster you go when
you make stuff where the defects are
caught the minute that they occur
instead of found later so your idea
according to lean in manufacturing or in
software development is to mistake proof
every step defects need to be detected
the moment they occur the idea is don't
track the defects on a list find them
and fix them okay so test first in other
words start by writing the test put them
in an automated test suite and then run
them as you write the code and catch it
I'm going to talk a little more about
that so let's talk go back to the role
of testing a quality process builds
quality into the product it does not
test it in later anybody's been in
manufacturing has known this
in their sleep for about two decades the
fact that we don't get this in software
development is too bad because this is
really fundamental fundamental in fact
going fast if you routinely find defects
in your verification or QA process do
you you know after you're done you toss
it over and QA looks at it do they find
defects okay then you have a defective
process you need to figure out how to
find those defects before you hit QA the
job of testing is to prevent defects it
is not to find defects if you're
focusing on finding the defects that's
not the right job of queuing so if you
have these tests and pick cycles at the
end of your development you're all done
with development done my job is their
problem if they have to do tests and fix
stuff then then you guys are testing too
late you have what's called churn
there's a couple of kinds of churn one
as requirements charming you're right it
you keep changing it and the other is
tests and fix churn you test it in the
end you have to keep fixing it if you
have testing at the end that's finding
the effect you're testing is happening
too late it should be happening
integrated into the development process
if not at the front so let's see how
that happens first of all there are four
kinds of testing this is a really
interesting matrix from brian merrick
and he talks about four kinds of testing
one you've probably heard of which is
unit testing okay because Marcus trained
very hard to get everybody to understand
about unit testing so your developer and
you design the code by writing a test a
unit test and you say when it passes
that unit test then I have done what
I've designed to do if you have an
automated suite of unit tests as part of
your development process that you run on
a routine basis you will in fact design
testable code and you will also have a
spec that says how this is supposed to
work that can be checked automatically
forever as to whether or not it's still
doing what you intended but then there's
some more testing there's only one
quadrant field the next thing is what
I'm going to
all acceptance tests or regression tests
or whatever it is that those QA people
do to make sure that it works the way
it's supposed to work and that says is
the business intent or the product
design being being still working and
those kinds of tests these days anymore
are also guess what easy to automate so
if you get people out there pounding
doing routine stuff then that's not the
thing that people should be doing you
need to be figuring out and there are
really good tools to to take and test
both your your code that's underneath
your page and your page flows with
automatic scripts that typically are
easy to read by anybody who wants to
understand what the intent of the code
is so anything in that area of testing
really needs to be automated there are
some things that can't be automated but
as much as possible that stuff is
automated know if it's automated and
you're going along testing developing
and you have an automated script of what
it's supposed to be doing you can be
running that on a regular basis as
you're developing and knowing that
you've not broken anything that used to
work and as you get stuff done that it's
working also that works both with unit
tests and with development of our
acceptance tests then you have some by
definition manual tests usability test
does somebody like me you know I just
come in as set down and you give me a
task to do and am i smart enough to
figure out how to do it and it's not am
i smart enough is your code into it
enough intuitive enough that I don't
have to be taught how to do it or go to
help screens it just kind of works
that's usability testing and exploratory
testing is if I do all this crazy stuff
can I break your code or not and that's
not does it do what's intended it's is
there any way that it can be deviously
broken these are manual tests and this
is where people should be intelligent
people should be spending their time
they're not doing this stuff that can be
automated and then you have stuff like
is it fast which you really care about
so you're really good at it so you must
care about it um
response security that kind of stuff and
those typically are some sort of tool
and you will have anywhere you care
about tools to test that that happens
the earlier you test in the development
process that you've got those kinds of
things working the easier it is to fix
it if you're not heading down the right
path so those are the kinds of testing
that need to be done early and often so
I'm going to talk about this thing
called technical debt because remember
the thing we're trying to do with code
is make it change tolerant anything that
makes code difficult to change is debt
the companies that haven't been around
for a while and you know really you've
only been around for what seven years
eight ten that Pisoni so I'd still not
very want when i worked at 3i might have
been around for 75 years and now it's
100 so um uh you you require this thing
called debt if you're not careful and it
first doesn't seem to make any
difference but the longer you acquire
debt the worst it is so I've seen
companies that have been around in
software for way longer than Google and
they're taking as long to test as to
develop code twice as long to test as to
develop code and on and on as time goes
on you acquire this thing that takes
longer and longer and longer to do the
testing because you have technical debt
if you don't care about technical debt
and you acquire it now you're going to
be sorry so think about that when you
develop what is technical debt for
example complexity which we just talked
about the cost of complexity is
exponential as time goes on is not just
a linear thing it just goes through the
roof but we talked about complexity so
the next thing I'm I talk about is
regression deficit regression deficit
you want you've got something that works
you're gonna add some more features you
want to make sure that what used to work
still works that's regression testing
it's typically in that acceptance test
quadrant okay so you do regression test
now you want to add something else more
features regression test takes a little
longer yes because you've got someone
features to test add some more features
takes a longer
add some more features takes a little
longer this goes on forever okay this
thing grows and grows and grows and
grows and grows until it dominates the
release cycle and you can't afford to be
there you need to figure out how not to
have regression deficit and that's where
automating your acceptance tests QA test
as much as you possibly can we'll get
rid of this tail end thing it doesn't
matter if it grows from a half a minute
to a minute or even from an hour to an
hour and a half but it does matter if it
grows from a week to week and a half
because that can go on forever so you
need to automate that and then the last
part is unsynchronized code branches
okay so we all know that as soon as you
take two lines of code and branch them
the longer they are apart the harder
they're gonna be to merge the more
difficult is going to be the more
they're gonna get out of sync everybody
knows that well if you've developed you
know that yes so this is life it's never
going to change so how do you fix it is
you synchronize you say I've got to code
branches I better fix incra nuys them on
a constant and consistent basis the more
you synchronize the less you don't have
that problem so recognizing that it's
always there the minute that you branch
you need to have methods of
synchronization so perfection in in lean
software development perfection in any
Lane area is one-piece flow protect
perfection and software development is I
have a feature set that's going to be
useful for some customer other I can
take that one piece and get it through
my system fast the longer you have this
kind of stuff on synchronized code
branches regression desa facade and
complexity the bigger you will be
tempted to make your batches of stuff
that go through because it's so hard the
whole thing you want to do in lean is
exactly the opposite you want to
continually focus on one-piece flow so
because you asked to go back to
manufacturing one of the most difficult
things in car making in one-piece flow
is the paint booth think about it you
know you get a white car and then you
want a bread car and then
on a blue car if you're going to do
one-piece flow in the order that they
were ordered by customers then the
colors are going to vary all the time so
what happens in this hole no matter how
instrumented a factory has been for cars
when it get to the paint booth things
kind of stopped because it's so
expensive to switch from one type of
paint to the other even three years ago
in the Georgetown Kentucky plant every
time they wanted to change paint color
they had to flush out the paint lines
and clean out the booth and have
solvents that you know and all that sort
of stuff and they did it a lot because
of one-piece flow is valuable and they
couldn't afford to have too much stacked
up of inventory because that was even
worse and then somebody came up with the
brilliant idea of instead of having the
paint tubes go to the robot arms that do
the spring have the paint tubes go to
canisters the robot comes and picks up a
canister with just the right amount in
color of paint sprays the car quick wash
down of the air and pick up another
canister for the next color they went
from three paint bousta to they went to
using seventy percent less paint or
thirty percent less paint and all the
solvents and cleaning time and stuff
that went through and they were able to
put through a hundred cars an hour
through their paint booths instead of 70
and they were able to go from three
paint boost to two and they have great
bigs floor space now that isn't there
that's one piece flow so if you say geez
paint takes a long time I got to have
all the blue ones and all the red ones
and all the white ones then you're in
trouble if you say I want to put more
and more stuff together because it is so
hard to release the production you are
going the wrong way your objective is
one-piece flow if you have an objective
of one-piece flow then you will watch
very careful not to have technical debt
because you can pay for code when you
make it or you can go into debt but the
debt has a huge interest rate so what
you want to do is not let this stuff
happen in the first place so you want to
constantly focus on rapid deployment of
small
feature sets one-piece flow into
production and in order to do that you
have to build quality inn so for example
we have what we call building block
disciplines first would be configuration
management such I'm assuming that you've
got okay a configuration management
system in which you check in code and
check out code and then once code is
done you have a one-click build so that
as people checking code if they're
working on the same area especially
there is a one-click build which will
run through and do a bunch of automated
testing now you won't run all of these
tests at the same time I'll talk about
that in a minute but the one click build
will fire off a short test maybe 10
minutes and if there's a problem you
need to stop now everybody doesn't need
to stop but the last person to check in
does that's why you don't want to ever
be the last one you want to be early and
checking in stop and fix it or chip back
out the code and find out what happened
you don't ever want those tests not to
be passing so it's not just have a test
but it's run them and stop when the code
tests don't pass back out the code fix
it and then you want continuous
integration okay which is with nested
synchronization which I'll talk about
and you want frequent deployment but
more frequently you actually get the
thing out there getting feedback from
real life people the better off you are
so let's talk about nested
synchronization because it's not just
everything is in unit test a little more
complicated than that nested
synchronization means that every few
minutes for example people working in
the same area of code check it in and
there's a test that fires off and tells
whether or not things are working people
have worked to get that test fast it's
maybe not everything it doesn't take any
more than 10 minutes so maybe you've
marked out the database or not or maybe
even the user interface but you know if
stuff is passing these are typically the
unit tests then every day for example
depending upon the length of it you then
run your acceptance test suite on this
particular thing that you're working on
and maybe every week or something you
have some harnesses that you get from
operations that are going to pound your
code and make sure it's not going to
kill anything else in operations by
doing all the stuff that they don't like
it to do and having all of the
protection from anything that could take
down an operating environment or and
then every iteration you want to have
stuff that you could actually deploy
okay so deployment ready you could put
it out there I mean people who do
antivirus stuff have about a 48 hour
cycle from starting to figure stuff out
to on my computer and they've gone
through all of this stuff in there so
every iteration whatever an iteration is
do you a couple weeks or four weeks or
whatever it means you want stuff to be
ready to deploy if you actually wanted
to or you want to deploy it in any case
you want to have releases as frequently
as possible so that's what i mean by
nested synchronization you are running
at whatever pace you possibly can the
whole suite of tests in an automated
manner as early and as often as you
possibly can now the job of QA is not to
find the defects is to create this
nested structure so that you have these
things available to you and development
that you can run helping what goes in
what test harness when makes when does
it make sense to do this sort of stuff
that's the kind of thing that is the job
of QA so and then I'm going to talk
about the last part but before I do I
want to see if there's any questions
about make it flawless yes
mm-hmm
or
Harold bonus they don't have to be
isolated
yeah so you you if you have various
things that you're working on in
parallel that means you can actually
release the production just a few of
them as possible and you're still
working on the others at the same time
makes a lot of sense as long as you have
a synchronization mechanism that you
know all the time as you as you have
these multiple branches that yes so it's
just an on/off play ok but when you're
not in production you should be
regularly turning everything on ok ok
yeah but what I'm saying is as long as
on a very regular basis you have
something that goes through their turns
everything on and make sure nothing is
killing each other ok so as even the
stuff that is suppressed should be a
good citizen and you should know that
the suppressed stuff is a good citizen
in ways now there will be some things
that won't be doing and sometimes you
can't turn that on because it you know
it's going to kill the other code branch
or something but you should have ways to
what you know should be working should
be tested across all the branches as
often as possible and that would be an
interesting challenge for QA so when you
get to a point where you turn one thing
on does it ever kill other stuff if you
catch you to run point well but if you
yeah and and sometimes catching it at
the run point will tell you what you
should be doing but what I'm worried
about is you catch it at the right part
in cycle and it still kills other stuff
that's what you want to know about you
want to know about the interaction
across your code branches that should
that should work has worked in the past
that stops working that's the stuff you
want to catch the minute you do sup
something to make it stop working it's
so much easier when you know that it's
yet worked five minutes ago I did this
thing and now it doesn't work well guess
what caused it ok its way the heck
easier than it worked five days ago I
did this stuff and
oh it isn't working that's a that's a
witch hunt okay it takes forever to
figure out what caused it so you always
want to be in the case of it worked this
little bit of time ago i did this very
small amount of stuff and now it doesn't
work how come now if it wasn't supposed
to work and it still doesn't work that's
okay but if it used to work and now it
doesn't that's not okay now one of the
things about unit test is they're not
really good for finding out stuff that
doesn't isn't supposed to work yet
because typically unit tests are
expected to all work one of the things
about classic let's sake take fit for
example as an acceptance test tool is
that is cognizant of the fact that a
whole bunch of times lots of stuff isn't
supposed to work yet so it just turns
stuff green and red and green means it
works red means it doesn't runs through
the whole suite of tests and what your
job is to say well if it used to be
green and turns red now I'm in trouble
if it's red but it's supposed to be red
because I'm not done that's not a
problem i just watched for all my Reds
to go green so what you're looking for
as you synchronize across those branches
off line is it used to be red green and
now it's turned red where is the thing
that caused that and how little bit can
I get away with doing before I discover
that so that's the game your plan okay
any more questions on make it flawless
yes
one of the bureau's of success
Rose
which is likely me passivation state
where they go great well the problem was
typical unit test is once a unit test
pass it's never supposed to not pass
again okay so that's okay as long as
that is focused on does the code that do
do it do it I designed it to do the
functional test can very easily not pass
for a good long time until they do you
can have functional tests in there so
your unit tests as soon as your unit
test is checked in you also should have
the code that makes that pass so unit
tests should always pass so I don't see
any problem with that I'm not sure what
you were saying with that part but if
you're not also doing your functional
tests simultaneously maybe not that our
but that day then you are going to get
out of sync on your regression tests and
that's where it's going to grow so what
you want is I can run I can add I can
have a regression twice test suite i
define during this iteration these are
my regression tests for this section
I've already got earlier ones let's just
pretend for now I'm going to add these
many features here are the regression
tests at the end of the iteration these
are all going to be green but right now
some of them are read okay so I ran my
regression test and it's not a stop go
situation it's a what's passing and what
isn't situation and by the end all of
the regression tests that used to work
should be green and the ones that I know
now should work should be green every
day I get more and more green and I
never turn anything read that used to be
green that's what you're trying to do is
accept does that make sense did I answer
your question or not
yeah exactly and and yeah the the
concept of regression testing is
different functional testing is
different than unit testing and both of
them are very important and as far as is
absolutely possible both of them should
be automated anything that's being done
routine should be automated there is a
way to do it I don't I'm not going to
tell you you know ask mark you can come
up with all solutions fit enough right
haha but the you want to have a
different concept of testing for
regression testing than unit tests but
you want to have them both automated
because you can't afford not that you
can't afford to have that manual okay so
we went through this anymore i'm not on
testing or make it flawless okay so now
we go into let it flow so let's talk
about cycle time that's the average
end-to-end process time from problem
detection to problem solution and this
always begins and ends with a customer
from the time of customer has a problem
until the problem is solved so I call
software development cycle time this is
by the way a classic lean concepts cycle
time is customer problem to customer
South TG ona who sort of invented the
Toyota Production system said what he
calls cycle time is from the time they
get a customer order until they have
cash so from order to cash so this is
from need to need field and never you
got to go all the way back to the
customer you got to go all the way back
to deployed and solving the problem so
that's cycle time and this is my opinion
the best measurement of process
capability is whether or not you have a
reliable and repeatable cycle time for a
category of problems okay so that's what
we look we do value stream map so the
entire value stream from customer
problems customer solution and say where
are the delays because we're the delays
are will almost always be where the
opportunities for cost reduction waste
reduction will be
so but I want to talk about something
else and that is I want to talk about
queueing theory because when you really
look at lean manufacturing a lot of it
is based on fundamental queueing theory
which you all get okay I mean you're in
Google and go gets queueing theory
otherwise how could you possibly have
your screens come up so fast I mean you
got all these little things instead of
big things and you also drive here in
traffic jams sometimes okay so you get
queueing theory and queueing theory
applies to development too so the first
question is how many people here have a
list of things to do in their backlog of
things to do that's a way longer than
they ever have any hope of doing okay
there you go okay I really run into
organizations that don't have that and
the first thing I want to suggest is
that that's actually not such a good
idea why do you bother to keep track of
it why do you bother to have that list
so think about this this is who here is
study queueing theory okay quite a few
people and you all get that when servers
get to be you know like eighty five
percent utilize you better start
thinking about what you're gonna do to
get some more in there and littles law
which is not my lot comes from queueing
theory says that in order for your total
cycle time which is what we're talking
about with their software development
cycle time to be affected that's a
direct proportion to the average
completion rate and the number of things
in process so there's two ways to go fat
to drive down your cycle time and one
way is to drive up your average
completion rate but get more people you
know stuff like that but that's actually
kind of hard you know even if you had
the money the people are hard to find or
you can drive down the number of things
in process and that takes more
intellectual fortitude than it takes you
know people and money and you have to
think very hard about what you can do to
drive down to things and process so for
example this is a well-known computer
manufacturer that used to compete with
Dell which had a who had a six-week
amount of stuff in inventory and the
neat thing about this was if you wanted
a
uter you could walk into a store you
could find a computer you wanted and you
could bring it home that was really cool
okay and then there was the put your
order online they'll pack it and ship it
in a day or two later it'll arrive so
this has like six weeks this as like six
days of inventory in this kind of the
line and the deal is that if there's a
new say graphics card out there that's
way faster or something like that which
one of these is going to take six weeks
to go from here to there with your new
graphics card and this is going to take
six days at most maybe even less because
we can start here and say maybe 40 80 or
so the ability to put in new features
that might be demanded is really much
greater in here because the amount of
inventory you have is the average time
of something coming through so because
it was new graphics cards that people
were looking for they don't want to go
to the store and get the graphics card
that was old and this is the model that
one driving down things in process this
is a classic queueing theory 101 picture
and it says that I'm just gonna go a
little bit over if that's okay with you
since I started a little bit late if you
guys don't mind you can leave if you
have to but I'll try to end by five or
ten after okay probably five minutes
maybe 10 pins on questions I should have
said that okay so here if you have big
batches of stuff this is you've got such
wrong regression tests that takes you
forever so you do long far apart
releases you are going to start slowing
down at about fifty percent utilization
of your resources if you have small
batches you start slowing down here at
80 or 85 percent you know this out there
on your servers you really do you ought
to know this in your development cycle
and actually you really do too because
what you're looking for is some amount
of slack instead of driving everybody to
use a hundred percent of their time
towards what they're supposed to be
doing you need slack so we had a rope
which you will be very familiar with at
3m and that was that anybody could spend
fifteen percent of their time if they
were in development area working on
anything that was good for the company
so you've heard of that because you have
something similar and so I'd like to say
you stole that from 3m but what it does
it's fundamentally is that gives you
some slack actually theoretically anyway
you're not supposed to be scheduled two
hundred percent you're supposed to be
scheduled maybe eighty five percent or
eighty percent and have some amount of
spare time to look at stuff it's nique
for the company that intrigues you if
the system works it actually just builds
slack so that people have time to
respond without having so much stuff
that there is absolutely no slack in
their schedule now I don't know how it
works here but it typically worked like
that at 3m was that your manager really
really had to plan on not quite loading
everybody up more than about 80 or 85
percentage after they take off vacation
and stuff you still had to come for the
fact that the person needed to have the
plan was maybe less than a hundred
percent utilization so there was no no
attempt to have everybody hundred
percent use that's not the game to play
every organization that drives to 100%
utilization find itself running up this
curve you can get high utilization by
doing other things but if utilization is
your goal you actually don't get it and
I'm the ging I might be preaching to the
choir are now on here because of I think
it makes sense to have slack if you want
your software development cycle time to
be fast there are some very classic
things to do in order to be fast Market
one is even out the arrival of work
there are companies believe it or not
I'm sure you're not one of them that
says every year we do annual planning
and that's what we're going to do for
the next twelve months we've decided
that's hardly evening out the arrival of
work but there are approval processes
that can get in the way of having a
steady even flow of work it doesn't
really do a lot of good to batch up
stuff into an approval process that is
then going to release it at the same you
know unless it comes out at the same
rate so work tends to arrive in an even
manner maybe it's too much work but at
least it's
putting in processes that batch it up do
the exact opposite of even out the
arrival of work minimize the number of
things in process okay so we talk about
those to-do lists of yours or defect
list of yours or whatever as cues and it
makes no sense to have a very long queue
so for example in Minnesota there were
as doctors offices that had typically 60
days of waiting time before you got a
average appointment and they studied
lean and they said you know we don't
really need 60 days let's see how we can
work it down so they started working
half a day extra meanwhile the
schedulers they continued to not accept
extra people and and try to keep the
scheduled down at least half a day or
maybe even more than that every week
they drove the schedule so that the
backlog went from 60 days to two days
over a period of about six months now
after six seven doctors were a little
nervous about this because you know 60
days feels good but it turns out they
saw the same number of people say mix of
problems everything from the doctors
perspective was exactly the same except
they saw patients two days after they
had a problem instead of 60 days after
they had a problem now there was no
useful purpose played by those cues and
I will propose to you that if you have
long list of things to do they probably
serve no useful purpose at all and if
you can drive them down to two days
rather than 60 the throughput time for
dealing with problems will be so much
faster and you'll see the problem when
it's fresher so the idea is don't even
live with an idea that it's good to have
a long list of stuff to do it really
doesn't do you any good and you're only
dealing with old problems so take a look
at your stuff to do and get it as down
as thin as you can possibly do and then
never ever accept more work than you're
putting out more a little bit more on it
minimize the size of things in process
small things rather than big things I've
talked about that establish a cadence
one of the nice things that iterative
development does is establish a two or
4-week Kayden's regular releases do that
and limit work to capacity so let's go
back to however much work you are
putting out is the rate that you should
accept it in at okay so if you have a
cue the first thing to do is say I have
only three slots in my queue or six
slots I don't care well equivalent of
you know a cycle or two of work that's
all you need one or two cycles of work
in your queue and that's how many slots
you have and if somebody comes in with
something that's more important you
gotta take something out and then as you
go you pull the stuffing out of your
queue and you don't you when that Q is
not anymore got when it has a slot
somebody else can put some work in there
or you can put some work in there but
you push work out and as the work goes
out you allow some more work to go in
you do not need long lists you should be
not accepting work beyond your capacity
to deliver you're frowning yes
so you swamp or four on the ground it's
dead you aren't going to get to it
anyway so I fool yourself let's be
honest instead of pretending you're
gonna get to work you're never gonna get
to just don't just say no you know good
well oh there might be but there's a lot
bigger cost probably associated with
them thinking it's going to get done and
it doesn't so I think it's much worse to
have a lot of people thinking
something's going to happen and it
doesn't if you have an honest q an
honest it's this big and what fits in it
will get done within this period of time
and people discover that your Q doesn't
have space then they have to do
something about it okay if you put it in
your slot and it's if it's not going to
get done it's you have honestly made
everybody aware of the fact that it in
going to happen people that have
customers you know and their customers
are sending inquiries they have much
happier customers when they can honestly
say you know I can't do that then they
have customers saying when are you going
to get to it and they're never going to
get to it you have to have what I'm
going to call an honest cube and that
means keeping it short and keeping it
within the realm of what you can
rationally expect to do now that doesn't
mean you don't have to figure out how to
help people that have problems that
can't get handled but at least you start
making that visible and figuring out
what to do about it um check in this
book and chapter I have a team that
works on this problem in this chapter
okay and some of the things that they do
maybe you can find that one time and
tell me tell me where it is asshole I
think it's on page 16 not 168 okay so
read that section for homework maybe
it'll any more questions on this Q thing
yes
is that you start optimizing as a
support throughput but might be
sacrificing fairness that's what do you
mean by fairness for example let's say
you want optimize something that's
cubase go through or the only work for
the shortest paths you always have the
highest possible but you have the right
size q where the the honesty is
maintained in the queue on the front
okay and the people that have the high
priority or even the big ones get
control of what is there so that your
honesty is served by your Q then when
you pull something out you work on it it
can be big or it can be small but you
can't put it in and if you pull a big
one out then there's going to be one
slot and there aren't going to be any
more slots after that until you finish
that big one so you have enough queue
size so that you can maintain the
fairness it doesn't mean you're trying
to do lots of little things it means you
don't have a backlog any more than you
can reasonably expect to handle that's
the game your plan it's not deciding
which to do it's making sure your
backlog is something that's within your
capacity to deliver
thing at the expense that someone thinks
might never ever get done that will
happen and if that happens you might
need to have 2 q's what we did in our
plan is we had like low priority stuff
moving through and high priority we had
an algorithm that for any time that we
got more than two of these kinds of
things in this thing we knew we had to
make it even though was low paraded
because we couldn't run out of it you
can have two queues and you can have
three of these in one of these you can
have rules they make sure that the low
priority stuff doesn't get done but I
typically find that those have to be two
separate queues feeding two separate
processes otherwise in any case the
little priority stuff won't ever get
done okay so and useful scheduling we
just talked about that so to wrap this
up I recommend three system measurements
at the high level you want to measure
how your system operates the first one
is the classic lean measurement of cycle
time from product concept to first
release from feature requests to feature
deployment from defect to patch whatever
it is that you want to measure you
should have a consistent cycle time for
that and this is a measure of process
capability and then you want to somehow
measure whether or not you're making
money in some way something that's
important to the business whatever the
business case is paying you to do are
you delivering on that thing and the
third thing is customer satisfaction
there are lots of ways to measure
customer satisfaction but this is a
measure of business return this is a
measure process capability and customer
satisfaction is a measure of
sustainability do you have something
that can be sustained on a long-term one
that I like that you might want to look
into is the net promoter score I'm not
going to say anything about it now
because I'm actually not very good on it
but there's a book you could read by
reichheld called the ultimate question
but if you have these three measurements
you actually are probably measuring
everything you need to measure in your
in your ability to do stuff because
you're measuring process you're
measuring financial and you're measuring
sustainability and with that I want to
say thank you and thanks for thanks for
inviting me
you
Oh</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>