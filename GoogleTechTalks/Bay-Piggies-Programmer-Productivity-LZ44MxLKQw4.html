<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Bay Piggies: Programmer Productivity | Coder Coacher - Coaching Coders</title><meta content="Bay Piggies: Programmer Productivity - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Bay Piggies: Programmer Productivity</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LZ44MxLKQw4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so programming productivity what
really matters I'm JJ my mom named me
with the girls named Shannon hi mom I go
by JJ some people were confused by that
I was late and that's because I get lost
not because I'm not productive I get
lost in bathrooms actually so that's a
separate issue I never claimed to be
productive either but that's another
matter so I started life at ecommerce
shops on any commerce shops and well
when I was working in e-commerce we had
a simple philosophy delivered yesterday
code today think tomorrow you know it
doesn't really matter anyway because
you're going to throw it away in two
years so like it that's just fine but
starting their gave me a perspective
where I only care about getting as much
functionality done in as little time as
possible I couldn't care less about
writing assembly language code I mean I
learned assembler in college that's
great but like I want to get done I
want to get stuff done as quickly as
possible and that's really my emphasis
so as an e-commerce guy you always have
too few people too little time websites
get thrown away every two years um so
the interesting thing about websites
getting annoyed thrown away every two
years you know you put a lot of time and
effort into programming I'm a
perfectionist but the funny thing is
there's no connection between good code
and code that lasts a long time
so another reason I care an awful lot
about productivity is that I have three
kids and I have a fourth one on the way
so I'm a little bit busy I work at a
start-up now on top of that but despite
all despite all of that in all this talk
I must be up front and say I'm not a
Productivity expert it's something that
fascinates me and I expect you guys will
just like realize how much of an idiot I
am by the time we get done with this but
I I hope in the meantime to at least
entertain you so so let me define
programmer productivity typing really
really fast so i define programmer
productivity in terms of features / man
month now as part of that definition you
must not sacrifice quality you must
maintain long-term maintainability and
you must maintain the ability to work
with others and whenever possible in
fact we need to improve programmer
parallelization typing pool I couldn't
come up with a better image for a typing
pool that's okay so specifically tonight
I'm not going to cover agile programming
or time management both are more
important in this article so like if you
don't know those you should just like
leave now and go like by book on those
but you know I can't cover everything
in fact so hang on I should have printed
this stuff bigger by the way I'm talking
about productivity I guess you guys
can't see that but I'm time management I
actually use a straight text to do file
which I edit using them because I'm a
vim guy and I actually use this like a
kernel process list which means that I
edit it every time a context switch
which is you know like a lot but that's
great because I've been likely to forget
things in about five minutes anyway and
so that's what a kernel process list is
for okay
I could try but it failed oh let's try
that let's see slideshow settings
let's try
a little bit oh maybe I wasn't ready for
that one oh if you guys want to see that
they're fix bugs for Fox marks in my
personal life write an article about
productivity I think I'm going to skip
that one after this talk oh yeah so
I
the little X's that one
this one
oh yeah doesn't really help I'm sorry
about that oh that's not going to help
oh yeah you I must admit that this is
actually my first time doing slideshow
like I yeah oh yeah now we got to get
back that window that we lost you know
it's shorter no
page up and page down
close this window
Oh
you said view normal oh okay oh okay
thank you okay what I'm also not going
to talk about is how to do slideshows
you know I'm a programmer not at p.m. or
something like that that's an excuse I'm
specifically talking about programmer
productivity okay one more thing I want
to say about time management one thing
that I finally drilled through my head
is time management is about figuring out
what's important and then dropping
everything else you possibly can because
you're never going to get to it anyway
unless it's fun well I mean yeah so I
have my fourth kit coming on the way so
yeah I don't drop all the things that
are fun but like I said there's too many
other sources of information on time
management so I'm not going to cover
those so one thing that I did want to
mention is that there's a lot of false
improvements in productivity I like to
call these red herrings so red herring
is Justin for those like non-native
English speakers red herring is
something that draws attention away from
the central issue so for instance let's
talk about performance versus
productivity writing something and see
that works really really fast that's
cool but that's not productivity that's
performance and in fact I could also
mention since you're looking at me more
I care about performance you know I
gotta write web sites and they got to
show up like you know like a thousand
hits a minute and stuff like that what
that's performance versus scalability
and so we talked about scalability so in
fact in my mind if huh those are big
last long time scallop is in my mind as
long as I could horizontally scale and
throw more servers at the problem and
scale linearly I don't care because the
fact of the matter is I cost a lot more
than servers do I hmm save Leonard and I
don't spend that much on servers so the
simple effective matter is like unlike
like 20 or 30 years ago programmer time
these days is the most precious
commodity so for an embedded programmer
you could futz around like to not that
last you know couple cycles and like if
you have to throw in one more little
tiny piece of hardware you're dead in
the water or use a chip they could do
slightly that's just not the case for
the majority of us I think the majority
of us it's really programmer time is
just the most expensive and precious
thing so I want to talk about limits of
productivity what can productivity not
solve like how far can you go
you cannot rewrite Linux in 24 hours and
in fact if you take every package that's
in Davion with the mate averse and
universe and everything I don't think
like we could rewrite it as an industry
within 10 years maybe 20 I don't know
but there's it's just limits to how much
you could do and especially with
software these days it's freaking huge
so it's just there's limits but
nonetheless I work at a start-up and I
need to get more done we have nice code
we have docs comets tests were pretty
agile but I need more and add
compounding this problem is the fact
that these days it's like incredibly
difficult to hire people you know I we
recognize we have positions open level
you want to be like you want to work at
Fox marks that's great come talk to me
afterwards there's a real shortage of
talented people in the industry and you
know I really thought long and hard
about where all the good people went
okay so my first thing I'm going to talk
about three things work environment
development environment and programming
languages i guess i should cover like an
outline but anyway there's out one so
the first thing is work environment so
lifehack org if I was more productive
and they had more time in fewer children
I would love to subscribe to this but
apparently this is a great place to
become a more productive person that's
all i could say because they haven't
gotten there but i thought i should
mention it so just randomly spouting out
random facts that I've learned but
because I've been reading a lot about
this topic lately having your own office
results in increased productivity since
i don't have my own office i have to
work at the start in fact it's san
francisco so we don't even have cubes I
resort to late-night hack sessions and
I've done that my entire career I've
been doing it 10 years I could do it
once a week if I need to not
indefinitely but um late night hatch
sessions are God's gift to coding in my
mind we've got to get away from that my
wife doesn't like it so much but the
conclusion to make is that interruptions
kill code is long is every time you get
interrupted when you're coding that's
severely impact programmer productivity
because I mean what we do is hard it
takes a lot of thinking you got to get
deep and that's just the way it goes and
in fact recent studies have shown that
constantly multitasking can reduce your
IQ by like 10 points which I mean you
know I don't have enough as it is so I
just can't give up 10 so other random
topics of interest up music or no music
when you're coding I read recently the
tax cask complexity and distraction
should be inversely proportional so I
have interesting equations to convey
this Python for dummies + iPod equals
success
design patterns plus ipod equals much
frustration yeah so so if you're writing
a hard piece of code turn off the ipod
so like in my quest for greater
productivity at that hey if i could type
twice as fast maybe that would make me
more productive and so what do you do
when you want to type twice as fast you
go learn how to use a Dvorak keyboard
and then before I actually did that I
realized quickly that like we're natural
shop and we got to do peer programming
all the time so that's kind of not cool
and I thought hey maybe I could get a
second keyboard and plug it into USB I'm
not sure if that works but then I
thought oh it does that's great um oh
but what about all those times I have to
like go to like my dad's house and like
admin has linux box and he doesn't have
a Dvorak keyboard and although if you
notice this shirt it's a binary shirt
which I'm pretty proud of that so is
that Lennox using grandpa uh but to
summarize about the diversion typing's
are only not the problem a like typing
is a small part of coding if it really
came down to typing like I really could
rewrite Linux in like a year I probably
could type most of the Linux source code
in a year because I do type pretty fast
but it's not really about typing so on
to development environment be a whiz
with your shell and your editor be a
master continually polish your skills
know your shell i'm pretty sure i have
one of the red ones so being a shell
newbie is a clear waste of time you're
sitting there you're looking at your
shows you're not spending a lot of time
sitting thinking like when i'm in front
of a show my fingers are going and so
being able to go faster as a clear win
so similarly being able to script common
tasks that is a clear productivity
improvement I mean not being able to say
you want to rename all the files in a
certain directory that's trivial with
the for loop it's trivial to write two
for loop if you do it by hand you're
wasting your time similarly like one
touch installs I mean I can't say enough
about that I mean everyone knows you
need one touch installs things like that
Todd I'll get to one touch installs
later this week similarly editor macros
can be clear when I don't I don't end up
using those all the time but sometimes
you're working on a piece of code you
need to do something repetitive and a
Mac will take something down from six
hours like half an hour if you guys use
bash or Z she'll just as a random
comment you guys know about control r
which is history incremental search
backward so you're typing bunch of
commands and you like control are and
you type part of the command and you go
up to the one I love that on that that
huge productivity improvement so because
I'm constantly honing my skills i
recently switched to z show and i like
it and it's making more productive
already the funny thing about it though
is if you read the docs it seems like
there i'm not sure whether they're more
like obsessed with programmer
productivity or just general tinkering
and that's greased lightning you guys
remember grease ok ok so making your
editor fly yeah one interesting thing is
one of the best programmers i know
kellyanne's see he uses pico and i just
can't understand that like and the funny
thing is that my previous company i
worked for a guy named um um all brain
deadness mark he was a freebsd committer
brilliant guy used VI and refused to
switch to them which
them has clear predictive the
enhancements with like no additional
cost I mean it's still wickedly fast and
so there's one thing I've really noticed
I've talked to a lot of people because I
like to tinker and like there's no
connection between like skill of a
programmer and skill with an editor in
fact oftentimes I find that really
talented programmers aren't that great
with the night over and it just it
shocks me but you know that's the way it
is so I had a buddy who was an emacs
user very very productive not one of the
editor newbies and next point by the way
one thing that he and I discussed and
and King became clear in my mind is user
friendly is not what you want to
prioritize for in your editor we're
programmers we spend eight hours a day
in an editor we know how to use the
things I know how to use mine I you know
I know them inside and out and so it's
like user friendly if it comes out of
the cost and productivity not so cool um
so perhaps one of the reasons why being
a whiz at your editor isn't the end-all
be-all and making a good programmer is
that in fact you spend more time reading
code than you do writing code and so I
mean code is read like three four times
to every time it's written maybe more
you know I don't have a like I count or
anything like that but it's obviously
read many more times than it's written
and so I don't know how fast he typed
that but I can't read it no matter how
much time I spend on it anybody know
where thats from well done international
offices skated see coding contest huh
yeah it has to do something so hence
being able to enter code really isn't
the limiting factor you spend more time
thinking than you do actually typing I
spend a lot of time thinking or at least
that's what I told my boss it's like I
had to put it in there somewhere so the
flipside of like having these awesome
editors is like you have these eclipse
guys and stuff like that that like have
these wicked fast editors have you guys
ever seen a screencast for like PHP or
ruby on rails guys it's like going and
like the editors typing half the code
and it's like you know the Eclipse can
generate all your public properties for
you I personally feel that generating
boilerplate quickly is actually more of
an insult than a benefit so for instance
I asked my buddy because I'm not a job
expert I mean I know Java but I'm no
expert I said can you give me a class
that has three properties in it it
didn't fit on the slide so his his ide
generated that for him and that's great
except for its not because you can't I
mean there's three properties there you
can't
read that well probably because it's too
small you guys are an audience but I
can't read it so similarly just the
other day on the Yahoo user interfaces
blog there were these guys who checked
out there text me to you know do that
whiz-bang thing where you quickly edit
inter code and here you can see they
typed like a few characters and then the
menu pops up and you select stuff and it
automatically puts in stuff free but
look at the code it's like Yahoo u tilde
Dom yahoo dot util dot like thank God
Guido gave us import you know like we
don't have to type that stuff it's a
waste of time to look at it let alone
type it but despite the above do learn
how to type and do become an editor
wizard so the funny thing about people
who don't know how to type I'm sorry fun
like insulting you some people could
type without my touch typing and do it
really fast but like I've seen often
times that people who don't know how to
type in can't control their editor
quickly their mind works faster than
their fingers doing in my case my
fingers work much faster than my mind
but the drawback of your mind working
faster than your fingers is that you
don't follow the style guide a lot and
I've seen programmers who are just like
wicked smart awesome memory and what
they do is they go on Google they grab a
piece of code from some random project
they paste it in they don't reformat it
and they don't comment it it doesn't
matter because they have amazing
memories they know where it was from
they know what it does and they're never
going to forget so they don't need
comments and their brains work so much
faster much faster than mine so they
they could part visually parse it and
they don't need to reformat it but like
I'm sorry I can't do that and when I
reading other people's code I need it
like indented properly it makes me
faster and remember I read more than
other people right so I'm what matters
so recently thanks to our editor Wars I
got interested in wing ide and I thought
hey like you know it's just going to
make me more productive switching to win
AI de instead of them and so it's really
a trade-off in raw editor performance in
terms of like I know them inside and out
versus wing ide which could show me
documentation as I'm going instead of
like what I usually do which is referred
to the Python shell and I'm kind of in
the air about it like I gave it a try it
and don't tell me that the vehm key
bindings in wing IE exist because
they're just not the same it's probably
true for emacs but just not the same and
so I'm kind of at a loss and like I
maybe I'm getting old and closed-minded
but I'm sticking to them but like what
if you want the best of both worlds well
maybe not so no one-size-fits-all and if
I did need to be in a certain mode I
probably would use both like I think
it's a good thing to be open-minded and
switch back and forth whatever anyway
programming languages mmm let's not go
there so let's talk about some red
herrings as far as programming languages
optimizing for code size you guys can't
see that more can you that's some APL I
think the top one like finds prime
numbers you know there's that saying
it's the dream of a recoder to like
right APL program and actually have it
compile I wrote one that had just a
comment one time and it compile it but
like when we had a PL when we the APL
experience perhaps like the Pearl
experience taught us that shorter code
isn't always better like I said you get
it
Alex I stand corrected thank you I'm
young
I mean that in both ways like pretty
young um I do stand corrected so I was
recently in a crew like in a functional
language crazy mean a lot of us get into
that sometimes and so you know I went
through a camel I went through Haskell I
wrote two articles on haskell as you
guys probably saw my recent love affair
was with her laying I was in love with
Alice for a couple days Alice the
language not the music not the radio
station and the one thing I've noticed I
put a lot of effort into Haskell but
there's one thing that's interesting and
that's that when you call a function and
you read a code that calls a function
for us programmers you don't have to
know what the function does I mean you
look at the name and you kind of know
how what it does and like that's enough
I mean our minds work with that but when
you deal with new programming constructs
such as monads you could look at it and
unless you know exactly how that monad
is implemented you can't read that code
so for instance just like um just as an
illustration I love a pile of lambda
reduce all of that stuff but unless you
know what map does that's not a new
programming constructs just a function
but unless you know what it does that
top ones not readable but the bottom one
like for someone who doesn't know python
the you could probably squeeze by and
it's worse when you have difficult
programming constructs and so as much as
I love functional languages as much as
you know I want to be predictive I
realized the fact that like look I could
code Haskell code and I could read other
people's Haskell code but unless I know
every single one of the libraries with
all the the monads and understand all
those interesting higher-level
constructs I can't understand the code
in so I'm not saying it's bad but like
it doesn't impact productivity
so similarly the same thing can be said
about heavily Mac Erised lists code so
common list macros rule so I've been
told I'm sorry I haven't done them I'm
willing to believe that they rule i'm
willing to believe that dsls or cool i
like dsl's actually you know i do simple
ones like you know within the limits of
my environment those are cool but in
particular when you have control over
dsl such as in common list you could
look at co and it might be short but and
that's cool and I don't want to knock
that but like I do want to remind you
that like you really don't know what's
going on first you don't really
understand the flow so much is as what
the function call you know you call a
function that comes back but with the
dsl and certain situations god help us
you don't know and so i want to say that
dsl's are wonderful but they are a
two-edged sword they could cut you they
could make things better I mean you just
have to understand that you know hammers
can kill people so the next fallacy I'm
sure that there's going to be
programming functional programming geeks
out there who going to hate me okay now
they already turned off okay so
optimizing for don't repeat yourself
versus code size so I've invented this
new programming language called Python
zip it automatically reduces code
duplication is the most succeed a source
code ever all code conveniently fits
inside a single file you have to use
this great new editor called hex edit to
edit it but like fantastic programming
language and so yeah mmm optimizing for
dr why and code size ok so there's some
limits but nonetheless do embraced dr
why don't repeat yourself copy and paste
non productivity
so one time I would I had the benefit of
working with up with some outsource
resources and my boss gave me some code
he says hey can you cover view this we
just got this stuff in and I was like oh
wow it's like eight hundred lines in one
module he wrote this really fast and so
i'm looking through the code and there's
this comment that says oh underneath
every function there would be this this
comment that says this function was
imported from some file import is not
the same as copy and paste refactor it
you know if you can't import it directly
for whatever reason refactor it and
don't copy and paste it's evil so if
we're going to think about more
productive programming languages what's
an approach well we could take our code
and look at it and take a red pen and
start crossing things out that don't
actually matter so I've taken this Java
code and okay watch closely I got rid of
the truly braces in the semicolons I
feel more productive already so okay
more seriously let's take a historical
perspective on what we've been able to
get rid of from our code so we no longer
think about register allocation that's
fantastic GCC does a better job than I
could ever do I guarantee it to Stallman
smarter than me although I'm better
looking
as far as memory management we don't
think about code overlays we don't think
about a OS memory pate I mean we do
think about OS memory paging that was an
improvement back in the old days with
cobalt they didn't have dynamic memory I
just can't imagine like every time I
hear that I think oh I'm going to
generate a huge array and like implement
Lisp and COBOL or something like that
it's just I just can't imagine that but
these days we've moved from C to like
languages where we have full memory
management and in my mind that's a of
course I mean that's just a wonderful
thing I mean if you're not writing it
device driver it's great and hopefully
one these days we will be writing a
device driver with memory management but
I'm speaking outside my field of
expertise so I could be an idiot
similarly error handling and see so I
read the Linux programming book and I
learned how to read along from standard
in and I packaged it in a function god
that sucks like look at the error
handling that you need to do to do it
right that's just bad and I'm glad that
like with Python exceptions and like
these days things are just better and so
we've come a long way is what I'm saying
so but still the rest of the world isn't
completely caught up with this hips
licking cool Python people see if I know
what that does I mean it just creates a
list you know I know Java pretty well
but like arraylist I mean I learned that
by reading Bruce Eccles web log that
like arraylist is the one that you want
to use by default without thinking like
if you don't care because like
ninety-nine percent of time I really
don't care I just wanted something
reasonable and if I need to tune it and
pick a different implementation of list
i'll come back and the second line
that's to get the last element in the
list and that's just the travesty i mean
at the very least it could have had a
method call but like hey you know guido
gave us you know brackets with the neck
one so like ooh you're right thank you
that is wrong it should be a space I had
a Java program and review this yeah and
I know but I'm seriously saying I had a
Java programmer review this and because
there's so much verbosity he didn't
notice that is what I'm saying and
that's a problem hmm so what's really
next the fact of the matter is Java and
C sharp Python Ruby PHP and perl they're
kinda in the same categories I know that
like half a you'll want to kill me for
putting Ruby in PHP or PHP especially in
the same category but like they really
are in the same class and we're not
looking like a level beyond and so you
know I'm sure the functional programmers
out there will say I Haskell's the way
Bianca spent a lot of time maybe it is
you know maybe like the next thing is
getting rid of type declarations and
letting the compiler be smart enough to
like automatically recognize them but
the funny thing about like coding in
high school and like I could say this to
a Python trot is that like I spend twice
as much time thinking about types by not
trying I trying to not think about types
as like in Python were like I could
really not think about types more
effectively and so here's an example so
i wrote an article called um i don't
even remember me i wrote a c-type
declaration and parser and haskell it
was cool so look at that first line get
token colon colon state parse context
less than greater dinner so
i kid you not I spent two days learning
how the state monad works I've read it
on Wikipedia I think I've read three
separate tutorials I admit I'm not a
genius there's far smarter people than
me and I understand it now but my god
how does that like those those words
like compared to the thing that's what
I'm talking about were like higher level
constructs they don't like unless you
know I'm backwards inside and out like
it there is some cost and in fact
someone who doesn't know the state monad
like he's not going to understand that
and yeah that's all I have to say about
trying to get the compiler to be smart
enough about types hopefully you know
there's a bunch of Python projects where
you know the compiler can assist you and
be smarter like a cyclist cool that's
awesome because it doesn't require me
thinking about it and any time I don't
have to think I think it's a win or in
fact I don't think it's when it's just a
win okay
so the mythical man month says that
there are no silver bullets you're
screwed I'm looking for copper slugs
made in bulk that I could buy it Walmart
so Burke argues that there will be no
more technologies or practices that will
so serve as silver bullets and create a
tenfold improvement in programmer
productivity over 10 years i think it's
10 years has passed but the face is
often quoted and applied to productivity
quality and control i got that from what
the pedia hey you know Brooks was a
smarter guy than me and I'm not going to
like contradicts that one of the key
things that he mentions is accidental
versus central complexity at the heart
of the argument is the distinction
between accidental complexity and
essential complexity accidental
complexity relates relates problems that
we created on our own and can be fixed
for example the details of writing and
optimizing assembly code essential
complexity is caused by the problem to
be solved and nothing can remove it if
users want a program to do 30 different
things than those 30 different things
are in central and the program must must
do those 30 different things so we're
stuck with the essential complexity so
well you know you guys have waited a
long time you ready for my solution
there's only one solution to this mess
think less let someone else do it and
I'm serious like if I'm coding my day
job the less stuff I have to think about
to get the given features out the door
the better if someone out there has
already written a program that does
exactly what I need I'm going to use it
and what's better is that they probably
had to think about the details that I
could remain completely ignorant about
so the interesting thing about being
able to think less is that most coke
these days is about organizing
presenting ensuring data
there's no it's all those crud create
read update delete sequel the web okay
these things are God sentence in my mind
I I still argue that like within the
last 30 years I haven't been coding for
30 years but like number one best thing
in the world the internet number two
sequel many people will think that
that's silly but like if you guys could
remember a time before sequel when you
had to like manage your data on disk by
hand my goodness like people these days
they're like oh I don't want to have to
write sequel statement you should be so
thankful that you have to write sequel
statements when I was young we stored
the date on the disk we coated uphill
both ways yeah so there's three there's
a couple of techniques for thinking less
so the Ruby guys are probably laughing
at me so of course there's convention
versus configuration so you just do
things the right wing you don't have to
think about all the weird details of not
doing things the other way policy of
least astonishment that one's great so
both the freebsd guys and the Ruby on
Rails guys embrace this one this is the
way this is their way of saying look
we're Japanese speakers and we don't
write English comments very well so just
it's going to work the way we say it the
way you think it would okay sorry that
was bad sign I really like the guy who
wrote Ruby anyway policy of least
astonishment says that it should work
the way you think it's going to work and
the nice thing about that is is that
that means you don't have to think about
the details because they're the way you
think that they should be the next thing
is embrace the 8020 rule and as a
perfectionist you know this is something
that I struggled with for a long time I
mean there are people who could code
circles around me but my code is higher
quality and you know what like there's a
big benefit of getting eighty percent of
functionality for twenty percent of the
work and like anytime you could do it
that's awesome
I'll create read update and delete and
so it's like with data you create it you
read it you update it and delete it's
what you do with sequel select insert
update and delete
so now that i'm finishing tell me more
like half the reason why I wrote this is
because I admitted that I'm not as fast
as I need to be I met a startup I need
to get more stuff done and like I expect
you guys to call me an idiot and tell me
how to do it better and when tomorrow I
start coding twice as fast i'll actually
be really thankful so there's my email
address or you could slip me a piece of
paper because I guarantee if you just
tell me I'll forget it so please don't
just tell me give me at least a piece of
paper Nina okay Alex so my favorite
suggestion for time management is a
notch is or I'll ebook Tom Lehman celli
time management for system
administrators I was not sure why I
actually started looking at it because
I'm not a system administrator at least
ninety percent of the book is fully
applicable to programmers as well I
really hardly recommend it I actually
Tommy's now I working at Google but he
wasn't when he wrote the book so awesome
make sure you give me a piece of paper
an email please Alex make sure you give
me that on a piece of paper or an email
thank you that's awesome yeah list yeah
Dennis um I find I spend a lot of my
time correlating looking things up
trying to read for different source
programs so i can trace things through
and a couple reference books and an api
and deal and you didn't really address
that is where the thinking and analysis
time goes you some pointers I max my
resolution as much as possible and I
have virtual desktops I have four of
them in fact so one two three four I
know where everything is at all times
because I put things in the same place
every time and I I always look at expose
and mac and you know god help those
people that was great because they were
needed but I think that if you're
looking for something you've already
lost the battle you need to know where
it is ahead of time and so I have
multiple tabs open my firefox that could
fit many terminal windows and
editor windows on the same screen and
that's how I deal with it search worth
yeah so that was one of my list as well
big monitors I know that that's that's
almost religion around here but a couple
big 24 inch monitors helps a lot so one
of the things that I got a few years ago
was the testing religion which I know
you guys but so we have a rule if you're
reading code which you do a lot more
than you're writing code and you see
something fix it because we're a small
shop and we have the test so just always
fix it even if it's not your code or if
you can make it cleaner nicer looking
anything like that just fix it do it
right then and there so I think I could
address that um that's awesome we have a
slightly different rule and that's that
we use our bug tracker like crazy and
I'm really a big fan of small bugs
because they make me feel productive
when I'm in between large bugs and so I
i'll create quick buds real quick so i
don't have to lose my train of thought
because i don't have enough swap space
up there yeah yeah i think there's a
difference between sort of the bug and
the the docs could be a little better
here but but that's a good one as well
the 8020 rule i'm also a big believer in
that we've we've kind of taken that I
don't know one step further a little bit
different we say the programmers part of
the program so we don't know often we
don't have a product manager at a little
side a little startup although we're
hiring in any case so we don't know
sometimes is this going to work as it's
not going to work so if we can prefer to
do something manually like if I have to
read something on the screen and then
type it in and read and type it in
retype it in as part of the ongoing
running of our application and it turns
out that wasn't a useful feature I
haven't wasted any time coding I haven't
wasted a lot of time coding so the
programmer can be part of the program
and if it turns out I am typing a lot
then well then I'll then I'll code i'll
do some work to automate i think that
that meshes nicely with the extreme
programming eating's that deferred
decisions because decisions require
thinking yeah and the last one the last
one is is a matter of servation i think
you're very good at this at least in my
limited observation that is just be
relentlessly curious you know
discovering textmate or z shell and if
you throw it away great you know you
look you tried am I going to be a little
bit better the only trick is you got to
make sure you don't do it for eight
hours a day right
but you're an hour a day just driving or
listening or whatever if you're always
curious always seeking something new or
better you know a little ten percent
here ten percent they are pretty soon
well it's eleven percent I can't agree
with you more if you're not curious if
you don't love your work go home I was
hoping you would mention this so if
you're having three four shells 24
editors a sequel prompt under my sequel
server or something else running you
need screen screen rules brain I've got
my own complaints about screen it's a
tool that we all must have and I hate
but anyway yes I agree though so one
thing I guess about you know when you're
doing a lot of sequel is to keep things
broken down as much as possible into not
like not abuse equal but you know keep a
very Cuba very simple scheme if possible
don't do a lot of joins and that keeps
your code in general a lot cleaner
especially when you end up having to
scale just makes it a lot lot cleaner I
just in general really simple design
patterns absolutely anytime you can
embrace simplicity that's definitely a
win yeah I agree
Oh No so we had a talk about simplicity
today by a guy from the MIT media labs
he's got this John Mead he's got this
book just just out well simplicity and
he's got the 12 rules he's a very funny
guy I've dealt with non-normalized SQL
schemas in my time and the point was all
but if I do normalize all how to too
many joints and it will be complicated
and there yes I haven't really committed
many murders in my life but if if I look
at what murders have done in my mind I
think that majority was about this
because people there's a view statement
oh no I used my sequel well then go get
a database instead and you view and and
by the first rule of simplicity actually
as the mighty say cause it encapsulate I
have all the joints you need underneath
and make a view that looks like a table
is simple to use but if I have to see
yet one more non-normalized schema I
hope somebody will rule justifiable
homicide because I am going to a good
point as simple as possible and don't as
simplicity is not an excuse to do
naughty things hey JJ just a comment
down at my current job I'm doing
something a little bit different than
I've ever done my programming career so
the management is adopting this a bit of
extreme programming where you're only
assigned tasks which take at most three
days and so what happens is they write
these tasks down on cards and they put
these cards up and you estimate how long
you know between one and three days with
half day increments and you choose you
know you basically determine how long
they taking you know as you finish each
task you throw away the card and you're
done with that you move on to the next
one next one I find that's a good way to
keep focus I don't know does that has
anyone ever done that so actually we do
do that
and I didn't cover it because XP book
was better than I could get like convey
up here and so I kind of like I didn't
talk about agile programming but in fact
we do do that sure that's good it is
very good and helpful one of the things
that I still question about it because
you know again I'm new to this is that I
feel that because you're trying to turn
around these things in very short order
that I feel like I'm not spending enough
time architecting a solution for cards
that haven't been written yet and I feel
like I'm throwing away more code or
having to rewrite more code than I used
to when I used to do things the
old-fashioned way so that's the only
thing that kind of bothers me a little
bit about the she's on the cards and the
show Leo said that it's easier for me to
build a 3 inch telescope lens and then a
5 inch telescope lens than it is for me
to build a 5 inch telescope lens so
sometimes I'm like if we writing we type
fast refactoring it's good you can't get
it right the first time because if you
you try to make it complex you'll get it
wrong and then you'll have complexity
for no reason so it's okay it's it's
okay to like start off simple and then
refactor that's the that's the secret
that's the magic sauce well I'll see the
other thing that I fight against also is
my perfectionism as well because when I
want to do something I'm going to do it
right and something that could be
expanded on more very plug-and-play
oriented that for things that you
haven't even thought of yet and so this
sort of changes that where I can't think
is deeply or be like a real architecture
on now I'm now an efficient programmer
but I'm not as much of a software
architect so I don't know if that makes
any sense so so the thing is you have to
internally change your definition of
perfection and I've actually faced this
just as well if you try to make it the
most flexible thing in the world it's
going to end up looking like C++ and
that's all I have to say about that I
yep you'd mention this witticism about
working on our you're expressing your
preference for working on a number of
small bugs in between the large bugs
which got me to thinking do you actually
do strict test-driven development
yourself
okay so I'm going to show my dirty
underwear just like everybody else in
the world were in cases where I know
what the test is going to look like
ahead of time I do like writing it first
but like I am a web developer and so
there's a substantial amount of stuff
where I just want to see something
because it's like I can't write a test
that says make it look nice and so I I
do fight with that and so I could
honestly say I don't test I'm not always
test driven I'm not saying that that's
good or bad i'm just saying what i do
well if Alex can talk twice then I can't
do so to your question or to your
concern so I have to flip the bit
sometime you know I'm I am I writing a
library or my an application developer
and and sometimes you don't know right
you're writing an application and that
code is going to get reused by others
but sometimes you do have a good sense
and so you can't play the 8020 rule and
again just be perfect on the eighty
percent or the twenty percent that
implements the eighty percent the last
of my last comment because I find it
hard to shut up is that the comment
about keeping your schema simple i think
is really good but you have to watch out
for the local complexity versus global
complexity issue so you know if i
simplify the schema is that a local
minima are and that's going to cause me
to have a huge number of back-end
servers and horrible performance and so
forth so i think well that's definitely
laudable to keep your scheme as simple
the reason why our appt scales i think
as well as it does is because we have it
extremely complex sequel implementation
now hopefully the core part of the
schema is understandable but we do a lot
in the database and and try to avoid
getting to the database as much as we
can but when we're there we try to be
very very very efficient and when i look
at the design patterns that come out of
some of the object relational mapping
systems systems like like django which
is great for lots of things it tends to
be really simple in the schema and
really complex in the python and I think
that sometimes that can be a big mistake
sometimes so yeah I'm really a fan of
having other programmers write the
complex code I have to admit I mean
especially if it's a library let them
deal with the complex stuff make it as
easy as they possibly can for me please
let me do bracket negative one bracket
so yeah I agree
since everyone's going for seconds about
the keeping the scheme is simple one
thing you guess you said leverage you
know external libraries as much as
possible was one of your comments and
trusted the other people are just
smarter than you i would say trust but
verify because there's a lot of good
python there's a lot of great python and
there's an even more like there's a
humongous minute crap and jake sure it'd
be very careful about the internals and
it really you need to have more than a
passing interest in how it actually
works if you look at like a lot of these
especially object-relational mavors that
is like a big pet peeve of mine that
they're all kind of Kroenke so just
minimal levels of abstractions are
usually a lot lot better yes actually I
do agree i'm pretty picky about which
code I Poland I just don't randomly
start pulling in stuff in fact some of
my co-workers get mad at me because i
have like certain feelings about who out
there writing open-source libraries like
writes really good stuff and who writes
stuff that sometimes you have to think
about and look carefully and so yeah
like just because somebody else wrote it
didn't doesn't mean it's better than
yours in fact it's often not the case
it's when you can trust someone I I do I
mean anytime you can find someone
smarter than you and trust them and and
no that's good that's great like I trust
Apache I trust glial I trust Alex I
don't so much trust a lot of other
things so dennis is going to kill me um
we have one more question do we want to
let it slide just when we're comment
okay but is the same thing is just make
sure someone consumes your code or uses
it that always helps to do you know
that's it thanks
thanks for your time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>