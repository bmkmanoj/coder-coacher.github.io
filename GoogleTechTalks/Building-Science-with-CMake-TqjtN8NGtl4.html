<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building Science with CMake | Coder Coacher - Coaching Coders</title><meta content="Building Science with CMake - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building Science with CMake</b></h2><h5 class="post__date">2015-10-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/TqjtN8NGtl4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi thanks everybody for coming that's my
pleasure to introduce bill Hoffman from
Kibler
he's here to talk about building science
with CMake bill Thank You Patrick
okay so I'm here today and I'm gonna
talk about building science with seaming
he makes a build tool and normally you
think of building software quick
introduction my name is Bill Hoffman I'm
one of the five founders of kitware
incorporated I was the originator of the
C make build tool and about five years
ago I picked up running and that's some
ultra runner with a run in sandals so
that first picture over on the left is a
Tech Talk I did on C make C pack C - C -
that I did about six years ago at Google
in New York you can see I don't have
quite as many gray hairs that picture on
the right is me finishing a 50-mile race
quick introduction of kittler kit where
is a open source based open science
company we develop collaborative Rd
software and we have several main areas
we have an HPC and visualization medical
computing a computer vision group data
and analytics and then right in the
middle is software process and that's
really what I'm here to talk about today
is our premier software process tool is
the C make build system and how it ties
all these together and enables science
to move forward we do collaborative R&amp;amp;D
software where we create algorithms and
applications we help people with
software process and infrastructure we
provide support and training we play a
leadership role in many open-source
communities and we work with industry
government and academia we were founded
in 98 we have offices in upstate New
York that's where I'm at North Carolina
New Mexico and Lyon France scientific
method let's let's go back to the
beginning here 16:37 doubt everything
and only believe in those things that
are evidently true or reproducible if
it's not reproducible it's not science
we're all Society 1640 take nobody's
word for it so an interesting thing has
happened since then computers and
computer software are driving science in
fact the former NSF director said that
software's replace mathematics as the
modern language of science so in the
past where you'd have you know equations
right now like that they look more like
this today but did not show there we go
they show up in code and to prove that
they work you have to run them and to
run them you need the data the input
data and the expected results and you
need to continually refine this so that
the great power of software is the the
many amazing things that we've been able
to accomplish with it but as far as
reproducing in science it actually has a
heavier burden and it's harder to prove
that the software is doing the same
thing all the time and this shows up in
modern science and our problem this was
in nature March 2012 and they found that
more than 90% of papers published in
scientific journals describing landmark
breakthroughs in preclinical cancer
research were not reproducible or just
plain wrong and the lot of this was
probably computational a lot of it was
because it was papers that weren't
reproducible and there's there's all
kinds of issues behind that I want to
get into all of them but reproducibility
is key to science I mean it goes back to
the roots
science if you can't repeat it then it's
not true so see make actually came from
an open science background now this is a
really interesting story I think so one
of the early projects with kitware was
with the National Institutes of Health
National Library of Medicine the visible
human project
so around 1994 1995 they created a data
set the visible human project and this
data set
they took bodies that were donated to
science and when they died they C T M
are scanned and saved those datasets at
the highest resolution they had at the
time but then they did something
interesting they froze the bodies and
sliced them as thin as they could and
took pictures so now let's imagine your
algorithm writer that wants to segment
the heart out of an MRI or a CT scan how
do you know you got it right
you can't cut the patient open that
usually kills them but in this case if
the patient's been pre killed and cut
into many slices and you can go back and
register that and so they created this
data set but then dr. Terry you had the
foresight to realize that it's not just
the data providing the data the
community is great and good but really
what you need to provide is the
algorithms because that's that's where
the key is the algorithms that do the
segmentation and registration as we go
to like your regular sort of PhD student
right the the professor reads something
it says Liz looks interesting hands a
paper to a grad student and says we'll
go off and implement it you know here's
a neat segmentation algorithm go go tell
me if they did it if it's useful to us
grad student disappears the other off
type type type type type type yeah three
months later comes back and said yeah
did mark did the grad student implement
the paper wrong was the paper wrong in
the first place there's so many
variables there so tell you that the
concept that really what we need to do
is take that code
state-of-the-art in segmentation of
registration and create a toolkit and it
had to be cross-platform and had to be
easy to use so grad students and their
professors could grab an algorithm the
state of the art and build on top of it
and not have to re-implement the wheel
every time so in 1999 this this project
was started coincidentally with the
start of kitware and we were tasked with
creating a build system for this beast
and the only parameters we were given is
that it had to work on Mac Unix back
then I think it was more like spark
workstations and things and Linux and
Windows so I remember one of the early
talks I gave when I was pitching the
whole CMake concept it was at the
National Institutes of Health National
Library of Medicine I was in a big
auditorium and I was pitching this idea
of my new build system and one of the
guys from CMU sort of raised his hand
bill why are you creating the itk build
system it's gonna be this weird thing
that's different from anything else in
the world it's just this itk thing and
but before he turned it over and let me
talk he said oh wait wait I think I see
what you're doing you're trying to
change the way everybody builds C++
world domination so that's that's what
really that's like yep you got it that's
what we want and eventually that's
that's kind of where we ended up but one
of the analogies that I like to give I
saw David Abraham's he was the one of
the main founders of the boost project
talk about what drives that project and
he showed a slide with Java and hundreds
of really useful classes that come with
Java and then he showed one Python and
Sears all these hundreds of useful
classes and here's c-sharp and here's
all this really useful stuff that comes
with it and here's C++ and we have
iostream library that's it
so boost aim to give C++ that rich set
of features and also a breeding arm for
the for the next standard so as the
were actually tried in an open-source
way and a reproducible way they could
make it into the next standards of C++
well C make aim to give C++ the compile
time portability now we can't have
compile once and run everywhere like
yeah but Java or some of the scripted
languages but we can certainly have the
same build file that works across all
platforms and have that compatibility
and also the ability to take these
different libraries and mash them all
together and get them to work and get
them to work with a little bit of effort
so the same build tool for all platforms
easy to best mix both large and small
libraries and work across a wide variety
of computers and I think so one of the
interesting things I like to throw on
this slide so you see the big
supercomputer there and the work we did
to get C mate to work and the
supercomputers actually helped us get C
mate to work on phones because building
for a supercomputer is much like
building for a phone or a tablet because
you have to cross compile to it the
computer you're using to do the
compiling isn't the one you're running
on and these supercomputers are
essentially a whole bunch of sort of
special purpose processors and small OSS
so you're not actually building on those
nodes so that was sort of interesting
that this whole HPC thing actually
translated into the mobile universe
which became very popular and see make
is the most popular kitware tool out
there that we do and admittedly probably
the most boring thing we do and pretty
much everybody hates build systems and
it's got its problems but it certainly
has become sort of the standard because
it does it always has been sort of a
pragmatic tool that got the job done and
that in 2006 the KDE desktop community
adopted seeming as their build tool that
was sort of an interesting little bit of
story there they have their yearly
academy conference where they get
together and decide things in purse
and it was scones versus emic and there
was a guy Alex 9rf who was the big see
make fan and there was a couple scams
guys and they met in at this Academy but
Alex couldn't make it so the scams guys
won and Alex sent me an email sorry you
know we lost I couldn't go I couldn't
make the arguments and I thought well oh
well too bad stuff happens and probably
six months later Alex sent me an email I
said hey I think we got a chance it's
been six months since the meeting and
they still can't build the core
libraries in a reliable way on platforms
because I think if we made our move
there people are getting upset now
they're complaining on the developer
list and Katie's always had a philosophy
of he who codes wins so I said all right
and I took a couple guys at kitware and
we we jumped on it we worked with Alex
and in a week we had the core libraries
building and I think in about a week and
a half we had a building on Mac OSX and
then probably a couple weeks later we
had the core libraries building on
Windows and sort of it took off from
there and it was probably one of the
best things that happened to see make
because it brought a lot of structure to
see make and and forced us to implement
things like proper shared library
versioning proper install things and to
work in a normal Linux environment
whereas we were a little bit more loose
when see make started and we followed
more standards with this and it also
sort of solved the chicken and the egg
problem so you have to have C make
installed to you C make to build but
people would be upset well I don't want
to install this extra tool and one of
the things driving C make is that we
always the requirements I put on is it
would only depend on a C++ compiler so
that's why I didn't use another language
or depend on Python or god forbid I had
I picked the language of the day it
would have been tickle I'm back in 1999
so as bad as the C make languages people
maybe it's better than it's not tickled
because it probably would have killed
Semak
if it was a tickle project but the main
dependency see make has is the C++
compiler because I figure rebuilding C++
you're gonna have one of those around
and that's done well for us as we've
moved to new platforms and the ladder to
adapt really quickly and this shows some
how it got sort of 2006 you can see
Google search trends on auto comp and
automate get surpassed by C make and the
other one is an ol o chart showing a
number of commits going into projects
based on C makers versus Auto tools so
you can see we're growing there and we
get some ridiculous number of downloads
a day like five thousand downloads a day
from the C make that org but it's also
in all the major distributions also in
2014 the company JetBrains wanted to
develop a new C++ IDE and they did some
market research to find out what build
systems people were using and they found
C mate to be the highest adoption out of
there they estimated 4.4 million
worldwide C++ developer community so
there we go
world domination now back to science
science is not being done by one mad
scientist anymore the problems are
bigger the tools are bigger you're
working from the atomic level all the
way up to macro level and there's
software all along the way
remember code is the language of science
now and well it was out here at Google I
talked to the robot operating system
folks and found out that they have a
huge project that has up to 12,000 lines
of CMAC code and it's hugely popular and
very big there's 2,000 packages and
they're indigo release all of those
package as far as they know or see make
projects or at least wrapped in see make
and they're contributed by roughly 370
different people or groups based on the
contributions in their github
make me accept about 6% of the code
about 12,000 lines of code for the Rasta
indigo code base I'm not sure that's a
good thing or a bad thing but it
certainly enables this this platform to
be created an open source platform for
robotics here's the 2,000 packages in
there build status I can't show them all
but they went from A to Z and there was
pages and pages of them all of them
building reliably across you know all
these different machines so how do you
wanna you see me so it's it's easy and
it works well so it's a build system
that just works it's what I'd like to
say um and it's a build system that's
easy to use cross-platform so this an
example I like to use the curl library
and you can see their their build system
is in red and you can see they've got
all kinds of stuff like make file that
walk comm make file that in netware
visual studio a some amiga thing a
Visual Studio 6 file and my guess is
that at any one point in time all of
those things never worked in their
codebase along the way people
contributed you know hey I got to work
on amiga here's to make finally post it
in there and so it might work but if
it's C make you're gonna have you know a
C make list file in each directory and
maybe a see make module thing directory
and it's gonna be a few files and the
project is gonna be able to outsource
the maintenance of all this stuff for
the C make development team so that's a
huge win for anyone adopting C make as
long as your platform is on the nightly
regression tests of C make you're
guaranteeing that we're gonna we're
gonna maintain it and as as we go
forward we'll know if we broke your code
because we're testing it and if you have
a platform that you want to work with C
make that isn't there you can contribute
to our dashboard system and run that and
people have done that in the past I'll
talk about an example a little bit later
on
y-you see make its fast this is from a
blog of was a QGIS they switched over
and they were really surprised that it
was quite a bit faster than Auto tools I
think a lot of this has to do with the
way see make works and not using Lib
tool which is essentially a three
thousand line shell script that figures
out how to build shared libraries and
complicated things like that
but whereas II make computes that once
and then writes a static make file or an
inter file that can do it in one fell
swoop and doesn't have to figure that
out each time it only does it once
during the C may configure process some
features of C make C make is actually a
open source to obviously open source
cross-platform build manager and it's a
macro build tool in the it generates two
native tools so it can use various
versions of Visual Studio and various
versions of make recently the ninja
build tool Xcode and this I think is one
of the important features because it
allows a project to take advantage of
the most important research on the
resource on a project which is the
developers so we got a whole bunch of
developers at kitware and they all use
different tools they like their tools
right some of them like Visual Studio
some of them like Xcode some of them
like Qt creator and we can all work
together and everybody can be happy with
something like C make and you're not
taking someone who likes to live in an
IDE I'm forcing them to the command-line
with some other tool you're allowing
them to use the tools that they're most
productive with and then they're gonna
be more productive on the project and it
allows greater collaboration so C make
supports a whole ton of operating
systems and you know we're constantly
adapting it
it's got platform introspection commands
so you can search for programs libraries
or packages I like to say I like to see
code that sort of programs to a
canonical system
specific system what I mean my dad is
instead of having you know if def linux
version 5 6 7 then add you can call this
function i'd rather see a try compiled
in the c make side and then something
that just says if this function is
available then use it and that way your
codes going to be portable going forward
so you can also do compiler feature
detection we've hadded
c make also adapt quickly a new
technology so as new versions of Visual
Studio released were jump right on them
or some of the community jumps on it
same thing with Xcode ninja is a great
story so that was the build tool that
was created for building Chrome I
believe through Google and it's a
command-line tool and it replaces make
and it does a really good job of doing
parallel builds and I think within a
couple months of it being public there
was a C make generator donated to C make
and then I think we got it sorted out
probably in another couple months out of
after that and got it working on all of
our platforms and passing all of our
regression tests we also when new
compilers come out we support those and
understand how to use them different GCC
versions clang compiler we support
complex custom commands so we can do
things like build CUDA or qts mock
originally this all came from vtk the
visualization toolkit which has the
ability to wrap into multiple languages
and we had a and that's like one of the
toughest things for a build system to do
essentially we had to build a program
and then take that program and give it
more input that builds more source code
that then it has to be built into
libraries so we have to support that on
all these different IDs and different
build systems so C makes always have the
ability to do very complicated commands
from the beginning building shared
libraries configured header files there
single implant for all platforms
it does automatic dependency generation
for C C++ and Fortran full dependencies
build target in the same directory we
handle out of source builds and parallel
built the sea makes port has many
features including color progress outfit
for make the ability to auto rerun C
make of NEC make input files changed
this works in Visual Studio as well and
the idea there being that you run C make
once and then after that you really
don't see it again you just run your
native build tool and as you change
files the build system will update
itself automatically it's got a full
cross-platform install system okay so
scenic provides various forms of
documentation there's a book for sale
there's a web page wiki a very active
mailing list it ships with HTML main
pages and command line help we recently
created a restructured text and Sphinx
system for generating the documentation
to make also has learn others cache
editors so you know in the sea make
project it creates a cache which stores
persistent variables and the results of
things like try compiles in your system
introspection in a file called the cma
cache and this also has things to turn
on optional parts of the build so you
can go into a GUI in create things like
you know build with NPI or things like
that and it shows up in this this GUI
there's a curses one and a QT one so if
you don't have a windowing system you're
on a some sort of supercomputer or
something like that you can use the
curse as one and of course you can run
CMake from the command line with no
options or you can pass in options as
well
you can run see make and script mode
there's also a see make - ii command so
it supports things like copying files
and sort of things that you might have
in your shell and we don't want to see
make or see make builds to depend on a
particular shell because we wanted to be
cross-platform and you can write
trips and run see make in that script
mode in that mode it just doesn't
generate the cash and doesn't do
anything specific to generating the bill
to make also has although I'll call it a
newer feature the idea of see make
packages and these packages can export
targets so normally when you're building
in see make if you add a library and
executable those are called targets and
they're part of your build and if you've
added library a somewhere in your
project you can say target linked
libraries my executable to a and then
able link to that library but if a was
built in a completely separate build up
see make or maybe even not with C make
you can now pull it in with what's
called an imported target which is just
basically a little bit of code that
describes you know where that file is
what the debug version is what the
release version is what includes you
need to do to get to use that object and
see make supports this there's a package
config helper that helps you write your
own see make packages and qt5 so
although QT does not use or cute does
not use see make has its build system
they do ship with C make config files so
they make using cute with C make very
easy you can go in and say fine package
QT 5 widgets add executable hello world
and then target link libraries QT 5 : :
widgets and that's going to pull that
imported target in and they're
maintaining it and this works out much
better for the C make development
community because we don't have to put a
fine QT module and C make and get out of
sync with their releases it actually
gets released with their code and C make
knows how to handle that another newer
feature is usage requirements so
originally C make had a very sort of
auto comm fish directory centric view of
the world right that's how make files
were and that's how it was when we
created it
is that you had each directory had you
know some libraries and executables and
pretty much the include flags and all
that went with the directory and you
sort of inherited this recursive
directory structure but see makes moved
away from that and the target is now
sort of more object-oriented view of the
world where a library or an executable
can propagate it's include directories
or compiled definitions and more so
target link library and target include
directories you can specify public and
private or interface options to them so
for example down here on the bottom I'm
doing target include directories foo
interface Zealander and now anything
that links to foo will automatically
have Zealander on its include line you
can also have compile options and
compile definitions done in the same way
you could also add say a private
compiled option so say I've got some
third-party library that I'm building
with C make and I don't want to go in
and clean up the code but I want to use
you know F no unused parameter I can set
that library and I can set as a private
thing so if I link against that library
it doesn't pull that compile option with
it it just sticks to that library
whereas if I want to add in debug to
anybody that links to foo I can do that
this way with compile definitions also
add a compiler feature detection to
chase the ever-evolving C++ standards
and so you can write your C++ code to a
canonical system and and handle various
different compilers another feature that
spin in C makes since to a but many
people don't know about is an external
project feature we did a kit where a
source article and this allows you to
either download or pull from a version
control system a completely separate
package or undo a tar file and build
that as its own complete project and we
put these together and this is important
for this
effort of pulling together these giant
systems and this was funded by the Army
Research Lab they created something
called a computational science
environment and it was a package of you
know 100 200 packages that they wanted
on their HPC systems and they were
building him all the seemed 8 but they
didn't want to rewrite the build system
for all them so external project can
actually build things that aren't built
with C make it can run auto tools they
can run other things it can run key make
essentially you give it the configure
command and the build command and it can
be set up in a cross-platform way here's
an example of a project that uses Google
protocol buffers sealer pack vtk cute
truly knows curl and boost and then I
can see this in visual studio project
now I'm going to talk about a test data
management and external data so Along
Came distributed version control and
it's meant for source code not data so
you have a local history of source is
great you're often modifying its
interesting history you can do things
like log and blame but a local history
of data is actually bad it's rarely
modified it's got a fairly boring
history whole file commits with poor
deltas and there's no real blame on a
binary file it's just someone so checked
in this and it's one big lump so it
really doesn't fit in distributed
version control very well so separating
the data from the source the source must
reference the data tests need matching
data and this is important because the
the tests and the data go together and
early on we struggle this with BTK we
had separate repositories there was like
a vtk data and a vtk but if you checked
out the wrong version of ETA data well
of all the tests might start failing or
some of the tests might start failing so
they really need to be bound tightly
together and actually distributed
version control and things like it gave
Brad King the idea that he could
implement something called external data
and see make that could use hashing to
content address storage to have your
data and arbitrary locations could be on
a local machining private server
internet server and the content gets
verified by hash so no need to trust the
provider of the hash is strong so the
external data module is part of C make
you start with real data and the source
tree locally you can change the source
code to reference the data by the
original file name and then you can
create it as a Content link which has
the hash and then thus have your data
stored elsewhere and be able to pull it
in and this supports various modes of a
place of storing the data and in fact
for the google tango project we added
Google datastore to it and the ability
to add plugins very easily to pull in
from different data stores the build
system does this on demand so it can
fetch it
during the bill that can download your
data or you can force it to download it
by building this target that you put and
uses local instances by file name the
original file name could be provided by
a symbolic link impossible on the
operating system so the external data
the method is sort of a black box
somehow it's going to get it you can
configure a list of URL templates and
try them in order so some things coming
to see make we'd like to generate
android MK files so you could do a cross
cross-compiled build onto android using
c mate tool and then have all these
libraries that are ready to go on the
android but then if you wanted to mix
them in to a android project you could
have c make generate android MK files
that point at existing libraries and
then make it easier for the Android
developer to use your large tool that's
Bill and C make and also we're working
on integrating the Android platform
support simplifying the Android tool
training that's been passed around the
internet from OpenCV Fame and used in
many many projects and I think we can
simplify that and move a lot of that
code into CMake
here's a simple example that sort of
shows the power of Si make it's a simple
project and executable that does pretty
much the full gamut of Si make things it
creates an executable and it links to
cute and installs required some
libraries and creates a seed package
package which is nice but then I added
four more lines of code and now I'm
using boost as well so this is a
powerful tool for developers to use the
rich set of C++ tools that are out there
now I'm going to talk a little bit about
testing so automated testing is
obviously important this graph shows
automated testing versus manual testing
and how much time it saves it seems a
little bit obvious here I guess but if
you're manually going through some test
suite
you're gonna keep adding up that manual
labor every time you do it but if you
have an automated test system you're not
continually adding time to the project
although unfortunately probably what
happens the same amount of time gets
spent it just gets tested less so we
have a project called C - which is an
aggregator of test data and it can show
you different builds it can do things
like image comparison here you can see
it does dynamic analysis and code
coverage and this actually came out of
Six Sigma GE so before I was that kit
where I was at G's research in
development and this was back when Jack
Walsh had a big Six Sigma push and he
pushed a whole company had to do Six
Sigma training so right down to the
secretaries and everybody at the
research center and this was a process
created by Motorola that create you know
chips on a mass scale where your errors
and defects would be in the Six Sigma
but if you've got a company like GE and
you want them to move in a certain
direction you make everybody do it and
score saw the scientists at the research
and or whining and screaming and saying
this is ridiculous you know we write
papers and throw a code how does this
apply to us but there were a few of us
there that were sort of software geeks
that said hey you know this might be a
neat way to get some funding or time to
do some software test
stuff and we create the idea of a
dashboard so I'll go back here so that
the idea there what can you measure in
software well you can't you know you
can't measure defects you don't know
what they are
but until you actually find them and
then you'll fix them but you can measure
things like built number of build
warnings number of build errors you can
do things like static or dynamic
analysis you can do code coverage and
these are all things you can actually
measure and try to drive down to zero C
dash can be used with other tools on the
project tango that I'm here for and
others they use Jenkins at kitware we're
experimenting with using buildbot
on the paraview project and we've
extended it to run configure and build
test steps for C make and build out can
parse the output of C test to determine
air and warning status people have used
Travis and Circle CI essentially it's a
great aggregator and it works great on
giant open source projects because other
people can contribute you know if they
are it's very unlikely you're gonna get
someone to contribute a machine to your
Jenkins build fun but you can probably
get someone to run a cron job once a day
that'll build your software if they're
getting something out of it like their
platforms guaranteed to work with cement
going into the future we've also done C
dash integration with github get lab
testing with C make is fairly trivial
you include C test you call add tests
you gives you a test name and execute
alone you give it some arguments and the
tests will pass if it returns zero or
nonzero it'll fail you can also set up
regular expression parsing of the output
and then it can be sent to see - there's
a video of pair of you nightly testing
running showing that C test can run in
parallel it's running like eight
different copies of this and that's
doing screen grabs and image differences
along the way that then get reported to
C - originally the truly knows project
was a sandhya project for solvers and
they create a multi package dashboard
and this allows a project to have many
projects because you might be working on
say you're one of the EPI guys you
really don't care what the thethe host
guys are working on and if they broke
their dashboard you don't really care
you only care about your stuff you might
care about theirs but you might care
about your stuff in this way it lets a
large project divide it up and look at
the different different sections can do
coverage JICA bullseye
valgrind and purifier supported and
again it provides a nice way to get down
to the details of these instead of
looking at huge log files that might be
produced as some build artifact it can
send you nasty grams when you've broken
the code it has nice wrappers of the
output so you can see exactly what the
command line that was used to build and
what the standard error standard out
were you can set up query filters on see
- to look at certain things like
sometimes I've looked at a particular
machine over you know a month period of
time to see when things started going
bad we've had a lot of support for clang
based tools so thread sanitizer address
sanitizer or memory sanitizer include
what you use scan build and this allows
this process where you have developers
and users they write look at the code it
goes some software repository there's
some build tests and package system that
then goes back for community review and
this cycle continues and that's really
an open source open science thing that's
enabled by see make and see - in these
testing tools also we have a tool that's
part of C mate called C pack which can
create installers in much the same way
we create build tools so you can create
you know Visual Studio installer Mac
installers does drag and drop plus the
other Mac installers supports just
creating tar.gz files and all soft
installer wixsnack
ss drag-and-drop plus package manager'
Debian and RPM packages using it's
really easy you as the first step is you
get your install rules to work so it
creates a tree that's gonna work and
then you include the C pack and maybe
set a few options before you include C
pack and then again this is one of the
design philosophies of C make is to take
these sort of mysterious things like
creating an installer when we first had
C make there was one guy that knew how
to make the installer and it worked on
one machine and if he was out or that
machine was down we weren't making C
make releases that had the installed
right so being able to abstract that
stuff out and sort of take the black art
out of you know weird computer science
things that usually there's only one guy
that knows about and codify it in the in
the built system is part of what's he
make does you can do component based
installed so now I'm going to sort of
give a whiz-bang tour of where C make
has had an impact on science so in the
beginning for kit where that was vtk and
that's the visualization toolkit and
it's you know grew though the whole
company and it's it obviously builds
with C make the Google project tango
which is why I'm here at Google right
now is a really cool project where
they're creating a mobile based system
that can scan the 3d world around you
and know where it is in that world and
it's a really exciting project and I'm
really grateful to be a part of it and
the reason we got pulled into that
project is because of the build tools
they make they were using C make based
build system and they pulled Kent where
in to help with using the build system
and doing some analysis and project
tango is a huge community effort with
lots of partners and lots of
dependencies so this is a graph of the
sub project dependencies where I talked
about the sub project builds at C dash
supports well it allows you to view all
those sub projects and their
dependencies and this is a view
obviously you can't
read the mother there's tons of them and
we also have a data storage system
called Midas which can store data and
then we created originally for our
computer vision group we created what we
call the tracker tracker so one of their
big algorithms is tracking things in
computer vision so you're watching cars
move around aerial surveillance video
and you're tracking them but they want
to know if their tracker is getting
better or worse over time so they
created this way of uploading the data
and we're doing the same thing for the
tango project and you can see here it
actually we've taken the sparse mapping
algorithm and we've basically got it
down to one number that's the error and
at some point in time you can see that
things got worse but that's alright that
it got worse and because then we can go
in and drill down at that data and see
what happened when it got worse and we
can see where it went and then we can
even get back to the C dash dashboard
and we can get to the commits that
caused it and then we can make things
get better again another project is the
computational model builder and reactor
geometry generator projects this is a
framework to easily adapt specific
problem domains and it's all developed
under a BSD license it uses various
simulation codes are supported and the
libraries used in the computational
model builder pages of them this is all
built with the external project and C
make the reactor generate geometry
generator and provide an easy set of
tools to model mesh generation component
applications that support various
nuclear energy workflows supporting
various HPC environments and leveraging
other existing efforts being developed
within do-e and of course got really
nice pictures put some slides in
and again it uses a ton of libraries and
they're all compiled and built and
follow this rigorous testing structure
that we talked about here's another one
a project that we worked on called
virtual pediatric Airways workbench and
its dependencies vtk ITA VPN RN Jason C
lapak it's a 3d interactive way of arrow
editing airway geometry with 3d input
voices to look at possible surgical
outcomes so in this case preoperative we
can see there's a problem that the
airway is choked and then they did
surgical modeling and that's what they
wanted it to look like and
post-operative then they can compare and
see that they actually got what they
wanted so that's an interesting
application of science and again it's
depending on this build system
infrastructure and testing
infrastructure this was an interesting
one I've never met these folks but
they're at down in Australia and they
had these big autonomous mining robots
and they used QNX
and they used C make and they came to us
they came to me any one of them email me
and said I want to use the Q and X
system for for C make and I said well
that's great but you're gonna have to
provide dashboards for it because if I
just take what you give me and sticking
into C make probably six months later
we're gonna break it and they said no
problem we'll set up dashboards and they
set up continuous dashboards and I
remember one time there was something
wrong with shared libraries on Q and X
and because of the timezone difference I
couldn't really talk to them or chat
with them and I just checked in some
extra print stuff and I checked in and
see my kind of wait ten minutes and I'd
look on the dashboard and there would be
the bill I'd look at the output and I
was able to actually debug something and
get it working without even console
access to the machine because they had
contributed that that dashboard pair of
you is another big project at kitware
it's a open source multi-platform data
and Aleks visualization tool for
analyzing extremely large data sets this
is also one of the projects that get
started early on with kit we're back in
nineteen
los alamos came to us and they wanted to
run use vtk on parallel systems and they
paid us to add MPI support and then they
wanted an end-user tool which turned
into pair of you pair of use an
open-source project and they're using
buildbot you can see sort of lines of
code going into a pair of you and then
the pair of you dashboard which uses C
dash and then build got to drive that it
does makes data analytics and
visualization software and it depends on
a whole bunch of libraries and various
specific versions of those libraries and
this is all maintained and controlled
with this external project there's a
about sixty thousand lines of C my code
so it's a even bigger than the robot
operating system broad set of
dependencies cross compiling support
blue-jean q cray x k7 windows another
projects 3d slicer this is a medical
application for doing image analysis for
medical research uses a VT AI ta c TK q
python a whole bunch of other stuff the
key infrastructure is c make CTS C -
github distribution mechanisms it's got
an extended manager for distributing
software and a lot of this is all
maintained and wouldn't be possible
without an open source build system like
CMA and it uses a ton of packages and it
has a whole bunch of interesting
clinical projects that have been used I
won't go over all of them the surgical
navigation prostate procedures radiation
dosage calculations so a lot of
interesting important science going on
this is one example I pulled out and
it's a case study built on top of slicer
where the grad student and professor
designed some robotic hardware for
improving preclinical ultrasound imaging
again this is all possible because of
the boring
build tool see make another interesting
personally the group that came to us we
have a source sort of a magazine that we
produce a kit lair and we invite outside
contributors and someone from Netflix
actually showed up and wrote a whole
article on how they're using see make
for their SDK so whenever you see the
Netflix inside on your blu-ray player or
different device some vendor had to use
the see make generated SDK for that and
they see - as well the killer computer
vision group works on aerial imagery
mostly they do event an activity
recognition and they're working on some
open source tools they're creating a new
toolkit called quiver which is open
source platform for production quality
video exploitation and again this is
using boost open CV various packages and
they've created a system called flush
which uses see make to build and compile
all these different C++ libraries and
other libraries and create a development
environment we've got a map TK again
it's another tool it's an open source
bsd thing that's created by the computer
vision group at kitware and this is a
open source for optimized for aerial
video processing and can use the GPU and
do motion imagery arrow photogrammetry
toolkit so we just celebrated 15 years
to see make it had its birthday about 15
years ago that was when i started in
2000 over that decade and a half it's
had a huge impact on scientific efforts
involving c and c++ building science
with seaming so i think think i made the
point that science involves
reproducibility and builds are part of
that reproducibility integrating with
continuous integration tools and it's
bigger than that it's also includes the
data and the algorithms and being able
to test the data and the algorithms and
tying that all together
and there's many domains to touch down
medical imaging computer vision and
robotics nuclear energy and there's many
more I mean it's an open source project
so it's kind of hard to tell who's using
it who's using it for what open source
is enabling the use of many
collaborators as well so I'd like to say
thanks to my hosts here at Google thanks
to the many many contributors of to see
make the awesome developers at kitware
the Google and Google tango printer</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>