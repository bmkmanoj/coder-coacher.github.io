<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Go Programming Language,  An Introduction (Go from A to Z — Zürich Gophers Meetup) | Coder Coacher - Coaching Coders</title><meta content="The Go Programming Language,  An Introduction (Go from A to Z — Zürich Gophers Meetup) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>The Go Programming Language,  An Introduction (Go from A to Z — Zürich Gophers Meetup)</b></h2><h5 class="post__date">2015-11-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hha7d97VYkM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everyone this is actually the it
was it was a it was mission that's the
second it goes like we meet up but it's
actually the third one that we have here
at Google the first one was April - last
year and I would like to introduce you
to Tom Owens wild he's being a pusher
since the last shoe once at least he's
been most like pretty much the organizer
externally and we were very happy to
have all of you here at Google and I
think that's all I have to say okay
thank you so welcome to go from A to C
and first of all I'd like to thank
Sydney like publicly and Google for
providing us with this awesome space
today round of applause please
it's really a great opportunity for me
to be standing in front of you today
it's cool to see so many attendants
coming to the go meet up and so I think
the bases are covered you know where the
sandwiches are where the beer is all the
beverages and so today's agenda is quite
simple we have four speakers first I'll
introduce you to go the programming
language the concepts the history a
little bit of everything so you can get
started with you know typical had a
world program all of that second goes
mad proud Google's own with a unit
testing he'll show us how to blackboard
test all kinds of different egg Co
applications after that we'll learn how
go excels in the web with REST API s and
so forth - and last but not least
Martinez is going to show us his a very
secret project of how he ported go to a
new OS okay so without much further ado
I'll just jump right in and it's ER okay
so not too long ago and 2007 these three
people they met they were working at the
same company you can get
which company that is and they basically
decided hey the languages that existed
they are not enough we we were more we
want something more simple so to give
you a quick introduction of who these
people are on the Left we have Robert
Crissman he worked on a JVM called
hotspot also on another virtual machine
called v8 that's a JavaScript engine in
the middle that's Rob pike
he worked at Bell Labs he co invented a
coding scheme for Unicode called utf-8
and also works actively on plan 9 which
is a UNIX successor the the official
UNIX especially if there was one and the
guy to the right that's Ken Thompson so
he Co invented a lot of stuff and
himself he also did a lot of work on
himself one of the things is the C
programming language he decided together
with Dennis Ritchie he's also one of the
many people behind Unix so basically
they realized we have two kinds of
languages in the market today the ones
that are faster writes and the ones that
are faster executed on one side we have
Ruby PHP Python Perl and so forth on the
other side we have C C++ to some extent
Java C sharp and so on they require a
lot of oil played a lot of complicated
writing to get a speedy program so why
can't we unite these both concepts and
additionally make it so that the
compiler is also speedy fast that
shouldn't take forever to compile a
program because at this very company
they had C++ programs that were
compiling in hours like they were
actually they couldn't know if the
program was going to work or not until
it was compiled and so they had to press
the button leave for hours come back
later and it will still be running so
that sucked
so that was a target as well so they
made a couple of observation the first
of which is that manual memory
management as you know it from C or C++
it really sucks
we human suck at manual memory
management it's a security risk it's a
it's an old story that you get this this
super old open SSL library or whatever
it is that has some buffer overflow that
leads to remote code execution or etc
etc so really memory management is
nothing for the hands of humans then
secondly people they like static typing
and if you look at the web right now
JavaScript is transitioning to a
typescript angular 2.0 will be written
in typescript a lot of a lot of other
languages are gaining type hinting or
you know where you write the type
annotation before the variable PHP seven
for example is coming up with static
type hints for scalar types which is new
etc etc so may let's make a language
that is typed as a static type system
that we can check at compile time to
remove a whole class of errors from the
runtime thirdly and this may be a little
bit controversial but inheritance
doesn't scale so I guess it was the 80s
when inheritance as a development model
boomed
when everything everyone thought classes
and extends and etc was their way to
program there was no other way so over
the years we've learned that inheritance
trees tend to grow exponentially like in
in the end you have this big big
inheritance tree with tightly coupled
things going around further and back and
it's not really maintainable anymore so
let's try to solve that in some
intelligent way with something that we
already have another point is that
languages programming languages they
tend to become products
the long run when when a language has a
little bit of success in the world they
tend to become this thing that gains
features with every new release you know
like I don't know Java gains those
lambda expressions or c-sharp gained
length and with every new version of
your language you get more and more
features and so everything becomes a
little bit more complicated because now
you can't parse your language linearly
so you have C sharp for example which
has a this Tomita style G LR parser
which is o and cubed which is just it's
huge
it's a it's a huge trade off for the
parser for the compiler it makes
compilers big and difficult to maintain
so let's cap it keep it small let's make
go a language that we designed today in
such a way that it can hold for at least
a couple of years so and one last
observation the obvious is that CPU
cores - today our concept ten years ago
we had just one core in each CPU today
we have I don't know in your commodity
laptop 812 maybe and it's expected that
we're going to have a lot more like
hundreds of them so let's make use of
that let's paralyze our programs instead
of gaining linear speed let's make them
concurrent power so they decide the go
programming language first of all it's
compiled that means there's no
interpreter not like Python PHP there's
no virtual machine like in Java or
JavaScript and it compiles to I think 11
different OSS combinations together with
architectures so you can have it on Mac
Windows Linux you basically write one
program you just compile it or whatever
you needed second point it statically
typed that's what we discussed just
right now it's a types are enforced by
the compiler and you have to play by the
rules of the compiler which is much
smarter than you third it's garbage
collected
I guess this was kind of a decision
because there's also other ways to
administrate memory automatically like
reference counting etc but garbage
collection seemed like a fair trade-off
and it worked quite well so there's
going to be no inheritance as you know
it and there's going to be embedding
which is a different concept it has to
do more with composition you know how
how Java devs and c-sharp devs are doing
dependency injection it's more or less
that just in the language not like an
additional feature then it's it has to
have structure and this is not a problem
with modern languages but if you have
ever written C it sucks because for
every header file you have you have to
declare some kind of a constants that
you check for the next time you import
it so you don't import it twice so
basically if you forget to do that yeah
you'll end up either in an infinite loop
or you import your library like 1000
times which sucks so it's got to be
packaged structured by default next
there has to be concurrency built in and
it has to be easy using P thread has
anybody ever used P thread here the
library yeah it sucks right it's really
difficult to use I mean even if you
actually grasp it and you understand it
it's still kind of this heavy thing that
just to carry around and work with we
have to distribute your work around
threads and managing this that local
storage thingy it sucks so let's make
that easy and overall let's keep the
design of go simple small and speedy so
in this talk we're going to be seeing a
lot of types and I assume some of you
guys work with dynamically typed
languages so I'm just gonna explain the
basics of that to you at the very top on
this slide we have a function definition
called add and it takes two integers and
it returns an integer it just sums them
together well so types in go are written
after the identifier that's contrary to
most programming languages you might
know from the C family like Java C sharp
etc and the reason is actually quite
simple you can read type signatures from
left to right below I have some C code
that's that's a valid C declaration and
it means declare acts as function
returning pointer to array of pointer to
function return in fact I got that from
a web page dedicated to this you can
actually type in a signature and they
will tell you what it means so if you
have a need for a webpage that does this
you're basically screwed up right so in
go that reads like you can see at the
bottom it's X and you see it's a
function that returns pointer to slice
or function to bytes whatever so you can
define your own types in this language
we're just gonna we're gonna look at
what types there are by default and go
in a couple of slides but for now just
know that whenever you write type then a
name and another type name you basically
are declaring your own type based on
that other one a little more interesting
type signature would be the one you see
in the middle which is a struct C
programmers know structs for the for the
rest it's basically like a class those
are the properties of it and they have
typed I mean an animal has a name that's
a strings Wow speed is miles per hour
that's the thing we declare at the top
and then it has two parents well it's
it's a safe assumption to you know to
make you know to parents and then more
interestingly we have interfaces ingo
and this is kind of that thing that
makes go work in the way does we're
gonna see a lot more about interfaces
later on we have this convert to
interface that says anything that has a
method convert which takes a bite slice
a slice is like an array or just will
see that and return to bite that's a
converter so we have predefined types we
into the language at the very top you
have the typical boolean which can take
two values 2 and false then you have by
its rules with which are basically 8
bits and 16 bits respectively
strings which have a length that's new
for C developers error which is a
built-in interface and we're going to
see how it's defined later on and what
its useful because error is something
you're going to see a lot in go code
then you have the two types of floats so
that's real numbers floating point types
32 bits wide
64 then you have architecture dependence
integers int UN's and unit pointer which
is it a bit special and then the
architecture independent inner types and
that last but not least complex but I've
never used it personally so I couldn't
tell you how how well that works and
there's also these composite types so
just assume that X Y I CQ are other
types so composite means that the type
itself is defined in terms of other
types the most simple case is to one at
the very top it's a pointer to X so
whenever you see a little asterisk and a
type name you know that's appointed
something again - Chris is at the
beginning of the type name that at the
end like in C then you have the sli's of
X which is like an array but it has no
defined length that can grow that's the
second definition you can see there the
third one is a nary an actual area which
has a fixed length it doesn't grow it's
just exactly that what it is a map is a
hash table it's built into the language
so you don't have to worry about
implementing your own although you can
if you know if you need one sure okay
then there's this Chan eggs
that's channel this is used for
concurrency when we're going to see how
just leave it at that for the moment
then a struct we saw struct earlier like
a class functions of course are also
type herbal and they are composite
because they take different arguments of
different types and they return several
arguments that something go has made a
little bit special
you can return more than one result from
a function two or three doesn't matter
and then lastly the interface which most
definition will see later
so maps and slices are really not that
difficult
it's a slice is what you would call a
list in Java or a collection c-sharp or
a dictionary in Python or an array in
PHP I don't know
it's basically growth you can just
append stuff to it and it just works you
don't have to worry about how big it is
allocating memory whatever done that
Maps same thing hash tables they map
from one type to another and this very
simple example we're mapping from
strings to boolean so we can say am
mapped yes equals true or not no equals
false you can basically use almost any
kind of type for the key except maybe
functions which will be a bit awkward
because how do you compare function sets
we have but whatever so now comes the
more interesting thing any nine type so
any type that basically you define and
it's not composite or no that's that's
actually the wrong way to say it
I need type that you defines can have
methods attached to it so it doesn't
matter if it's an integer base type or a
function it can have methods and the way
we attach methods to types is this weird
notation you can see right below the
person definition so you can see that
person has a first name a last name
which both are strengths and then H
which is an init and then we define full
name which is a method of person and the
receiver is this first argument which is
kind of in the middle between the func
keyword and
function name full name and that's kind
of what you can think of it's this in
Java or in any other language maybe it's
did this parameter so we're returning P
first name plus space plus last name and
P is this so the at the current object a
very simple example is that we
initialize or instantiate a new person
which has first name early last name f1
age 29 and we just take its full name
assign it to this variable called n and
then we print it the print thing I'll
explain later why that notation goes
like that also the short variable names
are customer ingo so we we tend not to
have these huge Java ask variable names
where the thing is kind of described in
itself we tend to use short identifiers
except for functions functions should be
you know good practice so let's see the
hello world program go is organized in
packages and there is one special
package with it which is called main the
main package is the entry point of a
program it has a function main defining
it and as you might expect that's where
it all starts in this case we're
importing another package called font
we're using fund which has a an exported
function called print line to echo hello
world to the console nothing out of this
world
so let's move on if anybody has been
paying attention you might have seen
that the capitalization of my names are
a bit weird if you're a Java store
whatever that's because in go public
identifiers are identified by an
uppercase letter at the beginning so
whenever you write a big F a big age
whatever at the beginning and then the
name
that's exported other packages can see
it equally for structs other packages
can access the memories of destructs if
you write them in lowercase No
they're private as we have no
inheritance there's no need for
protected
so let's write a package a simple one
with one type one method the type we're
going to define is session identifier
and it's going to be a string based one
then we're going to define the session
itself which has an ID username and it
expires at some point in the future
again we imported another package from
the standard library called time and we
are going to say that expires is of type
time time that represents a time well
then we have one function called init
session it takes the session identifier
it returns a session however it is
implemented is not relevant it's just to
get you an idea of how a package is
ready so you can see that the three
denta fires we defined so session
identifiers session and init session all
have a capital letter at the beginning
that means all the packages can see them
they're public so now let's assume I
push this to get up my session package I
find it cool I decided I wanted to share
with the world so I put it on get up
and now another user who may have
stumbled upon my codes and say hey cool
let's try it out so he goes to his
console and he just writes go gets get
up the account slash my user name slash
the project which it's called session in
this in this example and he can just use
it you can see in the import statement
that we're actually writing out the
entire URL accepting for the scheme so
get up coms large thw DS last session
and the name of that package in my scope
is session so whenever I want to access
init session I'm gonna write session dot
whatever so in this example I have this
handle HTTP request function which let's
assume is handling some kind of web
application so first on the first line
I'm going to take the cookie value
session
and that underscore you see there it's
emitting the second return value of
cookie which is an error so if the
cookie doesn't exist I get an error but
I'm just going to assume it does and I
get an empty string if it doesn't then
I'm going to use my package session that
in its section I'm going to pass the
cookie value which repeat session ID and
then I'm just I'm getting the session
back right I'm just going to print out
the username to the web browser that's a
very simple contrived example so one
thing about go that not many people like
or to get confused about we have
pointers and a lot of people think that
pointers in go it's just as bad as they
are in C e or just as complicated and
they really get scared when they have
here the name points because they heard
it in college and it was so painful
whatever
so go is normally passed by value
everything is passed by ballot so it
means that whenever you give an argument
to a function and gets a copy of that
argument not argument itself Java is
quite on the contrary normally when you
pass an object the function receive all
that method receiving the object gets a
reference to it and it can mutate it and
call methods and whatever and could
alter its States that's not the case ago
it's passed by value so the way we take
a pointer to something is this notation
we define P as ampersand of s taking the
address off that's what ampersand means
so if s was of type string then P is
going to be of type pointer to string
which is this asterisk and these
pointers work exactly like ANSI except
there's no no pointer arithmetic why
because we want to be memory safe if we
had this week basically access any part
of memory and just do whatever we want
with it
and that wouldn't go and see anything so
we we decided against it
there's no casting between pointer types
like in C so you can't just say oh yeah
that's a pointer to in it let's
interpret it as
to a float now you can't do that you
have to convert kneel which is you know
as now it's well defined so there's
never that question if if null is going
to be equal to zero or if it's some
weird macro defined somewhere or a
compiler extension or defined in some
other roundabout way it's just in the
language it's new it's always the same
and there's no arrow operator so doesn't
matter if you're calling accessing a
field for example and instructed this
reference by pointer or by value you can
just use the dot and the net result of
all this is that we have a memory safe
language yes exactly yes you can
overwrite them if you if you if you have
to need to like change the name you can
just write it in front of the import
path the input path is the string itself
where you see github.com slash tears
blah blah you can just write a name
there then you can import it as s or you
know as 0s whatever yeah you can change
the name you can even import it without
having a name for it by putting an
underscore in front of it or you can
import it so that everything declared in
that package is now part of your package
with a dot but that's kind of a advanced
use case I wouldn't cover that in this
introduction sure but yeah you can
change the name by the way if anybody
has any questions doubts at any time of
the of the talk just interrupt me please
ask your question there are no stupid
questions yes
so since Co punk 1.5 we have this bender
experiment thingy where you can actually
version your libraries and the whole
kind of version management the thing is
the problem isn't really solved in the
sense that it has no solution in the end
it's always going to be a bit quirky if
you import the library which imports
elaborate that you already import but
with another version and that gets
confusing
real quick and you can have you know
different versions of the same library
installed whatever so they try to avoid
that at all costs but we kind of gave up
because people demanded this future for
a long time so it's now part of the
languages of 1.5 which is a later
version yeah okay yeah we have package
unsafe for stupid things you know like
casting pointers reenter fair and all
that stuff if you're writing like a
performance critical section of some big
Pro program and the bottleneck is really
there you can use unsafe to hack around
it and manipulate data just like in C
you have all the power that you haven't
see just by using this package it's a
kind of a special package in that sense
I'm not going to show you how to use it
today so polymorphism might be on your
mind by now
so I said there was no subtyping no
inheritance right so how do we deal with
that we have these interfaces so if
you're doing opie today you're probably
using interfaces as well the nice thing
about it is that an inheritance tree can
implement this interface it doesn't
really matter where it comes from or how
its defined as long as it has the
methods to fulfill an interface and in
Java
in c-sharp etc you would rights my class
implements the interface right and go II
don't you just implement it you just
make the methods and then it's
automatically there you can use it so if
I define this type database adapter
which is an interface that has three
methods
connects that takes in a config and
returns in every one called execute
taking in a query and returning a result
in one go close and I can just implement
these methods in any type I want and I
can automatically use them as a database
of that we're actually going to do this
in the next slide ever it's the one
built-in interface it has one method
called error and it returns a string so
in go there's no throw statement you
don't throw things around you return a
second result which or a third one if
you are already returning to which is an
error and then your caller has the
responsibility to check for it
normally it's Neal that would mean
everything was okay if it's not
something failed and you have to act on
it
right so it kind of forces you to
actually deal with exceptions or with
errors because what we have observed a
lot is that in the opie world people
tend to just write this global exception
handler at the very top of the stack
just let everything else throw up and
whenever that global exception handler
catches something it will you know write
like a general message like yeah I think
something bad happened look at the stack
trace so in go you can actually handle
the error in context you can you know
you're basically forced to you have to
say okay what happens if I'm getting an
error connecting to this HTTP endpoint
and then you could decide on a smart
message that would actually actually
help the person observing the error to
fix it quickly so that's how it so as I
said interface implementation is
implicit that means you don't have to
write implements block it just does so
let's implement the error interface at
the very top we have this connection
error type which is an empty struct
what's an empty struck it's basically
type with with 0 it doesn't cost you
anything in memory you don't have to
ever allocate it or define it it's just
it exists only on a language basis
basically and it has this error method
which returns a string and I mean okay
this string is not very contextual or
good or whatever but you get the point
it returns you know and then we
implement database adapter and in this
example we are implementing database
adapter through a map so a hash table in
memory a hash table from queries to
results which kind of makes sense
because we have this execute method
which takes an Aquarian has to return
results so we can do it by just mapping
it in the connect method mmm
basically nothing bad can happen if
you're in memory right and so there's no
connection to memory but there's a
special little thingy there
I'm checking a which is the receiver
which is more or less equal to this to
be nil that doesn't make sense in a lot
of languages and go it does because the
receiver can actually be Neil you can
instantiate a a type and say it's values
new and just call method type there's
basically like static methods if you
want so I have to check for it if it's
new I'm just gonna return this
connection error that I defend and close
makes no sense in this context so I just
implemented it but I left it empty and
now I have a perfectly valid database
adapter that I can use everywhere where
a database adapter is expected without
implementing explicitly anything also
for the functional fans among you we
have lambdas with lexical scoping like
in JavaScript and whatever they took
closures and I wrote together a small
example for you just to demonstrate that
it actually works and there so this
function quote of the day takes a
function as argument so it's a
higher-order function and it will call
its argument with the string testing
shows the presence not the absence of
bugs then outside of that scope I
defined a variable called a day
which has the value Attica Dijkstra
she's a computer scientist if you don't
know and P which you can see is now a
lambda that's exactly what quote of
today expects a function that takes a
string and will just print it and
additionally it will print a which is in
its lexical scope it's not defined as an
argument or part of its definition of
whatever it's just in its lexical scope
so it's closure over a and we call it
and it works for JavaScript is this is
like the coolest feature because they're
very used to do this for the rest of you
man to look into it it's actually quite
kind of fun so now I told you at the
beginning that concurrency and
parallelism was built in right so that's
implemented through this concept of go
routines go routines are like very
lightweight
Rhett's or fibers for for that Rubeus
Python ists I think and we can start one
of these go routines by just writing go
in front of a function call and that
function call won't take place in this
reddit will just be scheduled and will
run parallely someone normally just
write down but it could happen in like a
couple of milliseconds or whatever so
here I have this function execute job
which takes a job ID which is an int and
it takes a long time to complete this
job it's going to be spinning for I
don't know five minutes or something so
I have this drop IDs seven six eight and
I'm just gonna call go execute job wave
another idea I don't know why I did that
sorry for whatever it executes parallely
so it's spinning in the background I'm
just gonna print okay job is now running
and whatever happens after that we don't
care this is cool
but it has the limitation that we never
know when the job is finished right and
we actually want to know that because we
might want to clean up or notifiers and
an email
so we're going to use channels to do
that channels is that will type with the
Chan prefix that we saw at the beginning
so this is how it would look if we just
use a channel that's basically not
device us whenever that concurrent job
is done so execute job has changed from
taking just one integer to an integer
and a Chan of boolean just because
whatever doesn't matter what type it is
because we're only going to use it to
notify not to actually transmit any any
information so additionally to this job
ID which I already superfluously defined
in the last slide I did it again in this
slide we are going to define done which
is going to be a channel of booths and
we use this make function and make is
good to create slices maps for channels
then we're going to execute this job and
give impassive this channel so the job
knows about the channel then we're just
going to print just like before that job
is now running and then we have this
arrow thingy before the done that's
basically wait on a channel so the
program is now blocked right there where
the arrow with the done thing is and it
won't continue until someone writes to
that channel so it's it's reading it's
pulling out a value but it won't
continue until it has something and
luckily our execute job function over
there which is running in a another go
routine whenever it's finished it's
going to write the value true to this
channel so as soon as it writes it it
unblocks the other girl routine and that
can continue and the net result is that
we can print the message job is now
finished whenever the job is done so
that's the basics of channels now they
seem like a very simple tool but you can
actually do very powerful things with
them a little bit more advanced kind of
thingy
is the worker pattern which is basically
you spawn these go routines which are
waiting for works and channels and they
do them and they notify the the caller
and we can actually run the
example in the browser because go
compiled Snickle and nickel is an
architecture that runs here so you just
run it and what we see is that we have
eight workers which are spawned in the
first four look and they are giving
access to the channel C which is a
channel of strings now in the second for
loop we're going to write words just
strings to that channel and on the other
end of that channel will be one of these
workers it's pretty random which one it
is what we that we don't care we have
eight concurrent workers that are
distributed on our threads that on our
CPU cores in the end and they can do
their work however they please
so we're just going to distribute their
work to them wait them for to process
them in this example instead of actually
doing anything useful they're just
sleeping for some random thing between
zero and three seconds and when we're
done with all that we're just going to
close the channel to basically close how
to go routine the worker co-routines
so they stop using any resources and the
program can exit and we're done
net result is this thingy that you saw
over here where you can see that the
workers are not working serially they're
just kind of randomly distributing work
around them and this example would take
at least I don't know free slides to
implement in other any other language
than go maybe Erlang would be possible
in one slit but I don't know enough girl
and so so to bring this to a conclusion
here are four very good resources that I
totally recommend you read the first is
effective go which is kind of the go-to
manual to write good go code secondly is
the standard library documentation you
will need that you will need it third to
go playground you can just type code
there in the browser and execute it
without installing any compiler or
anything so if you just want to toy
around with go try it out whatever just
go to the playground and forth the go to
work so if you're really interested in
learning go or learning to program just
go to the go tour and go through it is
by step tutorial that will teach
everything you have to know so you're
now golfers congratulations yeah with
this I conclude my talk next I think
Sydney wants to say word I thought if
there was any questions we can walk with
the microphone around yeah sure
if we can do a Q&amp;amp;A anybody you have any
questions remember there's no stupid
question just stupid answer so whatever
you feel you didn't understand
just ask was I so clear so everybody got
it yeah you could program now okay
excellent so we will thank you very much
Thomas thank you and then next we have
met or yes mats and aftermaths talk
we'll have a quick break you can go to
the bathroom and then have Sandra show a
drink so thank you very much please eat
them I made 70 sandwiches today so
please eat them</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>