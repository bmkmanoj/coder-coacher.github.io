<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Evolving JavaScript with TypeScript | Coder Coacher - Coaching Coders</title><meta content="Evolving JavaScript with TypeScript - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Evolving JavaScript with TypeScript</b></h2><h5 class="post__date">2014-12-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ut694dsIa8w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello and welcome hey thanks for coming
everybody we're really excited to have
the folks from Microsoft down anders and
the rest of the team he's going to talk
about where typescript is and maybe a
little bit about the future and please
give a warm welcome to the Enders thank
you thank you let me just put this one
up oh yeah we need to I think Brad's
pushing the button there's that we can
see some slides so my name is Andrew
Salzburg I'm a technical fellow at
Microsoft in the developer division
where I work on a variety of things
including the typescript project I also
worked on C sharp and dotnet and so
forth but today we're we're here to talk
about typescript which has been out for
a couple of years now it's actually
about our second anniversary up going
public and typescript is is about
addressing this problem basically you
know a problem that we hear increasingly
more and more from from from customers
and internal users that writing really
large apps in JavaScript is hard and the
reason people write these large apps I
think is as you all know you know
javascript is really the only
cross-platform game in town now even
Java that was conceived to be
cross-platform isn't really because you
can't run it on iOS for example and so
so people write increasingly larger
JavaScript apps and and javascript was
really never intended for writing large
apps and in fact you know it was
conceived in three weeks by Brendan Eich
and I think the intent was maybe you'd
write like a hundred or maybe up to a
thousand lines and now people write
hundreds of thousands of line apps arm
in a language that arguably have no
concepts for structuring large code
bases no classes yet at least there are
no modules no interfaces and there's no
static typing at all it's it's a purely
dynamically typed language and that's
great for little stuff but but the
bigger it gets the harder it is
to manage these large dynamic code bases
because if you think about what what it
is that powers the intelligent ideas
that we as programmers that rely on
everyday at the core of most of it is
static typing or the ability to reason
about the code in intelligent ways so
the IDE can deliver invaluable things
like statement completion or go to
definition find all references
refactorings that are known to be safe
um that just gets super super hard in in
big dynamic code bases and gradually you
know once you reach your some tens of
thousands of lines they basically become
read-only because no one dare touch
anything in here right because who knows
what's going to what's going to fall
over so so as we set out to work on this
problem we thought wouldn't it be nice
if we could add to JavaScript these
things that are missing like classes
modules interfaces and Static typing ah
but added in a way that doesn't mess
with the core value proposition of
JavaScript that is you know the ability
to run anywhere on any browser on any
host and that that really in a nutshell
is what what typescript is it's a
language for large-scale JavaScript app
development in a sort of more technical
sense it is a typed or statically typed
superset of JavaScript that compiles to
plain JavaScript so typescript itself is
written in typescript and therefore
compete compiles to plain JavaScript and
so the typescript language and toolset
and the code it generates runs on any
browser on any host and on any OS and
the the whole project is open source arm
we switch to hosting on github in June
arm and that is great we're getting a
lot of community participation we do all
of our development processes in in the
open so that's sort of in a in a
nutshell what typescript is basically it
starts with JavaScript so
so it's important to understand that
typescript is not a new language or a
different language it is it is at the
core of it JavaScript but it's
JavaScript with type annotations and the
ability to declare types um so so what
it adds is types including generics and
all sorts of other fun stuff and then
powered by that is excellent tooling
tooling that does things that you just
couldn't do with with with purely a
dynamic programming language but when
you compile it all goes away and you're
just left with JavaScript in fact you're
left with what I would argue is
idiomatic JavaScript that looks like a
human wrote um we we don't actually mess
with your code or inject code we don't
have a runtime library specific to to to
typescript the code that you get is the
code that you wrote - the types that's
that's basically how it works
so with that said I I'm going to spend
most of this talk actually demoing the
product itself live and then from that
you can sort of see how how it works
what I have here is a visual studio with
the latest version of typescript in it
and we're just going to write some code
and then then see how how the system
works I'm going to start just with some
plain JavaScript here there's a function
that sorts an array of things that have
a name property and as I said you know
to begin with any javascript is
typescript so you can just copy and
paste or rename your files to TS and to
begin with we know no more than that
dynamic said well we know a little bit
more but but but if you start like
hovering around in the ID here here
emitter here a but there's we don't know
nothing about it and there are no calls
there nothing
this a has typed any and that in turn
means that you can on a invoke any
method you care to and if I say a dot
well sorry
got nuttin at this point right so
clearly this this function is a function
that sorts an array well and and you
know we do know some things though we do
know that you've declared a function
sort by name so we can at least show you
that but you can pass it anything you
want including something that's not
going to work so it sure would be nice
to be able to annotate this and say well
I know that a is supposed to be an array
and we're we're not the first to get
this idea of annotating your code you
guys have a product called Google
closure right that allows you to write
I'm not sure if I wrote it the right way
but something like that right where you
where you where you put annotations in
in comments that works if your design
goal is to not at all nest up outside
the comments are but comments are not a
particularly great place to host the
type system at least syntactically it's
it's doesn't look us great and it's it's
you know an alternative would be to
actually allow you to annotate the code
directly so here I could say I know that
a is an array I don't know an array of
what so it's an array of anything but I
can simply add that annotation and then
when the compiler compiles my code it
just takes away the annotation so so the
annotation is there purely for
development time it has no cost at all
at runtime but once I do that well then
we now know that a is an any array and
we know that the slice function is a
thing that returns an array that has the
same type as as the thing you invoke it
on and therefore we know result is in
any array and since we're returning
result we know that sort by name now is
a function that returns in any event X
and any array and we can now validate
down here we can say number is not an
any array arm so you add annotations and
things gradually start to light up arm
and you'll note that
all of it gets inferred I just added one
type annotation but we found out a whole
bunch of stuff by flowing the types and
and you'll see that it's actually fairly
minimal
how many annotations you have to add and
and because we do a lot of inference
also now that I know that a is an array
when I say a dot we can show you all the
methods of an array we could give you
statement completion and so forth but of
course
there are things we still don't know
like result dot sort takes a callback
function that's going to present the
elements of the arrays in pairs and
you're supposed to compare them but
since we don't know what the types of
the elements are all we can know about X
and y is that they could be anything and
so we're sort of gradually type we have
typed here but we're not fully typed yet
armed and that means there there there
there might be bugs that we don't find
but we could we could try to say more I
mean here obviously we're we're sorting
on a name property so we could declare a
thing that has a name property and then
we could say that our thing is an entity
array now and an interface declaration
and typescript is really just stating
that here's a here's a thing that has
the following properties we're not
stating anything about how it came about
arm it could come about by you just
assigning some properties into an object
literal or it could have come about by
you creating a class or or whatever
it's structural meaning that anything
that has a name property is an entity
including some other definition called
Rousseau so our type system is
structural not nominal arm now you'll
see that that now that I said that these
guys are entities well now we know that
result is an entity array and we know
that sort is going to present two
entities here now we know that an entity
has a name property and we can give you
statement completion there and then we
know that name is a string so we can
give you statement completion again and
then you'll see here that we actually
also discovered a bug in this
dynamically typed code someone was
calling local compare but what they
probably meant to do was to call locale
compare but just typed it wrong so now
we can we can fix the bug ah is always
better to fix it before the space
shuttle flies then and in flight right
so okay so so now
let's try two now that we've actually
typed everything or given types to
everything let's try to introduce
another thing called name now one of the
things that's hard in dynamically typed
code is let's say you have 50,000 lines
of code and you're using a property
called name in a bunch of different
places and now for this object here I
need to change this name property be
something else but I don't want to
change all the other places right that's
something that is insanely hard to do in
in a in a dynamically type system you
may think you have unit tests that cover
it also but we find with regularity that
people that swore they have unit tests
to cover it all didn't quite have unit
tests that covered at all because
there's nothing that checks it for you
right so here I can now for example go
to my interface and say let me rename a
name to entity name for example and
you'll see that even though there's
another thing called name we don't
rename that because through types we
understand what the difference is
between the different things called name
and that's where this stuff starts to
add value obviously a little program
like that it's not hard but the bigger
it gets the harder it gets right and
eventually it's like I said it becomes
read-only okay so let me try to add a
few more let's add a price roll a number
here to our entity and then let's try to
create an entity so we allow you to put
type annotations on our code that you're
writing like this here for example I'm
saying is an entity and you see that it
complains that we're missing some stuff
we're missing the name property and the
price property we actually can give you
statement completion here through what
we call contextual typing we know that
this object literal is getting assigned
to an entity so we can flow the types
the other way and and show you what
should come here and there we should
have a name property ah call it a hammer
and a price of 595 see and now the arrow
goes away
I guess the type checkers is happy but
again here it's it's all structural
really it's not like I had to new up a
class or anything I just said you know
it has to have these two properties if I
go at say an in stock property yeah
yes
yes give me one second I was going there
right now let's say I that now add an in
stock property here that may or may not
be there okay but if it's there it has
to be a boo
right now it complains that it's not
there I could then either go at it or I
could indicate that in stock is optional
by adding a question mark to it and now
I've said if there is an in stock
property it must be of type bool but it
is okay for it not to be there so if I
say in stock here coal on five for
example you'll see that it complains in
stock is incompatible you can't assign a
number to two abulia um can you read the
font here is it okay but if I change it
to true then things are happy okay now
can of course declare other things we
could declare methods like say set name
and get name here on now since they
weren't marked as optional I I must
implement them so let's say set name
actually let's do get name first get
name : function return this dot name
and
name function that takes string and in
here now if I say s dot you'll see that
we know stuff about s and this is again
contextual typing in action we know that
you're assigning to an entity we know
that entity has a set name property we
can flow that into contextually into the
expression that you're initializing with
and then we can contextually type this
argument in case you didn't give a type
annotation and you'll see that this
actually this works great as you're like
doing these dotted together pieces of
code with callbacks in JavaScript we can
flow all of that stuff and you don't
have to put type annotations in a whole
lot of places so here this dub name
equals s is how we would complete that
that piece ago yes
of this week one
yes so the question is what if you have
two identical types what is it
it doesn't care if you have it's all by
structure if the two are structurally
equivalent you can use them
interchangeably and one is assignable to
the other so it's truly a structural
type system not a nominal type system
and that means you implement an
interface if you have all the properties
that the interface says that you must
have um it just happens all of woops
it just happens automatically I think we
somehow okay there we go go back to the
code cool you don't want to look at me
you want to look at the code dokie
let me try to shorten this down a little
bit and then let me grab this code and
move over to the browser and try to play
with this in the typescript playground
which I have over here so if you go to
our site the typescript site there's a
little playground where you can type in
code and see the output JavaScript code
and one thing you'll notice is it's your
code it's exactly the code you wrote I
mean they're literally we the method
bodies are identical except the type
annotations I race that's the only thing
you see so here all of the the type
declarations went away the type
annotation went away here but other than
that it's exactly the same code that
comes out on the other side I'm going to
try to actually make this code run just
just for fun so let's go back and let's
pick a
there are products here um maybe let me
just scroll this up a little bit here so
you can know there and then let's try to
use our sorting function on those
products so we'll save our sorted equals
sort by name of products now you noticed
here that I get statement completion and
hovering help and whatever I can hover
over here and see products is an array
of things that have name price and ID
this language service the thing that
provides all of that help is actually
part of the the open-source typescript
project so the compiler isn't just a
batch compiler it's really more like an
API that allows you to ask intelligent
questions about the code it can produce
an ast for your code to allow you to do
code navigation you can go in at any
point and say what is the type of this
thing and we will we will lazily
evaluate just enough to figure out what
the type is here so you can do statement
completion and and so forth and it's all
written in typescript so you can use it
anywhere and so here we're actually
using the very same compiler hosted in
in the browser in in our playground okay
so
if we look at what's happening here with
our with our sort function so so it's
sort by name takes entities and
therefore it returns entities we've
inferred we're passing at things that
are entities because they have a name
property but they also have other
properties right and so if I come out
the other side here and say products
dots whoops not sorted if I say products
I get all the properties if I say sorted
I only get the name property because
we've inferred that they're entities but
really there's something a little bit
funny about the way we've added typing
to our sort by name it isn't actually
true that sort by name takes into T
array and returns an entity agree it's
true that it takes an array that must
have a name property and returns an
array of that same type right arm and
that we can represent by writing it
using generics so we could say that sort
by name is a thing that takes a T array
and then from that we can infer that it
returns a t array and now
we passed in something that has three
properties well they come out the other
side now with the same type so so
generics here allows us it gives us a
higher a bandwidth conduit to flow types
and that's really sort of the purpose of
generics and typescript
it is to flow types with fidelity around
graphs of connected objects right now
you will note though that now another
problem showed up here it starts
complaining about the name property and
it rightfully does so because we're
using a name property on on a tee but T
could be anything
including something that doesn't have a
name property so we need to constrain
our T which we can also do so we can say
T extends entity and now things are
happy because now we know that X has a
name property but we will still flow out
of sort by name at T and so down here we
still get the right type for for the
elements coming up right so that again
is just sort of why generics are
important because you may go generics in
JavaScript that sounds insane why would
you want the generic set but but look at
the output code right there's no trace
of this generic stuff anywhere this is
all an illusion that exists at
development time to just give you a high
fidelity way of flowing types around in
your code
um just for kicks we could try to add
one line here that actually
json.stringify saw result and let's try
to run it and we can see that yes it
sorts things by by their name properties
now
I to make it a little more advanced this
example though let's instead of sorting
by a name property why don't we have a
function that that has a callback that
allows
you want to sort by arm and also do that
so let me pick one of those here let me
try to change this here to look like
this instead so now we have a sort by
method that takes an array of T's and
then it has a callback function that
calls back presenting a T and you're
supposed to then pick a value out of
that T that you want to sort by and then
it during the sort it calls this
callback function to pick out values so
now called sort by of products comma and
now we're supposed to write a callback
here armed and I can write that as a
lambda and this is where an example of
where we polyfill Egmore scripts --ax so
I just say call it X X dot and you see
that we do statement completion here we
know that we have flowed the T through
products into into your lambda and can
now show you that the properties you can
pick from so we'll pick a name property
here we can try to run this and see that
they're sorted by name ah we could
instead try to pick price
example writer on that and now it sorts
by price so so it works
notice how in the generator code we
actually turn it into an inline function
which is which is what which is part of
what fat arrow does in actor script six
it also has different semantics around
capturing this which we understand will
generate the right code in function
closures and so forth but basically part
of the purpose of typescript is to give
you static typing another purpose is to
polyfill those features that are missing
in es3 and es5 that are coming in year
six and so all of the extensions that we
have are aligned with what's happening
in echo script already and we're
currently working towards full fidelity
with echo script six which we'll
probably reach by by spring ish ah okay
let me let me just try to grab this code
and bring it back to visual studio and
then just show you some of the whoops
some of the latest features that that
that we're working on which is union
types and topple types topple types
already in but we're doing union types
curl or we did union types they're in in
the master branch right now it's very
common in JavaScript API soar objects to
have pretties or parameters that can
have that could be one of multiple
things for example a sort method here
might take either a callback function or
the name of a property as a string
that's one pattern another is you can
pass it you know a configuration object
either as an object literal or as a
string or as a number or whatever up
until now we could not express that but
we now allow you to write Union type so
you can say this must be a string or an
item callback and you use the or
operator for for that and now a few
things happen here well first of all
let's try to call this key and now it's
going to complain that we don't have a
callback so let's say Bar callback
equals key it's still going to complain
because you can't call a string or
function because it could be a string
right so you got to do something first
to sort of distinguish between the cases
and there are patterns in JavaScript
that are that are pretty common one
would for example right here type of key
triple equals string if we have a string
then well now we can make a callback
function that we could use them and so
let's make one where we pick out the key
otherwise we know we have a function so
we'll just pick that function now note
how the types all worked out here if you
hover here and see key it has type
string or callback function but if you
hover over here it has type string and
if you hover over here it has type
callback function because we understand
what type of does we understand that a
type of triple equal string will remove
string or will select string or remove
string from the available types in a
union type and so we can reduce the type
call it narrowing under a type guard arm
and that's what you're seeing
ineffective yeah
you
um there yes so there's so the question
is must I compare to the literal string
or could I have a function that says is
string or or whatever so one of the next
things that we're look so right now we
analyze type of an instance of we are
also likely going to do discriminated
union types it's very common to have a
kind field that can be you know let's
say north south east or west as a as a
string literal right and then based on
that you can know the rest we can we can
discriminate on things like that because
we actually allow you to define string
literal types that can be one of a set
of values we use that for overload
resolution but then finally the thing
that we're likely also going to do is
what we call user-defined type where you
define a function and you just designate
that function as the one that trust me
if you pass it if if you if you call is
customer and his customer says true then
whatever you passed is a customer and
we'll fold that into into the type
system as well so that that's one of the
things that likely will will show up in
in the next few months but right now we
at least cover the the typical patterns
that people use in in their JavaScript
code and of course we we cover all the
various funny cases if you write it the
other way around then you can flip the
arguments and etcetera etcetera you can
write it as an if statement will likely
also allow you to write them as switch
statements and so forth so okay that is
well let me show one more thing you saw
how when I say a dot here we showed this
statement completion you might wonder
where did that information come from is
that just sort of built into the
compiler how do you know what these
types are we can actually say go to the
definition of slice just press f12 here
and it jumps me into a file called Lib
DTS which is a declaration file that is
included in every compilation this
particular file you could think of as
the
enter file for the JavaScript runtime
library and the entire HTML Dom it's
it's a file that exists purely to
provide all the static type information
for the JavaScript runtime library
it adds zero cost at runtime because it
just goes away
it has nothing but declarations in it
but with this file in hand you now have
a synopsis if you will of the here you
see 14,000 lines of JavaScript code that
you otherwise are supposed to memorize
right when you're writing in JavaScript
you're supposed to know what all these
functions are because your IDE sure as
hell doesn't um now does right I mean
unless is this is where this is where
static typing really really helps right
it's like it's just ridiculous to sit
there and manually look up what all
these functions are this is just
something that the computer should know
for you right now the cool thing about
these is that that there's nothing magic
about these declaration files and anyone
can write them and you can write them
for existing JavaScript frameworks and
what we've seen shortly after typescript
went public is organically in the
open-source community this web is this
github repository called definitely type
sprung up and it's become the place that
collects all of the declaration files
for all of the popular JavaScript
frameworks and I'm I challenge you to
find a framework that doesn't have a
declaration file there now there's more
than 600 frameworks that have coverage
arm it's there over 600 committers in in
in that repository super super active
and the quality of a lot of this static
type information collected and is pretty
pretty darn high like things like jquery
angular i mean they all have declaration
files and and now we're seeing are tools
that automatically provision your
projects just by fetching the
declaration files from definitely typed
and so forth so so that's all pretty
cool what's their question over here
yeah
yeah
yes I mean so there are cases where
where we camped okay I'm sorry
what if what if a union type is like two
different functions that accept
different arguments for example well
there are different ways to write that
typically you would write those as an
object that has an overloaded function
with multiple call signatures which we
can then disambiguate if but if you if
through Union types you get two objects
that you can't actually with that type
of or instance up test tell which one it
is well then you could use a user
defined type guard like I like talked
about it's not implemented yet or you
can simply put a type assertion where
you you do your test and then you just
assert that it is now this type by
casting it and the cast then goes away
in the compiled code so it's really just
there to guide the type checker if if
you will I'll show you an example of
that a little bit later okay so that
that was let me try to go back and show
some of the other arm poly filling that
we do one important one is classes so I
could write myself here in the
playground class point with X colon
number
and why : number or poly filling means
implementing features that are coming in
a later version of the language in a
downlevel manner using features that
exist in the older version of the
language so classes are coming in echo
script 6 but you can actually emulate
classes using idiomatic JavaScript code
and certain patterns that correspond
exactly or almost exactly to what echo
script 6 would do so here for example if
I declare class a class at the core of
it in JavaScript is just a constructor
function we also use the pattern of
putting it in an immediately executed
function expression here to give us an
isolated scope for for for local
variables and so forth but now that I
have a class I can say bar P equals new
point
for example and then we know that P has
an X property and a Y property that I
can assign to for example the whoops
there okay
of course I might want to pass them as
arguments to my constructor and if I try
to do that then we complain that there
is no constructor but I could go right
one so constructor of X colon number
comma like our own number see
like so and in here we then say this dot
x equals x and this dot y equals y for
example and you'll note that in the
generator code we just omit the code
that you wrote
we can of course also add methods to our
classes so here let's add a distance
method that says return math books math
dot square root and by the way here you
see like all of that type information
from Lib DTS presented right we get not
just the parameters we also get the
jeaious document that the Daystar
comments that tell me what the arguments
do so this dot x times this dot x plus
this dot y times this dot y and now if i
say p dot you'll see that there's a disk
method that returns number
also write it as a property or as an
accessor just by saying kit and here
you'll note that the code generation now
is not quite as pretty
because Egmore script five doesn't
actually support properties other than
by calling object defying property but
in ECMO script six it'll support this
syntax over here and and basically like
I said earlier we are aligning ourselves
with with echo scripts syntax this
syntax here is the Egmore script six
syntax - of course - the type
annotations right um yeah um I was going
to say they're okay but so let me let me
move along
I to do statics vattic origin equals new
point of zero comma zero okay and here
you if you look at the generated code
it's now starting to get a little little
while let's not let's not do an access
or here anymore let's just do a regular
method you see that we put instance
variables on the on the instance we put
methods on the prototype we put statics
on the constructor function object and
now over here if I say point dot you'll
see that there's an origin property now
available that I that I declared there
and so basically this is the kind of
code that you would manually write if if
you were using classic JavaScript right
but it sure is a lot nicer to be able to
write it using using this syntax and I
do think deed you know Egmore script six
is going to offer a lot of these
features um but it's but that doesn't
mean that these features are going to be
available on all your execution targets
for for a good long time right
it's going to be years years before
there are enough browsers in the wild
that you can actually assume that your
execution target is echo script six and
one of the things that that we do for
example or that that's what I was going
to say if if you write here like an
access or like get this then if your
output target is es three or es5 will
generate well if a Jesus three will give
you an error because we don't yes three
doesn't even have defined property if a
T is five will generate that if it's es6
will just generate that um so from a
single source depending on what features
you use you can actually just choose
yourself what you want to target
the playground currently just Egmore
script five it's just hard wired to do
that the playground is not super
sophisticated so so we could be fed up
but but yeah yeah it just assumes es5
okay
another thing let's try to add a private
field say color here and say this doc
oops our equals red
like so and you'll note in the output
code we didn't do anything special for
private because there are no private
fields in JavaScript and there is no
cheap way to do private fields in
JavaScript however statically we can
certainly check and out here you'll see
there is no color on on P it only exists
inside the class we also support
protected and now in a subclass you'd be
able to access color but not outside a
class declaration so we do the best we
can which is we statically verify that
you don't use this private field but in
the generated code we optimize for
efficiency now as as enough es6 targets
mature out there it is possible to do
this with symbols in the Egmore script 6
but currently none of the VMS
implemented efficiently and you pay too
high of a cost to to access these
properties so so we're sticking with
this for now ok let me show also you
know some some syntactic sweetness that
we have this pattern of declaring some
properties and then having them as
parameters to your constructor and then
initializing them inside the constructor
is so common that that we sort of
capture it and allow you to just say
public on constructor parameters or
protected or private and then we turn
them into automatically initialized
properties we also support some of the
other things that are coming in echo
script 6 like default parameter values
so I could say this guy is default value
0 and this guy is default value 0 2 and
then we'll inject a check for whether it
was undefined and if so initialize it
with the value you gave and now the type
checker understands that these
parameters are optional and so I don't
have to specify them and I don't get
wined up by the checker ok let me see
where we are in time I'm not going to
show you inheritance trust me we support
inheritance
um uh well okay let me just right class
point 3d
extenze point and you'll see now that we
then emit a super call blah blah blah
here this is actually this is the only
place where we will inject code that you
didn't write we here specifically there
are four lines of code that we will omit
a little helper to create a and a
superclass or derived class but other
than that we never inject any any code
and like I said we have no runtime
library it's just the JavaScript that
that you wrote and of course in a
derived class you can override methods
and call super and blah blah blah all
all of that stuff another pattern that's
common in javascript is modules or group
namespaces if you will like think of the
dollar namespace and jquery underneath
which are a whole bunch of properties
right that's often done by creating
writing a function that you execute once
and you in there reveal an object with a
bunch of properties and callbacks on it
then you assign that to some global
variable and we sort of capture that as
a pattern so I could say module utils
and then put everything in here into
that module like so and whoops let's
just scroll this guy up so you can see
it all and now if I say if I then export
the class notice when I say export that
we then create a property on the object
that you wrote inside the function
closure and now I can say var P equals
new utils dot and here we see there's a
constructor function for point etcetera
etcetera so this is how you get to
namespace your your code
and we can sort of follow along and
actually understand the structure of it
modules are open-ended I could actually
write in another file another module
utils and then add more stuff in here
and the two merge together you'll you'll
see in the end in the code that we
generate well actually now that it's
empty let's say export
why are x equals 5 you'll see that we
generate two of these guys and we the
first one gets to initialize the other
one just adds to the one that the first
one created all exports are export Oh
bar X there we go there you go
yeah ok so that's the kind of module we
call internal modules we also support
external modules which are the kinds of
modules used by nodejs and require Jas
you guys use no Johanns yeah
yeah okay okay up here yeah yeah I would
I would assume you do yeah yeah okay let
me show you what that looks like in fact
let's go back to the IDE here and let's
try to
open up demo
No and let me write a first write a
little note server and then afterwards
write a little note client module that
uses the server module that I that I
just wrote so well I'm going to start by
doing is I'm going to reference the node
data ts declaration file arm if I go to
the jump into it you can actually see
and hear all of the type definitions for
all of nodes standard modules and of
course you can add more more to that but
that sort of gets me set up to to write
code the next thing I'm going to do is
I'm going to import the HTTP module from
from node and then write a little HTTP
server here the ID complains that you
can't use external modules unless you
use a compiler flag that enables them
but just forget about that for now then
I'm going to write export function
create server
a port colon number comma message colon
string
like so and then in here I'm going to
say HTTP dot and now you see statement
completion on on node right and notes
create server takes a callback that is
given a request and a response object so
declare those and then I get to write my
code in here and again if I say response
dot you'll see that we actually know
what the type of that is because we know
that HTTP came from the HTTP module and
it has a create server method and create
server takes a call back that has a
request that is of type server request
and a response of type server response
so we can give those types and and so
the types flow quite a bunch here and
and you actually really typically end up
only writing type annotations for
parameters and then you write some
interface declarations and that's
typically or class classes and then the
rest just flows so let me try to fill
out the body of this guy here
there and then let's start the server by
calling listen what listen
note here that listen has three
overloads and we actually know what what
those overloads are armed so we'll we'll
pick the last one here call it with the
port number that was past him and that's
our little server module so I'll save
that and then let me open another blank
file hello and then let's try to let's
try to write a client that uses it so
I'm going to start by saying import
server equals fire up dot slash server
like so and now when I say server dot
you'll see statement completion on the
server that I just wrote right so 1337
here comma hello Google and then console
log of this thing on 1337 like so they
are done so those are my two little
modules let me go to
I put them and then let me just try and
compile them and I'll just compile and
I'll actually just say compiled hello
and oops yes I still have two styles and
I'll say I want them compiled for common
J s modules and the compiler
automatically finds all of my
dependencies here so if you look now
what happened it actually compiled both
files it produced hello J s and server
Gaius if you type server dot J s you'll
see that that's pretty much the code I
just broke - the type annotations right
and if you type hello J s it is exactly
the code I wrote because I have no type
annotations um now if I if I run this so
say node hello and then go here and go
to localhost 1337 ah they're my little
servers up and running so that's a you
know pretty simple to use a node with
with with typescript the to really fit
together very nicely
okay um other thing I could show here is
what the experience of starting with a
JavaScript project is and then upgrading
it to to use typescript arm
let me close this stuff out and let me
open
a project here called audio scope this
is sort of a silly little app that has
three JavaScript files in it and if we
try to run it you'll see what it what it
what it does it allows me to view WAV
files graphically um basically now let's
say I wanted to convert this to a
typescript project since typescript
since JavaScript files are basically
typescript I could actually do that just
by renaming all these files in here to
dot TS instead so let me let me try and
do that so I'll just call this guy TS
and it says sure that's fine then it
offers up if you want to add some
additional packages I'm just going to
say no to that let's rename this guy
also yep and this guy here
there we go there um let me actually
also just close the solution and reopen
it again because sometimes in this
latest version it gets a little funny
there okay so now I have the same
solution but now all the files are dot
TS files and instead and you'll note
that I get some errors here and we could
go look at what is it that the type
checker is complaining about here if you
go look at default dot HTM you'll see
that in here we just have a canvas
element and a selector element if you go
back to the application we do get
element by ID of file select and the
compiler here in first that file list is
of type HTML element but it's actually
an HTML select element that has
additional properties that that we can't
really guess but we could theoretically
by looking at the HTML file but but
that's sort of beyond what what the
typescript compiler does but here I can
then go in and add a type assertion why
I just say trust me it's an HTML select
element um yeah
you
all right so so a cast is less strictly
typed it says one of the types has to be
assignable to the other so as long as
as their and ship between them either
that the one you're casting to is a
super type or a subtype of the other but
if you're going sort of a cross where
you have two things that are known to be
completely incompatible then we still
complain but but so it's sort of a
weaker check if you will so I could do
that in here also I have the same thing
going on in my in my audio file i get
the wave view which actually is a canvas
element so if i add a type annotation
here for our canvas element you'll see
that i silence all my errors except for
one which i put in there just to make
sure it was there someone had a typo
here right and this is one of those that
you know and we find you know when
people do this they will and they swore
they had unit tests that check this but
it turns out that this one only shows up
if you have 8-bit sample rates in your
WAV files and I guess the unit tests
didn't test that right so if we try to
run you'll actually see that depth that
bug is in there and if I click on a file
that I know is eight bits then boom it
blows up but
perhaps there just wasn't a test for
that right so now we can go we can go
fix that bug and now we are sort of in a
gradually typed state
we have types for some things but not
for for everything
for example the wav file here is typed
as an e and that means here I could
misspell the data property and I would
not get any errors because we don't know
but but it's now one of the ways you can
you can tighten the screw so to speak is
you can compile with an option command
like a baile has an option called no
implicit any and I'm going to turn that
on and that really just says ok let's
let's tighten let's tighten down the
hatches here and disallow any forms of
untyped variables armed and now you
start to get a bunch of errors that and
now you've got you have to go stamp
those out right um so to speak and then
I could do that in my project here for
example ah here I would likely for this
guy
I would instead declare an enum this for
this constructor function I would
declare a class for these two guys here
I would add type annotations to the the
functions and finally down here I would
have type annotations on these
parameters and as I do that the errors
gradually go away I still have a few
remaining over here that I could step
out stamp out so I could make this into
a WAV file and then this scale point
here I know that it's a number and now
I've actually killed well all but the
last bill they are there so now I know
with certainty that everything has a
statically known type in here and that
now means that refactorings are safe in
this codebase and now I can now I can go
to work and and maybe I for the longest
time been wanting to change this data
property here to be called wave data or
or whatever right now I can safely do so
call it wave data and if you go look at
way
here that you see here that we now know
where to where to go change this in and
this happens in files and it happened
safely and the type checker will will
tell you whether or not it works that's
I mean that's really sort of one of the
very very big value propositions that
this system brings because as you get
into the really large code bases let me
try to show you a really large code base
um the typescript compiler itself oops
oh well actually let me close that
project
and let me just open the
I'm driver for the compiler so the
compiler typescript compiler is about
22,000 lines of code and then on top of
that there's about eight to ten thousand
lines of language service code you know
the code that implements refactoring and
whatever and all of that is actually
part of the repository so all of the
support that you need to plug into an
IDE is part of the typescript
distribution now this guy here we could
sort of try to look at how the compiler
works it sort of starts by executing a
command line and now I can because we
have static typing it's super easy to
navigate around I just say go to the
definition of execute command line it
shows me where that is that guide calls
my compile method I can go look at that
the compile method in order to type
check ultimately creates a called get
type checker if I go to that we see oh
but that's implemented in an interface
but then I could say oh well show me all
of the uses of this guy and here
instantaneously in 20 mm code where
where is this guy used and so here for
example is the actual thing that
implements that interface and creates a
type checker and I could go look at all
the places that's used or go to its
definition and so forth so the code is
is is pretty pretty easy to navigate
it's not a very huge code base but it's
still sizable on but let me show you
let's for example go to
by let's say a check if statement
here here's the function that type
checks an if statement and you note that
it first checks the expression that
controls and then the den and the else
part of the of the statement if we if we
go to definition of this on this guy
you'll note that this is just declared
as an object that has these three
properties I could go back and I could
say well show me all the places that
this guy's used and here you see all of
the places it's used in the checker the
emitter the parser etc etc now you'll
also note that there's another
expression note up here on expression
statement but that's a different
property and I could actually safely
just write here say you know I want to
call this condition instead and you'll
note that it changes that one and all
the places that it is it is referenced
in turn ah but it didn't change this guy
up here because we know the difference
between the two and this is something I
did on a daily basis we refactor like
that ah and it would just be hell on
wheels without it ah ah okay ah let me
undo that one let me just sort of as a
final thing show ya go ahead
right
you
sure sure so so we do it it's sort of
yeah okay so the question is if it's all
structural how can you tell you know
like whether that one implements the
interface and well so we cheat a little
bit there you know we can actually also
trace the normal nominal type
implementation tree so we can say all
the places that says it implements that
interface those we will go change all of
the places where a variable has that
type or gets implicitly typed to that
tight we will go change so you know
having all but once we have all the
static knowledge we can do a pretty good
job of it arm I wanted to just show
sorry
source compiler here maybe just sort of
compiling the compiler itself
just going to compile it into xxx but
then I'm going to ask it to also
generate a declaration file now one of
the things that's that's whoops oh I
forgot to say - out XXX - D and then
compile TS c TS and that compiles the
whole compiler and then generates and
that's 22,000 lines I mean it's it's
pretty pretty fast on it also then it
produced two files here ah a JavaScript
file which is the entire compiler though
and which actually consists of ten files
that it automatically traced down
because we know from from references
with between files but then I also asked
it to generate a declaration file and
this actually sort of becomes a synopsis
or a dot H file for the compiler if you
will and if I say if I open that one
see that in here is all of the exported
types in in the compiler so as you're
building projects in typescript you can
basically build the implementation or
the binary if you will which is the
JavaScript and you can build the H file
that you give to the consumer of your
library and we can automatically produce
both of those um and that's super handy
okay that's uh that's sort of my
one-hour overview
maybe I'll just go back and just briefly
summarize here oops
so as I mentioned that the typescript
the type system the way to think of
typescript type system really is that
it's it's a highly accurate static
representation of JavaScript type system
because even though javascript is a
dynamically typed language it actually
has a type system with semantics that
can be statically modelled and then
that's what what we do here but one of
the things that's interesting about it
is that that we do it sort of from a
different vantage point traditionally
type systems have either been entirely
off or or strictly checked and and we're
in a sense instead of having a switch
that turns types on and off we have a
dial you can you can set the dial where
you will you know you can be gradually
type more and more and the more you turn
up the typing the more benefits you get
and if you turn it all the way up then
you get things like safe refactorings
and and so forth so that's sort of the
way we think about our types in
typescript
as I said we provide polyfills for a
bunch of things including modules and we
we are committed to also supporting equi
scripts have a different but not
ambiguous syntax with what we currently
support so so ultimately we'll support
both node requirejs Acree script six and
internal modules done as executing
functions revealing and so forth
pretty active
and we have we're starting to see a lot
of people take dependencies on
typescript now Mozilla has an
interesting project called Shumway which
is an implementation of a Flash Player
entirely written in JavaScript and html5
it's a hundred and seventy thousand
lines of typescript and that's in on
github
there are several popular gaming engine
so it's JavaScript game engines I think
a lot of JavaScript games used to be
written in flash and a lot of these
people are moving to typescript because
flash and an ActionScript actually
already had classes and rudimentary type
annotations and this is in a sense just
to move into the standards world for for
those people
there's an interesting crazy project
called doppio which is a complete
implementation of a java vm written in
typescript that compiles to JavaScript
and it's amazing you literally boot up
Java in your browser it's nuts I talked
about the frameworks on definitely typed
where where I I think we're even above
700 now library definitions very very
active community there and we're seeing
a lot of support in tools of course I
showed you Visual Studio here but there
are plugins for Eclipse webstorm
actually the jet brain guys do their own
type checking and whatever but using
type scripts syntax sublime text has a
plug in their various build systems and
so forth
so right now what's out publicly
released we just released yesterday
typescript 1.3 in preview visual studio
we're actually in house currently almost
done with typescript 1.4 which will have
union types left and cons template
strings symbols etc 1 5 will have
destructuring and so we're just sort of
checking off all the Egmore script 6
features and ultimately next year we
will arrive at es6 parity with down
level support where we're
it's deemed feasible certain things we
can take down level meaningfully other
things we cannot like letting Const you
you can't really take a down level with
with with the semantics of Latin counts
so so we probably won't and then we have
like some stretch goals we'd love to do
a single weight which if you assume es6
is easy because you can you can build it
on top of echo scripts it's generating
want a down level it gets trickier
because you have to do some very gnarly
source code transformations to turn
function bodies into state machines and
your code looks nothing like what you
wrote after after we're done with it so
and then that sort of has sort of been
our mantra to generate beautiful code
and it's not beautiful so so we're
mulling that one over um but but it may
be that you know given that we support
source maps and whatever it may not it
may not be an issue that's pretty much
it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>