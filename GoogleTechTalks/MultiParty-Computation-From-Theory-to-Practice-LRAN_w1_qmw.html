<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Multi-Party Computation: From Theory to Practice | Coder Coacher - Coaching Coders</title><meta content="Multi-Party Computation: From Theory to Practice - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Multi-Party Computation: From Theory to Practice</b></h2><h5 class="post__date">2013-01-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LRAN_w1_qmw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so you might have heard that there's a
lot of effort especially DARPA funding a
huge research program in computing
unencrypted data so this is the idea is
you encrypt data and you want to compute
on it and there's different ways of
doing that so one way is to use on this
mega thing called fully homomorphic
encryption which you might have heard of
which you might also think is completely
impractical and I would kind of agree
with you but I'm going to kind of
convince you it might not be too
impractical at some point and the other
way of doing it is with multi-party
computation so what what I'm going to do
in this talk is show you can do both
together and get efficiency improvements
over the state of the art so I have two
side of what what is you know just to
kind of give you an idea of what we
would like to do in about 30 or 40 years
time or by the time I've retired or
something we've got two drug companies
each has a database of molecules and
toxicology test results and they want to
combine their results so didn't want to
know I've got drug a I want to know did
drug a kill someone when it was used by
drug company field did it kill the rat
or wherever and so they just want to get
the yes/no answer without revealing what
drug they're testing okay this is
apparently we've talked to a bunch of
drug companies in the UK and this is a
big big thing they want to do you only
want to come so they don't have to keep
replicating they might have done the
tests for different reasons the mom
might be trying to solve cancer one
might be trying to solve outs high MERS
but they still want to have the
toxicology results of sharing chemicals
and so that's one application you can
imagine you encrypt the databases and
you will do some sort of comparison on
them another one is if you have network
traffic and and the government or some
agency wants to search the traffic for
some anomalous behavior but the network
operator doesn't will give this
information away to the to the
government and the government doesn't
want to reveal exactly what it's
searching for but you still want an
outcome to know whether what's going on
so basically think of some examples
where you encrypt stuff and you we've
got private stuff you want to search it
or you want to perform some operation on
it the classic example which I haven't
put in slides is the one that's actually
deployed is in Denmark they have a sugar
beet they make sugar beet and they have
to sell the sugar beet and there's to
those monopolies sugar beet suppliers
and those monopolies sugar B purchasers
and they want to determine the clearing
price of the sugar beet every year weird
but apparently this is this is this is
it's Denmark yet it doesn't have
high-tech industry they just do sugar
beet
this is videoed whoops there looks
really nice place so they actually run a
sugar beet auction using multi-party
computation they actually encrypt the
auction the the comeup the amount they
will buy and sell and then they kind of
and then you execute a protocol to work
out what the clearing price is he's done
every year and there's actually a
spin-out company of the University of
Aarhus which do that okay so there are
two main ways of performing computations
on encrypted data and now the first one
that everyone's probably heard of is
fully homomorphic encryption this was
invented by um well sorry's the idea was
invented by Rivest and some others back
in 1978 but actually being able to do it
in theory was first done by Craig Gentry
in 2009 okay the idea is that party a
encrypts and data sends it to party B
party B does some computation on that
data sends it back to sends the result
of the computation encrypted result of
the computation back to party a and then
party ad Crips okay
and this you can this is slightly
impractical for general computations but
we can now actually do this for small
computations and there's some recent
work of Stanford and IBM where they
actually implement this for daily some
very simple database queries and some
relatively small databases but you can
do real computation with this the other
approach is what's called multi
computation and that was developed
around the mid-1980s mainly used as a
theoretical tool and here what happens
is that the if you have many parties in
a computation and they all have their
own input and they want to keep their
input secret they want to compute some
joint function of the inputs okay
towards the end of the talk I'll have a
much more concrete application i'm
scenario and then what you do is you
they want to compute this function but
they want to own they want no
information about their revealed input
so the classic prototypical example here
is is voting yeah you all have who
you're voting for you want to know the
outcome of the election but you don't
want any information about the what your
vote was except for what you can
determine by the outcome of the election
yeah I'm so for example if everybody in
the room were in Google yes so everybody
in the room I'm save out a Democrat by
one person okay and that one person then
there was a hundred people voted the
Democrat and the one voted for a
Republican and then the result came out
you know you would kind of you know you
would and you were the one Republican
you would know that everybody else was a
Democrat yeah this is you could just
compute what you can compute about the
inputs is what you could get from the
outcome but nothing else
okay so in theory theory both
technologies can compute anything that
everything's a done deal it's polynomial
time overhead it's a polynomial overhead
everything's fine and we can all go home
okay but there's a big big big
difference between theory and practice
so in fully homomorphic encryption we
actually need the overhead although
polynomial is a huge cost yeah
absolutely huge the constant is massive
um but the benefit is is there's zero
communication cost yeah I just send the
stuff to the guy the guy does the
computation he sends the stuff back and
this kind of that's nice and simple in
multi-party computation we had virtually
no computation cost I'm a small overhead
compared to what we would do in
computing the thing in the clear in some
weird computing model but still know
virtually no computational costs but the
communication cost gets very high so we
kind of pay in different ways and we can
make any technology error tolerance that
means in the sense that if the parties
and malicious and want to disrupt the
computation we can protect against that
okay but right so as it's very fetching
is currently impractical for all but the
simplest functions you can't take your
terabyte database or exabyte database
and does encrypted search on it and
that's out of the question though you
can still do some useful things and as I
say MPC has been deployed for some
operations there's this Danish sugar
beet auction sa P has a supply chain
management solution where they can
different people in a supply chain can
put their inputs and it will compute the
optimal supply chain without revealing
information so FH is impractical for but
MPC has been deployed it's been deployed
for the sugar beet auction I was talking
about I say P with the supply chain
management and there's one other example
which I caught which doesn't my mind at
the moment but it's meant to be three
examples but U is the stoat there's an
Estonian company called cybernetic ER
which has deployed a solution which is
which amalgamates a financial data from
different small startups to get a
aggregate election information from
those companies the thing is is that
everything that has been deployed in the
real world of those three applications
and everythin everything that's been
implemented as experimental systems
essentially only works against what's
called semi honest adversaries there are
adversaries that are allowed to listen
in to the protocol and try and work out
information if we go back to the voting
example they try to break the privacy of
the votes but they don't tolerate
adversaries that are trying to disrupt
the election or to disrupt the
computation yeah so we won't be what we
would like is to protect against
adversaries that can do arbitrary
computation and just want to completely
screw over everybody else okay and the
other thing that they require is that
for all the implemented systems up to
this talk um they can only have you can
only have three people in the
computation of which that most one can
be bad
okay so you can only tolerate one bad
guy out of three okay so what I'm gonna
show is going to gives it so for the
next few slides I'm gonna give a bit of
maths and I'm gonna show very summer on
ik actually and we're going to show how
to combine fully homomorphic encryption
a multi-party computation together to
get something that's actually much
better and more practical okay we can
tolerate as many parties as we want to
or more parties up we have n parties n
minus one of them can be corrupt and
they can execute any possible corruption
they can try and disrupt the protocol
any way they want and will detect when
they disrupt the protocol and we can
abort the computation rather than get
the invalid election result or the
invalid outcome of the auction or
whatever and the bad guys can
collaborate so as bad as you want
basically okay okay so to say that is
that the underlying crypto is really
really really simple it makes if you
understand the RSA cryptosystem this is
easy much much easier than RSA
cryptosystem we teach this kind of to
the kind of bare bones of this to
first-year undergraduate computer
scientists so this is really moronic
okay so assume there's n parties of
which n minus 1 are bad guys and we know
Sheila's some global secret key alpha ok
which is an interesting mod p and but we
don't actually know what it is what it
is is that party one generates around a
mouth for one party two generates around
a meal for two and this global secret
which is secret is just defined to be
formally the sum of the random numbers
that they've all chosen okay so that's
the kind of setup and then what we're
going to do is we're going to secret
share the data so every every piece of
data item within the computation is
going to be shared in roughly the same
way so if I have a a data value X it's
going to be shared with the date with
the parties as fossil follows
everybody's going to have a value X I
such that the sum of the X is equal to X
if there's two parties I thought x1
you've got X 2 and the X is X 1 plus X 2
and we also hold each heart apart party
holds a share of a Mac a message
authentication code
on that particular value X so but the
Mac is just purely alpha that's secret
from the previous slide times X and we
share it out so I have gamma one you
have gamma two and together if we have a
Mac and the poor idea of the Mac is that
this is going to check that we haven't
done anything wrong okay so this is the
actual data and this is the check data
okay so for every data item we have two
pieces of data so we just got an
explosion in two in the total amount of
data were storing and if we have a
public constant you can kind of
trivially share it by party one can take
that constant V everyone else takes X I
equals zero and we can have the Mac is
just out for I times thee and that would
be correct
okay so simple everyone get this yeah
good okay now if we have a sharing like
that we'll call it square brackets X to
denote that it's been shared shared with
this Mac and what the protocol is going
to do is it's going to work in the pre
processing model so imagine it's like a
bank in the overnight you do shitloads
of computation and then during the day
you actually want to process
transactions so you do lots of
computation overnight and then during
the day you you consume the data you've
computed over the night as you do the
computations during the day okay
so overnight what I'm going to do is for
some method magic methods which I'll
explain later i compute sharings of a B
and C such that a zit
we've got sharing very share and be sure
and a C such that C equals a times B I
produced millions of these overnight
yeah in a way I'll explain later so just
imagine these has just been given to you
for free at the moment okay so how are
we going to do computation so what we're
going to do is we're going to represent
the computation as what's called an
arithmetic circuit over F P so in other
words we express the computation as a
sequence of multiplies and additions
modulo P okay now computer science 101
is we can do this because we can write
everything down as a binary circuit and
we can take a binary circuit and we can
write it out mod P
you can write it down as additions and
multiplications both P that's one way of
doing it of course there's more
efficient ways because we can work with
more people can think appears a 32-bit
prime or a 64-bit prime 128-bit Prime so
we don't have to work with binary gates
and actually it turns out we can do a
lot more efficient stuff here but for
ease of exposition I'll just assume we
write everything down as a circuit but
that's not actually how you compute cuz
that's just stupid yeah but let's just
assume for ease of exposition we
everything we can write down as a
circuit we know that yeah and so we have
the cout function we want to compute we
express it as a circuit and then we have
the players input slightly on my vote
okay
so what I do is I I shared my vote
amongst the parties in a in a manner
which I won't explain how to do that but
that's easy so just imagine what we've
got to the position where we have the
function as a circuit and the inputs of
every player have already been shared in
this way amongst all the players so if
we're going to evaluate the function all
we have to do is work out how to
evaluate the circuit and if the circuit
just consists of the addition and
multiplication gates all we have to work
out is how to compute the addition and
multiplication gates okay it turns out
addition is easy and multiplication is
hard okay
so we'd like what we try to do is create
a function which has as many additions
as possible and try and reduce the
number of multiplications essentially
every time we do a multiplication we can
have to do communication so that's going
to be a bottleneck okay so so far I have
okay so i've lost an order of magnitude
in f11 power of 2 yeah a factor of 2 by
this one
okay so just doubled the amount of data
I have to store ok so if I want to throw
32-bit values or 64-bit value so just
have to hold an extra value per player
ok here I have to write everything out
as a circuit but this is a
simplification ok in the way we're kind
of currently in
and stuff we don't write things down the
circuits we write them down as programs
which have op operations which we have
special protocols to execute those
operations but for ease of exposition we
have a bit of a killer in this thing so
and that's quite large bitch polynomials
so theoretically it's okay okay at the
end of talk I'll give you some real
numbers and you can actually see what
the difference is okay so the more
complications of what's expensive
computationally changes okay so but
you'll see that will come clearer when
you see some numbers at the end okay so
we've got to add add two numbers
together if we add two numbers all we
have to do is locally add our two values
that we've got shared so here we've only
got they sort of happen to do an ad in
the clear if you were doing it clearly
now to do to add so the explosion here
in cost for Kevin's question is is is
trivial okay here so addition is trivial
in a bit just locally add and we can add
and if you want do the mass the officers
EDD is X plus y likes if we add up all
the sir dies then it's just the ads of
the exercise is kind of that yeah it
really is trivial okay and then the max
work because the max work so addition is
trivial and essentially that addition
works is because this secret sharing
scheme is what's called a linear secret
sharing scheme is that when we secret
share a value we can compute any linear
function of it for free okay so if I
have secret shared values x and y and I
have public constants V 1 V 2 V 3 we can
with no communication and no extra cost
effectively compute any linear function
okay that's because everything shared
linearly it's just it's just linear
algebra yeah so linear linear stuff is
for free ok and this is the trick we're
going to use that linear stuff is for
free now in what follows which should be
on the next slide but it's not enough
lines on the next slide is that if we
have a share
well I mean when I say partially open a
value what I mean is I give away my my
sharing of that value so if we go back
to this slide by partially opening the
value it means I reveal the excise but I
don't reveal the Mac I'm always have to
keep the Mac secret and if you think
about why I have to keep the Mac secret
is because if we all revealed our values
shares of the Mac we'd all be able to
compute this value with know this value
and we could always and then everyone
can compute the secret key and we want
that secret key to always be secret yeah
so we never reveal the Mac value so what
we're doing is when we say partially
open a value we reveal the X I but not
the gamma I okay everyone following so
far yeah okay okay so here's how you
multiply which that's really complicated
but it's actually really really simple
okay so we will multiply a sharing of X
with a sharing of Y together sharing
have said so what we do is remember that
stuff we did overnight we had these a
B's and C's so we take one of those a
B's and C's off our list and then I'm
going to partially open X minus a ok now
what if we think about that a surroundin
value so X minus a is like a one-time
pad of X yes so epsilon is a encryption
if you want of the value X so X has not
been revealed there's no information
revealed for from revealing epsilon I
partially open Y minus B let's call that
Rho and by the same argument B is like a
random value I've masked Y with it this
is like a one-time pad and so there's no
information in Rho and then I just well
I know it's eylem now I know Rho I know
it's silent times Rho because I got
silent I know Rho so I just compute this
linear function of Zed and I can compute
linear functions for free okay so every
what we notice that every time I want to
do a multiplication I require
interaction I need to send two pieces of
information out and I need to receive
two pieces of information from each
player
so that seems to we need to older
n-squared communication but you can
tweak that so you get older end
communication everything is a one-time
pad and we get the correct result by
just this cool piece of maths so let's
suppose we were computing this thing in
the clear well we would compute C plus
epsilon times B plus Rho times a plus
epsilon times Rho and then you just
stick in what the epsilon and the Rho
are there's it's silent there's Rho as
if silent there's Rho and you expand it
all out and you notice everything
cancels and you just end up with x times
y this is quite funky yes there's a nice
funky know the protocol for computing
multiplications but the killer is is you
require interaction it turns out it's
not the amount of data you send which is
going to be your limiting factor but
it's actually the number of packets you
have to send so what you want to do is
you want to amortize the number of
rounds you do it's actually sending
stuff is actually the process of sending
stuff is what takes time not the amount
of stuff you send okay so that's that's
how we evaluate the circuit we can add
by doing that and we can multiply by
doing that okay and if we just did that
we would have a protocol that is
passively secure in other words if we
could guarantee that the adversaries
always followed the protocol we would be
able to compute any function securely
without revealing any information about
the inputs and as it stands this
protocol would be passively secure and
would be better than the other solutions
I talked about the one by the Danish the
one by the s AP the one by Estonia and
all the other ones that various
academics have ever created okay so on
its own this is just as efficient if
probably if not more so than the
existing state of the art but we want to
protect against people cheating we're
going to use the Mac's to do that so
what we're going to do is interactively
check the Mac values which is as follows
so imagine it with what executed our
protocol we've got to the end with
evaluated our circuit
some point executed T multiplication
gates so there's been T partially open
values which we'll call AJ and to each
one of those we've got an associated Mac
value yeah where each player holds a
share of that associated Mac value and
each player also holds a share of the
Mac key but we want to be able to check
the Mac's are correct without revealing
the Mac key itself and we do that once
and for all at the very very end of the
computation in that we generate some
random values between us that we all
agree on we then just form a single
value by adding up all the partial
values we form a single Mac share by
adding up all the various Mac shares
with those random values and then we
form the value Sigma I each party forms
Sigma I which is gamma I minus alpha I
times a we know that we've just computed
that that's our combined share of the
Mac that's the global value which is
computed and then we broadcast the Sigma
ice and if all the computations are
correct
then the Sigma eyes must add up to 0 so
in other words checking the computation
at the end is effectively broadcasting
of one thing so if you compare that to
previous methods where you have to do
lots of lots and lots of computation and
communication that every multiplication
go this is trivial this just checks
everything all in one go so essentially
get protection against malicious
adversaries at effectively the same cost
in running the protocol as if we've just
protecting against passive adversaries
so protecting its malicious adversaries
is just for free yeah ok ok you kind of
- we does you commit then open yeah so
there's a kind of like yeah there's a
kind of there's levels of inter yeah I
see two kind of hash and then open the
hash whatever yeah yeah yes you have to
make sure that when we say send there's
not the problem that who goes last has
an advantage yeah ok
so I kind of cheated in that one I said
there was some pre-processing and the
other thing I cheated in the sense that
I I haven't said this is just a
multi-party computation protocol and
I've said that I'm going to make
multi-party computation go much much
faster by using fully homomorphic
encryption which is meant to make things
run slower yeah okay so I'm going to use
don't that makes things around slower to
make something run faster I haven't told
you how to do that well the fully
homomorphic encryption occurs in the
overnight phase this offline phase and
that's in where we compute these the C
the a and the B these triples that we're
going to consume okay so the following
is a naive version of what we're doing
you could actually scale it up very very
this this is what this might look very
inefficient but when you actually
implement it this runs very very fast
okay because you can do many many
computations at once all in parallel
with virtually no overhead okay so a
fully homomorphic encryption scheme
essentially just basically we can
encrypt some some message under some
public key it gives us a ciphertext trip
some message under a public he gives
there's another psycho text and with we
decrypt the addition of the two cipher
texts we get the addition of the
messages and if we decrypt the
multiplication as a ciphertext we get
the multiplication of the messages okay
now the reason why our use of fully
homomorphic encryption is going to be
efficient is that we're not going to use
fully homomorphic encryption we're only
going to be evaluating circuits using a
home wolfg encryption scheme which have
multiplicative depth one in other words
we allow as many additions as we want
but we only allow a single
multiplication okay
so we're gonna need a little bit more
it's what we're gonna need is we're
going to need a distributive decryption
scheme for the fully homomorphic
encryption so every party is going to
have a secret a share of the secret key
of the fully homomorphic encryption
scheme and that together they can
together decrypt a ciphertext okay this
is easy to set up if you have shared RSA
signing keys it's roughly set up in the
same way shared DSA signing key shared
el-gamal decryption shared our say
roughly the same idea so there's nothing
really you know it can be done very easy
to set up so don't worry about that and
then how do we compute so remember that
key that everybody had that share of the
mat key so we just in compute an
encryption of the share of the mat key
at the beginning and then we're
completely done and then if we've got
this share encryption of the share of
the mat key that means everybody can
compute an encryption of the mat key
because it's additively homomorphic so I
just add up all these ciphertext and by
magic I get an encryption of alpha okay
okay so one protocol we need now this
game looks slightly complicated but if
you go into detail it's relatively
straightforward so I've got some Slifer
text and I've got which encrypts of
value m and what I want is I want
everybody in my protocol to obtain a
share of that that I'm value on what
they ought to get an mi such the mi sum
up to M without knowing what M is and I
want to get an if poss if needed I want
to create a new fresh ciphertext which
encrypts them so what I do is everybody
just comes up with some random crap and
encrypts it okay and then just sends the
random crap out okay
now let's imagine this round of graph is
Fi and F is the sum of the advice so I
can create a ciphertext which encrypts M
plus F by taking the ciphertext which
encrypts m and adding to it all the
ciphertext everyone just individually
created yeah so that's a ciphertext
which encrypts M plus
now what's F F is just some random crap
that everybody's produced because
everybody's in computed random crap and
just added the crap together so trap has
crap is crap okay so now what I do is I
decrypt the cipher text which is M plus
F to give me m plus F surprisingly
enough and then party one can set his
share M 1 to be the value just obtained
- his random thing party I not equal to
1 sets em I to be - the random thing he
came up with and then if you notice that
if you sum all those up together you'll
get em that's nice and and we can create
a new cipher text by encrypting m plus F
and subtracting this where we use some
sort of default randomness and the
reason for doing that is we want to keep
restricting to multiplicative depth 1
circuit so if we multiply we don't want
to kind of bring the the crate kick
creating fresh ciphertext okay so happy
not happy happy vaguely okay so here's
how to generate M be given those
components very simple everybody to
generate a you just generate some random
AI everyone generates a random AI you
encrypt your random AI but the fully
homomorphic encryption scheme you add
all the encryptions of AI together to
get an encryption of a you multiply the
two things together to get an encryption
of alpha times a and then you execute
the reshare protocol to get your sharing
of the mac yeah because if you have if
you wanted to have a sharing but to get
the shares of the mac you have to
compute a sharing of alpha times AC just
do the reshoring
and you do the same to get B okay so how
am I going to compute the encryption how
am I going to pre-compute sharing of see
I've got an encryption of a encryption
of B
do the exactly the same trick exactly so
I just got the encryption of a the
encryption and bi multiply them together
that gives me encryption of see ivory
share it with miry share protocol that
gives me my sharings of C and then I can
do the Mac in exactly the same way okay
and this is efficient you know every
time I when I execute one of these
operations I'm actually producing tens
of thousands of these triples in one go
yeah with virtually no overhead so the
so I can produce millions and millions
and millions overnight just keep
churning churning churning it's very
very simple and we can produce even
other we can do other stuff in the
pre-processing phase which I won't go
into because we're only going to imagine
we're evaluating circuits okay so that's
basically the protocol and that's called
speeds it's called speed because um it's
me smart
Pedro damn garden Zacharias and in our
house they thought it would be much more
fun to reorder the application the
author name so it spelt out speeds
because it ran fast okay so it's speech
there's another protocol called n nos
which is very similar very similar but
slightly different but the point is
these are the two fastest protocols we
have implementations for currently
available which are actively secure for
any number of parties from two upwards
the main thing is that the speed
protocol works for working with
arithmetic circuits modulo P and n n LS
is better for working with binary
circuits okay so whatever funk so
specific functions you want to evaluate
some will be better with binary circuits
some will be better with arithmetic
circuits so you'd pick your protocol
suite depending on which one is better
okay both are speed both speed and n nos
so for a mum this years crypto so the
actual IMP use of the creation of
protocols is from crypto but since then
has been lots of implementation work
okay so how do we suppose the
performance what's the real numbers
okay so there's been lots of work in the
literature about evaluating higher level
functions than just addition and
multiplication so if you want to
actually compute a higher level function
you don't actually evaluate you don't
write the function down as a circuit and
then evaluate the circuit yeah if you
want to do a comparison circuit you
don't write down the comparison circuit
you know you'd actually do something
slightly more intelligent if you want to
compute a would do a floating-point
operation you don't actually execute the
floating-point thing although it does
take a while okay you'll see in a minute
and what we have now is we have an
ability using the fully homomorphic
encryption to took more function
independent stuff in the offline price
in this pre-processing phase we don't
just have to produce these triples C a
and B we can produce anything we want
which will be in use for general
computation later there's a lot of work
we could doing at the moment trying to
take stuff that you do in the online
phase and move it to your Flex for
interesting functions like floating
point operations comparisons etc so in
the next slide you'll have one line
which should input if you know anything
about multi-party computation the one
line will impress you and if you know
nothing about multi-party computation
the other lines on the slide will make
you laugh okay in terms of it that the
the runtimes are very very slow but give
you an idea of what the current state of
the art is and when we as I said part of
the issue is is that when we send data
along a network it's not the amount of
data we send which is the computation of
bottleneck it's the the fact that it's
the number of times we send information
so what we do in our code is we have we
apply lots of optimization algorithms to
reduce the total number of rounds of
communication so we take an arbitrary
program and then work out what the
minimal number of rounds of
communication there would be okay so
here's the numbers okay so if we want to
do a 32-bit integer multiplication okay
we can do about 800,000 per second
that's about a 386 okay so that's the
impressive line we we can compute
okay that's a good question
386 how many were born when I was a 386
okay okay so just how many programs at
386 or used a 386 at home okay you could
do stuff with it yeah so okay
above the explosion in vice and
everything down as an arithmetic circuit
we could securely evaluate a pacman game
okay
so or whatever else you did on 386 so
this is we can this is real computation
yeah this is this is something useful we
could land someone on the moon securely
yeah so this is real okay the problem is
is that not all the functions that
you're used to computing on a
microprocessor and not necessarily that
can be fast so okay so that the reason
the 32-bit integer multiplication that
that is the timing after four months of
aggressive optimization right only four
months okay so we've ggressive Lee
optimized throwing all sorts of bells
and whistles at it we can do we can get
that and the latency is point zero zero
one of a second okay so the other lines
our timings produced by my PhD students
the day before Christmas so they
probably weren't focusing too much on
doing optimizations and they're probably
only spent two or three days optimize it
but the hot-off-the-press off by
Christmas holidays hot off the press
it's to do a 32-bit integer comparison
so if you have values that we know are
32 bits long
to compare them we can do 2500 a second
okay which is about a four thousand whoa
it's not even the four thousand four
because an Intel 4004 did forty six
thousand a second okay however this 32
bit interested comparison that's exactly
what you need to do to do the auction
application yeah so or in some sense
voting yeah you know you add stuff up
and then you do a comparison so it's not
actually that no so you can imagine
reasonable computations that you would
want to do but not searching your Mexico
database and then we have floating-point
operations
okay so weirdly edition takes longer in
floating-point because you have to align
the thing so you don't know how much you
have to align yeah because the exponent
in the floating-point value is secret so
you don't even know how much you neck is
it's the secret value yes you don't know
how much you have to shift but you can
still do it okay and we can do about 50
ops per second this is we implemented it
and just did it no optimization okay or
we can do a hundred of multiplications
multiplications are fine and okay the
ENIAC did 384 flops okay so we can't
even meet an ENIAC at the moment okay so
but again I reckon we can get I reckon
we should be able to get a factor of 100
by the summer okay which is a good mean
we're gonna be faster than any AK yeah
we'll probably be at edsac speed or
whatever okay my ENIAC timings are from
there if you want to look up weird
timings of Earth micro processes okay so
this is what speed can do moment okay so
that's the large finite field so when we
do it arithmetic circuits no no no if
not four months of pre-computation this
is for every integer multiplication I
can do I just consume an integer much
you know three times as much stuff so
it's not really that much stuff being
transferred so four so in eight thousand
eight hundred thousand I'm transferring
one point one point six million fun
32-bit values across the network okay
these are two points on a toll and all
actually what's interesting is we can
scale this up for ten parties and we get
very little difference in the same room
yeah might kill ya kill you but the
thing is is that um you can recompute
stuff whilst we're waiting for stuff to
come over the network so we're not
actually you were yeah note the
protocols with design so we never wait
yeah
so the real the real cost is actually
sending the signal to the operating
system send this stuff and then get the
stuff back at the end
okay so if you actually wanted to
compute over small finite fields this is
where you might want to either use the
variant of speeds or you could use this
nos protocol so here you what we do is
we evaluate the a s function so this is
a very very complicated function and
here we assume that the players have
distributed the secret key so we have a
secret key shared amongst a set of
players and they want to include compute
a decryption or an encryption of an Aes
block okay now this was done in the
summer at crypto using fully homomorphic
encryption and you could encrypt an Aes
block and it would take you a few days
on a very very large machine 256
gigabyte ram machine yeah so this was
not a desktop well not of desktop these
days okay so the question is is can we
do can we do something faster and
actually turns out that whilst it might
take ages to compute a floating-point
operation we can actually do we can do
with a s we can get these done times for
speed and get a four for four through
per second at about a latency of point
to 36 and with n nos we got a latency of
three seconds but in that time you can
do 33 at a time and these are very very
at least these are these implementations
haven't been touched since the summer
and we recommend get a an order of
magnitude improvement on these
straightaway I'm just by better
programming okay
so we recommend get a factor of 10
improvement instantly so why would you
care about evaluating asar seems to be a
stupid example to evaluate okay okay so
think of the following there's been
various attacks against super low end so
this with one application so that the
various attacks gets stored password
systems
okay so emc RSA have a solution to this
and their solution works the static
passwords in the following sense is that
when i want to log in to a site with a
static password I split my but I saw my
password together into
two things p1 and p2 now the certain now
what I do is a use where I sent p1 to
server 1 and p2 to server 2 now the
service they've got the password they
just want to compute and compare the
password yeah so what they do is they
split p1 they've they've already got
they they don't hold P they held a share
of P they hold p1 of s and P 2 of s yeah
so what the emc RSA solution is is that
what each server does it just computed
Azure and they send TI to each other and
then the service just check whether t1
is equal to t2 if t1 is equal to t2 then
the user must have entered the right
password and the benefit of this is that
for static passwords
you can't break into the if you break
into one server you don't compromise the
other thing now you can say why the hell
are you storing passwords in the clear
anyway but in some sense the password
has to go over the network so if you've
kind of sent one to one guy and one to
the other guy
at no point unless you break the channel
communication between the two points is
the password ever there so the password
is only ever in existence in this system
on the user's own machine
you say even if you would then kind of
even if you had a system where you kind
of encrypted the password to the server
and there's server then hashed it and
then compared it to the password file
then this you know you'd still have on
this if you broke into the server you'd
get the password yeah ok so so that's
what they're proposed solution is but it
only works with static passwords which
is kind of bit silly because I say
actually make dynamic password things ok
so um so the dynamic passwords what do
you what would you do so here's the so
where did you have bad passwords or you
have dynamic passwords insecure ID
tokens do you still have a secure ID
tokens in corporate America I don't know
you do equivalent ok so he still exists
um I'm ok so we haven't seen one for 15
years but we see them all over the place
in the oh I have just but I haven't used
one ok but we see them all over the
place in Europe because we have EMV chip
and pin cards ok
which we use for a banking application
so whenever I connect to my online bank
I essentially create a one-time password
but we've actually there's encryption of
of some data that appears on some
one-time system with my chip and pin
enabled credit card okay so typically
you could imagine that the password that
you actually type in is the is
encryption under some master password of
some nonce by the some value of some
transaction of his new banking or it's
some counter or whatever okay so a
dynamic password system you kind of
typically it would look like AAS encrypt
under some secret which is stored on the
server and by the user of some stuff
that's known by everybody and the idea
is if you produced the valid AES cipher
text then you have access to the system
okay okay so here's something we're
working on with bar-ilan and party Xia
which is which is to spin out in Denmark
so we've proposed system to various by
such dynamic passwords and and you need
to compromise all the servers to break
the system and the solution is really
simple you just apply multi-party
computation okay and with the runtimes
we have on this slide for a s we just
divide them by a factor of 10 that meets
the actual requirements of people who do
dynamic passwords in the real world so
we can be actually with virtually okay
they have to have a bit more iron at the
back of their machines but it's it's
relatively straightforward to do and we
actually working our system to do this
for real and extending it to DES md5
based passwords and sha-1 based
passwords and to get improved runtimes
so that's kind of why you might actually
want to do various functionality I've
actually seen a system which does by
another company which does multi-party
computation of AES decryption of email
so you have a encrypted email this is
encrypted
the key is transported with RSA but you
want to do searching of that email as it
goes across the corporate boundary so
what you do is you put a gateway on the
corporate boundary which is divided into
three three two or three servers and you
send a share of that key to
the is key to each of the servers they
decrypt the encrypted email run the spam
checker or whatever you know the
corporate policy on the email along that
thing securely so they not only do the
is decryption of the email but they also
run the the you know the the mission did
the that yet the filter yeah they were
expressed the filter as a as a as a
finite state machine in a way that is
suitable for multi-party computation but
because filters usually use if
statements if statements are a bit of a
problem because if I do a branch I
reveal which branch I do so I actually
have to write my filter in a way that is
non-standard in a way that doesn't
involve branching computations and
that's actually possible and it runs in
real time so you can send emails and it
detects whether there's like secret
mentioned in the email or ovens blocks
the email going through the gold gateway
you've outed here is is that you've
split the corporate gateway into three
so if you break one part the corporate
gateway you don't reveal everything okay
so that's basically where we are that's
the state of the art in multi-party
computation in fhe any questions
okay haha right so as this is quite good
good thing in that originally we looked
at a s because we thought that would be
rather hard to compute because strict
block ciphers they're meant to be highly
nonlinear and that and they're meant to
be really hard to Krypton and analyze so
they have very little mathematical
structure so let's look at a s turns out
a s has huge amounts of mathematical
structure which enables it to be easily
implemented with a multi-party
computation so AES is like designed as a
block cipher that's sufficient to
evaluate in multi-party computation I
mean so you know you're evaluating the
function which is essentially of degree
two to the 60 is if you think of it if
you expressed it as a circuit it would
be of degree 2 to the 60 but you can
still evaluate it really really
efficiently because it's got so much
mathematical structure you just kind of
very trivial
okay so I'm statistical applications so
Microsoft using fhe only have a really
cool demo where they do machine learning
on to databases so you have two
databases they do which are encrypted
with fhe in real time I think they take
five seconds I don't know how much their
training data is yeah so
dallisa pick numbers up ahead suppose
you have training data of a thousand
records in the database they can learn
to a cluster analysis to get the
clustering data on on the training data
of a thousand in about a minute but
using just purely fhe and then they can
match things into the cluster as you
know they get new data and they can put
it into the right cluster in also a
matter of seconds so they have but this
is again it's just particularly what
happens is is that if you have a
computation which has very very low
degree it's very easy to evaluate so
it's the degree of the function you're
evaluating that's complicated so a most
statistical tests are linear or
quadratic yeah taking the mean is the
linear operation means a trivial
standard deviation as a quadratic
operations are less trivial if you think
of you know most custer stuff almost you
know like single value decomposition
whatever this will matrix stuff so this
is kind of hit stuff with matrices it's
just quadratic so we can yes we can
compute relatively simple so the real
issue is is can you come up with a high
value enough application that doesn't
have loads of data the more data
you have it's going to kill you I just
have to just you know there's kind of
sweet spot that you need to hit but
floating points I mean that's the real
killer app once you could do floating
point you can do yeah there's lots of
applications of floating point out there
there's not not necessary databases but
kind of I'm just want to do with
satellites hitting you want to know yeah
or um yeah you can imagine you've got
coordinates and you want to kind of
people that things are traveling and you
just want to run two body problem in in
computation
yeah that's the question I emailed my
student like on the 4th of January bees
on skiing holiday services yeah yeah so
what's called fixed point calculations
we don't have the encrypted exponent
should run much faster okay but we kind
of but again you know this is kind of we
expect those numbers to come out very
very soon yeah I would expect or a few
orders of magnitude the fixed point the
calculations are much much simpler and
also it depends whether you want to be I
Triple E compliant as well so that so
that floating point calculation is I
Triple E compliant it actually executes
the I Triple E okay so the issue is is
when you do rounding and to get the
rounding in the correct order if you're
willing to pay a error in the rounding
of one bit you know so you are you
either round up or round down and you
know then it runs much faster as well so
it depends that you know exactly what
you mean by floating point so again you
know again you have to change your view
of what you're computing that's the
worst possible case for floating point
scripted exponent and I Triple E
compliant is on some Germans so this
huge number of applications are there so
some Germans have a working
implementation of a two-party one which
does using completely different
technology which does no-fly zone no-fly
lists so if you have a picture on the
no-fly list and it matches the biometric
information of the picture at the
airport so that the the TSA TSA is the
right an acronym isn't it yeah I don't
know what it stands for TSA yeah so the
TSA have a no-fly list of faces and and
that they don't would reveal what the
no-fly list is but you can just send the
encrypted biometrics from their face it
can match against the database and the
people don't even know what FaceTime
actually gets the
basically just know where it's yay or
nay both parties learn where it's yay or
nay on the no-fly list without reviewing
a no-fly list and without revealing the
person they're testing and you could do
that if you can do that for faces you
can do it the fingerprint you can do it
for but that's doable but I'm not quite
sure of its scales I mean that's that's
really academic test I'm not quite sure
whether that really does scale you can
get the throughput you need but you
don't need that much I mean isn't yeah
it's comparisons to the issue so but
it's kind of it should be it should just
scale linearly because you just aim
you're not doing you're not doing a
binary search you're just doing you have
to test against everyone anyway the
other oh and so there's some people in
America a B shall act and some others
have a system for just to party
computation they can evaluate binary
circuits that billions of gates per
second but again it's a completely
different model and it only works for
two parties and so so but you can so
these things are becoming much more
realistic yeah so the improvement is
like ten orders of magnitude within the
last year and so you can expect you to
have the orders of magnitude improvement
going forward</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>