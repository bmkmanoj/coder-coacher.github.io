<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Using Fit: An Open-Source Testing Framework | Coder Coacher - Coaching Coders</title><meta content="Using Fit: An Open-Source Testing Framework - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Using Fit: An Open-Source Testing Framework</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/He1LkcKMsA8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I
I want to introduce rig Magwitch from
all the way new zealand rick has the
crazy idea that we can talk about tests
and can define test when we talk about
features and developed a couple of tools
for it and he will talk about this today
thank you Mark in good afternoon please
three here so I'm going to be talking
about fit which is an openness open
source framework and I'm going to start
by talking a little bit about that which
will give you a bit of context before I
start tackling the issues that have been
raised how many people here are how are
already put on you look that okay and
and how many of you are interested in in
tests and or test-driven development
okay great so if I talk about anything
you don't know about please just
interrupt me I'm having to take
questions at any point I've got some
material i'm going to skip over because
it might come in handy and and I I
always kind of make it up as I go along
with it so please bear with me okay so
we'll start by talking about fit and as
you can see I've written a book about
that with Ward Cunningham last year so
this is milan my advertisement i suppose
you could say so fit was developed in
2002 at that time I'd been working on
agile software development I I generally
work an agile software development
although the things I'm talking about
today can be applied outside of that
context although some of the thinking
comes from that and you'll see in my
presentation I'm kind of assuming that
so Ward developed an open source
framework which was very powerful at the
time I developed a few frameworks and I
wasn't very happy with them and I
shifted over to using his and then I
started doing further development on top
of that so fit is a is available on the
web available and lots of languages it's
based on a very simple notation that's
kind of doesn't look very for
and this is tables as we'll see shortly
and those tables are a way of expressing
requirements and or tests now one of the
things I'm going to lead to in this talk
is to start by thinking about these as
being tests and by the time I finish I
want to talk about them as being a
requirements executable specifications
and so we're going to switch things
around so it's about testing and it's
also thinking about in a way of
specifying what a system should do so
it's not necessarily a back-end
something that happens at the end of the
process it's something that happens all
the way through right from the start so
these tables are initially were HTML was
used it's a very simple format and the
the data and the tables is is
essentially interpreted in a very
general way so if it is a if you're
familiar with domain-specific languages
it's a table-based very general purpose
domain-specific language there are a
number of tools that have been developed
fitness as a wiki based tool more
developed a very simple one this was
developed further by Micah and Bob
Martin and a lot this is probably
especially in the US is the main tool
that people use for developing it I've
done a lot of development on top of feta
which I call fit library and which is
used extensively as well and has been
ported by various people into a range of
languages so just very quickly before I
show you some examples using Fitness is
here here are four separate very little
tests so they don't give you much of a
sense of what of what a story tests will
look like I call them story tests for
good reason well I'll come back to that
later but they're not just a test
they're also telling a little story as a
concrete example and in this way they
act as a kind of specification this one
here is a very simple workflow which are
specifying a trace through the execution
of a system and it's showing here is
some initial context here are some
actions that are carried out and this is
what we expect at the end
some other kind of tables this is
representing an invoice and which is
laying out information the parts that
are green are these are actually reports
from the test having been run and
showing that the that the test has
passed and as with j unit or in unit the
the red green coloring is used to to
signal that something is correct as a
programmer which is primarily what I am
I now don't feel happy until I have a
lot of green and I don't really feel
like doing anything until I have a bit
of red so that's kind of my attitude
about writing a test and developing to
pass the test so the top table shows
where something is not correct something
hasn't passed either the test is wrong
or the system is wrong because the best
we can do is we have two representations
of a system and we're checking them for
consistency and it's just as easy to
make mistakes and the tests as it is in
the code within fit library I've added
the capability of going beyond plain
text within the tables and here's a
simple example where a graph is
represented as it happens by dot and the
tests can then be it more expressive
around a graphical structure ok so what
I want to do is show a little bit of
this in action and let me make this
bigger so this is not going to display
as well as it might because I've I've
upped the resolution can you see that at
back is that enough ok so here's an
example of a simple business process and
it's similar to the one we saw on the
screen and so in fitness I can edit that
by either editing and underlying wiki
format which looks like that so it's
relatively straightforward to get into
for people who are who are not
programmers who are not used to
technical stuff some people don't like
this as a notation and would prefer to
use HTML but essentially that's what the
underlying former's
Mike and we can then I can run that as
an individual tests and as you can see
the test is passed I'm getting green
it's possible to have a set of tests
which make up a sweet and here I've got
a suite of things and I can run that set
of set of tests as a sweet now once the
set of tests build up I have a large set
of sweets sweets of sweets and I want to
be up to then run these storytests in a
lot of different ways so the same story
tests when I run them and with slightly
different configuration may test the
system at the domain layer level it made
run into the different subsystems it may
actually test through selenium into a
web-based interface or it might run
through swing or some other GUI so the
story tests are somewhat abstract
representation if you're familiar with
use cases they are kind of their
equivalent to the notion of essential
the essential part being not too much
detail about the fine-scale interaction
and their power really comes when they
are not too specific about the finer
detail and I'll say something a little
more later about how a mapping is made
between the abstract form of the
storytests and into a particular testing
scenario now as I mentioned I've been
developing fit library which is an
extension of fed and of course the way
in which I do that is the same kind of
process and so I have a set of
specifications for fit library itself
and so I can develop those in and make
sure that whenever I make changes that I
don't break anything now I've just done
a major refactoring of the library and
it it's wonderful to be able to make us
change run all my tests and make and
know that nothing is broken well almost
nothing so I just show you that this can
happen on a larger scale there's a large
number of tests this is just the test
for one of the circle
fixtures and it it is it's both a test
and a specification of what happens and
so this doesn't look very nice but what
what we see is on the left hand side is
a table and this is the table under test
and on the right hand side and this is
what the report should look like so I
specify in in a pictorial form what
should happen within fit library under
these various circumstances so there are
a whole set of little programs and story
tests which together define the behavior
so I'm going to switch back to
powerpoint now i can get my fingers
working and so that gives you a bit of
an idea of fet a very brief one now as I
worked on this I've realized the process
of designing tables and of evolving them
is very got some things in common with
programming most people who use
acceptance testing tend to write tests
at to lower level and there's a lot of
redundancy and when the ue changes then
lots of this break that's a kind of
standard problem so obviously there are
kind of issues around avoiding
redundancy having the right forms of
abstraction what are the patterns that
you use for writing these and so on and
some of those are covered in the book
and I've been developing those ideas
further but one of the fundamental
things is what is the best way of
expressing this as concisely as possible
so that it's possible to see our all the
cases covered for example if we have a
lot of work flow and again this is a
common smell for people who write tests
is to write a lot of work flow tests
which then are repetitive with small
differences so there's a an extraction
process which can take the essence of
those different workflow and pull out
the differences and express them in the
clear form and that then is being
precise usually about business rules
which are encoded within that system so
I see the process of developing story
tests as a process of being clearer
the business rules underlying the system
and the way in which work and finding
ways of expressing those very succinctly
now when I work with clients working
with business analysts on doing this
process it's interesting that it going
through this people begin to notice
things they've never noticed before
because they've not had a way of
expressing and focusing on the important
elements of the domain a few weeks ago I
was working with a client where the the
business analysts were saying look we've
had ongoing problems with this feature I
can't it doesn't seem that complicated
to me but I'm finding it really hard to
communicate this to the programmers we
sat down and wrote some very simple
examples starting with an easy very
simple one and developing it step by
step and it it there wasn't much to it
really and the examples just came out
really clearly and everyone was
surprised they thought well we thought
it was more complicated than that now
underlying all this then is the notion
of writing examples concrete examples
which are meaningful so the more
meaningful layer for the domain the
better it is for the programmers I know
from myself as a programmer often I'm
working on something and I'm not sure
who the users are I'm not sure what the
business context is and I'm missing out
on that detail so the examples can help
with that the other thing I noticed is
that by starting with simple examples
then people start to make explicit the
assumptions that they don't normally
mention so it's quite often the case
that you find partway into the
development of a system that no one has
mentioned something really important
like access rights or money or
performance issues or anything else so
finding ways of starting very simple
with simple scenarios seems to be very
important in this I don't know about you
but all through my career I always see
the development of programming a program
of inventing an example which pushes
outside the bounds of what I'm doing
what is an example now which will push
me from here isn't it at a kind of a
modelling level he
a one-to-one Association see there's a
question to the project manager which is
essentially asking the question is this
a one-to-many or a many-to-many
relationship what are the constraints on
that association and then what is an
example which expresses that and pushes
the boundary so I seem kind of design in
that model is very similar to the
scientific process which you're saying
here I have a theory and I want to I
want to explore the theory the
consequences of it what does it
experiment which will allow me to
identify and show that I'm right in my
theory and possibly show that someone
else's theory is right so that's kind of
pushing around the edges of an idea and
the same thing I think applies in design
what are the way in which are we can
push the ideas and generalize and often
part of what comes out of that is that
you get a collapsing of a lot of
different ideas into something that's
much more powerful okay so I've hardly
got beyond so that gives you an idea of
fit and a kind of general attitude about
storytests now the the advertised issues
are somewhat well mark thank you for
bringing those together these very
nicely kind of get at some of the issues
that story tests begin to help provide a
solution for as I'm sure you know there
are no silver bullets or gold bullets or
whatever and that these are things that
might help so what I want to do is have
a look at each of these four issues how
do we deal with a legacy system and how
do we do that in such a way where we can
we don't want to slow down its evolution
by legacy I I'll I like Michael feathers
view of legacy what legacy means as a
system that essentially is not supported
for evolution so it doesn't have tests
it's not easy to make changes because
well people start getting worried about
changing it because things will break
and so it becomes solidified so so agile
sorry legacy to me means not able to be
changed easily so the next issue is well
we have a great application that's got a
neat
we then how do we supply a program
access to it and lots of different other
technologies underneath the next one is
QA tends to happen in most shops at the
end of the process and oftentimes that's
there can be quite a delay from when a
problem has actually been entered into a
system that may be a misunderstanding it
may be a bug or whatever until it's
found so how can quick you a be involved
earlier and more effectively and then
finally how can project managers beeees
product managers product managers and
the like how can they get involved and
utilize their expertise in this process
somewhat more then often happens so I'm
going to look at and I've kind of
covered some of this already in terms of
giving you an overview of that story
tests act in each of these cases
starting with a testing perspective and
heading more and more towards a
requirements perspective which is what
is it that we want rather than is it
what we've got what we want um I'm a
great fan of carpets and their geometric
design and they kind of I've always
wanted to be able to use tables that
look like carpets but I haven't managed
to come up with a way of having some
beautiful object represent a test yet so
maybe in time okay so legacy system
providing our test coverage how to
improve that that also to allow for
evolution so what are the what's the
fundamental problem if it's not if it's
a legacy system it's not test infected
it's not easy to be able to make changes
to it because you might break something
it's often easier to add more code
rather than to refactor what's there and
so you lose out on building abstractions
so there's a catch 22 and I understand
Michael feathers was here talking about
working with legacy systems and
essentially the catch-22 is that you
have a system and that once its chest
infected then it's very powerful as a
means of its its you have the support to
move forward but on the other hand in
order to add the test infection it
thoroughly changes the code if the code
is developed test first then it ends up
being in quite a different shape then if
it is we're adding test afterwards so
Michael talks provides talks about
various techniques that can be used to
gradually do test infection and I think
a fundamental principle of that is in a
large system it can take quite a long
time to do that so it's a matter of just
by need as parts of being changed to
then start working on them now as I see
it that story tests can support that and
if the story tests are written very much
in terms of this of what does the user
do on this user interface or what are
the low-level details of the protocol
between machines or whatever then the
storytests may be useful as test but
they're not so useful as in terms of
helping the domain and helping the
evolution of the product so by focusing
on the essence of the domain and as
we'll see as I move on I'm going to make
a case for using storytests as a way of
doing domain driven design how many of
you are familiar with eric evans book on
domain driven design okay so that kind
of fundamentally I think there's a very
nice fit between FET storytests and a
domain driven design as an approach okay
this so the standard approaches are
manual testing record and playback
techniques have been in use for a long
time they tend to not be that great when
a system changes because you tend to end
up well many of these systems have weird
scripting languages apologize to anyone
in the audience who's ty but I just
wanted something that most people
wouldn't know how to read as a kind of a
little example of something that it's
hard to interpret so I think it's
actually quite a beautiful script so the
it's possible to manually test and it's
surprising to me how many organizations
only manual test and can't test very
much automated test
most people test at the user interface
level tends to be slow the test of a
Bose they're hard to manage and so on so
the bossa t repetition hard to alter so
much detail it's hard to see what's
going on because its traces of the
system being executed it's very
difficult to see the abstractions pull
out that this is kind of no nation of of
what is at the heart of the system which
usually is a domain and usually the
things that are interesting and that a
long term are around the domain of
course there's going to be a lot of
technology supporting that so kind of by
analogy Roman numerals are great in some
ways but it really poor in others like
doing arithmetic on them is not very
easy and likewise from a programming
language perspective then what the way
in which programming languages have
evolved out towards high level of
abstraction finding brief ways of
talking about things and so on so that
they're the kind of same kind of issues
underlying pneus which are around
avoiding repetition and finding
abstractions finding good ways of
expressing things but without using a
programming language ok so the other one
is next one is in terms of providing
program access and the only kind of
techniques I've seen well let's so the
problem often happens is that many
applications are written with a tangle
between water often can be seen as a
separate layers and I think there's a
clear indication that in complicated
systems having clean layers as a very
useful thing and this will very much
come out when tests remand development
has been being used so I take it from
this issue is that there is a system
that's been developed but there aren't
clean layers and it's then difficult to
provide programmatic interface into the
API provide services so there's actually
lots of good reasons for separate layers
as you probably know including
modularity being able to plug in
different user interfaces and to the
same thing
clarifying the domain in the domain
layer and providing programmatic access
into that so there are various
techniques that can be used I've seen
people try and use automatic translation
techniques and trying to abstract stuff
out of the ue but I think it's
incredibly difficult it's kind of like
dumping all the uml diagrams for a
system and then try to make sense of
that um out usually it's not very
helpful unless you can really filter it
out so one way is just well duplicate
the code but then duplication is bad
smell pull out our service layer very
procedural or kind of focus on on that
domain layer so I'm kind of looking at
the same solution really which is be
clear about that about the domain and
and move towards supporting that domain
layer pulling it out and so that
programmatic access can be supplied in
that process and at the same time is a
clarification around the domain now I
talked about clarification roll the
domain it's very it's I find it quite
difficult to to give good examples of
that because often the examples arise
right within the context of the person
the way in which for example when a
client of our utility doesn't pay then
what is the process that happens so that
they are they warnings are sent to them
and there and there's a various steps
involved out of all of that kind of
business detail ask them are some
clarity that comes up around the
business rules but it kind of makes
sense to the people in that context but
not outside of it Eric talks about in
his book about clarity around the domain
which was the programmers assumed that
shipping containers around the world you
would you would represent you would have
objects for containers for ships for
ports and so on and it took them quite a
long time to realize the fundamental
abstractions were not at all around that
it was all to do with passing
responsibility and the legal
responsibility for the the goods as they
went from one part to the other so once
the focus shifted towards that
documentation and legal responsibility
then a whole lot of things made
since and I'm sure all of you have gone
through the process of oh there's kind
of a frustration that builds up you're
trying to understand something that's
you're not quite sure where to put it in
the code it's not making sense and then
you one day just realize if you look at
it you cut the world up in a slightly
different way at all just suddenly it's
so much easier and it's kind of relief
you feel it in your body and you move
forward on and you go really fast for a
while okay quality assurance getting QA
involved earlier well this is all about
feedback if you imagine that you've done
something a year ago and only today have
you found out that you made it a mistake
you go well I can hardly remember the
details of that now well I would feel
that way there's so much that I've done
in the meantime if you scale that down
to a week it's not so bad down to an
hour it's not so bad and down to a
second it's utterly different and it's
to do with if you're in the context of
doing something you're getting very fast
feedback on that then you can respond
immediately so there's much less if it
involved and tracking down the problem
getting back into the context of finding
a solution and making it happen so the
average programmer every time they fix a
bug there's a one in six chance that
they will yes that's right sixteen
percent chance that they'll make a
mistake so I'm kind of assuming that if
the the feedback is faster then the
charts of making errors is going to be
lower and then if there are tests test
driven development storytest urban
development those things are going to be
picking up picking them up much faster
so bringing the QA earlier in the
process is a good thing and the early
earliest you can bring QA is right at
the start now in a agile approach you
don't try in a waterfall approach I
suppose you would kind of say well we'll
write all our tests before we do any
programming and it kind of sounds a bit
daft because there's a huge numbers of
decisions that are going to be made
around
in those tests so an evolutionary
approach is to say let us write some
tests for the next iteration of the
system and then the programmers the
developers are going to then work using
those tests to then develop the code
they know when they finished and the
tests continue to build up and the
actors the framework for making sure
that things aren't broken so that that
these tests then turn more into at the
the overall system level in terms of
thinking about requirements and at a at
a programmer level more at a level of
design and so there's a kind of a
counter to that that testers do anyway
and there still needs to be activities
at the other end so as parts are
finished and a system exploratory
testing namely you play around and try
it out is is something that has to be
done because it's easy it's always easy
to make mistakes testers are very good
at thinking about well what happens if I
put a really large number in here or
what happens if I hit this this kind of
strange key sequence or I do things in
this with a speed or whatever so it's
kind of an interesting interaction
between talking about a system what it
should do and also the tests okay so one
of the few things there's not much that
we wish we have a lot of evidence about
and software development there doesn't
seem to be any evidence at all and from
an experimental point of view that oo is
any good that you ml is any good there
are a few things that we do know we know
that inspections are helpful in some
form and there are a lot of ways in
which inspections can be done the other
one that seems to be pretty sure is that
if there's a focus early on quality then
you you you can actually go faster if
you try and go faster and you end up
with poor quality you go slower so and
this has come about through people have
tried this in lots of different ways
okay so
how I see QA fitting in is that the
testing perspective as well as we'll see
shortly the business perspective the
design oo perspective the modeling
perspective all joined together up front
and coming up with story tests so that
so one of the things about writing the
story tests the concrete examples you
communicate them with people you
actually start and have building a
language for discussing it and they
provide very fast feedback so if there
is differences of opinion over the what
should happen then you may find them
earlier I ho was working with a group of
product managers and I was showing them
how to write story tests and getting
them writing a story test and two of
them said I'm partway through look it
was just amazing that when we sat down
together and started writing the story
tests for the the next system the part
we're working on that we understood it
completely differently and we never
realize that we've had lots of
discussions about it but when we sat
down right an example then we began to
see that we we had differences and we
were able to resolve those now rather
than match later on so basically
bringing in quality and thinking about
what's needed much earlier and this
leads to the final point issue as you
can see i'm skipping over these I'm not
really seeing seeing a lot of about them
is that how can product managers provide
their expertise more earlier writing
requirements well the requirements
engineers say well if the requirement if
the project doesn't go very well then
put more effort into writing the
requirements doesn't seem to work it's
very very very hard to write general
statements in English and have people
understand them it's hard enough writing
general statements and a programming
language for others to read so
requirements tend to be a problem
particularly if they all have to be
written up front when it's not at all
clear what is going to have the best
value in the system so there are issues
around what is needed what is the
business domain what is the return on
value return on investment
in different approaches so if we are
talking about requirements then how can
we express these in a form that will
help communication between all of the
various people on the team help clarify
and build understanding around and help
build a sense of the domain and also as
a secondary thing act as tests to tell
the developers when they're done and to
tell the developers that they've broken
something that was already done so
through the process of building up
storytests so storytests then can act as
a way of developing requirements as
executable specifications and support
the domain driven design idea of
developing a ubiquitous ubiquitous
language which is talking about the
domain so where does that language sit
in the tables it sits in the tables in
terms of the the names of columns the
names of the words that are used within
that which start to get clarity so again
I when i'm working with with people who
are product managers and the like who
work at this level then I'm always
saying is this the right term does
everyone agree with that does that make
sense and as they get developed is the
terminology still correct if I find if I
make a bag in if I've got a bag
somewhere ik sionally have bugs not have
you ever had bugs these days but
occasionally I do the often oh I i'll
rename something and try and make it
clearer because obviously there's
something wrong in what I've expressed
and usually it may well be round the
name of the method it may be that I
don't have clarity around a class it's
representing something in the domain
it's kind of got a bit bigger nuts
feeling a bit awkward and I'm talking to
the product managers about this and
they're saying ah gosh you've loved all
that together you know we never intended
that or they say oh that's interesting
there are distinctions in there that
we've never really thought about before
you know he let's bring in this example
and now we can start pulling things
apart changing the naming rethinking
about things
okay so I've kind of said most of what I
want to say that I've got a whole lot of
slides so test-driven development was
developed by Kent Beck his book came out
i think in 2002 he talked about it early
on an agile development and when I first
started I'd always done example driven
development but I hadn't developed test
and I found this a very powerful
technique if you're a programmer and you
haven't tried it i really recommend you
do it looks weird because initially
we'll tests are kind of something you'd
prefer to put off because when you write
if you if you test something then it's
just going to show up the floors you've
made but if you bring them up front and
think of it in terms of specification
and design it really changes the way you
program and as i say i spend very little
time debugging now as compared to before
i had tests so concrete examples
developing the domain and so on so i
probably don't need the same you think
more about test-driven development other
than it's it's a process of thinking and
I see story test is very much a thinking
tool a way of expressing things as
anything else and if you have a notation
which helps your express what you want
to express easily then it's going to
help you communicate and think about
those things so there's as well as test
you test at a programmer level unit
tests there's all kind of issues around
the business risk as well and around
what should have system do and here's
this is why storytests this was a term
invented by Joshua kyousuke and they it
comes originally out of the idea of a
story which is a unit of work with an
agile process so a story test is a way
of specifying what should happen in a
story but I like the idea of a story
test anyway because each story test
tells a little story it's not very large
it's just focusing on my
it's very easy to see what it's about
and that these step-by-step these
storytests accumulate and change as they
go so storytests okay around developing
something an idea of the domain and they
actually end up being a very useful
business resource for thinking about
things programmers need to write a
little bit of code which make
connections between the storytests and
the system under test but I've almost
finished in the next version of fit
library pretty much eliminating the need
for fixtures so that's going to make a
big jump in terms of how you think about
story tests and how how programmers use
them so this is kind of based very much
on a domain driven design approach to
thinking so at I'm quite excited about
that i was hoping to demonstrate that
but it's kind of I'm realizing now that
there needs to be new tools to support
this which I'll say something about so
the slides a little bit about the kind
of things that you model in tables and
it's not obvious and I would take a
while to cover this but essentially the
ideas of domain driven design and almost
all of the patterns out of eric evans
book translate directly on to how do you
do design at the storytest level so in
his book he really is talking about uml
diagrams and discussions here encode
there and what I'm putting in the middle
are fit story tests which are developing
the language and are mediating between
these two areas and obviously then that
we need to go up to refactor and change
names between the storytests and the
code so this is where the tools come in
to make it easy to to make changes at
multiple levels sometimes the
programmers are raising questions and
looking for abstractions and
refactorings sometimes it comes up the
storytest level as well as I mentioned
as constraints and calculations which
are abstractions of certain points what
can happen when who's allowed to do what
rather than showing them through lots of
work throw a workflow extracting those
out and showing
as individual things so a lot of this is
around noticing something isolating it a
mean clear about it and then be able to
ask questions have discussions about it
are there other cases are there other
constraints that apply in terms of
submissions to a conference or whatever
it might be okay so domain durrin design
as I say is kind of sits underneath my
thinking about what story tests are
about to my mind many people who write
fit storytests writing the very much as
tests and not thinking about this about
the domain but I see real power in
writing them around the domain and
mainly because it comes back to the
principle of saying things once and that
is that if you say things and mobile
times then when you change your mind
it's a bit of a pain to have to change
all all those different repetitions of
that idea now the repetitions may not
look very similar they may be in quite
different forms so what I'm finding is
that the storytests are a way of
specifying the domain and they can be
used in a range of ways not only in
testing but also in in other forms so
the storytests the very same set of
story tests could be used to test
through the domain layers i said before
through subsystems through the user
interface through dealing with
performance and load issues like
automatically being used to generate
large databases for over which load
performance testing can be made and more
recently I've been working on using
storytests adding a little bit of extra
information to the storytests okay so
that context is as a customer who
generate who has a application which is
generic it's it's tailored by all the
clients who use it to their currency
their date format the format etc etc now
they they need to provide help and
document online documentation and the
customers aren't very keen about just
the the mass of it and the fact that it
but it's always showing examples in US
terms and it's not showing it
tailored to their needs the other thing
is that every time the system changes
then all the screen dumps have to be
done and all the documentation has to be
changed it so we're real pain to track
that so what I was what I suggested and
this is working out very well is to have
the story test and some of them have a
little bit of extra information around
around what this what is happening in
here and now what we can do is
automatically generate the help
information for that system not only can
we do that automatically but that the
system does screen dumps of all the
screens and we can define what the
screens are and that the the
documentation can be generated
dynamically based on the tailoring of
the users who are using so they are
seeing examples based on the system that
they using so that then means by having
a common form for representing the
storytest and generating there it means
then that you can do continuous document
generation and as well as support
continuous changes to your database as
the system evolves and to be able to
easily to do poor performance testing
word of the wise fashion
okay so the question is given a set of
story test how do you do how do you
drive test drive that through the
through the user interface now with
fetch there is a thing called a fixture
which is a little bit of code which i'm
mostly getting rid of except in this
case and that is making a mapping a
simple mapping between the storytests
and the system now I have a set of story
test for the domain layer now I want to
want to be off the test user interface
so i plug in different fixtures and what
those specs just do are essentially
making a mapping from the domain layer
into the ue now support what's really
surprised me is the amount of code that
has to be written there is very very
small and you only write once how to do
something within the user interface and
then if the user interface changes is
only one point where you need to change
the fixture to manage that so it
completely insulates the storytest from
the user interface so I've done this
generating selenium running dynamically
selenium testing through swing using in
fact JFC unit so and I don't see any
reason why it can't be applied to any
arbitrary standard robot type approach
or anything else as well and I'm sure
there are other situations where story
tests can be used in other ways okay so
I'm coming towards the end so Oh
remaining challenges well this is still
relatively new some of the tools are
need to be improved as we move more
towards the main driven design
perspective i can see that story tests
change at the moment if the terminology
changes then you have to go through and
edit them in a very simple way so i'm
currently working on refactoring tools
at all which will allow me to construct
refactor and run storytests and support
the domain development and automatically
generate use cases and um UML class
diagrams and the whole lot of other
things that people have worked on before
so that's where i think i can get to so
those kind of tools
kind of useful the other ones in terms
of supporting refactoring such which are
applied to store it is such as
extracting calculation rules out of out
of a set of workflow rule the other one
is then looking it up yeah okay come
back to an earlier point is what this
tool turns into is a general purpose
tool for managing table based and
domain-specific languages so it's got a
lots of interesting connections into
other areas okay so I kind of brushed
over a few problems and very quickly
brought together the idea that story
tests could play a role and help him to
solve them there's still some serious
issues around well how do you take an
existing system that is doesn't doesn't
have a domain layer how do you gradually
build the domain layer well the
storytests can help but there's still
issues around what is the domain how do
you get that understanding and have you
evolved that concrete examples are key
asking someone to give you an example is
so powerful as a way of starting to
understand things and we use it all the
time in terms of of how you ask things
how many if I learn a new programming
language I don't want to read the
specifications I want to just see a few
examples now let me see an example with
a for loop in it or how does recursion
work or what is the class structure how
does inheritance work whatever it might
be executable specifications looking at
storytests as saying what should happen
as well as saying this has happened or
not clarifying a thinking tool a
communication tool through domain driven
design and alignment between storytests
at a domain level and the classes within
the system that are representing domain
objects and then using storytests for
testing and other things in very general
ways okay so that's my message the book
that you have available to you covers a
certain amount of that I've is okay so
I'm ready for questions
library and
Avengers
me the literate specification
so the question is what a step like we
drove up in terms of getting rid of the
fixtures that the key to it is is very
simple and this it actually ends up
being amazingly simple in some way and
that is that if the storytests more
directly represent the domain then there
is no mapping between the storytests and
the underlying system because they are
the same and the storytests then become
almost like a serialized representation
of the objects the domain objects in the
system so the closer there is an
alignment between the storytest and the
system the less the mapping so the trick
is to find a way in which to embed the
storytests so that you are talking
within a narrow context whenever you
write a story test and that was that's
the track that suddenly makes all this
easy so where where the storytest don't
met directly as with selenium tests in
yui testing then there is code that's
written but now that turns into a much
more of a general mapping issue and
there are there's opportunity for using
general mapping tools to do that mapping
so you're not having to write lots of
code to map here is a piece of a story
test here's an action that happens what
does that actually mean in terms of what
does the user do slip from this item
select this menu item click here and so
on yeah
how easy is it to use this for C++ there
is there is a version of C++ C++ is kind
of awkward because it doesn't have fit
relies on reflection and so with with
languages that don't have reflection
it's harder to provide the support for
them there is fit libraries has been
ported to c sharp and to think it's
being ported to ruby &amp;amp; 2 it's been
Python for quite some time small talk no
no one well Michael feathers talk to me
about porting fat library to C++ but I i
think it's not it won't be easy I'm not
sure if that's the fundamental part of
your question but but once once the
tools are set up to make it possible
then the storytests a language
independent and it means that once you
have the storytests developed as part of
the implementation if you decide to ship
your platform then the storytests are
the resource that remain and then you
can continue deport them so that's the
way in which fit library has been ported
people have used my story tests for fit
library to then develop in a different
language yeah
okay right okay so there's no reason why
this can't be supported yeah it's free
perspective here that's just wrong just
happen to Texas like you if you have a
sympathizer slimming down any other
Christians yeah like to do it on Jeff's
Russian little bit because I think you
corrected if you don't main layer users
to be coded language the fit test so
very much use the same vocabulary but I
think they're still challenges some of
the structural subtle thing is to be a
nice domain layer dedicate sort of
migraine nice object graph solid
relationships was it seems the tables
benefit more full of coarse grain
actions no control struck
no life cycles and I think there's a
catch
I think there's two answers to the
question one is that I just showed you
one example one is that I don't I kind
of want a notation which allows me to
express a whole range of things and
sometimes the table is not it table is a
good for very simple hierarchy but
certainly there are graphical forms
which are better represented elsewhere I
think in time the stuff that I'm doing
tables will just be one way so I kind of
allow for for trees and graphs and in
general images as well so it's possible
to use a whole range of ways so I kind
of want to push this into essentially
the the domain-specific language allows
you to build visual languages to
describe what you want but lets up here
way off the other one is around well
what what things can you express easily
and whatnot so up beyond allah so we may
have a set of storytests the way I think
about workflow is that there are tracks
state transitions within a state
transition graph of the system and that
what we're doing is describing each of
the important transitions using examples
and if we set that up in a particular
way then we can focus on here are set of
states of the system and here are
transitions and we can define what we
expect so then we can share the states
between tests so this test includes the
state as a starting position and the
state as an ending position and then I
can include this ending position stayed
here as a starting position for another
so it now has it so I've set it up so it
has the same form so now I have a graph
of these transitions and so it would be
useful to have ways of pulling out
pictures of that and to see what is the
relationships between those and what
comes out of that I think our use cases
because use cases tend to be at a higher
at a grocer level normally then then
storytests so that's kind of one example
the other one is in terms of what are
what a fun at the domain level what are
the associations between objects and
again at the story at the example level
normally with tables that's kind of
implied it's never explicit the
a current tool that I'm building is is
fundamentally building everything at an
example level but it constructs the
domain so it's actually constructing a
domain underlying it and that's how I
can that's why I will be able to
generate UML class diagrams and such
like so I think part of it is to see
what are the what are the techniques
that other people have used flow
diagrams use cases plus diagrams object
diagrams all of those things I think
those things can be emergent the other
part of it is in terms of emergence of
Yui out of domain as well and that's
another area in which I want to push up
so I think there's a lot of really
interesting challenging I issues around
that and if you have particular examples
of issues that come up I'd love to hear
them I am a great fan of examples end of
challenges
any other questions
well thank you for your attention and
patience</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>