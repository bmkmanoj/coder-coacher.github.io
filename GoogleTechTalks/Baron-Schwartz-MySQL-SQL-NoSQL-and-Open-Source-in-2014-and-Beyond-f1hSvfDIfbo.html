<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Baron Schwartz: MySQL, SQL, NoSQL, and Open Source in 2014 and Beyond | Coder Coacher - Coaching Coders</title><meta content="Baron Schwartz: MySQL, SQL, NoSQL, and Open Source in 2014 and Beyond - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Baron Schwartz: MySQL, SQL, NoSQL, and Open Source in 2014 and Beyond</b></h2><h5 class="post__date">2014-08-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/f1hSvfDIfbo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">&amp;gt;&amp;gt; SCHWARTZ: Thanks Razvan [SP].
And this is--I was telling Razvan earlier,
this is regardless of what I say here today
or how you guys receive it or what we--what
conversations we have of it, just being invited
to come and talk at Google is definitely a
high point in my career.
I want to start off by thanking Google, Razvan
for inviting me, Google for building all of
the amazing things that run my life.
I kind of get a little list of the things
that would be very difficult for me to do
these days without Google products and services.
And it's a really long list, from my phone
to calendar, to maps, I mean, and you guys
know but, anyway, thanks a lot.
So this is me at work.
This is VividCortex, the company that I founded
after spending a few years leading various
parts of Percona and helping out in various
functions in the MySQL community.
I decided that I wanted to move away from
command line tools and towards the software
and service tools to help people understand
how their databases are performing and how
the queries run and how applications use the
database and things like that.
So in some ways, you can think of it as the
evolution of Percona tool kit, tools that
I ended up building as an open-source and
it kind of merging into a tool kit in Percona.
But I want to go significantly beyond that
of what we do and I'll--and you know, because
it's my reality now, I'll just make a few
references to it as I go but not spend too
much time on it.
The basic architecture of our services that
agents run on client machines, agents are
written in Go.
Thank you, Google.
So agents run on client machines and send
information to our APIs which are written
in Go.
Thank you, Google.
And our friend in that's just written in Angular,
thank you Google.
We share a bunch of our code on GitHub under
the VividCortex account.
And there's a whole bunch of other stuffs
that we've tried to do.
We're trying to share as much of our codes
just open-source as possible.
And obviously, there's things that would be
a real competitive advantage for us to disclose
and there's some stuff that's proprietary.
But we're trying to make an effort to get
our code to be open-source ready and to publish
it, and share it with people whenever possible.
One of the things that we've done is this
go-database-sql.org website in which it started
out as just a readme file.
It was just a repository with nothing but
a readme file in it about how to use Go's
database/sql package and in particular for
connecting to MySQL databases and then I've
learned about the beauty of GitHub hosted
websites and we turned it into an actual website
that's kind of a tutorial for how to use the
database/sql package much more effectively.
So it's kind of--you know, in the last years
so since founding the company and getting
involved with Go and running a whole bunch
of code, it's taken a little bit of its life
of it's own and gone in directions that I
wouldn't really have been anticipated.
Also, I found the open-source community around
Go to be really friendly and the intersection
of Go and MySQL, there's a driver which is
mentioned in this go-database-sql.org website
which is written by two guys, Aaron Horman
[SP] and Julien Schmidt.
I've never met them.
They've been incredibly helpful and friendly
to me over the internet through, you know,
full request and things like that.
And the result of the work that they've done
is that what I think is a really high quality
and very idiomatic go-database-sql driver
from MySQL which we use in production is fantastic.
It's been great for us.
That was actually--when I started to look
at using Go, it looked absolutely ideal for
our use cases.
Single compiled binary, you know, free of
dependencies, high performance, concurrency
built in, simple language, etcetera, etcetera.
But the one concern that I had was, &quot;What
about drivers for connecting to various things?&quot;
And so this go-database-sql driver's been
great.
I'm also interested not only in Go, the language
but in Go, sort of the philosophy, the minimalistic
languages you may know.
But it has a lot of power that's actually
built into the language by removing features
or omitting features from the language and
making it possible to use various idioms in
the language that are more powerful than any
features built into the language really could
be.
So I think that's--you know, that's actually
been quite a revolution for me and I'm impressed
usually several times a weeks by something
that I learned about Go where other languages
might build in a feature to enable you to
do something complex.
Go actually omits that feature and makes it
possible to use the language in a way that
supports that use case and many others.
So, you know, there's a couple of things occasionally
that people mentioned as being missing from
Go like generics.
But every--the more I learn about Go, the
less use I have for generics.
And there's other kinds of things as well.
I'm also interested in other languages and
programming practices that help people build
higher quality software faster with fewer
bugs and with better performance including
Rust, Juliet, to some extent, closure and
so forth.
So MySQL--so MySQL, the state SQL today in
my opinion, you know, this is--this is larger
and it going to reflect a lot of opinions,
of course.
The state of MySQL today, people often ask
me, you know, how do I feel about the MySQL
community and where is it going and what's
happening under Oracle and things like that.
And around the time of the Sun acquisition
of MySQL and then the Oracle acquisition of
Sun, there was a lot of concern over--I think
the term most often used was community fragmentation
and I don't use the term fragmentation myself.
I don't feel that the MySQL community is fragmented.
I think what's happened is that it's matured
and instead of being homogenous, it has actually
developed several centers of focus.
So there are people who for example, just
want to get business done and they don't really
care as long as the database is available
to them and works.
And, you know, the fact that Oracle is there
and you can pay Oracle with their support
contract is a good thing for a lot of those
folks.
There are people who care more about the open-source
side of it and really wanted it to be open
and the community develops and the community
that input into its development.
There are people who care most about performance
and, you know, I've been kind of centered
in that account to tell you the truth.
So I see that these things instead of--instead
of their being a single MySQL community, what
I've seen is that there are several MYSQL
communities growing up which are--and a again,
I wouldn't call them fragmented.
I would just call it a little bit more diverse.
And as things had matured and settled down
as Oracle has--has Oracle's ownership has
stretched into the months and then the years.
I think a lot of the fears around that have
calmed.
So instead of having a single dolphin representing
MySQL, now, we have several dolphins swimming
in roughly the same directions.
Some of them maybe a little bit further off
to the side than others.
So that's kind of represents how I feel about
the MYSQL community these days.
It's--Buyenlarge is a good feeling for me.
I'm--I still feel the MYSQL community as a
welcoming and a friendly place even though
it's more corporate and kind of growing up
and being a little bit more enterprise in
some ways.
Oracle, I'm pretty happy with Oracle's stewardship
of MySQL as well.
I guess, I would just--I would say I'm very
satisfied and have no significant complaints
about Oracle.
I know that my point of view on this is perhaps
different from a lot of others, but for me,
Oracle has been a fairly good steward of the
code and that's the most important thing.
It's actually improving the code base because
it does remained open-source.
There was a little bit of friction around
the time of the acquisitions and there were
things like, you know, not participating in
conferences and so forth.
And I think, we've seen Oracle kind of learned
how to have productive exchanges with the
MySQL community and those--you know, they're
now participating in Percona's conference,
for example.
Those are--those are some pretty significant
changes.
There's still little things around documentation,
licensing on documentation, these are kind
of like long standing things that were promised
a long time ago and you may still hear people
saying, you know, &quot;But they promised to open-source
the documentation,&quot; because somebody did,
I think.
And a moment of unbridled passion on the stage,
in a conference, the leader of the MYSQL under
Sun said, &quot;We'll open-source the documentation.&quot;
And perhaps, it was a promise that couldn't
be followed through on.
But I don't have--really have a problem with
the documentation not being open-source or
open-source is the wrong word but permissively
licensed.
There's a few other things, the test cases
are not part of the public source code anymore.
It's quite clear when you look at the code
that there are test cases that are excised
and are internal only before the code is pushed
to launch pad.
That's--I think that's almost completely a
bad thing but it's not a--it's not a deal
killer for me.
Security bug reports.
Sometimes, bug reports are more private, things
like this.
This is not with the open-source community
comes to expect but I'm not--again, these
are not deal killers for me.
As for me, personally, we use MYSQL as the
backing store for all of our data at VividCortex
which is--it's not anything on the scale of
Google but it's a lot of data and MYSQL is
a high performance and efficient and reliable
data store.
So that works pretty well for us.
That will change in the future, you know,
we'll--as our initial simple architecture
as we--as we prove that our product is worth
buying and as we grow and have a lot more
data, we'll build a more sophisticated architecture.
And MySQL will always, I think have a place
in that but it won't be the only data store
and probably even in the near future and probably
have other data stores involved.
So--and we use Oracle's--you know, we use
stock Oracle in MySQL.
A couple of years ago, I would have use Percona
server because there were such serious problems
in the standard MySQL distribution that it
wasn't usable for a lot of things.
But these days, the edge cases are very few
and far between and I think the productive
interchange and competition between Oracle,
MariaDB, and Percona server had found a lot
of their performance edge cases and I will
also say other companies like Google, Twitter,
and Facebook have played a big part in that
too.
So I'm going to have some words of criticism
and I just want to say that these are offered
in the spirit of helpfulness and I hope that
they're taken in the kind-hearted spirit that
I offer them because there are still some
areas where we can improve.
But before I do that, I just want to do something
that I like to do often which is make a gratitude
list into my Oracle gratitude list.
When you really think about what Oracle has
offered the open-source community, it's pretty
stunning.
A lot of times, people will say, &quot;Oracle is
trying to kill MySQL, you know, they're anti-open-source.
The World is going to end.&quot;
And if you actually look at how they're interacting
with the open-source community, it's very
clear that that's not really the case.
VirtualBox, it's actually hard for me to imagine
a modern development work flow without VirtualBox
these days.
VirtualBox is probably the--one of the least
talked about and yet most valuable contributions
to open-source that Oracle has continued after
acquiring the Sun.
It was MySQL 5.5 and 5.6 which were both great
releases, 5.7 looks pretty phenomenal too.
They employ hundreds of engineers more than
MySQL themselves ever employed working directly
on the database server and the things around
it like the tools.
There's the MySQL Connect conference which
used to be a sort of a sideshow on a weekend
and this year, it's opened up into its own
conference.
It's a--it's a proper MySQL conference in
its own way.
This time, returning under Oracle's umbrella
as part of Oracle OpenWorld.
There's participation in Percona Live which
is the other big MySQL conference every year.
There's a MySQL Workbench and lots and lots
of tools similar to that.
You know, I'm repositories right now, so recently,
you know, the community team I think has been
very productive and helpful recently.
Morgan Tucker resolved a problem with some
feeds on Planet MySQL for me yesterday and
today.
So I get lots and lots of good feelings from
my interactions with the--sort of the open-source
community face of Oracle.
And finally, I just want to say that in the
face of intensive, often heavily funded competition
that's been sometimes really nasty and a lot
of criticism and negative advertising and
politics, Oracle has remained calm and just
carried on.
And I think that's been a huge benefit to
just kind of settling the ladders around MySQL
in the last couple of years.
So you know, their sense of poise and grace
in receiving all of the criticisms that they've
gotten has been great.
There's MariaDB and SkySQl, it's kind of another--now,
I would--I would segment the MySQL community
these days or ecosystem if you will into four
really major chunks.
There's Oracle of course and then there's
MariaDB, SkySQL.
I would count Percona as worth mentioning
there in their own right and then there's--I
would lump together companies like Facebook,
Google, Twitter and say sort of corporate
contributors and major open-source contributors
to MySQL.
There are other companies like Baidu in China
as well.
But MariaDB and SkySQL had recently have merged
just many of you know and--how many people
here are involved in Google's deployment of
MariaDB?
Anybody?
Okay.
No hands go up.
So not in this--okay, one hand is up.
So there are--there are folks in this room
who are involved with that.
I think that--I think--I have a very optimistic
feeling about the future of MariaDB and SkySQL.
Recently, I've seen positive signs that there's
an actual business model coming and sort of
emerging out of what do--you know, we have
an open-source fork of MySQL, what do we do
with it now?
And a business model that's sustainable is
critical for me because without a sustainable
business model, desperation might set in.
And when people get desperate, they do things
that may not be very productive.
And I think in the past is they were searching
for that business model.
There was a little bit of kind of kicking
at the sand castle of MySQL and the MYSQL
community.
And I thought that was less productive then
kind of what's happening today.
MariaDB is not interesting for me because
of technical differences but just because
of the fact of existence of a major fork.
On the other hand, I would--I would also like
to gently suggest that we try and put the
divisive politics behind us in that regard
and particularly, any complaining, I just--I
just don't have any room for that in my heart.
There's been, for example, a lot of--a lot
of complaining about how Oracle may or may
not be making things hard for forks.
Well, look, if you fork a product and you've
got a major company who's continuing the main
line.
Deal with it, especially if you fork in a
hostile way.
Do you expect them to make it happy for you?
It's--the burden of forking should be on the
people who fork, not on the people who maintain
the original product.
And there's also been a lot of politics and
favoritism around things, like including MariaDB
in distributions which I think is wonderful.
Definitely.
I would love to be able to yum install MariDB.
But if I say yum install MySQL, you better
not give me MariaDB.
And I think that's something that comes from
sort of a myopic point of view.
And I'm not saying that that's what happened
but there was a lot of a--there was a lot
of noise around.
Just replace MySQL or Oracle's distribution
with Maria's--MariaDB's distribution and I
thought that was extremely unproductive.
Along the same line is what's happening in
the Nagios community.
Whenever you think of Nagios, the company,
or the personalities behind it or the technology,
if somebody says, &quot;Yum install Nagios plug-ins,&quot;
they better get the Nagios plug-ins.
If you want to fork something and provide
an alternative to it, fine, let people yum
install whatever the alternative is but don't
go asking--you know, don't go giving something
that people didn't asked for.
And then there is Percona and I'm a little
bit biased about Percona just because of my
long time there and the leadership positions
that I held there.
But I'll say, I'm really happy that Percona
is doing well and it continues to grow strongly.
It's another signal to me that MYSQL has a
strong future, a secure future no matter what
else happens.
And Percona is also very apolitical and I
think that's a good thing.
There's not a lot of engaging and sort of
the, you know, any negative--negativity around
things.
And Percona releases and produces lots and
lots of open-source software as well as--don't
forget, the Percona Live Conference which
is an enormous amount of effort and money
to put on and a huge benefit to the community.
So open-source databases now, there's--I wanted
to do a few things in this talk and one of
them is to talk about where we are as open-source
database users and what's the state of the
open-source database landscape and where I
would like to see it go in the future.
And there's several particular things that
I want to come out of that.
Some of these are very ambitious, some of
them are actually quite small, a little wish
list.
There's a few things that I would say about
the now as opposed to when I got involved
dated 10 years ago that are starting to change
and really looked different.
One of them is that permissive licensing is
becoming much more prevalent these days.
It's not that people are not creating GPL
products anymore because they are.
There's still a lot of GPL software out there
and new products using GPL.
But personally, I'm kind of tired of having
conversations about the GPL.
&quot;What is it that you do?
What obligations is it placed on you?&quot;
And you use GPL software without paying for
it.
I mean, just endless.
There's something about the GPL, the fact
that it's not just a license but it's also
like an assay and sort of a manifesto that
makes it particularly toxic for people just
trying to get stuff done.
And so these days, I'm much more in favor
of permissively licensing things and not worrying
about whether that might let somebody take
my code and something with it.
I think obscurity is a much greater danger
than someone doing something and may not getting
paid.
That said is very difficult to run a business
with open-source software.
I've only seen a few examples of that succeeding
and they've all been open core which open-source
purists or free software purists would call
crippleware and that's fine.
I don't think it's a very good term but I
have nothing against so called crippleware
as long as the core product is useful and
productive for people and the licensing is
not--the licensing is truly open-source.
I'll point that InfiniDB's recent licensing
has a really good example of--and a licensing
that was a mismatch at first and then relicensed
in a way that makes a lot of sense.
And Oracle themselves, you know, opening up
things inside the server and building plug-ins
but allowing other people to provide alternative
plug-ins such as a thread pooling plug-ins
for handling lots and lots of connections
to the server.
Those are good examples of how you can create
an open-source product and sell things around
it, whether it's proprietary plug-ins to help
in a particular workload pinching point or
if it's the MySQL Enterprise Monitor or other
tools around it to help manage it.
I think those are legitimate and praiseworthy
ways of doing business.
Finally, I think we've seen what I would call
the maturity of relational database management
systems in open-source where--I don't think
that we can expect anything radically different
in the upcoming years.
And I could be proven very wrong about that
but I think a lot of the innovation is in
systems that looked very different from let's
say MySQL and Postgres.
And that's not a bad thing.
I think the sort of the state of the union
of the relational database management systems
is that they're kind of converging asymptotically
towards what they should be.
And I don't think that we should look forward
to turn tremendous amount of additional things
to be added into relational databases because
they may not be a great fit.
So we have today is kind of MySQL and PostgreSQL,
the most common and most prominent members
of the open-source database community although--open-source
relational database community, although by
far not the only ones.
But I would call them sort of Seiko and Timex.
They're not Rolexes, they're not Breitlings.
You know, these are very credible, solid,
dependable, durable products that do lots
and lots of good things but they don't cost
you a mint and they don't have absolutely
every bells and whistles in the features built
into them.
And I think that's actually a good thing because
I think going too far into, let's say, some
of the features you might get in, Oracle database
or SQL Server, something like that can be--it
can be overkill and it can go beyond the point
of diminishing returns for what people really
want build in large scale systems today.
There's a good question about why PostgreSQL
is still lagging MySQL in popularity.
And folks have asked me that a lot.
I say it's replication but it's--there's more
to it than that.
MySQL shift out early and arguably before
it was ready, before it was trustworthy, before
it was really reliable open-source database.
And people look at it and said I like, I'll
improve, I'll use, I'll support.
And between that and replication, you know,
the simplicity of the early MySQL, it took
off.
And I think that's kind of the--if you look
at the evolution of that product and compare
it to the agile or lean business models that
people talk about a slot today, looks to me
like MySQL was sort of accidentally or intentionally
developed in an agile way, if you want to
think of it that way.
Whereas--there's been a little bit more perfectionism,
to be honest, in PostgreSQL and I think it
is--it is held back adaption to some extent.
And there are completely different views on
this depending on which camp you fall into
but that's the way that I look at it.
There is a tremendous amount of, sort of,
overlapping progress between MySQL and PostgreSQL.
Each database can claim who have done some
very important and powerful things first,
often a decade first.
And then those things will be, you know, there--some
of them are still not implemented today and
one or the other.
And some of them are in progress or have been
implemented recently.
To give some examples, MySQL does not have
recursive queries and common table expressions.
And it's, now, kind of--has the devious distinction
of being one of the few open-source--popular
open-source databases that doesn't, these
days even SQL, iTest.
And I think it's a very powerful feature that
would be nice to have in MySQL.
I don't know if it's coming at any time in
the future.
It's something you can live without but something
I feel the lack of.
On the other hand, things like reliable crash
recovery and really high performance in heavy
and mixed work loads and all of these kinds
of things, each of these databases can claim
to have achieved something before the other
and one or the other of these ways and it's
good.
At the same time, I sometimes wish that we
wouldn't have to wait ten years for a feature
from one database to be reimplemented in the
other or that when it's implemented in the
other, it doesn't make mistakes that were
solve years and years earlier in the first
one, because I've seen a lot of that.
And I've seen a lot of sort of predictable
problems coming about because something was
solved in one database but in other.
To give an example, page checksumming has
been there in noDB forever.
And when I raised this as an issue for Postgres,
you know, &quot;If you're not checksumming your
data as you read it off the disk, how do you
know that it wasn't corrupted on disk?&quot;
&quot;Oh, we don't have corruption.
Oh, that would never happen.&quot;
And immediately all bunch of other heavy duty
PostgreSQL users in the room said, &quot;If we
had checksums, we would find out that we do.&quot;
So that's the kind of thing where--that's
the kind of thing where it's really important,
in my opinion, to take seriously what other
people in some other communities say is important
to them.
The other, sort of, elephant in the room is
MongoDB.
Although when I say elephant, maybe you think
I'm talking about the [INDISTINCT] or Postgres
for that matter.
So MongoDB is--has what many people describe
as sort of raving crowds of screaming fans
that love it to death.
And if you look back 10 years, that's pretty
much where MySQL was at one point as well,
maybe not to the same stand, I would say.
MongoDB has people falling even more in love
with it than MySQL did in the early days.
But it wasn't a great set of alternatives
in open-source to MySQL.
If you look around, it was--it was one of
the--it was one of the only things you could
do if you wanted an open-source database.
So these days, you know, there's lots of choices
and MongoDB, in a much more crowded and noisy
market, is still gathering lots and lots of
rave reviews particularly from developers.
Why?
Because it's approachable, it's fun, it's
nice, you know, the whole thing about impedance
mismatch or whatever you'd like to call it
between code and database.
That's actually a real thing for people who
don't spend their lives immersed in database
and thinking sets.
And--so making database is more approachable
and more fun is--I think in this case, in
MongoDB's case, I'm not going to say MongoDB
is going to win this for that battle but I'm
going to say, I think they're going to be
successful regardless of whatever technical
or academic shortcomings you might think the
product has.
I think it's just--it's just made enough people
happy enough that they're going to use it.
At the same time, we can see there's a lot
of sort of reinvention of the wheel here in
MongoDB as well.
The ability to use more than one index per
query, that came in MySQL in a generally available
release in 2005.
That was a really big deal because you had
to pick one index before that for every query.
Well, MongoDB still has that limitation today.
So in many ways, MongoDB actually feels really
familiar to folks who kind of live through
the infancy of MySQL as well.
There's a lot of things about databases that
are hard and I know I don't need to tell you
this because you build databases that do really,
really hard things really well.
But I just like to catalogue a few of them
because I think it's important to understand
the difficulty of dealing with persistence
in general.
And in general, each of this points that I'll
bring up over the next several slides, either
has to be done in the application or has to
be provided by the database.
And wherever you do it, it's hard.
If you do it in the database, it's a really
monumental engineering problem.
If you put it in the application, maybe easy
at first but eventually, someday, it's going
to be a hard problem to deal with.
So here's kind of a laundry list of things
that are hard to do with databases.
There's real-time, by the way, this picture
is because cupcakes has nothing to do with
real-time.
I'll digress for a moment.
When I compose slides, I have a custom search
engine that goes to Flickr and searches for
creative comments, licensed images, and sorts
by interestingness, which means that you usually
get something that has nothing to do with
whatever.
And so, if there's a picture of, let's say,
a rainbow trout in my slide somewhere, it's
because I found it on Flickr, sorting by interestingness.
I like to try and make some of my slides correspond
to what I'm talking about and others just
because.
So building real-time applications on relational
databases is really hard because relational--the
relational model and the language doesn't
itself in any sort of standard or in any sort
of fundamental sense address real-time data.
In other words, data is coming in real-time,
we want to query it, perhaps, incrementally
in real-time.
We want to get results out real-time as they
come in.
All of those things are things that you usually
built either by pulling the database to see
what's changed or in Postgres, for example,
you can do listen and notify but that's not
available in MySQL, that's how do you that.
And so this is kind of--these are the things
that are hard to build into the database or
hard to build into the apps.
So that's one of them, dealing with real-time
data is hard with relational databases.
Very large deployments.
And by very large, I mean on the order of,
let's say, hundreds of more.
I know there are definitions of very large
that are much larger than that.
But large deployments are difficult to do
with relational databases because you either
have to hobble them together, restarting or
something like that into what looks like a
single large virtual database or you have
to have a database technology that supports
that notion itself.
Also, really high workloads, large number
of connections to the database, if you got
large numbers of application servers and you're
using something that--typically what I would
see is Java with a pic size connection pool
and a shorted deployments, so each Java application
server has a connection pool open to each
set of database servers and, you know, you
just get kind of an N squared cross product
of connections opening up, most of which are
not really doing anything.
And suddenly, the database server has to struggle
pretty badly under that.
On the other hand, if those connections are
doing a lot of work then the database server
is under high concurrency and preventing degradation
of servers into those circumstances is hard.
Admission control, prioritizing, making sure
that really important things get done and
less important things are done on the best
effort basis.
This is really important for getting utilization
which matters a lot at large scale.
You want to really utilize all of that hardware
and software that you're running pretty well.
There's a few other things, when you build
for sort of that very large scale thing, the
single threaded performance or the performance
of individual queries can suffer.
And so, thus, can kind of work across purposes
to each other.
So that's another really hard problem.
I mentioned mixed workloads a little bit.
Lots and lots of short queries, lots and lots
of long queries, long running transactions,
things that are idling transaction for a long
time, those are hard things for a database
to cope with.
And yet, if you're not going to cope with
them in the database and maintain availability
and performance under those kinds of demands
then the application has to be smart and do
things like not leave transactions open for
a really long time which as you probably know
is--it's difficult to not but, in many cases,
you can actually ask application developers
to do that instead.
You have to ask them to retry after you killed
their long running transaction.
So, you know, that's--I don't know if there's
a great answer for this.
I do know that some proprietary databases
are better at this than some of the open-source
databases that are dealing with, you know,
really mixed workloads.
Disaster recovery, dealing with--all of the
things not just recovering from the disasters
but preparing for disasters as well.
So taking backups, taking backups is a hard
thing.
To take a good backup, you have to take a
consistent snapshot at some point in time
and there are lots of techniques for doing
that, but many of them are hard.
Taking consistent backups across lots and
lots of servers, restoring backups, restoring
large amounts of data, these are hard things
to do.
The database itself recovering well and gracefully
after it crashed.
Obviously, there's decades of research and
practice in building databases to do this
but that doesn't mean that it's not still
hard.
Running reliably, this is kind of a funny
one.
Actually, I think last year at OSCON, there
was a really great slideshow from a Googler
called While (true) run; how hard can it be?
Or something along those lines, anybody remember
that?
It was about how to run something, you know,
and make sure that it keeps running which
turns out to be nontrivial due to problems
with tools, like init in Linux distribution.
And I'll just pick on MySQL a little bit here.
MySQL uses configuration files and then it
scripts by default in most distributions to
run.
And I never really thought that that was a
bad thing until I started to see how brutal
that actually makes the server.
There's--on the other end of the spectrum,
there's this philosophy called The Twelve-Factor
Application which is basically do everything
that way that Heroku does it because Heroku,
which is fine.
I mean there's a lot of--there's a lot of,
sort of, deep truth to be had in the Twelve-Factor
philosophy.
And I was a little bit skeptical at first
but then when I started--one particular member
of our team encouraged us to rewrite some
applications that kind of behave like MySQL
with regards to config files and stuff.
And we rewrote those to use environment variables
for configuration and we did a couple of other
things, you know, we made them not daemonized
for example.
And then we suddenly found that our applications
were behaving much better.
And it started to make a lot of sense to me.
And a lot of the complaints that I've had
about MySQL, things like it loses track of
its PID file and loses its mind and the init
scripts then does something stupid like starting
a duplicate instance or shutting down a server
when it shouldn't be shut down or it doesn't
get shut down when this--when the--when the
operating system shuts down, so it gets kill
-9 in unclean state.
All of these sorts of things, those are--those
are problems that need to be solved to--either
in the database or you need to solve them
yourself the hard way as the--as we've done
at VividCortex to get things to run reliably.
And I know given that While (true) run talk
from the Googler in OSCON, similar things
have been done in Google.
Extensibility is hard.
If you don't make your database extensible
then you have to extend it with the application.
I'll come back to that topic a little bit
later.
Schema changes are a really big deal especially
at large scale.
And if you have online non-blocking transactional
DDL in the database, that's a beautiful thing.
It's a very hard thing to build into the database.
So if you don't have it there, you end up
having to build into your deployment processes
and lots and lots of tools have sprung up
around MySQL for doing this.
Facebook's online schema change, Percona's
pt-online-schema-change tool, there's another
one as well in common-schema [INDISTINCT]
so, this schema change problem is yet another
thing that's hard either in the database or
in the application, take your pick.
Query plans and query planning.
The bad thing about having a database that
can run queries as supposed to simple gets
and sets is that the queries have to be planned
and the plans can have worst cases.
And people can easily, kind of, shoot themselves
in the foot with the worst cases without what
they're about to do.
The good thing, of course, is that you can
declare what you'd like from the database
and you don't have to write query plans into
your application code.
If you are using a database that just does
simple gets and sets, you end up with query
plans in application code.
So they're hard in either place.
Doing background operations, like maintain--maintaining
the table space, defragmenting data, merging
unused data, called vacuum in Postgres, those
are hard things to do without blocking the
foreground operations and the database.
This is not something that can really be moved
into the application in any credible ways,
so this is just hard to do in the database.
ACID transactions, I love ACID transactions.
They, they are such a simplifying and such
a force multiplier in many cases.
But they result in lots of types of things
that are hard and hard not only in the database
but sometimes it's hard in the application
to deal with.
The alternative, of course, is roll your own
transactions in your application which is
not a solution that I'm interested in particularly.
I've done it but I've never enjoyed it.
Replication, we can probably just leave it
at that.
Replication is hard.
And to be done credibly almost, it always
has to be done in the application.
Sharding or distributing data really needs
to be done in the database in the future,
I think.
This is--this is going to be in my list of
thing that I want to be done in, let's call
it, next generation databases but often it's
done in the application today.
Sometimes in sharding frameworks or middleware,
things like vTest, or Jetpants, or MySQL now
has this thing called Fabric and there's Tungsten,
continuing Tungsten and there's lots and lots
of sharding proxies and sharding middleware
and so forth and so on, that are trying to
abstract a set of single node database servers
and make you think that there's one big database.
And by large, it doesn't work very well.
The problems--there's a couple of problems.
One is that sometimes the products are built
by people who aren't practitioners in which
case they may not serve real used cases or
may not serve them completely.
And if you don't serve something completely,
let's say you have a 95 percent solution.
What I've often observed is that in practice,
95 percent of people then can't use it.
So, you have a 95 percent solution and five
percent of people can use.
It's like, you know, this catch 22 if you're
trying to build something that's generally
useful.
Another problem with sharding frameworks like
these is that they're often built by practitioners.
So you're sort of damn if you do and damn
if you don't.
But if you are--if you build a sharding framework
for your application and then open-source
it, it's often very difficult for people to
assess and think about what this sharding
framework, or middleware, or whatever it is,
how it's going to behave.
Like, the database underlying, it is complex
enough.
And now, you're giving me a layer over top
of it that I have to evaluate and think about
whether it's going to meet my needs and in
what cases does it going to fail and what
are the--you know, where are the lift points
on it and what sorts of nasty things am I
going to have to deal with.
And so that's often scarier than just building
sharding into my app.
So that's what ends up usually happening.
I haven't seen any sharding frameworks or
middleware really adopted at large scale.
And I haven't seen any proxies.
Sharding proxies actually really solve the
problem either in my opinion.
So what often happens is you just sort of
build the best effort good enough into your
application and now you got a sharded application
to deal with.
So this is hard sort of no matter--which way
you look at it.
But I'll return to this later.
I think it's largely because we're dealing
with a single node database that we're trying
to use as a multiple node distributed database.
And that's probably not really the best fit.
It's probably--not doom to failure but it's
not necessarily going to be a smooth and wonderful
experience.
Performance management is a particular challenge.
This is really near and dear to my heart for
reasons that I'll come back to again and again.
But troubleshooting databases, especially
in a large deployment under heavy load and
lots and lots of different things going on
at the same time, troubleshooting what goes
on in the data--in the database and managing
performance in general, is a real challenge.
And to some extent, this can be supported
within the database.
To some extent, you can architect your application
smartly but you also probably just need external
tools as well.
So the application performance management
market has done really well here, tools like
New Relic, AppDynamics and so forth.
Of course, there's also things that are, let's
say, distributed tracing like Zipkin or App.net
is actually built on the same thing, xtrace.
So there's lots and lots of tools that you
need both within and without the application
and the database server.
And it's--it feels like something that can
often be planted but eventually it comes back
to the point of okay, we have a lot of database
servers now, a lot of applications accessing
them and we really need to understand what's
going on and that's hard because we haven't
built for it yet.
So, for example, VividCortex, we're in the
process of maturing that framework.
It's actually open-source already.
It's called PM stands for Process List Manager.
We're building the notion of something sort
of similar to MySQL show process list into
API servers or any type of--any type of server
that accepts a request and does some work
in return that response.
And so, what we're trying to do is build ourselves
a distributed ability to look at every process
that is currently running in all of our API
servers across all of our machines which it's--even
at our small scale right now is already hard
to do without tools like that.
So, there's lots of work that needs to be
done to make that happen.
A lot of that is enabled or prevented by instrumentation
or lack of instrumentation inside the systems
that you're trying to introspect.
However the instrumentation inside the systems
can come at a cost.
Typical ways to do it in MySQL are through
things like status counters and the Performance
Schema.
Performance Schema is getting a lot better
but it's really complicated.
Everything has really long names.
And I think you'd have to basically live in
a day and a day out to make much sense of
it and to kind of know where to look for your--for
the data that you're looking for.
Also, it's inherently limited.
It's--you only get the data out of it that
somebody thought it was useful to build into
the server ahead of time.
And if you need some additional information
on a running database server, you're going
to have to get it one way or the other and
that--you know, that's often something that's
not instrumented.
Percona prefers to use the slow query log.
I have slowly sort of falling out of love
with the slow query log for instrumenting
what goes on inside of the server and probably
because of the same things, you know, it's
slow moving.
If you don't get a particular statistic in
the slow query log then you're kind of out
of luck unless you want to rebuild your server.
But also because logging is pretty resource
intensive and it's dangerous.
You can run your disk out of room and crash
your whole database server which is in my
experience the number one reason that database
servers crashed.
And finally doing something with all of these
logs is really expensive.
So, there are ways to work around that like
sampling and partial logging and things like
that.
But those are not answers that I'm happy with.
So, what we've opted with VividCortex is to
capture the network traffic, decode the protocol.
And then anything that we can't observe from
that which seems--that actually seems very
limited, right?
But anything that we can't observe with that,
we're now building a system to compute based
on particular regression techniques and so
forth.
So, we actually can get things that are impossible
to measure anyway and we can do it after the
fact with essentially no performance impact
and we can ask ad-hoc queries that we didn't
have to instrument ahead of time.
So, there's a lot of benefits to that.
You know, we're still early but we'll see
how it goes.
So, far it's looking very promising.
Configuring and reconfiguring the database
is something hard because a nicely operable
system has to be reconfigurable on the fly
which introduces all sorts of interesting
things into the code.
But if it's not, then it has to be shut down
and restarted which in many cases is just--that's
a showstopper.
You can't do that.
So, there's sort of a spectrum from things
that are hard coded to things that are configurable
when the process starts to things that can
be reconfigured during runtime.
And then the Holy Grail, maybe not the eventual
Holy Grail but the Holy--slight Holy Grail
beyond that for me at the other end of the
spectrum would be things that are adaptive.
You could maybe configure them if you wanted
to but they figure out what's going on and
adapt themselves.
And I think SQL server has done a really good
job with this.
It's--with error codes, it's self-tuning and
I'm talking to people who are SQL server experts.
I used to work with SQL server.
I'm not an expert in it by any means.
But talking to experts, they tell me that
it does a really good job.
Benchmarking.
So benchmarking is hard.
There's a theme going on here, somewhere,
I know.
Benchmarking is hard in part because benchmark
tools are often really miserable to work with.
They do silly things that are unrealistic
like drive the database or other system that
you're measuring, pass the point of good performance.
They'll drive it as fast as possible way over
capacity.
And if you're trying to ask a question like,
what's the maximum capacity of my system with
good performance, you won't get it if you're
just bringing it to its knees with more load
that it can handle.
So, that's kind of a, go really fast as fast
as you can and sort of a fundamental assumption
with a lot of benchmarking tools which makes
them really unproductive for a lot of things.
The benchmark themselves--oh, and the tools
also by the way can be really hard to use.
Like SysBench over the years I think has almost
devolved, the last couple of times that I've
used--that I've had to use older versions
because newer versions, I either can't figure
out how to use or they have bugs that prevent
things that I was used to relying on from
even working.
So, I don't know maybe LinkBench or other
benchmarking tools are an improvement here,
maybe there's a better breed, or maybe SysBench
is going to be improved again in the future
but for right now, benchmarking just looks
really hard to me.
Finally, after you've done this benchmark,
you realize, oops, I goofed something up.
And a good benchmark can take hours or days
to run.
So, the whole thing is invalid, start all
over again, gather--get resources for this,
got to get time for this.
It's really--it's just--filling good benchmarks
and doing them well is so much work.
This is probably why I'm really thankful to
Vadim and Percona because he does a good job
with his benchmarks.
Every time somebody asks me what I think of
another set of benchmarks--it's not that there
are not other people doing good benchmarks,
so.
But Vadim's benchmarks usually impress me
pretty well.
And then the last thing I'll say about benchmarks
is that it's almost impossible to extrapolate
what happened to that benchmark and how is
that going to have anything to do with my
application even when you try with things
like LinkBench to build benchmarks that more
closely resemble your application.
I think the best you can do with benchmarks
often is compare that benchmark against itself
with different settings or something like
that.
So, useful for improving the server's performance
but not necessarily useful for extrapolating
to real world applications.
So, conclusion is databases are hard.
No surprises there, right?
So, what can we do?
There's a thing--a set of tools that I think
are useful for dealing with hard database
problems.
And I'll just go through a couple of those.
These are--these are some of my favorite techniques
and I won't go into great detail with a lot
of them.
Queuing theory, I think everybody should have
some grasp at least of what can--queuing theory
is about.
The math is really hard.
It requires understanding probability which
I don't and so I awfully admit that I am not
the person to explain to you in depth why
queuing theory works, like particularly the
Erlang queuing theory equations.
I'm not the person to explain to you how they
work.
I know that they work.
I know they're a little bit difficult to use
but that--when you get the principles behind
them, it's sort of reorienting set of mental
principles to guide building applications.
So, that queuing theory, those principles
behind them can be gotten without studying
queuing theory itself.
In particular there's a book by Eli Goldratt
called The Goal which I love.
It's a novel and it explains in two other
things like boy scouts hiking along a trail,
how queuing theory works, and why systems
go faster, slow, and why things get inconsistent
and pile up and get bottleneck.
So, that's one of my favorite books.
This--Little's Law by the way has nothing
to do with coffee.
It's just because coffee.
Who wants a cup of coffee?
Little's Law is one of the unifying principles
behind measurements of performance.
So, Little's Law says that concurrency is
equal to--long-term average concurrency in
a stable system is equal to long-term average
throughput multiplied by the long-term average
response time.
And those three metrics are all about units
of work which is one of my sort of founding
philosophy principles for VividCortex is that
you should care about the work that systems
do.
In the database, the unit of work is a query.
In the file system, the unit of work is typically
an IO read or an IO write.
So, those--you know, those bits of work are
really what we should be caring about in our
systems.
And so, Little's Law is kind of core to that
and these three metrics, throughput, concurrency
and response time are really important in
understanding that.
Another thing is Amdahl's Law.
This is a mathematical way of saying, if your
system is five percent serialized where serialization--the
portion of your system that's serialized would
be the sigma.
If your system is five percent serialized,
no matter how much parallelized it, you can
only cut out ninety-five percent of the runtime.
So, the best you can do is make it 95%t faster
which is 20X speedup.
So, Little's-- Amdahl's Law gives us a very
clear and intuitive explanation, sort of the
asymptotic best-case behavior that we can
get on the system.
When we try and parallelized it, it has some
serialization in.
Going beyond that is, Neil Gunther's Universal
Scalability Law because chocolate cake which
adds an additional component into the denominator
there.
That additional term has a kappa coefficient
in front of it.
And kappa here represents when you parallelized
something, how much crosstalk has to happen
between the units of workers that are happening
concurrently in order to coordinate and make
sure that they do their work correctly.
And the Universal Scalability Law is in my
opinion a very elegant and powerful model
of how system scale and why they don't scale
as well as they should and why their performance
drops off under higher concurrency in particular.
So, you can--it's a closed-form equation and
it's easy to regress to some example data
sets and you can gather these samples easily
which is something that you can't say about
formal queuing theory but the data that you
need to do modeling with formal queuing theory
is very hard to get.
So you can get these examples of throughput
and concurrency.
Notice that the throughput, concurrency are
the only two things that you need in this
Universal Scalability Law.
So here we're dealing with a subset of Little's
Law.
We're dealing with basically these three metrics,
these fundamental metrics of performance around
units of work in your system.
So you can measure throughput and concurrency
in your system in the wild very easily and
regress it against Universal Scalability Law
and do useful things, like, how close am I
to the maximum capacity, how much more capacity
can I expect out of my system beyond what
I'm able to measure.
If my system looks like it's not--looks like
it's suffering under increased concurrency,
what's causing that and what can I do to fix
that?
So it's a--it's a framework for describing
why things scale or fail to scale and for
understanding and putting things into a logical
model of how to do better.
So these fundamental performance metrics that
I've been talking about, throughput, response
time, concurrency, those are really basic.
Utilization can be derived from those.
The things that we can measure on systems
really easily even from things like, TCP traffic
which is part of what we do at VividCortex
is the arrivals and completions of these units
of work.
So if some query arrives at the database server,
it's now inside the database server, we can
increment concurrency.
When it leaves and goes back, we can decrement
concurrency and we can measure the elapse
time we set out with the response time and
we count the completion and that's our throughput
so completions for a unit of time.
So these--just measuring arrivals and completions
is a really powerful technique for being able
to pull all of these things out and do all
of these rich modeling with things like the
Universal Scalability Law.
Models are dangerous because you can sort
of get model tunnel vision and start cramming
your system's behavior into some model that
may or not fit.
I love--this is a recent tweet from Hilary
Mason, who's at a venture from now but she
was formally the chief scientist at bitly.
And there's lots of lots of sayings that are
similar to this, you know, &quot;All models are
wrong.
Some models are useless.&quot;
I like this picture of Da Vinci's helicopter.
Theoretical helicopter theoretically might
fly.
&quot;Everything that's simple is false.
Everything that's complex is unusable.&quot;
There's some spectrum between models that
are simple enough to be applied and therefore
useful and models that are correct but too
difficult to apply such as queuing theory.
&quot;The map is not the territory.&quot;
That's actually a philosopher.
And then there's another modern philosopher,
Neil Gunther, who says, &quot;All measurements
are wrong.&quot;
Those are essentially statements of the same
thing.
In a talk very much like this one, Neil Gunther
said, &quot;All measurements are wrong.&quot;
Who knows what that means?
And he pointed at me.
He said, &quot;Baron, I know you know what that
means.&quot;
And I didn't know what it meant.
But a few minutes later, the light bulb went
on.
The measurement of a quantity is not the same
as the quantity itself.
That was such a revelation for me and it's
such a simple thing.
But I was flattered that Mr. Gunther had such
faith in me.
So here's some interesting things that I continue
to study and some cases apply.
Regression.
There's lots of different types of regression.
I'll probably spend the rest of my life learning
about them.
I've sort of quasi-invented a variation on
regression that we actually used in production
that I find very helpful.
Forecasting.
Regression can be used for forecasting.
Lots of techniques can be used for forecasting
including things like analyzing time-series
metrics for periodicity, seasonality, and
predicting where they're going to go in the
future, those kinds of things.
In fact, most work around time-series metrics
as far I've been able to discover has really
been in one way or another trying to forecast
what that metric is going to do one second
from now, if not, a long time from now.
It turns out that even predicting what the
next measurement is going to be is pretty
hard.
Anomaly detection is another way of saying
the same thing.
If I expected it, if I forecast this metric
to be a certain thing and it's outside of
my expectations then I can call it an anomaly.
I used exponential moving averages to death
and I love them to death.
And I wish that I were able to invent something
that had some of the properties of the exponential
moving averages and gave these modern desirable
properties like exponential moving regression
which is something I'm working on.
Control charts if you can forecast, you can
draw control lines, and if your--if your measurements
fall outside of what you expected then that's
essentially applying a control chart to measurements.
Some people don't like Holt-Winters or Double
Exponential Smoothing or other seasonality
methods and they like to use fast Fourier
transforms and that's something that I'm interested
in but haven't done it myself.
And the final thing is supervised learning
which is a fancy way of saying that I take
some data, I look at it, slice it, dice it,
pull something out of it, write an algorithm
to do that again in the future, deployed in
the production and then repeat it.
So that's my supervised learning method.
And those are all kind of things that I'm
working towards or working on sort of hooking
up a performance management solution.
So I want to talk a little bit about performance
management.
And by the way feel free to interrupt me and
ask questions at any time.
But I wanted to talk a little bit about performance
management because people often say, &quot;Oh,
yeah, you're building a MySQL monitoring company.&quot;
And I don't want to build a MySQL monitoring
company because I think monitoring is kind
of the wrong tool.
Monitoring says, thresholds and alert checks
and, you know, health and is it up or down
and that's not necessarily I think what people
really need most of the time.
Most of the time when people install a monitoring
tool, there's--somewhere kittens are dying.
They really should have installed a performance
management tool instead because performance
management tools care about the work getting
done in your systems.
And I think if you look at the user interface
of application performance management tools,
you'll see that implicitly or explicitly they
are very focused around revealing to people
visually or with numbers the work that's getting
done and how good the performance is and what
needs to be done, where you should direct
your attention.
And monitoring doesn't do that.
Monitoring takes metrics or monitoring checks
and sees that something is alive but it doesn't
know anything about the metrics.
It doesn't know anything about the meaning
of them.
It doesn't have any predefined notions.
It's just--these monitoring tools like Nagios
or Graphite or so forth are by and large just
drawing charts and maybe allowing to do some
nice things with the charts and telling you
whether something is alive or dead but they're
not really measuring the work getting done.
So--and the reason I care a lot about this
is because almost literally, figuratively,
the sky is falling as we deal with lots and
lots more data.
And, you know, I'm caught in this.
A lot of my good friends are caught in this.
We--the data that we're dealing with is just
growing and growing and growing.
And we can't really scale proprietary expensive
systems to those levels so we turned to open-source
software because it's cheap, maybe even free
like a puppy dog.
And as a result, we get--we install things
on our servers that have no really strong
revenue streamer on them.
And since there's no revenue stream, it means
that nobody has invested millions of dollars
making them really easy to manage or making
them easy to--easy to measure and understand
or building really good tools around them.
And so you've got really large scale distributed
systems without good tools to manage them.
And this throws the burden back onto the people
that we've really overburdening already in
the first place which is the operation staff
most of the time, database administrators,
developers to some extent.
But largely, it's the operation staff who,
in most organizations are responsible for
prior fire fighting when things goes out in
production.
And so it's--in some ways, it's a vicious
cycle.
And the only thing that I can see that can
make it better is tools.
So, you know, that's what we're trying to
do in VividCortex, is build better tools for
performance management.
Tools drive methods.
If you give somebody a hammer, they'll bang
on things.
If you give somebody a screwdriver, they will
twist, and pry, and poke.
If you give them performance management tools,
they'll manage performance.
If you give them tools that are based around
the performance management methodology and
the mindset, they will follow it whether they
realize it or not especially if the user interface
follows it for them and just presents them
the results.
So I really want to build tools that express
a process implicitly, preferably.
I don't want to beat people over the head
and educate them.
I just want them to be able to do things without
sort of going down wrong troubleshooting pass
and looking at metrics that may have nothing
to do with the problem and sort of ending
up with the tail wagging the dog and the cart
before the horse.
I want to build better tools so that people
automatically do things better.
And there's nothing that I have ever observed
that's more powerful for driving a process--for
example, the tools that I built at Percona
were largely to try and drive a better process
for the consulting team, and it really worked.
So again, for me, the central thing of concern
is the work getting done and is the work getting
done consistently with good performance and
good behavior.
The other question that I want my tools to
answer is the so what question.
If you show somebody some data or you tell
them that a metric is so and so, you have
to be able to answer the so what question,
you know, CPU used just a hundred percent.
So what?
The disk is getting full.
So what?
If you can't tell people why this matters
and what the consequences of it are, then
you haven't followed it through all the way.
And I want the tools to follow through all
the way to help people to answer this so what
question.
So to give you an example right now, Pt-query-digest
from Percona Toolkit will show you which queries
consume the most time on your systems.
So what?
You have to--you have to do all the rest of
that work yourself after that to do anything
with that information you've learned.
I created an acronym for this, the things
that I really care about in systems; capacity,
availability, performance, and scalability.
And those are the things that I want my tools
to care about the most.
Performance, I'll just mention briefly.
There's two aspects of performance that I'm
most interested in.
Cary Millsap defines performance as response
time.
That is the time it takes to complete a task
or unit of work.
I think there's another dimension of performance
that's really helpful which is resource performance.
So Cary Millsap focused on task performance.
Resource performance is usually expressed
in throughput.
How much--how many units of work can my system
perform with good behavior?
You know, meeting a--meeting a service level
agreement.
For example, a 95th percentile response time
or something like that.
Availability is really important to me as
well.
I want my systems to be highly available which
not only means that they're up and responsive
but they're responsive with good characteristics.
I want my response times and my throughput
to be really consistent and predictable.
One of the, sort of, grumblings that happens
a lot in MySQL systems is short little stalls.
This is not limited to MySQL by the way.
You can look at almost any system like--it's
even in the React documentation.
I can't quote the numbers off the top of my
head but it's something that's sort of appalling
about how long the system will pause and how
often.
And those kinds of short little stalls are
momentary downtime and unavailability of the
system, and I want to kill them.
I want to detect them at a very fine granularity.
I've invented a--an algorithm called Adaptive
Fault Detection and you can look at some of
my past talks online for more details on that.
But the idea is to be able to detect these
short stalls and to know whether they're inside
or outside of the system.
So if we see MySQL not doing any work, is
that because it got stuck?
Is it because the disks were stuck or is it
because somebody restarted the application
servers and it suddenly didn't have any queries
to perform?
So those are important questions to answer.
And I really want that--so our algorithm doesn't
need any reconfiguration and that sort of
adopted algorithm again is kind of a holy
grail for me.
There's a set of metrics that systems expose
and a lot of them are easy.
You know, developers include them in the system
like show status, counters or whatever because
they were handy.
It was something that was easy to count and
then just expose.
But with a little bit of forethought about
the metrics that I told you mattered earlier,
response time, concurrency, throughput, those
kinds of things, most systems you can get
throughput from.
But otherwise, if you get response time and
concurrency, most of the time you have to
do something yourself because it's a Black
Box and it doesn't provide you that.
So there's this set of metrics that's usually
baked into a system in some kind of a status
command.
Most of which are not useful.
A handful of them are useful and then there's
a whole bunch of things that are highly desirable
but not included.
So for the most productivity, my recommendation
is to focus on the overlap of those areas
between the easy metrics that you can get
and the metrics that you want and ignore a
lot of the metrics that you'll get out of
the system status command because they're
not--they're not really useful information.
So as I mentioned, I'm heavily influenced
by Cary Millsap.
This is his book.
I recommend it for anybody who's interested
in these topics.
And there was a link on that slide also to
an ACM Queue article which goes beyond what
he talked about in his book which is really
great reading.
Databases are heavily concerned with storage
and indexing and that's changing.
Now and in the future, there's going to be
a lot of changes to storage and indexing.
And I think there's a lot of exciting things
coming out here.
In the beginning, there was the B-Tree.
This is sort of like everything--you know,
the matured database systems that we have
today are largely built on B-Trees.
Up and coming database systems are built on
things like Log-Structured Merge-Trees like
Google's LevelDB or Tokutek, the fractal trees--fractal
Tree indexes.
There's variety of other things.
Skip lists are popular in some newer products
as well.
So these more advanced data structures and
algorithms, I think, hold a lot of promise
for improving performance.
But we're still kind of in the land of the
Tree and we're dealing a lot with the existing
algorithms, and understanding them and their
characteristics is important, I think, to
making better products and to dealing with
the products that you have and understanding
their--how to--how to get better performance
out of them in particular.
I'll touch briefly on the cloud.
I'm not, you know--I have a probably well-deserved
reputation for being a cloud skeptic because
I've spoken against clouds.
In particular, the Amazon Cloud, you know,
a handful of years ago.
The machines that were available and that
were very low performance and comparatively
very expensive compared to your own machines
running in the data center.
But I'll say VividCortex is running entirely
in the cloud.
As of a month ago, we shut off one of the
machines at my basement which was just a staging
system.
So we're now completely in the cloud and the
Amazon Cloud is it happens.
And it's not a bad thing.
We're doing okay, you know, I could get better
performance out of some Fusion-io drives or
something like that.
But we've managed to figure out how the architect
around the limitations and for a start up,
it's lowered our cost of entry and cost of
getting started with the--with the company
over all by at least a factor of 10 and allowed
us to move in months what would have taken
probably the better part of a year before.
So it's been a great thing from--for us, and
call me still a cloud skeptic but I think
things are improving.
And, you know, we're not--we're not really
approaching the Utopia an ideal of utility
computing yet but we're getting in that direction
like things are definitely going in that direction.
And I don't want to just mention the Amazon
Cloud because there's lots of other things,
there's like Google Cloud SQL and in addition
there's other people who are bringing up platforms
or database as a service and there are even
cloud native databases that are coming out
these days that are designed to run entirely
in the cloud.
So, you know, there's a lot of innovation
going on but we're still--where we are right
now is we're kind of grafting old style infrastructure
into stuffs that hosted in a virtual environment.
And I don't think that's the full potential
of where we can get to eventually.
And then NoSQL, so this is a much more interesting
and fun topic, I think, because I've been--simultaneously
for years, I've been a critic and an advocate
of NoSQL systems.
I'm not an advocate of the name, I think it's
an awful name but even I can't think of anything
better as critical as I am of it.
But what's really interesting is that there
are a lot innovations.
You know, we've really moved the state of
things forward in the last few years.
I know the folks at Google with the Spanner
and F1 projects know a lot more about this
than I do.
But even things like eventual consistency,
the dynamo model, the distributed consensus
algorithms that have come down in recent years
like--obviously Paxos is very widely used
but very difficult, so now Raft and there's
the algorithm his name, I forget, that's in
Zookeeper, is it Zab?
I think something like that.
And so, you know, that's--this whole sort
of distributed systems research, this is where
I see things that's being interesting.
This--the No to SQL or the Not Only SQL, that--the
interface or the data model are not particularly
interesting things to me.
The interesting things are the distributed
systems and how we can build systems that
run--databases that run across more than one
server natively.
Like not just sort of bolting together a bunch
of single node databases and making them think
that they're a big single database but building
things that are--that--you know, it's the
core identity of the software itself is that
it runs in a distributed fashion.
And this is not necessarily new either.
There's Tandem and the--what was the operating
system of Tandem?
&amp;gt;&amp;gt; [INDISTINCT]
&amp;gt;&amp;gt; SCHWARTZ: The--huh?
&amp;gt;&amp;gt; [INDISTINCT]
&amp;gt;&amp;gt; SCHWARTZ: Yeah, so NonStop SQL but there
was a name for the operating system as well.
Sorry, say it again?
&amp;gt;&amp;gt; TCL.
&amp;gt;&amp;gt; SCHWARTZ: TCL?
I'm...
&amp;gt;&amp;gt; [INDISTINCT]
&amp;gt;&amp;gt; SCHWARTZ: Yeah, I'm--that's not the word
I'm looking for.
Oh, well, word retrieval problem anyway.
So this stuff was done decades ago, right?
Distributed, really reliable, very high performance
SQL databases running across clusters and
machines.
So it's not necessarily a hundred percent
new but there is a lot of innovation.
At the same time, I think the innovations
have to be approached cautiously and not sort
of with the Kool-Aid drinking approach.
This was one of the funniest tweets that I
think I've ever seen from Stewart Smith.
Stewart is--if I can characterize him, speak
on his behalf, I think he's pretty against
eventual consistency.
I think it has its place but I think you do
need to be aware of the barbs that can come
with it.
At the same time there's a ton of reinvention.
If you look at MongoDB--I do not count MongoDB
as a distributed system.
It's the same thing as MySQL with Master-Slave
Replication and each node is a node unto itself.
And then there's the [INDISTINCT] proxy in
front of it which tries to make it look and
behave like a distributed system which may
be good enough.
I'm not saying that it won't work.
I'm not saying don't do it.
I'm just saying this is not what I call a,
sort of, native distributed system.
In a distributed system, the data is distributed
in an intelligent fashion, queries are distributed,
all right, so queries don't just run in one
node.
This by the way means that you need to have
the notion of a query.
Cassandra, for example, doesn't have the notion
of a query, it's basically a--you can do MultiGet
but that's not a query.
What I call a query is something that actually
expresses declaratively what you would like
to be done.
And then that query, that expression is compiled
into a program and executed on the database
server.
In Cassandra you can't execute expressions,
there's no notion of an expression in Cassandra.
You can put lots of data into it and you can
get lots of data out and then you can operate
on that data but you can't send an operator
through the data itself.
So distributed databases need to distribute
the data, the queries, and the work represented
by those queries and the decisions.
So we can't have a single node system that
lives in this mindset of &quot;I make decisions
on my own&quot; and bolt that into &quot;I don't think
that we can, I don't think that it will really
work.
I don't think that we can bolt those things
together into a distributed database.&quot;
So for me, actually, Cassandra is a good example
of a system that distributes--aside from the
lack of queries, I think it distributes things
in a very sensible way.
So there are great databases, MySQL, PostgreSQL,
et cetera, et cetera, but I don't think that
they will ever be great distributed databases.
Here's my wishlist for what we could do to
improve the great single node RDBMSs that
we have right now, towards some of the things
that have--that have either been innovated
in the other relational databases or towards
some of the stuff that is coming about in
the NoSQL systems.
And then I think we should kind of stop there
because if we're trying to go--if we're trying
to take these products and go that much further
with them, it's probably better that we just
think about other systems that are more suited
to that instead because relational is not--it's
not the [INDISTINCT] the other thing I want
to do is I want to try to avoid too much diversity
in my text TACT.
So there are lots of databases that are particularly
well-suited to something, let's say full-text
search.
But if that's not the core of my application,
maybe it's better off for me to use a relational
database that has a text search function,
even if it's not as amazing as Elasticsearch
or GIS, you know, even if it's not as amazing
as a database that's designed for geospatial
queries.
It might be better for me to use at a fewer
number of products that can sort of do some
things really well and gesture at other things
around the edges a little bit than to run
a whole bunch of different products.
And so I think that's where relational databases
I think should go and, you know, and search.
That's a great thing to have--full-text search
is a great thing to have in a relational database.
JSON, we've had XML databases for what, 10,
15 years now in relational databases.
Put JSON in there too, it's really convenient,
it's really nice.
But that doesn't necessarily mean that it
is a JSON database.
So those are some of the NoSQL things that
I'd like to do in current generation relational
databases.
The things that I want for my next generation
databases, I'm going to flip through these--my
slide pretty quickly.
I want reliability.
I want really reliable distributed systems
because--rainbow trout.
I want high scalability, high performance.
I want them, as I said, to be distributed
by nature, sort of like native distributed
systems, not bolted on afterwards.
I want them to be extensible.
So I was talking to FoundationDB month or
so ago and I said, I really want to be able
to run queries and operators in the database
itself.
And that's something that for example Aerospike
allows you to do in Lua.
And that's really important to be able to
extend the product for uses beyond what it
was originally conceived for.
I want it to be developer-friendly like MongoDB
or Redis which is a huge force multiplier
even though it's not a distributed database
sort of from its inception.
I want databases to be that friendly to use.
SQL is here to stay but that's not necessarily
to say that it's a beautiful thing.
I want it to be manageable and by that I mean
that I want tools to manage but I also want
to eliminate the need for tools as much as
possible.
I want the database server to be very efficient
so that I can get a lot--I don't have to throw
a thousand nodes at something.
I want to be able to do it on my laptop.
And there are highly efficient databases that
show us that a lot of that is possible.
There's also databases out there that claimed
to be perfect.
There are some claims taken from recent marketing
of particular databases.
I think that that unicorns and pixie dust
was in one of the up-and-coming databases
recent best released somewhere in--I'm really
skeptical.
I mean, this--the problem is that marketing
makes it hard to understand what you can actually
get from these databases.
And I want those failure points and the promises
to be really credibly done and explicitly
made, so that developers who don't believe
they can get something or office staff don't
believe they can get something from their
database that they can actually get.
The only thing worse than believing that your
database is durable and resilient and handles
clustering and [INDISTINCT] and all of these
kind of things well is believing it when it
isn't true, you know.
If you tell me that it won't handle that kind
of--that kind of scenario then I won't--I
won't subject myself to that possibility.
So here's a list of some of the databases
that I still am very impressed with, both
the way that they communicate, the capabilities--as
well as the capabilities themselves.
And there's a few here that I'm still looking
into, like, Druid, we're doing a proof of
concept to [INDISTINCT] right now.
And so in some ways, I'm not even a fast follower.
I'm very conservative in these matters.
But these are some technologies that still
remain interesting to me and I think will
be successful and important in the future.
The other big category that I wanted to talk
about is time-series databases because time
is almost always an element in every metric
that we take.
So the notion of handling and working with
changes and series of metrics over time is
really important and it's not built into many
databases today.
There's a few, there's vertical that has kind
of a little bit of a variant on their SQL
dialect that can deal with a little bit of
time-series.
There's a couple of promising up-and-coming
ones like Druid and InfluxDB because beautiful
picture of guitar.
But I really think that the future is going
to be increasingly time-series and so I think
databases like InfluxDB, Druid, New Relic,
Rubicon, looks like it has time baked in as
a sort of primary concept.
And we don't really have anything that's good
for that today.
What we do is we typically build on top of
low level components that don't have a query
language, things like Cassandra.
Cassandra is heavily used for time-series
data.
And the main regret that I've heard from talking
to people who built and deployed large-scale
time-series databases is that every time somebody
wants to do something like management wants
to run a report, you've got to involve a developer.
And not a developer who knows how to write
a query but a developer who knows how to write
an application that goes and does all bunch
of operations against this low level thing
that we call a time-series database.
And I don't think that those are proper time-series
databases.
They certainly don't satisfy me anyway.
So I wanted to close with maybe book recommendations,
it's not the right term here but books that
I've really enjoyed recently, most of which
have nothing to do with technology at all
but I just thought I'd share with you some
of the things that I've enjoyed.
Seven Habits of Highly Effective People, if
I could boil that book down to a phrase, it
would be, &quot;You are free to choose your actions
but not free to choose the consequences of
the actions.&quot;
A book that my brother shared with me not
too long ago is called The Road Less Traveled.
And the phrase that I would pull out of this
is, &quot;Love is not a feeling.&quot;
There's--and oftentimes when I say that people
have a really negative reaction to me and
sometimes we've gotten into a heated discussions.
I mostly try and stay out of that.
But read this book about three times and tell
me if it doesn't change your entire world
view about love and being loved with people.
The Four Agreements added in my screen sharing
view, I don't have my slide notes up here,
so I can't quote this off the top of my head.
But there's a--if I can try and get them,
don't take--I'll just try a couple of them,
&quot;Don't take things personally because it's
not about you personally.
When somebody behaves in a particular way,
it's really not that person and what was going
on inside of them and, you know, all of these
other sort of things that you have no idea
about.&quot;
This is a lesson that I'm trying to teach
myself, usually trying to re-teach myself
everyday.
And hopefully--I think I'm making slow progress
on it.
I don't know how to pronounce this man's name
but this book was just really inspiring to
me.
I guess, the phrase that I would pull out
of this book and share with you is that, &quot;Life
exists only in the present moment.&quot;
And I think the quote might be something like,
salvation exists only in the present moment.
And I fully agree with that, from any philosophical
standpoint that I take.
The last lecture is about a man who was drying
and he wrote a book about a life, so I highly
encourage reading that.
Here's something from another man who died
recently, Seamus Heaney, famous poet, Nobel
Prize winning poet.
And after he died, I realized, you know, I've
never read any of his poetry, so I got this
book.
And it is just been an amazing read.
This man was able to say things that were
just--I would have thought were inexpressible.
He grew up in rural Ireland and I grew up
on a farm.
And his poems about picking blackberries or
walking through the mud or mounding and things
like that are so powerful to me.
But at the same time he grew up in Northern
Ireland and all of that conflict and he's
able to say gracefully and lovingly the truth
about what was happening.
I feel like I--you know, sometimes when I'm
reading one of these poems, I feel like I--I'm
growing up in Northern Ireland with him.
It's an amazing, amazing book.
Man's Search for Meaning, I've read this one
probably six months or so ago.
This is from a man who survives the Nazi Concentration
Camps.
And as far as I can tell lived the happy life
after that which is more than I think I would--you
know, if you were to send me to a concentration
camp right now and ask me, &quot;Are you going
to be happy coming of it?&quot;
I'm not sure that I could be.
I'm not sure that I could deal with that but
a tremendously inspiring book.
So here's my contact information and I always
love to hear from people.
I'll post my slides online and a little bit
of maybe narrative in a blog post about it
as well.
That'll be on my blog xaprb.com.
And I hope this has been fun.
Open to any questions.
Otherwise, if it's lunch time, let's go eat.</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>