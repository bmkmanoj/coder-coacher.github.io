<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Advanced Topics In Programming Languages: Closures For Java | Coder Coacher - Coaching Coders</title><meta content="Advanced Topics In Programming Languages: Closures For Java - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GoogleTechTalks/">GoogleTechTalks</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Advanced Topics In Programming Languages: Closures For Java</b></h2><h5 class="post__date">2007-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0zVizaCOhME" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">but I wanted to welcome everybody
because this is what I hope to be the
first talk in a long line of talks about
programming languages topics at Google
that I'm trying to organize the goal is
to sort of expose all of your you're all
very smart people expose all of your
knowledge about language features and
runtimes and up kindly changes to
languages and software design principles
and get you all up here to give talks we
have some upcoming talks planned in a
variety of things including C++ and
Python and Java an API design josh bloch
will be giving a talk next week but I
wanted to take this time before Neal
comes up here to make a pitch and really
say that everybody can give a talk
you're all smart you all know something
really great about something and you can
talk about it for 45 minutes and even if
you don't know something great about
something you could learn something
great about something and come up here
and talk about it for 45 minutes being
giving a talk is one of the best ways to
learn a topic that I know how to do
because having to explain it to somebody
else is a really great way of forcing
yourself to understand it the topic
doesn't have to be all that popular if
you don't want you know I've had people
asking me I sent out a message the other
day I have had people coming back and
asking me if they can give talks on
things like Ifill and software
transactional memories and
domain-specific languages it doesn't
have to be as sexy as closures for Java
and if you give a talk you get some cool
free sweat cool free Google swag so if
that can't doesn't entice you I can't
imagine what will so that's my pitch to
you please give a talk contact me I'm
Jeremy manson at Google we have a wiki
page it's the talk series is called
advanced topics and programming
languages so just look that up on on the
wiki you can subscribe to the mailing
list or add it to your Google Calendar
and with that I will let me talk about
closures neil is very impressive and
famous and you've all no doubt heard of
him he
his long history of giving giving these
sorts of talks and closures for Java is
just the latest in a long line of very
good talks he's given this is his
proposal for a feature that is sorely
wanting in Java and his implementation
of it for the next release Java 7 and
without no further ado I will top thank
you so thank you so I want to start with
a quote this is a something that Merck
Jason Dominus said in a recent interview
discussing his book higher-order pearl
in another thirty years people will
laugh at anyone who tries to invent a
language without closures just as the
left now at anyone who tries to invent a
language without recursion and I think
that's true a lot of the languages that
we're seeing being designed nowadays or
or starting to see wider adoption have
closures as a very basic part of the
language right from the very beginning
and I think I think Java sort of missed
the boat on that but it's not too late
and some people some people even think
that Java maybe already has closures and
and there are technical reasons why Java
really doesn't have closures and I'm not
going to talk about the technical
reasons I'm going to really talk about
the practical reasons why what-what is
in Java right now doesn't satisfy what
you what you what you get from the
requirements that you sell by adding
closures to the language so here's an
outline of the talk I'm going to start
by giving sort of a very high-level view
of the goals of the language feature
what it is we're trying to accomplish
and a definition what is a closure and
it's I'm not going to go into a lot of
technical depth about what what the
definition means but it just give you a
feel for what it is and then we're going
to look in a little bit more detail at
the existing solutions to these kinds of
problems in Java and we'll show some
examples of using them to solve some
existing problems and you'll see where
the shortcomings are and that will lead
to the requirements for what it is we
want what kinds of problems do we not
want to have in the language once we
have closures as a solution to these
problems
and then that will lead into the
specification and I'm going to give you
a high-level view of the specification
there's a lot more detail there's a
specification that's online that covers
in a lot more detail what this is I'm
just want to start to give you a feel
for what the specification looks like in
what it would feel like to have closures
in the language and then I'll give some
examples of what of what code might look
like when you start using closures and
there are in particular you want
closures to be able to work nicely with
the existing language not only with the
existing language but with the existing
libraries and I'll show that there are
things in the specification to make it
work very nicely with the existing
language and the existing libraries and
finally I'll talk about some of the
kinds of new API s you might want to add
to Java as a consequence of or well not
as a consequence of having closures you
would want to add them now if the only
there was a way of expressing them but
there will be a way of expressing in the
ones we have closures so what's the goal
the goal is to enable something that I
call control abstraction ap is what
these are their methods as part of api's
that act like new statements in the
language I'll talk about what that means
in more detail in a moment in addition
you want to be able to do the sorts of
things that you can do with anonymous
inner classes but you want to do it much
much more easily than what you have to
go through right now so I'll call this
concise function literals you want them
to work smoothly with existing API so
there are a bunch of api's right now
where you generally use anonymous inner
classes with them you'd like to be able
to use closures with them and make to
make those api's easier to use and I'll
show you how that works and there are
all sorts of things that in the
functional programming world you do with
aggregate operations and higher-order
functions that are possible because
because you have function types and
closures in those languages those sorts
of things will start to be possible in
Java and I'll give you a feel for what
those are but mainly the intent is for
closures to be something simple it's not
supposed to be sort of a overarching
consideration of the whole Java platform
it's supposed to be a sort of an
addition that's orthogonal to the rest
of the features in the language that's
straightforward but it provides a lot of
power and adds a lot of flexibility to
the language that is lacking right now
in some cases you don't even realize
where it's lacking and I'll sort of show
you places where the power is lacking
and you really don't even realize it
when you end up writing lots of
boilerplate code so let me start with
the definition what is a closure a
closure is a function that refers to
free variables in its lexical context
now what's a what is a function function
is something that takes some parameters
does something it might return some
result in a language like Java that's
not a functional language but it's it
right there is state and there is
mutable state the body of the of the
closure might mutate something might
make some changes and what is a free
variable free variable is essentially a
name that has a definition outside the
closure it's not defined by the closure
but is used inside the closure and you
want those free variables in the closure
to have the same meaning that they would
have had outside the closure so it's
basically a lexical scoping
so and I also mentioned that one of the
primary goals is to enable control
abstraction api's now control option
abstraction API it's a new kind of
statement form that is added to the
language but you add it to the language
by writing a function so the idea is it
will be possible to write a method that
acts like a new statement form and they
are ordinary methods except they may
happen to take a closure as one of the
arguments and the idea is you can start
using methods to extend the language and
these are typically API specific and
it's this is the reason it doesn't
necessarily make sense to add them
directly to the language is because
they're specific to the API now if you
have an API that's in the platform
that's in part of j2se you might
consider adding a statement form
specific to those api's in fact that is
the approach that's been taken up until
now for example you have the collections
hierarchy well and JDK 5 we added this
new for each loop but it's really an API
specific statement it's designed
specifically to work with the
collections hierarchy if we had had
closures in the language before JDK 5
before we added the for each loop I
believe it would have been possible
instead of adding for each as a new
language construct to add it as a method
and some utility class somewhere it
would have exactly the same syntax but
have exactly the same semantics you'd
use it exactly the way you use it right
now but it wouldn't be a language
extension they wouldn't have to be known
by every IDE you wouldn't have to go
under the java language specification it
would be something that's documented the
same way you document any other method
and you only need to know about it if
you use it and if you want to understand
how it works you go to the documentation
or if you're using an IDE you hover over
the name of that method and the
imitation pops up so now I don't think
there's a problem with the fact that
that methods already there in JDK 5 I
don't think that adding closures after
the fact somehow makes a mess of the
language it is sort of unnecessary in
the sense that you that it's a statement
that you wouldn't have had to have if
you had closures first but once you add
closures to the language there are lots
of other places in the AAP is where you
actually want to have statement forms
that are specific to those aap is there
are a lot of them in the JD K and I'll
talk about some of those but there are
also a lot of them outside the JDK where
it doesn't make sense to add those
language those statement forms to the
language because it's because the the
api's aren't even part of the jdk i'll
show you some examples of that but you
want the statement forms to act like
built-in statements that's important and
I'll tell you more about what that means
so let's suppose you decided without
closures to make to add for each loop as
a library instead of as a statement form
how would you do that using anonymous
enter classes well you make a method
we'll call it for each here okay and
it's going to take two things it's going
to take the collection and it's going to
take the block of code to execute once
for each element of that collection well
how do you express a block of code well
that anonymous inner class it's got to
implement some interface so here we make
an interface it takes it has a method
that takes one argument and it's generic
because we want this thing to work for
any kind of collection and here's here's
the implementation of foreach it works
for any type of collection it takes a
collection of T and one of these
interfaces a one arg of T block and in
the implementation I'm using this sort
of old style loops rather than using the
for each loop because I'm assuming we
don't have the for each in the language
so we go through the iteration write the
way we would have done it before JDK
five except of course that's generic and
we call the invoke method on that block
once for every element of that
collection right this is very
straightforward what's the problem and
why isn't this a good enough solution
what you see here is only one half of
the equation you see the unimportant
half this you only have to write once
but the person who uses this code of
course there's going to be thousands and
thousands or millions of people who use
this code every day when the writing
loops that's the important part because
that's the part that everyone has to
read and write in their day-to-day work
so let's see what the client looks like
well this is this is the sort of thing
we want the client to look like right
this is how the for each loop looks in
JDK five but if we're using this
interface this is what you have to write
for each the collection and then you
have this long and complicated
construction which is the idiom for
constructing an anonymous inner class in
Java and it is a little bit verbose
maybe we could just make that a little
bit shorter right maybe that's the
problem is it's just a little bit too
long in fact there is a proposal to to
shorten the syntax of anonymous inner
classes and that would make this this a
little bit shorter you know maybe it's
maybe you can remove one line or two
maybe you can even remove two lines in
fact maybe you can make it almost as
simple as this maybe I cheated a little
bit here by putting do thing on the same
line after all so so maybe this solution
isn't too bad it's just a little bit
verbose but after all this is a very
trivial example so let's look at a
slightly more complicated example of a
client so here we have a client it has a
local method called to string that turns
a thing into a string and maybe the
reason you want a method like this is
the toothed string method that's that's
a member of thing doesn't quite do the
right thing maybe you need
internationalization or maybe it's too
verbose and you just want a sort of
summary so so we have our own two string
method that we're going to use for the
purposes of
of invoking inside this loop and we go
through this loop for each thing in this
group of things and we print the the
value of the result of this to string
method on the thing okay so we we
basically call our own method and meet
when we print put the result not very
complicated
so here we here's that code modified to
use anonymous inner classes but
unfortunately this code won't compile
what's the problem well the problem is
right here this is the invocation of
this two string method and what the
compiler is going to tell you about this
is it's going to say yeah I found the
two string method but it doesn't take
any arguments I don't know why you're
trying to pass an argument to it so what
is the compiler talking about what the
compiler is talking about is this
anonymous inner class here extends
object an object has a two string method
and that two string method is inherited
inside this anonymous inner class and
because the scope here is inside the
scope where this two string method is
defined we find that first because of
what because that's the way lexical
scoping works you find the stuff on the
inside before the stuff on the outside
so the compiler is going to find the
wrong to string method well okay that's
not a big deal maybe you can just say
enclosing class name to string and
wouldn't that solve the problem sure
that would almost solve the problem
except this isn't a static method so we
have to actually say enclosing class
name dot this stuck to string but
wouldn't that solve the problem yeah
that would solve the problem unless the
enclosing class as an anonymous inner
class then it doesn't even have a name
in that case there's no way to refer to
it at all now you simply can't do it so
okay well that's fine maybe we just move
the to string method somewhere else but
we rename it somewhere else there are
solutions to all of these problems
but this is where you have to start a
step take a step back and say what
problem was I trying to solve I'm just
trying to write a loop I'm just trying
to print out the value of calling this
function why am i fighting with a
compiler you see anonymous inner classes
because they're not closures they have
all sorts of constraints they have all
sorts of semantics that interfere with
your ability to refactor code and and
this is an example of the kinds of
trouble that you can get into so the
point is the point here is Java is a
turing-complete language right
adding closures doesn't change that
anything you can do with closures you
can do without closures but closures
enable you to do things much more simply
and they enable you to refactor code in
ways that are not possible without
closures when you use anonymous inner
classes you have to look at the body of
what it is you're going to wrap in the
anonymous inner class that is you have
to look at this code inside the loop and
if you're going to wrap it in an
anonymous inner class you have to look
at every single line on every single
expression and say do I need to modify
this because I'm using it inside an
anonymous anonymous inner class and
express that code differently to
accomplish the same effect it would be
better if you could always express the
same code the same intent in using the
same code so here's another another
example let's suppose you sometimes
inside that loop you want to throw an
exception well if you're refactoring
your code to use an anonymous inner
class you can't do that a checked
exception the reason you can't do that
is this exception is not declared to be
thrown by this invoke method well can't
we just declare it on the invoke method
well no the problem is the invoke method
in the interface that we're implementing
doesn't declare that so how do we solve
this well maybe we add another parameter
of that interface which is the exception
that can be thrown that works great if
there's exactly one exception that can
be thrown but what if there's zero then
you have to have
two different versions one for no
exceptions and one for one exception but
what if there are two or three or four
or five do you have sort of an infinite
number of these methods one for every
number of exceptions that can be thrown
and you're also sort of forcing the
programmer to sort of explicitly write
this exception over and over and over
again out through any intermediate
anonymous enter classes it's quite
awkward so another example what if
inside the loop you sometimes want to
return a result from the enclosing
method well you can't do that with an
anonymous inner class because the return
type is void in fact it would be right
that the compiler is trying to return
from the wrong place because you've
inserted a new method lexically
enclosing the code that you're trying to
put inside the loop you can't use a
return statement fact you can't use a
break statement to break out of an
enclosing loop or or continue an
enclosing loop finally let's suppose you
want to say set a variable here a local
variable inside the loop this is very
easy to do using an ordinary built-in
loop but if you're using anonymous inner
classes there's a rule that says you're
not allowed to use non final variables
local variables from the enclosing scope
and if it's if it's a non final vary if
it's a final variable with the only kind
that you're allowed to use you certainly
can't assign to it well there are ways
around this you can make an array of
length one or you can make a little
class that just contains all the
variables that you want to modify those
are kind of ugly maybe a sort of
refactor the entire method as a little
class and you make statement you make
fields for all of the things that would
have been local variables you can do all
of these things but again the point is
all of these refactorings of the program
have absolutely nothing to do with the
problem that you're trying to solve you
just want to find the value and return
it from inside the loop
so these are all examples of sort of
trouble that you can get into using them
anonymous inner classes for the kinds of
things that I think closures should be
used for basically they're quite verbose
you have at least three or four lines
well of course you can put everything on
one line if you want but by the usual
conventions you have at least three or
four lines when really one line would do
closures on the other hand are intended
to be much more concise and much easier
to use in your code the most important
thing is the lexical context of the code
is not completely captured by anonymous
inner classes the meaning of this
changes it refers to something different
inside an anonymous inner class than it
did outside the to string or any of the
methods that you inherit from object or
from the interface that you're
implementing or the class that you're
extending all of those affect the
scoping return break and continue simply
don't work the same inside amount of
center class as they do outside and of
course the non final local variables
from the enclosing scope you can't use
them so the bottom line is if you're
using anonymous inner classes to do this
kind of thing you're going to be forced
whenever you try and use them to examine
every line of your code and figure out
how to rewrite that line that code or
maybe you don't need to but you're going
to have to look at every line of code
and think about what you have to do to
make that code work inside the wrapped
anonymous inner class because they are
so difficult to use for these kinds of
things control abstraction is simply not
possible it would be impractical to add
for each loop as a library method using
anonymous inner classes because it would
be unusable but people it wouldn't be
any point in it it would be too awkward
to use and that's why we don't see these
kinds of api's in Java today not because
they're not possible but they're far too
awkward to be practical
so one more example in a little bit more
detail this is this is a program that
you would like to refactor slightly so
this is a this is something this is this
is how we hire people at Google okay
what we do is we have a every candidate
has a set of qualifications right these
are all the keywords on their resume
that that they say the person what do
they know they know Java they know C++
and you know they're certified j2se
level 1 or whatever so we have all these
keywords I'm not gonna tell you what a
qualification is for the moment let's
just suppose it's a string and we have a
pool of candidates which is the stack of
resumes that we received in the past I
don't know a month or two or something
like that this is not really how we hire
people at Google by the way just just so
you don't get the wrong impression and
the candidate pool is a collection of
candidates okay so it's just the set of
people that we can consider to hire and
there's one more thing inside it there's
this lock object now the reason there's
a lock object is when you when when say
my group Google Calendar says oh we need
another person we want to go to that
candidate pool we want to shuffle
through them until we find the person we
want and then we want to remove them but
we want to do that atomically we don't
want to find the person and then try and
remove them and discover they're no
longer in the collection because someone
else hired them so the idea is whenever
you're doing a couple of operations on
the candidate pool you'll lock the lock
you search for the candidate you want
you remove them and then you unlock the
lock that way you make sure that you
also have a consistent view for that
short duration of time and in fact
here's how we recruit someone right we
have the candidate pool as an argument
and the set of qualifications and we're
going to return a candidate and what we
do is we synchronize on the lock we go
through each candidate in the pool of
candidates and if the candidates
qualifications contains all of the
requirements for the position then we
remove the candidate from the pool and
we return the candidate we've done we
found the answer and if we go through
all of the candidates and we don't find
anyone
then we call this other method that for
recruiting someone outside Mountain View
maybe we try and find someone in you
know who's applying for position in the
Zurich office for example and this way
hopefully we always end up hiring some
candidate so this is straightforwardness
code is is more or less correct except
there's one little problem this code is
not fair you see Google is hiring at
such a furious rate that there's lots of
contention for this for this candidate
lock there's so much contention that
there are always people waiting on this
lock looking through the pool of
candidates to find someone and the
problem is some groups get starved some
groups end up waiting on this luck
forever never getting the lock and never
being able to recruit someone and some
other lucky groups get to hire get get
people through the process over and over
and over again they get the lock and
that's because there's no guarantee of
fairness in the locks that are built
into the java programming language
there's no guarantee there's no
first-come first-serve for example when
you try and lock something but there's a
really easy solution to this problem and
JDK 5 the concurrency utilities were
added and they're a very useful
substitute for the built in locks and if
you use those locks when you create a
Java util concurrent locks lock you get
to pass a boolean flag that says whether
or not you require fairness and if you
say you require fairness when you
acquire the lock then it's first-come
first-serve and this is actually very
useful we solved a severe performance
problem in Google Calendar by replacing
the ordinary language built-in locks by
Java util concurrent locks it was a
fairly easy thing to do and it solved a
huge problem for us and so we can we can
refactor this program to use blocks now
this is what I think the refactor
program should look like
the lock method instead of returning an
object returns a lock and I've replaced
the synchronized keyword with an
identifier with lock now the intent is
this with lock method is one that you've
statically imported from somewhere say
Java util concurrent locks some some
static utility method and it acts just
like a built-in statement of the
language it acts just like synchronized
did except instead of using the built in
locks it uses the concurrency locks so
if you compare this with the previous
slide which I don't seem to be able to
do right now but basically this was
synchronized this with lock used to be
synchronized and this lock used to be
object it's the same code but I want you
to be able to the idea of the closures
proposal is that you should be able to
write methods like this with lock method
that behaves like this and there are a
couple things to notice about this code
here we're referring to local variables
from the enclosing scope that are not
final okay we have candidates and we
have requirements now we don't actually
assign to those variables so we could
have just made them final no big deal
but as another thing in here is that we
have a return statement inside this code
this return statement doesn't return
from some closure it returns from the
enclosing method and that's very
important for this code in order to make
this refactoring as painless as possible
you don't want to change the meaning of
the return statement when it's wrapped
in the closure so here's one more
example from the Google Calendar code
base this is code that we have repeated
in the in the calendar code base
hundreds of times and this is the kind
of code we use to time operations in the
Google Calendar code base so what we do
is we take a snapshot of the system nano
timer we set a success flag to false and
the idea is
excuse me we'll set that flag to true
when the operation completes normally so
we can distinguish failure from success
cases we we try we have a try block here
we do the operation and when the
operation completes successfully we set
the success flag to true and in the
finally block we have a method that we
call called record time and that records
that that gathers statistics of the
running time of various operations we
have a string that identifies the
operation we're timing the success flag
so we can gather statistics separately
for the success and failure cases and
finally we take the current value of the
nano timer minus the initial time so
that's the elapsed time that was
required to do that operation ok this
code works just fine the only problem is
it's repeated hundreds and hundreds of
times throughout the Google Google
Calendar codebase and it obscures the
business logic of what it is we're
trying to accomplish right here we have
one two three four five six seven eight
nine lines to do two things the
operation and to time that operation
what I would really like the code to
look like is something like this I want
to call a time method pass the string
that I need to distinguish one operation
from another and then just a block of
code which is the thing I'm timing
there's no way that an
application-specific
API like this is going to end up in the
JDK although maybe you'd argue this is
not specific to Google Calendar maybe
anyone could use a timing operation but
you know does it require a distinction
between the success in the failure case
should it be a nano timer or microsecond
timer and there are many other examples
that are really more deeply into the
semantics of the application than this
one is in fact I've abstract it away
some of the some of the things that
actually are Google there are Calendar
specific about the way we do the timing
so so this I think should help help
motivate the kinds of things I want you
to be able to do and that leads us to
the requirements so what are the
requirements for closures
you should be able to write control
abstractions that is you should be able
to add statements to the language by
writing methods where those method
invocations act like and look like
statements in the language that are
specific to your api's and they should
be on par with the built in statement
forms that are in the language they
should be they should allow you to you
know you can put an if statement around
any block of statements well you should
be able to put your invocation of your
API around any block of statements
shouldn't have to refactor the code in
order to make this work they should be
concise that it should they should be
very easy to use and that's the previous
slide I hope showed you there should be
as easy to use as the built in
statements are and in the cases where
there are things in the api's right now
that have this flavor you should be able
to use the syntax and the semantics and
all of the benefits of closures without
changing those api's you should get that
naturally with the existing API s and I
think we've accomplished those things so
let me show you what the specification
looks like and here's what I'm going to
show you there's really three parts to
the specification there's function types
there's closures those are values of
function type there's a control
abstraction invocation syntax it's a way
of invoking a method that looks like a
statement but it really is just a method
invocation there's some things in the
specification called transparency that
I'm not going to talk about in detail
there's there's four of them that I've
listed up here let me just give you an
example exception transparency that says
that when you define your own with lock
API for example that you should be able
to define it in such a way that any
checked exceptions that are thrown
inside are known by the compiler to be
propagated out and that the language is
natural exception checking will work
with those api's
I'm not going to talk in detail about
how those work if you want to know more
about those you can look at the
specification I'll give you a URL
shortly I will talk however about
interoperability about how closures work
with existing api's so starting with
function types here are some examples of
function types here's a function type
for function that takes an int and
results in an int here's a function type
for functions that take two intz and
results in an int so here's one a little
bit more complicated this is a function
type for a function that takes a string
and results in an int but might throw
number format exception I'll give an
example of a value of that type shortly
here's a function type that doesn't take
any arguments and doesn't return any
result right so an ordinary block of
statements would typically be of this
type where it doesn't take any arguments
and doesn't return any result and
finally if you're in generic code
somewhere and you have type parameters
floating around you can write a function
type using type parameters so here's a
function from tdu that's that's just
fine function types are ordinary types
you can take them as arguments you can
return them from methods you can have
variables of function type you can have
a function type that takes a function
type as an argument and returns another
function type basically anything that
you can do with an ordinary type you can
do with a function type so a little bit
more formally here is the grammar rule
the syntax rule for how you write a
function type it's an open curly brace
it's a list of types and that's optional
because you're allowed to have a
function type that doesn't take any
arguments then you have a fat arrow
equals greater than and then you have a
result type you know you always have to
write a result type but if you don't
have any result you can just write void
and then optionally there's a throws
clause so throws number format exception
for example and the idea is or more than
one throat more than one type you can
list there in the throws clause so the
throws the type that can be thrown by a
function type is part of that functions
type
and finally there's a closed curly brace
at the end so what is the meaning of a
function type well this particular one a
the function from string to int that
throws number format exception that is a
shorthand for a particular interface
type so function types our interface
types they're not a separate extension
to the type system if you understand
interfaces and generics and perhaps a
little bit about wildcards then you
already understand how function types
work this is shorthand for java.lang
punch in IO a string command number
format exceptional what's this IO the
idea is the name of the interface is
taken from the signature and it uses the
conventions of the of the VM signature
of methods so that you start with the
return type or the result type I should
say and that's int and you represent
that in a signature using a capital I
and then the argument types are listed
except any argument type that is an
object type is simply listed with a
capital o rather than describing the
exact type and it becomes a type
parameter so in this case our argument
type is an object type so we have a type
parameter in this and the type
parameters is filled in with string
because that's the argument type of this
function type and there's always another
argument type of parameter for the
throws clause and it turns out if it
doesn't throw anything you can put null
in there and this function type IO looks
like this interface IO a for the
argument type and it takes a type
parameter that extends exception because
that's the throws type and the method is
always called invoke in these function
types and in this case it returns int
because that's that's the one it is and
it takes an argument type a and it
throws X
now you might be wondering am I going to
be typing in a million of these of these
function types and putting it in this
package java.lang function the answer is
no these are generated on demand in the
same way that array types are generated
on demand by the VM any of these that
you need are just there okay if you if
we add this language extension in JDK
seven you could simply write you know
Java dot length function I Oh in your
program or iiiiii oh and those types are
all there or you could use more likely
you'll want to express it this way with
a closed with the curly braces now the
compiler when it gives you error
messages hopefully will give you error
messages in terms of the function types
that look like this rather than function
types that look like this with the angle
brackets because hopefully people will
be thinking in terms of function types
rather than thinking in terms of these
interfaces that's all there is to it
well no it's not quite all there is to
it
it turns out we actually use wildcards
in these arguments as well so that
function types are covariant in the
return type and we use wildcard types in
the argument type so there contravariant
and the argument types mostly you don't
have to worry about that except that it
does some surprisingly useful things
where you would hope it would and you
simply don't have to worry about it
I'm not going to talk about that in
detail but if you want more detail you
can look at the specification which I
will give you a pointer to at the end
so again function types are ordinary
interface types they're not new types
that are an extension of the type system
and function types always have an invoke
method you need to say dot invoke if
you're invoking the method of a function
type you can extend them just like you
can extend any interface type you can
make an interface that extends them you
can implement them well why is it
important to be able to do these things
well let's suppose you want to be able
to serialize one of these things
it's part of a serializable data
structure or maybe you want to express
something that you want done on the
other end you can make these function
implementations of these function types
serializable simply by implementing them
in a serializable class and you could
even make a custom serial form if you
wanted to and again you can declare
variables parameters return types all of
the things you can do with ordinary
types you can do with function types and
there are no special type rules for
these function types they simply obey
the type rules of interfaces and
generics so now I'm going to tell you a
little bit about closures here are some
examples of closures so here's a closure
that takes an int variable or an int
value and results in that value plus one
here's one that takes two values and
returns the sum of them so here's one
that takes a string called X and returns
an int which is the result a pass
parsing that string but this closure
might throw a number format exception so
the compiler knows from the from the
body of it that it can throw a number
format exception so this is the this is
a closure of the function type that we
analyzed in more detail a couple slides
back finally here is a closure that it
doesn't take any parameters that just
print something on the output and it has
no result two has a void result type and
you can tell it has a void result type
because there's a semicolon here there's
no final expression it's just a
statement instead of expression so if a
closure has a result it's the final
expression inside the body if there is
no final expression then the closure has
a result of void so here a little bit
more formally as the syntax for a
closure a closure is a kind of primary
and it starts with an open curly brace
and then you have your formal parameter
declarations optionally you're not
required to have any parameters
then a fat arrow and then a bunch of
block statements but those are optional
you don't have to have statements and
then a final expression but again you
don't have to have a final expression it
could just be statements finally a close
curly brace yep
does it make sense to ask if these
should be parameterize by type I think
the answer is no I haven't I haven't
come across any situations where where
that would make sense maybe I don't know
it's I I haven't I haven't come across a
need for that kind of thing
so what is what is a closure
what is the semantics of closure was a
closure mean well closures don't add
very many restrictions to the statements
and expressions that are within them you
can access local variables from the
enclosing scope there lexically scoped
you can return from enclosing method you
can use the variable this that refers to
the whatever this meant and the
enclosing method doesn't refer to this
of the object that contains the method
that the closure implements it means the
same thing inside the closure is it
meant outside however there is no way to
yield a result early from a closure okay
I mentioned that a return statement
returns from the enclosing method
there's no equivalent of the return
statement inside a closure that means oh
I found the answer I really want to just
get to the end and produce this result
you can assign it to a variable and you
can break from a statement in order to
do that but there is no state there's no
syntax inside of a closure that allows
you to produce that result early and
that's actually important it turns out
that if you try and add a syntax to do
that inside a closure you can no longer
use it to to write control abstractions
I'm not going to explain that in detail
and because a little bit of a
counterintuitive result but if we have
time at the end and someone cares I can
I can explain that yes
so your question is does that mean you
can break or continue inside a closure
okay so I think I know where you're
going with a question but I'm not going
to repeat the question but I'm going to
give you an answer that probably won't
satisfy you
you can break inside of a closure and
the break statement breaks from the
nearest enclosing loop or switch
statement okay
you can continue inside of a closure it
continues the nearest and closing loop
if you want to use closures to write
your own loop constructs I'm not going
to tell you how to do that but there are
ways of doing that
yeah right
so the question is do we get
continuations for free using this in the
current form of the specification the
answer is no if you attempt to return
from a method that's not on the current
call stack you get an exception and
that's specified in the current form of
specification however you can do things
that look an awful wet like
continuations if you're careful using
closures but I'm not going to talk about
that either okay so there's one more
thing that you need to know about
closures and that is something called
the closure conversion so the idea is I
talked about function types and I talked
about closures but I didn't tell you
what the type of a closure is presumably
it corresponds to some function type
well the answer is no not quite the
closure when it appears in a program is
converted to some interface type but the
compiler doesn't always choose sort of
the obvious function type for the
closure instead the compiler is required
to look at the context in which the
closure appears and choose an
appropriate interface type so for
example if the closure is being assigned
to a variable of type runnable then the
compiler is responsible for turning that
closure into an invoke into a meth into
an object that implements runnable
which means are going to use the dot run
method to invoke the closure and
anywhere a closure appears in the
program where it has a target type the
compiler is required to try and produce
something of that target type if you're
returning closure whatever the return
type of the current method is if you're
signing to a variable whatever the type
of the variable is if you're passing it
as an argument to a method whatever the
argument type of the method that you're
invoking is that's the target type and
when you have a closure appearing in the
program it is converted to the target
type now occasionally you might have a
closure appearing in the program being
assigned to something like object where
there is no target type in that case
it's it's turned into an instance of the
natural function type that is the one
corresponding to exactly the same the
function type with the same return type
in the same argument types and same
throws Clause but most in most cases in
a program there will be a natural
interface type where the closure appears
and that's the type you want the closure
to produce this is important for
providing interoperability with existing
api's because we have existing api's
where you register swear you register a
swing callback or you have a runnable
you want to submit to a to an executor
as part of the concurrency framework
lots of places where you currently use
anonymous inner classes because of the
closure conversion you will be able to
start using closures in those places
instead of anonymous inner classes yes
is this conversion strictly oh I'll find
activity or visit
excellent question so the question was
is this conversion strictly a
compile-time activity and the answer is
yes the the sort of a closure and
isolation doesn't need to generate any
code if you don't assign it to anything
and the user can never get his hands on
it then you can't do anything with it
so the compiler applies the closure
conversion always to every closure that
appears in the program and it decides
there on the spot at compile time
what interface type it's going to
construct so there's no there's no
runtime performance penalty for the
closure conversion it happens entirely
at compile time yes so the question is
does that mean that there's a debugger
penalty that the user won't see what the
user thinks of as their code well the
line numbers are going to point to the
right line but if you're wondering what
class is thinking is going to be
executing in he's gonna think it will it
will act similar to the way an anonymous
inner class will act in that you'll know
what source file you're in you know what
line you're at but the name of the class
that you're executing is not one that's
visible to the programmer it's a it's a
compiler generated class so it will it
will act similar to anonymous inner
classes in that sense but maybe maybe
debuggers get smarter they can do a
better job of that the debugger Tinley
will know what the enclosing class is
that's part of this structure of the
name of the generate compiler generated
class I meant there's something in gray
here I'm not going to tell you in detail
but anonymous inner classes restrict
what you can do you can't return from
the enclosing method you can't access
non final variables and for some API
those restrictions are important there's
a way of expressing that you want those
restrictions on certain api's so that
people don't do things that they ought
not to do yes
closure which passes an exit an
exception through the call error which
you have walked the
okay so the question was what's the type
of a closure that throws an exception
that you want propagated out to the
caller
so the question confuses the control
invocation syntax with a closure a
closure is just a method it either
throws an exception or it doesn't okay
every exception thrown by a closure
that's actually thrown it at run time
the person who invoked that closure gets
the exception whether they like it or
not now you can write api's that receive
a closure that somehow cap take the
closure and do something with it or
Express have a way of there's a way of
expressing a compile time that they pass
them on through for runtime type
shopping but that's not part of this
part of the proposal that's part of
something called exception transparency
which I'm not going to talk about in
detail but it is expect it is explained
how you write such api's and the
specification how you write ap eyes that
are exception transparent right if you
want to use this with existing api's you
would not get exception transparency in
particular runnable the run method does
not throw any exceptions so if you want
to use if you want if you end up using
an API that receives a runnable and you
try and pass it a closure that might
throw a checked exception you are going
to get a compile time error the compiler
will say I'm sorry this closure throws
an exception and I'm trying to create a
runnable and it doesn't allow you to
throw any exceptions you're going to
have to deal with that okay so so that's
that's a little bit unfortunate but in a
sense that those are restrictions on the
existing api's my hope is that the
function types once they're added to the
language it will make it easier for
people to write API is that our
exception transparent
getting a return statement of any kind
of exception
it's specified that if you in if you
execute a return statement and the
function invoke the method invocation
that you're attempting to return from is
not on the current call stack that
you'll get an unmatched non-local
transfer exception but it turns out
there are even things you can do to hide
those and shuttle them across threads to
make them return from the right thing
I'll mention that again I think so with
what I've told you so far you could make
a method you could write a method called
whitlock that takes a lock and a closure
and the way you would write that method
is you would write it that it receives a
function type that takes a no arguments
and returns a void as its at the other
argument and you would be able to use it
this way right so you pass a lock and
you pass a closure and the way you write
a closure is an open curly brace no
arguments here the arrow and then
statements and here we're not providing
there's no results so so there's no
final expression close curly to close
the closure close paren to close the
with lock invocation and semicolon to
end the statement that's the invocation
of with lock and this is this is not bad
but it's certainly not as convenient as
the built in synchronized statement you
can statically import it from wherever
you want and if you don't like stat yeah
the question is what is with LOC and
Method on I would expect it to be a
static method somewhere that you would
statically import or import or maybe you
would qualify it maybe you say LOC start
with LOC it's it's you know it's it's a
matter of taste and style how you invoke
it so I'm assuming that you have static
import java.util concurrent locks dot
with LOC at the top of this of this
program in order to be able to do
something like this and that we've added
such a method somewhere but this is not
as convenient to use as the built-in
synchronized statement and the reason is
with most of the built-in statements you
know you sort of remind yourself by the
intent ation level how many closed curly
braces you need to put
well that's not enough here not only you
need to remember the closed curly brace
but you also need to remember they'll
close paren and you also need to
remember the semicolon and that might
not seem like much of a burden but it
actually is especially if your method is
more than a couple of lines long you
really want the user to be able to not
have to remember more than the closed
curly brace so this is a new invocation
syntax method invocation syntax that's
proposed as part of the closures
proposal and it means exactly the same
thing as the previous line so the idea
is if you have a method invocation or
after the closed paren you see an open
curly brace and a bunch of stuff in a
closed paren that is a statement form
and it means to package up that block as
a closure and pass it as the last
parameter to the method yeah
can you write something with more than
50 the question is can you write
something with more than one closure
like an if statement as conveniently as
this with a current specification the
answer is no but you can still use the
closure syntax with the with the curly
braces and the arrows the problem with
with with doing something as nice as the
as the sort of if and then is you can't
tell whether the then is a new method
invocation as a separate statement the
fact that it appears in the same line as
the close curly brace you see this close
curly brace at the end here ends the
statement we don't need to look any
further to see what else is part of the
statement if we allowed another word
here and then another block you can't
tell whether it's one statement or two
statements I wrote a recent blog post
about how to how to deal with this kind
of kind of situation I don't know
whether it's very important to be able
to have those kinds of statements but if
it does turn out to be important I think
that's probably something we can do so
far those use cases seem to be more rare
but maybe that's because I'm only
looking at very simple things for the
moment we're only looking at the use
case where there's a single block of
code that you're trying to do under
control in a sense there are things like
loops and all the sorts of things where
you would use advice in aspect-oriented
programming less those kinds of
applications and callbacks for example
registering callbacks and starting
forking off threads so here is the
formal syntax for one of these new kinds
of statements I call it a control
invocation statement and the idea is you
have a primary just like you have a
primary in an ordinary method invocation
an open paren and you're allowed to have
a bunch of formal parameters here and
I'll show you what those are in a couple
minutes then a colon and formal
parameters in the colon are optional so
you can also do without those and then
you have an expression list and then a
close paren and then a stay
and single statement and what this is
translated to what this means is exactly
the same as if you had written same
primary the same expression list and one
final closure the formal parameters to
the closure are the formal parameters
that appeared before the colon if any
and the closure only has one statement
inside of it and that's the statement
that was the final statement at the end
here now of course a statement could
start with the curly brace and have lots
of stuff inside it and end with a curly
brace but you only you only get one
statement there finally close curly for
the close close of the for the end of
the closure closed paren for the end of
the invocation and a semicolon because
this is a statement form it is not an
expression form yes question so the
question is when you run this at runtime
does this mean you get some instance of
an interface every time you evaluate a
closure expression you get an instance
of some interface typically anonymous
instance of some interface and in
general every evaluation of a closure
will result in a new instance of some
interface now sometimes they can be
optimized away the compiler can
determine that can use one for all of
them and it will only create one but in
general you'll get a new instance every
time you evaluate a closure expression
but you know what
on modern VMs allocating a new object is
just bumping a pointer memory allocation
and and and and garbage collection is
are very very cheap especially when the
garbage is very transient this is the
sort of thing you have to write to use
the locks that are part of the
concurrency framework yeah that's one
more question
somebody forgets a semicolon like some
but it's somebody forget a semicolon or
a second line here it is start to
Trinity to the closure to the gate well
in this example if you forget a
semicolon on the second line
pardon no well yes but it's unlikely
that it will find a lock a method on
java.util concurrent lock that accepts a
closure as a parameter you see so yeah
it's possible the compiler if you forget
it yet so the question is if you forget
a semicolon does that mean the compiler
is going to try and do one of these
invocation the answer is yes but the
chances are the compiler is not going to
find anything to invoke it would be very
strange to have a method overloaded one
that takes a certain number of
parameters and another one that's
exactly the same that takes a closure
right or or a closure
yeah or an object for example yeah that
would yeah
generally speaking overloading is a bad
idea anyway
but it's unlikely that you would get
something that that would be that would
be meaningful but yeah in theory you you
could but on the other hand you know if
you if you you know if you forget an
argument and an invocation is possible
you'll you'll invoke the wrong thing
also but yes if you if you forget a
semicolon somewhere you can end up
attempting to do an invocation like that
and so that suggests that perhaps the
compiler should be careful to point to
the beginning of the statement when it
gives you an error message that it
couldn't find anything to invoke the
close paren and perhaps would be a good
place to do to point so this is what you
have to do today to use a lock from the
concurrency framework right first you
lock the lock then you have to use a try
finally then you'd put your business
logic inside the try block and inside
the finally block you have your unlock
and and and this is what I did in the
calendar server I mentioned recently I
turned some some native locks into
concurrency locks fortunately I only had
to do it in a few places because this
turns
you know you know this adds quite a bit
of boilerplate to your code to have this
interspersed with your business logic
and as I said before this is the sort of
thing that would be a little bit better
where you use your with lock method and
pass a closure as your less parameter
but even better yet would be to use the
control invocation syntax so this is
what this is what you get using the
control invocation syntax blocks that
with lock pass the lock and then as a
final extra parameter we pass the
closure that actually does the work that
we want to be controlled by the lock so
now not only does it act like a built-in
statement but it looks like a built-in
statement but you know it's not a
built-in statement because this is not a
key this is not a you know this is not a
statement keyword right this is an
ordinary identifier and you can look it
up in your IPI documentation you can
hover over it with your IDE to get the
Javadoc popped up just like any other
method invocation you have all of the
resources for learning about it and
understanding it that you have with
ordinary methods so here's another of
the kind of things that will start to be
possible when you have closures in the
language well okay there's this thing
called map in the functional programming
community and it means the sort of the
same thing that we mean when we say Map
Reduce inside of Google but
unfortunately Java already has this
thing called map which is a which is a
data structure and it gets a little bit
confusing but ignoring that for the
moment wouldn't it be nice if we had the
functional programming equivalent of map
right it's something that takes a list
and it takes a function that goes a list
of X and it takes a function that
translates from an X to a Y and simply
does that translation on every element
of the list and returns a new list which
is a list of y's and naturally you'd
probably want that to be in collections
because that seems to be the place where
we
throw all of our static methods on
collections and you'd be able to use it
this way right
collections map a list of some sort and
you simply write a closure as the other
argument that does the translation that
you want this is the sort of thing that
you might frequently see in in
functional programming style and I think
that with the addition of function types
and closures to the language this
becomes easy enough to express that it's
worth adding to the libraries in Java so
what about existing api's for example
there's this executive framework this is
a Java util concurrent executor it's an
interface that takes a runnable and
depending on what implementation of that
interface you use it Forks off another
thread or pulls a thread out of a thread
pool and causes the run will you be done
by that background thread for you it's a
very useful facility but in order to use
it right now you have to write this
anonymous enter class new runnable
public void run do something and you
have to count your closed curly braces
and your parentheses and your semicolons
which is a little bit of a pain but IDs
help I don't want to throw out those
interfaces I don't want to throw out the
whole concurrency framework it's a very
useful framework it should work
naturally with closures and because of
the closure conversion it does you can
write this this way you can write if you
have an executor X DX dot execute open
paren and then between the parens you
write a closure open curly arrow bunch
of statements close curly in fact you
can even use the control invocation
syntax here if you want to do it this
way now
when the thing that you're doing is not
being done immediately I personally
prefer not to use the syntax I prefer
the syntax with the arrow because if
you're just sort of skimming the code it
kind of looks like this is being done
sure here and now in the context of the
program and it isn't this is something
that's going to be done in another
at some other time but it is possible to
use the syntax and maybe maybe it'll
turn out that when people are aware of
the syntax it won't be it won't be
unnatural to use this for for things
that are running other threads yes so
the question the question is if you have
a return inside the closure does that
mean your function can return twice so
this I think I heard this question
recently and the guise of does this mean
we get continuations for free yes and
the answer is if you invoke if you
execute a return statement for an
invocation of a method that is not
currently executing on the current call
stack you get an exception no it's not
on this current threads call stack it's
on another thread call stack yeah so the
cult yeah so the short answer is no on
the other hand you can use closures
reduce on some of those kinds of things
but not not simply that way so one of
the things Oh
one more example adding a swing listener
this is the sort of thing you do today
item listener is actually a base
interface that's used throughout swings
for things that you can that are that
you can listen to and the way you add
something is you call add item listener
and it takes a item listener which is
another interface that you have to
implement and the method inside is
called item state change and it takes an
item event because there are different
kinds of events and this is what you do
when you want to add a listener and
swing well because of the closure
conversion if you want to do this with
closures this is what you would have to
write a is dot add item listener and you
simply pass it a closure item item if an
e arrow do something with E and I
yes and in this case now is doesn't even
have to be final probably or maybe it
does have to be final it depends on
whether or not you retrofit the
interface to require the restriction yes
question we're going to convert to
either interface with one so the
question is it a little more so the
question is it looks like when we're
doing this conversion we're either going
to go to an interface with one method or
an abstract class with one method the
answer is it only works for if you're
converting to an interface with one
abstract method and the definition of
abstract method is complicated because
you can actually have the same method
with the same signature coming from
multiple places and different return
types but that that's basically it you
cannot use this for classes that have a
single abstract method for technical
reasons having to do with the part of
the specification that I haven't told
you anything about so I'm not going to
not going to tell you why yes
I'm sorry what would you rewrite this
could I rewrite this using the control
abstraction well that's a question that
that's a question that would make me
smile and the reason is when you try and
do that you get this little : before the
closed paren because you have you have
formal parameters but you have no
expressions so you end up with smiley
Smiley's in your code if you do that
sort of thing but yeah you can use the
the control invocation syntax for this
sort of thing but again as I said I
don't prefer that if you're doing if
you're writing a closure that's going to
be executed it and some other time and
some other place I think it's more
natural to use the the closure syntax
rather than the rather than the in lines
at the controlling vocation syntax like
this but you can do it yeah so I promise
to tell you something about some of the
new api's that I think deserve to be
added to the JDK but have sort of been
waiting for a way to express them a
bunch of things in collections
I'll show you remember the for each loop
okay well we already have the for each
loop is a statement but there are things
like the for each loop that that I think
are worth doing that I mentioned the
concurrency with lock I mentioned I
haven't mentioned closable x' but
there's something in c-sharp called with
where it closes something for you
automatically at the end of a block and
that's a very useful facility and
there's a lot of boilerplate in Java
that you have to write because you don't
have anything like that and you could
add a statement form to language in Java
but if you have closures you actually
don't need to add a statement form to
the language because you can do it with
an API and I'll show you how that would
look
I did mention aggregate operations I
gave the specific example of map but
there are many more of those and all
sorts of things from the functional
programming community that I think are
worth adding so
ss4 the collections api it's nice to be
able to iterate over a collection but
there's this other basic interface and
collection that right now there's no way
of iterating over and that is map so if
you want to iterate over a map today you
have to ask for the entries and you
write an iterator that maps over that
that iterates over map entry of well in
this case it would be key come a value
and then inside you probably want to
declare local variables with the right
names so you don't have to say entry key
and entry value which gives you no idea
what how it relates to your business
logic so the idea is I think you should
be able to write a loop that loops over
the entries and a map and here's what I
think the programmer should be able to
write if you have a map from key the
value of some kind you should be able to
write each entry key k so you get to
name your variable in a way that makes
sense in your application value v : map
closed paren and then a block of code or
maybe you don't even need a block of
code if it's only one line you don't
need the curly braces personally I like
the curly braces although maybe that's
just because the style guideline here
tells me that I should put the curly
braces in but here inside you can
operate with local variables K and V no
problem and you can do anything that you
would be able to do in an ordinary for
each loop in return for the enclosing
method you can break it can continue
it's no big deal what is a big deal is
that you can write this as an API that
someone can just put this in the library
you don't need to get a jsr together and
edit the java language specification and
figure out how the rules interact with
all of the other rules in the language
you can just write a method that does
this and you know if if map Java util
map wasn't in the JDK it would be
completely hopeless to get this kind of
language extension but you don't need a
language extension if you have closures
I already mentioned being able to lock
using Java util can
and locks briefly this is a common
problem you open a stream and you want
to do some stuff with a stream and when
you're done you want to make sure it's
closed whether an exception is thrown
you know no matter how you get out of
the block you want to make sure you
close the stream so here's what I think
you ought to be able to write with then
you declare the type of your stream
variable a colon and then here's the
expression that opens the stream and
then you simply have a block of code the
width method is responsible for making
sure that the stream is closed when
you're done and one of the neat things
about the control invocation syntax
because it takes a statement not a block
statement but a statement at the end if
you need to open three or four streams
you can just say with input stream s
expression and then before the close
open curly brace with output stream you
know another expression that opens an
output stream and you can do this both
on the same line so that you only need
one pair of curly braces around the body
and that way at the end of the block
both of your streams are closed in the
reverse order in which they were opened
that's not something that you can do
easily with a with statement and c-sharp
pardon
yes the with the whiff method would have
a try finally block and invoke the
closed method on the stream after
invoking the body of the closure yep
yeah it is I it is I he said
it's odd that you have the open in one
place that is here in the expression and
the closed in another place that's true
but what you can think of is the purpose
of the with statement you're calling the
with statement to do the closed right so
you could think of the with statement as
from the programmers point of view that
is the closed so you actually have the
closed here you're calling utility
method to do it for you but you're doing
the closed here explicitly by calling
with so I mentioned map
here's another related operation this is
reduce and this is reduce operation
takes a list of something in this case
we have an example where we take a list
of integer and a binary operation on
those which is a associative and it sort
of operates pairwise summing up all of
the results in the list and finally
gives you the one unique answer of doing
that operation pairwise of course you
could write this as a loop but one of
the interesting things about having this
operation is if this operation is much
more expensive than simply adding two
instigator then you might want to do
those operations instead of sort of
chomping from the beginning one by one
to the end of the list you might want to
do a pairwise concurrently so maybe you
would have a version of this reduce
operation that takes the same arguments
but also takes an executor from the
java.util concurrent framework it would
take an executor that you can use to
fork off threads in the background and
you could do this concurrently using a
whole bunch of threads but what you
would have to change in the collar here
is you just have to add one extra
parameter that is passed the executor
and as
argument and it would automatically fork
off the bunch of tasks wait for them to
finish and then join them all at the end
and you're done
pardon so the question was if you do
that could you forward exceptions so yes
it would be possible to define the
reduce operation in such a way that the
closure that it receives is allowed to
throw exceptions and those exceptions
are propagated to the caller in fact you
could also make it so that return
statements worked and returned from the
caller if you wanted to make the reduce
operation work that way I'm not sure it
makes sense to do it that way but you
that would be when you're making the API
reduce method you would have to answer
those questions of whether you want
exceptions to be propagated out whether
you want return and break to work and
and you would have to in the
implementation of that reduce operation
that uses concurrency that'd be a
non-trivial amount of work to do to make
sure that the exceptions get shuttled
across and so on but from the
programmers point of view if that's the
way you want it to work it would be very
convenient yeah question these examples
are not yet in the in the draft
specification oh I think that figuring
out what sorts of API is to add is at
least as large a task as doing the core
language extensions and I want to have a
lot of help doing that Doug Lee is
working on some on the fork/join
concurrency framework and that includes
a lot of these like map and reduce
operations yeah and I expect to lean on
him a lot as far as the proposal for
what what those operations should look
like the stuff that makes it
interoperate with the existing classes
you don't have to do anything not very
much there actually is are a few things
that are available to do that you can do
without breaking backwards compatibility
but for the most part I'm focusing on
the language issues and my hope is that
someone will create a jsr for adding mr.
Java and that jsr will be composed of an
expert group and that as expert groups
will contain people who are interested
in various api's within JDK and they'll
brainstorm about what all of these areas
should be but I'm sort of using these
more as examples of whatever I think the
JDK would be likely to go if closures
became were put on the table for JDK 7
so I did mention that Doug Lee is
working on what he calls a fork joint
concurrency framework includes a lot of
these primitives that you see from the
functional programming community I think
there are probably others that are worth
adding there are a lot of things that
people currently do with aspect-oriented
programming that are possible to do not
quite as conveniently or maybe more
conveniently depending on your point of
view with closures for example I showed
you how to do timing operations how to
do locking operations you do logging
operations sort of before and after
various operations if you think of those
as as advice and the aspect-oriented
programming community closures provides
another way of conveniently adding
advice into the source code of your
program and there are some things like
continuations like bounded continuations
that are easier to do in a library
without language changed without VM
changes if you have closures in the
language and my hope is that someone
other than me will explore that in more
detail but I have some ideas along those
lines but again as far as the API is I'm
personally mainly interested in the
language issues and getting a prototype
out for people to try but at the same
time I hope that the prototype will have
a lot of these examples of where what I
think ought to be done to the JDK in the
context of products for people to try
out see what they look like and see what
they feel like to use
because just having a language extension
with no sample code is very hard to
judge you know sort of what you have
some references there's a home page for
this
it's wwg opposite info it used to be my
home page for the Java compiler but I've
repurposed it to the to be the Java
closures home page currently the only
thing that's there is the current
version of the specification but I
expect to have not only history of all
of the versions and specifications but
the rot of the the open issues list and
maybe even a discussion board for people
to comment on it currently most of the
comments on this work appear on other
people's blogs or comments on my blog
because I do tend to write about the
motivation for the changes from one
version of the spec to another so yeah
there's also my blog a after dot blog
spot.com the other people that have been
working on the specification with me
Peter ah hey here's the URL for his blog
blog sun.com
ah hey he's the the the lead of the Java
compiler development at Sun Microsystems
he was one of the implementers of the
wild cards part of the generic type
system that was added in JDK 5
gilad bracha was also participated in in
the specification
he has wrote a couple of blog entries
although he's no longer with Sun
Microsystems so he's less interested in
this stuff he's working on small talk
lately James Gosling worked with us on
some version of the specification I'm
not sure exactly where James sits on
this issue he's written a few things
that can be read either way but it's
some of the things like the the control
invocation syntax came out of ideas that
he
from our discussions with him and
finally there's a there's the courses
Wikipedia definition of closure which in
my opinion sort of supports our position
on what what closures are compared to
the alternatives but that's you know
Wikipedia sort of varies from day to day
and maybe part of the reason it supports
my position is because I contributed to
it so there any other questions Wow okay
yes with the closures you always get
this question of how to produce in
director for beautiful
luckily Scott's variables that's suppose
I get a vote in which I declare a
mutable viable yes
closer he sent the both reckoning closer
that they all took the same or different
so the question was how do closures
interact with mutable local variables do
they all get the same version of the
variable or they'll get their own
version of the variable the answer is if
they're all you know if for example if
it's inside of a loop and the variables
defined inside the loop and the closure
is defined inside the loop you have a
new very you have new vert logically you
have a new variable on each invocation
of the loop and therefore they are each
referring to distinct variable on the
other hand of the variables defined
outside the loop then logically you have
a single instance of the variable that
all of those closures are referring to
in other words closures don't change the
way variables come into and go out of
existence
they just make some of the issues a
little bit more obvious where where the
question you know doesn't doesn't make
sense without closures but essentially
if you're if you think of executing a
variable declaration okay if when you
execute the variable declaration the
variable comes into existence if the
closures are referring to the same
variable that where the declaration was
executed they write the same execution
of that of that declaration then they're
referring to the same variable if the
variable executes if the variable
declaration was executed again in
between those definitions than they're
referring to different variables I hope
that answered your question
I'm sorry
so question is Asia's boxing the list so
the question is in the implementation
you're just boxing a lexical scope right
well it's not quite that simple and the
reason it's not quite that simple is you
take the example of a loop Java does
have loops unlike something like scheme
that doesn't have loops the variables
that are declared inside the loop have a
different lifetime than the variables
declared outside the loop so they cannot
be boxed together you have to box them
separately so you cannot create a single
box or the entire lexical scope yeah but
you do yeah you do end up boxing up the
lexical scope perhaps in multiple boxes
no you can't yeah so so what happens if
yeah so what happens if you're using
closures and you have nested loops and
you're no longer in the inner loop but
you try and break out of the the inner
loop and again if you try and break out
of a loop that's no longer executing on
the cur in the current threads stack
then you get an exception an unmatched
non-local transfer okay and it's it's an
unchecked exception so you have to deal
with that and it's a programming error I
don't know what I don't know what else
to tell you it's a but again you know
the sort of things I don't expect that
you're likely to see concurrent loops
that don't provide explicit support you
know if you have a concurrent looping
construct then I would expect that
breaking out of the loop would terminate
all of the all of the all of the threads
that are executing as part of that loop
before it lets you out if on the other
hand what you're doing is you're working
off threads then hopefully the API won't
even let you return in the first place
and there is a way of defining in the
API in such a way that you can't easily
simply return you can restrict it in the
same way that it's restricted in
anonymous inner classes okay yeah
you should learn them for help
yes yes let's uh yeah so the question is
how do I write a method that receives a
closure so let's see here
so first thing I need to do is
well I can't mirror on to that but okay
so there's WordPad there we go
okay
all right so how about with luck okay
well remember I mentioned there also
there are a bunch of things called
transparency I'm going to start by
ignoring transparency I'm going to arc
exception transparency I'm just gonna
write a simple Whitlock that doesn't
work with exceptions so void with lock
it takes a lock lock and it takes a say
I'm ordinary block of code block we'll
call it oops
yeah block
and inside
we have locked out lock try block invoke
finally lock unlock and and done okay so
that's with lock and I think it's
straightforward right it's sort of
obvious now when you start saying well
what if I want it to be known the
exceptions on the inside are propagated
out it gets a little bit more
complicated so let's suppose you want to
do that
okay well since you don't know what
exception types are going to be thrown
we have to make a type parameter for
that and I'll use X for the exceptions
and now so this block can throw X and
here this can throw X okay right so we
want to say whatever the block can throw
is known to be thrown by this yes thank
you now yes
this is this is WordPad yes okay so now
this is still not quite right and the
reason it's not right is you have to
have an exception okay what if you don't
throw anything right this isn't quite
right so now I'm going to have to need a
little space to fix that so there's a
little change here there this is part of
the specification it's a new kind of
type parameter it can take zero one two
or three or any number of type parameter
of exception types okay and what this
says is however many exception types are
thrown by that block those same
exceptions are thrown by with lock okay
and this is how you get exception
transparency okay now there are other
types of transparency that this doesn't
provide okay so I'll do one more and it
turns out it's the only one that you
actually have to change the code to do
the other one is something called
completion transparency the idea is when
you use synchronized if you have a
return statement inside the synchronized
when the compiler knows that
synchronized block will never fit finish
it won't complain you know oh you forgot
to put a return at the end of your
method it knows that you can't reach the
end of the synchronized key but if you
use with lock and you have a return on
the inside the compiler doesn't know for
sure that you're going to execute that
block and never come back
okay so if that's the case you need to
have some way of expressing that and the
way that works is I'll make a return
type for this method
and we'll return that type here and
instead of returning void I'll return
the type r here and I'll return block
that invoke and you might wonder how
that solves the problem well it seems
obvious this solves another problem
which is what if you have a if what if
you want to avoid the expense of a
return return actually is going to be
implemented under the covers using
exceptions if it's frequently executed
the VM is actually going to inline it
and optimize it into a jump but if it
isn't very frequently executed you're
going to pay a little bit of an expense
for that so this allows you to use a
with lock as an expression and have the
resulting value from the closure be
passed out to the caller and that
sometimes convenient but what's more
important is that is that the the result
type if if you use this in the normal
way where you don't return you just have
some statement the compiler is going to
decide that the result type R is not
void void isn't an object type it's
Kitt's java.lang void it's a new type
that's being added it's just a
placeholder okay it means no no value
and the value is going to be that it's
actually going to return a runtime is
null but if the block does not return
normally if you have a return statement
for example as the body of the block the
compiler is going to infer that the type
of the block is something called
unreachable java.lang unreachable and
unreachable is special to the compiler
the compiler knows that whenever you
have a value of type unreachable in hand
you cannot get there so because the so
when you in when you have this with lock
with a return inside the compiler knows
that the closure returns the type
unreachable and therefore with lock is
going to return type unreachable the
compilers going to say oh a statement
it's a method it's a function it's a try
expression statement whose result type
isn't unreachable I know this cannot
complete normally
and therefore the compiler will not
force you to put statements after that
that with lock so this provides you with
completion transparency and as I said
there are a couple of other types of
transparency but they don't require you
to make changes to the source yes
yes
such as
okay so the question was if you take
another closure will X have the
exception inspect for the other one also
well you can do it any way you want you
can you can declare two throws type
variables one for each one and you can
say throws X comma Y on the with lock
okay that would be one way of doing it
it depends on what you want to express
in your API but if you had if you had
two closures each with an exception and
you know you're going to execute them
both and you want to say I can throw
both of those you would you would use
two separate type parameters throws X
and throws Y and then and then you would
say with luck throws X comma Y yes
yeah the question was I mentioned that
local variables are boxed up that is
they're packaged up into some object
that exists at runtime does that mean
that I can access them after the
enclosing method has finished and the
answer is yes absolutely you can yes
yeah which means you might be sharing
them among threads and now you can
therefore you probably can mark them
volatile and you may have to synchronize
around access to your local variables to
make sure because it's shared state
didn't use to ever be shared State but
now
yes local variables can be shared State
it's generally not a good idea to do
heavily concurrent things using local
variables simply because it's confusing
but yeah it's certainly as possible yes
you had a question yes with a cedar
ectly
what's happening
when I look up the definition of with
luck yeah yes what are they going to
make what are they going to make of this
yes so the question is what about the
the dumb programmer which by the way is
always not the person who's asking this
question runs across a piece of code
that uses with Locke and he says oh I
better go and see what with Locke does
and he comes over he looks at this and
he says oh my gosh yeah left arrow comma
right arrow our throws X throws X throws
X closed paren open curly what the heck
is going on here and if there's no
documentation on this method he's lost
just like he's lost with any method
whose invocation he wants to understand
that has no documentation now admittedly
there's some new syntax here that you're
probably going to want to get used to so
that you can understand code without
having to read the documentation but it
is important if you're if you're writing
these control abstraction ap is that you
expect to use frequently in your code
it's really important to make sure
they're well documented
if you expect these methods are going to
be used very very heavily it's even more
important that they be documented that's
true of any method though if you expect
if you have a method that you expect is
going to be very frequently they have
you have you ever looked at the
signature of collections that's short
yeah do you know what it looks like
it's okay so let me let me tell you what
collections dot sort looks like less
than T uh
extends comparable less than question
super T greater than greater then yeah
so that I don't think as a practical
matter I don't think that anyone is
going to have difficulty with with luck
because hopefully it will hopefully you
know it's obvious what it's supposed to
do and it's obvious what it does yes
Oh
the closure method that you would be
taking here like me so the question is
either proposed changes to Javadoc to
support this I expect Javadoc will
understand the syntax of types that's in
the java language at the time yes yes
yes
but maybe you get another one you for
two minutes you need to say whatever
those two is in your Javadoc yes so
there are a couple of ways of dealing
with that and one of them is you don't I
mean if you need to document if if
describing the the function type is not
enough that is if you can't if you can't
simply say you know a block that might
throw an exception X which is really
what you want to say about this you just
say it's a block of code that can throw
some exception X because it really isn't
there isn't much to say about this about
this block yes
yes right so let me put it this way you
can the documentation that you want to
put on the parameter is very much like
the documentation you want to put on the
method that you would have had an
interface that this had been an
interface yes yes yeah yes yes yeah yeah
so you can you can still express these
using using interfaces if you want and
you can document the interfaces that way
the problem is when you do that then
anyone who's interrupting with this API
has to use that particular interface and
this is one of the reasons why function
types are most useful I would hope that
there would be extensions to Java doc
I'm not doing them as part of the
prototype but I would hope that there
would be extensions of Java doc can do
that on the other hand I also would
expect that it's very rare that you
would have a function type that's very
complicated for most of the time you
would just want to say block you know
can throw is a block that can throw an
exception X that is you don't need to
have extensive documentation about the
about the individual arguments because I
don't think that it's likely that you're
going to have many distinct arguments
even in the case of reduce where it
takes two arguments right and return
something of the same type well first
the three types are the same so all you
want to do is you want to say it's a
binary operation that's associative and
associative and commutative no
communicative well I don't remember no
not commutative no but you want to say
it's a it's a binary operation that's
associative and and I think that's all
you need to say you don't need to say
you know the left argument this and the
right argument that if you really need
to say much more than you certainly
would expect to have some some extension
to Java doc and I don't have I don't
have anything specific to propose but I
hope that if this becomes a jsr that
would be one of the subjects that the
jsr would look very carefully at how do
you do that yeah lifetime of objects are
in the same sensible scope as a closure
but not referred to by the way what's
the lifetime of objects that are in the
same scope of the closure but are not
referred to by the closure the short
answer is you can't tell like this if
you have a very large memories for
example that's of the eMeter yeah so I
mean the point is you want to avoid
preserving objects in memory that can
never be referenced okay and I agree
with that you should avoid preserving
objects a memory that can't be
referenced and it's an implementation
detail how you go about doing that as a
practical matter I can tell you that I'm
not going to the implementation is not
going to box up local variables that are
not accessed inside of closures are just
going to remain local variables I would
have no reason to to make them boxed up
but the the longer answer is you don't
know and you don't care and and it's
none of your business
you know yeah yeah yeah
lexical lot yes local variables are
lexically scoped returns are lexically
scoped breaks and continues are
lexically scoped exception you no
exception machinery is lexically scoped
you know the completion you know the
rules for what statements can complete
normally that's lexically scoped all of
the things in Java that are lexically
scoped interact with closures properly
you know in a language like scheme
closures are really really simple
because there's only one thing that's
lexically scoped and that's variables so
that's why the definition for for
closure says you know variables are
likely you know the variables take their
definition from the enclosing lexical
scope but Java has lots and lots and
lots of lexical so you know it has it
has the method namespace it has the
variable namespace as the meaning of
this it has the meaning of break and
continue and return it has the exception
machinery and then it could on and on
and on there are all these separate
lexically scoped language mechanisms and
in order to have closures really useful
in order to be able to do things like
control abstraction you have to consider
all of them and you have to make sure
they all interact what what I call
properly quote unquote properly in the
way that nonnamous enter class is a
couple of them sort of work properly
sometimes but for the most part none of
them you know none of them really are
fully fully work in the way that they
need to did i mention did I forget the
type namespace as well and the label
namespace that's another one this
there's a lot of them so yeah they you
have to you have to look at all of them
and make sure they all work properly yes
make some specifying of method name
so a method object method
okay yes so the question is I've been
considered some way where I can just say
you know variable method name and have
that method of that variable
automatically can be converted into a
closure or a function type that refers
to the invocation of that method the the
short answer is yes the long answer is
it doesn't actually buy you very much so
we haven't done anything to add it to
the specification but again if that if
that's really it's you know if it's
that's something that jsr could consider
and it would be compared to the rest of
the stuff that I have have to implement
that would be very easy but again it's
it's sort of added mechanism that
doesn't buy you very much
you know normally object identifier is
referring to a variable in the variable
namespace you can tell one namespace the
other by whether or not they're parens
so you have to do some really fun you
have to either add an ampersand operator
so you can tell you're taking the
address of a function or something like
that or some other syntax maybe a pound
sign I don't know what you do but it
would have to be an additional syntax
and once you do that you know what why
didn't you just put an open curly and an
arrow before it right I mean it's really
not that hard to put an open curly arrow
before it and then a close curly after
it because it gives you exactly the same
effect and that's what the compiler has
to do anyway if we provided a shorthand
syntax part yeah you have a different
instance you have to box up the instance
with the method and you have to know to
invoke that method with that instance as
the first argument part
parameter names Miss Brown
yeah if the method has parameters you
have to receive those parameters and
pass them on and again the compiler has
to do that but maybe you don't care what
the compiler has to do you just want it
to work right but yeah you know it's
possible there are some circumstances in
which case that would actually make
things simpler I don't think I don't
think that there are many I don't think
it's I don't think it actually buys you
very much compared to the complexity you
would add to the language but you know
if it turns out to be important then
then I don't feel that strongly about it
okay
so yes you're mapping over some
collection you want to call some method
on the object so why don't you put a
curly open curly brace the object method
open paren close paren semicolon and
you're done it's I mean it's not a yes I
know you know I've seen the sort of
abbreviations you can do in in languages
that allow you to sort of you lie to the
parameter or less that's implicit in the
in the iteration but you're not going to
get that simply by this kind of syntax
that's that's not enough you have to do
a lot more and doing something like that
alone where you turn a method into a
into a into into a function type or a
closure I just don't I don't think it
gets you very far so yes
have you tried have we tried to do
multiple dispatch using this stuff
personally i i i like using visitors
from my vault multiple dispatch that's
too yeah yeah so i don't i'm not sure i
understand how it would help you to have
have me you can build a table and you
can sort of populate the table with with
a bunch of closures and then you have
some algorithm that looks up no that
mean that's that's the sort of api that
you might consider right you have a
multi you have a multi dispatch thing
and you have to fill in the table but
then you sort of then you're doing all
your checking at run your type checking
at run time rather than a compile time
because you have to somehow keep track
of what are the types of the arguments
and what are your overload resolution
rules and what do you do when there's no
best answer and i don't know the answer
to those questions so the short answer
is no we haven't we haven't really
thought about that but that's hopefully
there are lots of examples of api's that
people can start thinking about once you
have closures that you just weren't
practical at all before that people can
try out these ideas and find out if they
really if they allow you to do something
useful or not because I don't know I
don't know maybe there is something that
you can do that would be very handy
actually - uh sorry
so the question is is there actually a
jsr on this is someone planning on
opening up a jsr on this there's a long
answer and I'm afraid a longer answer I
was planning on writing a jsr for this
Sun Microsystems actually asked me to
submit a jsr proposal for this but I
can't do that because I am NOT Google's
JC JC p representative I am and I cannot
do it as an individual contributor to
the Java community process because as a
Google employee I cannot be an
individual contributor to the java
community process Google's a JCP
representative is Joshua Bloch and he
has other ideas about what should be
done in the java language in this space
and as far as I know he has he is not
currently planning on submitting a jsr
on this my hope is that creating a
prototype which by the way I'm doing on
my own time will be something that that
Sun can use to as a justification for
Sun creating a jsr to do this into the
language because I think that's the only
way that this is this is going to happen
in Java at this point yeah
any other questions thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>