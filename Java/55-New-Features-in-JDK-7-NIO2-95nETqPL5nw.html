<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>55 New Features in JDK 7 - NIO2 | Coder Coacher - Coaching Coders</title><meta content="55 New Features in JDK 7 - NIO2 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>55 New Features in JDK 7 - NIO2</b></h2><h5 class="post__date">2012-05-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/95nETqPL5nw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to the 55 new Java 7 features
that you probably didn't hear about this
is the second part in the series that
we're doing here and this part of the
series will focus on the niño 2
features so let's go directly into the
slide it's about 1 minute for each slide
as we move through so sit back enjoy
this for about the next 15 minutes so
why do we need new i/o 2 well prior to
Java SE 7 release the Java IO file class
was a mechanism used for file i/o but it
had a variety of drawbacks first of all
many of the methods didn't throw
exceptions when they failed so it was a
it was impossible to obtain useful error
messages for example a file deletion
failed if a file deletion failed the
program would receive a delete file but
wouldn't know if it was because the file
didn't exist or the user didn't have
permissions or there was some other
problem the rename method didn't work
consistently across all platforms there
was no real support for symbolic links
more support for metadata was desired
things like file permissions file
owner's and other security attributes
accessing file metadata was inefficient
many of the file methods really didn't
scale requesting a large directory
listing over a server could result in
the hang large directories could also
cause memory resource problems resulting
in the denial of service and then
finally it was just not possible to rely
write reliable code that could
recursively walk a file tree and respond
appropriately if there were circular or
symbolic links so do I know two features
one of the key features that you want to
look at when we're looking at new i/o -
well we're looking at helper types and
there are four key new helper types in
Java 7 now from a developer's
perspective the biggest change will be
to replace the use of the file object
with a path object since the file was
not designed to be extended it's not
possible to add functionality so a new
class was required in many places this
can be used exactly the same way but
there were a few there are a few
differences that developers would need
to be aware of to use this correctly now
when we look at these four keys
here we look first at at-at pass now
pass is an interface consistent consists
exclusively of static methods to return
a path by by converting a path string or
a URI then we get down to the path class
well the path class includes various
methods we use to obtain information
about a path access elements of the path
convert the path to other forbs or
extract portions of the path
there's also methods for matching the
path string or methods for removing
redundancies in a path path methods are
sometimes called syntactic operations
because they operate on the path itself
and don't access the file system now the
the the next part so if you're using the
pass you use a path to get a path and
then we use files to do stuff while
files the file class is another primary
entry point and this class really offers
a rich set of static methods for reading
writing and manipulating files and
directories then of course the last one
is a file system and that's a variety of
methods for obtaining information about
the file system itself so examples of
helpers in action well with the new i/o
to the most obvious file system
operations are supported in a complete a
clean and consistent way in Java copy
moving renaming files is all performed
using a path for each part of the
operation now three copy options can
also be specified to copy the attributes
of the file rather than the defaults may
be to replace an existing file if one
already exists at the at the destination
path and to make the move and atomic
operation from the file system
perspective but you can see here in the
examples that you can have some really
fine grained control when you're doing
copies or the atomic operation when a
move is supported here now there's a
variety of features so we have this path
instance representing a file or a
directory but does that file really
exist on the filesystem is readable is
it writable is it executable now a file
class provides a large number of utility
methods for typical file
system operations things like copy
create directories create files create
links use a system tip directory delete
the file where the attributes you know
care let modify it can be modified the
owner permission size things like that
is it read or write a bowl can I set
those type of things
now directories the directory class
provides an iterator that can be used to
read the in trees of a directory now
like prior versions this scales really
well it uses less resources well and it
improves the response time one point of
note here is that the directory streams
provides an iterator it's not possible
to use a directory stream more than once
since there's no way to reset an
iterator additionally there is a whole
set of built-in support for regular
expressions so complex patterns could be
used at for instance in the sample that
you see here the example code here is a
more you can do things like the star dot
Java or you can do more complex
expressions things like a star dot left
squiggly C comma H come a CPP come h PP
come a Java right squiggly now the Java
I knew IO file package and the path
class in particular are now linked aware
so symbolic links are gonna work for
this and this is based on long-standing
UNIX semantics every path method either
detects what to do when a symbolic link
is encountered or provides an option
enabling you to configure the behavior
where the symbolic link is encountered
most of the time the link is treated as
a normal file exception to this include
the delete operations in the walk file
tree which we will discuss a little bit
later the example code snippet here
creates a symbolic link with default
permissions now the file attributes of
our Arg enables you to specify an
initial file attributes that are 7
topically when the link is created
however at this particular point in time
that argument is intended for future use
and it's not currently implemented
little more details of symbolic leaks so
you can't create a hard or irregular
link to an existing file by using the
create links method the second path
argument here locates the existing files
and it must exist or a no such file
exception is thrown to determine whether
a path instance is a Polock leak you
could use the symbolic link method and
then finally you can obtain the target
of a symbolic link by using the read
symbolic link method if the path is not
a symbolic link the method this method
throws a link exception yeah we talked
about walking a file tree so to walk a
file tree first you need to implement a
file visitor and a file visitor
specifies the required behavior and a
key point in the traversal process with
the file I visited before a directory is
accessed after the directory is accessed
with the failure occurs now this
interface has four methods that
correspond to these situations so
pre-visit directory invoked before of
directories entries are visited post
visit directory invoked after the in
teresa two directory are visited if any
errors are in canada the specific
exception is passed in the method visit
file invoked with the file as being
visited the basic file attributes are
passed to the method and you can use a
file after being packaged to read
specific attributes visit file failed
invoked with the file cannot be accessed
the specific action exception is passed
to the method and you can choose whether
to throw the exception print it to the
console or along the file and so on you
don't need to implement all five of the
file visited methods instead of
implementing the interface file visitor
interface you can extend simple file
visitor class in this class which
implemented the file visitor interface
visits all the files of the tree and
throws an i/o err when an error is
encountered you can extend this class
and only override the methods that you
actually require a couple of caveats
here a file 3 is walked depth-first but
you cannot make any assumptions about
the iteration
order that the subdirectories are
visited secondly if your program will be
changing the file system you need to
carefully consider how to implement your
file visitor and then finally you need
to decide whether you want symbolic
links to be followed if you're deleting
it files for example following symbolic
symbolic links might not be advised if
you're copying a file tree you might
want to allow it
by default the walk file tree does not
follow us a bollock link watching the
directory now the Java new i/o file
package provides a file change
notification API called the watch
service API this API enables you to
register a directory or directories with
a watch service and when registering you
tell the service which type of events
you're interested in file creation file
deletion file modification and when the
service detects an event of interest
it's forwarded to the registered process
the registered process has a thread or a
pool of threads dedicated to watching
for any of its it's registered for and
when then event occurs it's handled as
needed one of the new features in i/o to
is custom file systems so to provide
accessibility the file system class
provides an interface to the file system
which can be at any form of a file
storage system a good example of this
would be like the zip file that has that
could be accessed as if it were a file
system even though it is itself a file
system on another file system the
attribute package provides an enhanced
access to metadata for files it also
solves a long-standing performance
problem namely that every request for an
attribute results in two separate stat
calls now there are two steps for this
first you want to implement the Java do
IO file dot SPI file system provider
that's gonna handle your URI your
caching your file handling and then
secondly you want to implement the the
Java new il file filesystem that's that
whole access about routes read/write
access file stores etc
file system provider for zip ajar
archives so this is obviously the
implementation of a custom file system
that was done here so we know that the
the implementation actually works here
the zip file system provider it's
reduced in the Java 7 release is the
implementation of a custom file system
provider the zip file system treats a
zip or a jar file as a file system it
provides the ability to manipulate the
contents of the file the zip file system
provide provider creates multiple file
systems one system for each zip or jar
file the example code demonstrates
copying a file into a zip file finally
when it comes down to using these we can
take a look at the mapping of Java IO
file to Java in Ohio file now there is
no one to one correspondence between the
two api's but following the table of
these next two slides will give it your
normal idea of the functionality of that
in the java io file API maps to the Java
you know why files so we can see simple
if we're using it if previously were you
were using jong-il file we want to use
Java and IO path so files could be read
files could read could write can execute
we want to use files is readable files
is writable files as executable files
history files as file file is file dot
length changes to its directory we will
pass the path in here in this particular
case last modified set last modified
again will we'll get the modified time
or the last modified time we're gonna be
passing in a path here as well file
methods like said executable set
readable set read-only set writable we
have the files methods set attribute
path string link option and then finally
new file parrot new file instead we're
just going to do parent dot resolve new
file continuing on to the next page here
file this is where it gets a little
simpler file stop rename to file stop
move
miles not delete files stop delete file
create new file create file delete on
exit well this one's a little different
we can do a delete a close option to the
create file file exists file exists or
file does not exist files dot compare to
it equals path compare to this is where
we'll start using path here path not
absolute value path the real path or
normalize that is it hidden files not
hidden file dot bake directory this is
where we're going to want to do path dot
create directory and file dot list
routes file dot system root directories
now that just kind of wraps up what we
wanted to do with it I know to today if
you want more information about it IO to
go to the open JDK
n io project website on java.net this
will include resources for additional
things that we didn't cover here like
multi casting asynchronous IO creating
your own file system implementations and
then also there's a file IO tutorial
which is available on the o TN network
and then also if you want to listen to
what Alan Bateman who is a project lead
for new IO to has to say the java
spotlight podcast for episode 59 now as
we move on to the next version of the
installation of the 55 new things in
java 7 we'll take a look at concurrency</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>