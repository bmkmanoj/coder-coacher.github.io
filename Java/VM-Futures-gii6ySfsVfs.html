<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>VM Futures | Coder Coacher - Coaching Coders</title><meta content="VM Futures - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>VM Futures</b></h2><h5 class="post__date">2016-08-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gii6ySfsVfs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello I'm John Rose jvm architect and
this is my favorite professional time of
the year to be together with you folks
and exchanging notes and figuring out
where the jvm and the language is on top
of it are going and I think all the
interesting stuff is being said by other
folks about project Valhalla project
Panama I'm going to fill in a bunch of
stuff that maybe is worth talking about
also and i'll make some generalizations
about where i think though the jvm is
going and how we think we might get
there but I just want to acknowledge the
the great speakers so far and I'm
looking forward to the ones that are
coming because that's the real need of
this conference but i hope i will give
you some inspiration and maybe some
crazy ideas along with me i have 45
slides in 45 minutes and the slides are
not your mark reinholds end slides where
there's just a picture i wish i could do
that but what I like to do is is pack my
slides until I'm full and everything in
my ideas are spilling out in my brains
and then I say well of course I won't
get to all this but at least I'll post
my slides and then we'll have a capture
of what the I what the world looked like
at that point so here we go again you've
seen it before I think I I want to say
that this is a special kind of crystal
ball that works only for geeks and not
for marketers or lawyers but that's okay
we're all down with that last year last
year I gave a talk on where we think the
vm will be after 20 years in another 20
years so now we're at 19 and counting
and I want to I want to replay those
goals basically verbatim so we can
compare with with what we're doing right
now at the moment there should be a
uniform model that in other words our
models should be getting more and more
uniform not more and more discreet and
with more sidecars and add-on
we want we want primitives and objects
and arrays and values to look more and
more similar to each other so we can use
the same high leverage plays for for all
of them at the same time we want
efficient data layouts we want efficient
code we want it to be both shared and
customized if we can pull that off
that's kind of difficult but you know
it's possible if you if you pay
attention we want something that is post
what I call dinosaur threads I'll talk
more about that later but we want very
good right size granular concurrency
which generally means one or two
variables and var handles are a great
move in that direction since since last
year in the year before we want we want
our JVM to be interoperable with a wide
variety of other system components
including languages that are running
beside the JVM and not just on top of it
we want it to be useful for those
languages that run on top we want lots
of really cool languages like Scala and
Clojure and so forth to run on top of
the of the JVM excuse me and rather
uniquely for Java we want it to run 30
year old or at that point forty year old
dusty decks for how many of you know
what a dusty deck is okay it actually
refers to the ancient practice of
encoding software in in cards of paper
and where you punch holes in them and
that a deck of these cards has your
program on it and it becomes dusty after
a while and you still want to run it
through the card reader well we have a
jar reader and we want to be able to
read virtually dusty jars and of course
it has to be performant and the fun
thing the thing really one of the things
that really makes the job of JVM
engineer interesting is the hardware is
always changing underneath you our JVM
is more slowly changing than the
hardware or over which it runs which
means that we are always getting the
latest chips and in trying to figure out
how to do the trick again on the new
chip it's really a blast actually
alright here's my my one diagram here's
here's a methodology for trend capture
I'm in the wrong room to say stuff like
that but it really amounts to looking at
the trajectory of where you came from
since one dot 0 and what your current
slope of your curve is in a very highly
multi-dimensional space and trying to
guess where that's going next and of
course the dotted line shows that you
have no hope of guessing exactly right
but I'm still going to guess and we're
going to we're going to think about it
together so you're some trends the jvm i
predict will continue to emphasize
predictability which includes
reliability and security we don't want
to give our users surprises we want to
be the jvm people run on when they want
to know that their their their jobs are
going to get delivered we want
deterministic GCS as as Bernard hinted
at we want to manage ability which means
ever more ways of looking under the hood
and seeing what's going on with your
software system especially as it becomes
more and more magic sorry we want we
want the ability to monitor and manage
the the intricacies of how this how the
system is working especially when it's
compiling and recompiling and we have
various pieces there we want to do more
another independent trend is scaling and
density we want those terabyte keeps we
also want to be able to do tiny micro
services may be running a few of them in
a JVM or maybe a million of them in a
JVM but independently we want to be able
to scale using sharing tricks we want to
start up fast this is this is where
we're going this is what we're working
on I'm predicting that immutability will
become more and more important and for
reasons that we've already heard today I
totally agree with those we want a vm
that will continue to be polyglot that
will interoperate with unmanaged
languages implement well-managed
languages maybe in the next stuff in the
next decade or so we'll see see programs
or C++ programs running in managed
mode on top of the JVM I wouldn't be
surprised here's another one that's less
obvious I predict and I think what we're
aiming towards is more layered
implementations where instead of have a
big wad of C++ and then a bytecode
interpreter on top you have various
factored layers there's maybe lower low
layers of C++ mid layers of low-level
Java specially compiled aot java java
components this is this is what i would
call java on Java which is I think a
very important area of inflection to
move the the technology forward on and
braless is one of the one of the leading
indicators of this in general we want
strong layered abstraction where you can
really reason about each abstraction
without peeking underneath the hood and
yet have the the system drill through
them in order to optimize its what
everybody wants one of the one of the
evidences of this that's already exists
is the the Indy macro instruction which
is it's a it's a it's a it's a way of
layering the sort of in a fat area of
the bytecode it's a bytecode instruction
but it's a bytecode instruction that
like a macro expands to many more by
code instructions so it provides not
just a narrow line between c++ and
bytecode but a way for bytecode to edit
itself and we want to see more of that
stuff moving on these are my predictions
now let me give you some big ideas that
implement these predictions and in a
promising way interoperability let's
make native code and data look more like
managed code and data this is uh this is
what one of many unifying or heal the
rift or talking over the cracks i think
is how bryan said it where we take
things that didn't look like each other
before so they had to be managed with
separate tactics and we make them be
more like each other okay sorry how do
we heal the rift between managed and
unmanaged data there's going to be a lot
of talks on wednesday about this for
project panama we have we think we have
some good ideas it's basically up
leveling and adding
there's that there's that theme adding
layering to unsafe so there are safe
ways to use pointers which can point
both on and off heat which is a designed
in characteristic of unsafe from the
beginning this interoperability depends
there's alway dependencies between these
big ideas depends partly on value types
you want value types to represent
platform types that aren't in the Javas
repertoire primitives you want to use it
to you want parametric polymorphism to
deal with things like foreign arrays you
also need some sort of bridging
technology to bridge through special
abis to non java methods this kind of
interoperability when it wins gives you
a tighter coupling and a more virtuous
cycle with a wider range of data types
not just the ones defined on the Java
heat but off heap numeric types various
kinds of bulk data it gives you better
better access to see api's that haven't
been retranslated into java yet and
maybe never will be you want to be able
to sometimes call Lib C type functions
you want to interestingly and this goes
with the trend towards more and more
exotic kinds of hardware you want to get
to the latest instruction set
instructions from your ISA we think one
of the one of the ways one of the new
ways to get to things like AVX or 80 x
512 is to make them intrinsic sat the
java level and have a bunch all the way
through using snippets and vladimir
we'll talk about that later so in the
interests of speed I'm just going to
continue but I want to give you a good
picture this is coming to a towel near
you the theme of platform
interoperability shows up partly in the
hammer of density and the shield of flat
data they want one of the reasons we
want to go off heap is so we can control
the the storage layouts more more
tightly okay here's another big idea
java on java what do i mean by that i
mean implementing the java engine the
java execution
environment using Java so Java is
implemented on top of itself so it's a
meta circular move it it heals the rift
between having to code in C++ and Java
at the same time it lets you use one
high leverage point the Java compiler in
the Java jet and the Java type system to
manage more of the important parts of
your system it depends partly on on
native interconnection which was talked
about earlier but which might be called
project Panama and it also depends on
being able to integrate Java components
more tightly into hot spot without
having hot spot to go into infinite
regress trying to manage itself depends
partly on flat data in particular Jets
have these tenant a tendency to make
very huge spikes up to up to the
gigabyte scale of temporary IR and those
huge spikes are limited in part by the
density quality of the data structures
that that are in those spikes so once
again flat data is shows up as an
important goal in any case that Java on
Java which I hope it in the open JDK
community we can begin exploring
together this year using growl as a as a
vehicle it reduces all kinds of costs
it's a and it lets us take more control
over our own destiny the current
practice of Java and Java exists is this
is a vector that has some basis in
reality the whole JDK is written in Java
after all there are some some languages
where lots of the runtime is written in
some other language that's not the case
for for Java much of the libraries are
written in Java and the method handle
runtime for example is written in this
low-level sort of self generating Java
and the aot compiler is written in Java
and can produce produce machine code so
and then further experiments of Java and
Java are brawl is the obvious one also
something called substrate the M which
we've heard about in previous years
which is sort of a way to shrink wrap
applications down into smaller
smaller envelopes than Java applications
and something called that was invented
exactly one year ago in an after party
for this conference the beef roast beef
roast interpreter the beef o beef roast
bridge is the Rainbow Bridge to Valhalla
and we want to do some of our later
prototyping using a meta circular
bytecode interpreter which Brian gets
put together uncontrollably inspired
after last last year's meeting by the
way I'm coming to a town near you here's
the grawl reference that's that's what
that thing is you'll see it on your
towel it's right next to Valhalla
alright what else and post threading
that's what i call it I threads our
dinosaurs threads have attracted
features so to the point where a thread
is that the committee that designed
threads hardware software and Java that
committee would the names would fill a
phone book it's just a huge number of
different ideas all along together
there's no way you can take that and
virtualize it and make it small again so
we need something smaller than threads
and we've been talking about this i
Charlie ran a yo a workshop years ago
when we were gathering fiber
requirements we're still thinking about
it I want to present a few ideas but
basically we need to not virtualize them
and shrink them we need to work around
dinosaur threads we need to leave the
fossiliferous parts behind so that you
throw the working title for that is
fibers and it depends on some very
tricky cuts in the JVM interpreter and
yet but the the meta circular
interpreter is helping us do those do
those experiments those early
experiments and of course lots of
library work which we had a great talk
two years ago on this which helped spur
some of this work today okay another big
idea value types that's already been
covered but I got to say a few things
about it right so this is caulking the
seam it depends on here's the important
dependency and here's a reason why
you're looking you're seeing
so much talk about parameterize types
and any tight and specialization when we
thought we were talking about values and
the reason for that is there is a really
strong dependency if we want if we want
to do value types we need to know how to
parameterize over them if we're going to
parameterize over them we we actually
need to do most of the work just to
parameterize over primitives so it turns
out there's a very natural initial
delivery point of doing parameterization
before you do full values if you can
parameterize an array list of int you
are most of the way to parameterizing an
array list of unsigned or complex or
point or whatever and also prob so
that's that's why that's why we we talk
so much about parametric polymorphism
it's not because we forgot we were doing
values but that depends in turn on on
template like classes and I when I say
template I want you to think C++ but I
don't want you to think of something
that's that's statically expanded we
have to do things with the the JVM
especially flexible mix of static and
dynamic so okay so that depends that
requires deep cuts again to the JVM code
and data model we need to be able to
model these strange class files that
expand to multiple species this this is
a quick this is a huge big this is a big
ticket item this is why it hasn't been
done by somebody in you know in their
garage already 20 years ago it's just
hard to do but we're pushing on it this
time we're going to get it done what a
value types enable huge changes
throughout the stack I almost think of
this as the Francis Fukuyama end of
history for java this is that this is
the last big thing that Java needs in my
opinion is the unification of primitives
and reference and objects but with
everything looking like a class and
adding in user-defined primitives yeah I
mean tight tight based encapsulation is
really cool right private being able to
mark things private and have them be hid
encapsulated and have people ignorant
what's behind them have interfaces where
there's zero leakage about what's
underneath we should be able to do that
with values too that's going to make a
huge huge difference there's Valhalla at
the top of the Rainbow Bridge okay so
let me say a little bit more about
parametric polymorphism by parametric I
merely mean to suggest that the
parameter can vary more freely than ever
before the type parameter used to be
bound under object it has to be a
reference and now it can be any any de
notable type which is wonderful it maybe
even non two notable ones wouldn't that
be interesting so it fundamentally lets
you make generalizations for any t
here's what you can do with those teas
oh and you can assume that the tea is
comparable oh that means I can do sorted
algorithms on them that's very cool I
can do all sorts of things like that it
depends as I said on templates something
like C++ templates and it's dependent
upon by any number of different things
in other words this is another reason
parametric polymorphism breaks off as an
early deliverable before the full world
of values is there's a lot of stuff you
can do with it just by itself such as
new array types you can't express new
array types as interfaces until you have
the right kind of polymorphism or
foreign pointers for that matter it's
hard because primitives are totally
different in fact they have different
numbers of slots as Brian pointed out
that's something we've got to fix along
the way it's pretty II that if that's a
small thing you need to fix before you
get to the big stuff you know we're
talking about a multi-year project here
this has already been covered so I'm
just going to say that the interesting
solutions to this involve moves like
fixing the 12 slot thing so making the
data model more uniform as a preparatory
move or for example figuring out a way
to bind an interface to a primitive so
or and eventually to a value so that you
can
not only parameterize over over at
primitive types but actually say things
about what those primitives can do once
you've parameterised over them I don't
even want to talk about equality today
but that's suffice it to say you could
talk for a whole day on equality and
still be scratching your head and we've
been there haven't we yeah all right
what what does it do for you parametric
polymorphism well once you have a way of
talking about any type as a type
variable then more things have methods
more things have interfaces more things
can be can you can create generic
algorithms on them and maybe it's not so
new for those of us who code with C++
templates but it's some it's it'll have
its own flavor in the Java world because
there'll be a lot more dynamis itti in
the with it with the java it turns out
that we have to reinvent some of the
different levels of equality that that
Lisp that Common Lisp add from the 80s
there's the pointer equality there's the
structural equality and then there's the
algorithmic equality those are all three
different things structural equality
means that my little struct has the same
bits as this same typed other struct
that's eqv we have to have something
like that it turns out you're like
forced to invent it for Java and then of
course the big one is the template
templated classes we need we need to be
able to have these templated classes
move their layouts as you put different
types in for the type parameters so that
this field might be 64 bits here or 128
bits here or might be 0 bits in an
extreme case the same class different
species we think we have models to do
this semi dynamically which is extremely
exciting and here's a here's a dangerous
opportunity that falls out there's focus
folklore that the Chinese characters for
crisis is dangerous opportunity and I
was going to hit that hard but it turns
out that's false but in any case this
I'm going to say it anyway it's probably
a danger
opportunity that if you're going to if
you're going to generalize over a type
variable that say can you can add the
instances together to collect them into
a sum or multiply them to collect them
into a product well maybe you got
something like operator overloading
going on what could that mean could it
be possible in this framework to have
pluses and minuses be bound through
interfaces to big integer as well as
integer and long and the answer is
probably yes do we want to go that far I
don't know we're feeling our way in the
dark eventually we'll grab a razor blade
and then back off but we're trying for
it so we get template classes and then
what a class is as Brian put so well a
unit of source code and it's also a unit
of abstraction but then when you fill in
that the type parameters the holes in
the class then you get a species so what
are we talking about we're talking about
polymorphism of the constants in the
constant pool we're allowing a constable
contain holes and then when you fill
that hole then you get a species which
is one of a controlled population of
instances of that class I don't mean
instance in the object sense i'm in
instance in the type sense so we use
species instead of instance when we talk
about it so but what else might a hobie
I mean that's that that takes us to a
template model in the vm which may
supply other interesting features that
haven't been figured out at the language
level yet what if a constant pool hole
is a hole for a string or more
interesting ly a method handle or maybe
just an integer maybe it's maybe it's
the dimension of a fused array inside
the object in which case you're starting
to build tuples and algorithms and you
know you're doing some of the same
tricks you do in C++ with function
arguments to templates or array
dimension arguments to templates how
many of you have used those sorts of
template tax yeah it's pretty powerful
stuff isn't it yeah I think we can do
that and better with this stuff
Constance might and then this this would
be just stretching and being crazy but
what if a constant could be
tuple descriptor where the one constant
describes n types and then somehow you
link that through to n fields of those
successive types you've just got one
class that represents all tuples we can
pull that trick I think I mean there's
there's some possibilities here when
once you sort of double down on the
concept of a constant pool with holes in
it yeah maybe maybe this is a way to to
combine with Paul Santos's trick that
was already referred to of having many
sort of duplicate field variables and
then overlay a local array on that
that's a very powerful data structure
which C programmers take for granted and
we can't use yet because we don't have
fused in line to raise yet all right so
I've already used up almost all my time
to talk about the big ideas let me throw
some really smaller ones and when I say
smaller maybe it's just because they're
farther away on the horizon so they look
small you know Everest looks small from
a certain perspective but here we go
stack introspection we've got some
interesting experiments going on that
length polymorphism is an idea which i
think is of interest i'll explain that
in a second bootstrap methods everywhere
that's that's a whole talk all by itself
but it's fun because there's a lot of
places you can put bootstrap methods to
intro to sort of make programmer will
some of the built-in behaviors of the vm
especially linkage behaviors and i want
to talk a little bit about immutability
but it was well covered already so i'm
going to skip over that real fast i want
to say that the design of all these
things it looks like just grabbing one
interesting idea after another and it
feels like that sometimes but what's
really going on or has to go on is
something like assembling a Chinese
puzzle which looks like a piece of
disordered irregular pieces at first and
even while you're putting it together it
looks like remember how the death star
looked when it was half assembled it you
know you don't really know what it's
going to look like and it looks kind of
irregular in the end it should look
simple and people just say of course you
should have done that way what took you
so long but what in the process you and
I know you have to
put each piece and try it up in four
different places and finally it clicks
in somewhere and then you put in the
next piece and sometimes you have to do
three at once you know with its Chinese
puzzles you like cold three pieces
together before you put with the fourth
one and it's like that with with
language design and with VM design the
only reason vm design is slightly easier
than language design is because there
aren't as many people throwing their
opinions at you there's like two orders
of magnitude fewer people who care about
VMs that care about languages probably
three orders so I like my job you can
have yours Brian all right stack
reification let's walk live stack frames
let's not just let's stop parsing
strings out of stack frame elements
let's get live classes assuming we have
a certain permission to do so let's not
stop with that let's let's grab the rest
of what's in the stack frame let's let's
see which method it is let's see what
the bc i was let's start looking at the
local variables once we once we can pull
out the full state of a of a stack we
can then perhaps do tricks like point a
meta circular interpreter at it and run
an our way the rest of the computation
let's edit the stack let's replace those
ongoing computation with the computation
running our way there's lots of use
cases for this you could dismount a
blocking khalas this press is like this
is your preview of fibers but dismount a
blocking call from a thread kick the
thread over the next fiber and keep the
fiber with the blocking call and then
later on come back to the fiber when the
call is ready generator co routines now
you basically say ok this piece is the
generator I'm going to Reese pin it as a
as a heat based data structure is going
to push stuff this is this is what is
what net does really well with their
right with their async stuff replace a
serial algorithm by a parallel one what
if you start running something cereal
and then you notice it's taking a while
and you realize your data set is growing
too large proportions let's just replace
the computation by the fork joint
version
alright so interesting idea right pardon
me fighting off a cold let's talk about
length polymorphism what does that mean
what I mean by that is a a single class
that has different instances of
different lengths okay and what all that
really means is fused arrays here's a
poster child the string object string
object has a sub object which is an
array of bytes or an array of cares and
that by itself just the extra
indirection costs if you count it all up
16 to 24 bytes that's a lot actually
that means that the amount of storage
space we we save by moving from a care
to a bite representation which we do in
jdk 9 and is really cool we can say that
much and more for Strings less than 24
in length by removing that extra in
direction also by fusing the objects but
in order to do that you need variable
length strings that's hard but there's
some pieces that we know how then we
know we need to do and there's a
generalization of that to look you can
do be trees instead of red black trees
if you have private or raised but it it
requires the number of things it
requires that hidden array to be proxied
so that you could actually run be a load
instructions against it and have it have
the vm not explode because there's not a
real array there so that's more like a
race to do isn't it it requires some GC
cooperation to have the variable length
objects and this is the most interesting
one of all it requires a deep
refactoring of our stupid sorry new
invoke special dance gah which is like a
security problem and it's a it's the
worst part of the verifier and it's what
let's get rid of it and use factory
methods instead of new invoke in it if
we have factory methods in the factory
method is responsible for allocating the
object he can tell from the constructor
arguments how big it's supposed to be he
can create the instance and that's
what's that's what it takes to get fuse
two strings and the other kind of hybrid
objects
and why not have more than one array /
object because you can do it we're doing
the hot spot today and C++ all right
whoa what happened to my slide that's
really weird ok I want to talk about
bootstrap methods everywhere I want to
double down on the SMS I want to use
them wherever the JVM already has some
sort of a non-trivial hook for
resolution and here here are some cases
I want to when it when I do an L duck
LDC of a constant I want I want to hook
there when I invoke when I resolve a
constant method ref in my constant pool
I want to hook there when I do a check
cashed or a type query maybe I want to
hook there although that's a that's a
more terrifying thing so this leads me
to and this is where my slides are
getting backwards but this leads me to
three items constants bridge ematic duck
typing ready for the fast presentation
first of all what's in a constant well
primitives strings classes API points
indian method handles for Valhalla so
the things that Brian was showing but
maybe also we want constants which are
arrays a constant array that would be
pretty good right it's probably time for
a constant array in our system list sets
maps of course value types why can't you
have a constant Enuma in your in your
constant pool answer well no really good
reason just have gotten around to it and
various other types what about a
constant that's a dsl snippet a snippet
of intermediate code that some that
compilers put in but it's not time to
render to bytecode just yet but you want
to render it like three times or you
know a bunch of times wow we could
really do we could really use that
couldn't we how about a semi constants
which are templates in a different term
in a different sense of the word
template things that are factories of
partially constant partially
non-constant structure so like a string
which we have in jdk 9 we have we have a
templating mechanism for for string
concatenation
the last sub bullet items there are
shamelessly stolen from some of brians
dreams about what Constance might look
like and of course it's um it won't look
like that in the end because it never
does but in any case maybe you could do
some sort of a constant list or constant
string that has interpolation points in
it the important thing is a constants
have to be not externally mutable you
may not change them otherwise they're
not constants and that you're you
probably made a mistake putting them in
the constant pool we don't stop you from
doing that right now with anonymous
classes but it's like I said earlier
it's a party foul and they also we want
them to be materialized lazily like
string so what's here's a future proof
design in my opinion there should only
be a few new types not one for each
constant like there shouldn't be a
constantly new no thank you that's a
that would be a code smell should be
programmable using be SMS should allow
various clever factory schemes and
coding schemes it should allow you
should have a sort of a small fixed
overhead should allow delivery of large
amounts of constant payload without lots
of a wrapper around it should work
clearly for the kind of use cases we're
talking about so three new constant pool
types one constant dynamic don't you
just love it it just captures the static
dynamic angst yin-yang of the JVM so a
constant dynamic would have two subparts
a type and a bootstrap specifier which
further consists of a bootstrap method
and an optional vector of arguments
which are further constants so these
things can recurse it's resolved by
executing the bootstrap method slightly
different signature than the one you're
used to today it doesn't return a call
site it returns the constant right so
it's not a meta factory it's a factory
no point of linguistics there but
basically the same rules as indie for
dealing with all the edge cases constant
group is numbered number two there's
there's a narrative limit of 200
54 or something like that for bootstrap
methods just because of the way methods
are set up so pass a list oh my gosh oh
wait we don't have a list yes now we do
constant group is a very long list of
you got it more constants and if we're
clever we can nest them in such a way so
there'll be an efficient envelope for
AST like structures we have group of
group of group like a list best
expression and finally for the bits
constant bites up to say two gigabytes
does that sound like enough for
everybody and you can have more of them
if you if you need to have larger
payloads but basically this is where
your primitive arrays get their bits
from what's the format well it's up to
the factory and the static compiler to
agree maybe it's gzipped maybe it's just
a data input I don't know all right
application to erase should be obvious
I'm just going to skip over this slide
because I'm at a time the important
thing here though is that if you're
going to constant arrays on like
constant lists you need a new way to
make a raise frozen so frozen arrays are
sort of a side dependency of this whole
scheme that's what makes it worthwhile
an alternative is to not not expose
arrays but expose some other interface
that's backed by a non mutable thingy
alright Bridge o matic that's easier to
describe than the constants what a
bridge is do what we know at bridges do
so I'm skipping this slide let's allow a
method to have its own bootstrap method
it doesn't have bike codes it has a
bootstrap method what does a bootstrap
method refer to well maybe it has a
static constant that has some dsl in it
or maybe it's just a pointer to another
method saying adapt me maybe there's
hints on how to adapt it may be as type
is all you need that's all it is so the
method is resolved on first execution
bsm execute returns in this case a
method handle that's all you need it
could be a call site I don't know it
returns a method handle and that becomes
the behavior of that method as linked is
trivia question what kind of method has
no byte codes but is executable
yep well maybe what we're looking for is
act native plus act bridge that wouldn't
be the worst thing in the world okay
what would you use it for well existing
bridges bridging becomes a very
open-ended concept what can you bridge
to well you bridge to the future you
bridge to a native API you can bridge to
a some Panama thing you can bridge to a
piece of DSL here's another idea maybe
maybe the maybe the bridge logic is
triggered not just for one particular
type and name name and type descriptor
but the name and any type it wouldn't
that be cool now we're beginning to talk
about duck typing maybe there's name
polymorphism maybe there's a backup auto
bridger on a class that will take any
unrecognized method and now we're back
to the original invoke dynamical this
these are all the variations on the
theme of bridge o matic and finally for
duck typing it's more bridge o matic
more more of the time basically you you
equip an interface with a bsm that says
if i'm calling through this interface
you don't require a preexisting subtype
super type relationship with the
receiver you just look at the receiver
and if it's a class you haven't looked
at yet you run a bsm and do the matchup
and if you can match point to point then
my interface will complete that call to
that object there's some serious
questions of where you put that
information whether you use a proxy or
you can somehow retro actively change
the class which makes some of us run
screaming including me on a lucid day in
any case the bsm makes all the matching
decisions so at that point you could
have multiple grades and types and and
opinions about what duck typing really
means it's all up to the bsm and so okay
the downside of all of this is your
compiler has to be smart with this this
is a problem we need what we need is a
way for the
the bootstrap methods which especially
as we put them in more and more places
to run in a predictable manner we want
to be able to run to have j-link spring
bootstrap methods optionally just as we
want jailing to be able to run framework
code injections optionally so that we
can seal down the module get the code
and share it and not have it d optimize
the first time you use it so there the
downside of all this BS m stuff which
cleverly we've already introduced as
technical debt is is that we have to
figure out what these bootstrap methods
do statically and in fact that's how
some of the java platforms already
implement JDK 8 in debased lambdas they
simulate the lambda meta factory at in
the compile time but just by special
pleading we need to do better than that
but we have to start with special
pleading all right so immutability like
i said i get to skip over this because
it was already really treated really
well you can read the slides I think
that it would have been cool if java had
had final be the default and non final
be the the thing you had to call for
it's as if it's as if you had a version
of Java where static is the default and
you have to say non-static everywhere in
order to get the good code that's kind
of how final is so what can you do I
don't know oh you we have some ideas but
we're not ready to wait it's probably an
intractable problem in any case
immutability even if you have to code
extra for it is important frozen arrays
are something we need I think we need
boxes that really work we need immutable
final methods that really are immutable
and can't be reem uted bye-bye clever
serialization required set accessible
true hacks we need probably need frozen
objects although that's debatable object
that was originally mutable make it
frozen for shareability there's some
stuff with identity which i won't go
into but the key problem with identity
is
here's coming to a towel near you these
strong box the box which which has too
much of its own identity and semantics
and you need to track some people
actually synchronize on strings and in
turn strings and in turn to integers is
just horrific but so what we basically
need to say okay there's a new kind of
box which is the light lightweight box
that you can't synchronize on and you're
not you're not going to be able to
capture the identity of I'm not going to
talk about monotonicity because I'm at a
time but that's the sort of next step
beyond immutability it's sort of it's
the generalization but one thing that
I'd like to figure out in the next year
or so is how to do lazy variables right
in the JVM so that it's either it's it's
something as a civilized version of what
we do internally that's called stable
variables it's either uninitialized or
it's initialized once and the compiler
can rely on that I think that's a good
that's it that's a little piece that we
need to add to the to the ecosystem more
vectors but I'm going to I'm going to
leave that behind just a few things
about fibers we want our threads to work
for us we don't want them to move in
with us when we're when we're done with
the with the with a thread doing
whatever it does it carries a
computation fine oh yeah it's going to
carry a bunch of a whole AVX vector file
and there the other ten kilobits of
intel / cpu state fine but all I wanted
to do was this one little thing and then
move on to something else I want to be
able to have that that fiber tail call
some other fiber and not not have to
make a new thread to do the new thing
there's lots of things you can do with
fibers here are some possibilities and a
final final bit yeah there's nothing
nothing really new on this slide that
you haven't seen before a final bid is
the is the again the meta Circulo
interpreter the beef beef roast is the
name of the of the bridge to the Rainbow
Bridge to valve Valhalla and so exactly
one year ago after this very meeting we
were drinking beers as I recall and we
realized that it was time
to build a meta circular interpreter for
bike codes and Brian got very excited
and he had a he had a whole plane trip
to think about it and when he got when
he got home he couldn't stop himself and
he went and coded it up and it's
actually there in the Valhalla
repository it's really cool to play with
so I think one of the things we want to
do with this interpreter is is fiber
eyes it take the take the frames at the
interpreter builds and reify them and
and work with them with it with an API
that decouples the computation from the
current thread it's sort of the bsm
trick again the interpreter is like a
bootstrap method around your bike codes
to do something non-standard with them
do you see a trend here we're also going
to use it to hack the meaning of the new
byte codes probably it's all hard but
it's fun I want to say that there's a
couple other projects one in Oracle labs
called truffle and one I don't know who
hosts it called pi pi which is again one
of these met these meta circular
interpreters I think it's a good idea
and it's time for OpenJDK to play in
this space and one last towel preview
there's the there's the beef roast
bridge it's even marked properly with it
with an excess bit all right so that's
that's all I got for you are you ready
for a break</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>