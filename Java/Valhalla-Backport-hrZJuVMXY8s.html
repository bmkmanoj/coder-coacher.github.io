<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Valhalla Backport | Coder Coacher - Coaching Coders</title><meta content="Valhalla Backport - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Valhalla Backport</b></h2><h5 class="post__date">2016-08-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hrZJuVMXY8s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everybody I don't know if you can see
ok so today we will talk about another
backport it's another back part for me
because i have already right back part
of 292 feature and mrs. would join work
with Jefferson here basically do the
artwork add work and I just put my name
on it it's not valhalla backport it's
more specialization back pot at that
time which means that we don't report
any value type things only the
specialization basically only the
specialization of primitive types means
so the journey is to come from air and
to be able to go to Valhalla I know that
you are asking yourself a question why
trying to back back bought something
that doesn't exist which is a nice
question I think part of the answer is
Brian should not have all the fun the
other one is as I said I have tried to
implement a back part of 292 and it was
a good good way to try to understand our
invoke dynamic here at work so what we
up with the back part of Valhalla is to
be able to gain the same kind of
what we can do what we cannot do
basically the idea of if you create a
backboard you can't cheat by saying the
vm will do that for me so it's basically
you put yourself in a corner and you try
to go out there is there are two kinds
of backport one is a kind of global
backport you think that you are in a
closed world and you rewrite the wall
things here we try something a little
more fun which is to be able to only we
only need to know either classes that
use specialization or classes that
declare that are declare declare and any
something which means that we have to be
a backward compatibility compatible with
so we'll Java ecosystem we are grown up
so we don't talk about syntax more we
want we reuse the model free syntax so
model free class descriptor which is
really nice earth at the previous model
and initially the idea was to not change
the semantics too but it was too
tempting to do something so i will
explain why the semantics it's not
exactly the same as the semantics of val
ala actually basically so and online is
that we think our semantics is better
so what does it means to be backward
compatible it I mean we have sauce back
backward compatibility or binary
backward compatibility here we want
something more than just been re
backward compatibility let me try to
explain the question is what is the
relation between our list of int and our
list of integer what is the relation
between hourly story of wild card and
already stuff so raw reddest the issue
is that people get generic but in the
wrong way what they get is that you have
a rare and when they use generics they
think in terms of a ratio if we try to
provide something that change this model
that change this model model it will be
odd I mean currently if we do
specialization by changing the model
model of the people it people will will
add up time and to figure out the main
issue is that a roger is already
something which is odd hen we don't
think it's a good idea to say oh you
have erasure in this case but not in
this case and things like this you have
another way to see things which is
specialization for from the user point
of view should be see as an optimization
and not as a new model model
basically it means that for the user
point of view generics are not ref ID
the vm we do things that's the vm vm
will do specialization it's an
optimization so what the back part tried
to do is to see our list of int as a
plain old arraylist and to see the error
list of int code as a specialization but
this is two different nature obviously
you can get things like this so this is
how the back part works so back porch
show you just Jake hill and basically
hide mr. Hyde let's take just an example
i have another list of integer basically
what is an array list you have to field
the array of element and the size and
i'm only interested by one method add
that is able to add a new to add an item
inside our list it should be enough
and the question is what is the
representation for a list of end as I
said so ID is to have to our list you
have the front class which is named a
realistic java.util.arraylist which is a
class which which is visible from the
user this class doesn't contains any
fields just one which is a pointer to
the back class and the back class is the
one which is specialized the
specialization contains the field and
the code but not by examples static
method and static field data in the
front class in the front class you need
two big backward compatible which means
that you need to have a method that take
an object as parameter so even if you
specialize the code to have an array
list of int so specialization code will
be in the back class and in the front
class you will still have your classic
add that take an object inside the front
class or the code all the public methods
are redirected to the back class using
in vogue dynamic because the back class
is one which is specialized so so
signature of the thing will change so
this gives us
Pass you can think the ad in the front
class as a kind of bridge that give you
as the ability to use our list of int as
an array list of integer because you
have this front compatibility layer so
technically it's not exactly what we
generate and I will step by step give
you a kind of tore off exactly the code
we generate for it because it's a little
bit complex first in the back class the
method has to be static otherwise it
don't have the right this object so you
have to take another list as parameter
which means that when you try to access
to a field you have to access it using
invoke dynamic now let's see in case of
a realist of int what is generated so
the front classics is exactly the same i
have just duplicated here because its
employee to see that it's exactly the
same class and you have the
specializations back class which in our
case will contain an array of int and
signature of the method add in the back
will taken it as a second parameter
because of specialization what is nice
is that the code that could use our list
of int is a new code it's not an old one
so we can use in vogue dynamic at call
site
directly it's not a code that currently
exists so because we use in vogue
dynamic we can bypass the front class
and avoid boxing and what do in vogue
dynamic does is just take a look to the
back object take a look at of its class
and just do the right direction
basically if you take we have a kind of
environment but class is always access
using in vogue dynamic so we have we
have the guarantee that we will not do
any boxing announcer among the pass it's
means that if you take a look to the
front as of because you have one code
for the front for several specialization
it means that the code that deuce a
compatibility layer as to implement a
polymorphic in earning cash because it
can dispatch on all specialization I
mean we use in vogue dynamic so it's not
a big deal yes yes yes currently we
don't support value type so it's easier
we still have trouble with this design
which is it has to be a backward
compatible with none any word which
means that we can have a string or
release that extend a realist of string
which means that in fact inside are
released you can see both word you see
the
the field of the old world and the back
field for the new any file word which is
not that great but it's it seems to be
the only way to do the thing and with
this design we have the nice property to
have a realist of integer a list of
entry list of while catalyst of nothing
that are the same of that is the same
class how it works at compile time it's
not exactly at compile time but it's
just after compile time at weaving time
we use a patch version of atoms that
recognize the viola bytecode model free
lalala bytecode and basically generate
the classes of the front and the classes
of the back technically we generate not
all the specialization we just generate
one class with all that will be
specialized at runtime we don't need to
do specialization at compile time and we
generated front and back only if so
class is any fight how we do the
specialization of the back class at
runtime yeah here lies dragon late like
this you have three problem problems to
solve how to deal with field and method
access because the signature of method
or field will change how to deal with
instruction like loading a local
variable because vs instruction is
specific to a type and the last one is
how to deal with
size of the local viable long and double
of a double size which is 0 for so first
the abuse part which is basically when
we generate the back class we have only
one back class and in the constant pool
we user a raised version of the world
and we have a side table which store as
a class attribute that say for the
constant pull the constant pull on 32
it's a tee and we will do the
substitution using a string substitution
so basically is a mod n free bytecode
represent parameterize type as a tree
and we flatten the World Tree and do
string specialization it works and at
runtime we use define and animals class
to load the class as a bad class and
patch the final image class the last
parameter of define animals class is an
array of values that will be a
substitute that will substitute a
constant pull on three so basically you
can do the specialization just by
calling different define animals class
and roll ID is to not use any bytecode
weaving at runtime so it work well for
field and method it work not that well
for local variable instruction because I
can't just say I am the owner of the vm
and I will create a new by code I have
to use byte code that already exists so
I need something special
black magic so basically we generate
something like this it's not bytecode
it's not java is just to understand how
it works we generate and if for each
specialization for each primitive
specialization so we generate a bytecode
that basically check what is the class
at runtime and use the right instruction
I have no problem with a verifier I know
I mean it's a good friend of mine and I
know how to speak yeah in two slides I
will explain how it works but yes for as
size of the local rival basically
because a teak and represent a longer
the ball at runtime and I don't want to
rewrite the bytecode I have to use two
slots right it's not a big deal you just
have to rename remember are the local
viable it's a little more complex with
parameters because the number of the
slot for the parameter are implicit and
depends on the descriptor and because
the descriptor will change with the
specialization we have to do a little
trick it's not a big one basically if
you have the method foo that taykitty as
a second parameter T now small T needs
to two slots so we have a translation
between the object world and the
specialization world and we have to add
a preamble which is able add to
basically if it's a longer a double we
have to do nothing other ways we have to
change the slot so we generate code like
this nautical e if the class is longer
or the ball go to end an otherwise we
have to move the local viable and that's
it we have solve our all our issues not
really you have the stack nap frame
stack Mac frame-up generated when you
have a drawing between things obviously
it will not work well here I mean you
will have we need to generate a stack
map frame when you come back from the
eve of the different type but here the
type will be different at each time
basically what we have generated is not
very few bytecode so we can use dash no
verify but is not that fun now we need
another way to bypass bytecode
verification ok question I will be out
to bypass bytecode verification but for
one class not hmm yes we've defined an
animal's class we've defined and in this
class you can choose the last class we
will we use a java.lang.object so it's
full but it works well because every
class of travel ankh is basically not
verified so because so we generate a
class using define animals class and you
say use because the earth class is
java.lang.object we are saying you don't
need to verify it because it's it has
exactly
the same security guarantee that
java.lang.object obviously it has a
little side effect we need to raise or
descriptor because java.lang.object is
loaded by the bootstrap class loader and
the bootstrap class loader doesn't see
all other type because these types are
only the sin by the application class
loader or by any user class loader so we
need to erase our object or all type the
heart that not in Java long basically so
it's not really an issue because we have
invoked dynamic we can go back to the
right type we just have a small small
issue which is we can't call a bootstrap
method because you have to put the
bootstrap method in a class and the
class is not feasible oops so how we can
do that we need a way to call a method
we know basically the idea is instead of
instead of using a bootstrap method
which is in the application class loader
we will use a bootstrap method which is
how we will use a bus rapid odd which is
inside as a bad class so we can see it
but it means that we have to duplicate
code which is stupid so basically the
ids the bootstrap method is in the back
class and we call it but we have still
the same issue to do the call but
because the bootstrap method is inside a
bad class we can
send bootstrap parameter in on this
bootstrap method and because we use
define and animus class we can patch the
bootstrap constant at runtime and send
it a method under which is already
resolve to the right bootstrap method so
basically we've involved with define an
image class we insert a special metal
under which are as already things so the
metal under point to the bootstrap
method with the right information which
means that inside as a bootstrap method
pink one we have the lookup of the front
class which means that we will be able
to resolve every core as it as if it was
in the front class and we have the
string of the descriptor not erased and
by the way we wish to be stupidly at at
some point instead of using a string try
to use a method type but it was not
resolved at the right time so basically
you can bypass bytecode verification is
just painful and it seems to work I mean
there is really no reason that it work I
mean it should work with interpreter the
interpreter just interpret the code but
was a jet the G does a kind of static
analysis of the code so we will see that
the code is not safe it's the same with
GC GC use type information which is
derived from the class it's a kind of
static so information as derived
using a static analysis to in fact it
works with hot spot jets and with odd
spot GC but it doesn't seem to work with
the IBM one which sees more information
this is because the jet of hot spot only
take a look to the things that are
executed at least once so it works
almost so how to store static fields or
species fields it's really easy you can
store static fields in the front class
and species in the back class if you
have conditional methods we're close
it's easy to you may have a kind of a
clash if you generate all the things so
we change the name by appending dollar
something at the end and we because all
the code of the back is called using in
vogue dynamic basically what we have
done is use a special V table which is
specific to a twist visualization that
do the translation in fact we also need
this if we want to support any returns
so summary with this scheme our list of
nothing an already stuff int at the same
class technically it's means that you
can use a list of int as an array list
of integer it will work which will be
very great it means that you
incrementally change every list of
integer as an area stuff int so not that
nice part is that we have to rely on
unsafe bytecode I mean each by code it
is safe but the wulfing is not safe so
it's a security nightmare basically
because we generally use
java.lang.object as the last class it
means that every code which is any fide
as the same security privilege as
java.lang.object it may not work with
all VMS and it doesn't work with methods
that sniff the call site as a call stack
because you have an indirection so it
doesn't work with the content context
sensitive methods as the code is freely
available here you have I think two more
tricks in the code if you want to see
you have one which is how to get a
lookup of any class if you want things
like this and doing this I mean the
thing is we think that Valhalla should
do have exactly the same semantics we
have which is from the user point of
view there is only one
java.util.arraylist and all other things
should be seen as an optimization done
by the vm and not at something that user
can see</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>