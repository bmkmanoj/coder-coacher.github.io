<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Getting Started with Oracle Java ME Embedded and Raspberry Pi | Coder Coacher - Coaching Coders</title><meta content="Getting Started with Oracle Java ME Embedded and Raspberry Pi - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Getting Started with Oracle Java ME Embedded and Raspberry Pi</b></h2><h5 class="post__date">2013-03-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nA7AMuTK9sE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello of welcome to this screencast
which is going to cover how Java ME
embedded can be used with the Raspberry
Pi
my name is Simon Ritter my work for
Oracle is a Java technology evangelist
what we'll do today is to give you some
ideas about how these two things can be
used together to create some really
interesting types of applications let's
start with a quick recap of what the
Raspberry Pi actually is it's a small
and cheap but very powerful single board
computer at the heart of the machine is
an arm 11 processor running at 700
megahertz this is put together with the
memory in a single on chip package
thanks to the work that's been done by
the Raspberry Pi foundation you can now
overclock the processor up to one
gigahertz without breaking the warranty
I typically run mine at 900 megahertz
and I've not had any problems at all in
terms stability of the board or
applications originally shipping with
256 megabytes of memory the new boards
now have 512 megabytes so there's plenty
of room for application code from an i/o
perspective you can connect board to a
monitor or a TV screen using either the
HDMI or a composite video output there
are some USB ports so you can connect a
keyboard or a mouse and there's an
Ethernet connector so that you can
connect it to the network and log in
remotely using things like SSH one of
the exciting things about this
particular board is the fact that it's
got a number of header pins available
these give you the ability to work with
general purpose i/o a UART for serial
communication and then spi and I squared
C if you want to connect more complex
peripherals Java technology covers a
very wide range of devices from very
very small all the way up to the very
very big looking at embedded types of
applications at the very low end you've
got devices or things like a Java card
which have literally tens of kilobytes
of memory
for bigger devices which have more than
ten megabytes of memory maybe in
hundreds of megabytes of memory you can
actually run Java SE embedded which is a
full implementation of Java SE in fact
for the Raspberry Pi we recently
released an early access version of JDK
8 for embedded because the Java the
Raspberry Pi has enough memory to do
that what we want to do though is to
enable people to use Java ME on this
device Java EE fits in the kind of
memory space where you've got somewhere
between one and ten megabytes of memory
the idea behind making Java EE available
on the Raspberry Pi was because it's a
very cheap and easily available board it
allows people to test and develop
applications before deploying them onto
a more commercial type of board if we
look at Java ME embedded version 3.3
there are a number of key features that
we have there at the bottom of the the
stack if you like is the connected
limited device configuration what this
does is provide the definition of the
java virtual machine and a small set of
API s which allow very basic form of
applications to run on top of it this is
defined through the java community
process and specifically from jsr 139 on
top of that we then have a profile and
when Java EE was first created there was
the idea of configurations and profiles
configurations were tailored to a broad
range of devices which had a particular
range of memory and then the profiles
were tailored to specific types of
devices in terms of their capabilities
for embedded devices we use the
information module profile next
generation in addition to those we also
have some other api's so there's things
like the ability to do file input and
output there's some web services
capabilities that you can use there's
some additional security and Trust
services and you can even do things like
XML processing from within Java ME
look at your Java and me embedded and
the Raspberry Pi specifically as I said
we're using the InP next-generation API
and this is really based on mid Peter oh
if you've done any programming of Java
and mobile phones in the past then
you'll be familiar with how this works
we use the same kind of ideas for the
lifecycle management and the way that we
deploy applications onto the device and
so on one of the things that we were
left out from the specification because
we didn't feel it was relevant to this
type of application was the LCD UI and
the game api's terms of executing the
code use a thing called an inlet which
uses the same lifecycle methods as mid
'lets you have the ability to start an
application so you can set up what you
want to do when it starts there's the
ability to handle things when the
application pauses remember there's also
the capability to handle what the
application does when it is destroyed
and it finishes all of this runs in less
than four megabytes of runtime on the
Raspberry Pi in addition to the standard
API is that I mentioned in the last
slide we've also included a thing called
the device access API I mentioned the
idea of the Raspberry Pi having all
these header pins that we'd like to be
able to use what the device access API
does is give us a nice clean way of
accessing all of these connections
externally and enable us to write simple
code to make use of them one thing that
you do need to be aware of is that some
of the devices that you talk to do
require root access although as we're
talking about this in terms of embedded
system then it's not really too much of
an issue from a security perspective to
use the device access API we need to
ensure that the immanent that we're
going to run has the right permission to
access the underlying hardware and the
relevant parts of the Java in the
runtime there's going to be done in one
of two ways the first which is a little
bit more complicated but also more
flexible is to have the inlet be
digitally signed so that it's trusted
and can be granted the the
and access to the things that we need to
do that you need a certificate authority
and need to sign the minute itself and
there's a instructions on how to do that
in the getting started guide the second
way to do it is to allow any untrusted
Inlet to access the devices on the
Raspberry Pi this is fine if you're
doing development testing because you're
not working in a deployed application
and so you you understand what's going
on so from a development testing point
of view what you need to do is change
the policy text file in the app DB
directory of the Java ME home
installation all you need to do there is
to look in the file and you'll find that
there are two domains which have
information about what untrusted and
unsecured inlets can do there are two
domains servers specifically that need
to be edited one is the untrusted an
unsecured one and the other is the
minimum an unsecured one and all you
need to do is add the allow : device
access to these two domains and then
your Inlet will be able to access the
pins without any problem from a coding
point of view what I've got here is a
simple example of how you can configure
a pin to be accessed from within your
code now you can do this with again one
of two ways this is the slightly more
complex but also more flexible way where
we define a GPIO pin pin config object
in order to use the peripheral manager
to open that particular pin so we create
a new GPIO pin config object we pass in
a number of parameters to the
constructor first of those is the port
number and what this does is it allows
us to group together certain number of
pins but we're not doing that in this
case so we just treat that as 0 then we
have the specific pin that we're
interested in this is pin 7 and if you
look at the raspberry pi documentation
you'll be able to see which pins are
available on the header after that
you've got the direction that you want
pin to work in so we're going to use it
as an output pin you can also configure
it as an input pin or as an input and an
output pin there's some configuration or
mode which we're just going to use the
default if you want to see more
information about that look in the
documentation there's some quite
complicated things that you can set
there and then if you're using the pin
as an input there's different ways of
having it trigger again you look at the
documentation on that we'll see the
different ways that we can do that
lastly we've got the way that we or how
we want set the pin when it's first made
available so we're going to set it to be
false which means it's low in order to
get access to the pin using that
configuration we use the peripheral
manager we open call the open method
with that configuration that we've
created that will return us a pin in the
form of a GPIO pin object and then we
can use methods on that to control it so
here I've got a simple method set value
we're going to set it to high or true
and obviously we could set it to false
which would set it to be low so having
seen all that let's move on and see a
demo of how this actually works in
practice
so in this part of the demonstration
what I'm going to do is I'm going to
show you how we're going to configure an
emulator so that we can test our
raspberry pi code before we actually
deploy it here I've got the code that
we're going to use so we've got the
inlet which is extending miss alert here
and what we do is we use the same GPIO
pin configuration that we talked about
earlier we've got two of those and then
we simply say okay give me the use a
peripheral manager to open the ports and
then we're just going to loop three
times moving the motor one direction and
then the other direction clockwise and
then anti-clockwise one second each now
in order to do that we need to create an
emulator so what we're gonna do here is
use part of the Java ME SDK which is the
custom device editor if I click on that
we have CDC CLBC and IM p ng and what we
want is an IM p ng so we click on new
for that that brings up the screen that
allows us to configure that I'm going to
call this rats motor and then what we
need to do is we need to add two pins so
add a pin and in this case we're going
to call this one pin 7 a hob we're port
number will leave is 0 because that's
what we used and pin number 7 Direction
is going to be output trigger none and
that's okay
then we add another pin in this case
we'll call it pin 8 again that's already
filled in for us but we need to change
the direction output and that's what we
need so we've got the name of it we've
got two pins configured for GPIO if we
wanted to configure anything else like
it's okay squared CSP i/o and so on we
could do that as well but from the point
of view this application we're just
using GPIO so I've done that so click on
OK
and now what that's going to do is it
creates this R as plain motor and then
what we'll see in NetBeans
yeah that we should well that we gave
the device is now registered and so we
now see that there's a raise my motor
down here in the device part of the
display what I'm going to do now is say
ok for the rasping motor application I
need to go to the properties of that and
I click on platform here we've got the
device that we're going to use and in
this case it's actually IM p ng device 1
i'm going to change that to be there as
my motor device that we just created
click on ok and then if i run this
application what's gonna happen is it
will start up the emulator and we should
see the emulation and when it comes up
if I switch to GPIO pins you'll see that
here you can see the status of that and
it's changing from high to low as the
application runs and then that's
finished doing it's three iterations and
if I close that and the application
that's finished the next part of the
demonstration what we're going to do is
show you how to configure the Raspberry
Pi through NetBeans so that you can
actually deploy the inlet from NetBeans
directly to the rod board so in order to
do that we need to do is remotely login
to the Raspberry Pi so I've configured
that with an ssh server and i've logged
in as one of the users onto the natural
device so by LS here what we've got is
Java EE 3.3 if I go to that directory
I'll see that there is an apple TP
directory which is where the policy file
is that we need to change
there's the bin directory and the Lib
directory bin directory I find that
there's a number of scripts here that
allow you to do things like install
middle it's just billions and so on what
we're gonna do here is actually run use
a test because we're gonna ask you first
because you need to run it as root
and once you have logged in this route
what we're going to do is run user tests
which will enable us to deploy directly
onto the Raspberry Pi sorry prints out a
few messages so we can see that it's
actually up and running everything seems
ok now if we go back to NetBeans what
we'll see here is that we've got the
window which shows us all the devices
that we have that's where we created our
R as by motor what we're going to do now
is going to create another new device
this time we're going to give it an IP
address so I type in the IP address
about Raspberry Pi then what's gonna
happen is it's gonna say oh yeah that's
okay so that's done if I click on finish
what will happen is that that will
appear as an external device and at some
point hopefully we'll see that the
device will be registered which it seems
to be ok so now if I go back to my
Raspberry Pi project I open up the
properties again I go back to platform
remember this is where we set the device
to be the raspberry pi motor so that you
can use the emulator to see an
application running now we've got the
external device which is the real
physical Raspberry Pi I select that and
then click on OK it's all ready to go
now if I run this application
well I'm be able to do is I'd be able to
see that the output from yeah the party
that's downloaded it and now we've got
the application running there we'll see
that what's actually happening is we're
getting information back about the fact
that it's set the motor pins and we see
this is printing out the iterations and
what we can then do is see that running
in real life
here we have the hardware setup that
we're going to use for our demonstration
we have our Raspberry Pi which is
connected to the network so that we can
access it through SSH we've got an SD
card which is configured with the
raspbian distribution and has booted off
that and then we've got the Java ME
embedded three-point-three installed and
running on there we've then done is to
connect some of the GPIO pins that are
available on the board so we've got a +5
volt line ground and then we've got pins
7 &amp;amp; 8 connected these fed to this little
circuit board here which contains a chip
which is acting as an h-bridge
and what the H bridge allows us to do is
to control different voltages and
significantly higher currents then we
can do directly from the GPIO pins so we
feed the outputs from the GPIO pins into
one side of the H bridge the other side
of the H bridge uses a +9 volt power
supply here and you can control a Lego
motor because the outputs come through
here we feed the outputs to the Lego
motor and then from the Raspberry Pi
were able to control the like a motor
and if we run the application what we'll
find is we should get the motor
there we go now that we've seen Java ME
embedded running on the Raspberry Pi and
controlling some of the GPIO pins what
should you know next well first thing is
if you haven't already got a rugby PI go
out and buy one they're cheap next you
need to download the Java EE embedded
runtime and the SDK you can do that from
the address that's shown here once
you've got that you can install it on
your Raspberry Pi you can integrate the
Java EE embedded SDK with your favorite
ie whether it's NetBeans or Eclipse and
then you can start building some Java
applications of your own thank you for
listening to this screencast on Java ME
embedded 3.3 and the Raspberry Pi we
hope you enjoyed it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>