<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JVMLS 2015 - New Bytecodes, New Objects | Coder Coacher - Coaching Coders</title><meta content="JVMLS 2015 - New Bytecodes, New Objects - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JVMLS 2015 - New Bytecodes, New Objects</b></h2><h5 class="post__date">2015-08-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/SPhJs4KpJBM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm John rose and one of the mary oracle
java team and Brian and Mark and I and
and all the other folks have been
working pretty hard on our big job which
could be summarized as keeping Java
vibrant it's very exciting since in the
last several years that we've we've been
given both the resources and the
motivation to go do some really cool new
stuff with java and I think you've all
seen the results so it's later on in the
conference and you've already seen some
presentations about what valhalla just
now an aot and var handles and Panama so
there's there's a lot of specific very
well-designed projects underway I am
going to give you more of a sort of a
crazy future lead leading collection of
thoughts not all of which connect well
I'll tell you when when people ask me
what I do I have to think for a long
time because there's a list of about 20
things that are happening at any one
time and you're going to enter into that
that sad personal world of mine of too
many too many interesting problems to
worry about so in preparing this talk I
felt a little bit like the the donkey
between two equal piles of grain or
maybe 50 equal piles of grain or maybe a
dog in a park with too many squirrels so
but here we are I I'm talking about byte
codes and by extension bytecode
architecture and we'll even have a
chance to talk about what the future of
the vm ought to be over the next 20
years but in fact not none of what I say
about the future is intended to outline
our general product direction etc so
you'll have to read that slide and if
you want to go have a coffee break now
for the next 45 minutes it's fine with
me but for hypothetical purposes i'd
like to say i'd like to talk about the
instruction set architecture that we
have our beloved bytecodes our
challenges and what we might be doing in
the future I want to look again
the basics to try and understand
fundamentally what our JVM is doing to
point out some of the sharp corners in
what it's doing today and the design
thereof to sketch some future fixes
perhaps and some of this is overlapping
with a talk I gave a Jay focus there is
a link to it that's about again JVM
challenges for the future but today I'd
like to dive deep into bytecode ism
since we're talking about new kinds of
byte codes and new kinds of polymorphism
so last year this was an image that that
captured my sense of what the vm feels
like and it's useful right there that
most of the pieces on that Swiss Army
knife like most of the pieces of the
bike of the bike code engine our JVM are
useful but there are some pieces in
there like maybe the toothpick that you
don't use very much and maybe there's
also the let's say jsr rat or multi a
new array or something that that kind of
you you might think of a way to use them
but they don't come up very often in
your thoughts the vm vision from last
year just as a reminder this is directly
from brians and my talk is let's find
some pain points let's find some rough
edges where the vm doesn't quite do what
you want from a language point of view
and you know in the last year we've only
gotten much more ambitious at least in
in java per say what we want to do with
the language on the vm we've got a lot
more crazy requirements for polymorphism
from project Valhalla and value types
will up the ante even further so we have
more pain points to to think about so
there's an update on that problem from
last year so let's talk about the design
of the vm what is in the vm this is for
most of us motherhood and apple pie but
i thought I would go over it anyway it's
a way of working with data and code in a
way that is perhaps more unusually safe
and portable right so you can run
everywhere and and you don't crash and
let me let me unpack those concepts in
in detail data structures in the JVM are
connected by managed pointers and a
managed
heap and there's dynamic typing as well
as static typing so there's a sort of
suspenders in belt we get both
primitives and and objects the code does
run fast without pre-processing it's
directly executable but it also amounts
to something like an abstract syntax
tree that you can that you can compile
the the binding is done lazily so that
you you have just one binding decision
instead of a compile-time binding
decision which might go out of date this
is you know that's the C++ way with Java
you have to pay the cost at runtime of
binding the safety is is based on
enforcing types and also as a layer
above that enforcing access control
rules public and private and so forth
and it has proven over the years fairly
robust and secure although not
impervious to all attack but we're that
you know that's a that's a serious value
that we continue to uphold yeah we don't
want either erroneous or malicious code
to take down the system and finally the
portability is kind of cool because it
means and it's part of the reason that
I'm here today to talk about changes to
the vm because we continue to aspire to
run the vm on whatever important
architectures are out there that in the
hardware that that people want to run
their apps on so that's Intel and spark
of course and arm powerpc and you name
it we we want to run it and that also
means whatever the hardware designers
have been inventing I see some Intel
people here we have to keep up with that
too because some of that stuff isn't
directly expressible in java yet ok what
are the clever moves we have well GC
obviously primitives with boxing
interoperating two objects that's cool
the code is the jet compilation which I
already mentioned the profiling is
something neat that we that the vm can
do online profiling to then do behavior
directed reoperation of code we 20 years
ago this was all pretty new stuff right
but now we depend on it every day it's
the the redundant checks like in the
verifier
and and in the language compiler the the
fact that abnormalities cause hopefully
exceptions to be thrown rather than bad
code to run silently or crashes that
those are clever moves in the VM and
that one of the reasons that we are so
portable is at the very beginning of the
Java ecosystem some very clear thinkers
put together the specifications to say
exactly how our our system was going to
work if you compare our specifications
with others there's there is often a
different difference in quality and this
gives us the ability to continue to
evolve the implementation with respect
to the spec as opposed to with
yesterday's with respect to yesterday's
implementation in keeping with an
upcoming theme of complexity they i
would say that although there's a lot of
complexity in all those clever moves
their best when they're invisible and so
they used to be people would say well i
really can't get with this garbage
collection stuff because there's all
this complexity going on under the
covers and i don't trust the machine and
i can do much better job managing like
my malik blocks right you've heard
people say stuff like that maybe but in
fact a lot of people have gotten used to
trusting the insides of the vm although
of course it's always a give and take
and many people in this room have cursed
the garbage collector and found ways to
work around it but still the the
majority of uses of the JVM SGC are
treating it as if it were a simple
entity when in fact it's not under the
covers so complexity hidden can be okay
so how are we doing today is our data
easy to understand is it compact is it
flexible yes partly no partly does our
code continue to efficiently encode what
we want to do and run fast and flexibly
well yes but perhaps not on the data
structures we want today are we still
safe or are there no sharp edges mostly
yes let's keep that in let's keep that
true as we evolve the language and the
and the vm
are we still portable yes unless let's
keep it that way but let's let I want to
probe what the weak spots are in each of
those points to our data is has too many
pointers in it I'll get into this in
more detail later our generosity is is
weak so as brian has pointed out it's
hard to tune the data structure you
can't write a an array of int array list
of in the same way you can do it a
corresponding c++ template we're going
to fix that and probably the worst thing
about java data of all time is that it's
terribly racy java introduced threads
and multi multi processor programming
but we also introduced by default
mutable data which is kind of painful
did you say terribly racy or terribly oh
yes yes to tear it tearing li racy yes
yes we're on a runner at air with racing
thank you arc as was just mentioned not
a half an hour ago our compilation unit
size is a little bit limited our 16-bit
limits why would anybody want more than
16 bits right our compilation unit the
class file format is also a little bit
to Java specific for the kinds of
workloads that we might want to run in
the future are we safe sure we're safe
until the next earthquake hits but the
hotspot code base in particular is
highly complex that's just you know
that's what we throw a lot of our
engineering time at is is maintaining
that code base and trying to understand
it and keep it same and what's what
could go wrong with portability well I
would pick our arrays and our primitives
are now too small and our threads are
too big those are our two biggest
portability problems we'll have more to
say about that in a bit so gee that's
all painful right so let's let's
remember though that Aeschylus did we
already have an Aeschylus quote today he
says that suffering makes learning
gain through pain and so we're going to
blender around we're going to we're
going to step in the puddles and and and
look for look for stuff and hopefully
find stuff as experimentally as we can
this is the slide verbatim from last
year just to review showing some of the
pain points in particular the VAR
handles here are mentioned as upcoming
projects you've seen an update on that
this week and then there's some stuff
about arrays to do i'll be talking more
about that Brian just told you about
parameterization and value types you've
seen presentations on FF I so most of
what's on this slide you've been
refreshed on already this week but I
want to talk in particular I want to do
a deep dive with with thanks to Attila
from who's earlier presentation of
earlier year talked about byte codes and
why there are so many I'd like to go
there to do you know where this quote
comes from programming languages should
be designed not by piling feature on top
of feature but by removing the
weaknesses and restrictions that make
additional features appear necessary
I think it's it's either Sussman or
steel I think it's it's on it's on the
revised report of the scheme algorithmic
language scheme in particular they claim
and I agree demonstrates that a very
small number of rules akin to the rules
of chess or have even go for forming
expressions with very few extranjera
composed suffice to form a practical and
efficient programming language that is
flexible enough to support most of the
major programming paradigms in use today
so as with java scheme has a certain
ability to be both object-oriented and
functional and imperative and and it
does so with small number of moving
parts relatively so this applies to VMS
virtual machines i claim should be
designed by removing the weaknesses and
restrictions that make additional
features up here necessary right so i
sandbagged this is not really a talk
about adding new byte codes it's a talk
about removing old byte codes so an
ideal vm would demonstrate that a small
number of rules for loading programs
which you know a class file is an
expression that you hand to the
expression evaluated which is your vm no
restrictions on how they're composed
should suffice to form a good platform
to support most of the major programming
paradigms we're not doing a fully ideal
job here but we can learn from ass from
our aspirations so here are the scheme
fundamental operations names and
constants of course you can call a
function you can create a function using
a lambda expression which we're all
familiar with in this room now and you
can define a name to an expression
that's all there is that's all you need
of course there's some library functions
but there aren't any other primitives
not even if then else needs to be a
primitive right it can all be expressed
with lambdas you of course need lexical
scoping shift reset yes well I I'm not
going yes not going to the co routines
yet there is assignment also so scheme
actually
is has an impure side effect mechanism
in it so there it is just like Java
control flow is here's the here's a
complex expression that in terms of
lower level constructs here I'm not
supposed to point into there with my
finger and you suppose use laser pointer
you'll see that this complex expression
if you if you work it out it does the
same thing as this if then else so the
if is just a syntax sugar for this
underlying library function which is a
three way ? colon x value selector that
picks one of two lambdas and execute it
right away and if you know small talk
that's how small talk does if then else
also with pair of blocks here's a pair
of lambdas everything is everything else
is syntax sugar a scheme purist will say
that there are certain things that there
were a screen purist already did say
that there are certain things beyond
this model but that's that's basically
enough for our purposes today so you
might build a bytecode engine for scheme
and if so you might have byte codes like
this this is from everybody does a
scheme at some point their life I think
this was mine is if my bike codes
actually happen to be literal capital
letters of the alphabet so I could read
my bike codes so there's there there you
can do a perfectly respectable and
somewhat rich scheme engine on top of 16
byte codes not bad actually a few more
there's the brain there's a couple
different branches okay what about small
talk it has a similar set of fundamental
operations it function return is a
special operation unlike scheme blocks
and objects are a little different but
you make objects by calling library
functions so object creation is not a
sub primitive a primitive of the
language there is assignment also
everything else again is a library class
or method so if you go to a small talk
vm you get to press the button until the
slide goes you get a few more operations
because the object model is a little bit
richer than schemes function model but
many of these operations will look
familiar either in comparison with
either the java virtual machine or the
scheme virtual machine i just i just
showed you there's a funny line number
annotation opcode here this is the good
news Smalltalk engine which I picked at
random but yeah there's push push a
global push a constant push one of mice
fields that sort of thing actually you
send yourself a message to get a field
so Java fundamental operations these
look familiar to right but wait there's
more and more and more there's a lot of
Java fundamental operations the language
feels reasonably workable and and feels
simple even to a student but in fact if
you analyze it it's got a lot more than
then either small talk or scheme and
therefore the vm is similar in
complexity here is a here's a number of
byte code points that's similar to the
previous charts but we haven't even
gotten out of data movement right and
i'm including the first part of return
as part of as data movement instruction
here so oh look there's the array byte
codes yeah ok there's there's another
whole block with another small virtual
machine worth maybe array byte codes are
Turing complete I don't know and then
there's some other miscellaneous ones
the the top the top whoops this one the
top group here is the control flow
thingies plus comparators so there's a
there's a miscellaneous bundle of
control flow operations some of which
are obsolete others which are macros for
smaller ones and then the lower frame
here shows all of the what I call the
nominal instructions the instructions
which take as a parameter a name that
must be linked right so anything that
refers to a class by name or a method by
names or a field my name is a nominal
instruction these these nominal
instructions in the in the small talk
engine would in the small talk framework
would correspond to message sends right
just one kind of one kind of instruction
instead of however many there are here
and then of course there are all of the
primitive operations plus a few
miscellaneous like monitor enter and I
also like to think of method entry as an
implicit instruction at the beginning of
every of every method it's the one that
sort of unpacks the the incoming
arguments into locals and also does a
monitor enter if necessary okay so and
this this list doesn't fit on the slide
but we all we all know what it is and
it's all very regular all right so what
can we do to simplify well there's a
bunch of moves we can try and I want to
comment on them some of them we want to
do and others we can't do or don't want
to do but of course well what about
those prefixes do we really need all
those prefixes well yes we there a nice
optimization if but Brian just showed
that you can write perfectly reasonable
code without the without the prefixes
per se and put put them on later on
right you have a type parameter that
says what kind of a value it is but it's
deferred and so you use some sort of
other prefix like the v load v store or
q load or I don't care what your
variable you know what the what the
letter is but use something else and
then later on if you want to you
optimize it back to an I load or an L
store or whatever and eventually these
instructions could in principle become
part of a deprecated or you know a
second-tier instruction layer that that
you don't really need in practical
purposes they become quick and byte
codes inside the vm perhaps the hair
salon i would like which use cases well
yeah there's great dynamic language use
cases so and then return becomes v you
have a V return your maybe you have your
pop and pop two guys they have to
negotiate whether you're a slot pair or
not so maybe maybe do something funky
with with stack instructions the effect
of this is that every local value seem
tactically within the byte codes looks
like in any in any in the sense of the
Valhalla any parameter so you sort of
you can if you wish syntactically and
sometimes it's useful compile your
strongly strongly typed programs
to use type parameters for their types I
do emphasize that strong typing is still
in play except perhaps for the use case
of intentionally dynamic languages but
it's like parameters parameterised types
as a useful feature for everyday use as
a code generation tactic and one of the
reasons we want to do this besides lists
list of int is list of complex we are
not going to put in a new letter of the
alphabet for a prefix for every single
new primitive type we want to have right
that would be impossible there's only 50
code points left and in any case where I
think we've overused those those bites
all right so how is it really going to
work I'm not here to tell you that today
as brian has said we are experimenting
vigorously there are there are several
different ways it could work maybe the
letter V is really the letter A because
we're secretly putting these things
under value-based objects I'd be kind of
interesting for our own sanity we prefer
to make a distinction explicitly but
maybe maybe some implementation exigency
will force us to use A's in the end I
don't know do we use tight prefixes do
we use some sort of a bytecode
annotation mechanism which the answer to
that is no because it's too fragile do
we use some sort of dependent tight
tight token mechanism don't know we're
figuring it out it's going to it's going
to be fun so but the any generics and
the value types are driving this
investigation obviously but it's going
to end up with a simpler and hopefully
with a simpler bytecode set if not the
alternative is we end up with a more
complicated bytecode set and it's
already frankly complicated enough
static typing is good i already said
we're not necessarily doing the Lisp
Smalltalk type things what we're doing
here though should allow a an untyped
type to exist like like dot Nets type
dynamic and maybe several versions of
that so here's here are the
simplifications you get when you
move those those prefixes that's pretty
good empty empty opcode maps are good
for our sit for our world let's keep
those code points slot pairs by already
covered that for a race let's talk about
arrays what about the prefixes on those
are raised and a a load is not really
the same thing as an a load at all even
though they differ just buy one it
letter let's just say as Brian said that
we need a top type for arrays so a
generic a low to VA load would be one
which would invoke an interface to get
necessary to get an element and again
with strong typing so the interface
would know whether it's getting an array
of doubles and a rave yes or whatever
again compared with the the scheme move
of taking what appears to be a primitive
if then else and turning it into a
library call or small talk what appears
to be a primitive array reference
instruction really under the covers can
be viewed as just an irate and interface
call on the array here for concrete
mistake is I've been prototyping on this
a little bit and here's a here's an
example of the sort of array interface
that I'm writing this one in particular
has two parameters and I don't know what
I don't know what an ordinal is yet so
don't ask me that's just slide where but
the basic idea is you parameterize over
both the index type in the element type
and then everything falls out and
there's a long list of methods it's a
fairly rich type the in particular you
get to import versions of all of the ER
java.util.arrays functions so there's
some there's a raised dot to string
which everyone in the room has used I
hope and here it is as a as its own
method and can it be the two string
method oh I wish but that's a
compatibility question that I don't want
to solve right now
so classic inter-class in order to make
this particular move work we give we
want to give classic arrays new
interface super types right sounds it
sounds good all that all that
boilerplate above works I don't know how
to spell it exactly where you know this
is early days but it's either array of
int comma II or classic array of e
whatever what's more difficult is
perhaps also we should have the
hardwired vm type the one which is a
concrete irate classic array type now
which is the bracket I for example
perhaps that should become internally an
interface oh my gosh why would you do
that you're going to kill performance
well maybe maybe it's useful on balance
for array operations to become
polymorphic so like if you have code
which is jam jam packed with AAA loads
or IA stores maybe you want that to work
on new library type arrays right like a
block DeRay or frozen array or an
off-key beret or there's several
different kinds of arrays that are
natural in this kind of context existing
array code like sort can become generic
and we can do the specialization trick
right too so we get something like
templates out of it and also we would
allow legacy api's to which talk about
arrays to talk about new kinds of arrays
as well so any there are many java api
switch talk about arrays which will
never change but maybe it would be
worthwhile to replace the kind of array
that they return like have it be non
mutable frozen arrays right frozen rays
are not necessarily a new class a new
implementation but it falls it falls out
of this this move also the risk of
course is that we don't want to we don't
want to drop any optimization on classic
arrays at all classic arrays are are bad
but we can't live without them right
there they're not they're not good
enough but getting rid of them would be
the wrong wrong move it but we've had
some very interesting experiments with
optimizing code which works like arrays
like the array mismatch adventure we can
see that the vm is able to optimize that
kind of code
as well as it cannot work with plane
arrays so there's it's hopeful that we
might be able to do this here's a
snippet from a some proof of concept
work you can see here I'm grabbing a
string I'm calling an array a freeze
operation and then that's a string array
and I'm asking are you array equals to
some your original copy and it's going
to be true here's a called get element
here's a call of AZ list that one
doesn't work because genera fide lists
are a little bit fragile and then here's
our ray to string being called on a
string of a primitive array of primitive
int so that's like you know that that's
about all all that ever works right now
but it's it's worth the slide so that
would let us empty out the array part of
the opcode space for the byte codes what
else what about all those primitive
functions well let's give them API
points let's also make interfaces maybe
this might help us organize things let's
make interfaces for the primitive so an
integral interface those these opcodes
here can become interface calls it wise
by the way I'm not going to minimize the
design problems how do you axiom atty
these things what guarantees and
contracts you put on you can go to town
on this and write whole books on how to
do this right we don't want to do it
wrong so we're going to take that slow
so there's a simplified opcode space can
we take can we can we cole s new
valhalla value types like complex or
128-bit int with the existing primitives
I hope that will cause the complexity
associated with primitives to become
subsumed by the more regular complexity
of value types that's what I'm hoping
will happen in that in that case there
could be a net decrease of a parent
surface complexity even if there are
dark corners I do believe that int and
long are always going to be special
there's every language has instant
there's there's there's got to be some
very basic reasons for that here's
another idea which probably isn't so
good except in certain cases we can we
can take all the nominal instructions or
replace them by indie but so you could
actually have Java Sea compile only to
India instructions with very few
exceptions that's kind of cute it
reduces complexity in some sense it's
also fairly heavy so but it can be
useful for very specific cases where we
don't want to hack the existing
invocation modes maybe you want to do
some flexible bridge matching yeah and
indie can help with that yeah all right
here's here's one that's close to my
heart I don't like special invoke
special I invoke special is a dumping
ground for for questionable behaviors
and the most questionable of all is the
initialization of a blank object I call
that the new invoke special in it dance
and I think it's an evil dance it must
be banned the it should become a factory
call there's there's never any reason
for especially for untrusted out of
capsule code to make a blank instance
and then the verifier is going to make
sure we hope that you're going to fill
it in right that should just be inside
of a library call and it should be so so
overwhelmingly common that the vm should
be willing to synthesize those factory
methods for you and populate them with
the one call to New and invoke special
in it I want to be able to deprecate or
encapsulate the naked op codes they
should be private write a new op code
should be private to the to the class
that you're making a new of what this
would allow by the way as a not only as
a cleanliness move but as a
functionality move it will allow you to
do in a uniform way the creation of
instances and generic reified generics
and arrays because any parameter you
need to create the object is present in
the factory method signature and then
whatever the factory method needs to do
internally to create the object of the
right size and shape and with parameters
generics whatever species that's in
that's probably
to the factory and you don't need to
specify how untrusted applet code plugs
together the the reified parameters and
the array length and the whatever else
right you just do it all of the factory
method what a concept so these are a
couple examples you know of what what
pseudocode would look like with the
invoke static new dance instead of the
new invoke special in it dance note that
there's a reified parameter type being
passed here and an array length being
passed here you can't do that trick with
the with the existing dance finally it
leads to what about serialization it
leads to a better story for
serialization wouldn't it be nice if
every serialized type gave a one or more
factory methods to the serialization
framework and then the serialization
framework called a factory method which
then could do whatever was necessary for
that type to create the thing wouldn't
it be more secure and safe you wouldn't
cover every last case of serialization
but recover a lot and it covered a lot
more safely the reason we have
serialization weight is today one of the
main reasons is it it Apes the new
invoke special in it dance in a
completely unsafe and unsecure away and
it's just a bad dance turned into the
serialization dance so better would be
to have some kind of a convention for
saying this guy has this serialization
factory that's a lot closer to a factory
model and it's a lot easier to secure
and think about okay what else besides
byte codes class files are too small we
already talked about this they're also
too large we've talked about that too if
you want to upload just one method of
class files too large they're too rigid
because maybe you want to have an
extension methods on a class or maybe
you want to load the debug methods later
and the hot methods first so why not do
a new class file format yay
so I'm imagining a hypothetical tie-dye
festival in Portland with all the bikers
and their tie dye and there'll be more
bike shed colors on a classf I'll
rewrite than there would be on that
festival so okay another pet peeve this
is on a level with the new invoke
special in it dance are our static
dependencies are first come first serve
when you when you initialize a static
module you run it CL in it the first
time you touch it and is that the same
order every time no is it an irrational
order every time note is to pick up the
right class every time no other than
that it's great yeah this is why people
spend their whole careers doing
dependency injection frameworks and so
forth now we there's an interesting
interesting direction of a possible way
out here the hot spot you may have
noticed now implements get static and
put static as derived notice a theme of
a derived non primitive on top of lower
primitives it's actually a non-static
field on a class object internally what
if we bring that up to the level of the
language you know what if we start
talking about the object which receives
the request for a static value or a
static method Gil add is probably you
know laughing at us all here because he
called this twenty years ago small talk
also put statics on class objects so we
could hear that here's pseudocode for
that instead of saying get static of CX
why don't we say load constant of C
class and then get field of CX of that
of that thing that we loaded that
involves different name resolution rules
so maybe it's an invoke dynamic right to
follow my own rules but this reduces all
the static e byte codes to the non
statically non-static friends it also
gives you a framework for talking about
more explicitly about what your static
dependencies are in a module which could
have benefits and and so maybe we can
encapsulate the the CLN it thing more
as a manageable method on an object
instead of as a magic block of code
which you're not sure what it does okay
initializations r us let's see we got I
would give this one I'm going to skip
this light hello no this is the part i
want to say the another feature of
statics is that they have this
initialization barrier that that turns
on the initialization what's what we're
really trying to get here is a framework
for run up configure run some
configuration code the first time I need
it and when do I need it well right now
it's when you first load and initialize
a class but that's that's not always the
right answer of when I first need it
sometimes you you want to get a value
computed when you first compile an
expression so now we're talking about
constant expressions which java has a
story for but it's very limited but
maybe we're going to extend it i don't
know but there what i want to say on
this slide is there multiple early
points at which you might want to run
once some configuration code to assemble
you something and then that will then
feed into the later phases of your
program and those phases could include
compile time in Java Sea could include
the J link tool could include class in
it time as we conceive of it today or it
could be bootstrap execution time which
is per call site right there there are
there are all these golden points where
wouldn't be nice to just do that
computation once and create something
robust and simple and then just plant it
where you need it right so I think
that's what static is trying to be let's
let's let it out and let it let it be
what it wants to be flux flux is a
problem there hold talks on this we get
a keynote from rich Hickey a few years
ago about why flux is evil yeah when
your whole world is moving then there's
some then you can't say anything about
it that's some Heraclitus said that I
think in Java everything is non-final by
default how dumb is that well
hindsight's twenty-twenty there's not
even a final way to finalize array
contents hello even final variables are
not really
I know that you can always change them
it's like it's like what they said about
the witch in Narnia you can always get
them back so what does an optimizer do
well an optimizer it makes special
special pleading for his friends like
the method handle inlining rules and so
we wonder why our why there's so much
clicking going on on the memory
backplane there's things are changing
when they shouldn't be changing one of
the side side side aspects of the
associated aspects of this problem
mutability is that memory is far away so
you're there's a cost to changing
something even if it's innocuous and
it's not an oculus usually cache lines
ideally if you're going to use your
memory because you purchased it you want
to get your full purchase price you want
to use fifty percent of each kind of bit
if you have ninety-nine percent of one
kind of bit and one percent of the other
kind of bit you're only using two
percent of your memory right sort of
stands to reason and that's what Claude
Shannon would tell us too if you were
here so you you don't want your you
don't your memory which includes your
cache hierarchy to be polluted with a
bunch of useless zeros it's usually
zeros right usually we don't see
polluted pollution with useless one so
I'm going to blame the zeros so let's
set whatever else we do and this affects
JVM and language design whatever else we
do let's make sure that cache lines
which are here to stay for four
apparently for the next 20 years I would
venture to guess let's let's uh let's
make sure that they're full of full of
data full of random data / random access
and that means pointers are not so good
because pointers are are probably got a
lot of zeros in them or ones sometimes
depending on your platform so what you
want to do is you want to make
sequential accesses to get lots of high
entropy bits every time the vm violates
both of those i both of those desirable
characteristics by heavy reliance on
pointers because a pointer not only has
a lot of zero bits in it but also a
point somewhere else where no one's
going to predict that you need to
prefetch a cache line
somehow magically suddenly you need a
cache line way over here and the memory
system has to scramble and get it for
you that's called it you know dependent
pointer dependent load data dependent
load arrays help but not if it's an
array of pointers because then it's just
more pointers and it's worse the JVM
cannot express fundamentally one value
containing another that's our problem
that's what we're working to fix that's
one of you know it's a high-ticket item
another problem is a scientific side
effects causing around the world trips
through your memory backplane thread
over here says I want to change that
that counter right over here says I want
to change the counter to and the memory
backplane says oh well you guys please
agree which one of you is going to
change this cache line and instead they
is ping ponging back and forth it's
actually subtle problem the the simple
answer to the subtle problem is stop
changing stuff so much make things final
by default so a Java object should be
mostly I mean when you when you need
state you program with it very
intentionally and seriously but when you
don't need state a Java objects should
just be a message to the future here's
some stuff i collected once and a header
and now here's a pointer to it somebody
else read it and do something about it
share share share frozen friends share
frozen stuff I can't make a good slogan
out of that but you know what if you
have non-local right to read effects or
there so often bugs and it would be
better to catch it by having an
exception on a frozen object rather than
I have your back plane do something and
then a thread far away does something
else so we want a color inside those
cache lines and use them use them as if
they were trees which were not fully
renewable resource or something you want
to use use use a whole cache line for
for random data and then use another
cache line near to it because we
recognize that cache lines only only
when they're clean and shareable can
they really transmit data to other cpus
so you want to have you all your your
you want to pack the cache line and then
that's just one thread and you're done
and then you hand it
so how can we make more data structures
in Java that neatly fit in two
consecutive cache lines with nested
values well value types also Ras 20 also
good boxes a box which can be which
doesn't need to be the same box
everywhere but can be reconstituted
locally if necessary fused array objects
the stuff that guilt na was talking
about last year it also means we also
want activation records when we get into
the the fiber cut routine world we want
those also have the cash friendly effect
also i'm going to put that put that in
here so pointer free data structures we
are proudly serving ArrayList event next
year even this year we also want to be
able to do a larger primitives I mean if
you can work in one step with the larger
value that's also a good way of nesting
stuff close together and that means that
means Intel AVX instructions yay you
know we want to work with those types so
we're looking for we're working actively
on ways to box something bigger than a
64 bit primitive into a into a Java
buffer of some sort and eventually have
it lifted into registers and so forth
what else as mentioned before if we if
we have fewer pointers at least the ones
that we have we can keep it can matter
like V tree node indexes and then few
strings as I think I already mentioned
you want Springs really to be one or two
cache lines long and that that means
packing the tail of payload onto the
header of the object we also want the
the freezing operation shutting down
future changes on both objects in a
raise so we're you know we're we're
moving slowly towards the towards those
those ideals there's a concept called
larval construction where you say I've
got this thing that's under construction
it's growing inside of its shell and and
we're we're feeding it the pieces that
it needs and eventually is going to
sprout and wings and fly away and then
it doesn't need to change anymore
can be shared by the world free
publication note also just for the
record that object identity is really a
side effect having to keep one object
identity fixed even if that object is
completely immutable is a cost because
someone might synchronize on it that's
that's going to tweet at least the bacon
bits in the header and that counts for
all optimizations as a potential side
effect so it's ugly we want identity
free values that are lock free that just
have content only value based is what
they're called we want more value based
objects which time do I have I'm coming
towards the end I can skip some
motherhood slides but I do want to
mention i do want to talk a little bit
about threads because it's not something
we're working on hard right now but
we're going to have to Java began as a
threaded language when other languages
weren't cool and all threat all cool and
thready they were hard to program java
was for many people many purposes the
best you could get but threads use
enormous amounts of memory you can't get
away it's like dragging jacob marley's
box of chains and boxes and cash boxes
behind you it's with you for eternity if
you're if you're in a normal threading
model also a technical problem is normal
threads can't do simdi lockstep
synchronous synchronized execution like
the the indexed type of streaming
whereas with a very small modification
to threading you could say start me a
million threads run them in lock step on
this vector workload that would be a
reasonable semantics but you can't do
that the way threads are configured
today a thread basically holds on to its
resources forever until you kill it a
lighter model would be let's have an
event handler let's run it wherever is
convenient and let's get rid of its
resources when it's done that's better
you can have millions of those instead
of thousands
q Ron press leurs demo from last year
this is a this is a more about fibers
I'm going to just skip over it because
we've talked about this stuff before in
this in this some in this group in
previous years but we want to do we
don't have y'all do lightweight reactive
programming which means basically
reifying stack frames small groups of
stack frames on the on the heap and then
having the mount onto threads and then
dismount as soon as they're not working
you also need some continuation
mechanisms you need tail calls so that
one handler can call another handler
without dragging the dead handler behind
him forever like a mini thread tail call
means you can leave one frame and enter
a new one at the same time it's an
important you don't always need it but
when you do need it there's no
substitute for it good oh I think the
jvm of five to ten years from now will
be routinely running many of its
computations out of heat based frames
not stack based frames okay what's in
the activation record the one thing I
want to point out that's kind of
interesting is that an activation record
seen in apart from a thread is a
sequence of bytecode executions he's
also an actor in the Java memory model
in other words who is it that's doing
all these happens before relations and
these volatile stores and so forth it's
not really a thread it's the frames of
the thread and so when you when you try
to talk about frames apart from threads
the Java memory model wants to watch
wants to know when that frame dismounts
from a thread and then remounts another
thread because the the member that
happens before effects need to follow
through from thread a to thread be we
can do this right run good races are bad
variables are hard to tame we need
confinement models this is one of my
motherhood and apple pie slides this is
an interesting slide though here
because I I want to say that the the
hardware people when Java was first
created 20 years ago it was a little
ahead of the hardware not every machine
had good 64-bit integers right some of
them had to be done in software now Java
is in the reverse position we are behind
the hardware our best integer is 64 bits
their best injure is going to be 512
bits soon right so and and do we want
these dumb big long who needs who needs
that many numbers right we've got to the
64 is enough for anybody right heard
that one before well in fact there are
many good uses and especially Lane wise
vectorization algorithms are really cool
on this new hardware and if they're
going to give us all these lane wise
parallel execution units maybe we should
find a way to use them from Java maybe
what do you think so we need flat types
that can hope that can map to those
vector types and we need some api's for
remember i showed you just as an
armchair exercise what if we got rid of
I add and ill add an el mall and f neg
and all those guys and replace them by
API points well that it didn't feel like
he gained a lot from that right maybe a
certain aesthetic satisfaction but now
what if you want to work with vectors
and you suddenly need a suite of AD and
mall and neg gee maybe we need an API is
that can talk about these scalar
operations in a flexible way and refi
them yes okay so that's this that's the
hidden agenda behind beginning to
propose primitive interfaces we want to
put those interfaces in non-trivial
hardware hardware centric places like
these vectors so I you know we're sort
of on the cusp of being able to use the
VAR handle like patterns to put a vector
in a box so that we can operate on it
and hand it to the you know the Haswell
execution units that's going to be
really fun you can do what we missing
key stairs we need some sort of azum
like trick for getting to all those
crazy instructions right now we some
very good work from Intel is putting
those AVX instructions into
primitive loops if they're for loops in
there well conditioned but we want to
have free access just to program you
know because we love to hack with that
stuff right we want to be able to play
from Java with with AVX instructions
like you can play today using GCC inman
tryn h if you if you know what that is
it's fun if you don't they should should
try it so here's now here's again a
piece of slide we're sketching what a
cpu vector interface might look like
because after all in a Java interface
does not make any commitment at all to
what the implementation is in fact there
might be an underlying hardware vector
here especially if we do the boxing
elimination right we have value based
objects you see these themes all
interoperate and build on each other if
I have the right kinds of containers for
256 and 512 bit vectors and I have the
right interfaces and I can bind them
through you know with method handles and
unsafe or did I say unsafe no no one
said that then you can begin to work
directly with interfaces like this and
have them compile up to two real a VX
instructions or spark instructions or
arm what's it called neon yes yep vfp
all right so we've come to the end of
all the all the squirrels they aren't
any left I've chased them all the way
but I want to say i want to leave you
with a big picture what do we want in 20
years i claim join me i raise the flag
we want a more uniform model simpler
less apparent complexity lots of clever
tricks underneath but we want our
objects and our arrays and our values
and types to feel more similar to each
other than they do today because we're
going to be adding in more special cases
we want them to all feel like like
they're they're related family we want
memory efficiency as I've gone into in
great detail we want good entropy and
all of our cache blocks good prefetching
less pointer dependencies better vector
instructions we want to be able to share
code and then customize it as needed as
Brian was talking about we want that
when the customization be mechanical we
no longer want nine different versions
of arrays dot sort right yes but we
don't want templates either because we
don't
want to what we want don't want eager
specialization we want lazy lazy profile
driven specialization we want to be in a
post threaded world 20 years from now I
claim there'll be too many processors
and and the dinosaur threads hopefully a
comet will have killed them we want
interoperability with non-managed
languages good good discussion about
that today we want it to be broadly
useful we want it to run most modern
languages whatever those modern
languages are including Java 20 years
from now and of course we want it to run
yesterday jars of yesteryear you know
they order the 40 year old jaws yes my
arithmetic is bad it you know the the
the jars of yesteryear are just like the
the COBOL programs running on MVS of
yesteryear they're not going away and
our ecosystem has a nice warm corner by
the fireplace for them to sit and of
course we wanted to run blazingly fast
we're in the business of helping
programmers use the hardware and enjoy
it while they're doing it so questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>