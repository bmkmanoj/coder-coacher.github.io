<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JVMLS 2015 - Flexible Types in Kotlin | Coder Coacher - Coaching Coders</title><meta content="JVMLS 2015 - Flexible Types in Kotlin - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JVMLS 2015 - Flexible Types in Kotlin</b></h2><h5 class="post__date">2015-08-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2IhT8HACc2E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Andre breslov I work for
jetbrains uncut lon and today I'm I'll
try to communicate some of the
experience and flexible types that we've
had recipe so common two things you need
to know today carlins statically typed
language and its job interoperable so
these are two things that kind of impose
all the difficulties how we present
anything so alternative title for this
talk is how we learn to stop worrying
and give up sound this actually we gave
up two kinds of soundness at once and
I'll try to elaborate on that a little
later so this ability to give up
something as precious as sound this has
a lot to deal with the question is this
glass full and I as many of you in this
room and a kind of person who has the
luxury to being able to say that it's
full enough you know because we are we
mostly stuck to what works or we can say
that it's practically full yeah so we
can sometimes we can't afford to give up
with your reticle a nice property so one
of the ideas behind cotton when it was
initially designed what's make it safer
than Java you can get much safer at
runtime of course but you can try to
prevent some of the common errors at
compile time and here are four points of
what we kind of thought we prevented
these are knowable types that fight
against a null pointer exceptions these
are read-only collections where you can
express in common whether your
collection is supposed to be modified
through this reference or not so you
can't express that this list is not
supposed to be modified or that this
method is not modifying the argument
collection at as getting also there is a
holy grail of fixing the covariant
arrays
that are in Java since the beginning and
we thought we fixed time and of course
Java has raw types and we have no row
type so that last point here should be
no row types so these were the four
ideas we had and now we have interop so
we have this somewhat nice or language
and we have these constraints we want to
be interoperable with Java actually it's
both ways but I'm not only talking about
calling calling java because the other
way around it's all easier so when
cuddling calls Java there should be no
overhead neither one time nor in the
code so the coal shouldn't be bigger
longer in the code and shouldn't take
any extra time what kind of manage that
and also we are not supposed to prevent
the intended use of the API because
sometimes the API was designed for
example to take an array of object which
most likely means that this method is
working on any kind of array and if it's
not malicious it's not putting anything
wrong into the arrays is probably only
reading them like this one is supposed
to count what how many anon all elements
are there in the right and if in Catalan
would say that our for us an object
array is invariant it means that it
cannot put an array of string into this
method and this prevents the intended
use so this is something we cannot
afford so we cannot make this code red
because otherwise it would be not
enabling the use of the library and the
last point here and then drop is that
the interruption spoil the pure Colin
situation if possible so if you're not
interpreting with Java you're as safe as
Colin can't possibly be any questions at
this point should be pretty
straightforward so actually something
should seem fishy already from from the
previous slide and the whole point of
this talk is that those two things are
contradictory so it can't get both
smelt the smooth n drop and type safety
at the same time so let's start with
knows these are like another Holly grail
of very many attempts by many people so
what do we have in common so yeah so you
know the Java situation right yeah I
have a string and can put an awl into
the into it and then blow up at run time
by trying to do references and catlin if
you say a string it's a string it's not
null so you're not allowed to assign no
there you don't blow up and if you want
to know and somewhere it's not a string
it's a string ? which is a nullable type
and that it cannot reference without
some extra ceremony around it so we
transfer the error from the wrong time
to compile time and there are some
special devices in the language are
quickly going over them so first thing
you can check for null and then it's ok
you can even check in return it's ok and
then there are some special characters
you can type in either check and not run
if the receiver is notable or blow up if
the receiver is novel or even have this
short form of if that group of people
named an Elvis operator anyway there are
some nice devices for treating knows so
it's all pretty convenient with Kevin so
take away carbon is good with notes now
the question is what about Java so
Calvin can call a Java API but upon the
event of the call the compiler must
somehow make up its mind like this java
string is it like nullable it's not
knowable you know yes I and also if if
you have a list of string it's not so
few options anymore right can be a non 0
list of non null string and on the list
of a nullable string a nullable list of
non null string and a nullable knowable
so we have many options and we have to
make up our mind as typesafe people we
initially decided that ok we have to be
on the safe side the only option that is
sound here obviously ok everything is
elbow and jela we don't know anything
any reference can be null so question
marks all over the place this kind of is
sound of course if you have a primitive
end it's not knowable but everything
else is so this means that whenever I
have a Java kool like to string or
something all my dots are illegal I
cannot do reference null point nullable
pointers without anything any ceremony
around it so what i can do is for
example these safe goals they do not
evaluate or basically value to know if
the 11 side is null but this picture
means that all your code where you
interrupt with java is covered in these
special symbols and this may be a price
you are willing to pay for type safety
and soundness but unfortunately there
are worse situation here like if i have
a list in java and it's that list of
string right so i can so i think it's a
knowable list of notable strings so the
best i can do is put this double banger
prater here and it will be an unknown
list of unfortunately knowable string
which means that it doesn't fit so so we
kind of asserted that list itself is not
know but the arguments we can do nothing
about and there is no generic way of
dealing with this so this is a deadlock
for the user there is no way of using it
without an explicit cast which would be
unchecked of course so kind of you know
it's kind of a failure the safest way
doesn't actually work I would like to
have it but it's so inconvenient nobody
would put up with it what time
oh yeah there is of course an option of
not interoperating with Java but that
will be a very nice kind of you know
theoretical situation but yeah very
unsafe from the like marketing or
adoption standpoint that was yeah so we
tried for a while to get away with using
annotations so you can put a non-null
annotation here and there and it kind of
double crosses and some of the options
here this unfortunately doesn't help
with these because there is Android and
it's not java 8 there are no type
annotations there and you can some of
the libraries are not under your control
so you carry around those huge XML files
with annotation information or newer J
files with annotation information users
forget to figure their tools properly
annotations are lost compilations broke
and everybody is unhappy so yeah yeah
java 8 yeah yeah yeah thank you so Java
it does solve this problem of not having
type annotations so of being unable to
put a nation on the string inside a list
so I can't annotate it here in Java 8
but I still am stuck with two problems
one being Android being not java 8 and
being a huge market another being that a
library developer has not annotated his
library and I cannot possibly do it in a
convenient way for my user so again
practically it's not working so again
practically you have a list of three
requirements and apparently I have to
pick two we didn't want to give up on
either convenience or Java so we kind of
gave up under not safety and introduced
something called flexible types Oh with
the help of
stay from Cornell okay so what is a
flexible type a flexible job is when you
collapse many options into one I see a
java string oh I say it's a java string
have no idea if it's not able or not I
have this red ! it's red in the code
well actually it's not in the code at
all and it's a flexible type it kinda
behaves ambivalently and when I have a
generic oh well be both of the
components of the type will be generic
so the bar is generic is sorry is a
flexible type for platform type and the
string inside also platform time so what
it gets us is this kind of behavior so
normally when you have a non-null type
you can reference it with no problem and
if you apply some non specific
operations you get a warning because
it's a pointless operation if you're not
able you cannot the reference and the
knowable operations are applicable if
you are flexible you can dereference the
compiler does not complain it may blow
up you probably remember that from the
Java age right and the knowable
operations are legitimate because they
may actually make sense so this is the
flexible behavior we wanted to achieve
now it gets a little more complicate so
before any flexibility we had a very
very clear nice picture when there is a
not knowable type and non no type and
one is this type of the other so the one
with null is wider so we can't assign
and string to a knowable string with no
problem now you should obviously be able
to assign the platform string to any of
these and of course if you're trying to
put a null an effective null into an
unalterable well will emit a runtime
check and blow up but this now is not a
transitive relation anymore so normally
you would like your subtyping to be
transitive and here it's a clear loop
you can assign through this loop we can
assign a nullable string through it
from value to a string and blow up
probably a bit from like the type system
design sign points and unpleasant
property gah wrappers for what ok so the
question is could we wrap all the Java
calls we're making to you know have some
checks there and probably annotate the
wrappers problem correctly in theory yes
in practice it violates our requirement
of being smoothly interoperable the idea
is that you can throw any Java library
at catlin with no integration work and
it will be convenient to use so the
answer is technically yes practically no
so this isn't this picture has an
unpleasant property of being circular or
non transitive and we have to live with
it no way around so this is by the way
the first unsoundness we have but it's a
nice kind of an soundness because if you
look into the gradient typing theory and
all this kind of resembles gradual
typing this is ok because it blows up
here so as soon as you violate your type
system requirements your static
requirements the runtime will blow up
it's ok so this is the nice kind of
unsoundness where predict we are
introducing into the language so a
little bit on how its represented inside
so my tags have weird weird shapes so a
normal string would be rectangular the
the significant part is how long are the
horizontal bars in the rectangle so
basically any type may have a wide and
and a narrow end so for string both are
of equal length and for a platform
string the wide end would be string ?
and the narrow end is a normal string
what it means
is that of course will use those ends
differently in different contexts like
when I'm checking subtyping I'm doing
doing a like funny trick of picking the
most convenient end like if I want to
want to check if my platform string is a
subtype of normal string I so the normal
strain is this wide so this is more
likely to fit in so i'm sure i'm taking
the narrow end and check if it's a
subtype of this wide end here like the
upper end so by the same logic if i'm
trying a novel string and if it it as a
subtype of a platform string again I'm
taking the narrow end from here and the
wide end from here so this way it all
works so the internal representation is
that flexible type is basically a pair
of like bounds a narrow bound in a wide
bound and so when we are calling methods
on if we use the narrow one when we are
working with subtyping we use the wide
one questions here all right everybody's
lost now next unpleasant thing here is
that when we are checking subtyping on
to invariant classes arraylist is a
familiar one from the JDK so this is
invariant which means that too for this
to be a subtype of this the arguments
should be exactly the same or equivalent
and by equivalent we can mean that is
equivalent to be if they are both
subtypes of each other with a normal
type system it means that these are same
types but our type system just has got
abnormal so what we have here again so
string platform string is a subtype of
nullable string and vice versa and same
here right so the equivalence relation
is not the equivalence relation anymore
it's not
again so surprisingly all the typing
rules sustained that although it's a
very unpleasant property from the
mathematical standpoint but yeah it kind
of gets unpleasant here so all the
mathematics is basically thrown away and
we have to recheck everything all right
yeah and by the way it sometimes can
result in string being kind of
equivalent to string ? and there are
NASA tricks of getting rid of this okay
so let's bit is that I mentioned that we
perform some runtime checks and but of
course not all of them all of the
necessary checks we can before because
with a simple string it's easy you
assign to a normal variable you just
check one value it's okay but now i have
a list and again i can't check the list
itself but i can do nothing about its
content so all I can do is say it's fine
assign this and there will be no check
on the elements of the list and it will
probably blow up somewhere else so this
is uh huh assign ability when I'm
assigning this to this platform type
yeah yes yes normal string to a string
that is that is not supposed to be null
I can make a check yeah and same here so
this is a hole in the academic sense so
for a gradual typing system this is a
bad unsoundness because you allow
something in the typed part of the
language that will not immediately blew
up at runtime it will blow up sometimes
maybe yeah now I yeah I have some notes
here so one thing is that a flexible
pipes
not part of the language so you cannot
write them down yet we are very
reluctant to introducing them and I'll
show you why in a little while pure
cotton has nothing to do with them so
it's still null safe current plus Java
here is arguably as safe as Java so you
can have a nullpointerexception from
Java you can have a null pointer
reception from from Java blood Scotland
it's okay also the annotations I
mentioned before still can be used and
then we will do proper checks and turn
the flexible types into inflexible ones
and then just complain about you trying
to do something bad but only if the
annotations are here and actually the
property that there is that if you pull
out the annotations if the program
compiled with them it will compile
without them and it's important because
people lose their and Asians along the
way all the time okay so we kind of
manage the noble any questions here okay
so now I picked a nice citation from
John's talk of recently there are many
AP is that talk about rice which will
never change and we have to deal with
them so as I mentioned already arrays in
Java are covariant we would like to make
them invariant so that you cannot assign
either of these two each other because
it's bad you know but in cotton you can
express something you can assign many
kinds of a race to it is called
covariant projection it's very very much
like in wild card from Java so you can
say it's an array of out t out means
covariant and then an array of this
should be T or subtype of T so an array
of subtype of tea will be assignable to
this this this is totally broken this is
incorrect don't don't look at it
there are many typos in one life so a
peculiar property of a projected type
where a wild card type is that you
cannot call contravariant methods so the
compiler would not allow you to set
anything into an array which is
projected obviously because you will
break so that's all nice and shiny in
cotton now we have to enable the Javas
intended usages so we make a flexible
type out of any array we see in Java and
it's narrow n is the most narrow type I
can give to an array which would be an
array of so if i have a java array of
foods it will be an array of flexible
foo and the upper bound will be the most
y type the most permissive type i can
give witches and rave out foo ? now
imagine putting this into the language
yeah so that's pretty easy if if you
check subtyping it's that weird rule we
saw if you're trying to call a method or
assign an element to an array you're
using the narrow bound it's allowing you
to do anything you can do in Java that's
alright again so yeah so if you have an
array of string you check the narrow
from here against the Y from here it's
alright it assigns so again we're as bad
as Java we're as good as Java it's good
the next thing is collections so we
really wanted to express the read-only
contract on particular references to
collections so what we did was we try to
go away from from this idea of the list
interface having both get and set we
wanted to split it into two so that here
i can actually without a comment
explicitly in the language say that this
list is read-only so that it doesn't
fail at runtime because I return now
unmodifiable list but it complains at
compile time so let's interface in
carlan look like this only has get and a
bunch of other accessor methods
up then the mutable list would be a
subtype of this and it adds the mutating
methods and now if I want to return a
read-only view of my collection albeit
actually mutable by implementation I can
say just listed few is read-only mutable
this is mutable so it compile time I can
manage my situation so the overall
structure would be like this these are
read-only types they don't have any
harmful methods in them now I can extend
each one of them and I did in the
library with a minimal version and the
actual Java collections one but when we
look at them the library collections
they are kinda fictitiously extending
the mutable interface so at runtime
there is still java.util.list it's
alright bud at compile time we split it
into two so in common you can say list
or a mutable list and it compiles down
to the same java.util.list and we'll
load the Java classes so that they
extend the mutable versions the question
is do is stop people casting from a read
on the last immutable list no we don't
so the property is if you're your own
enemy cast okay so back to flexible
types we used to have this bar loaded
like this I have a flexible bar of
flexible string and it's all right so as
soon as bar becomes a collection it's
not only null ability I don't know about
it's also the mutability so it's a maybe
mutable list of may be mutable maybe
nullable list of maybe nullable strength
and i have to manage it okay so
obviously it's again I platform type I
flexible type represent them a platform
value and the narrow and is the most
precise one immutable less it's the
least the lowest class on a hierarchy I
can get for it and the wide end would be
a nullable list of stringless is
covariance oh this is a subtype of this
it's all right nothing's broken yet ya
know it shouldn't so the question is
should i make my lower bound it actually
doesn't matter so the question was
should be the narrow and be not able to
the answer is no because if you think of
string string we would have not know at
the bottom and nullable at the top and
this is the combination of two we
express both null ability and mutability
in the same thing so it's a non null
list here and immutable so the most
precise i can get and this is knowable
and read-only which is the widest i can
get and so the the nice property of this
pair is that i can combine two
properties in the same representation
well well maybe maybe another dimension
what would have solved a problem i'll
present in a minute I don't know so when
we first thought about this design for
collections it seems safe compatible and
covariance for the read-only classes at
the same time it looked like a rare lock
but when you can get something that
works really for all the clients and
does break anything but apparently it's
when there is no java when there is java
it's more complicated because say i have
a list of object i represented as i
showed before at the top i have a list
of any any is our object its covariant
and at the bottom i have a list of any
immutable list of any now this is
covariant again so when I take a list a
string in Catalan take its bottom which
is Alice the string again and check if
it's a subtype of this it is because a
read on Lilith is covariant which means
that I have just passed a list of string
to a method that expects a list of
objects which even Java wouldn't allow
you to do
and carbon does so so you can do this
right i have a list of strings and i can
pass it to this foo method that can do
anything for example put a an int into
it or something that's unfortunate and
this is likely the biggest unsoundness
and the biggest reason why i refer to a
dr strangelove in the beginning of it
because all the rest was kind of
manageable and this is really upsetting
because this is where we got somewhat
worse guarantees than java gives you but
apparently if you want all the things
that we want you can't get rid of it if
you want the list they read unless to be
covariant if you want it to be in an
interface be implementable so not final
and if you want to enable the interop
with java you inevitably make it
possible to make some transition from a
list of string to a list of any and then
pass a list of any to java somehow so
for example we could do that through an
extra variable right so I have a list of
string in cousin this is a legitimate
assignment there's no problem with it
when you wanna stay in cotton and
through this one variable here we still
tacit to a java method and this is
something that would be very unnatural
to forbid because it's a list of objects
from the Collin standpoint like if you
raise it right and so this is totally
unthinkable to forbid and this means
that we can't get around it any
questions here
a list of objects when we see a Java
list of object we allow you to put
anything into it that's right yeah a
list of anything fortunately Alyssa ?
would be a little easier because it
would be covariance so you couldn't you
couldn't you can't say yeah you can take
static stuff out you cannot post up in
but it doesn't change the picture very
much but it's safe because it's clearing
down the java side it's not a problem so
here the problem is that we introduce
covariance where Java doesn't have it so
we got rid of it with the rice but
introduced it here so the interesting
thing is that we were not aware of this
problem for a while after prototyping
for a few months at least and nobody has
stepped on it because there are actually
very few things you actually have you in
your api's that are open types like a
list of object is very uncommon actually
even list of carriage sequence is very
uncommon so it's not a very typical
situation that you fail with this
normally it will blow up I mean it will
complain at compile time but technically
we're not even as safe as Java here but
you know and of course of course I can
always take my duct tape out of my
pocket and patch a little bit here and
there so that you don't do an obvious
error at least of course I cannot
prevent you from doing something more
sophisticated but when you're explicitly
passing a deal you typed as well as the
string from carbon to something I know
to be a java method I can put a check in
here like a special check it's not in
the type system is just a special thing
for java and say okay this is forbidden
it's definitely wrong but of course if
you do it through another variable it
will allow it anyway so this again it
doesn't cure anything but helps a lot in
practice
and yeah I'll bet on runtime checks of
course we can check a little bit at
runtime here so we can try to make sure
that nobody assigns and something that
is not mutable two immutable collection
again technically at runtime everything
is still a collection in Java collection
so we have to somehow put some metadata
on to those but anyway we think that all
Java things are mutable but a kaplan
class that only extends a list and not a
mutable list should not be assignable to
something that lettuce type with mutable
list so we have checks for that but not
if you have a collection of collections
of course so four elements of
collections you're in your own questions
here what's with that yeah well this all
plays nicely with both type variable
bounds and type inference so that this
not much not much most most our
algorithms was not we're not modified in
any way for for this so it's pretty
transparent which was a surprise because
one would think that having no
equivalence relation there or having no
transitivity would be a bad thing but
apparently all the algorithms we checked
or agnostic to this okay few last bits
you're supposed to eat raw some people
say so with the wrong types it's kind of
annoying because it's a legacy thing
anyway so we we know it was inevitable
to introduce them but we kind of think
that they are not there anymore
everybody's on Java 8 java for has been
very long ago so who cares about raw
types so one thing is that people
actually use raw types now and then in
very many places because of this
this is just an unfortunate thing and I
wonder if it maybe even fixable I don't
know so the thing is that somebody wants
to write a recursive generic everybody's
saw a new class in the JD Kane wants to
be as smart as JJ DK people so you
introduce a tea that extends the the
class it's a parameter for but then you
just forget to pass the tea as an
argument here the problem is that the
compiler does not complain in any way
and you end up with a row type here so
as soon as you have a tea anywhere
you're stuck with raw types and this is
not an imagined example this is why we
actually pay a lot of attention to road
types because it pops out from here and
there all the time like you load any big
library if there is an example of this
do we have to deal with it also there
are many raw types somewhere stuck
somewhere in the middle of a large
hierarchy it may not be accessing them
immediately but when we're binding
overrides in the compiler we have to see
that this Roy type here is actually
compatible to that generic type over
there so we have to represent them or we
don't do it as smoothly as everything
else but still so when we have a row of
foo which was declared as foo of T that
extends bar we have a narrow end of just
full of bar which is an erasure of tea
then we have a wide end of a covariant
version of that so that again assign
anything that satisfies the bound to the
raw type which is roughly Java semantics
so here this means that if you have a
java method that takes a row type you
can pass anything that Java would allow
to it if you if agile method returns 0
type to you it's not a smooth it
wouldn't fit into anything only into
full of bar so what you can do is just a
closely cast and it's very uncommon so
we don't care so this again formerly it
violates our constraint of having no
overhead at the call site in the code
but actually we don't care because it's
a very
same questions here all right
everybody's completely lost good could
have been some initial reading I felt
before I throw myself in altitude okay
my track of the cochlear alliance yeah
so a summary of the Java situation would
be that with notable types were more or
less well off we are as safe as Java in
in the sense of guarantees we give we
can throw in some annotations and be
even more precise in our type checking
weekend amid some runtime checks that
they don't guarantee anything but still
they help a little bit with the Rays
it's the same thing no checks needed
same with Java basically with
collections we are unfortunately worse
than Java we allow some covariance where
it is not intended we have a nasty patch
that rules out some common cases some
common errors we can throw in some
annotations and they helped along we can
do some some runtime checks again as
usual raw types not so important for the
client so they are usable not as smooth
as in Java but safe enough so in the
takeaway from here is that we're trying
to put together a more safety than Java
and seamless interoperability you get
some kind of gray deol types during
sound in at least two meanings of the
unsound so you get less safety but not
so often so it's still practical to have
this questions here good invariant right
again philosophically we wanted to get
rid of the unsoundness of java type
checking with respect to array
assignment so we wanted to get rid of
erased or exceptions yeah
yes yes I can totally understand why you
wanted covariant collections yes every
child who sees a list of objects and
thinks you've been a Chinese the string
get disappointed the problem again
erased or exception yeah yeah so yeah
one can think about imposing safety
features into the language as getting
rid of runtime exceptions as it turns
out we cannot get rid of them entirely
but we can get rid of some of them at
least ah mark questions okay yeah so
it's safe enough again now yeah if you
want to play with it just visit our
website and the last bit that I would
like to advertise here is that we
actually not only compile to Java but to
JavaScript as well and javascript is a
little less type than Java as you know
so there it's even more relevant to have
some flexibility because you have no
types whatever and there it turned out
that with the same machinery we can get
something we call dynamic type it's not
available for the JVM at the moment
because we don't know how to efficiently
implemented so a dynamic is something
from bottom to top just anything it
actually required a little bit of
patching on the resolution side because
normally what we do if we were trying to
resolve x-point foo would be take the
narrow end and ask its members but
nothing has no members obviously so this
comes together with a few rules that
allow basically anything to be called
and dynamic and this is an extra work
language but type system wise with
inference and subtyping and everything
there it just works this way so this
idea of having type split into two
bounds and having weird rules and those
works pretty well and covers many use
cases so this would be if you want your
language to be safer than some other
language but compatible you can try to
use the Strix two questions all right
thank you very much it was fun for me at
least</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>