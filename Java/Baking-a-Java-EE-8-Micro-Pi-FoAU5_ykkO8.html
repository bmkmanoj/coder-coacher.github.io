<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Baking a Java EE 8 Micro Pi | Coder Coacher - Coaching Coders</title><meta content="Baking a Java EE 8 Micro Pi - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Baking a Java EE 8 Micro Pi</b></h2><h5 class="post__date">2017-10-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/FoAU5_ykkO8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so look at this let's have a
go with what we've got
so this was gonna be a fairly demo heavy
presentation fortunately I have actually
got some code snippets from the demo in
the slides so hopefully we should be
able to at least talk about the sort of
things that I was going to do so if we
can switch over to my laptop later on
then we will but if we can't then we'll
just we'll make do so my name is Mike we
both work in the support team there and
this talk is titled baking a Java EE 8
micro PI it's it's had to change a
little bit from that due to did
completely different hardware issues
before we even got here
so it's not many good talk for hardware
gremlins though affecting what this is
about is putting Java e8 and Java in
general into context so see given that
Java 8 has just been released there's
going to be tons of talk to Java 1 that
are going to go into all the specs that
are going to tell you all about how they
work so although we'll be touching on
that that's not the core motivation for
this talk the core thing that I'm
looking to do here is write a little bit
of context show you kind of where Java 8
is now where it's been and how it
relates to the world that we're in
currently yeah so let's get started such
a little bit about me and Andre so I am
a part of support team member that's my
twitter handle if you want to follow me
and snowboarder and there's my proof
that that is a genuine photo of me but
it's it is made to look much better than
he actually is so Andre is also prior
support that's him on Twitter and he's a
dad and obviously doesn't have much time
for anything actually exciting anymore
since that happened
so what's this all about then so the key
thing that I want to talk about to begin
with is how lightweight Joffrey really
is so Joffrey traditionally I mean
you'll know is have lots of lots of
criticism about how it's heavy weights
bloated it's bulky it's all difficult to
work with I think to be honest I think
in general that the tide is turning on
that sort of opinion more and more
people are using modern Joffrey in
finding out that it's completely
different to how it used to be so I
don't want to label that point too much
but just kind of investigate what makes
it lightweight why is why is it easy to
take it up and running with then I'm
gonna look out what's in Jerry eight
today what's been released and what kind
of things can you use and so that this
last point has been heavily modified so
he would just recently found out that
Java is moving to the Eclipse Foundation
and then it was announced that that
project was going to be named Eva J
Eclipse Enterprise for Java but then
also there's been a recent clarification
from Michael link of itch from Eclipse
to say that although EE for J is the
umbrella project name it's not
necessarily going to be the replacement
branding for Java EE so I had to modify
a third time because we don't know what
the name for it is going to be we know
that it's probably not going to be Java
EE due to just a trademark things via
that there's a lot of reasons to be very
excited about the future of java re'
whatever it becomes and I'll touch on
that a little bit and also depending on
how the demo works hopefully get a
chance to look at that as well so when I
kick off with a bit of recent history so
kind of around this time sort of four
years ago we had java re' seven just out
of the door with GlassFish for i am
because i wasn't a java one but i was
back in the office blogging
about it and trying to get everyone
excited about the new java re' 7 release
and as I was preparing this presentation
I was thinking a lot about the the
general landscape that we've got at the
moment the service that we've got
available how things have been changing
there's been a lot of change that's just
in recent months but trying to think
back to when GlassFish 4 first came out
actually was quite difficult so I went
googling I went to have a look at where
things were where key technologies were
and what I found that she kind of
surprised me how far we've come in such
a short time so the first thing was
docker at this point was just three
months old so Linux containers obviously
were a thing and people were aware of
them people was trying to use them but
docker was really really new so at the
point when Java EE 7 was released this
whole you know brave new world of
containers and you know shipping
absolutely everything in just one night
neat nice neat little box that year
operations team can't mess with you know
that that was completely out of the
heads of most people
wasn't really on the roadmap
wildfly it's one of Pyro's competitors
that didn't exist in a named former it
was still JBoss AAS the open source
version of JBoss
so I put it was before spring boots
actually at that date you can check on
github because that's how I find out
there are lots of tags sort of
pre-release tags of spring boots so it
was being very actively developed at
that point but it's I know I didn't go
into the details of what features they
got in there yet but it was still very
very early days quite far away from its
version one WebSphere Liberty profile in
June 2013 had recently been released
it's actually wasn't long after I had
left IBM so I used to work for IBM a
little bit before this so I kind of saw
a little bit of the background of
Liberty being created and that was
something I was quite interested in but
at that point it was still very very
early it was just implementing actually
the Java EE 6 specifications
it was quite far away from doing in Java
7 stuff it took me quite a while to
adapt to those and a lot of the features
that are in WebSphere Liberty now were
not in Liberty profile as it was so
bring this forward to four years later
we're now at a stage where Java EE 8 has
been released and obviously in that time
docker is now the dominant container
format so it's gone from completely
brand-new and a lot of people being the
lowest skeptical about it it's gone you
know through the traditional hype curve
and to be honest has not really been the
the massive trough of disillusionment of
most things yet but when you look at
competitors to docker like core OS who
did their own container format even they
in their engines will support Dockers
container format so a might still be a
little bit early to call it but it does
my doctor is probably one on the
container format Wars before they even
started really but that has actually
introduced quite a seismic shift in just
the way that we deploy things in general
when you look at the really key
technologies in cloud computing at the
moment we've got kubernetes which is got
awkward is hot and lots of other things
which are only really exist because of
what docker has done why I've included a
non Java technology there it's a while
fly first on has become what a flight
they've I put down that they fully
productized swarm so swarm is their
composable job EE application server so
if you've not used it before you can
define fractions in swarm which are
really small kind of components may be
just like a CD on jax-rs and nothing
else they've got a microphone file
fraction as well I haven't said they've
released it because I'm not sure what
had they stand on support as to know the
wild flight is their unsupported you
know innovation stream it is now into a
proper product remember when it first
came out it really did seem to me and
probably to quite a lot of other people
as a bit of a hobby project it was quite
good when it worked it was quite easy to
get wrong and break and quite hard to
find out where it broke but quite
quickly Red Hat of put a lot of effort
into that and made into a really really
good product and good compared for us
off your spring boot have been making
their jars not was it's just long enough
to stay for quite a few years now I
think the key thing there really is that
they've they were really the ones to
kick off the current kind of fat jar
movement if you like so it's really
popular I think mainly or the key
benefit that I see is that you keep all
of your configuration within one waffle
within one distributable so rather than
having your application which you can
deploy to an application server but then
it won't run because you also need to
get some configuration in the
application server that's non-issue
whispering boot because it's all just
packaged together which is nice
IBM a released open Liberty everyone
noticed that happened fairly recently if
you don't I BM have obviously got a
booth at the exhibition center you can
go and find out about that I know a lot
the guys there are quite keen to chat
about that
so open liberty is remember when
websphere liberty was the the main thing
they were saying that I think about 40%
of the server was open source so they've
open source a lot more of the server
it's not quite all of WebSphere Liberty
so a few things that are left out of
that so for instance the admin console
that they've got is not in the open
source version but what is in there is
all of the Java EE specifications and
all of the micro profile specifications
that they've pushed out so as developers
who want to write applications to run on
a server and just want something to run
stuff that's that's a really great
option now and of course that's us
obviously we didn't exist four years ago
but since then we've seen that GlassFish
is no longer commercially supported
payara has brought in pirate server and
we've also introduced PI our micro which
we'll be talking about today and finally
we've got the Eclipse micro profile we
see show of hands who's not heard of
micro profile ok so a few people haven't
heard it ok so I'll give you a bit of
background about what micro profile
actually is then so it all kind of
starts back last year around June and
it's been really a collaboration between
Red Hat IBM awesome payara
Tommy tribe and a few of the Java
community groups like the London Java
community and Su Java in Brazil and
effectively what it is is just it's a
response to the question that often gets
thrown in Java EE about innovation so
Java EE you might well know by design go
slowly
it doesn't want to kind of push forward
and try and standardize on something
before it's a well-respected technology
because it has to be backwards
compatible it's got all these different
kind of business requirements
so because obviously that there's that
restriction of Java EE and we don't want
to kind of break that all the guys
involved in my profile and we a payara
were quite involved with that decided
that what we need really is a new place
where we can kind of sandbox new
technologies that react to what's
actually going on out in the real world
get some quick feedback from from you
guys developers who want to use this
kind of thing and these API is and then
hopefully use that as a way to kind of
push forward into Java EE
it's obviously was announced as an
initiative in June last year we
announced microvolt 1.0 which was really
just a starting point based on Java EE 7
api's just CDI jax-rs and JSONP just
last year at JavaOne the reason why we
only went for those was because we
wanted to stick it right back to the
absolute bare minimum that you would
need to write a micro service style
application in today's world so we
accept that you would likely have to add
the extra on top of it we wanted to
start with as little as possible so that
we didn't add too much extra cruft that
we regretted down the line that's
progressed quite a lot since then so
we've released 1.1 I think 1.2 is as
I've been released there okay so it's
sort of released for 1.2 I think there
still needs to be a few after things
need to be tied off before we properly
announce it but we've got an API for
configuration which I actually show a
little bit in this slide deck we've got
an API in 1.2 for metrics for health
checks for JWT token propagation and I
think code everything I think that's
everything that there's been an update
to the config API as well and
fault-tolerance
yes we've got an 8 an API fer fault
tolerance in micro services as well so
or sinjar v8 again I didn't want to kind
of come
ignore all the stuff that's in it we've
got a few things that have been upgrades
jax-rs has now got a reactive client in
it just had to cry for quite a while but
there's no reactive api's to work with
that there's also server sent events in
jax-rs which I think have been out in or
standardized in kind of the non Java
sphere for quite a while so now we've
got standard in jax-rs certainly for
which I think it's actually one of the
really really major things in this
release I know servlet is a very old
technology but that now supports 80 to
be - if you thinking well that's fine
h-2b - or is a big thing you really need
to look into it I really think that's
going to be a major major thing over the
next few years particularly with the
speed improvements it brings and the
security by default that it brings you
can't run actually to be - without being
secure I could talk a little bit about
that later but I don't want to labour
that too much
I've been validation 2.0 is out it's got
quite a few updates in that same with
JSF I don't there's anything any
individual thing that's to major in JSF
I know it does support WebSockets now
natively so you don't have to add in
your own framework like atmosphere or
something it's all native CDI - brings
asynchronous events and JSONP brings a
few kind minor additions I think I merge
patch and Jason pointer just to you know
close off a few things that were missing
really from the first back new specs
we've got jari security it's kind of
based on jaws pick I don't know I'm very
pleased you have to speak about that a
bit more if you want
but uh nothing much room should be on
there yeah can you hear me the the thing
is with it with security it's uh it's a
crucial component of Java EE and and
business applications but it was
traditionally hard to set up security
and was divided or between the
application and the application server
so traditionally specify how users
credentials are authorized but how the
user is authenticated and given the
roles is specifying the server and the
application only consumes this
information specifies required roles but
it's cancer or it couldn't influence how
the user is authenticated and authorized
and that was an addition I think even
Java is six supported this that's it
there's a specification called a spec
which provides a way how to plug in your
authorization mechanism from application
but this there are too many problems one
obvious problem is that very few people
know about it as there are other
specifications in Java EE version which
are also lesser-known and this is
probably the least known specification
and the other point why it also isn't so
widely adopted and known is that it's
very complicated it has like three
different interfaces but you need to
combine together and and if I could
compare it to the new Java security API
it's like in jb2 and a type III so the
the just peek was really complex to work
with and the music security API is based
on the CDI and only with the fever
rotations you can specify your own
pluggable module which you can put into
your application so you can account for
authentication and authorization from
within your application and you no
longer need to
depend on the configuration provided by
the application server so the simplicity
was in mind there thanks Andre it was
great to have someone else here she
knows what they're talking about to get
some extra details see I think that that
kind of ties into what we saw on the
previous slide about how the Java EE
landscape has changed and how we've got
spring boots and I should waffle ice
form and pie or a micro or which allow
you to add configuration for your
application server into the deployment
artifact so again like Java security is
kind of enabled a big thing about that
as well Jason B is obviously and I
always think there's a bit of a danger
of seen Jason being is quite a minor
thing I think it's actually much more
significant than people might think
certainly from using it in in the demo
which I hope will melt actually look at
its it was quite significant and I think
it's it's a big help it's a lot of
convenience annotations but it will make
life a lot easier so when when we get to
the demo hopefully we will we're gonna
be running this on pyre on micro so just
wanted to for the benefit of people who
may not know about PI or micro and what
that is go over a little bit about
what's actually in it and what what we
do with it
so it's a downloadable jar artifact it's
just 60 megabytes ish I think it's it
always tends to come up around 60
megabytes it's kind of varies a little
bit from release to release based
dynamically scalable so at its heart
it's got hazel cast and obviously hazel
cast is really good at dynamically
clustering with other different
environments so if you stand at one pile
on micro just you Java - jar player
might create a jar and then you stand up
another one they will automatically
discover and cluster each other without
any extra effort on your part and
obvious because we're based on hazel
caste we've got all of the different
kind of hazel cast plugins for
things like AWS deployments so it's got
native discovery Aveda other instances
that run on AWS it can do it over TCP or
of a multicast it can use kubernetes as
your as well I think there's a few other
different discovery methods as well that
can be added through plugins it's fully
embeddable so you can just embed it to
your application we call it web profile
plus because it provides or it will
support all the same API as the java re'
web profile but one or two extra ones as
well they've been added in and it's all
maven central there so I'm not sure if
that beta one snapshot is actually up
yet it was supposedly up around about
now I haven't actually been in touch
with that developers to see if it's been
released yet but there is definitely an
alpha 2 snapshot which is on the maven
snapshots repository it's they're just
the key API so I won't go through them
all but we can see that that's all
basically the web profile except for
we've added J batch we've added
concurrency and J cache which obviously
isn't a jari api yet it's still a
candidate to be one I think it should be
but it's does need to be moving forward
although the spec itself is still
evolving we've also quite recently added
JCA to this so it's not been a prob
possible with web profile before what
that enables you to do is use it as a
JMS client which i think is a really
important thing for cloud native
deployments but also it's meant that we
can create our own resource archives for
working with modern messaging
communication tools like mqtt Apache
Kafka Amazon's sqs service we actually
got a repository in github called our
cloud connectors repository where we've
got examples of all of those say it is
very simple to use just kind of create a
new MDB use all the same activation
conflict property and
patience to set up your location for
your MQTT broker and you can subscribe
to messages just with normal MDB stuff
so yeah EJB pool configurations can can
be used to control that the other thing
is config that's the micro profile
config api and that's been added for a
little while now
I think we've we certainly got a few
extra updates for config 1.1 and i think
that's due out in November ish time in
our next release so that leads us onto
the demo which is ready to switch over
to the laptops is that is that gonna
happen let me get that sorted number 5
to make sure I've got lucky
great you got something nope
there you go no that's nice
someone's like this
so we'll have a go and see if we can get
everything up and running if not then I
can just talk you through things I guess
yes the best issues that it's not
detecting any input it did first thing
this morning but yes since not be able
to get it since all right then
okay so let's ignore the demo then let's
go
okay so let's show you what the demo was
he was going to be running on my love of
Raspberry Pi cluster there so the
cluster itself is just for the benefit
of any hardware hackers in the room just
a Raspberry Pi 3 on the bottom the red
board on the top and it's kind of it
looks like it's plugged into itself it's
not that's just transporting power from
the main board that is a just a board
which kind of supports power for the 4
ratified zeroes on top which allows it
to cluster together which worked
beautifully back at home and then I
killed it because the problem with it is
it's all coming through a single power
source and the the issue with that is
that when you got all four them running
at once plus the main board there's not
a lot of power to go around and it's
just slows down a lot so I tried to
increase the pattern yeah don't mess
around with power and things like that
when you don't know what you're doing so
the demo scenario was gonna be all about
dock it's based on a an application that
we'd already got I guess stock ticker
demo where we'd had a couple of Ralphie
PI's we stand up pyre on micro on one
which has got a stock ticker in it and
we stand the pile marker in a second one
which has got a web application and we
use an EJB timer to fire events over CDI
which then because we've got hazel
castor cluster these two together
rather than these events living just
within the first JVM these can be sent
over the network to the other JVM and be
processed by another member of the node
it's quite a neat API that we've got in
PI or micro it's the same CDI events API
that you would normally use but we just
annotate that with at outbound so that's
roughly what it was going to be so we've
got stock tickers at the bottom and
we've also got another feature in payara
which allows you to have clustered
Singleton's this basically means that
across the entire cluster you can stand
up the same micro-service that you want
but you can guarantee that across the
entire cluster there will only ever be
one instance of that either EJB or annex
actually completely feature yet but soon
to be and applicate a clustered scoped
CDI beam
so yes the stock ticker has any heavy
timer in it which is a singleton that'll
produce events the stock web obviously
being on clustered together will receive
those events and push them through
WebSockets to a browser so they can be
consumed so I might have to skip through
a little bit about the things that were
going to show but effectively what I
would have shown an atty all this is on
github so I could just see if I can get
that up
at least be able to talk about the code
a bit she's better than that
great so
it's the first thing is how the stock
object so this is a stock Lib hopefully
this has got the sets a little bit
better it looks like it's good so
actually this is gonna have all of the
kind of finished final stuff so I was
going to kind of run through it and
write all the code for this but we just
look at the the end product here so what
got is just a normal stock object I've
added JSONP annotations already but
there's later so all we've got in our
stock object is a symbol a description
and a price
so this the symbol obviously every stock
needs to have a symbol that it
identifies itself with which needs to be
unique price now this is just a a random
double and a description which is a
string so to begin with I created a to
jason method which obviously just see
related to adjacent object for me and
then had a string which just two string
method which just called that and then a
two string on the data object that was
returned this was the kind of the old
java re' seven way of doing things with
the JSONP api so it it's quite
functional I mean that there's not a lot
there that's really difficult or hard to
use or but it is quite manual so kind of
creating all this stuff is involves a
lot of extra work from I think so the
other thing that we need once we've got
our stock object is the stock ticker to
actually set the stock price so we've
obviously the the object is just there
it's not doing anything at the moment
yes here we can see that we've got a
stock ticker all it is is just a
singleton EJB with an EJB timer there
which is scheduled for every second you
can see at the top I've added the
clustered annotation there which is pyro
micro annotation just to ensure a single
instance across the entire cluster
probably it's probably a bit better yes
so we've got this event here that I've
created here I've annotated with inject
and at outbound so the outbound
annotation if it tells the clustered CDI
event bus that these events need to go
across the network to anything else
that's that's cluster than that's
listening on them and see that in the
brackets here also added loopback equals
true now the reason for that is that if
you want to process the events within
the same JVM as well as over the network
then we add the loop back so that it
sends it to itself as well you don't do
that by default and here obviously in
the timer were just kind of creating it
a new generic instance of stock with
just a math or random for the yet for
the actual stock price which obviously
means that the yep
every note yes yes it's what we cannot
actually also do is that there's another
thing that we can do in the brackets
there is add a name to the event and
then when you add your inbound
annotation you can specify that you only
want to listen to a certain name so it
effectively worked it's not quite a
topic style of thing but it's
effectively doing the same sort of thing
yes yes entendre just point out that
yellow with CDI events you kind of
filter by the object class type okay so
yes so we've got the stock ticker that
set the stock price and we've got a
publisher for the CDI event bus so if
the stock web listener what we're doing
is creating a WebSocket
endpoint which is just a standard API
that's been around in in Java EE 7 so at
this point in the demo all we're using
is just Java EE 7 stuff in existing
technologies so we're gonna kind of
start there and then add on the Java EE
stuff later so we need to class to
manage the WebSocket sessions and then
for each session that's registered we're
going to kind of push things out via the
on message I think and then class to
listen for the stock events on the CD
event bus
so first we've got the session manager
which is an application scoped CDI bean
and we inject the CDI event bus itself
this is how we actually receive the
events that we've got you've got a
registration do you register session
which is just a hash set and here we've
got an observer method where we've added
our at observes at inbound stock so the
only thing that we've really added there
is the at inbound and there that's where
you put the extra you know in the
brackets to filter by that the name in
the the for each loop that we've got
there as well each session that we've
got registered we wait for the event to
be received as soon as it's received it
will send everything out to every
subscribed consumer that's all this is
kind of fairly basic just send in text
as a string object if I you know to here
let's have a look at the actual
WebSocket class
so we've got the server end point of
slash graph we're injecting the session
manager that we just created got unopen
method here which registers the session
then once it's registered then we let
the session manager push out all the
data based on the observe method so
that's really all what's going on there
I won't go into the the actual
JavaScript page because it's just a
JavaScript page which has the JavaScript
WebSocket endpoints to to listen on
those so now there we should be at the
point where everything that we've got at
the moment if I was able to run it in a
show you're working we would have a
single JVM with the stock ticker every
second that's going to publish events
those are going to be fired out and then
received by the other instance and then
that's going to be pushing these things
out via WebSockets and via the session
manager to the browser so what the user
sees is a nice dynamic graph which just
has WebSockets dynamically updating
everything so at the moment that's
something that you can do well before
today before Java EE 8 came out and
there was nothing particularly new in
there so my first thought for this like
I said at the beginning I wanted to put
Java 8 into a little bit of context so I
thought that the the issue with using
the cd-i event bus although it's
fantastic if you've got like an internal
application where you control all of the
services to you know give you your end
application you can use the CDI event
bus for your internal communications
there you can use it wider than that if
you want but you can't guarantee there's
someone else who wants to maybe use one
of your mic Riserva TSA's or if you want
to expose something publicly you can't
actually guarantee that they're going to
be able to consume those sorts of events
so we need something else to handle that
and the solution there was server sent
events from Jackson RS softly I did have
the WebSockets thing already set up in
the stock web obviously we could have
used that but the the difference there
is that WebSockets is binary
communicators two-way communication so
what you basically do is opening up a
channel where you not only send dates
but yours are waiting to receive data as
well so you've got all these extra
endpoints listening for stuff that
aren't doing anything because all we
doing is broadcast so service and events
is a perfect chance for this it's it's
just using rest it's using standard web
technologies that have been around for a
long time and there's basically designed
for broadcast and so the other thing
that I was going to do as well is again
assuming that we're going to make this
thing public for other people to consume
we'll use JSON be to serialize the stock
object and give like a nice a nice kind
of stock object which we can then the
use easily by other consumers so this is
actually where I cut code in the in the
slides which makes things a lot easier
so beginning with we saw this in github
already this was the original way that I
was doing things with JSONP so all we've
got is just a JSON object returned by it
adjacent method and then we're just
saying that to string just fine but it's
it's a little bit manual and bit brittle
so these are the things that Jason B
brings with it Jason B dotnet has got
quite a few examples and things and link
to the specification and have been
affected we can see down at the bottom
there we've got this sort of stock
equals jason build it or create dot from
jason and i'll sorry that yeah that's to
deserialize so that the one just above
that is the the two string method just
here so what we're doing here is we've
got jason be config which is move called
nillable config because we're
for null values here what I've done is
just put that in the brackets where I've
got doc create nillable config you don't
have to have that they can do dot create
with nothing in the brackets and it will
just follow its own defaults rules to
create the jason and it will just
serialize for you in the middle there
we've got on our three three fields
we've got symbol which i've just left uh
nana Tate 'add I've put Jason be
transient on the string description
since just to demonstrate that we might
have like quite a long or quite a heavy
data field that we don't want to
serialize or it might be maybe an image
or something in your class that you
don't want to see a lot of - Jason Jason
be transient we'll just set that to be
ignored we've also got a Jason B
property there so again because this is
liturgist in each every time a
generating random numbers and it's a
stock ticker thought it's probably good
to let people know that this isn't an
actual stock price it is just a random
number so that will just override the
actual price and that will mean that in
the json object that you get back that's
what gets picked up there and i've seen
in the demo we needed to change our
javascript class to from looking for the
dot price to look into dot random price
actually always that would not be found
so move on so I'm gonna ask Andre to
again come up and talk a little bit
about the jax-rs reactive client API so
this wasn't something that I actually
included in my own demo but I thought it
was actually quite a significant feature
of jax-rs so I wanted to mention it
fortunately Alex tdum who is here and
doing some of their own talks do go and
catch them if you can this is a very
good speaker
I'm sure his demos always work he's
written this blog post which is very
good investigation into things and he
goes over a little bit about the
reactive client API just here so the
reactive client API is like improvement
of the API with that's that was there
already with Java EE 7 and it was called
a synchronous client API and it was
based on the Java 7 it couldn't use
completable future or not all these new
stuff in java 8 like lambdas so it
provided more cumbersome API then it can
with Java 8 but previously with video
synchronous API you had an option to
provide a callback when when you send a
get request to the service and the call
wouldn't be blocked so you can continue
doing some other computations in the
same threat and then when the service
call was finished the the application
server would execute the callback
usually in a different thread and
without blocking your original threads
with this was a cumbersome because you
needed to provide a callback as as an
implementation of an interface and there
was no way to simply chain other
execution on top of other executions on
top of it so if you just execute it
another synchronous call within the
callback you
- spaghetti code which is referenced as
callback hell because there you have too
many brackets next it inside complex
nested inside so with a Java 8 there is
a new thing or it's not already it's not
new but Java 8 what the completable
future has new thing which allowed to
chain these invocations and to create
readable code while it was still a
synchronous and with new tracks are so
reactive API it's now possible to chain
the callbacks with completable future
but don't know not only with computable
future but you can plug in your
alternative mechanism for example rxjava
handler which are is Java is quite
popular when writing a reactive code and
John Jarvis natively supports it so you
want the only thing you need to have is
a factory that can turn the result of
the service call into an hour exert our
observer and then we can use it within
the same fluent API of jax-rs no need
don't need to wrap it into a different
object you can just change the method
calls and just change change the return
value to what you wouldn't need to work
with the library so that's my nice but
it by default the reactive call would
return a compostable future or motor
more precisely completion stage but you
can override it and have a plug in your
factory to return a different different
time so you can easily change more
computations and turn it into the stream
of invocations it's it's not technically
a stream of data because simple reactive
simple rest call would just wait for the
rest coat of thing to be finished then
it can turn it in
or process it into a java object by
parsing JSON or XML and then you still
have the final object in the end but it
makes it easier to write synchronous
code so that your original blah thread
is not blocked if you want to use reals
streams with jax-rs you would go with
the SSE the server sent events which
allow to initiate a call and then in the
server can send individual events stream
of data as a server sent events which
you can again chain with a complete loop
of future callbacks so that's the new
addition of reactive client so CI back
to the application that we were talking
about so the server sent events is
really the thing that I wanted to to
talk about here so I was playing about
with certain events for it for this
quite a few months ago now actually but
basically the jax-rs specification
wasn't finalized at that point so all I
was doing was really just using the the
Jersey implementation of it which was
kind of where the jax-rs Edition had
come from so we can see here we got this
SSE endpoint here or this is the Jersey
API is not jax-rs but I wanted to have
it here just so that you can compare
what it was like to what it is like now
so here you can see that we are
returning type of event output annotated
with producer of sse featured observers
and events obviously now we've got a
proper media type you know that we can
produce so we needed to create a new
thread and do everything in that
separate thread nothing in there is
particularly
complicated but it's a lot of extra co2
right and just a lot of extra chance for
bugs so just to compare that with the
jax-rs code really it doesn't even need
to be as complex as they even it can be
as simple as just SSE broadcast
broadcast that you can see down the
bottom there so the reason that we've
got two methods is that there is a get
to end point which can receive a client
request as an SSE event sync now this
event sync is just something that you
can register in your broadcaster so that
then the second method is where we
actually broadcast events so because
we've actually also annotated the second
method there with a post it means that
you can not only you know call this
broadcast method from within the same
class within the same application you
can have like a separate micro service
that sends something to be then
broadcast by a separate micro service to
all of its consumers so you can see at
the top there the first one I've got is
the event output one there's actually
two lines there the first isn't
necessary but it's an example of how you
can just send a single event so you can
use that kind of API there but the the
SSE broadcaster I think is the really
useful one for the purposes that we want
now the next thing to think about is
from an architectural standpoint is
where where do you plug this into the
application see at the moment I've
already got CDI events close to CDI
events between the stock ticker and a
stock web services and then I've got
WebSockets in the front-end so we could
do is replace the WebSockets on the
front end so we've still got a CDO event
bus between the stock ticker and the
stock web and then it's just the
JavaScript SSE client that we have to
that we have to create basically own
that the changes between those and
fortunately haven't got those on slides
but they are minimal
it's not much to do that but when we
spoke a little bit earlier about the the
way that we manage these things the
other option that we've got is the
jax-rs SSE client and really that the
decision here is where you want to
orchestrate our micro services if we've
got a more complex scenario with this
where you've got a particular functional
process that you want to run with
several different work so you think five
or six would you want to orchestrate
that within a JavaScript browser-based
application or would you want to
orchestrate it on the backend and then
have your JavaScript web page be more of
a thin client to it I would generally
prefer to do it the second way have
everything be kind of orchestrated at
the backend and then have a thin client
at the front but I know that's not
everyone's preference and either way as
possible so again I have a look at the
SSE client code so from within jax-rs
now this is the old jersey method again
we can create a new client builder this
actually quite similar to the new jax-rs
api but we're just using different
objects and things here here we need to
actually return the event source and
we're doing create a new client builder
registering that and targeting things to
a stocktake a URL so we need to know
this URL in advance which is tricky
we've got a way around that I'll talk
about later the event listener we need
to add and then register to the events
source so we just create a new lesson
that obviously this was slightly old
code so actually that could be replaced
with a lambda rather than an anonymous
method this is in jax-rs 2.1 so we've
set that into basically the three
different methods that we got
an EJB that I'm doing a post construct
in a pre destroy on the post construct
initialized everything's very
initialized the client in the web target
exactly the same as before and we're
setting the source as an SSE event
source rather than just a normal event
source and then just calling the observe
method so in the observe method this is
how we actually consume the event so
we've just got a nice brief lambda there
just to handle all the events that come
in again I'm using Jason B API to
deserialize
stock events that come in and providing
the throwable print stack trace
method reference there for anything that
goes wrong so we don't need to handle
that in any more detail and finally I
just do source not open and then these
events will start to be consumed at the
end there I've got a destroy method to
gracefully close that I saw so we don't
get any errors on the remote side and it
just finds the client consumer just
disappears
this was the if you wanted to sell
JavaScript to do things so in my
particular example because I'm running
this on a or I would have been running
it on a laptop with everything was
localhost you can see that obviously
you've got cross origin issues if you've
requesting from two different ports so
I've got a little diagram there that I
got from developer mozilla.org and I
won't go into that this is just a
standard response filter for jax-rs just
adding that a single header just to say
yep it's okay the cross origin request
don't matter for real this wouldn't
really be a problem because they would
always be from the same domain so we'd
know that that was okay so really ahead
of schedule now but yeah so the next
thing that one is to look at so we've
added a few jar v8 api's to kind of make
things a little bit more generic what a
next one is look at was the future of a
Java EE and where it might go
or II for J or whatever it gets called
and it furtively because I think a lot
of the people that are involved in the
micro profile efforts have got grand
visions that actually micro profile
itself is gaining a lot of traction a
lot more than I think than many people
expected I think there is a strong
feeling that the future of Java EE if
you want to see it now look to micro
profile personally this is again like
completely my personal view I think
actually this is really is the future of
Java EE whether my profile gets subsumed
into it or not I don't know I hope it
doesn't I think I quite like it as a
separate project where we can innovate
and it has that extra freedom to just do
things that people need I know that IBM
and Red Hat are investing heavily into
it they've got quite a few people
working on it we empower our as well as
our Tommy tribe but then also we've got
tons of people in the community so we've
got lots of community Apache committers
that are putting a lot of time and
effort into micro profile and that the
whole goal of is to be really really
community community oriented so anyone
who wants to get involved with it can it
can get involved with it there are
stands actually in the exhibition hall
downstairs so you can go and find out a
bit more about it and how to get
involved Oh
put some transitions on there yeah so
here is the dependency for the 1.1
version which is the current release
like I said 1.2 is imminent it's
basically code complete at the moment
you need to you know specify the type is
parm and specify that's provided because
it is just an API there's no actual jar
implementation yet the implementations
are provided in the same way that Java
implementations are by vendors so those
are all the things that you need to do
to set how a stock ticker URL that we
had on our sse client class so now the
issue that we had there was that
we had our jax-rs clients that needed to
connect to a URL that it didn't know
already because you don't know where
it's going to be until it starts up if
you're in say communities where the
remote server might not be there yet we
don't know we don't know ahead of time
where the endpoint is going to be it
might change and we need to react to
that so the config API gives us the
ability to look for a property that we
set in as far as the API is concerned
three places
that's system properties environment
variables and a file in the is it the
the meta-inf or web-inf for the config
property so it's my perfect mess yes I'm
in the meta-inf by an F directory of
your application you can create a micro
profile that properties file which has
all these properties in and that's a
valid config source as well each of them
has got different ordinal priorities so
that you can always know which one is
going to be preferred so we're injecting
that that how to set a default value as
well so that we can you know handle if
it's not there and that's all you need
to do to use it there at the top I've
given an example of how to actually run
everything that we were doing there so
the stock web application here it's a
micro bundle we really kind of in the
project we're kind of building a new
bridge our with PI our micro but I'm
setting the micro deployed at stock
ticker dot URL property as a system
property and that will be then picked up
by the application which works
beautifully if I had a demo but there's
also another option that we've added for
pi our server
obviously there's we that are familiar
with GlassFish if you haven't used pyro
server yet and you should definitely
check it out but we've added a few extra
AAS admin commands to set and get
conflict properties the reason why I
wanted to demonstrate this one here is
that we've got
property name property value are quite
clear but then I've added the source of
cluster so I said that there are three
default sources for the micro profile
config API those you can rely on for any
micro profile implementation whether
it's waffle ice warm liberty or Tommy or
payara
that they're reliable here though we've
got a source of cluster so that means
that all those properties then can be
stored in hazel cast and then
distributed to any other cluster member
that joins that cluster at any later
point in time so once that's been set
any other member that joins will get an
store that cluster so that if your
initial member goes down the property is
still set and is still available for
your application which again when we're
looking at things that are using things
like our at clustered annotations who
got close to singleton that will still
be available to that singleton when it
starts up later on so that's quite a
neat little convenience method there so
really really ahead of time I hope
you've got like 50 minutes of questions
maybe I'll prepare to talk without a
demo next time so yeah I'd wanted to
recap a little bit about what we talked
about I'm mostly highlight the fact that
a huge amount of what I've talked about
aside from the API is has actually come
between four years previous when Java 7
was announced to this year when joffrey
8 was announced all of this has not come
from the Java EE specs themselves it's
come from the vendors seeing what's
happening in the world around them and
reacting to this kind of change so Java
EE is incredibly adaptable and the the
vendors themselves that have created
these new distributions I even spring
which obviously isn't Java EE but does
use y2 Java API s and even their
influence is helping to kind of drive
things forward and even though that
there was definitely a significant delay
in the release of Java 8
the industry didn't stop moving and
there's been a lot of change that's been
driven by illness implementations and
finally just that Eclipse micro profile
is I think where there's a lot of
innovation happening at the moment
there are lots of interesting specs if
you are really interested in looking at
my micro service deployment it's really
good to look at if you go down to the
Exhibition Centre at any point I think
during the conference there will be
demos of Micra profile happening there
so it'd be really good to go and check
out and hopefully I think some of those
demos should include some 1.2 specs but
because they so new there's not many
implementations around just yet and I
think that's everything that I had was
everything I had without my laptop CI
sorry that things didn't quite work out
as planned
yeah are there any questions we've got a
lot of time for them yes great
yes yes yes
well I know that sorry okay yes so I'll
repeat the question so that the question
was that the clustered CDI event bus
obviously is very pyro specific and the
question was do you know if there are
any plans to get that to be like a
proper standardized feature I know the
CDI to brings asynchronous events on
table know a bit more than me about that
but it's not same thing there my my good
feeling is that it would be very
difficult to standardize on and the
reason for that is that even the the J
cache specification which is provided by
hazel caste is that does not actually
include any clustering and I think there
is that there is not a lot of appetite
from people writing specs to include any
sort of clustering technology as part of
the implementation so yeah it would be
amazing if it could be I think it would
be such a useful thing to have but I I
would be surprised if it does yes
absolutely yes and it's something that's
in in player obviously we're looking for
with PI or a5 the intention is to kind
of remove the old domain model and go to
more towards a domain data fabric so
yeah it is going to be much more like
that I know vertex I think are quite
similar in that they use hazel cast as
well I don't know if they've got any
similar kind of technology to the
clustered CDI events but what ups they
don't figure would any sort of events
think that they obviously have messaging
the but their time of messaging
messaging mechanism is based on the
sending JSON data so that it can be
distributed to any kind of language
because vertex supports not only Java
but Java Script groovy and other
languages but they also rely on the
handle cast equality and
like distributed data grades are very
interesting because there are quite easy
to setup
they're very complex so you wouldn't
want to write them in your application
you'd rather use a existing proven
solution they provide lots of
interesting features and they are very
easy to use and the to show that and the
city has been even buzzing by our
microphone by our server a demonstration
of how easy it's it's to integrate a
zorka's to build a solution to
distribute messages we are CDI and in
fact the API which is in power is only
two annotations so you can and these two
annotations are basically qualifiers in
CDI
so even if the implementation is not
there an Iranian application an
application that uses CDI even boss you
run it on a different application server
you can still plug in your serial
extension or just a CDI observer and
plug in your own solution it can be
based on hazel caste when you have to
create and create it by our server and
micro have have it built-in but even
just use the PI API in these two
qualifiers you just put the dependency
on on these two qualifiers and then you
can plug in your own observer and
distribute the messages yourself if just
PI R makes it easy because it provides
this list for you but it demonstrates
how easy it is to plug additional things
with the help of CDI the CDI API is very
very easy to use very straightforward
and very easy to plug in two additional
extensions
yes I guess it were there anyone else
that had questions or we've got a couple
more that we can carry with I guess yes
yeah
yes so I thought that myself
I don't know particularly why that's not
half of their then if you are too
familiar with it personally I'd like if
that was the case I'd like to just be
able to see you lie straight to yanil
because I'd be really nice yes
yeah yeah I mean actually on that point
Andre pointed out the other day which I
didn't include in the presentation that
obviously service and events has got its
own convenience methods for serializing
to Jason formats as well so that there's
a lot of this kind of almost like I just
repeated things in my opinion is that
maybe Jason as a format is a bit
different from eczema and jugs B was
specifically designed for axonal and it
lacked some some support for edge cases
in in Jason that's why I created they
created Jason be to support it as a
first-class citizen to support azem and
some some application servers I'm not
sure about bias but some plication
servers support in Jack's B annotations
to convert an object into JSON and back
but this was kind of limited to if you
hit DC each case use cases it was hard
to get it get the result and you expect
it would work but if you really want it
to conform to specific format in the
JSON serialize data it was hard to get
the names of the fields right it would
just create a random random fields but
there is obviously no schema for JSON
but if there was it will be hard to fit
the schema and make it valid against
this the schema
so Jax B is possible to use and it was
used
it wasn't standard Standa was normally
it was standardized against a against
XML but some application servers also
could use Jack's B annotations to
produce Jason and also opposed to Jason
but it was lacking some features and
since juggs B is already a part of Java
language not only Java EE was much
harder to to extend Jack's B and add
some more features into it them to
create a new specification which is
specifically tailored for Jason yeah I
guess another point on that was we just
that I think when Jason B was proposed
it was very deliberately limited just to
avoid you know becoming this how huge
sprawling thing that tried to you know
be everything to everyone I think I know
I know there was a decision made her to
kind of limit it to let's just you know
do one thing and do it well
yeah so I ideally I would like to see
something that's just you know that the
same annotation and the same thing where
you can you know just or plug in
whatever data format that you want but
I'm not enough for a developer to know
how feasible that is so maybe it's just
I have a particularly complex problem to
solve you know and Andres given a few
examples of how it is quite complex
yes
yes that the micro profile config yes
yes yep it is very possible so this was
something that I nearly did with with
with the demo but I thought that if I
did do it then maybe I'd run out of time
ironically so yeah we're basically
discussing this in the office but so
that the use case that I've got here is
that we we don't know this URL fizz
micro-service ahead of time so we need
to kind of run time to discover it
but then the remote micro service that
may also not know it's the thing ahead
of time so really what we need to do is
have the remote one to kind of set a
property in some config source now that
there's a company called I think config
hub which do like a server which can you
know you can set and get properties from
so that the config API was deliberately
I'll let Andre talk a bit in a minute he
helped to specify it or there was a very
deliberate decision made to avoid doing
that so we were they wanted it to be
read-only specifically to avoid things
being set so the it is possible to do
this so you kind of to set a conflict
property dynamically through code what
you'd need to do is create your own
config source right and then set that in
that way using the SPI that's available
so the reason why I didn't want to do
that is because it's moving outside of
the scope of configuration of an
application and into being a service
registry effectively so you know like at
CD or some other ones that I've just
forgotten any others console maybe and
it seemed too far outside the bounds of
what config really was so I don't if you
your honor correct wife
not sure if I correct with maybe add
well you didn't say and simply the
configuration API which is part of micro
profile have has two different
components one is for reading the
configuration and this this provides two
different api's just for playing Java
API with static static methods and with
serialization so that you can inject
values but it also has an extension or
SPI in interfaces oh and you can provide
your own configuration sources within
your applications so you're just
implementing interface when she has I
think four methods one of them is get
get value which gets the name of the key
and you provide the value from from this
object and the configuration mechanism
detects there's your implementation of
config source via second service locator
so we need to create an additional
service file today to find to register
this implementation and configuration
are specific oh it's not a specification
in terms of jsr but the configuration
mechanism specifies ordering of these
sources so there are defaults or config
sources for reading prover for providing
values from property system properties
from environment variables and I have
some value of order or some some index
to order these config sources yes yes
you can you can change them you can
change them then basically the the
source is whether higher order are asked
first and if the value is not there the
other sources are asked until it's found
so you can provide a config source with
higher high order high priority and you
can overwrite any value there and it's
still within the application you just
register it with with the service
locator mechanism with the service file
and
what the configuration does it will
detect the config source it will ask it
for for the value and it will provided
them when it's required by the
application yes
okay it's a really really brand new
feature that it's actually the the demo
that I was gonna run what was it what
was the question that I'm sorry I should
it was the question to get right about
which server which node in the cluster
is the master is that correct the thing
is that the advantage of hezekiah that's
why I said it's very complex and you
wouldn't want to write it it's a
distributed memory or distributed data
cluster so it doesn't have a notion of a
master you just connected to it from
from a node or even from a client which
is not part of the cluster and you can
send the data there and it's evenly
distributed across the cluster is about
support data distribution and
replication so I think but if all it
copies the data three times so that it's
always at least at on three notes and
when any node goes down it's a very
distributed so that it's again on three
different nodes so it's always there and
there is no single point of failure with
has a cost you can you can bring down
any any notes if there is at least one
node the data is there if you have
enough memory on the node to store the
data so it's just enough to to send the
data from a node and is distributed and
then there's no no master it's always
available if the data is not available
the note
hello cards will ask other nodes to
bring will and bring the data from them
yeah it is a friendly feature so it's
it's not even released yet I think we
depending on how testing goes this is a
cluster that clustered yes yeah so the
the obviously the way that I got it in
my demo you kind of start at multiple of
these stockticker
yoruba jars they've all got the
application and if there's already one
running that's running this singleton
then it just doesn't start
the Hib timer and then obviously
wasteful want to go down and I guess you
know however the partitions are set up
so now it comes designates one notice I
took the primary copy of the data and
then like backups around it I don't know
how it would decide which backup to
reinitialize but then that's how it
would work so you had at the moment it's
I think it's just ejbs that it works on
but yeah we I say we the engineer that's
doing it is it's working on the CDI
beans as well initially I was answering
a different question I thought I thought
you were asking about the configurations
conflict source which is also based on
heads of cars with the cluster config
source we have in Peyer micro and bi
server is that you can send or provide a
config source from one of your
applications into or send send the
configuration to the cluster from one of
your nodes and then is available to all
the nodes because it's evenly
distributed with this class cluster
scoped being that it's more complex
because you need to synchronize and make
sure that the data is only once there
and hisoka's also provides locking
mechanisms and synchronization
primitives so we we only needed to put
all these things together to provide
things for the Java EE API because hazel
Kyle is not to it it doesn't know about
Java EE so we essentially want to do and
what we are doing and Empire is bringing
all this excellent features of hazel
cast to the level where it can be easily
accessed from Java EE applications
it's the same with Syria even bus we are
using helices topics and as Acosta
queues to distribute the data that's the
the API is very simple it's just two
qualifiers and the same with the CDI
scope is just one called one
scope annotation and it provides these
things base or handle cast and
synchronization okay any other questions
no I think well thanks again for bearing
with us we got through it just about
yeah I think we've actually got a demo
that's sort of similar to this on the
payara stand in the exhibition hall so
if you want to kind of come and see
something that's actually uses raspberry
pies as well you do drop by</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>