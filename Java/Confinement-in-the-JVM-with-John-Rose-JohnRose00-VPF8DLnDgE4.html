<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Confinement in the JVM with John Rose @JohnRose00 | Coder Coacher - Coaching Coders</title><meta content="Confinement in the JVM with John Rose @JohnRose00 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Confinement in the JVM with John Rose @JohnRose00</b></h2><h5 class="post__date">2017-07-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/VPF8DLnDgE4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to the jvm language summit we
are now online alright I'm going to talk
about confinement I'm going to back up
and talk about abstraction I'm going to
back up way up and talk about the
history of logic a little bit and then
I'm going to give some proposals
assuming I get through the whole talk
but I want to say that Java gives you
really good abstraction they give it
gives you abstractions that are defended
at runtime as well as enforced at
compile time and that's that that gives
you thank you a lot of confidence when
you're trying to reason about what your
classes are doing what your objects are
doing sometimes a good abstraction will
have to be paid for in learning curve
but often the often time it's usually
worth it if it's a well tuned
abstraction a bad abstraction is really
expensive much more expensive than a
good one so if you're tired of having to
pay for say a garbage collector go back
to using malloc and free and see how
that costs you usually not always but
usually if you want to you want to let
the GC do the heavy lifting for you
they're not always but when you have
when you have a badly tuned abstraction
something where the invariants are on a
good day only or the invariants have
lots of fine print in them you will pay
for it even though your implementer says
well this is the best I could do cheaply
for you so Java is proof that you can do
better cheaply enough by the way these
I'm going to I'm going to go fast with
these slides the way I like to go and I
I'm a slide pack rat so I put as many
points as I can on each slide and then I
move to the next so what that means is
there won't be time for me to explain
every phrase in here but that's okay I
hope to motivate what's in every slide
for you and if you want to go see more
I've put in links I put in more
supporting detail and these PDF these
will be posted as a PDF
for posterity so we know what's in we
know it's in Java we like with gin Java
don't we and there's the original white
paper lists the the cool stuff in Java
and and you can if you put on your
today's talk spectacles you can say yeah
those are all abstraction mechanisms
classes yes
check abstractions safe manage pointer
you check abstraction and abstracting
it's something that that provides you
and in variant necks traction is
something where you you don't have to
tell yourself the whole story of a
machine that's running you just can tell
yourself a limited story and it'll still
be true the thesis for today is that
there's something that I'd like to
define as confinement which enables and
enhances abstraction and then moving
back to the sort of ground truth of Java
there are some things we can do in Java
which can incrementally improve its
confinement properties for some
abstractions it's really fun to
introduce something like lambda because
suddenly you have lambda abstraction as
a tool right you can you can write new
api's that express new kinds of
invariants new kinds of requests this is
an example of Java growing Java has been
growing for 20 years and we're really
proud to say it's going to keep growing
that the JVM language summit is in some
ways a visit to the future of Java and
where we could get to talk about stuff
before it's fully baked the please move
forward slide all right fine
what would confinement does for you is
it gives you a magic circle around some
piece of code that you want to
understand and prevents causes from
coming in that are unaccounted for
that's that's the basic idea here
confinement again using today's talk
spectacles if you look you can see
confinement everywhere and a good
example of that is class based access
control you put a circle around a class
and you say everything that's private
within that class is inside
a inside offense inside a series of a
barbed-wire fence a series of
protections that prevent people from
just reaching into the class and
changing something or extracting a
secret both of those are bad without
your permission if you want to provide
secrets or if you want to allow
something to change and provide an
access function that's that's not
private so that's an example of
confinement perhaps it's a term that's
so broad that anything can fit to it but
in any case I have some particular
suggestions that will get to freezing
better immutability is something that we
can work on also I think I think it's
time to talk about putting in online
checks for arresting races speed traps
if you will and also I want to talk a
very small amount about lavender
cracking which is a way to have
libraries work more intelligently with
their lambdas so backing up to the
10,000 foot level what is abstraction
let me give a working definition that
when you're faced with something really
complicated if you can tell the truth
about part of it and that truth helps
you then contemplate that part that part
is an abstraction that is pulled out of
the whole it gives it gives the mind
some rest to think about what what it is
that you're you're you're seeing in the
subset the model of the of the whole
reality of course once people realize
that they were doing abstractions which
is as soon as they can talk I think then
it became a game to think about what is
abstraction so of course we abstracted
abstraction and that led to 2,500 years
of very interesting philosophy but it
seems to be a consensus that that is
2500 years old that there is a sort of a
logical account that you want to build
and you want it to be both true and also
not the whole thing so how do you make
something that's true but not the whole
thing relief this leads to like the
medieval discussion about the problem of
universals
quantifiers were discovered apparently
by Aristotle 2,500 2,400 years ago and
they've been puzzling people ever since
when you bring in formal methods then
you begin to enable things like what we
do for our day jobs and so the you can
you can look at our place in the world
as being a top a very laborious we built
our of concepts that started with
quantifiers and brought in algebra
brought in the unification of logic and
algebra by George Boole and then brought
in set theory machines metamathematics
and finally finally finally programming
languages but I think those are all
steps that depend on each other and so
it makes me makes me happy to think not
only that we're doing this cool 21st
century thing but it's also a very old
enterprise I do want to also call out my
favorite logician because he has taught
me his books have taught me about these
about some of these matters in a very
beautiful way he also passed away at the
age of 97 this year and I've been
enjoying his work since I was an
undergraduate and he I just want to
recommend that particular book also a
mathematical logic by Raymond smoly and
it will it will delight and enlighten
you if you were at all interested in
logic and that includes all of us in the
room his his book on set theory and
introduced me to temporal logic in a
just a charming and useful way that set
me up for appreciating some of less
Leslie lamport's work anyway back to
abstraction with respect to computing an
abstraction is when you pull out a piece
of a program that's worth looking at by
substance programs or formal entities a
formal account of a piece of a program
is probably just a fragment of that
program and that's the way I'm going to
go with it
abstractions are separable and so they
need you need to be able to say it's
true what this thing says and I can make
make true statements about this piece of
code and even though it's integrated
with an entangled with a much larger
system the work the role of
specification is very important there
and this brings us to confinement in a
dynamical formal system which is
software there's causes and effects
flying around all over the place and so
you have to you have to take into
account causes and you just as
importantly you have to block away
causes so that they don't affect the
abstraction that you're trying to build
and that's why confinement in as I'm
defining it is a good design purist ik
so there is a boundary of a confined
piece of code has a boundary and across
that boundary causes go out where the
code is affecting something else in the
system causes come in where the code is
being affected and we want to remove the
irrelevant and disruptive causes there's
many examples of incoming and outgoing
causes that you could list some causes
go both ways I don't know how to make
that I don't know how to be couple of
calves into a cause of one cause that
goes in each direction so maybe it's a
bidirectional cause in that case local
causes or of course don't cross the
boundary in there and they're completely
inside the abstraction so you can reason
about them more easily here's a
visualization of the magic circle of a
confinement boundary and here are some
causes and effects that go outside of it
let's let's use an example here is a
piece of code what does it do what are
the possible causes causes and effects
and put your job of puzzler mindset on
because there there can be some
surprising answers here and there
well in the simple case you're just in a
local subroutine and this is the this is
the this is a car essential part salons
abstraction this is what you want most
of the time there's there really is only
a few things that can happen there's a
call and return there's invoke there's
return not much going on that's okay but
if the variables in the heat there's
more to say right that's when you get
interesting stuff going on here's here's
what it looks like when you have a
something in the heat first you read X
and you're reading it from a memory
state somewhere and then you're going to
write X again so that looks pretty
normal but I doubled those arrows to
make them look a little scarier because
they at least scare me one thing that
can happen is the first time you touch a
static is you could trigger a CL in it
call right so that could that could
cause a whole boatload of effect that's
that's a surprise just that one little X
there you might also have a linkage
error if you have a miss compiled class
and and then of course the thing that
really makes containment difficult or
makes containment necessary is the race
condition so here's a here's an example
of a Java CL init call that then enables
the read to continue and return a value
makes sense and here's an example of a
race condition here between the brown
lines somebody wedges in a effect that
that that is going to have to be
accounted for in the abstraction inside
your Magic Circle you're going to have
to worry about that so we want to make
sure that we make a careful accounting
of everything that can come in or go out
of the circle and part of the problem
there is some of our circles are leaking
this is when when you have a abstraction
that works only on a good day but then
on a bad day and effect
comes in from from a place that you
weren't expecting and makes your program
crash that's uh that's what keeps us
paid a lot of us right a lot of days but
I you know of course we want to avoid
this so we can do the stuff and we
really enjoy anyway so I'd like to talk
a little bit about the Java memory model
and this by itself could be a three hour
talk and there are some very good three
hour talks out there I want to recommend
Alexei ship left right up the front is
his blog on this stuff is excellent but
so you know we we know about the Java
memory model because after all we use
Java and Java has memory and memory has
state and James about state and so what
more is there to say really right I
learned something new every time I
reread the Java memory models back and
that was true this week also it's kind
of scary but ok buy me a beer and we'll
talk about it the easy part
threads run concurrently life is great
if you're if you're only in one thread
right what could go wrong nothing really
there's no race conditions at least it's
very easy to wrap a good confinement and
make a good abstraction inside of one
thread threads can communicate through
actions on the heat there you make sure
that those actions are properly
synchronized by use of a combination of
the keywords synchronized final volatile
if those keywords are not in your
program and not in the not in the
libraries you're using then you're
probably going to win the win the race
contest we'll talk about that in a
minute
there are even appear now Java because
Java makes variables variable by default
not fixed it follows that there are
potential race conditions everywhere you
look inside of a Java program you have
to work very hard to prove there aren't
race conditions and therefore of course
the Java memory model does something
which C++ didn't do it said
if you do if you commit an indeterminate
action we are at least going to give you
minimal safety guarantees on it we will
not give you a bad pointer we will not
make up a random value for you that's
good
recent C++ compilers are not so friendly
but even that is not reasons to sleep
well at night there's some more easy
parts here there's something called
happens before which is a concept from
Leslie Lamport that guy's been all over
this kind of stuff for three decades
he's still working on it
so happens before two events well one
happens before the other or they do not
they're not related at all those are the
only three possibilities it's a nice
little eerie flexible part irreflexive
partial order every thread is fully
ordered boring sequential so inside a
thread the events marching in strict
sequence monitor eggs are exit monitor
enter volatile reads and writes they
also are linked by this relation so
we're beginning to build up a partial
order and you know most of you have
probably studied that sometime at some
point you know how that works it's going
to help us stay sane right we hope yes
declare victory no not quite not yet
normal reads and writes which are the
default write in Java if you just don't
write anything special you get a normal
read and a normal right they do not
create these links you think they do I
think I think they do on a day when I
can conveniently forget the Java memory
model but actually they don't they don't
create these causal links they rely on
them what does this mean well here is a
graphic that I invite you to study more
later but the idea is memories in the
middle of a bunch of threads and the
threads are talking to memory and
through they're talking through memory
to each other okay and there are causal
links going from instructions in through
the threads to places in memory and
through to the other side of the thread
the strong the non dotted lines the
solid lines are in the Java memory model
events which which do create these
happens before relations so you can
reason about them in terms of causality
the dotted lines are mere data flow they
are not causally determinative the data
flow rides on top of the of the other
more rare links so that the freedom of
the program to reorder itself is based
on this the sparsity of the solid arrows
even though there might be zillions of
dotted arrows the dotted arrows can be
reordered any old way that is consistent
with the solid arrows so let me give you
an example here I've crafted this so
that there is a um there is a release
and then an acquire that's what this JMM
calls them a monitor exit and then a
monitor enter in another thread and so
the red lines are are some relevant
solid arrows some happens before
relations and you'll notice that because
they connect all the way from one thread
to the other you have a happens before
linkage between two threads that's good
we're winning and that means that the
dotted arrows which are related which
are touching those those red arrows are
also properly ordered with respect to
the two threads so those dotted lines
that have the blue lines next to them
are nailed down by the Java memory model
but all the other lines the lines that
you think should also be nailed down are
not you're you're lucky if you get
something useful out of them you get
rates can they are racing they're racing
lines so if things are that bad then why
aren't we already insane well you can
hope that you're that you have excluded
all races from your program it's really
sad because if your thread is for its
part race free it's very easy for
another thread just to touch it and make
a race oops
both threads have to agree in an shake
to make race free all right but maybe
I've got that maybe I'm like protecting
myself from other threads and hiding my
data
maybe I'm data arrays free if so I went
to quite real consistency and that's ok
not the it still you're still in a world
of hurt even if you have sequential
consistency but that's the prize you win
if you get rid of data races okay fine
answer number two
I'm not I'm not insane because I use a
restricted implementation of the GMM
that uses fences fences of the way it
really works right because that's what
the compiler cookbook says that's not
true Aleksey debunk that myth very very
well I again I refer you to his blog
well you know what that said that's a
temporary condition maybe the JMM is
friendly to me because I'm using the
right implementation of it but that's
not true tomorrow or maybe I'm just
lucky and anybody that gets the bugs
they must have done something wrong they
deserve to fall into the snake pit
or I read a lot of Stack Overflow and I
just know that right incantations and
and I'm so lucky and I'm so hidebound
compulsive that I write the same
incantations every time and so I never I
never get a race in my in my program
that might be why I'm with why I'm okay
some combination of these reasons I
think is the reason why things work also
you know if most of what you're doing is
in one thread then you're okay right
but remember threads are increasing in
number all the time
so we're getting pressure to do more and
more multi-threaded we're going to make
threads cheaper and more numerous when
Ron Presley's work kicks in that's going
to be exciting so what is what a
sequential consistency to round that off
well it's as if you'd shuffled all of
your execution traces together like a
deck of cards that's what it is and
isn't that all isn't that the only thing
you can get aha no my no means by no
means caches actually screw up the
shuffling so that year there is no such
thing as a global memory state that is
serialized there is no such thing as a
unique most recent write in the in the
real world you have to even with
sequential consistency you still have to
guess which interleaving you get but
you don't get really weird like
simultaneous values and the in the same
variable that's what you get a normal
Java memory model in a race the very one
variable can look like it has two
different values in two different places
at the same time so there is no same
time okay
what do you get if you get a race well
this is the thing I want you to take
away I'm going to say it a few times any
given variable when it reads when when
you read it you can see any write to
that very almost any write if it is
racing if you're not if you're not
nailed down by those up by those blue
and red arrows it's pretty stunning to
to actually come to terms of that
reality there are a few cases which are
often enough so that we're still saying
but there are there's there's a
frightening leaf small number of cases
where the memory model says no stop it
you have to read this right when you
read and it's only it's only in the case
that I show you w0 and w2 are the only
are the only forbidden right everything
else is allowed so you better have
everything very strictly tied down so if
you have some other racing
double-oh-seven variable out there that
it's writing to your variable like like
the an attacker and I fix security bugs
like this you have to buy me several
beers to hear about that one but you you
you have an attacker that goes and it
takes a perfectly well structured
program and he manages to get a
reference to a variable and he smashes
something in racially in a concurrent
thread you can you can you can break the
system you can route you can rootkit the
system so in practice we avoid crazy
stuff but we don't avoid it well enough
to avoid bugs and security escalations
we sprinkle the right keywords on it but
if we don't understand what we're doing
or if we don't have more help that's
what I'm arguing for today then
we still have problems we can make it
better without class-based encapsulation
where yeah you can actually make
variables private so you can really
prove invariants about who can touch
them we'd be in a world of hurt
we wouldn't be we wouldn't Java would
not be what it is today without without
privacy okay here's an example of a
double of seven guy coming in there he
is
ha you thought you had a perfectly
nailed down program but if you let it if
you let a reference get out to one of
your variables and some attacker or some
doofus made a thread to go and write to
it
it's just it's a tentacle that reaches
in and spoils the the delicate symmetry
of your of your program here's a worse
case suppose you have suppose you read
the same variable twice back to that
what could go wrong well you can
actually the Java memory model says any
a read can read any write that can
connect to it and the connections are
very broad there's there very few
limitations on the connections so those
two r1r2
can read the initial value of a or the
initial value of the of the start of the
variable it can get a
nullpointerexception on a it can and
either one can read either of 42 or 0 in
any order it's just that's the way it
really works if you don't put volatile
final or synchronizing your program
that's what really going to happen it
just doesn't happen that often that make
you feel good it's a little tiny little
gap in the containment sense all right
yeah you that's why you put volatile
everywhere now the the double-oh-seven
guy this is this is a real thing that
really happens and causes lots of damage
there's a thread double-oh-seven that's
just pouring bad data into some pointer
he's gotten hold of and the poor guy
who's trusting this the memory model
that doesn't really exist because it's
only in his head as a wishful thought he
says lost anody checks the operand and
then I'll use the operand what could go
wrong well you sanity check a good
operand and then a microsecond later
it's a bad one or vice versa yeah this
is very bad bear arms because in bear
arms you don't even see the array
creation so it's hard to see from the
source code that there's a piece of
mutable state that can be manipulated
and yet this is this is one way that
black hats get in ah what's to do yeah I
just wrote a poem to summarize all right
let's talk about what works let's put a
volatile in there and let's hope for
something better
so there's a there's a release when you
read of all there's a reason released
when you write a volatile so key one
does a release and t2 doesn't acquire
and at that point you do have some
causality that's nailed down unless
somebody manage to get a handle on a and
is putting garbage into it concurrently
so I here's a here's a reference to ship
elapse discussion called Close
Encounters and this particular
interesting area is in his blog is
called avoiding pitfalls in the terms of
the previous diagram there's a release
when you unlock or write a volatile and
there's an acquire in the other thread
when you walk and and or read the maybe
the corresponding thing on the other
side and that's what gives you the nice
red and and blue lines where all of the
story uncertainty can't be wished away
it even if you feel close to the
hardware and you're writing those
non-volatile racy reads and writes and
it seems to be working and you feel like
you and the hardware have this really
good kinship going on sympathy you know
with the mechanics of it it's it's not
going to last
sorry if you can't actually code to a
spec then you're racing somewhere that's
nowhere
Lamport said in one of his talks aspect
is more important when you don't know
the program is doing it so that's not
when you treat the spec as optional
either coding - or writing a spec how
many of you have noticed that the recent
C++ compilers are getting more
legalistic with you and and giving you
bad bad results because you transgressed
some little tiny corner of the language
you know you know I've been noticing
that Java has always gone a different
way
Java doesn't say unless you could make
the optimizer happy it's going to give
you bad data haha Java says we're going
to give you something reasonable and
we're going to make it fast that is an
awesome feature of Java and it's related
to the online checks that it does it's
more important to do this it's more
important to get it get these things
right at the invariance level at the
programmer service level then let's make
the optimizer go fast level let's get
the optimizer in spite of the language
by the language semantics so anyway once
more bad news is unless you have
releases and acquires there are bases if
there are races any read is a candidate
for any write any right is a candidate
for any read and you know you're
probably not okay with that there's not
much more to say than that you don't get
values out of the air but that's the
only good part about it there are benign
races but they're very hard to set up
right and you don't get a diagnostic if
you make a mistake you just get a race
and it works you know 99.9 percent of
the time the best benign race is when
you write something exactly once this
only works for final variables because
other than final variables the Java
memory model will give you give you
a racer a choice of two rights the
initializing right and the right that
you wanted
oops and the second best is when you're
okay with all the values that the racing
rights are writing not sometimes that's
okay but it's not okay as often as you
would wish we could impose sequential
consistency all the time thereby sort of
removing races by you know my Fiat it's
it's debatable how slow this would get
there's a silently shifting semicolon
that claims hand-wave hand-weave that we
should really do this and it's a java
like thing to do maybe to just say what
we're going to do no more races and
we'll figure out how to optimize it
anyway but um we I I think that the cost
would be would be enough to make people
go to C++ instead of Java and that'd be
sad for me people who need races even if
we went to going to consistency
consistency you could use bar handles so
that's a good thing
races are sometimes the best answer if
you're willing to take all those caveats
and the multiple indeterminate values
and you can trust in Newton which is the
not out of the air invariant that JMM
museum it's not a cure-all though it's
really hard to manage mutability even
under sequential consistency which is
the grand prize of the java memory model
so have you looked at the boilerplate
lately on sorry Brian on on the streams
API Brian and his team did brilliant
work writing this all up but when it
comes when you come down to it it's one
of those specifications which you say I
guess I can learn to live with this
given how useful it is for me but it's
funny that it can't be simpler isn't
that right
so sequential consistency if you win
that you still lose the the game of
statefulness the complexity of streams
even under sequential consistency comes
from unkind effects it comes from the
fact that when you pass a lambda in
nobody can prove nobody can check that
that
lambdas doing the right thing it's not
confined stateless lambdas need to have
the right restrictions on their
causality links you need builder draw a
confinement circle around a lambda and
prove that it's stateless at some point
and I'm thinking wouldn't it be nice if
you could crack the lambda and examine
it and say this has only stateless ops
inside of it and have that be inside of
an at least an assert in the library so
that when assertions are turned on your
library will kick your lambda back if
you put the wrong you know system out
print line in it that would have some
use wouldn't it so a stateless lambda as
as the oil afflict says it can't it
can't be the cause of side-effects it
can't have outgoing causal links to go
you know do something change it press a
button or print a print align but it
also can't have incoming causal links
these arrows go both directions and the
two cases are distinct so it can't it
can't be the effect of a side cause and
I hereby claim the term side cause as
the arrow reversal of side effect so a
lambda needs to be neither a side effect
side affecting or side causing a side
caused like I say it's it's not
verifiable it is like the Gary Larson
cartoon where the the family is sitting
in their living room and the kids are
writing tricycles around the living room
and there's a snake pit in the middle
and the parents are smiling to say now
Joey stay away from that snake pit okay
not even that's kind of that's with
respect to mutability and race
conditions that's where we live so all
right I'm just whinging right all right
I'm going to go through a another
history a logic kind of a thing to try
and bring a few points out of talk that
Ron Pressler gave in 2016 that curry on
that was really good
surely a smart group of people like us
can just calculate the right answer a
static analysis that's really clever
like including a program or staring at
it as well as tools that's going to win
every time we just have to know right
we're human beings that's what we do we
know we know stuff and in fact you know
we must and shall know that's live nets
and
and in Hilbert Gilbert was saying it's
just about the same time that oh by the
way have you as your boss said smart guy
like you can give it to me next week
right because we really need it right
and I'm sure you can figure it out
there's some what's the pointy hair
bosses slogan anything that's too hard
for me to understand must be easy all
right
while Hilbert was saying we have to
understand girdle was young fellow was
proving that not all proofs could be
automated and and our friend Turing was
saying not all automata can be proven
difficult so it's not just a matter of
training talent discipline there are
some things that really are too hard and
there's a theorem by Rice that says
anything that you need to prove about
software that isn't trivial is going to
be occasionally impossible to prove
except by running the software and
there's actually get out of jail card
for that and Java found it which is put
in the online checks if you can't prove
that the array range is statically in
range no problem we've got an online
check the Turing machine can run a long
long time and do complicated stuff but
we're going to check that range check
every single time that is a safety
invariant that you can win with and then
if the if the JIT can prove statically
that you can remove the check B win - so
here's a link to um to Ron's talk it
pairs well with his talk this year
because it was interesting to me I went
and grabbed some hard problems from
Wikipedia or you know other places like
that and some of these are ones that Ron
quoted and I graphed them again I graph
the the the difficulty of the problem
against the number of lines of code it
took to express the problem okay
so way down there at the bottom left is
people
two equals four and hotspot is it's got
a lot of lines of code in it and it's
about two-thirds of the way up the
complexity spectrum both of these scales
are logs so simple code is over here on
the left unaccountable behavior remember
an abstraction is where you have a true
account of a subset of the behavior but
if you have unaccountable behavior
there's it's not abstract about and in
particular the universal Turing machine
on an arbitrary input that's not
abstract about except in Reverse you can
say it you can't you know you can't say
anything about it that's about the best
we can do and there are busy beaver
machines which also can't be abstracted
either are difficult or cannot in
principle be abstracted so even even
small even small things can be
unaccountable that should make us pause
when we put think about putting our
trust in static analysis there are
things that are so hard that we can't
even in that we can't even analyze them
with the best minds on the planet a
little checker tool is going to fail
sometimes won't it yes all right here's
some more details as we look at them and
you're in your in your spare time this
is where the numbers came from so our
our safety checking is never finished
Java safety checking is inherently
dynamic it's good that it's dynamic and
you get to pick one you get to pick that
online check or you can trust to an
offline check if you're smart enough and
sometimes that won't work or you'll get
an error when it doesn't work that's
those are the choices so you can have GC
or you can have handmade storage
allocation which under the right
data-dependent turing-complete
conditions will fail you can have a
verifier enforced runtime type
information or you can hand check it and
blah blah blah it's going to fail you
can have array range checks or you can
hand solve the Daiya Fantine equations
ahead of time and all yeah not just
havoc prove that that's turing-complete
to so you're going to get buffer overrun
once
while or and likewise the new thing that
I'm proposing is you can have online
race detection or you can be static
concurrency checking and you know I I
balling of code and then when that fails
you'll get races and various kinds of
excursions and behavior dynamic safety
checks as I've been saying our
superpower
this is java's excellent trick putting
in dynamic safety checks that are
strictly more powerful than anything
people with Plus can do for you and make
them cheap enough it's it's so it's the
reason Java is around I think it's one
of the reasons one of the big ones so
can races be made rare and obvious and
self-diagnosing maybe we can do it maybe
we can get our users away from the snake
pit let's at least make a mutability
easier to do Amber is working on this
but wouldn't it be nice if mutability
where the rare opt-in for new code we
can do that we can rehabilitate racy old
types maybe arrays arrays are a thorn in
our side because they're a special case
you know for everything let's freeze
them let's make them freezable at least
that's pretty simple harder would be
defining some type state that would make
objects feasible also but we're working
on that that some parts of Valhalla will
help with this and then maybe there's
some new safety checks we can add simple
to check for rights to immutable rights
to frozen objects I should not say
immutable because it sounds like
immutable right in the audio domain
those two words that are opposite and
meaning sound the same so maybe I should
just stop saying mutable and immutable
in any case there might be some other
things we can check too why should you
watch for racers if I haven't convinced
you already well you know it's time for
a break almost so but here's a few more
points fast fails better than slow fail
fail fail under load after you've
shipped the product and people are
relying in a new that's the worst of all
we can do better
relying on lucky hardware means you're
locked into that you're married to that
hardware if you in that hardware have a
special understanding
and it understands how you really want
the Java memory model to be you're
married to that hardware it's going to
be very hard to when the breakup comes
and the rest of us are going to move
forward to better jets better hardware
and then you're going to be stuck on
that you know there's less there's
better abstractions if the racers can be
can be arrested so some design patterns
immutable objects we can do it today
can't we there's some there's some
wrinkles with immutability there's some
things that are hard to do with with
today's language but it's it's workable
and lots of people do use immutability
well the best is to have mutability be a
a parameter to each object so that you
could say well this object here is
mutable because I'm busy making him up
and he's in a hidden state and then I
say freeze and then he's done and then I
can hand him out and he's immutable
that's the ideal don't have a don't have
a fully worked-out proposal for that but
I think that's where we want to go with
arrays it's really easy you just take an
array and then you make a snapshot of it
and what the out of the snapshot Factory
comes a frozen thing right that's the
obvious way to do it race so you do one
copy to get the freeze we might give
users control over the freeze operation
that's already in the JMM you extra
points for using stuff that's already in
the JMM because that's a sunk cost if it
makes sense the serialization is a place
where mutability and the immutability
are muddled up very badly and so in an
explicit freeze operation we've talked
about this at length in some of us would
make the serialization a lot saner so
frozen arrays it throws an exception
kind of like an array store exception if
you try to write to it that's it at the
point of the arrays creation the Java
memory model says by Fiat that this
array acts like it has final variables
such as a freeze operation with respect
to the Java memory model so there's an
API
this would help a lot with their arms
this would probably cut out some future
security bugs that haven't hit us yet
okay stable variable just something we
use internally it's a variable where you
can see either the default value or the
one right to the value and it's okay if
you see either one eventually hopefully
you see only the written value but it's
okay if you see the default value this
is a super useful concept inside the VM
right now for family only because
there's no mechanical checking that it's
used properly if it were to be given out
to everybody unfortunately it would be
abused not by anybody in this room but
by blackhat hackers looking to introduce
race conditions yeah and arrays can be
stable as well as frozen monotonic
variables you know you could have
variables that only count up so you can
you can make conclusions about their
state if you see a state then you know
that the future states will will never
be lower than that so you can take that
as some sort of a given so there I think
there are interesting things we can do
in this area if we want to build new
kinds of abstractions based on
controlled state changes but the real
important thing is mutability and thread
confinement how about a function that
says assert throw an error if this thing
is not already confined this object if
it's not already locked by my thread
that by itself would be a optimizable be
fairly easy to use and see it would find
a lot of the race conditions that
currently go under the radar a simpler
version of that would be well you might
be able to build on top of that
primitive a race resistant class where
all of the accessors had that little
race check in them and maybe we could
build them in a implicitly like in the
compiler and the vm but you can put it
in the put field so it's a new kind of a
volatile field it's a race race
resistant field don't know whether to do
this there is another design pattern I
think we're looking at which is the
thread confined class which is an object
that just basically wakes up and he's in
a thread from
from birth right there's no lock
operation on him his constructor puts
him in the thread and then thereafter
any anybody from outside the thread that
touches him blows up that would be also
cut out a lot of the sort of typical
race conditions that we see in in when
we when we go observe them this pattern
can apply to arrays to I we are
experimenting seriously with this design
pattern in Panama as a way of managing
off key preferences safely an extension
to it would be being able to take these
objects and hand them off between
threads using a handshake that would be
well you know release acquire handshake
between threads another clot here make
the best of the object etter we're
already spending 64 bits on every object
here for what for synchronize which how
many people use it all the time well you
know it there there's Doug Lee's locks
which are often better for particular
purposes wouldn't be nice if we could
somehow integrate the Doug Lee locks
into the object header more closely make
them more programmable so the assert
locked
proposal is an example of making more
use of the object header also we're
going to have to put a micro lock for
four fields that are multi-word but
Atomics and that would be another place
for it and there's other things we can
do with we can reply some of our bias
locking adventures which failed because
of something called lock revocation
which if you're doing this kind of
structured confinement model you don't
have that failure case so you can bring
back bias locking as an optimization
alright just to give you an idea of how
I think some of these ideas could apply
to current projects that you will be
hearing about the rest of the week I'm
going through this fast is in the last
few slides valhalla the value types
because the value types are confined
both it can be stored in registers yeah
we win because we can confine their
reads and write under atomicity we're
going to need some help with that and
that's another way that confinement
can be improved by by multi-word
valhalla types maja also includes
specialization we might be able to tie
special JMM behaviors to certain system
polymorphic value holders pact lists
will provide alternatives to the array
see arrays and maybe we can behave on we
can specialize on on behavior of locking
as well as type in amber of course we're
trying very hard to get to a immutable
data model for new for a new new code
this is a place where frozen Ray's would
help defense of copying by the way is
bad for the same reason mutability is
bad it's like it's a cost you have to
pay over and over again to try and get
ahead of the racers that are trying to
attack you frozen frozen nuts and
immutability gets you away from from
defensive copying project Panama as I've
said we're using minimal value we're
using confinement patterns for scopes
we're also doing the vector API which
we'll hear about later we're using
minimal value types to be able to
describe vectors that can be loaded into
registers and that's something you can't
do as well with objects because of the
Java memory model effects I'm going to
in order to take questions I'm going to
skip over this but there's there's a lot
of places in Panama which have excited
me into thinking we can do better with
immutability we can do better with
confinement we can be do better with
with type type state project metropolis
needs certain kinds of confinement in
order to for example if we're ever going
to be able to execute bootstrap methods
ahead of time we're going to need to be
able to take those those method handles
and say you owe method handle I can tell
that you're safe to execute at compile
time
that is a confinement problem if we want
as Bernard said to load Java code into
the JVM and have it become part of the
JVM then that Java code that's part of
the JVM needs and
interfere with the application Java code
like by causing GCS that that are
embarrassing that isn't that is a
confinement problem it's true not just
for all that it's perfect any part of
the VM that we code in recoding job we
recode the verifier in Java I'd like to
do that someday it's going to have to be
confined by a special Ã¤Ã´t algorithm
that keeps that verifier from have being
affected by or affecting the wrong parts
of the VM so yeah I've said confinement
a few times the main point is our
mutability story needs some help so
let's at least add freezing that'll
block a lot of bad right and make it
easier to pick the right right for every
read and maybe add race or arresting and
let's say aim for libraries which can
can work with can confined lambdas which
means really cracked crackable lambdas
we're going to need to work out rules
for what it means to have pure code and
data
luckily the D language and C++ and other
languages have gone there ahead of us so
we have some selected sedimentation we
don't need to make that be a science
project doing pure code and data that's
cool there you'll see on the goodie it's
part this year's graphic it's a it's a
thread spool obviously but it's um it's
somehow alive the threads are an
invasive species here and but they've
been confined in the in a davinci
polyhedron so we're safe right and that
takes me to the end I have a few minutes
for questions and I thank you for your
attention</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>