<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Frontiers of Access Controls: Modules and Nestmates with Karen Kinnear | Coder Coacher - Coaching Coders</title><meta content="Frontiers of Access Controls: Modules and Nestmates with Karen Kinnear - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Frontiers of Access Controls: Modules and Nestmates with Karen Kinnear</b></h2><h5 class="post__date">2017-07-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ju2oqc6-mxE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Karen Kinnear I'm the jvm
runtime lead it will Oracle and I'm
going to talk about frontiers of access
control it's a two-part four three part
talk I'm going to talk about modules and
nestmates
and I want to preface this with I did
like John every slide is way too full
and saying far too much there's no time
for questions so we have two workshops
we have a workshop with Jalen baton is
running tomorrow about modules so bring
your questions there because you'll have
a whole lot of people who know even more
about it than I do and we I'm giving a
workshop on Wednesday for valhalla value
types and if you have an estimate
questions bring them there so I wanted
to start like Paul did I thought it was
really nice to start with a thank you so
I've just do a starter list of folks who
worked on nest mates who no farm where
that excuse me on module so mark
Reinhold
Alex Buckley Alan Bateman Jonathan
Gibbons mandy chung paul santos Louis
bullpen
Harold Siegel George to Toronto salut
and if I missed you I apologize there's
a world of people who've worked really
hard on this for years and for nest
mates
I want to thank Dan Smith Bjorn guard
all at IBM and David Holmes who's in
Australia so we're far reaching you've
seen this before
so I'm going to do this in three parts
the first part I'm going to discuss the
JVM access controls in general just
brief review so we're all speaking the
same language then I'm going to discuss
access controls for modules which is
coming soon in Java SE 9 and then access
controls for nest mates which is a
Valhalla work-in-progress that don't
believe anything I said it will all
change for the time you see it
okay so JVM access controls what are
they this should be familiar to
everybody but I just just for quick
review access controls the access
control flags come in two parts we have
type access and we have member access
control flags right so type access your
publicly or default which means package
and member access is public protected
default or private there's a key point
to this in neither of these projects
have these likes changed okay that's key
there's another key point which is any
time you want to check number access you
type access first the first feature I'm
going to discuss which is module has
changed how we deal with type access and
the second talk about nestmates has
changed how we deal with member access
the flights themselves haven't changed
oh one more note everything I talked
about is talking about runtime types so
any class or type and I'm going to be
really fuzzy about you think type and
class so it's if you're a language
person my apologies I always mean
runtime if I talk about a package its
runtime so it's always paired with a
class loader okay so I'm this is a talk
about how runtime handles please so
we're our JVM access controls checked at
runtime verification bytecode resolution
which is the common path everybody
thinks about we check them with
inheritance and API such as method
handles or handles and reflection so
there will be quiz at the end on the
access control JVMs this is v8 and I try
to illustrate it okay so here's a
picture I am a auditory not a visual so
apologies on the pictures okay so
seriously I it's a struggle for me to
have to do this visually but so boxes is
the best I could give you so this is the
terminology I use for all my boxes this
is a type access check in java SE a
target type T is accessible to Type S if
okay so see if this will work you have s
is making the access check the access
request s is in package P sub s I use
that syntax all the way and then you
have type choices so you have a default
T in package P sub T or you have a
public type in package P sub D and the
rolls which are all familiar with are if
it's a default type if the packages are
the same the answer is yes if it's a
public type the answer's yes always
right you all know this stuff so that
was easy
so remember access check this is the
review without change right you all know
this one - same kind of syntax is target
number DX accessible to type s so once
again we have s in package P of s and
then we have the different member
access flags public always protected
this means if s is a subtype of D where
D is the declaring class okay of X worth
the same package default if they're the
same package private if they're the same
type right so all of this is familiar
just wanted to put up there so when I
change these you'll notice the
difference okay
so let's jump into modules in order to
do that I want to get some background on
module this is a very quick summary of
modules what is a module so a module is
a name set of packages it's designed for
reuse we partitioned the packages into
concealed and exported confinement got
it we're doing that and a module depends
on packages exported by other modules
explicitly clear boundaries good
parenting good coding types
accessibility in Java SC 8 we had a
class contained within a package those
are our containers we have class access
because with modules were just talking
about type access default and public
okay type acts accessibility with
modules in Java c9 has changed we have
class inside package inside module now
you'll notice the class inside package
you got that in your fully qualified
name we did not change that for module
so we need a way to specify that we also
have modified the class XS we did not
touch the access for default or package
private we have changed how public is
translated how the accessibility check
works when you're in a module ok and I
will go into gory detail about that this
is just your teaser okay how do you
define a module so you define it with a
module descriptor so basically it's a
Java source file of module info Java a
we compile it into module info type
class which is your module definition
and the class goal is at the top of your
jar this declares your module metadata
because we had to have a place to put
that important information like what
packages are in it like what your module
name is
whatcha requires this is the two key
ones there's lots of others and there's
a link at the end that you can go find
to the others the two key ones for
access controls are a module requires
another module and a module exports
packages to other modules okay so I will
repeat that in the next one because it's
so important so and you can just you
know sleep tape this a module requires
other modules and a module exports
packages to specific modules or to all
so we have a picture thanks that Alex
Buckley I stole this from his slides
let's start with Java top base is the
basic module for Java Fe ok it's
everybody requires to over that base and
in fact you get it for free the JDK has
been modularized into a whole bunch of
modules this is the bottom one it
contains things like Java like object
which you all need Java language of Io
java.net who's supposed to be a dot dot
here those are the exported packages and
then you have things like security and
JDK internal those are the concealed
packages okay this in this example we
have you write your own module and it is
in your source directory you put module
inside a Java and you say I want to
write a HelloWorld I stole this from
Brian so this has a fancy print package
because I had to do a trivial example
that you really want to make available
to others ok
and it also has some internal stuff so
you split use write your stuff with two
packages comma hello dot internal is
your package that has all the stuff you
don't want to expose and then you have
Conda hello to print package which you
export ok so how do you do that you do
that in your module info you give it a
name hello world
ok could have been more creative but
anyway requires Javid update so there's
your little arrow from this module to
that module and exports Conda to load up
print package ok
so Java debase exported these libraries
to me and I export excuse me packages
these pack this package to others you
compile it with Java C you can PI
both module info and your source and you
run Java - and hello world so on I have
a whole lot more to say I'm just giving
you the rest of it that didn't fit on
the slide but I'm going to tell you it
anyway so modules are designed
explicitly for reuse okay
following the principle of the unit of
reuse is the unit of release so you've
all been shipping things with jar files
we didn't change that keep chipping in
with jar file if you add your module
info duck class to the jar file you have
not created a modular jar and others can
reuse this modular jar by writing
requires hello world in their module
info okay and there's a real benefit
here this is the confinement benefit the
release er you hello world benefit
because nobody is going to be using
condom hello to internal and that's
access checks we're going to prevent
that okay that's what we do for a living
I know I answer for more flies with JVM
apologies and the other piece is that
the guy who then does the importing he
benefits because you've committed that
the ones that are exported they aren't
going to change I okay you can
explicitly say these are going to be
supported and these aren't and it
reduces your burden and it lets them
count on you so this is this is one of
the benefits of confinement so how do we
use this module information okay at the
beginning of time we when we compile or
run a Java program we perform module
resolution so resolving a module in
tables when resolving all of its
dependencies we start with the
observable modules which is which come
from the module craft which we'll go to
later and from the system image which
I'll touch on later we start with a
route with a set of route modules so
when you did Java - M hello world hello
world was your route module okay we form
a readability graph so we do a recursive
enumeration of all the requires and we
get a readability graph so this
resolution ensures that you have no
missing dependencies
cyclic dependencies and no module M
reads more than one module that exports
package P to n so there's no ambiguity
okay so one of the things I should do in
terms of terminology you put oh I should
have put up there hello world requires
job at a base we build a readability
graph so at runtime accessibility checks
readability can read so that's the
terminology you wrote requires we took
all the complexity of requires and
turned it into a readability graph so I
will use the term read we talk touch
briefly on where do you find modules so
there's a module path which is a
sequence of locations for modules
modules have several formats one of
which is an exploded directory with its
module info one is a modular jar there's
some other forms we talked about we we
search the module path when looking for
a module in a fully modular application
if you we were starting from scratch
we'd find everything on the module path
obviously that's not the world we live
in so we have class path and module path
and we can mix them the other place we
look is in a runtime image so there's a
new tool called J link go play with it
it's really cool the default system
image has the Java C modules you can
create your own that has an execute and
making executable for just your app with
just what you need in it so I'm pretty
excited about that
so class path versus module path you're
all familiar with class path let me
mention a couple things about it to
distinguish how module path we tried to
make your life a little better so with a
class path when we sorry I also happen
to be a quest loader in my other life ok
when we go to look for classes we
linearly search the class tasks for each
epoch class granularity what that means
is a fixed time and B if you have
shipped old and new of the same package
and the first class you reference is
let's say your package P and it has old
class in it and new class in it and you
had already on your class path package P
with just old class in it and since we
all all love our edmonds append to glass
path because
right you've got them both on your class
path right now so I search for new and I
find the new one and I'm happy and then
I search for old and darn if I don't get
the the earlier one not the one that's
been changed okay so you can get run
into some interesting pain points there
we try to avoid that with module path so
the module path is designed to be
predictable only one module of a given
name is observable there's no
interference
so we perform a directed search once the
runtime finds a module it remembers its
packages and never has to search those
again we know where they are
okay so at the package level we will
find them all in the same place which
gets rid of that mess it also means the
class loading is ordered one instead of
order of n so for those who've been
asking for years yes we have making
quest voters texture to waste streak so
we're back to that original question and
giving you the module background that's
all I'm going to give you for background
the question is accessibility right so
can Class S access public left T so
you'll be able to draw this in your
sleep by the end of this talk okay class
s in package PS in module M s can it
access class T in package PT in module
MT so the question is type access from
this type to that type so there's two
questions you asked we asked a read
question and an export question okay the
question is can module MS Reed module
empty and does package does muzzle empty
export package PT to module MS ok have I
set declared the city as a dependency
and did you allow me to get there okay
so in this particular case I have module
M s requires empty check got the wreath
module M key exports PT okay where this
means exports to all so in this case the
answer is yes but this is the heart of
the new access checking ok we set up our
module boundaries we explicitly declare
a dependencies we explicitly export
access checking checks this at compile
time and a treinta okay so
this is part of the quiz so this is JVMs
nine five four for access control these
are the changes let me put them in my
picture okay so this is exactly the
picture you saw before I'm not even to
go over again note that number
accessibly is completely unchanged we've
added a new box
we now have s is in package PS in module
M s and PAC public T is in package P T
in module empty the first thing we do in
lib four in our job is to work really
hard for backward compatibility okay so
default C is in package P T this is
unchanged if you're the same package
you're golden what we have changed is
exactly what I told you in the other
slide is to do access checking s in
module M s T in module M T first we
check reads can Ms Reid empty and second
we check can empty did empty export PT
2ms either explicitly or to all modules
if you pass those you're golden okay so
those are the new rules that's the heart
of it I work in the VM we tried to
ensure that this didn't slow down at all
we have some shortcuts if you're in the
same module well duh if you're in the
same package then you are also always in
the same module the answers yes okay so
I mentioned backward compatibility what
do we do how do we interact the right
with classes that have not declared
modules information right you have
thousands of classes tens of thousands
hundreds of thousands of classes out
there on the class path we coined the
term unnamed module it's analogous to
unnamed package so today if you could
write a class and you don't declare a
package you're put in the unnamed
package okay if you don't have a module
definition here then the unnamed module
okay and the goal of the unnamed module
concept is to allow visting code to work
so we have a couple of rules the unnamed
module can read all other modules this
is easy to remember where would you have
put the information specifying what you
can read right okay well we tried to
make this clear right an unnamed module
exports all packages to all modules
again there's no place to declare this
right so we tried to make that easy
there is one unnamed module per class
loader so for most people the unnamed
module is synonymous with the class path
and that's the hand wave oh yes the
class step and for most people that's
all you care about if you happen to be a
person who cares about multiple class
loaders there is actually one for each
class loader so the application class
loaders unnamed module is we find the
classes in the class path the boot
loader we find it on the boot quest path
which only has one flag option left
- execute quest path slash a pen we are
looking there last no prepend add JVM TI
has an appended boot quest path okay so
let's see what this did to our exes
jacket okay I showed you this one
earlier we added some things
this is the last complexity that's as
far as it grows okay
so we've already talked about the access
to a fly type with a default access is
just package membership so here we have
extended this is in a module and named
module and this is an example in an
unnamed module so this is unchanged
right the other piece that you want to
notice is if s is in an unnamed module
accessing T in an unnamed module the
answer is always unchanged all these are
unchanged right totally backward
compatibility now we wanted or
operability okay so the next exercise we
did was make sure that you can work
between your class path and your module
path so between your named module and
your unnamed module remember named
module you check reads you check exports
same rule if I am s in an unnamed module
and I want to access T in a named module
well reads comes for free and you check
exports and we actually allow you to
export to all unnamed which is a very
helpful thing for backward compatibility
same concept here if I am s in a named
module and I want to access T in an
unnamed module we check reads same role
and empty always exports to all modules
so fundamental message check your reads
check your export ok
and we tried to make it as clean as
possible so you work with old code as
much as possible
so where do we do the checks I mentioned
that we do type checking and member
checking and that member checking first
you always have to do a type check we do
this in verification and that's only the
special protected handling so don't have
to go into detail I will now discuss
bytecode resolution which is the one
most people care about and then the API
bite to the resolution so here's some
sample byte codes not complete that do
sabab that resolve a symbolic type
reference in the constant bowl so things
like new instance of our favorite lvc
they are going to resolve type and
therefore dude compactive checking but
also with get static put static get
field put field we have field
descriptors we have method descriptors
with invoke virtual invoke special etc
so this is my terminology and this is
where I apologize if it could have found
a clear way to write it this is the
language I speak inside the JVM
so if class s wants to do an invoke
virtual on a static reference type
member named X on a dynamic receiver
object ref of receiver okay so we have
we're going to figure out where the
access control happen so we have this
ref C is the symbolic type reference or
static reference X is the member in this
case of the method receiver is the
object graph receiver this and D is the
declaring class of X which you don't see
in here but which we care about ok so
let's see what happens there are three
steps to the method resolution first we
resolve the reference then we resolve
the member where we start the search
starting at the static reference we look
locally super classes maximally specific
super classes and then we define the
member name and Signac
or we don't in which case is an error
then we do selection based on the
dynamic receiver ok
we select the number there something is
worth well something we pay close
attention to and hopefully you guys
don't need to is that constant pool
resolution requires we always return the
same result success or failure including
like an illegal access there which is
what your access type checking would
give you so that has generally not been
a huge big deal but one of the things
that we've added with modules is you can
dynamically augment your readability and
your exports
you cannot decrease but you can increase
this will not help you with a bytecode
that have already resolved a constable
entry okay it will not change what we
return we have promised we will always
give you the same answer so do it before
you do the reference okay it matters so
to add access checking do this
step one we resolved the static
reference and we do a type two checked
type access check can s access that
resolved type then we resolve the member
and we do a member access check can F
access X as defined in the defining
declaring class and then selection for
invoke virtual we actually do this up in
advance to make it faster we cache it in
our cast selection table which is our V
table or virtual member chill table and
it follows the inheritance and
overriding rules so let me talk just
briefly about those inheritance and
overriding model did not change with
jigsaw okay with modules inheritance
type accessibility has always required
that a subtype have type access
permissions to its direct super type
that is still the same however as we
noticed we are also going to be checking
reads and export right so for your
direct super type you have to be able to
access it that is not new the extent of
the things we check I have been extended
overriding I won't go into great detail
but fundamentally it means a subtype has
to have member access to a super types
member in order to override it just
leave it at that library so method
handles and bar handles follow the byte
code resolution or Java language access
check rules so they should behave the
same way doing the type in member access
checks there is an exception of course
for backward compatibility there's a
public lookup with unconditional mode
that ignores reads one thing to note
here is that for performance with a
lookup we can pre cache the answer to
that check because it's the same guy
requesting the same member access so
that's how we make method handles and
bar handles faster or one of the ways
reflection does type in member access
checks also it actually ignores reads
because we have so many frameworks we
really want to keep working it does
check open so I talked to you about
requires and exports there's other Flags
opens is one of those so a package can
open to another package it's analogous
to export it's explicitly for what's
called deep reflection so it's
explicitly to allows that accessible to
work so you can have a package open you
can have an entire module open and opens
implies exports okay so for those of you
who use that back door of set accessible
which well it's very very useful it
gives people a lot of power and it
messes up all sorts of assumptions about
things not changing so in all the talks
we've had today I kept wanting to raise
my hand and say could you please stop
using said accessible because people are
using backdoors to write things that
they should not have access to but
anyway said accessible will fail if the
type in a package is not open to the
caller and it actually is a little more
complex than that but we'll summarize
there there's some migration AIDS I'm
going to just put these up here so that
you can read them later I'm not going to
walk through them the point is we've
tried to make things as easy to migrate
as possible and I know there's still
challenges so if you have more questions
go to the workshop tomorrow okay and I'm
going to jump into nest
it's now because 45 minutes is a really
short talk this one is a work in
progress okay so now we're in a
different time frame and we're talking
about things that are evolving so I am
going to give you a snapshot of where we
are today and expect this to change this
is part of the bahala project the
original problem we were trying to solve
there's a Jeff 181 which is aligning the
jvm checks with the java language rules
for nested classes so Java has the
concept of a nested class and if you
look in the language spec there's rules
for private members that talk about
access is allowed if it occurs in the
body of the top-level class that
encloses the declaration if you've read
the JVMs you've never heard of a
top-level class you don't know anything
about enclosing classes right so we have
a disconnect here a friction point so we
want to solve that we want to do a
better job of making sure that they're
in sync and I'll show you the details of
that we also wanted to enhance access
controls to better support other
languages that care about them and we
have we want to invoke evolve unsafe to
fun and I'm in this class to be safe
supported API so what we found is we
started to explore different possible
solutions here for nested classes and
for unsafe define anonymous class and
then we discovered as we came up with
different concepts some of these
brilliant architects they work with came
up with the you know if we thought of
something like nest mates there's a
whole bunch of other possible uses so
I'll describe you at nest mates are but
we've discovered that there's some
commonality a common need for a a
concept which is an access control
context which we might be able to use
for sealed classes to only allow them to
be extendable by nest mate value types
in their boxes may have a tighter
connection than regular classes or may
not implementation specific same with
generic specialization implementation
specific may or may not need this
isolated methods may be able to take
advantage of it so the key message is we
just do this to solve a problem we've
already solved in a not the best
possible way but solved but adding them
all together we think this has multiple
valuable applications so I will give you
the use case of the nested class today
so I said there's a disconnect between
the language spec which Java C
implements and the JVM s spec so today
if I have an outer class that has a
private member in this case a method and
an inner class that wants to call it
sounds pretty simple right you do this
all the time
Java C under the covers is going to make
this possible okay because the
implementation generates a class file
outer class and outer dollar inner dot
class well now we're two different class
files and from a JVM perspective you're
not related right you're just two
different class well so what Java C does
today is it creates its trampoline it
creates a static synthetic accessor
which calls invoke special it's inside
outer class it called invoke special on
that method it's inside the class it's
allowed to access the private method
you're happy but you notice this is
default access so it's available to
anyone in the package so here we are
inside the inner class which by
definition is in the package we call
invoke static number six which is the
access ur and guess what we've now been
able to access it also than anybody else
in the package so we think that's a bit
of a problem ok here's the proposal the
proposal is a concept of nestmates so
we're looking at this is giving you an
access control concept so conceptually
nestmates derived from the same source
file is a single author single
compilation unit implementation may just
split them up
the goal is that nestmates be able to
access all members defined in the nest
so nest mates I should put it on here
the rules were proposing they have to be
in the same runtime package which means
they're in the same runtime module they
need to be in the same protection domain
so you kind of got your public and your
you're protected for free right you
already have that we are not changing
any of that but you did not have access
to the private member that you were
expecting to get to because it was in
your source file okay so we're looking
at expanding it to allow you to have
private access if your if your author
approve this we also want for dynamic
languages and our owners whose classes
to be able to statically or dynamically
add to the nest so the concept here is a
class is completely contained in a nest
it completely contained in a package
which is completely contained in a
module which is why this is one talk
even though it's a little off so your
next quiz will be on the access control
changes that we're proposing for nest
mates the key message years type access
rules did not change sorry the supposed
to be spaced their member access for
public protected and default did not
change what we're looking at is
expanding to X the member access control
rules for private as you can access by
any class belonging to the same nest the
other note that's down below is there's
two key points here one is the owner
says who's in their class who the
members of their nest are and the other
is that a class that does not declare
belonging to a nest belongs to a nest
with only its one member
so being you are a member of your own
nest so this definition of a class below
you the same nest includes yourself
right because we like the really clean
concept stuff okay you've seen this I
want I won't go over it this is to show
you the before all we changed in the
member access was the private okay so if
s in package PS wants to access private
member X declared in d if s and D are in
the same nest
Nesmith that's what we're proposing
that's the heart of the nest mates
proposal so it allows you to fix the
nested classics and pleasures earlier
and in fact it tightens the security to
that example so I know it's a little
full but this is I hope I made this up
so merge oh if this is not precisely
what you're generating this is close to
what you should be generating we with
nest mates we don't need this accessor
okay it's not necessary anymore our
dollar inner class is an estimate of
outer and this guy Java see behind the
scenes you do not have to this will not
change what what the programmer sees
right for most people this will be
transparent Java C will generate the
information inside the class file that
says I am the nest owner I am a nest
member and they have to agree and what
the byte codes can do now is invoke
special of M outer proof and we will say
ah you are a nest member this will work
so it actually tightens security because
you don't actually have all the guys on
the package able to get to this anymore
okay so one other example the unsafe
define anonymous class has multiple
problems today it's unsafe it's not
supported you're not supposed to be
using unsafe it conflates capabilities
so let me tell you what some of those
capabilities are I am NOT saying this to
encourage you to use it okay do not I
mean you know don't take away the wrong
message here it allows you to add a
class into a host package with access to
the hosts private member okay we call it
a VM anonymous class as we evolved
please find a new name anonymous is
overused like
it is not findable okay if this class
cannot be found via class before name I
could resolution it's not
in the load of cleft cache you define it
you get yourself a class the Java line
class you get yourself an instance you
pass it around but nobody can go look it
up what does that mean well it's
temporary the life cycle is independent
of the class loader life cycle we don't
have to return it again in fact we won't
return it to you at all you can't find
it we can therefore unload it please
don't make this a reason to start using
it okay we really are going to get rid
of it so don't even go there okay it
also allows this crazy addition of
runtime types through patching the
constant pool you don't want to know
what I think about that okay exploring
evolution not based on unsafe we are
exploring these are you'll see some of
these on the bahala mailing alias we're
exploring we'd love you to contribute so
in java SE 9 we added a lookup define
class with a byte array which allows you
to define a class in the same runtime
package modulo protection Danai that's
your look of class ok so that's been
added we are looking at the possibility
of extending that by having a look up if
you have a look up with private mode we
could allow you to dynamically create
Nesmith so remember I said that the
author gives permission to be in the
nest right now and I'll go into the
details of how that's in your class file
this is how you dynamically give
permission okay we care deeply about
security here we know we are opening a
little door and we are containing that
door if you find a hole let us know we
are totally aware of being careful about
the boundaries the lookup with private
mode is how your author says you can
dynamically add to the nest ok so we
have a static mechanism and a dynamic
net negative them and the author is
responsible for it so we're not playing
free-for-all here ok for not findable we
may change the API or at a boolean same
with temporary and we have some
exploring some alternatives to constant
pool patching so keep your eyes open
detailed jvm requirement okay so we
mentioned that nestmates must be members
of the same runtime package runtime
module and share the same protection
domain we don't have nested nest mates
you just need belong to a single nest
the goal is to allow nest mates to
access private members declared the nest
when the author allows it we do not
extend this to allow nest mates access
to protected members inherited by an
ethnic which are declared in a different
package not going there for a thousand
reasons you didn't even want to see the
diagram there is no support plan for
mixing unsafe to funding on this class
and nest mates don't even try it you
just you just I can't even draw the
combinations it's awful and supporting
static and dynamic nest edition edition
so these requirements should echo what
we said was needed implementation change
is required most of this is pretty
straightforward clear and clean okay and
this is where most people say yeah just
add Nathalie great it's just easy most
of it is clean so for field access get
fields get static put field put static
all we need are the access control
changes and it just magically falls out
and we like it when something is clean
and just magically falls out four
methods invoke static invoke virtual
invoke interface yes invoke special darn
okay so this is the hard part where
people can feel free to leave or doze
actually that's the invoke special which
is the next slide first I got to tell
you I talked about in the class file we
say the author says these are my mess
members so we're adding we're proposing
adding two attributes one of which says
these are my nest members and you can
bike on the name as long as I can
translate a tile care the other says I
am the member of this nest and guess
what
verification had better check that you
agreed on that right we really do care
about security deeply we also ensure
that you remember that same are done
package and my favorite invoke special
has some verification rules and bytecode
special rules that we're going to go
into and goreng
so in case you like this kind of stuff I
do but invoke special has three uses
today in it
super and local and I managed to fit
them all on one screen which is maybe
not a plus but in it example we're all
familiar with new dupe in it right using
invoke special that's pretty standard I
want to talk about that anymore it's not
changing invoke special is used for
super call so if I have class child with
the parent a direct superclass parent I
can call super duck parents method and I
call it using invoke special parents
method okay local example today so if I
have a private member and I inside the
same class I call oh did I do powder it
up private oh sorry I cut and pasted my
bad anyway I can use invoke special to
get to the private member right and in
fact for private members interfaces
invoke special is the only way to get
there okay so the restriction the JVM f9
invoke special restrictions so we're
back to that same I'm doing invoke
special and recipe so just to remind you
the terminology all invocation bytecodes
have the restrictions that method should
only operate on subtypes right so the
dynamic type of the subtype of the
static type right like virtual methods
wouldn't work without that but I like to
be anal so that that's in here we didn't
change it invoke special has additional
restrictions it is essentially a
non-virtual call so for super class
invocation you're only allowed
invocation on a direct superclass okay
if you do the implementation you know
there's a corner case and we're not
going there
and we'd like to get rid of it something
but that's of my wishlist but
fundamentally you can only call a direct
superclass which we translate as your
classes authorized you're allowed to do
this you're bounded in what you're
allowed to do through this non-virtual
backdoor and you can only operate on
objects
yours so that the dynamic type has to be
not only a subtype of the static type
but a subtype of yours so if I am a bird
and I am inside and my parent class is
animal I can operate on birds I can
operate on Robin I cannot operate on
elephants ok so we try to bound this we
are letting you do a non-virtual super
call and we bound who you can operate on
ok
so key thing is we are going to maintain
those restrictions so I tried to say the
same thing for visual wolf is in a chart
so it's the same thing so if you're an
auditory you already heard it if your
visual let's see if this makes sense
s can invoke could call invoke special
on the static reference X on dynamic
receiver if so in this super case the
restriction is that s has to be a
subtype of rep see ok and we talked
everybody says receiver has to be a
subtype of the static type and we just
talked about birds and animals so
receiver has to be a subtype of the
caller in the local case this is sort of
trivially true local means we implement
this right so we care deeply that the
caller is the same as both the whoops
Wow that was exciting
we were really done the static reffered
and the defining class right which
basically means you have to be in the
same class today right but that's what
it means to us internally and in that
case the restriction is the receiver is
a subtype of the reference clock because
the others fall out for free now what
did we change we actually work this
proposal is in progress what we work
very hard to do is to make sure that in
the super case the rule did not change
in the local case the rules did not
change we have expanded
what we mean by local okay so that's
very intentional and thanks to Dan Smith
for the contact because I get into the
details and he hop up levels and I'm
really grateful so the point is if you
are a super and a nest mate you follow
the Nestle rule but if you are a super
your rules are unchanged you cannot lose
fundamentally since we're talking about
restrictions means you can't do anything
you couldn't do before right that's our
goal
we are not expanding what people can do
beyond the explicitly authorized nest
mate where the author said I will let
you do this okay nest mate open issues
so we are still sweating weather if you
do an invoke special on a private member
and then you change that to be non
private should it still work or should
we say I'm really sorry and there's pros
and cons and I'm finding more pros and
cons every person I talk to so we will
sweat that for a while we are also
working hard on this is an
implementation issue minimizing
additional class loading and
verification because that slows down all
your quest loading in your startup time
so we're being careful we're checking
the restrictions we might have to evolve
what what is checked at verification
time versus run time so something that
is now verify error may become a runtime
error and we are also being very careful
the order of checking subtype and nest
mate because we have to check whether
you're in the super box or in the nest
mate box without doing the class loading
to find out if you're an SMA automatic
no actually we're being really really
really careful to close all to dot all
the i's and cross the t's the question I
wanted to ask you is how do you how many
of you currently use unsafe define
anonymous class all right hey all right
well says I have 30 seconds left gosh I
okay oh my name is Karen Kinnear at
Oracle comm I actually would like to
know this I really deeply we want to
make sure that as we evolve it it meets
your needs
okay so if you would like to come to the
workshop tomorrow here we go
references there's two workshops that
mentioned Allen baton is giving 100
jigsaw tomorrow and I'm sorry mine is on
Wednesday it's for bajalia value types
if there's time I would really love to
hear about NASA night questions and
unsafe to find a non underclass if not
if you want to find me some other time
or email or just find me in the hallway
we actually really deeply want to know
in fact Paul Santos also wants to know
because he knows the Java side I just do
you know the plumbing what how are you
using unsafe define anonymous quest
Oh 45:44 okay</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>