<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java EE and Websockets | Coder Coacher - Coaching Coders</title><meta content="Java EE and Websockets - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java EE and Websockets</b></h2><h5 class="post__date">2014-04-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_hPSlOYdoY0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yeah thanks so good afternoon guys so
I'm gonna present about Java EE 7 web
socket API so before going into the
topic let me just tell who I am my name
is Liran I work in software AG I'm a Jag
member for the past year and I've
contributed to a few open source
projects and done few Android projects
so that's it about me so before going
into web socket API let me just give you
a small intro about web sockets how
things work why web sockets came into
the picture and then I will explain why
the why there was a need for a API for
web sockets in Java w7 ok
so as I told this is what I would be
covering and I will show you a quick
demo of the power of web sockets so web
sockets by nature is TCP based and it's
full duplex so meaning that it can
communicate in both ways so if a client
and server communicates so it can send
messages at the same time in his tea
teepee that's not possible
you could either send a request or it
receives a response so that was a major
flaw and has TTP and this was originally
part of html5 so people got started
working with WebSockets in html5 and saw
the power of it and wanted it in Java so
there are many implementations of
WebSockets in Java I will just show you
a slide
after a few slides it will come and
there is also a w3c API for this so as I
told it's full duplex meaning that you
could send messages in both directions
so here half duplex is HTTP so you could
either send a response
sorry send a request or receive a
response so this is full duplex and this
is what WebSockets do so before
WebSockets it was pretty nasty out there
so poling long polling was methodologies
that were mostly used in case of polling
what it will do is it
send a request and get the response but
the client is programmed to send a
request again after a fixed period of
time meaning that the client knows when
the data is available in the server so
that is how polling used to work but in
case of live sharemarket information
that needs to be pulled up so that was
not possible because the data would be
changing dynamically and you don't know
when there would be an update so there
that was a major flaw with polling so
long polling this slight update to
polling but it's much more worse so it's
like you open up a connection send a
request and the connection is there for
a fixed period of time if the data is
not available it would send a response
stating that it's time out and there is
a problem if the data is available it
send it back so if there are multiple
requests more than 100 requests are
going in or take instance for 10
requests 10 connections would be opened
up and 10 would be sitting in my idly so
that is a waste of socket speed and this
was avoided in WebSockets completely so
comet Anna Jack's used both of these
techniques to simulate a rich client
user interface so it what comet does it
actually assigns a callback function
using polling or long polling so when
the data comes in it would appear that
the function it would appear that it has
come dynamically so it's like callback
handler when the data comes in it works
if the data doesn't come it doesn't work
so it simulates that data is dynamically
coming but in turn it's waiting for the
data and it's not dynamically done so
and the HTTP method of sending request
and response is much much more bulkier
so HTTP adds lots of header information
in it so each time I send the request on
a response there are lot of unnecessary
data being sent and received it makes my
header information very much heavy so in
case of I'm sending a simple hello world
message it takes up to two hundred bytes
so it's in case of WebSockets it takes
only 20 bytes so there is a lot of
information being sent everytime isn't a
request and I get back a response which
is inefficient in case of me a make a
thousand request just multiply the
numbers and you would get the picture
it's considerably reduced in WebSockets
this is a normal HTML firm ation it
sends a request to the server it gets
the response back from the server this
happens not me
in case of poling it sends a request if
there is no information it gets a
timeout error so that happens again and
again till the data has been fetched
from the server so as it old in long
polling that thing is being avoided so
the connection is there for few minutes
and making it making the connection
persist for a few minutes and so there
would be a lot of unnecessary poke
sockets opened up for connections but in
case of web sockets only a single
connection is opened up since it's full
duplex in nature and it's by directional
by the way it's full duplex you could
send and receive messages at the same
time and bi-directional meaning that
both the server client as well as the
server would be able to send and receive
the messages simultaneously and not
resting not restricting the client or
the server to only send or receive
messages so for establishing a WebSocket
connection it will send a handshake
request of the starting the handshake
request will contain the information or
its that it's upgrading to a WebSocket
so this WebSockets occurs on top of HTTP
are the starting for the first time then
it upgrades to a WebSocket if the server
supports WebSocket it will send a
handshake response so in that in the
header in the handshake request you
could see there is an upgrade here
so there is a as you could see upgrade
to WebSocket so and the connection is
also upgrade it's not a normal request
it's an upgrade request to the server
that's being sent and the server if it's
understand if it understands what
WebSocket is it will send back a
response stating that it's accepting
WebSockets and the client could further
really communicate through WebSocket APA
rather than HTTP 1 and WebSocket uses a
ws instead of a HTTP for every time it
sends and receives the messages so after
the handshake request on the response
it's connected totally and the client
can send and receive information
dynamically here the main advantages the
unnecessary HTTP header that was sent in
history HTTP is being avoided totally in
WebSockets meaning that it reduces a lot
of information redundant data is being
reduced so this is the support that is
being currently provided by all the
browsers in WebSockets as you could see
almost all browsers are supported so
there's a site called can I use
WebSockets if you go there this start
would be available only the native
Android browser is not currently
supported other than that everything is
supported so if you are a developer you
want to develop in WebSockets you could
straightaway jump in so there won't be
any problems as I told you there was a
need for why web socket API was
implemented because there were lots of
API is being developed for each specific
use cases so Apache Tomcat was
specifically done for Apache and plays
in case of gracias so it had its own
implementation so it's unnecessary that
developers need to go through every
implementation and they need to
understand so for this purpose they had
produced a Java API a web socket so what
Java API helps us to do is it it would
it can be either done through an
interface method or an annotation so I'm
going to deal with interface methods oh
no sorry annotation methods annotations
are much cleaner than interface
and interface is just a bit messy here
so let me show you a small example so
here I am just honored annotating the
method with AD server end point so it
makes it clean makes the class now
becomes a WebSocket endpoint and
whenever I hit the resource whenever I
hit the URL with a slash hello this
endpoint gets called and the
corresponding method will deal with the
messages so that is how things work here
so these are all the other annotations
that are being currently support the ad
server endpoint as I told you will make
a POJO look like a server endpoint and
it's a class level annotation in case of
grant endpoint it needs to be annotated
without client and point and the beauty
of prep sockets is there is a concept of
server on a client and there is a
concept of peer-to-peer in case there
would be a central hub and it would be
sending the information to rest of the
peers so it's like I make a change in
one peer it would get reflected in all
the other peers that is something which
was done beautifully in WebSockets and I
will show you a demo on how it is done
at open annotation will make the message
deal with a open whenever a connection
gets open so the corresponding method
which is annotated with that open will
deal with all the stuff and it will tell
you what what it does so likewise that
closed on closed man annotation will
also deal with the closed instance so
whenever you you can also send params
through this so when you send parents
and at path param they'll be called so
it will deal with the params and however
you want to manipulate your perhaps it
can be done in the message so likewise
you just need to annotate every message
every method with the corresponding
annotation and it will look much cleaner
than what it can be done through an
interface method so interface it's a
little bit it can give you the power to
manipulate stuff but it's not cleaner
this looks made very much cleaner in
comparison to the interface methods so I
will just show you a demo
so this class is my server end pointless
I've annotated it with the method so at
server end point and I've given the URI
here
so at slash WebSocket is the URI that is
going to be it each and every time I
send a request and the class as you can
see I told you whenever whenever I
annotate a method without open it will
deal with the open connections
so whenever a connection is being opened
the method on open will be called and
correspondingly it will take care of all
the events so likewise for the on close
and in case of message sending that on
message can be an annotation will be
used for the method level and one more
thing there is a small drawback in this
you can only use three or turn messages
for a single class so that's a small
drawback here let me show you a demo
so this is a collaborative whiteboard so
whatever you do and one by whiteboard
will get reflected in the another one so
I'm actually firing up three browsers
one as a Chrome and another one as a
safari let me just open up Firefox
so as you can see now I'm just hitting
in one browser the data gets propagated
in all the three browsers so that is the
power of WebSockets in case the
architecture here it's like peer-to-peer
everything is appear in if data gets
changed in one peer its it gets
reflected in all the other peers
correspondingly so that's that is
getting dealed in art on message
annotation rending okay yeah sorry
so now are you able to see it so that is
the power which is being done here it
doesn't follow a typical client-server
architecture it follows a peer-to-peer
architecture there is a one common at
server end point and it will reflect all
the data that is being done in one peer
to all the others
now let me just show you what what is
happening in the wire oh yeah
so this is what is happening the
corresponding coordinates and the color
gets sent each and every time so as you
could see it is stating that the message
is received and not sent or something
else this is the data that is being
received if I do a change in one browser
it gets reflected in another so let me
just show you something
so this is a chrome application that
will help you send requests to
WebSockets so it's showing disconnected
and in case of the normal loading there
is any there is no disconnected or
something this is the way you send HTTP
requests so it's like you press send the
information sent that's all but in case
of a socket you could see it's showing
disconnected
if I just press connect it connect it
will get connected meaning that every
time you you open a socket it will open
up a connection and keep it open for
some time I am just changing the color
so that it so that you could see the
difference
see so the request has been sent and you
could see that a black box has been
generated on top of a red box where the
data read the color was used to be so
this is the change
so see you could see the change it's
been propagated in all the two browsers
and it's like Pierre a peer-to-peer as I
said let me just explain the code a
little bit so that you would be able to
understand things so what happens Cirrus
JSON data is being sent every time I'm
clicking a send request end button so
it's a data which is being sent from the
Pierre gets come to the WebSocket
endpoint and it's being decoded so it
cannot handle raw data
WebSockets can only deal with binary or
strings and here the JSON will come as a
string and the figure it uses encoders
and decoders to convert it to pojos and
play with it
so in case of here there is no need of a
POJO but still if you go for complex
architectures you need a POJO so this is
a decoder that will decode the json
information to a POJO and the POJO will
be again sent back as a response it will
be again encoded as a JSON and Vincent
will be sent back as a response and as
you could see in the figure decoder it
implements a class called figure so this
figure contains information about how to
deal with JSON so whenever real some
event happens in a peer the data gets
come sent here and it will get saved as
a JSON as say JSON here in the POJO and
the POJO gets played with and it will be
sent as a response so that is what is
happening inside this application
so that's it from me any questions
yeah but yeah it's it's like a central
hub
so yeah broadcasting the information but
still it's like a central hub and in
case of a client and a server that that
in normal scenarios a single client will
respond to a server and there is a
central hub and it will deal with all
the other peers here so everything
everything is getting converted to
appear rather than a client it's not a
client it's it's a peer yeah yeah
somewhat yeah yeah yeah so somewhat like
I guess that is being achieved like this
but web web RTC in sense is not yeah
maybe if you want you could start a
perspective yeah yeah yeah yeah that's
true yeah
so it's like there is some bad sides to
it it's like a server it's an endpoint
gets opened up and the connection state
if you open fire up ten connections ten
connections will be opened up so that is
I have not played with yeah yeah it will
so in case of some errors happen it will
close the connection so it's it's a
protocol ap Unni you only need to be
figuring out all that stuff a games yeah
game development will be
yeah first time it will send the header
then afterwards there won't be any
headers only the message will be sent on
the way so meaning that the day an
amount of data sent is being reduced
considerably so I said for a single
hello world message there would be 200
bytes of data being sent in case of
WebSockets 20 bytes of data is being
sent that is excluding the starting
point but in the starting point the
header information is sent afterwards it
is not you I think you might be neat you
need to send the data with the client so
yeah
oh yes so once if the connection
terminates I think so any more questions
it happens it's a it's a part of the
protocol so WebSockets typically will
send the handshake yeah yeah fasting
from the client from the Pearson so let
me just show you that
so here it will make the request
yeah that yeah so that is why it makes
the request yeah
so any more questions no I have not
tried it so thank you guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>