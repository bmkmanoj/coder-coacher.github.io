<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JVMLS 2015 - JyNi | Coder Coacher - Coaching Coders</title><meta content="JVMLS 2015 - JyNi - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>JVMLS 2015 - JyNi</b></h2><h5 class="post__date">2015-08-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hD0r3k9IwkE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm Stefan let me quickly introduce
myself I'm actually a PhD student in
from Germany at the University of Bonn
and researching in computational
neuroscience and yet the work we do our
scientific computing our scientific
computation mainly with Python but
sometimes I wish to be able to interface
it with some Java frameworks and that's
why I came across jython which is yeah
and I was amazed by it how elegantly at
bridges Python and Java and was so
beautiful too bad I couldn't use it
because our work is mainly dependent on
an umpire and other see patent
extensions but mainly numpy then I found
another solution for my actual problem I
wrote the data to files and opened the
files we could have done it by embedding
or process communication but still I
kept wondering why it is so hard to add
C pass an extension compatibility to
jython
because Java has some layer and C
partners some layer wife why can they
not be a male that emulated so now since
since I am standing on the Java summit
I'm not sure how wait
yeah okay how I'm not sure how familiar
you are actually with jardín who has
used tried in here okay so I can do that
I can do this rather quickly
ok but I think just for completeness I
should state some most important facts
about it it is Java based Python
interpreter it's a bit more than an
interpreter it actually compiles patent
code to Java bytecode
yeah it has a multi-threading support
cpython also has some multi-threading
support but it's not so straightforward
and yeah because he Python has this
global interpreter lock why do they need
it mainly because of reference counting
based garbage collection reference
counters are not atomic and using atomic
reference counters usually did not yield
sufficient performance so why does try
to not use a non teetered global
interpreter lock because it's garbage
collection is based on Java garbage
collection yeah this regarding finalizes
and how weak references break and
resurrection there are some subtle
differences he is usually don't matter
much but if you search for them you can
find them and you can also write
incompatible code but ok well the big
killer feature of jivin is its Java
integration it is very seamless you can
just call Java methods from Python code
just as if it were they were python api
the other the other way round is a bit
more complicated you have to add type
information using interfaces yet I hope
in the future it will be possible to
auto-generate this to some extent by
yeah python is adding type information
now and maybe and some IDs have some
very nice methods to pass the type
information from comments and there are
some techniques so it could be improved
a bit yeah the the integration is even
that smooth that you can have driving
classes or Python classes in that case
extend Java classes well you cannot
sneak in multi
a moody extension Moochie inheritance
but you can have one Java class as in
several Python classes yeah and the big
drawback is that it does not support
native C Python extensions C okay why do
I write why do I write C Python style C
extensions because it is Java and in
Java we could have J and IC extensions
and these would work okay let me
illustrate this we have C Partin which
as its
c-pod any extensions we have jivin on
top of java with chess Jana extensions
and now guess what how Johnny would look
like it is it is actually a Jana
extension that pretends to look like C
Python regarding twisty path an
extension so far so good okay if the
motivation is not yet obvious let me go
through it okay we would vastly improve
the number of paths and frameworks
runnable on Jonathan often enough it is
some tiny subtle dependency which would
be added and yeah tons of frameworks
could be made working yeah okay
no please note that everything that
works in drivin would also work in Java
you can have with some additional effort
yeah built Java Java API Java accessible
API on top of it so you could use Python
language bindings in Java well it's not
so performant and but yeah it would you
could you could achieve compatibility
rather quickly and test things out and
why not
yeah and finally it would allow our
programs to have simultaneous
dependencies on Python code and Java
code and with Python code I mean also C
extensions of course
yeah so let's leverage all this synergy
between the worlds so when writing
Johnny my main design goal is to
magically just work that is the user
experience I want to deliver and in
detail that means having maximum
compatibility okay this is an ambitious
goal but so far I don't see a
showstoppers it is challenging it is not
always performant but I think I am still
ambitious to reach at almost 100%
compatibility at one yeah at one day
then of course it shall not have
regressions regarding drivin so yeah
especially motivation a new
multi-threading support should not be
harmed
I don't want to Moo definitive extension
code it should work with the original
extensions I even named for binary
compatibility so it shall even work with
close source extensions and finally I
also don't want to have changes on the
drive hand side own on the pattern side
yeah using native extensions from drivin
shall just work as if you would do it
from C pad okay then there are some
subsequent goals
yeah performance is yeah the biggest
issue is that it will always be kept by
Jane I overhead but I hope that project
project Panama can improve it to some
extent yeah I would be happy about some
follow-up discussion here and finally I
would like to have a global interpreter
lock free mode currently Johnny
introduces a girl which is not applied
on drive inside but it is applied once
that the threat enters a native mode
because native extensions might rely on
it but I believe there are several
extensions out there that would not need
it would or would only need it forever
and Counting and I think I can
circumvent this reference counting stuff
and if the extension does not need it
for its own internal synchronization
then it might work
and through this talk I will sometimes
mention some things that some aspects
that extensions might not may not do in
order to be a suitable for guilt-free
mode for a potential girlfriend
and in the end I think there could be
something like a white list of known
extensions and then it can apply a gear
free mode okay let me start with a proof
of concept and a live demonstration it
is still alpha state and not so much
works but tkinter is a tiny Python GUI
framework that already works at least
for some simple example so okay this is
a rather tiny program it just opens a
window with a label and two buttons one
button prints the the value of the label
and you have the other button okay let's
look here this method and this these two
method definitions are the back ends of
the buttons and this one prints the the
text label and this one intentionally
intentionally performs a Java call yeah
just to prove that dragon is running and
in order to make it also run a bill with
C Python we do the import inside the
method which is not such a nice style
but this way the program can run and the
error only occurs when pressing the
button okay okay here's the the yep the
program again okay let us first try it
with - okay this is dragon code by hand
without log using the launcher this way
you can just quadratum by
and with the argument of this of this
program and yes it will fail we have to
wait up the startup time which is not
yeah Johnny
increases the startup time a lot yeah
okay it doesn't know what to do with the
import so let's look let's run it with
with with C patent okay this is so now
we see how it should look like this
Bratton works but of course he patent
doesn't know what to do in this case
because it doesn't know the Java API
okay finally let's run it with Johnny
active okay you might recognize the
slight difference we just put the giant
jar file onto the Java class path and
that's all no other changes unnecessary
and keep fingers crossed
okay yes and we can print this text yeah
and now also the time stamp works just
for curiosity I converted the program to
a Java program so to see how how the
Java version would look like on top of -
it is not so smooth now the clam project
will improve this a lot and for instance
yeah okay this is the cheap version you
can just inline a Python code and I do
this here to do the import stuff because
doing it with actual Java Java API would
be very cumbersome but ok and the other
aspect is that constructors are not
nicely wrapped yet so you have to do
some ugly stuff to do to come to do the
constructors and yeah yeah I defined the
interfaces that backup the objects that
are used that as the the tkm main object
it I only use the the main loop method
for my program which starts the main
loop the GUI complete components I only
use
pack but after putting the objects under
the interface where's the call somewhere
there so call this two-year to Java
dustless here to Java converts the
pattern object to the Java interface and
then I can just do Java code and if the
main purpose the main operation of the
program would be in calling Java methods
I could do my whole code very very Java
like and again also the other parts will
be improved where with a clamp project
okay finally let's run the Java program
which is actually a bit simplified test
UK yeah it has only one button now yeah
but we are using from completely from
Java native C extension API yeah native
C patent extension okay
let's continue to with the with
presentation okay just in case it would
not have worked I could have shown you
this picture okay I want to yeah let's
come up let's say something about the
implementation I guess hardly anyone of
you did ever take a look into the C
Python interpreter
source code someone who did solo okay
okay if you look into the sea and it has
seen a sip as an interpreter source code
you will notice that everything is about
something like something called PI
object how is this power of check
defined if you if you search through the
headers you will find this definition it
is main mainly consists of a reference
counter and of a type object and yeah
this type object is itself also a PI
object and just copies it repeats the
sera and by repeating the sera you do as
the inheritance somehow so let's look
how - implements this in drivin this is
the PI object is just Java class and the
methods are dressed methods and in this
case the methods are yeah fields in the
type object and yeah it has one field
that is actually a dictionary containing
the methods and the other things are the
type name and other operational stuff so
okay how to bridge these things yeah
okay basically we have objects on
pattern side and objects on Java side
side and we yeah must somehow bridge
them one could make pi the object okay
the one with a with a star is the is
always the sea side we could make the
sea objects to be just stops backed by
the Java objects and convert our calls
through the Jain ilayya we could also do
it the other way around
we could have recruit could create
special C Python drivin PI object a
subclass that uses a see Python object
as a back-end finally we could do we
could mirror it we could have a
full-featured object on Java side and on
Jane I site in this case we would have
we would might run into synchronization
issues so it turns out that I need all
three approaches and the syrups Java
approach is the easiest one and I apply
it wherever possible depending on the PI
object type a table of power check types
which says which approach to use yeah
the main advantage is that if if the
data of the C object is changed this is
instantaneously visible on no the other
way around if the Java objects data
changes it is instantaneously this is a
visible
yeah you have no data synchronization
issues but yeah you must have matching
driving type for the cpython type and
the other problem is that cpython often
uses uses macros to directly access
internal data of the object and
extensions also use these macros if
jivin has no corresponding type to the
native to the native type for instance
okay
I'm speaking faster than my presentation
knows fallback approach yeah it's even
all dragon-type exists for instance for
pi c function this is a native PI object
that is introduced by the layer and it
is really needed because it wraps the C
functions for Python and yet of course
writing has no equivalent type so this
this variant of wrapping is the only
direction that works here and in
addition native C Python extensions or C
patent office API for extensions that
allow the extensions to define complete
custom types and of course Dragon could
not be aware of these two so this
approach also works there okay finally
we have the problem with the macros
here's one illustration of such a macro
it gets the long value out of the PI
integer object and yeah it's very used
very frequent frequently they are
defined in public headers so just
looking at the headers you will get the
impression that it's nice to use them
reading the manual you will get the
impression that it's not so nice to use
them but in the end tests doesn't matter
much because they are just used as
effect as a matter of fact
yeah yeah so mirroring the data allows
macros to work but of course then I ran
into a synchronization issues which is
not so bad as long as global interpreter
lock is existent but with guilt-free
mode in mind it is not so nice but mmm
luckily these macros mostly exist for
immutable types so I get away with an
initial synchronization yeah there are
some edge cases eg PI list where I do
some other tricks but I still managed to
have only one source of data and also
will get away without synchronization in
that case yeah like okay I can just
quickly sketch how this works internally
the drivin PI list implementation uses a
Java list but it stores it only a type
by the interface so I can have a custom
list and implementation it in that
insert this and that deals with this
okay so far so good again let's come to
the main issue which is garbage
collection which has the potential to
blow everything up but okay why is
garbage collection an issue okay in my
illustrations I will usually have this
gray line the buffer line is JVM world
below the line is native world JVM is a
buffer line because it's the high-level
language okay let's say we have a native
C object just even independent of this
giant giant giant shiny case now yeah
and let's say we have okay we can we how
can we access it from Java we would have
a Java appear and that stores a native
handle and by this way we can access the
native object through a j'ni
now how to do garbage collection okay
this is the back end you could use
finalizar but we are no finalizes are
evil and so let's do it the right way we
have a weak reference we have reference
queue we after Aggies GC run this isn't
quite and cute there and we pull it okay
now we know we see we don't have the
handle anymore so we notice it must be
stored in the reference we have really
weak reference subclass and now we are
able to use the poet weak reference to
free our native memory but wait we could
have there could be other objects that
need this so we have to do reference
counting and this is in fact an entry
and yeah in incrementation of reference
count can we have Java objects about
Java objects pointing to this because we
do a good design we let them all the
ways used to the pier and only have one
pier so this is not an issue but okay
this would work in this direction so far
let's consider the other direction we
have the Java object and remember Johnny
needs both both directions
we have Java object and we want to
access it from Seaside then we have a
native pure object and yeah somehow we
must assure that the garbage collector
wouldn't collect our back-end because
otherwise we yeah have a problem and
would probably sec forward or something
okay in Jana there's this concept of the
global ref which keeps the reference
Java object alive indefinitely until we
explicitly free it okay again so far so
good but now the Java object could point
to another Java object onto another
object and suddenly we could have the
situation from the slide before and now
guess what this one could hold reference
count of another native object and
we can have a cycle and this type of
reference cycle
it's absolutely immortal because the J&amp;amp;I
global ref is never freed because - yeah
we the destructor that would trigger the
explicit release is never caught because
it is incremented and yeah cpython
usually deals with reference cycles by
active searching for them in their
garbage collector and this search would
ultimately fail here because it cannot
trace the Java side even if we would
provide a mechanism to trace the Java
side which I actually did but mainly for
debugging proposals proposals yeah even
if we would allow this then the
complicated reference graph would not
allow to trace it here to treat this
situation unless we would do a full
reference counting on Java side so
tracing is not enough we would have to
count them but as I mentioned before
reference counting would imply to have a
gill enjoyin which is obviously no opt s
it contradicts one of the one of my main
design goals so how else could it be
done how is it actually be done in
Johnny now okay let's say we have a
native object
oh no let's say we have several native
objects and let's say we have an entire
reference graph on the native side okay
in CPM this is kept alive but there you
have some entirely immortal objects
which are usually a list of loaded
modules and the type tickets and yeah
these are immortal and keep the
reference graph alive and what I do now
is I explore this reference graph by
using the C patent reverse traverse proc
mechanism that is used for by the C
Python garbage collector and I rebuild
this graph on Java side
with light white objects that only saw a
handle and yeah I think it's expensive
enough but so let's keep them as cheap
as possible and note here that I don't
copy all objects I'd only have to mirror
those that can have references to other
objects that are exactly those that
cpython would would register at it's
garbage collector
yeah these tiny objects on Java side I
call the them I call them GGC hats and
also copy this mortal sight into static
heart references and I let have every
year GC had a ref count for its native
counterpart yeah and now we can have
Java objects that also a yeah have a
part in keeping something alive and it's
yeah this goes through to native side we
can have Java objects kept alive by
native objects indirectly now which is
reflected by the addressee head okay and
so usually directly see there are also
GC heads that have a bit more than they
have their handler they must keep a lot
of some objects and this is now the
situation where the native object where
I used the tiny globe ref I glow breath
before now I can use a jane i wit global
reference and the object can still not
vanish because as long as the native
object exists the jane igc head exists
because yeah because the reference
graphs are equal and they change down he
would have been reflected here yes this
updating this is not an issue for itself
but so this is kept alive but no jane i
a global reference is involved yes and
now let's say some part of the graph
becomes unreachable on the native side
and i added code that reports this to a
java side and let's say also
there are no java objects anymore
keeping Java site alive then the Java
garbage collector can collect this part
of the graph this triggers reference
decrements and you have the counterparts
to vanish and finally also indirectly
reachable objects will vanish and
everything is cleared mission
accomplished
isn't it ok let's quickly go how much
time do I have
ok and then I assume I have some more
minutes ok let's go quickly through the
variants we have if we have just 2 pi
objects I use just normal drag VC hat in
case we have PI objects or native side
that are needed by something on Java
side this is the case where I call which
I call PI CPU which is itself - pi
object and in this case I have but I
have PI CPA extent the GC had a GC hat
is actually an interface and there are
some handful of different
implementations and Poggi's pi CP is one
of them and yes this here is a very
simple basic implementation used but
such a CPU could have references to
other objects in this case I use a bit
more complicated version of Pi CPU that
also store ascenders to them so they are
kept alive on Java side or their GC
heads are kept alive on Java side and
this also extends Johnny GC head and
yeah finally we have the third situation
which where the native object has a Java
back-end and in yeah ok I already
illustrated this in the sketch before so
ok let's take a look now at the heart
case when how can spray
okay we have this reference graph right
before it would have been deleted by
javac GC Java GC did not yet run and now
let's say some native extension that's a
reference on native side by using a
macro then the macro very way is
something that is not detected or not at
once reflected on Java side I try to
keep this a rare case yes you sometimes
I just react the checksums to a distinct
to find out whether the graph is still
valid but even how many how much care
you take there can be the situation
where the Java ZC runs on an
inappropriately reflected reference
graph in this case it would delete this
although it is the native site is still
needed and yet to make this still safe
before removing the native side I check
the reference graph for consistency I
can check it for internal consistency
and if there are reference counts that
are not explainable within this graph
and something from outside must have
changed and in that case I do a yeah I
do a reacceleration of the graph I don't
have to do a fully full reacceleration
because I know the objects that might
cause stuff like this so I can only it
is sufficient to start exploration and
at some certain critical objects but
wait something missing here what about
this guy yeah and to handle this
situation I have to do resurrection sure
it was the oh it's the only solution
that was feasible to handle this
emergency case
which is a rare case it's just an
emergency case but still I don't want to
have a crash in this case and so the
resurrection must be done at least and
with current GC functionality over on
resurrection
yes I want to state here that while it
is not recommended it is a legal
operation and yeah okay it can only be
done from a finalizar so some certain
GGC heads master fine lasers but I take
care that they are only used when needed
and yeah only for objects they're aware
this backend situation is there and yeah
finally resurrection has some more
problems if we had a weak references
that pointed to this objects they break
and in jasmine case we can restore these
references by some magic which works by
yeah we can delay the the callbacks of
the rear of the weak references for a
while and in case of GC run we can we
can wait until the deletion of the
object is confirmed and if a
resurrection is detected I can restore
the weak references yeah
the other problem is that the
resurrected object might have four might
hold references to other objects that
then that are also resurrected and these
objects might have finalizes and this
might run although the and freer area
press those resources that are still
needed and this is also a problem and we
have special finalizes in jivin at least
and for these dry finalizes i can
prevent them from running in this case
also because once there's a special mode
in the java in the in the jivin garbage
collection module that enables a delayed
finalization that means that the the
actual finalizes only at some some
methods some some at ourselves to a list
and after the last finalizer has done
this the whole list is processed but
yeah in this case we we can also confirm
that the objects were really deleted and
these delayed weak reference processing
and this delayed finalization is only
activated if china is loaded so no
impact on ordinary jython
operation here so now while i have been
a tension of some of the JVM core
developers I have a wish list to make
this bit cleaner one idea would be GC
virtual objects I imagine they could
there could be an interface that they
implement and if I implement this
interface the object is able to veto on
garbage collection and yeah in this case
it would be notified that it would have
been deleted now but it actually isn't
deleted keep in mind that you can
already do something rather similar with
finalizes but in contrast to a
resurrection by finalizes subsequently
deleted objects would not get their
finalizes called
and weak references would not break this
would make life a lot easier at least
for the journey use case ok obviously I
cannot achieve this by reference queue
mechanism because that doesn't allow me
to keep the object to life at all
somewhat alternative approach which
would also be a nice addition but I
think I could also do the things in some
other way with this would be a more
precise notification of GC phases I
would like to have a listener that is
before the garbage collector explores
the connectivity graph and is even able
to change it make some objects quickly
reachable or keep them from deletion so
you I could prevent the resurrection
situation and I would like to know when
clearing weak references starts and ends
and when finalization process starts and
ends there's an inner fish for some of
this around this Java annex bean but it
turned out that it doesn't work properly
yeah the events came too early or too
late and I tested this and yeah it
didn't work to some excellent I can I'm
so I can't lean this yeah by some dirty
tricks I insert a sentinel and add a
weak reference and measure the time when
it is collected and this way I have an
idea of the time and then yeah in the
end I just wait for the garbage
collector and hope that it is done then
and by measuring this time it is very
likely and I yeah okay very ideal this
could avoid the whole situation oh okay
no okay wrong wrong wrong order okay
there would also be some GC features for
from native perspective I would like to
have to it we have standard methods for
okay I believe maybe I reinvented the
wheel a bit here with this situation
there are several frameworks but that
have some more advanced native memory
management like reference counting or
something else I don't know but I think
there should be guidelines or standard
mechanisms that explain how one should
bridge these with j'ni or maybe we
project Panama yeah and I would have
liked to have an interface that tells
the Java garbage collector about native
memory usage so it can take it into
account when deciding that it should run
ideally maybe one could tell it how how
much memory would be freed by which Java
object then it could also take this into
account and the very ideal situation
would be that one could have could allow
it to trace native objects and yeah on
top of this yeah one could avoid this
whole situation this would mean
basically yeah somehow bring this
mechanism I currently do for garbage
collection make it a feature of the JVM
meant that would deal with this okay and
I know probably some some of these
features were already proposed sometime
I'm not a core developer and I have no
idea how hard they might be to implement
just want to start a discussion and if
there should be positive feedback on
some of this I would also be willing to
draft a gep or something for it okay
then I today or yesterday I already
asked this stuff about this exporting in
the sum of symbols yeah the pain with
the JVM is that you cannot control how
dynamic libraries are loaded and you
need a special flag that allows native
libraries to export their symbols to are
subsequently loaded native libraries and
this flag is usually not not used so in
fact I have to do a workaround I have to
have a layer that is just loaded push
pushes through all the Draenei calls
just to be able to load the actual
library I need with another flag because
so that the library is able to export
its symbols to other libraries so some
more control
of the symbol order I also discussed it
a bit with Charles maybe there can be
some additions to this yeah okay this is
this workaround more control on JVM side
about this would be helpful well then I
would have a dream and that would be
that I could have arbitrary symbols that
I can define on Java side back then by
Java methods and export them to a loaded
dynamic library for call backs I don't
know whether this would be possible
I just wanted to state it as an ideal
situation for instance I want to do
things like then you could do things
like implementing some graphical
framework and loading let's say GIMP
plugins or something I don't know or the
architecture gimmick uses foil for its
plugins but I believe it's a typical way
for plugins to export symbols for calc
for callbacks on genomic library loading
ok then some future work I'm almost I
think I almost reached C type support
hope to get this done in time for the -
two - two point seven point one release
then I will have to add support for a
new style classes and yeah the big goal
is numpy support which is rather
involved because it has so many
dependencies on other native libraries
windows support is also not yet done
currently it's only Linux only and
finally after windows support works
which will mark Johnny two point seven
point zero I believe I will focus on
some optimization try to reduce number
of Jane I call this that are needed and
maybe explore the guilt-free mode and
one day when Jonathan 3 would be a bit
more on the way I was
consider two right Johnny three of
course which would be a nice opportunity
to use new FFI features of the J of the
JVM now finally I would
in first place like to thank the Python
Software Foundation for funding my trip
to the jvm language summit and in second
place I would like to thank you for your
attention
any questions I actually didn't test
that much and it's I think it's only so
few things workable that
yeah the performance tests are not so
yeah not really doable now but I think
the performance should be quite good if
there are not so much calls but few
calls that have heavy workload for
instance for now which is ideal for
numpy yes other questions
yeah thanks thanks a lot
yes yeah let me quickly go back to that
slide
when this graph is detected I
intentionally I intentionally don't
reuse the old objects on top but I
really and recreate the GCE heads so
that they are new objects and have new
finalizes that can run again exactly
the lives lifecycles of the deceived
generations
okay okay I I'm not sure whether I
understood this completely but maybe we
can go into it offline again or
something okay and so things that depend
on you know finalize our lifetime your
finalizar might be running within clock
cycles after the outfit was made we grep
might die almost instantly there's a lot
of funny issues appending on these
things that asking for that support of
GC is interesting you should go back to
the list of options you had cuz some of
them look like doable with some hard
work and some of them look like not
doable and maybe I guess I see I see
Brian thinking that maybe this is an
open-ended discussion
okay oh by the way what I forgot to
mention about gear free mode what
extensions may not do then there since
extensions can almost do anything they
want they might create islands of such
immortal objects they could have other
state seeds inside variables that are
not reachable but still hold reference
count and this would break a potential
gear free mode for this usual mode is
it's not such a problem because if they
do it properly they have to register it
at the cpython GC which is in here in
this case we implemented by me so I can
detect it but okay yeah I said the
second idea first to have Gil free mode
I would have to not only to replicate
that graph that part of the graph that
can add that can have references to
other objects I would have to replicate
the whole graph because Bill free mode
would mean that reference counting on
the native side is not trustable you I
would monkey patch the DI locator and
just completely ignore the reference
counting and use this machine ism for
all native stuff and yeah since in that
case the such islands such unreachable
islands could also consist of objects
that are not reported to GC yeah these
situations there these are things that
native extensions may not do to be a
suitable for gear free mode and also
this sorry one moment this second is
hard case this emergency should see a
resurrection and everything would also
not be possible for give free mode give
remote extensions must not cause this
situation okay
no I think officially there is no
guarantee on the timing of the finalize
errs I just repeat the answer I got from
the Python mailing list</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>