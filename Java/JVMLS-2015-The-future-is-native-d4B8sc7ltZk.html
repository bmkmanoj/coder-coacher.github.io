<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JVMLS 2015 - The future is native | Coder Coacher - Coaching Coders</title><meta content="JVMLS 2015 - The future is native - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JVMLS 2015 - The future is native</b></h2><h5 class="post__date">2015-08-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/d4B8sc7ltZk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone today I'm talking about how
the future is native and ways in which
Java is learning to interoperate better
with native data it's a lot of fun to be
back here at JV MLS so I missed last
year so it's good to see lots of
familiar Flay faces and new faces as
well so my slides of course have to
start with our safe harbor claims of
everything i say is a lie don't trust
anything don't make any decisions based
on what I'm saying all be simply slides
by the end of the talk or by the end of
the the conference so Who am I for those
who don't know me I'm the interpreter
team lead on j 9 j 9 is ibm's
independent implementation of the JVM
I've spoken here in the past related to
29 to invoke dynamic and 3354 lambdas
I'm also the guy who's responsible for
IBM's implementation of those so if you
want to talk about those as well come
find me later and I've previously done a
lot of work with the verifier so what am
I talking about today the purpose of
this talk is to tell everybody here that
if you care about native data you need
to get involved you need to make your
use cases no one if you're doing native
data if you're writing a lot of jni code
if you're using unsafe direct bytebuffer
you know whatever it may be that you're
doing you need to surface those use
cases we want to know what they are we
want to be able to use those to help
drive the direction of native data
interop we have ideas we have experience
with a number of different things that
we've done with prototypes but we want
to know what you're doing and how these
directions fit with solving your
problems so you know I will repeat this
again at the end with some more details
on how to get involved but really this
is about asking you to share your
experience so you know here's what I'm
going to talk about i'm going to start
by talking taking a look at packed
objects packed objects was an
experimental feature that we added in
java 7 and we addressed a bunch of
interesting problems with data locality
and then dealing with off heap
so you know we'll take a look at that
will take a look at how we've used that
experience to help drive our
contributions to pack to Panama and
Valhalla and then we'll took look at
layouts which is coming out of Panama
and some of the open issues so what is
packed objects back in Java after we
released Java 7 we'd done a bunch of
work we wanted to get that out there
wasn't quite time to release Java 8 yet
so we put out a technology refresh we
call java 7 1 and in that we had a pact
objects as an experimental feature that
you could try why do we put this out
there we wanted people to have an option
to improve the serialization and IO of
java objects we wanted to be able to
make it easier to work with native data
and we wanted to remove a lot of the
overhead of dealing with with the small
data and improve data locality and we
wanted something that you could write
easy Java code with so if we take a look
at you know a simple layout in in Java
this shows a hash table some of you may
have seen slides like these before I may
go fairly quickly through parts of this
this is mostly about what we've done and
an experience report on packed and some
of the the open design issues and design
challenges we have so here we've got
some Java code you've got a hash table
it points to an array each of the
entries in there is an object right but
we've got some overhead we've got a
header on each of these things and to
reference anything in here we do a lot
of pointer chasing so we've got to walk
our way through to actually do any look
up these may be spread all over the heap
so we've got cache misses and other
kinds of problems and locality right
there's no claim that any of the fields
that you want to touch are actually
nicely together they may be spread out
you're looking at this and thinking this
is a simple example yes but we've seen
you know it's not uncommon to see
customer code that has hundreds of
fields and there's no reason that these
fields are going to be connected nicely
together so what are we trying to solve
well locality problems come
in other flavors as well if you had a
class and it had a bunch of fields and
you wanted to say that these two fields
get used together soul declare them
together in a source that doesn't
actually help you the JVM is free to
reorganize your fields and it does we
want to put lungs and doubles together
so we don't waste space they need to be
maligned on 64-bit boundaries we want to
put objects together it helps the GC and
then you know we may even have cases
where a superclass had some padding in
it and a subclass can stick a field in
there and make use of that pattern right
so we we've got no guarantees from the
JVM on how your objects laid out so
that's you know on he play oats and then
we've got you know native code here and
maybe I've got a native or Ravens and I
really want to be able to access that
array and I really want to be able to
access it as though it was a Java inter
a I want an easy solution right I don't
want to have to write J and I code I
don't want to have to get into unsafe
for DB bees I don't want to have to
marshal this data okay so you know we've
got the idea of how do i do away with
headers how do I bring these objects
together how do i flatten this data and
how do I allow better native interop you
know if I take a look at this structure
here I've got two structs I've got an
address it's got a char array to give me
the address it's got a short for a port
and I've got some struct called a header
which has two of these things so I've
got them you know nicely sitting
together this was where we started when
we started looking at packed objects how
do i get a layout that looks like this
in java and this is why we developed
packed this was our prototype to address
some of these things so if we want to
start looking at packed objects under
the cover what we're going to do is
we're going to show some examples of
very simple Java code and then we're
going to show the pact equivalents this
is not because I'm trying to say all go
use packed it's because i want to show
you how we developed our solution for
this and then get into some of the open
issues there so i've got a point here
it's got an
why and if i want to make the pact
equivalent here's what it looks like
wait a minute though it's bigger than
the normal point which kind of goes
against the the goals that we set out in
the beginning we wanted to make things
smaller impact things together and here
I've gone and added two fields so what
are these fields for the target is
always going to point to the object that
owns the data and the offset is going to
be relative to that to the target and
going to tell you where the data starts
this is the standard unsafe addressing
mode if you've played with you know I'd
say if you've seen these same kind of
address modes right you know here's just
the the picture with the points or the
lines showing where they point to so if
we actually want to read this data we go
target plus offset and there's my data
alright so now I've got a line it's got
two points in it right and standard Java
it looks like this impact it looks like
this right we've got the data directly
in line in the pact line so here's where
depending on the size of my headers I'm
starting to win footprint wise you know
I've improved the locality of this
because now it's right there and one
thing and we see the target points to
itself the offset points to the start of
the data great and I still have those
two points there each you know directly
in line here and the code looks pretty
reasonable for java code rated it seems
to be the code you would want to write
though it does have a couple of you know
at packed annotations all right so you
know going back to just this if i want
to then you know access one of my points
in here how do i do that you know how
does the model work so i write the code
that says you know a pact line dot e and
i want that to be that second point you
know first the source for this looks
like normal java code which is both good
and bad it means it's very easy to write
the code but it also means that it
doesn't do exactly what you thought it
so when we write this we actually have
to proof up an object header so your
access to this is through this extra
object header that we grew and as we
know the target points to the pact line
the offset points to the data that I
want to talk about here for my
particular line so it's easy to access
you may be thinking wow you know a lot
of operations this is going to be a lot
of GC pressure but in hot code a lot of
this can be optimized the way that it
doesn't have to create these extra
headers and there's still you know we're
still GC safe there's no real internal
pointers here at least not without the
direct pointer to the pact line okay so
we want to take this and we want to
extend it to two native access we have
some data an instructor that looks just
like our point it's in native memory you
know what does the Java code for this
look like well looks like you know
exactly what you want it to look like so
how do we tie these two pieces together
right again it's the unsafe addressing
mode except this time our target is null
and our offset is an absolute address so
if we wanted to build something and see
you know going back to my address and
header example we expect something that
looks kind of like this you know it's
got a number of good things going on
here that's got the nested substructures
its compact there's no headers and it's
got you know good alignment for
forgetting access to the data so if I
wanted to build the same thing in Java
right we're back to Java is all about
memories I've now got headers again I've
now point chasing pointers I've got you
know no locality I've got no guarantees
that these things are close together
something has to give here if we want to
be able to get back to that nice native
structure so if we did this impact
objects you end up declaring very
similar Java code to what you want this
to look like and we've got this
structure crammed nicely underneath
right we're still on heap though
but we've you know definitely increased
the locality of this so if I wanted to
do this with Java and I wanted to access
something that's off heap how would we
do this right you know I've got my
native structure still looks the same
how do I talk to it the first tool most
people reach for is Jay and I and you
play the usual I want to stash a pointer
in a long trick and there's a lot of
overhead here Jay and I one isn't fun to
write nobody enjoys it people frequently
get it wrong most VMs have a check mode
to make sure that your Jay and I code is
correct because it's very easy to
accidentally stash a local ref somewhere
it shouldn't be stashed use it from the
wrong thread or use it after you've
returned you know Jay and I is slow you
have to process things so the GC is able
to run you have to build the right stack
frames you need to pass out indirect
references for things there's a high
cost to do Jay and I especially if all
you want to do is a field read so people
often either you know cash those things
you look it up once and you cash it
internally or you do some other kind of
game where you copy the whole data in or
you move to a direct byte buffer right
you don't have to write J and I which is
good easier to get right but now you're
keeping in to see straight you've had
the head to map what these indices are
so that you can actually do this or
you've stepped all the way to unsafe
which looks almost identical to the DB b
code because let's face it DB b is
basically just a wrapper on and safe you
know none of this code is fun to write
none of it's fun to maintain and you
really shouldn't be here if you're
playing with unsafe no reaction to that
so impact right you know I can write the
code that i want to write i can access
the data off heap I've got my target is
no my offset points to this data it's
really nice and it manages the the
indices for you great you know that's a
very quick overview of packed it's a
quick look at you know what packed is I
don't want to spend too much time
talking about that but I do want to look
at some of the the design challenges we
ran into with packed some of the things
that made it hard for people to pick
packed up and run with it so one of the
first things is the annotations for a
number of reasons mostly related to
making it easy for the JIT to top two
mice things we require that you had to
say import packed for any packed class
you wanted a reference this is very
painful for people to writing writing
the code base they then need to know
every class that gets referenced in
their class they need to declare it as
packed and as they're modifying their
system and making things packed you have
to go back and update all kinds of
places that you know now need these
annotations you know packed array types
or any type that you want to be packed
has to descend from packed object class
primitive arrays aren't interoperable
with packed arrays and you know it's not
quite conventional Java so let's take a
look at some of these in a little more
detail so for packed objects we put
packed object the class under the object
hierarchy good and so any class that you
wanted to be packed had to be a direct
subclass of packed object or a subclass
of an abstract class under packed object
which you know used up your I want to
inherit from something single slot that
you get in Java it also meant that you
had to fully buy into packed there was
no way to use packed here and use
something else somewhere else if you had
some kind of structure you want to talk
about you were buying fully into packed
going to retrofit your code to use
act in all places that's a really good
question the question was does it
degrade is it an error does it degrade I
believe it degrades but it depends on
which version of the prototype you were
running on and I'm it's hard to keep
them all straight great and so you had
packed arrays for these things which
were you know very nice they flattened
your data and they got good locality but
they couldn't interoperate with you know
byte arrays you had to do something to
mediate from your pact thing to a byte
array and we can't really reuse the
existing Java syntax for a lot of
concepts because they're different you
know what does it mean to put an object
or something into a packed array it's
really more of a copy than an assignment
and if you make equals do the copy it
may not operate in the way people think
right it's very easy to break users
mental models and we saw this a lot with
our research teams and our test teams
who tried to take packed and use it for
different things they were constantly
struggling with wait a minute this
doesn't quite mean what I want it to
mean packed arrays right so you know
assuming my array is a packed array and
you know I'm not using the copy from
syntax here so the syntax isn't quite
right ignore the improper syntax the
point here is that once you put your
point object into that array and then
you go to take it out you've created a
new header for it so they're never going
to be equals equals at least not in the
interpreter so this code is act that if
statement is never going to be true now
the caveat on that is if things get hot
enough and you get away that extra
header this might suddenly become true
you know this is really not what you
want so nested fields if I've got my
packs line and I want to initialize this
nested field I can't use equals these
aren't reference feels right so if I
create a new object I can't use equals
to assign it that's not really what it
means I need some kind of copy or some
kind of initialization for it I need
some way to or some set of default
values for X&amp;amp;Y when i created my my line
class what values do i set to x and y
it's got them in line right so I've
pre-allocated that memory do I set them
to zero do I set them to something else
okay you know it's a prototype so maybe
we just explicitly assigned each of the
fields ourselves you know anybody doing
this is going to grumble a lot but you
can make it work which can let you you
know move forward and see what other
issues are still in this prototype until
somebody declares point to be final or
starting in to be final now I can't do
this java sea starts to fight with me
and yes i can go hack java sea for this
but what does the semantics of this
actually mean right it becomes a user's
mental model problem of how do I teach
people to treat things as final what
does it mean when I put them off heap
final may be something that we can
enforce from the Java side but there's
nothing going to prevent the native side
from modifying it if the native side
modifies it what does that mean for when
I have to read that data when I can cash
it when I can skip reading it volatile
starts to run into similar problems you
know we have a copy from api and it's
easy to change the values of x or y
without triggering the volatility checks
identity right I've got two packed lines
that point to the same native data
they're not equals equals but the data
is the same what does that mean for
people how do users make decisions about
this what kind of invariance can you
build into your system when your data
can be changed by some other object you
know this is not the semantics that Java
typically has right and there's the same
problem what is synchronization mean in
this model what kind of invariance can I
impose on things when synchronization
doesn't really mean anything I've got
lots of ways I can point to a reference
that data and modify it and none of them
can be you know if I had some invariant
that said I had to to modify them or
limits on what the values could be I
can't enforce that using synchronize
finalization when am I free to finalize
this this particular object right point
0 isn't referenced anymore can i
finalized it when it's not referenced
can i finalized it when polyline isn't
referenced how do I explain that to to
user you know weak references are really
the same problem same with soft
references what's the lifetime of this
object and you're thinking okay well you
know whatever you don't use that well
then when do I know when it's safe to
free that memory how do I know when I'm
okay to tell the OS to let go of the
native memory so that's a bit of a look
at some of the issues we ran into so
next let's take a look at sort of where
we've taken our pact experience and how
we're pushing this forward so we looked
at pact we looked at some of the design
challenges we've dealt with the
prototypes been good it's helped us move
forward on looking at things like
flattened data on looking at off heap
access right remember this this talk is
about experience it's an experience
report and it's helping drive where we
go from here so we had a bunch of goals
with packed I've shown these earlier a
number of these fit very nicely with
Valhalla right these are about flattened
data which I'm hope
I think Brian and company are talking
about later great there's lots of
overlap here between the on heat packed
and value types all of the off heap
stuff fits very nicely into Panama so we
look at it as we have some experience
from packed objects we have some
experience from other areas we have ddr
which takes the vm data structures and
stores layout information for them and
then lets us debug with that yarn will
be talking about that later today I
believe and we want to take that
experience and help drive it into Panama
in Valhalla and we want your experience
in there as well right you know I'm
repeating this over and over again
because it's really a call to action
this is a room full of people who care
about native data who care about the JVM
and the future of Java and so if you're
not speaking up we need you to please
get involved so you know shifting gears
now a little bit what's layouts layouts
is where we're going this is the next
set of prototypes to address native data
so a lot of the information that I'm
going to talk about here is from the
state of the LDL or layout descriptor
language we've been posting this on
github and pushing it to the Panama spec
experts list fairly regularly you know
please take a look at it offline share
it around comment on it so what's the
problem that we're trying to solve all
right let's step back again we've got
you know your language runtime and you
want to access that great c library and
you don't want to write j9 you want to
do something from your OS that isn't
standard Java and I 02 is great but it
doesn't cover everything you've got some
legacy system then you want to
interoperate with its data you know I I
list COBOL here we've got a lot of
mainframe customers who are still
running a lot of cobalt or you've got
some awesome hardware RDMA you want to
you know drive that IO from Java you've
got some GPU you want to drive that
compute you know how do we increase
static locality and remove copies well
you can play you know Jay and I nobody
likes Jay and I
you can play the offsets game doing you
know unsafe or gbb but both of those are
hard to keep up to date especially as
your systems are modified right if you
modify the layout of your native
structure you have to come back and
modify all your Java code that deals
with it you could use packed objects but
what we really need is a better way to
do this so if we keep looking at our
problem we have some kind of native data
it might be C or C++ it could be COBOL
it could be network packets POSIX
structures proto buffs p value stores
you know whatever this data maybe it's
something you want to interoperate with
and it's not something Java knows about
but that data doesn't live on its own it
comes you know encompassed with an
environment is it 32 bit is it 64 bit
did you compile with pragma packed what
kind of padding did your compiler put in
are you on a bigger little-endian
platform is your you know structure
defined to be a certain Indian like a
network packet which compiler did you
use which OS are you on what library
versions right there's lots of things
that come together to tell you what your
data actually is and you need to be able
to look at all of them as a big piece so
you take your native data and then you
need something that you can program
against so you need some way to take
that data and express those offsets
express those bits in something that you
can work with we're calling it a layout
descriptor language you also need
something you can program against so
some kind of stub interface
generating the LDL right now we don't
have a tool to do this yet but we do
have people working on tools to try and
make this work particularly the first
thing we're looking at is C and C++
headers so we packed I said you had to
be a subclass of packed object one of
the benefits of using interfaces here
instead is that you can gradually
migrate your system to this you know as
a user you can implement that same
interface provide the implementation
that you want and for the things that
are off heat you can use the same
interface and deal with the native data
it just lets you abstract nicely over it
this is good it may have a jet cost the
more times you implement that interface
so I've got my native data I've got my
stub interface and then I've got some
runtime behavior so you know ignore the
use of unsafe on this slide it's just
there to get me my native address but I
have some layout factory I get the
factory I asked it to map my layout
which is some point class on to this
address and then i can just operate on
it using methods right so this is a very
unsafe way to work you know there's
nothing saying that you actually have to
have allocated the memory you're trying
to talk to right now we're allowing just
passing any address through which is not
you know the end goal so one of our
prototypes has a layout factory that
looks a little bit like this I know
there's a lot of text on this slide I
don't actually expect anybody to read it
it just shows some of the ways we're
looking at how do you map layouts onto
onto data it might be you have a long
address like I show it on the last slide
or you might just want this to be some
matters or some memory allocated on the
Java heap maybe you have a byte array
maybe you want to create an array of
these things so we've got different
api's for each of the you know one
dimensional array or two-dimensional
array or whatever it may be this is not
a final API alright this is just
something to let us explore and
prototype and play with to find out what
the right direction is all right so
that's sort of the Native data and the
runtime
system now we need some way to describe
how this is all going to interoperate
how it's going to work so the piece that
describes it is the memory model you
know this gives us the meaning to what
those bits are gives us the meaning to
how we access them there are many
diverse languages with specific rules
regarding data access we can't describe
them all we can't give you the answers
for all of them so we're going to look
at you know some of the most popular
languages for dealing with negative data
which if we look at TI obe you know jab
is the number one most popular language
why we're here right C and C++ are the
next most popular these are sort of the
common language for data access so any
memory model we provide should be fairly
consistent or compatible with C and C++
so we take a look at what the C and C++
memory model says it says memories
really an array of bytes and then it
points out a couple of interesting
things that I've underlined here that
memory locations are what matter and
these matter to deal with concurrent
access if two things are in the same
memory location rights to them are
allowed to interfere the reason for this
is it means that the compiler can take
certain liberties when it's reading and
writing data and those liberties are
well understood by compiler writers
makes it easier to optimize so that's
something we want to keep right to show
what this this actually means if we look
at you know two structures the only
difference between them is that one of
them has this extra you know zero length
bit field and that has forced the to
container version to have two memory
locations so if I have two threads
writing on them one of them is going to
interfere in the one container model and
the two container model this is actually
safe I don't have interference right now
right this is because there are two
separate memory locations okay so you
know layouts need to have some similar
memory model they need to have some way
to talk about how the bits are laid out
so we've got fields which are continuous
sequence of bits and we've you know
adopt
in le centric bit numbering scheme and
then we picked containers rather than
memory location which is very similar
it's basically the same idea and we've
allowed you to specify the
containerization in your layout
descriptor so if two fields are in the
same container you can say that if
they're in separate containers you can
say that as well I try to find out you
know from my notes why we picked the
term containers that a memory
utilization or memory location and that
rationale seems to be gone so we may end
up switching that so looking at this
again right well I've got a field it's
some sequence of bits fields are
collected into containers it might be
one field per container that's up to you
containers are about concurrency and
then I've got the idea of unions in a
race right if you've written C code this
is very familiar to you a union is a a
group of overlapping members so
overlapping sequences of containers and
an array is a sequence of containers of
the same type all of these things are
members so if I want to talk about Union
really a union is a sequence of
overlapping members which all boil down
to a set of containers right we're
talking about how the bits are laid out
in memory here and this is sort of text
that describes the same thing it's taken
from that state of the LDL document so
you know tearing early java allowed
32-bit machines to tear lungs there's
points at which atomic rights can't be
done and we have to allow tearing so
anytime you're writing inside the same
container the model has to say you're
allowed to modify these things and
rights may interfere with each other if
you're accessing separate containers
they can't and then we want to have the
idea of atomic you may have some
invariance when the data that you're
writing gets written into memory that
you don't want somebody able to be able
to read partially written data so you
know to force this in we've said maybe
there's a reason to make containers
atomic
now this is sort of a best effort on the
VMS part because if you've specified an
absurdly large container there may be no
way for us to actually do that
atomically we could take locks on the
Java side so the Java side is consistent
for this but we can't force the native
side that you're talking to to obey the
same rules and then the last piece of
data access has to do with end you know
you know are you big endian or little
endian what we said is that containers
have an Indian you can define whether a
particular container is little endian or
big endian and that tells the runtime
system how to read that data alignment
very similar to to see the alignment is
for the entire container and it's based
or sorry the entire layout and it's
based on the maximum required alignment
for any particular container and the way
you do that is sort of a recursive you
walk through each of the members in your
layout find their containers round the
size of that up to 2 to the N to get
your number of bits and that gives you
what your overall alignment for the
thing is so that's how the bits get laid
out in memory that some of the data
access patterns for it and then you need
some sign of type information to tell
you how do i access this data or what's
the meaning of this particular sequence
of bits so there's primitive types in
Java when your data maps from the
primitive types that's great unsigned
throws a bit of a monkey wrench into
this as you native data frequently uses
on signed Java 8 helps us a little bit
by adding some methods to classes like
long and integer to deal with unsigned
math it's still not a perfect answer the
other thing I'm going to have a
structured types this is where I've got
a layout and I want to add you know this
is my pact line where I have my point
inside it might need some structured
layout to describe the points inside so
I can talk to them the accessors for
these are going to give you back another
layout instance that points to the same
thing you know arrays and nested layouts
are the same then I've got raw types
maybe I've got some sequence of bits in
here that I don't care to give a job
meaning to or I don't have another
structure to map to it so i would give
you back you know maybe a byte buffer
here to be able to do you read and
you're right this could be for things
where there's no suitable java type to
map it to write if i have a 128-bit
integer in my native side i don't really
have anything in java that i can use to
talk to it and then I've got pointer
types I may need to be able to walk
through a linked list for my native code
and I need to be able to have the right
kind of abstraction to do that and then
I've got opaque types all of the bits in
a layout need to be exactly defined but
you may not want Java to be able to
access all of those bits so there may be
pieces in there that you say this is
opaque don't give me bits for it one
area where we're not clear on what the
right answer is is how does this play
with Rob it's right if I asked for a raw
access Iran my whole layout do I have to
disallow access the pieces that you've
marked as opaque and then effective
addresses right this is really the you
know sees address of a struct field it
becomes really important for cases where
you've got some kind of header you've
read the header to decide where to pass
the data to and then you just want to
pass the address of that data out you
don't want to expose the address pointer
operations to Java code because it's
very easy to get them wrong right it's
easy to incorrectly index something or
index outside of your memory so if you
kind of wrap it inside an effective
address call you've limited where this
can go wrong we found this really useful
in our ddr code which is our dynamic
dump reader stuff for dealing with self
relative pointers rather than having
everybody implement that where for
anybody who doesn't know a self relative
pointer takes the address of the field
as its value and turns that into the
actual pointer we use that a lot for
dealing with wrong data this makes it
really easy for everybody to easily do
those kind of operations without having
to manually do it everywhere and get it
wrong
alright so that's sort of a whirlwind
tour of the layout of the bits of the
you know data access and the type
information but there's a lot of open
issues there's a lot of stumbling block
still here this is about the experience
we've had and some of the issues we see
going forward for anybody who's written
language you've probably run into stack
map tables everybody's least favorite to
verify our related class Brian you know
shaking his head over there these are a
horrible horrible structure and I'm only
showing one of the frame types here but
this this has a fixed header and then a
bunch of variable data now you can't
process this nicely with a structure and
see either but it no it has this fixed
piece you know that I can give you a
struct for and then it's got this
variable piece and it's actually
slightly worse than this because it
actually has two variable pieces so how
do I deal with this in an LDL I can't
describe the full thing I don't even
know how big it is up front how do I
process this structure i can describe
the first piece of it but then how do i
safely take that to locals pointer or
the address of that and cast it
something else to read it maybe i use a
raw access or here and i read a bite
figure out what it is and then i can
cast it to the next sub structure and
walk my way through memory but again
this is a lot of unsafe operations what
if the memory i'm trying to talk to is
smaller than what the structure says you
know how to or have i done the math
wrong how do I ensure the safety of the
JVM that dealing with this kind of thing
isn't going to crash you and crash you
hard right and the memory lifetime you
know we looked earlier at some of the
issues with with packed objects on
finalization and weak references how do
you know when it's free you're safe to
free this memory how do you set up the
life cycle for this memory what's the
contract between the two sides on when
it's free or it's safe to free them
maybe this isn't a problem for the LDL
we just take our hands off when we hand
the problem to the users but those types
of solutions always come back to her
in the form of customer issues you know
when i'm debugging the crash because
somebody's done the wrong thing you know
i really wish i would have put a bigger
seatbelt on so you know what the right
answer is here we don't know yet if
you've got experience dealing with this
kind of problem you know let us know and
security right a lot of this comes down
to what's the security model here is it
a you know easy to climb fence that if
you want to crash your vm we say go for
it is it some kind of razor wire wall
that we don't let you cross java has a
culture of not crashing you know if your
vm segfaults that's a serious problem
you know we get lots of very unhappy
customers when that happens there's
security implications of this so we
really need to make sure that whatever
model we expose from ldls tries to help
you do the right thing native culture is
if you do the wrong thing you know
congratulations blow your foot off
that's really your problem but that
doesn't really work with Java so how do
we marry these two very separate and
very dilute cultures together and then
right there's all these existential
questions Who am I what's the meaning of
life no wait sorry what's my identity
right a lot of them come to how do you
say this is that piece of native data
versus some other piece without giving
people direct pointer access there are
answers here there are things we can try
we don't have all the answers right
again this is about experience so i can
pick on you brian but your quote here is
is good you know the the prototype LDL
grammar that we had picked was horrible
it was hard to parse mechanically and
hard to read for humans
it's one of those things that grumach
grew organically it was a little piece
here and a little piece there but it
ended up just being bad so we've kind of
flushed that moved to stepping back
looking at the model and how do we get
the model right so that you know when
the grammar comes out later it doesn't
matter as much so again you know I'm
here to tell you to get involved if you
care about native data interop get
involved now join the Panama spec
experts list get involved with project
Panama surface your use cases if you're
dealing with you know unsafe memory
native memory if you're dealing with J&amp;amp;I
a lot we want to know what use cases are
you using what things do you care about
you know take a look at the state of the
LDL document comment on it let us know
areas where it seems to have missed the
boat we don't have all the answers what
we're happy to do those work with you to
find what the right answers are you know
try out prototypes as they become
available you know Poquette packed a
little bit see what pieces that work
well and what don't for your use cases
and one of the other things we need to
know is have we gone too far are we
trying to solve too many big problems
here should we step back further and
give something simpler and smaller right
our use cases are we have those and we
know our internal teams but we don't
know what everybody else is doing so
please you know get involved and this of
course is my legal notice slide there's
no conference is complete without
multiple legal slides any questions yep
when he comes to a data layout minor
have you looked at there's a old but
quite powerful chemical dsm don't want
no I'm not it describes a crime to lay
out data over his leave for
serialization but swype are powerful and
it can't handle those variable sized
structures like those stat man pedigree
it also has like reports of leverage we
can already see ya who has partial
strand generators for pretty much every
language in existence I don't know it's
probably 20 years old but it's
constantly maintained industry-wide
standard daily so that was a SN one
occasion excitation TCS scan and that's
why we come to these conferences right
expo 93 ok thank you I will take a look
at that Jeremy
why so why is readability for anybody
other than the hardcore extremely
dedicated it's not really the question
I'm asking ok so the readability matters
because there are languages that aren't
easy to parse right there's no standard
definition of network packets so I need
something that I as a human can go
I'm not aware of anything for network
packets and we took a quick look
everybody likes to draw pretty ascii
diagrams or right you know a description
of it but there's not a well-defined
here's something you can grab it
yeah I'm not arguing that readability is
the main goal imac you know today we're
actually handwriting a lot of these but
we do have people working on tools we're
currently calling them growlers to go
read your C++ header files and generate
the job aside for you you can it's not
the sorry the question was why is the
variable size data structures hard and
the answer isn't that it's technically
hard it's that it's hard to do that in a
way that doesn't make it easy to crash
your BM right I could make that same
claim about Java code but as a vm
developer i still care about the
specification at the bytecode level just
because javis automatically generated
into byte codes doesn't mean that nobody
else comes along and writes horrible
byte codes that go over right you know
the zeroeth argument in my eye the
implementation has to be correct you
need some way to handle that kind of
data and there are times where it's
going to be wrong right customers get
things wrong all the time
right it's enforcing that jvm safety in
there if you've got smart users and
they're willing to do a little bit of
debugging on their own you can usually
get the right thing no problems the
description of field isn't fixed like
four bytes it's something variable
length in of itself and requires a more
complex over yeah it's a lot of the the
same problems I mean we have utf-8
strings which or Pascal strings right
they have a length and then a certain
number of bytes all of these come down
to the same problem of how do you do
that safely it's not that it's
impossible to write the code to do it
it's how do you get it right descriptor
language the description of how you
decode the data might actually yes and
I think most packet languages Commission
some point a variable-length something
County gray bar or something that's not
what we're trying to
we're prayin understand the next lower
layer that lets you pull up the mids and
then you can write some code
why
something worse if you have something
like that somebody needs to you for any
target domain you need to build
libraries
but there's a way to plug in thanks
everyone</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>