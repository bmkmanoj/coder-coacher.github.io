<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ask the JDK Architects | Coder Coacher - Coaching Coders</title><meta content="Ask the JDK Architects - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Ask the JDK Architects</b></h2><h5 class="post__date">2017-10-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Pr2v9E_oPXI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon welcome to ask JDK
architects here we are again I'm mark
Reinhold I am joined by John Rose Bryan
gets Alex Buckley I work on everything
John works mainly on the VM Bryan and
Alex work on on the language and how it
looks after the specifications so this
that there's hardly any presentation
here you'll note this is from 2016
because sorry I was busy with some other
slides today and didn't have time to
update it they're only they're only two
other slides in this deck one is that
one yes we still work for work the other
is well this is QA so we have a mic up
here we have a mic up here you can come
use if you're shy you could you could
tweet at me and maybe I'll repeat your
question maybe I won't I have had it can
exercise editorial control so have at it
we've got 44 minutes or so for QA any
question you everyone asked doesn't mean
we will necessarily answer them so
Mike's right up here or if somebody
wants to run it around and do that drop
you can do that too
so if I've got a program I'm running in
my JVM and I know what meta space
setting I want I know what heat setting
I want I've found it's incredibly
difficult to figure out how much memory
on the machine or the VM is going to be
needed and I was wondering I've seen a
little bit about some sort of support
for that with the Java 9 and the
available memory but is there a good way
to figure that out or is that really
just a run it a lot and measure until it
gets down but the nature of complex
dynamic systems I love John's grimace
somebody get a picture that we do we we
we give you the controls because we
don't know how to drive them
automatically I think that's the short
answer
the longer answer is we have some very
smart people in the storage management
group who worry about this stuff all the
time and you know they they they're
trying they're trying to figure this out
and make it better over time the the
problem of the last several years has
been in Layton sees max latency and
we've gotten a good handle on that you
know you if you if you squeeze one
parameter or the other ones pop out of
control and I suppose now that we're
getting into clustered and and stacked
containers running on you know in small
spaces constrained spaces we need to
look again at at memory limitations and
and you know with with the rapid
build-out of cloud infrastructure Java
is going on that ship big time where
we're looking at ways to make the the VM
have more predictable memory
requirements but I would say it's early
days on that and best thing to do would
be to have the community tell us what
their best practices are so that and
tell us if it's if it's so easy that
that even a machine even a robot could
do it then maybe we want our robot to do
it for you but we have we have special
insight into some algorithms of how to
manage memory and keep it keep it
limited in size but the special
knowledge does not give us the best an
idea of best practices for the actual
applications out there in the wild so
I'm afraid I have to punt that question
back to this audience fair enough
Thanks
I have a question for versioning for
next version wouldn't be a better to add
some marker of great big feature such as
when we when you add value types it will
be say 10.20 dot 3 and now we will have
nine dot 18 3 can I ask the question in
return who wants to spend the next 40
minutes talking about version schemes
yeah didn't think so
I mean sorry it's this enormous bike
shed we could spend all day on it there
are lots of factors to be to be
considered we'll be having a no doubt
vigorous discussion of this in within
openjdk when the JT the new JDK project
is approved so if you care deeply about
it I encourage you to participate in
that but as I just I don't honestly
think it'd be a productive use of the
time of all the people in this room is
that I mean is that unfair that's okay
for a $1 response no no no I was 0.1
beta 1 John well I have a question so
about like I'll report from VM language
spec so it's a future of Java memory
model so maybe you can like say
something about it so Jim Jim I'm 9 I
may be the future of it
so what's planned to be implemented
needs a future there are some people who
thought about it but I don't know that
they thought about it very recently you
know what yeah there where this is
happening is and maybe you've seen him
hints of it is on
JMM working group that Doug Lee leads
and I would I'll give a couple of
remember the lawyer slide but a couple
of things that are we're talking about
in public are yeah thank you
oh yeah are getting more coherence with
the C++ memory model which is kind of
the little brother to the Java memory
model Java has powerfully strong and
tight specifications thank you Alex
Buckley and others and the memory model
is one of the places where Java had a
better spec than any other widely
deployed language but now the C++ is
growing one we want to make sure that
they're they have some coherence
relative to each other so we're adding
notions like acquire and release but
it's still no substitute for the base
memory model that we have acquired and
release our behavioral indications of
what's going on in inside the happens
before the foundation and that that's
not going to be changing anytime soon
will have to be changed with extreme
care one other item though of special
interest I would say for the Java memory
model is we have the special rule for
final-final fields in object and that
means that there's a special special
guarantee for a safe publication of a
final final field value in an object and
one thing that Doug thinks that we can
pull off which would be really great if
possible and it looks possible to me too
is extending that guarantee to two
stable fields that aren't necessarily
marked final in all objects so that
would mean that would mean you could
have an object that if it's I if the
fields are effectively final in other
words if you don't actually go and have
a racing right to the field or a right
after the constructor exits then for all
intents and purposes your data is as
race free as if you had marked the
fields final that said I it's probably
pretty hard to use that correctly
and again this is the the memory model
is a concern for library library authors
more than end-users I would say Brian
I'll bet you have something to add to
that so so there's there's some that
there's been a little bit of progress
you know in the working group as you
know as Don's mentioned it it doesn't a
truly impressive panel of experts and
they've been bashing their collective
heads against it for a lot longer than
they planned to and they're still not
satisfied that they have something
that's better than what we have now but
they're still bashing their heads
against it so so you know to be
continued but also there's been some
nice progress in I did find some of the
requirements for an updated memory model
in addition to the coherence with the
C++ model the of art handles work that
went into Java ngayon exposes a lot more
control over the memory coherence
requirements so var handles support
memory accesses with all of the
different access modes you know playing
a choir you know one full fence etc so
for bleeding edge adopters who are
looking to build the fastest libraries
they can there are some new tools that
are there for them to to play with
thanks for bringing the are handles
those are a big step forward but they're
they also are hard to use correctly yeah
thank you I had a question over here
yeah so I just saw your slide about that
new gussied up switch statement and so
I'm just trying to understand how with
six months releases how does one develop
features like that so as soon as I saw
that statement I was thinking about the
Royal mess that it is in Scala where you
know there's 15 different ways of doing
the selection and they are all slightly
incompatible with each other and clearly
that thing had organically grown over
time as yet another graduate student
added another sub feature to it so what
do you guys do to say okay you know
we're gonna roll it out gradually but
we're gonna plan it out first what's the
process is and also how does that
process involve the public at large
now we have these chaps and jo soares
and it's all confusing and how is that
gonna happen with six months releases so
I managed to cram a lot of stuff in that
question yeah yeah so this there's kind
of two aspects to this so the first
question is how do we deal with the
release frequency which is very
different from the time scale on which
we've been developing previously and
then the other question is how do we
design features more incrementally
so those are two separate questions the
first question about the release
frequency is actually really easy
there's nothing that says we only have
six months to develop a feature it's not
like there's some starting gun that
fires like okay start typing and then
you have whatever you have at the end of
six months ships that's not how it works
right so features are developed in
branches there are long-running projects
surrounding them there are expert groups
that advise the that advise advise the
requirements there are people trying out
early access builds and so we're using
the exact same process as we use to
develop something like lambda but you
know we just you know it's a freerunning
process and OpenJDK you know that you
know is exploring the space now in terms
of how you break down a complex feature
into a number of simpler sub features
the answer is fairly straightforward you
have to design ahead right and so it's
if we kind of anticipate well there will
be a feature like this and then a
feature like this that builds on top of
it and then something this features not
ready to ship right ready to ship is not
only do I have a solid design
specification implementation and test
week for the future but I have a clear
idea of how it's going to fit into the
next three four or five layers of
features built on top of it which
requires those features to have you know
gotten to at least some level where I
have a design and a prototype and all of
that so it's not like we're gonna throw
whatever we had out there every six
months when the bell goes off it's when
we feel like this is something that's
solid enough and clean enough that it
can be logically decoupled from teachers
that would depend on it and we've
developed I think a pretty reasonable
sense
or you know when when something is
reaching that stage and you know
yes we're probably gonna make some
mistakes but it's still the same people
that have been moving the platform
forward for all these years who have a
deep understanding of what it costs to
maintain something for 20 years and how
features interact with each other and
the importance of compatibility so I
don't actually think it's as terrible as
it sounds since I still have the mic
maybe the switch side sort of threw me
off because when I saw you're talking
what destructuring I mean there is a lot
of stuff that can go wrong in that
particular aspect you know how
comfortable are when do you think this
will actually see this this is not gonna
be 18 point O 3 right when we're
comfortable is the answer right yes it
said so the first feature we showed
today local durable type inference
that's already checked in that's done it
sits on the train it's it's going the
other features will come over time in
some ways this is hard but in some ways
it's also frankly liberating right
because you can work on something until
it's done and then okay what release is
ready and it goes well I can think of
many language features in se 7 &amp;amp; 8 where
as soon as they were shifts it wasn't
that we then realized something that
should have been added as sort of a big
user-visible thing but sort of like a
tiny tweak to type inference an 8 for
example where every where it's
completely additive it's it's just an
extra
it makes the language more open to
support it and to now own if you've only
got if you've got 3 years before the
next thing I mean there's no way you can
even tell people what what happens it
might go into the very first build of
JDK 9 right but you can't tell people
about it and there are lots of these
little things lots of little corner
cases basically which you can add
completely safely I'm not talking about
the difference between a constant
pattern and
the nested pattern and talking about
corner cases but corner case is an
inference make your life better when
they're supported so I think there'll be
a lot of that and I'm very excited about
being able to publish the language of um
specs more frequently what Alex said
about the language goes for the VM to
you that the VM the VM has a lot of
small opportunities for improvement and
some of them are so small if we did
everything with a grand galactic scale
Big Bang feature driven engineering that
takes two years those little
improvements never get in yeah but if
we're if we're doing things on the part
of the being liberated by the the
six-month cadence is not only shipping
when you're ready but also being able to
ship something that's that's right right
size to downward somebody else yes so
you mentioned some of the deprecated
classes that will be removed in support
of entire module modules so are there
any others out there that have lingered
for years that are difficult and just
never went away that we should start
worrying about yeah well yes I know so
in in 9 to give you a little more detail
we have deprecated all of the modules
that contain api's that overlap with
Java EE plus the Corbyn module so those
are there they're a 9 they're actually
not resolved by default due to a really
hairy compatibility problem but they're
there you can ask for them they work
that's not a problem and they will be
removed now it's a perennial question
why don't you remove that you know those
three deprecated methods over in
java.awt component or those twelve
deprecated methods over in this other
place and the answer is it's not really
worth the cost in most cases it wouldn't
save very much that's that's one reason
why why we are rather doctor deprecated
er was under the leadership of dr. dr.
Debra cater
enhance the deprecation annotation in 9
so it can indicate when was something
deprecated and is there an expressed
intent to remove it so all those
annoying methods in a WT will we ever
remove them now probably not what what's
you know what's what's the benefit at
the most of them just redirects from
from the old method name to the new
method name it's not like it's a huge
maintenance burden or anything else we
might be a little freer about
deprecating things piecemeal here and
there but you know I I would I would
caution you against hoping for all
deprecated methods to be removed but
that will probably never happen and
since every time someone mentions
deprecation I like to mention incubation
as well yes it's a dual yes since
incubation so JEP 11 is incubator
modules and incubator module is a way of
shipping an incubating feature which is
basically an API that is in developments
its package name will change should it
ever be standardized but it might in
fact be removed and then that would also
be changing its package name because you
couldn't import it anymore and the point
is that the conception of incubating
features would be that something goes
into one of these things let's say in
JDK 9 example JDK . incubator or HTTP
clients and then it's got vector the jdk
dot incubator dot vector I believe if
you pay close attention although that's
not a nine might be in some future
release who knows which one so the the
conception of these incubating features
that they go into a full heavyweight
3-year release and people get experience
with it and either it it gets
standardized or it comes out well that's
now on a six month cadence as well so if
you're seeing httpclient today unless
you I see a lot of samples and questions
on the web about that API it's not that
it has to be definitely done or out by
18.3 it can be later than 18.3 but it
can be sooner than three years for a new
API
has anyone thought about using the
container metaphor for describing how a
JVM gets initialized in terms of not
only classes being loaded but objects
already been instantiated so that I mean
like we do with docker light I mean
having slices built upon each other I
mean the images right so that when I
then bring up the JVM according to that
description it has already all the
classes that's probably the easier part
but the objects already insensate it if
I had done that manually sort of you
know container yeah we we have various
technologies that go a little bit ways
towards that but not in the in the in
the sort of slick way that dr. that
docker cans layer the images on top of
each other I mean we've had for awhile
now a thing called class data sharing
one of the one of the closed features
that Oracle is going to open source this
application class data sharing where you
can you can point point the VM at your
own application classes and they'll
create a pre-baked archive that makes it
but it makes it faster to load up those
classes at runtime right in four years
we've done that for the JDK classes
themselves with this feature you can do
it for your own application classes but
there but there's not yet a notion of
layering another another tricky part
about layering especially with some of
the other changes in nine is you know
our ter is gone right and it's this new
file you know it's it's in Lib slash
module in a format that we will not
specify because it's going to change
frequently completely internal that file
is not designed to be layered on top of
any others now it doesn't mean it
couldn't be it's just that that idiom we
had is not one that we've that we've
thought deeply about I think it's an
interesting question to ask it's also
it's also unclear would that really be
useful or in the world of docker is is a
JDK or a subset of the JDK is that a
fine enough grained unit do you really
need to be able to layer bits of JDK S
on top of each other or not I don't I
don't know
ah even like a small talk or a lisp save
the world have that's a much harder
problem it's honor it it's on our wish
list but it's very very far out there
not far down but far out because there's
several wishes we have to make it come
true first in order to make that happen
so we solved classpath hell with modules
I think we will eventually need to
address static and it hell with
something like what you're talking about
and so we have some early days ideas
about this but we we have to crawl
before we can fly so if I can ask can we
have the microphone passed back after
your question is done because otherwise
only the people in this section will
actually get to ask any questions and
that doesn't seem fair so here's a
question from from Twitter um have the
four of us considered forming a
barbershop quartet you wouldn't want to
hear that probably not it's timely that
you brought up modules because that was
the scope of my of my question noting
that G saw and modules go back with jsr
to 77 to about 12 years so the concept
is old enough to be going to junior high
no sorry the concept of modules goes
back to a classic 1971 or 72 paper by
David Lords Parnas my apology yes not is
not a new idea
I meant with respect to Java that I am
rightly put in my place if it's taken
that amount of time for expert groups
and Oracle to have done this what hope
is there for the rest of us in
modularizing our legacy code bases
abandon all hope ye who enter here
it's it's it's it's not that bad so this
was a a long-running project for many
many different reasons and guess what a
lot of them were not technical I mean
technically it was it was tough didn't
you no doubt about that trying to fit a
module system into an existing platform
while maintaining as much compatibility
as we possibly could without degrading
performance it was it was quite
difficult but there were also political
and even business issues you may
remember when I first started talking
about modules working on models publicly
that was in 2009 and my employer was a
different company you know son son son
was acquired time was lost that's what
happens in corporate acquisitions and
everything and there was nobody else in
the wider world when you're working on
that particular set a problem so things
did sorry stall for a while the whole
space of module systems is also one that
is politically challenging because there
are solutions that overlap with what
jigsaw does and do a bunch of fancier
things too which you know many many
people think oh well you you know you
think cut probably the most frequently
asked question oh just use OSGi right
well just just use it just use it you
know you know and I won't repeat them
here but they're play there are many
strong technical reasons why that was
not the right answer
nonetheless it created a political
environment in you know in the wider
Java community where there's a lot of
tension and you know those of us working
on jigsaw I had to work hard to try to
defuse those tensions and you know some
people in the in the other module system
communities neo also helped to to
understand okay there is common ground
but there are also different problems
being solved here it's okay for there to
be one more than one modularity solution
in in the java technology ecosphere
that's that that's actually not a bad
thing so yeah it took a long time I you
know sometimes I reflect back on this
and
I'm kind of jealous of my colleagues
because usually what they do is not
nearly as fraught with politics you know
you know pattern matching in in the java
programming language is somebody gonna
kvetch and cry that oh i wrote a library
five years ago that does something
vaguely like this you should just use
that well
unlikely so anyway sorry a bit of a
long-winded answer it's all right mark
keep standing there please I make a
comment about the ridiculously broad
surface of the Java SE ap is it's true
that jsr 277 starts didn't sketched out
in 2005 but that was not modular that
was not modularization of the java
platform that was an abstract module
system you say well okay Oh 2008 and
then you lose some time because of the
Sun Oracle thing okay well the 2010 it
still years and years and years the
module grab you know producing you know
first of all visualizing visualizing the
modules in your application is a fairly
straightforward thing right there are
tools to help with that you can sketch
out a basic graph hey put put put each
jar into one module and write the
dependencies and you're done you're done
here's the thing about the JDK first of
all we kept discovering little surfaces
that were not part of the SE API but
that were as if they were part of the SE
API in AWT in xml and you have to then
sit through and say so hanging this has
never been documented as part of SE but
it's been exposed as if it has been so
what should we do and that's it's
neither a technical question nor is it
really political or business but it is a
policy question then there's this whole
encapsulation story of it's dead it's
obvious what the public protocol of the
Java based module is it's the java.lang
package in the java io package etc etc
some misko was hived off to the side so
that was a whole policy decision in
itself right the sunless gun safe is
still there and it's in its own module
it's called JDK unsupported I remember
an entire meeting about naming that
module
I remember multiple meetings about
naming which by the way eventually will
go away right about about so this is
Judy unsupported that sounds like a
dangerous term for an enterprise vendor
to be putting out in everybody's runtime
images when we're selling support for
the JDK but there's an unsupported
module in there that kind of thing so
okay so you eventually fine you've got
you've got all these exports from Java
base you've got the legacy some stuff
over in Suraj it account supported oh
but then it turns out that all of the
libraries are using protected asset
accessible on protected methods of
official API s in other words they're
invoking them in an in a in an
inappropriate manner
I think you've defined class typically
finalized and so you say huh and frankly
that is not a problem you're gonna have
for your library or for your code base
and now you've got to come up with a
policy for what should we allow and then
I mean that that alone took most of this
year about how open do we want and this
is before the deprecated for removal
stuff for EE and figuring that out so
all of these it's the it's managing this
surface area that's why when we talk
about modules and it is it seems like
okay there's a graph that's grades but
what those things are exporting versus
not exporting ie what what we want you
to care about versus what you really
mustn't care about it's it's it's this
weird it's not programming it's not
architecture it's but it's something
that only really only the JDK has to go
through it's empirical to right
yes it's yeah we weeded met many many
analyses of like a dump of made maven
central to figure things out
yeah does existing code use this or not
what you actually mentioned in the key
nodes that the recommended naming
convention for modules is is reverse DNS
based or you didn't say this but I'm
pretty sure this is our policy on based
on the principle package in the module
well primary primarily reverse DNS
principal package when that makes sense
so I would so-so resident that in itself
was a huge debate that a huge debate
based on the see I believe Brian Fox is
Brian Fox here I don't know what he
looks like
the CEO of source OCT oh if SonoSite
gave a whole bunch of input about names
of maven artifacts and a or her we
haven't even mentioned automatic modules
via thing in itself but bear in mind a
big feature of the module system is that
it supports code that isn't in modules I
challenge you to find another module
system that supports that you will not
find one you can take non modular code
and treat as if it is modules it will
get a name it will get resolved there
will be an API for those things you can
reflect on them it goes on and on and on
and on and on didn't see that anywhere
else don't see it in jboss modules don't
see it in OSGi so that that migration
story also took a long time
very quick
yeah just very quick so there's a lot of
32-bit systems out there still is Oracle
for the long run for that one can only
do so many things at a time okay
I was asking after 20 years of oh sorry
I was gonna try to answer this
gentleman's question first sorry okay
yeah so we did we did shape the ship
32-bit builds of the JDK nine early
access releases and when we shipped GA
we where we in this case is Oracle we
did not ship 32-bit builds this was a
decision you know driven by but you know
by basically resource issues does it
there's only so only so much we can do
for the types of developers that
Oracle's most most interested in
enabling 32-bits not that interesting
but you know all the source code is
still there you know you can you can
build it I'm sure other vendors will
ship 32-bit builds and and that's part
of what open JDK is all about Oracle
doesn't have to do everything yeah you
know we talked about moving faster right
you know and part of moving faster is
doing less right and and so shipping
binary is on fifty six platforms is
something that makes it harder to move
faster and so perhaps you know it is a
better trade off to ship binaries and
and support the platforms that cover you
know ninety-eight percent of the user
base so that those resources can be used
on you know more forward-looking things
and just
I'm gonna throw something out there for
your amusement that that's related to
old platforms because this is the kind
of thing that someone who wants to run
on an older on X people want to do no
one has yet noticed that Java C in
jeddah k9 when when you specify - source
and - target who specifies source and
target when they invoke their compiler
some have frankly not many people but
some people did ek9 you can do nine
eight seven and six you can't do any
earlier than that that's why NetBeans
doesn't compile on JDK nine because if
you have a legacy system that has got
source one for built into all of the ant
files because that's just where you are
you're on X pianist in an environment
where they're not upgrading that's
another compatibility surface of that
you will be affected by JDK nine but it
is clearly to everyone's benefit that
the Java C internals doesn't have to
drag around 1997 era code that supports
1:1 for example the ability to assume
that all code that is being compiled
this from the era of generics means you
would interpret a type name as a raw
type rather than as neither a row type
nor generics because that's how it
wasn't one two okay third time after 20
years of doing optimizations in JVM do
you think that everything that is left
is micro optimizations or do you really
believe it that 9 is going to put on
solid ground to maybe do some big chance
of optimizing the JVM are you talking
about the optimization code quality from
the JIT yeah okay well we have a nice
little group of JIT engineers that work
on stuff like that and they are they are
driven by whatever new whatever new
initiatives were doing such as value
types they're also driven by our sense
according to our best information as to
the experience of customers and and what
what what loops they're failing to
optimize and
you know so we're always making small if
you look at the changelog on the on the
JIT portion of hotspot you'll see a lot
of small ad hoc optimization changes
though there's an intrinsic we need here
or probably the most dramatic stuff in
the nine era would that that is new
would be support for the newer Intel
hardware as well as other there's other
chips out there too that we support but
you know Intel is what we're
concentrating on but you'll see you'll
see more frequent success of
vectorization although for reasons
already explained in previous session we
don't put all of our eggs in the auto
vectorization basket we want explicit
vectorization also yeah there's probably
a large slide with tiny print of all the
small compiler changes we've made and is
that does it answer your question yes I
think John's being a little modest here
so if I could paraphrase the question
boy you know the JVM has done amazing
optimizations over the last 20 years is
there anything left to do I think that
is the essence of your question and oh
my god yes right so yes we've done
amazing things over the last it's the
last 20 years and there is so much left
to do you know there's there's big
things you know what John was talking
about but both auto vectorization and
you know manual vectorization there is
better multi-threaded performance better
memory latency optimizing object layout
for the memory you know characteristics
of today's systems hardware is
constantly evolving the software has to
you know has to have some awareness of
what the hardware's gonna do so that we
can generate optimal code so there is no
shortage of really cool things to work
on it I'll put in a note here about
project metropolis the the increase in
in in nimbleness that we're getting from
the faster cadence will be mirrored I
hope in the not-too-distant future by a
succession of technologies from the
server compiler C to jet which is
written in C++ and is about 15 years old
and the
and a new a new jet probably based on
the Gras technology which has been under
continuous development for for many
years now and is beginning to rival on
some metrics the c2 jet so the next step
for us after having played with äôt
for the JDK 9 timeframe is to begin
applying äôt to the two Graul itself
and then bundling that into the hotspot
VM and trying that code out to see how
it goes
that is not why don't you just use Gras
instead of c2 that is not one of those
sorts of problems this is a multi-year
better part of a decade succession
problem kind of like modules and and yes
we can do it with the six month cadence
bit by bit by bit and with with
long-running side projects but in any
case what I hope to get to there to
answer the question is a more flexible
fluid codebase that's easier to work on
that's smaller simpler lighter more
modern than the current C++ C of nodes
compiler digit that we have now instead
it'll be a java-based C of nodes with a
with a refreshed design and with as
we've found it's much easier if you're
working with Gras which is Java based
you know a Java program with annotations
and modern stuff in it
especially as Brian adds new modern and
stuff to the language it'll be much more
pleasant and therefore faster and safer
to to add new optimizations with the
Java on Java strategy and that's what
metropolis is about and as you probably
know from the mailing lists we're just
beginning to boot that up alright
anybody who hasn't asked a question the
mic is moving just slowly sorry
because because Java 9 is using the G
memory and the processor directly is it
possible for the programmer to hack or
what read viruses in the GDK 9 I'm sorry
I couldn't couldn't purse that speak
more slowly maybe Oh
because JDK 1989 we can use memory
access directly or for the processor and
for the memory accidentally so is it
possible for the programmer to create
viruses or such type of stuffs can you
create virus 9 because it is using
direct memory access by a direct memory
what do you think why if the process
boundaries in your us OS don't work I
suppose you could sorry what do you
think you'll fight direct memory access
that's because I have learned just
listen that it is using the processing
CPU directly in previous lectures what
is the name of that lecture are you
thinking for handles for the vector and
vectors right so the old way of doing
vectors is either writing assembly code
in an atom statement or in a you know
dot s file or it's if you have the GCC
tools you you can there are a few
intrinsic sin the extended geez good new
C C compiler that will let you program
some vector instructions and plus
there's a whole header file in full of
intrinsics so we're doing something like
that but it has the Java properties of
safety and integrity compatibility etc I
forgot one of yours mark and then but
the the Java vector API will let you
code a vector add instruction just like
today you in Java you can code an
integer add instruction it's the plus
sign what the what Java will not let you
do is get bounds check
elision that will lets you do a buffer
overflow it will not let you jump into a
data buffer there's a whole bunch of
safety operations that you can easily
that are in Java you can easily override
them in C even by accident that you'll
never be able to override them in Java
unless you use something unsafe yeah
unless you're an implementer unless
you're an implementer of the lower
layers of the stack and you're willing
to take their take that take that
responsibility on but most people don't
need it
whereas in C even the person writing
hello world takes on the responsibility
to avoid a buffer overrun or code
execution out of a buffer or something
like that okay there was another
question up here
can I ask my question or should I feel
free to throw things at me if it's a
stupid question but do you support
modulized versioning for module modules
and watch that's a mark one
no thanks question no modules are
modules are our constructs known to the
language in the VM they're not artifacts
it's important to keep the distinction
straight right a module you know a jar
file is an artifact it can define a
module or not but a module is kind of a
higher level more abstract thing there
are not version numbers on them this was
an intentional design decision I realize
it's yeah we know really we know very
well it's somewhat counterintuitive
because people expect all modules to die
version numbers doesn't mean someday
they won't but I think they're a bunch
of strong technical reasons why that's
probably never gonna be a good idea I
think we're simple first is good so I'm
asked this on Twitter but I can ask it
in person now so there's a lots of
languages and lots of language features
out there that you can draw ideas from I
would obviously can't pull in everything
in the kitchen sink how do you decide
what's appropriate for Java and have
there ever been any ideas that you
thought were philosophically very good
that were not appropriate for Java one
one answer is easy that the default
answer to the why don't you just add
question is no all right it's not an
answer to a wide but I mean it's it is
it isn't it is never been a goal indeed
it's been a contrast sort of anti going
it's not a goal to add every cool
language if you try no that's that's not
what you're asking but you know a very
frequently we get feedback of the form
oh well you know cool language X has
feature why why don't why don't you just
add it in and the answer is as Brian
will is capable of that's venting at
much greater length than I am you know
the answer is he is you know why don't
you just is just
beginning of a long investigation into
how does it fit with everything else is
it actually something that really needs
that everybody needs and if we do this
now what features will it prevent us
from doing later on because of
compatibility so Brian you wonder why
don't we be really selective about how
we slowly sediment features one by one
into our system yeah
and we have weilert we don't learn a lot
from others I mean Scala has been a
veritable font of information about yeah
that was a good idea that kind of worked
out it
yeah there's nother one over here yeah
so they you know we can't possibly do
all of the language features that even
the ones that seem like a decent idea
right so a lot of them just seem like
bad ideas or they seem like good ideas
at first and until you dig at them and
then you have a list left of ones that
are okay not terrible ideas and we're
only going to implement 1% of those
maybe and so we have to pick and choose
very carefully and it's not like we have
a detailed scientific process it's a
very subjective thing where we look we
you know we look at candidates and we
say what is the what's the
thrust-to-weight ratio here right what
is it what is it foreclose on what does
it enable what does it encourage and how
much is that worth compared to our
limited budget for adding complexity of
the language and again totally
subjective you know but we try to we try
to add things that have that build on
existing concepts rather than add new
concepts we try to you know add things
that have a lot of leverage obviously
something like lambda has a huge amount
of leverage much more so than you know a
lot of other candidate language features
but in the end it's a fairly subjective
process that involves saying gee that
sounds nice but no to an awful lot of
things so that when something really
good comes along we
the ability to do it for a long time I
thought collection literals were sort of
a no-brainer but eventually I was
convinced otherwise it's in a different
language maybe they're a great idea
there's there are so many features that
are just so much more complicated than
they look and then it just becomes a
matter of how much of our complexity
budget do we want to spend on that
versus something else all right I think
we're out of time so thank you very much
for your questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>