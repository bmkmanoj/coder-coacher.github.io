<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Servlet 4 0: A New Twist on an Old Favorite | Coder Coacher - Coaching Coders</title><meta content="Servlet 4 0: A New Twist on an Old Favorite - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Servlet 4 0: A New Twist on an Old Favorite</b></h2><h5 class="post__date">2017-10-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/k4tSKHH63fE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everybody welcome to the server photo
Oh a new trees and all favor
it is the standard sly I'm not going to
talk about this I'm Ching hai Chang I'm
a so that 3.1 and photo Oh coach badly I
also working on South select three
thorough implementation and the security
jsr JCCC and jasp I so I will let at
introduce himself
alright I know in my name's ed burns and
I'm very happy to be here
given the servlet for talk this has been
many years of Java one trying to get the
servlet for respect done and the Java EE
eight SPECT on it's been quite a long
journey for both technical business and
organizational reasons but we're happy
to have it finally done we think there's
a lot of great stuff in in the spec not
just in survival but in all of a II and
I hope to convince you of that today
Shing why and I hope to convince you of
that today I think this is set up to
auto-advance that's what's doing me in
here
mm-hmm oh well have to get that fixed
yeah I have to set that up hold on
that's terrible slideshows setup show
that's why is it doing that
manually all right play from current
slide sorry about that
so I've been doing specs for a while JSF
and servlet expect leads and also been
an expert group member for a lot of
different specs written a few books
about Java and a lot of conference
speaking on this topic and with the
coming of the Eclipse Foundation and the
handing off of the Eclipse Foundation
which you'll have quite a bit of detail
on later I hope to still be able to do
that but in collaboration with whoever's
working on it and in the community so
we've got you've got a lot of talks to
choose from I'm very honored that you
chose ours and I want to make that
investment worth your time a bit of
high-level content on the contemporary
and historical role of servlets
particularly taking a micro services
perspective and a historical micro
services perspective on this and the
heart of the talk is mostly shewag
giving the new features instead of four
and then we'll have some stuff on
opening up Java EE and then a summary
living that the only we only have 45
minutes for our session today I don't
know if we'll have time for questions
but I will be out in the hacker garden
and I'll be here all week you can catch
me there and also on the booth floor so
let's get into the historical portion
micro mano
oh no I put up here j2ee servlets a very
early Java micro services platform so
hmm what's the right way to start with
this all right who was using servlets in
2000 anyone okay who started using
service in like 2005 right and who is
still using sort of what's today
all right all right all right so it's
been around now this micro services term
is a new thing but you know there's
nothing new Under the Sun really and I
would like to take a few slides worth of
time to go through this definition what
I've determined to be a consent
this definition of what microservices is
and see how well historical
old-fashioned j2ee servlets stack up
with my own opinion and analysis you
probably might have a different opinion
this is something of a controversial
topic too so micro services generally
are seem to be all small a system that
is a collection of services each of
which is small loosely coupled and can
be composed isolated from other services
very highly internally cohesive it does
one thing each service does one thing
can be managed deployed and developed
independent of the others and is
responsible for owning its own data
let's look at each of these here now on
the small side there's nothing stopping
you from keeping your server what's
small one of the things that we that I
learned in doing JSF with is which is a
web framework is this challenge of
trying to design something where it's
easy to do the right thing and and
harder but not impossible to do the
really wrong thing because a lot of
times you need to do the wrong thing to
you know get the job done so servlet
with it's very easy to use HTTP session
and a lot of the properties that it
offers in terms of being ubiquitously
available and usually reliable and then
over the years app servers have added
clustering and failover to the HTTP
session so we did a lot of stuff to make
it easy to really abuse that thing so
servlet in that sense is small you can
do it but you have to work a little hard
to make sure it stays small so I'll give
that a maybe loosely coupled well
filters can compose pretty well that's
what they're designed to do the filter
Jain concept is expressly designed to
support composing and if you have a
system that's composed of a number of
different wores you can kind of consider
them to be composable as well isolated
from other services this is generally
not how people use serve what's so in
the model if one of the reasons why the
monolith is
seen as a pattern to get away from is an
outage and a servant would prevent the
entire rest of the call flow from
executing that's where the stacktrace
is we get these big long stack traces in
Java e my opinion on that now is we
still have the huge long stack traces
just spread about through all these
different machines but on the other hand
we have a whole huge raft of logs
science technologies that are out there
to help you make sense of that large
stack trace so imagine if you could put
your huge stack trace from hell from
j2ee into something like cabana and be
able to analyze it and tear it apart
like that that might be kind of useful
but it's just a different approach that
people are using now so in terms of
isolation I would say it's I'll give
that one a know highly internally
cohesive does one thing generally
sleuths are used as controllers or
filters that act on an HTTP request and
either pass it on to some other service
or send a response so I would say yes
they can be said yes to doing one thing
can be managed to poi develop
independent of others this one again
make it hard to do bad stuff easy to do
good stuff and j2ee didn't do so well on
this because they came up with this ear
concept and it let people be very lazy
and just say here is this one gigantic
ear it has five wires and whatever else
in it and it takes forever to deploy and
so that one is probably you know I'm
giving it a yes but it's that's as if
you if you restrict yourself to just
wires that you're deploying on different
containers and servlets responsible
handing its own data service generally
don't have much in the way of data this
was always handled by other parts of a
java ee monolith but whatever data is
sort of what does have it's generally
not shared with other parts of the
system so I'll give that one yes for an
overall rating of kinda sorta you can
look at servlets as a very early
microservices platform but you know if
it was the perfect micro-services
platform then we wouldn't be where we
are today
evolve and people change their tastes in
response to economic trends and popular
tools and what is seen as best practices
so talking about trends this is one that
I really like to talk about we have been
doing JCP specs for a really long time
and I think there's a proven track
record of success it's often held up as
slow and ponderous and difficult but you
know you do get results you do get
representation so in the particular
aspect of servlets David we've always
adopted and incorporated new features
from industry trends and best practices
all along so we've had the packaging
concept of waar for forever
we added asynchronous i/o as that
started to be more and more popular when
you know when it came into the Java
platform with niño we added that I
would also say that we had the ability
to do a fully reactive application even
before the reactive manifesto was put
out there being able to have back
pressure with the on data available on
write possible methods when dependency
injection and inversion of control
became popular with the advent of spring
and then CDI shortly thereafter we added
resource injection to servlet and and
Java EE in general and the latest trend
of course incorporating HTTP 2 into the
spec so if you had a Greenfield project
from scratch would you choose to use
servlets on that project given the
choice of any tools you you had mmm it
would be a stretch right but there are
some reasons where you might want to
choose to use serve vote for green food
development and a microservices style
let's say many enterprises have very
strict standards as what is approved and
what is not approved a couple years ago
I had the great pleasure to give a talk
and with a couple colleagues from
Lufthansa Airlines and they have this
thing called the big book of standards
it's probably not uncommon in many enter
and if you want to use a piece of
technology and your solution it has to
be in there and those solutions are all
vetted by their corporate architects and
have met the necessary security
requirements and legal requirements and
indemnification and support all these
important enterprise concerns so you
might be in such a shop and you have
basically have to use whatever you're
given in terms of j2ee or servlets and
you might want to take advantage of the
micro services architecture but not be
able to use all the different kinds of
tools
that's one reason it also could be that
the the team itself is maybe risk-averse
and try new technologies but adventurous
and trying new architectures they want
to take an incremental approach where
let's do the new architecture using the
old stack and if once we get the
architecture right and we understand how
to do it then we can take the
architecture and apply it to the new
stack so there are some reasons why you
would want to choose servlets for micro
services but the more common approach I
would say given by judging by the huge
number of talks on breaking up the
monolith I'm sure if you do a web search
for breaking up the monolith you'll see
quite a few of them is using servlets as
a stepping stone to a more pure
microservices system so I mentioned ears
that have wires you know separating out
those into separate wires another
approach that people do is to stand up
rest services in front of their existing
wores
and then eventually decompose those
wires so you just have the rest services
the pure micro services and so that's
kind of the approach so I'm gonna hand
it off to Shing Y here to give us the
heart of the talk the servlet for new
feature review Thanks
thanks to add the introduction of the
servlet with no micro service now let's
try to take a look on a new feature in
the server photo Oh now before I go into
the new feature I would like to mention
that all we done in the Java EE
is available in hip-hop calm and slash
Java EE you're welcome to try dissemble
in there is in the Quixote um Java EE
grassfish - sample in the samples there
you will see a lot of example and to
illustrate the new features in the Java
EE in particulars servlet photo now
let's take a look on what the HTTP 2
years now we all know that exceeded HTTP
2 is important
the primary focus is in the performance
and it has a lot of features to improve
the page loading in the browser how do
they do this let's take a look now first
is primary framing now in HTTP 1.1 the
protocol is in clear tags and primary
know though is more compact and
efficient when this transfer across a
wire and the second one is the stream
multiplexing now in HTTP 1.1 what you
have is one request one respond one
request and one respond and they also
have a feature called HTTP pipelining in
1.1 basically it says that you can send
send multiple requests at the same time
so you can request one request - and
request free but there is a requirement
the requirement is that the responded to
become in the same order of the request
so it must be respond 1 respond to and
respond free now there is a problem what
happened when you take a long time to
compute the respond 1 in this case
respond to and respond 3 need to wait
and the respond 1 is finished and that
is call head of lime parkland problem
now in htv-2 you can actually send the
respond in a different order
that is cost-free multiplexing what it
means is I can send request one request
to and then request free and then I can
send respond to and then respond one and
then respond free so the order of the
response is not important anymore even
better actually we can split the request
and the response into pieces
for example you have requests one
request - and then you were sent back
part one of the respond one and part one
of the respond to and then part two of
the respond one and then part two of the
respond - so this is a very nice feature
of the stream of the practicin in HTTP -
and this allowed us to improve a lot in
the page loading in the browser we can
see more about this later today
now the third feature that we have an
HTTP to to improve the browsing
performance is the header compression
now if you try to take a look on the
communication between a given browser
and a server you will notice that most
of the time a lot of the header they
sent across a wire is actually the same
a lot to Heather actually the same for
example what kind of content type of
mind type that a browser will observe
they need to send it across a wire every
time now this is a redundancy now the
way that HTTP - - about two years you
allow to do the compression in the sense
that the first time you send a header
the second time you send index of the
header of a particular table which they
re on to the other side so in this case
you do need to send the whole header
they only need to send an image integer
yes because that table is is a private
between the server and the browser and
the server is not shared
okay the fourth feature is certain push
and the server push basically is to say
that okay you allow the server to push
the data to the client I'm going to talk
more about this later
and finally they in this HTTP - we
always use keep the conditional life so
in HTTP 1 yes you can keep the
connection alive but you have an option
to turn it off but in HTTP 2 is always
keep alive so you can send the data back
and for like this now what happened in
server photo Oh in Soviet photo if you
use it then you basically can use
leverage all the feature in HTTP 2 so
you get the primary framing stream
multiplexing had a compression and the
connection those thing free
this is transparent to the user so the
only thing that you have to do is to do
something special above the server push
which I'm going to talk more in HDTV to
yours we also have some flow control
thing that is under the wire you can say
I want to turn on or turn off the server
push this part is still working
underline the Polacco we're going to
take a closer look on what happen now
before we go to the server push let's
try to review what happened in a
classical case in servlet now you have a
browser the browser will go to get
indexed or take HTML and then they will
return to the browser go to the server
and then come back to the browser and
the browser will do several things they
will first of all look inside intact out
HTML to do a passing and then they will
found out oh I need a stylesheet and I
also need
javascript so after they do this passing
they will send another two HTTP requests
called get stylesheet and then return
and then get JavaScript and then return
now this is a very common classical use
case now let's take a look on how server
push can improve the performance in the
classical case now with this in mind we
are going to take a closer look
what is the extra server push now if we
call the wording from out the RFC the
basically say server push allow server
to speculatively send the data to a kind
that the server anticipate the kind of
need trading of some network usage again
the potential latency game now what does
this mean okay yeah I love the Senate
data from server to the client and then
they are actually with all the kind
asking for it okay now first what is the
data can they be anything no it must be
HTTP response right because a browser
only understand HDTV respond
secondly the responded to corresponding
to a request right now can it be any
kind of request it turns out not let's
take a look on what the RFC say okay the
request that they correspond to is
called Palmas that request and you have
three criteria
the first one is cashable the second one
is cost safe which he sends means
essentially only the third one yes your
request cannot have a body now with this
requirement you can look at the Venn
diagram on the right hand side for the
standard HTTP method
hashable mean pose get and have and safe
mean option trades get an had so if you
want to be cacheable and safe then it
can only be get and help in this case of
course if you have a custom HDTV method
which is supported in the servlet like
you can define a method called foo and
in this case as long as they satisfy the
criteria of cacheable safe and with our
will cross body then you can still use
the push method now let's take a look on
what we had done in a servlet API now as
I mentioned before the servlet the data
that we push across a wire corresponding
to a HTTP request so what we have an API
call push builder is basically to
construct the corresponding HTTP request
and so you can see the method like add
header method which is get or head or
your custom cacheable save with our
request body and then you have a curie
string and then you can specify a
section ID and of course you have to
specify the corresponding URL path and
then you push now given this push
builder you can call us construct the
corresponding request but still you have
to give me a way to try to get this push
Buddha we can get it from the HTTP
request now in the HTTP request the API
is called new push builder once you call
this you will get push builder and then
you can manipulate and create the
request now I would like to mention two
things for this new push builder first
it's called new push builder so every
time you call it you may get a new copy
of the proofreader object second is what
happened when this connection
the cry and say I don't want anything
from the push server push then again
actually turn it off you know in a
political layer in this case the push
bill that will return now object so
every time you call new push builder
what you have to do is you have to check
whether it is now before you try to use
it now to illustrate this let's take a
look on a second diagram and to see what
we can do to improve the performance of
the common use case there are you
straight before ok now you still have a
browser and the browser will go to get
the inductor HTML and then the they
allow it to a servlet and the servlet
internally because the T is the
information you can put in a server yes
ok T is indexed or HTML and you know
you're going to need the stylesheet and
a JavaScript so what you have to do is
like this first you get a you get a new
push builder and once you get this your
return object and you return the object
you have to check where the T is now or
not once you know that thing is not now
then you can start to use it then you
can set the path and then push and then
once you push in from the container and
then come back and then once you push to
the stylesheet you can do the same thing
for the JavaScript and then the server
will send the push for maths frame to
the to the browser and then eventually
they were sent the data and then they
will send a body of the inductor HTML
now I would like to mention several
thing about this signal diagram first of
all we notice that the push builder is
reused in this case so you have one push
builder it was put pushed twice
the first time years you push the
stylesheet and then you also push the
JavaScript now if you share the push
builder they is advantages that you can
actually P populate all the information
that is common for this to HTTP method
for example this to I know is scared so
I just put dot method get' and then they
may share some common had a live session
idea or whatever so you can set up
everything in one push builder and then
you keep setting the path and push then
you've saved the work you don't need to
reconstruct the object again and another
thing that I would like to mention this
in here the diagram I say I sent out a
thousand and JavaScript here we only
send a push Tomas frame first and then
later the server will send the body as a
data frame I think it is going to talk
more about this in a concrete example so
now with this particular set up what we
have is like this we save the two trip
we save the trip that is from the
browser to the server again to ask for
the stylesheet and ask for the
JavaScript now T is a big advantages
because in our previous diagram when you
travel in data HTML you try to get the
stylesheet and the JavaScript but we do
not immediately together you have to get
in depth on HTML first and then you have
to pass the internet or HTML and then
you have low inside and then eventually
find that you actually need it and then
you put a request so this caused a
latency in this case but in here
everything you know you need it you just
send across a wire and then let the
browser pick it up now I'm going to let
air to do a demo on the server push ok
who is using any kind of Java server
side web framework of any kind
right a lot of folks okay keep your
hands off those are had them up and if
you're not using JSF put your hands down
okay so we got some JSF users the demo
I'm going to show is based on JSF and
it's nice and simple and this is just
I'm running GlassFish five and I have
the primefaces
demo waar deployed and http2 is enabled
by default in certain and JSF in and
yeah and JSF 2.3 so you're going to get
the features if you're going over H if
you're going over HTTP if you're not
going over HTTPS on GlassFish at least
you're not going to get HCB - it has to
be HTTPS for the server push to work and
so you know we're just let's reload this
page and this is just one of the prime
faces components and let's take a look
at the chrome net internals localhost
and I just look for push promise frames
these are you can see it's making the
request for some of the showcase CSS
files and there's quite a lot of
resources coming in here some jQuery
JavaScript there's some facelet stuff
that's being templated an inline here so
my point in showing that is primefaces
six didn't have to rewrite itself to
take advantage of server push the fact
is web frameworks not just JSF but web
frameworks in general know what those
resources are they know the association
between the pages and the associated
resources in the case of JSF it's very
strongly known because we have this
whole resource loader concept where you
define your resources to this thing and
you say this is my resource loader jar
or you don't have to have it in a jar
but you put there and then once you put
it there the server knows okay these are
my resources and the page that has a
resource dependency on those resources
knows that it's going to be serving them
so it's
an ideally suited situation for doing
server push so that's the quick demo
we're getting short on time so I'll just
hand it back off to Shing line to give
us some more features
we're friends to add for the demo and
now having talked about the server push
let's try to talk take a look and
another feature called HTTP trailer now
trailer is not something that is for
HTTP 2 only we are also happy in HTTP
1.1 so is something earlier
now let's take a look on what it means
now let's let me call wording from the
RFC it says that the sender decided to
send metadata in the form of trail of
views at the another message the
sender's should generate a trailer
header field before the message of the
body to indicate which field will be
presented in the trailer
okay that's uncomplicated now let me try
to extract the information from this
statement first of all the trail of view
is some metadata can it be anything
metadata means header here so it will be
a header here okay
secondly when I call trailer trailer is
something that is sent at the end of the
message so you can see is at the end of
the message
and finally for a trailer the sender
need to inform the receiver that you I'm
going to send you a trailer field in
this case they will send you a trailer
header now let's take a look on a
concrete example what it means now you
have a standard HTTP response now in
HTTP 1.1 in order to use the trailer
there is a requirement you need to use
the strongly transfer encoding here so
in this use a chunk wrong sir
encoding here and then in this case I
want to let the user know I want to give
you a trailer the trailer you send at
the end call foo colon bar food is the
name of the trailer PI's are very
and then in order to do this in my
request header I have to set a trailer :
foo to tell them that I'm going to send
you a trailer for you with the name fool
there is a meaning of the of the RAC
statement that I described earlier so
now now then we have a question here we
know that all the trailer trailer field
will be a headers like this can it be
any kind of headers okay we can be fubar
but can it be any kind it turns out
against there is a requirement for this
it can be anything but not the pseudo
header what is a pseudo header a pseudo
header for request will be the HTTP
method the scheme which is HTTP or HTTPS
the authority will be the hose and port
and also the path so this information
you cannot send in the trailer view for
the respond the status code you cannot
send a trade in a trailer view it must
be saying earlier in the header now this
is a requirement that you have for the
HTTP trailer field now then we have a
question yes why the people wanted to do
this can you think of any use case why
people try to do this yeah good checksum
is one other thing then the other thing
will be the digital signature right and
we have more and we have one pretty
popular use case recently is called G
RPC which is our PC protocol developed
by gogo and this protocol will require
two things they require HTTP 2 and they
used the trailer field and in fact this
feature is requested by the by the user
from the from the eg discussion and the
bring up they say oh we needed support
to trailer vo so this is a good example
of cooperation between the expert group
and us now given we understand what is a
trail of view and how important it is we
will take a look on what the server
photo done for the API ok the API
consists of two part one is for the HTTP
server requests the other one is for
HTTP server respond for the request we
have two ABI one you score is trailer
feel ready the other one you scare
trailer for you the getcha review will
return a map so we will like fubar that
kind of thing and then for the HTTP
server respond you have a set rate of
view and a get rid of you now I want to
emphasize that on the right hand side
the response when you say get and set it
straight up for you you do not set a map
object here instead you send a supplier
object here and a supplier
object is new feature in Jady Jady ka
and basically you only have one method
called get here and which is a
functional interface for a functional
interface it means that you can actually
use it in the lambda expression and the
reason why we give us a prior what
rather than a map is by the time that
you try to set the supply set the
trailer field you may not actually know
what you try to set for example this is
a checksum you don't do the checksum of
your body and you compute everything now
if you try to set your trailer feel
earlier then you have to know somehow
let them know what is the checksum in
this case I will give you a supplier
function and the supplier function will
keep track the information and compute
the corresponding to checksum and put in
the header okay now let's take a look on
the HDTV server request now can we just
call it get rid of you without coloring
his trophy ready can we do that
it turns out we cannot because the
reason is if you do this
by that time the true review may not be
ready it's not ready you try to go out
call it you will get a exception so the
right way to do it yes you have the
Kogi's trail of you ready and then you
get a boolean return and then you check
whether the boolean is true if it's true
then you'll get the trail of you and
then you return okay now having say
about the request side we have the
respond and then respond as I mentioned
before you just have a set trail of you
API and in here you will get a supplier
and the supplier will be a lambda
expression in this case they will create
the clear hash map and then they
populate the object here now if you use
the JDK 9 there is a new feature called
map off you can actually simplify the
expression here I'll let you find now in
the Java table or you go to a GDK deny
talk they will tell you ok now notice
that in the AVR no on the response I you
have a get trailer field and you also
have a set you have a saturate of you'll
also have a get rid of view why do we
need a get rid of you because you're the
owner who already said to trailer field
do you already know what it is why you
need to get it again it turns out
there's a reason the reason is this as
you can see in this example you have a
filter in front of servlet and you were
called to filter inside the filter you
will set the trailer view and then when
you come to the servlet by that time
someone already said the trailer view
and the server is also interesting
setting the trailer view but you don't
want to override everything from the
filter right you have to know what he
the few that does so in this case you
get the trailer filled first and then
you recover the supplier one and once
you know the supplier one then you can
control another supplier based on some
prior one and then set it back to here
so the primary purpose of the gate
trailer field is to support this
composite trailer for use case okay this
is about all I can say about the trailer
and there's something more about the
server I will let act continues about
the mapping yep I'll be real quick on
this we're getting like five minutes
left the mapping discovery feature was
entirely donated by the community member
argent i'm z' and then we debated it and
discussed it in the expert group he's
now working at a PR on PR server and
part of the micro profile effort which
is hopefully going to benefit from the
EE Foundation thing it allows for
discovering how the current server was
reached you not only works for Sur
what's not for filters it accounts for
all the various ways the container can
invoke a servlet which many right so the
claim you think you can invoke a servlet
by the container applying the mapping
rules or the application code can invoke
any of these methods here and if they
use that approach then there's an
Associated set of request attributes
that go along with that that let you
discover where it was before it came
through get was crest a 2.4 word or
include so that's just in keeping with
what the art we already had in the
specification when you ask the request
give me the serve up mapping it'll
return this immutable serve up mapping
it has an enum property which will tell
you what kind of mapping it was context
route you know exact extension and such
then it has some other javabeans
properties the match value what was the
pattern that was actually matched and
the name of the server that was invoked
and if you have multiple servlets being
called and you happen to call this thing
it'll give you the name one will be the
current
the one that's currently executing some
miscellaneous stuff we had some encoding
clarifications we did on the request
side the Earl paths read from the wire
are specified to be in utf-8 we didn't
specify that before although we do allow
vendor specific configuration for
reading the earl path portion some
clarifications on the encoding for xww
form Earl encoded we added method set
request character encoding to the
servlet context there is a new XML
element that lets you set that as well
on the response side we have the same
thing method and an XML element okay and
I think you're gonna take us out right
yeah we also have some other feature in
the server photo oh one of them is e we
add some API so that we you can
implement a servlet API eat more easily
what the first one is we have a tin some
default method for the listener and the
second one is is in the filter in it and
destroy and we also add a helper class
for the generic filter and an HTTP
filter and the only change in the schema
in the web dot XML is we add a new
element called default contact root in
the past we can not do it we in this
servlet and you have to depend on the
party tree way to set a contact root and
we also add a new API to set the session
timeout which is in minutes here and
then you also have an API to add the JSF
R which is similar to the surface a JSP
file sorry okay I will add continues
because you're gonna see this in the
keynote but there's one additional side
that I want to put you'll see this in
the keynote but I wanted to give my
perspective from the servlet side
and actually if you were in the previous
talk from Linda you got lots of most of
this too but the challenges I can see
for servlet and EE for J that's gonna be
the name of the thing and eclipse
servlet has always been revised in
lockstep with the whole EEE platform if
a stated objective of e4j is to make it
more agile it's gonna be hard to do that
right
also Sarila has extremely high backward
compatibility expectations and important
servlet EG members are not full Java EE
vendors so that questions gonna have to
be addressed we've always kind of had
this little dichotomy where jetty and
Tomcat which some of the most popular
containers out there are not full Java
EE containers you don't get EJB by
default for example or CDI and that was
the difference between the so called big
full Java EE vendors WebLogic and
WebSphere and GlassFish and pair also
and there's also a very large number of
implementations so the servlet has been
a great example of the success of having
JCP efforts but it's going to be a
challenge to have all those stakeholders
that's been my challenge over the years
with servlet EG is to keep all these
spectacled stakeholders in agreement and
there's quite a bit of difference of
opinions we'll see how that goes in the
foundation yeah that's as I said more
agile flexible open compatible you'll
see that in the keynote and that's the
summary of moving Java EE to e4j and
let's let string Y close us out with a
summary of the whole talk ok as a
summary the server photo Oh bring the
HTTP to to the Java EE platform and this
is a significant improvement in the
website and we are also backward
compatible and you can download the
grassfish fight all and try out the new
features in the server folder Oh
now one thing that I would like to
mention is right now phyto only one run
on
gdka it does not run on jdk noggins and
we are working on the version fight or 1
which will run with the Java SE 9 ok
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>