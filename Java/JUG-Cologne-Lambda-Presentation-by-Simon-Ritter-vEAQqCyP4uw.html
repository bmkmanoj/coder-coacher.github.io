<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JUG Cologne Lambda Presentation by Simon Ritter | Coder Coacher - Coaching Coders</title><meta content="JUG Cologne Lambda Presentation by Simon Ritter - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JUG Cologne Lambda Presentation by Simon Ritter</b></h2><h5 class="post__date">2014-03-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vEAQqCyP4uw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we'll do it right let's hope that me
right okay Gooden arbonne do not be
fooled by the name despite having a
German name despite having done three
years of German at school I'm be a
bitter is about as good as it gets so
what I'm going to talk about this
evening is java SE eight but
specifically about lambda expressions
and the streams api because these are
two of the biggest changes that we've
included in java really since Java SE 5
came out which was scary enough nearly
10 years ago and so this is a
significant change to the language and
it's a significant change in terms of
the api's this is going to work yeah i'm
going to say i'm going to have that yeah
okay so this is the usual Oracle slide
which says you know that we're not
saying that we will deliver anything at
a specific time I think we're fairly
safe to move past that because we
actually have got the ga of java SE
eight so the launch officially will
happen tomorrow but we don't need to
worry about that so let's move on from
that now the reason for including lambda
expressions into Java is because if you
think about the kinds of computers that
you use today they're all pretty much
multi-core or multi-process machines
that means that when we write code we
can actually do things in parallel we
can be more efficient in terms of our
code by using parallel execution now
Java has right from the very beginning
have the concept of multiple threads of
execution so right from Java 10 we had
the thread class we've had the ability
to do things like sleep wait notify and
interrupt so that's all good so we can
actually have multiple threads and
execute them in parallel but the problem
is that if you try and apply that to
writing application code it's very
difficult to write reliable code
just using those for primitives and
synchronized blocks and volatiles and
those types of things so in java SE 5 we
introduced the concurrency utilities
that gave us a whole lot more api's it
gave us the ability to do things like
semaphores things like mutexes things
like read/write locks which are all
things that people understand when
they've done multi-threaded parallel
processing code java SE 6 we introduced
the idea of a couple more api's things
like phases and different ways of
coordinating threads and so on amending
Java C 7 we introduced the fork join
framework which was the idea of taking a
single task decomposing it into a number
of subtasks having that happen
recursively until you got to the point
where the task was small enough to have
it executes in a single threat so that
saved a lot of work for you as
developers because you have to worry
about the thread pool you didn't have to
worry about how the queues were
organized and how we did things like
thread stealing but what I wanted to do
is go further how could we make it
simpler for you as developers to write
really good parallel code and make it
simple to write parallel code and that's
what we're doing in java SE 8 so this is
the introduction of the lambda
expression so yep and if we can just
move on to the next one as well right so
this is this is lambdas in Java why do
we need them and what's the reality
behind it this is a very simple piece of
Java code it's the kind of thing that we
are doing lot of actually sleeve I'm
gonna move over here because I think
that's probably easier if I stand this
side because a lot of people over there
this is a very simple piece of Java code
what we're doing here is we're taking a
collection and we want to find something
in that collection so what we do is we
say we're looking in our collection of
students for the student
yes you just plugged in the the thing
for the clicker haven't you ah excellent
right a clicker that works good okay
let's see if I can manage it right so as
I say we've got a collection of students
what we want is define what was the
highest score that any student scored in
a particular year so to do that we can
write this code this is perfectly valid
works java code so I say okay I've got
my collection students I need to
variable to record what my high score
was and then I use a loop i iterate over
the collection and I test to see if the
graduation years 2011 if it was I
compare the score of that student
against my current highest score if it
was higher then I record that in my
variable and I do that until the end of
the collection it works fine no problem
but it has some drawbacks problem with
this is that we are controlling the
iteration so we have the for loop in our
code and that means that we're making it
inherently cereal we can't simplify this
in terms of decomposing it into parallel
threads in a simple way the other
problem is that we're not thread-safe
because we've got a mutable variable
higher score which we're changing if we
wanted to break
we change the method calls together to
have the same effect so we take our
collection students and this time we say
that the highest score is going to be to
take that student collection and filter
it so we filter it based on some
behavior that we want the behavior is
defined by the predicate in this case
it's an anonymous inner class we define
what the anonymous inner class does in
its method we say that we compare the
graduation year to 2011 return true if
it is false if it isn't the results of
that filter is a subset of our
collection and we pass that to a map
method that then takes a class and
anonymous in a class of type mapper
which extracts some information from
that set so this time what we're going
to do is we're going to extract the
scores from those students so what we
pass to the max is a set of scores for
all the students who graduated in the
year 2011 and then we can pass that to
this max method and we can identify from
that which method which student got the
high score what that my score was so
this is much better because it means
that now we don't have the iteration in
our code we're separating that out we're
putting that into the underlying library
code and the important thing about that
is that we're now not making it
inherently serial so we could make it
cereal or we could make it parallel
because how filter works how map works
how max works those can be handled by
library code and if we want to have our
filter happen in parallel we can do that
if we want to have our map happen in
parallel we can do that by applying the
right kind of code so we can also do
things in a lazy manner if we wanted to
rather than having all the students
filtered before we pass any of the
results on to the map method we could do
it so that as we get the students who
graduate in 2011 we pass them on to the
map method and we make them available so
that way if we were looking for say the
first you
who scored more than 80 in a particular
year and we've got a million students in
our collection rather than having to go
through all 1 million students to find
those who graduated in 2011 before we
start looking for those who've got more
than 80 we might find that we only need
to process three rows of data before we
find a result so that way by doing it as
a sequence of operations and lazy
evaluation we can really improve the
efficiency of how we do these things a
problem with this is that the code is
just plain ugly because we're using
these anonymous inner classes which
let's face it they were a bit of a
clutch when we added them way back in
the mists of time for java and if you
look at the the code here what i've done
is i've actually highlighted some of it
in red and the rest of its in blue the
red code is what we actually are
interested in it's the key parts of the
code the rest of it is mostly just
filler it's like boilerplate code that
we have to put in there in order to use
an anonymous in a class so we need some
way of changing this so we can use the
same approach so we can make our code
parallel if we want to but not having to
go through all this work of including
all this extra code so this is what a
lambda expression does a lambda
expression allows us to simplify that so
in this case what we're saying is it's
it's effectively a replacement for the
use of an anonymous inner class and to
be a little bit more explicit where you
have a single abstract method type I'll
come back to that in a moment but if we
rewrite that using lambda expressions
what we end up with is this so we're
still doing filter map and max but now
rather than having the anonymous in a
class we have a lambda expression and
you can think of a lambda expression
like a method but it's a little bit
different to a method and there's a
number of reasons for that so you can
think of it like a method in that the
left hand side of the arrow is the
parameters that you're passing to that
method the right hand side of the arrow
is the body of the method so it's doing
the same thing we're passing a student s
as a parameter and we're processing it
by saying
compare the graduation year to 2011 now
we don't have an explicit return type or
return statement in this code so the
compiler will figure that out for us
we're simply saying there is comparison
to 2011 so the compiler will infer that
the return type is a boolean so that's
all good similarly with the map we're
simply saying that the parameter that we
passed this method is a student and the
body of the method is to return the
score of that student so does exactly
the same thing but it's much much easier
to see what's going on to end up with a
lot more readable code because now it
can suddenly see all much clearer and
what we're doing it's more abstract in
terms of the code that we're using and
so the way that we're defining things is
is more abstract in terms of the concept
less error-prone because there's less
opportunity for typing things in the
wrong way still no reliance on mutable
state so we can decompose it more easily
into a parallel set of threads if we
want to and therefore it's easier to
make parallel now if we look at some of
the details associated with lambda
expressions basically a lambda
expression represents an anonymous
function so I say it was like a method
but it's not a method so a method has to
be associated with a specific class
that's the way it works in Java with
lambda expressions they are anonymous
there is no class associated with them
and that will have some impact in terms
of the way that we use them and some
things we need to remember about them so
in terms of its structure it's like a
method so it has a set of typed
arguments it has a body it has a return
type it can even throw exceptions if you
want to so structure is the same as a
method but it is anonymous and we call
it a function because it's not
associated with a class the really
important thing about this is that what
we're now adding to Java is a simple way
or parameterizing behavior as well as
values because using a lambda expression
you can now pass the way that you want
thing to happen rather than just a value
that you want to process with your
method so what we've got here in terms
of the structure of our code now is
we're saying that we've got our
collection of students and we want to
filter that map it and then perform a
max operation and that's really saying
what we want to do so the what is the
filter map and actually you can say max
is a reduce its just a particular form
of that the lambda expressions say how
we want to do that so that's the big
thing is the separation of the what from
the how parameterised behavior we can
pass a lambda expression as a way of
saying how we want something actually
happen now if we look at some of the
more more details about lambda
expressions we use single abstract
method types a lot in Java so things
like runnable has a single method run
things like callable has a single method
call action listener has a single method
action performed so these are interfaces
that have a single method associated
with them you can use them with
anonymous in a class that's fine what
we're saying here is that this is a
functional interface any interface which
has a single abstract method in it is a
functional interface in terms of Java
from java SE 8 now one of the things
that is a little bit confusing about
this is the fact that a functional
interface must have only one abstract
method but that doesn't mean that it
actually only has to have one method
there's two reasons why that can change
but I'll come back to that as we talk
about some of the other features of java
SE eight so the type of a lambda
expression because when you're passing a
parameter to another method it must have
a type associated with it will always be
a functional interface there will be
some interface that's represented by
that lambda expression and that's what
the type will be
now in terms of variable capture if you
look at anonymous inner classes you can
reference variables from the surrounding
scope of that anonymous in a class but
there is a restriction on that which is
that any variable you access from the
surrounding scope must be final so you
can't modify the value of that variable
within your anonymous in a class with
lambda expressions we kind of relax that
rule a little bit so now you don't
actually have to mark the variable as
being final but it has to behave as if
it was marked as final so we have the
idea of effectively final variables now
in this example here what I've done is
I've created method which passes a
parameter called room before of type
long and then I've got a lambda
expression where I want to use that so
this is using meth the variable in the
surrounding scope even though before has
not been marked as final it behaves as
if it was final because it's only set
once I'm not modifying it and that way I
can use it within the body of the lambda
expression quite happily and this is one
of the reasons that we call these this
particular syntax lambda expressions we
don't call them closures if you've used
other programming languages that have
closures this is one of the significant
difference its closures would allow you
to access non-final variables outside of
the scope of the Lambrecht brought the
expression so these are not full
closures they are lambda expressions
another thing with lexical scoping is
that in an anonymous inner class that is
a class call it an anonymous inner class
it is a class so the compiler will
generate this class for you so any
method that you define within that is
obviously associated with a class which
therefore has an object associated with
it in the context of the use of that
anonymous inner class a lambda
expression is an anonymous function and
that's a subtle difference because there
is no class associated with it
that means that in an anonymous in a
class if you refer to this this variable
it will refer to the object of that
anonymous in a class in the case of a
lambda expression there is no class
there is no object therefore this will
refer to the object of the surrounding
scope so that is a slight difference
between the use of anonymous anonymous
in a class and a lambda expression so in
this case where I reference this dot
before again it's referring to the
before in the surrounding scope because
this is the object that that is in type
inference what we can do here is we can
actually use the fact that we know
things about things like collections so
collections we have generics introduced
back in Java in five if I take this
example here I've got a method here sort
which takes a list and a comparator now
we've used the generics and the type
parameters to define the types that
we're using so the list will be of type
T and the comparator will be of a wild
card which is a superclass of type T so
we know there's a relationship between
the type of the comparator and the type
of the list that means if i define a
list of type string that I want to use
and then I do a sort on that I can pass
in LS as my list which I know is of type
string and then I can define a
comparator which takes two arguments
string X and string Y and then the body
of the lambda expression will be to
return the difference in the length so
that's how I'm going to compare them but
the compiler already knows that LS is a
list of type string so in this case I
don't explicitly have to state that x
and y are string so I can leave that out
that's another shortcut that we can use
in lambda expressions the important
thing about this is that this does not
introduce any form of dynamic typing
into Java this is still very much static
typing because the compiler knows the
type of the collection
and therefore you can't use you know
different types in terms of the lambda
expression it must be a lambda
expression where x and y are both of
type string so this is what we say is
more typing with less typing which is
why you can use English as a good way of
writing jokes because typing in terms of
the the types that we use for the
variables and typing on the keyboard
method references this is another
shortcut that we've introduced to
simplify a number of lambda expressions
if you have a lambda expression where
all you're doing is calling a method on
a variable or on a class which is the
parameter then you can shorten that so
that it becomes the name of the class
colon colon and the name of the method
and so that will do the same thing as
that lambda expression we've got far
left arrow f can read you can reach
Orton that to file colon colon can read
and on the whole that is a really good
thing sometimes it can get a little bit
confusing there's there's an example
where if you use system dot out colon
colon print line you look at there you
go it's printing something but I don't
actually know what it's printing so
sometimes it can be a little bit
deceptive in terms of understanding
what's going on can also do the same
with a constructor the Constructors our
method so we can use a reference to that
rather than actually having to call it
explicitly so the same idea as before if
I want to I can say okay I've got a
factory here of list of type string and
I'm going to assign that to be a lambda
expression which is a constructor
reference by saying ArrayList of type
string colon colon new and that will
instantiate a new instance of an
ArrayList of type string and is
equivalent to the same lambda expression
one thing that's worth noting here is
that if you have no arguments for your
lambda expression don't need any
arguments then you use an empty set of
brackets to indicate that is the case so
you have to put
it's there to indicate there are no
parameters so we talk about lambda
expressions let's talk about libraries
and how we can involve them and how we
can use this power this idea of having
behavior passed as parameters to enhance
the libraries that we've got what we
want to be able to do is to provide ways
of dealing with aggregate operations and
we do this a lot in Java you know we've
seen where we do things like filtering
where we do things like sorting where we
do things like searching so you know I
want to find blue blocks or whatever so
i'm using filter Map Reduce very typical
type of approach to doing this sort of
thing the problem is that as we have it
today well I should say last week java
in terms of the collections api didn't
have a map a filter or reduce method so
how can we extend things like the
collections api is to add new methods
because the collections api is based
very heavily on interfaces so if we want
to extend an interface and add more
methods to it we can do that you know we
just add more methods into it fine but
it breaks backwards compatibility any
class which use that interface where it
doesn't have filter map or reduce in it
when you want to compile against that or
link against it you're going to find
that it can't be resolved in terms of
those methods so you get a breaking
backwards compatibility so what we need
to do is find some way that we can
extend existing interfaces without
breaking backwards compatibility and
that's basically what we've done we've
added extension methods different
methods defender methods to java SE
eight what this means now is that in a
in an in an interface you can now define
a method which has a default
implementation that way when you compile
against a class which uses that
interface
and doesn't have an implementation of
that particular interface the compiler
will say okay in that case I'll use the
default version so for stream it'll use
string support stream splitter ater so
this is good because now we have the
situation where we can add methods to an
existing interface without breaking
backwards compatibility for the
observant about you you will of course
go all hang on stop just a moment we're
adding behavior to an interface doesn't
that mean that we're adding multiple
inheritance to Java well the answer is
yes and no because if you think about it
java already has multiple inheritance of
types interfaces by their very nature
are a way of having multiple types
associated with a specific class good
old polymorphism if you look at a
particular object if it has multiple
interfaces you can use that view that
object in different ways based on
different interfaces so we've always had
multiple inheritance of types what we're
now doing is adding multiple inheritance
of behavior you can include behavior in
a interface in an interface but we're
not adding multiple inheritance of state
and that's really where a lot of the
problems come in terms of if you look at
languages like C++ that do proper
multiple inheritance there are some some
issues that you have to be aware of so
if you have a class which implements
meta interface a and interface be if
both those interfaces have methods in
them which have the same signature and
have a default associated with them and
the class doesn't implement that what
does the compiler do how does a compiler
decide whether to use the default
version from a or the default version
from be the answer is if it can't
resolve them by any means it will report
it as a compile error and therefore you
as a developer have to figure out how to
resolve that problem manually but so
long as it can differentiate between
these signatures of the methods then it
will
use the appropriate default method in
terms of functional interface it's i
mentioned that lambda expressions can be
used for functional interfaces so
wherever you can use the lambda
expression is where a functional
interface can be used functional
interface remember is one that has a
single abstract method associated with
it so I mentioned that you can have more
than one method in an interface and only
one of them is abstract so if you look
at something like the predicate
interface you'll find that has five
methods in it one is an abstract method
3 have default implementations and if
you have a default implementation it is
not deemed or not termed abstract and
the fifth one is actually a static
method and this is another change in
java SE 8 is that you can now put a
static method in an interface so a
functional interface is one that has one
abstract method and you can mark that
using an annotation so at functional
interface will be used by the compiler
and will test to make sure that your
interface matches the criteria for a
functional interface as long as it does
then it will compile quite happily so
let's look at how we can use lambdas and
extension methods and streams because
what we want to do is we want to add
this ability to use things like filter
Map Reduce so that we can do this more
functional style of programming and we
now know that we can add new methods to
an existing interface we can extend the
collections API we can do all of that so
what we're looking for is you know being
able to find the most profitable company
by or product by region grouping
transactions by currency all these types
of questions that we have to solve and
we know that up until now we've tended
to use external iteration we have
explicit loops we do it that way in java
SE 8 to solve this and make it so that
we're not making our code inherently
serial or in
any parallel we have the streaming API
which works lambdas now what a stream is
is in effect a way of specifying these
aggregate computations the important
thing to remember about a stream is it's
not a data structure actually might look
like a data structure at times but it is
not a data structure another thing
that's important to understand about a
stream is it can be infinite if you are
generating say random numbers or a feed
from you know trading system potentially
that could be infinite so you can have
an infinite string of course some people
look at that ago well if I've got an
infinite stream and I'm doing you know
processing on it how do I stop
processing that stream and that there's
different ways of doing that but you can
end up with the situation where you
don't stop processing that stream but
then that's not bad because well he's
bad i suppose but the point is i can
just as easily write a piece of code in
Java which is infinite you know infinite
loops very easy to write while true
semicolon it'll just carry on forever
same thing can be done with streams it's
not including something new so the other
thing about strings is that by the way
we define them the way we use them it
enables us to apply underneath using the
library code a number of different
optimizations we can actually make the
code run very efficiently by looking at
what's happening in terms of the streams
we can fuse together operations we can
do lazy evaluation we can apply parallel
ISM where it's appropriate so like I say
a stream is really a pipeline of
operations that we want to apply to a
set of data and a stream consists of
three things the first is a source so
where we're going to get a set of
elements from that we want to do
something with then we have zero or more
intermediate operations and what those
do is they take a stream they do
something to it and they produce another
stream and then when we've finished
doing all of our intermediate operations
we end up with the streams
our output and then we pass that to a
terminal operation terminal operation
will take that information in the stream
and generate either a result or some
kind of side effect now what I mean by
side effect is something like you may
have a place where you decide you want
to print out some message or something
so that is a side effect even if you're
not generating result that would be a
side effect but it stops what you're
doing with the stream so if we look at
the example here processing some
transactions now there is a new method
on the collections API where you can
call and you can get a stream so that
will generate your stream and what that
does is provide us with the source so
from our collection of transactions we
ask for a stream that's what we get but
remember it's not a data structure so
it's just a stream that represents the
elements coming from that collection
then we've got a filter where we use a
lambda expression to define how we want
to do that filtering filter says what
the lambda expression says how so that's
an intermediate operation so we filter
the stream to reduce it to only the
plate only the elements which have a
buyer from London so we get a stream on
the output which is smaller or
potentially smaller could be the same
size as the stream of the input and then
we use a map to int as another
intermediate operation to convert the
transactions that we've got into or
stream of transactions into a stream of
integers which is the price associated
with that and then our terminal
operation which is again another reduce
in effect specialize in reduce is to say
some these values together so each thing
coming through the stream will be added
and you will get the result which is the
sum of all of those transactions now
there are a number of ways you can
actually get a source of a string so
obviously there's collection not stream
that will give you a stream and in that
case that's a serial stream so it's a
stream which has one thread associated
with it
if you want to make it parallel you can
simply say collection or parallel Street
and that will give you a parallel stream
so you can decompose that into multiple
threads and have that processed in
parallel the way that works internally
is it uses the fork join framework so
the framework is used internally in the
library code to break that into a number
of threads a stream itself if you've got
a serial streams over you do collection
not stream you could then call the
parallel method on that stream and that
map would create a set of parallel
streams as well if you've got an array
you can use the arrays dot stream method
passing an array and that will generate
a stream of elements from that array or
if you want to you can use the static
method on stream and say stream of there
are some nice little static factories
that have been included in different
classes so for example if you were
looking for a range of numbers integers
then you can say in stream range and you
give it a starting point and the end
point so you can say 1 comma 100 and
that will give you the integers from 1
to 100 files that walk you pass in a
path and then what you get back is a
stream which is the walk through the
file system structure giving you all the
different paths to the elements in that
file structure and if you want to you
can actually create your own using the
splitter reiter class or splitter right
yet splitter age class method i should
say i think its class actually it's an
interface anyway use splitter ater and
that that is a whole other presentation
on its owns i'm not going to talk about
the traitor specifically here now in
terms of stream sources there's also a
number of different things that you get
with a string so clearly a stream gives
you access to a sequence of elements you
know the items in your collection items
in your array the files in your file
system structure but you also get some
other things you get the ability to
decompose it into parallel operations as
I said using foot draw and framework and
you get characteristics about the stream
so the stream will have some
characteristics that are used internally
things like is that stream ordered our
list has an order associated with it
because the elements in that list are in
a particular order so if you're taking a
list and generating a stream from it it
will be ordered it may be distinct that
means that all of the elements in that
stream are not going to be equal to each
other it could be sorted so you could
say it does have not just an order to it
but it has a sorted order so we know
that it's in alphabetical order
numerical order whatever it could be
sized so we know that the stream has a
fixed size and that can be very useful
in terms of how we optimize processing
sub sized is a little bit involved it's
basically if you do break things up into
sub components or decompose it then
you're saying that the the sub streams
will also be sized it doesn't actually
have to always be the case so if you're
using something like it's a a tree
structure sometimes you know the size of
the tree structure but you don't know
the size of the individual parts of the
tree so that's an example non-null means
that you will not have any null elements
in your stream immutable means that you
can't change the elements in your stream
and concur it means that it can be
handled concurrently so different
aspects of the your characteristics of
the stream terminal operations are
basically when the pipeline gets
executed because the the way that the
intermediate operations and the source
work is that you're really just
constructing what's going to happen when
you call the terminal operation that's
when everything actually happens and so
the underlying library code will fuse
together where possible operations and
the idea is that you only have to have
then one pass on the data other things
that we can do in terms of taking
advantage of some of the things we know
is for example if we know that the
stream is sized so we know it has a
specific size and you're using the to
array method as your terminal operation
you want to make an array of it then we
know that we can all we can pre assign
an array of the right sites because we
know how big it is so it's things like
that
enable us to again make improvements in
efficiency map and flat map so map is
the idea where you take an input stream
and generate an output stream by
applying a function to each element on
the input stream so it's a one-to-one
mapping so you say ok our input stream
is you know students output stream is
the score of those students so you're
mapping from a student into a score a
flat map is a one-to-many mapping now
I'm going to talk about an example in a
moment which will make that a lot easy
to understand but essentially what
you're saying is that each element in
the stream is processed in such a way
that the result is a stream of results
so each element becomes a stream on its
own and that way you end up with it in
effect a stream of streams but quite
often you don't want that what you
actually want is one stream on the
output so flat map will take those
stream of streams concatenate them and
give you a single stream as the output I
will like a cell give you an example in
the moment which makes that very clear
as to what that really means now the
other thing that we introduced in Java
SE eight which is closely linked to
streams is the idea of an optional so
this is all about reducing the idea of
null pointer exceptions this is a very
typical way that you might do something
in Java so you string together a
concatenate together a bunch of method
calls and in this case what I've been
doing is working on some GPS stuff so
I've got GPS data as an object I call
get position on that and then I call get
latitude on the resultant value call get
direction on the resultant value of that
which is fine except that if gps data is
null i'm getting a null pointer
exception because i can't call get
position on the null similarly if get
position returns a null I'm going a null
pointer exception thrown because get
latitude can't be called a null and
saying forget direction so I've got the
possibility in several places of
throwing a nullpointerexception
different languages provide different
solutions to this there
this bizarrely named Elvis operator
which some languages use which basically
say if you any of these return a null
then rather than throwing a
nullpointerexception and trying to
continue you just return a null as the
result which is one way of doing it so
what we're going to do we're not going
to do it that way so we end up doing it
in Java at the moment to be safe is we
do it this way so end up with like
direction is unknown if gps data does
not equal null position peak with gps
they presumed and we end up with a lot
of extra code it's very nice and safe
but it's you know a lot of extra code so
this is why the optional makes life a
whole lot easier because what an
optional down does is it basically says
it contains an object or it doesn't so
it's either there or it's not it's
optional now that might sound a little
bit sort of glib but it does make a lot
of sense because you could think of it
in some ways as a stream which has 0 or
1 elements in it if there's zero
elements when you call a method on that
it does nothing so it doesn't throw a
nullpointerexception if there is an
element there it does whatever you want
to do and there's different ways that
you can do use this so for example I can
create an optional of type GPS data i'll
call it maybe gps and to create that
i'll use optional of gps data now
problem with that is that if gps data is
null and whatever time good if gps data
is null i'm actually going to throw a
nullpointerexception straightaway so
that's probably not great advance on
what we had before but you can do of
nullable in that way if gps data is null
or if it's a value then the optional
gets assigned appropriately so we end up
with maybe gps and then what we do is we
can say maybe gps if present do this so
the if present is like the the idea of
saying the stream from maybe gps is
either 0 or 1 elements if its present we
will print the position but if it's not
present we don't do anything so it's a
null a no-op so nothing happens there's
no null pointer exception we can also
have a or else so we can say let's say I
want to make sure that I
currently have a GPS data object so what
I'll do is I'll say take maybe GPS and
if that has something in it which is a
valid GPS data return that or else
create me a new one using this
particular expression here it's a new
GPS data and then we can take that one
step further and we can say we can
filter so we say maybe GPS dot filter
where we say let's look at the last read
date on that GPS data if it was less
than two minutes ago then that's what we
want to use so that means that we get a
result out of that and if its present
then display the data so this is where
chaining together things so that we've
got an optional which we can filter
based on some predicate some criteria
and then if that returns result then we
do something with it so this is a nice
way of avoiding null pointer exceptions
and in fact there's a whole bunch of
other things you can do you can also use
flat map but unfortunately don't have
time to talk about that right now
collections and strains and it revolves
so you have the idea of illustrator
already that's a well-known interfacing
Java so what we've now done is add a for
each method to the iterator interface
iterable interface and we've also made
it part of the stream interface and
that's where things get a little bit
complete confusing a little bit
complicated because you can use for each
with an iterator and obviously that will
apply the lambda expression to each
element in the interim it's a revolt
interface or object but you shouldn't
use it really for streams if you're
using there are some cases where you
would use it but on the whole you
shouldn't really use it so you then ask
what why do we included time ok five
minutes then I'm getting fish honest
so if you use like word list which is
collection that implements iterable so
you can just do print that's fine but if
we have something like this we've got a
list l and we say okay so I've got
something we're going to map based on
lambda expression and then what we want
to do is we want to add all of those
elements that we generate from that into
this list we could do for each and then
say add that element to the list but
that's not good because it we can't make
that parallel it's not thread-safe so
that the better way of doing that is
actually to do a collect on and to list
so that's the safe way of doing that so
just to kind of wind up I've just got a
few examples just want to go through
very quickly so there's an example one
where we want to convert all the words
in a list to uppercase so basically
we're taking out a word list which is
our collection and we ask it for a
stream so we get our source stream and
then we map it based on just converting
it to uppercase so he's a method
reference we're going to convert all
those strings to uppercase and then we
collect them using a collector's lot to
list which is a utility method to return
the appropriate collector to generate a
list for us so we end up with a list so
nice and simple straightforward we can
extend that a bit and we can change it
and you say rather than mapping
everything to uppercase what we'll do is
we'll filter and only have the items
which are even in length so we change
that to being a filter rather than a map
and then bufferedreader is another class
which we extended so you can now get a
stream of lines of text from the
bufferedreader which is quite nice so we
can say okay if we want to count the
lines in a file we simply do
bufferedreader lines count that's it so
we've got our sauce we've got our
terminal operation no intermediate
operations and we've counted the lines
in the file and we can extend that we
can say okay take the lines in the file
but this time what I want to do is I
want to take only the third line and the
fourth line and join them together so
now what I do as I say okay
get a stream which is a lines that's my
source pass that to skip which will skip
past a certain number of elements in
that stream and then produce a new
stream from that point so that skips the
first two so we start at the third
element limit the output of that stream
to another stream limited to only two
elements so take the stream that's
coming from skip take the first two
elements pass that as the output stream
and pass it to collect then there's
another utility method joining which
will allow us to join those things into
a single string and generate that as a
result so that's where we start to see
the power of this because that's very
simple obviously we can do that
similarly we can say okay let find the
longest line in a file so we've got our
reader got our lines as our sauce and
then what we do here is we map to int
based on the length of the string so we
create a stream of lengths of those
strings and then we pass that to max
which will look for the biggest value in
that stream what we get from that is
actually an optional so we need to get
the result out of the optional and we
knew that you do get as int and that
will extract the result for promise for
us and so we get the longest line in the
file using only like four lines of code
and if we want to we could then say okay
let's collect all the words in a file
into a list so this is where we see the
idea of flat map so we get lines is a
stream of lines of text in the file flat
map we'll use a lambda expression to
generate a set of streams based on each
element in the input stream so what we
do is here is we create the stream of
the line based on being split using some
regular expression separates up on
spaces whatever so what we get is a
stream of streams each line has a stream
of words but we don't want a stream of
streams we just want a stream of words
and so flat map will do that will
concatenate it we can then filter out
any zero length words and generate a
list and just the last one is if we
wanted to then take that
and we say okay got our words in a file
convert them all to lowercase sort them
alphabetically and put them in a list so
again that's like six lines of code
which I've actually spread over a number
of lines think how much code that would
require to do that in java before java
SE eight that's where you really start
to see the power of screens so just
conclude basically lambda lambda
statements were something that we really
need it in order to simplify how we can
pass behavior as well as values and that
allows us to then extend the collections
ap is to have a more functional style of
programming to do that we needed
extension methods because we needed the
ability to add new methods to an
existing interface and then the whole
idea of the streams API bulk operations
on collections simplified processing the
ability to do things in parallel the
ability to optimize things that's what
it's all about so java SE 8 really is a
big change in terms of this kind of
thing and that's me i'm a bit over time
but i'm sure nobody
so what do we do now so all right so
Simon was talking about all the cool
stuff you could do with lambdas and the
new stream API and one of the other big
features in Java 8 is the ability to run
all this stuff including lambdas and
streams on small devices like the
Raspberry Pi so a little bit about
myself my name is Steven Chen I'm doing
a crazy motorcycle tour through Europe
for the next six weeks already been on
the road for two weeks and yeah you can
follow the broadcast and we're all
streaming live ok so we have a raspberry
pi I need a volunteer you look like a
good balance here what's your name sweat
thank you and we have it hooked up to my
computer here so you can't see my screen
I'm going to run a application which
enables this force sensor and can you
grab that not to don't try to pull it
out but just see okay so what we have
here is he's grabbing a force sensor is
an analog force sensor it's hooked up to
a little analog to digital converter and
then it's connected to the Raspberry Pi
using gpio and a library called PI for
Jay thank you the other thing we have on
the board here come on you can stop is
we also have an LCD screen so I'm going
to get your help again so you can see
there's a little LCD screen and it
prints out the force and the photo
sensor so if you grab the this again you
should see the force number going up
yeah and then if you cover the light
sensor with your finger yeah you see the
second value going down right okay so
just a quick example of what you can do
with you know Java 8 running on embedded
devices like the Raspberry Pi
leave this up here if you want to play
around with it and then I think we're on
break right Michael yeah yeah yeah okay
break time
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>