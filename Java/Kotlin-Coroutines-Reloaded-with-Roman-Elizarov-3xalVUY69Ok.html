<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Kotlin Coroutines Reloaded with Roman Elizarov | Coder Coacher - Coaching Coders</title><meta content="Kotlin Coroutines Reloaded with Roman Elizarov - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Kotlin Coroutines Reloaded with Roman Elizarov</b></h2><h5 class="post__date">2017-08-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/3xalVUY69Ok" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'll keep introductions and go
immediately to business
so this talk will be about curtains and
cotton and it will be the second
installment of the talk that Sandra did
last year so the key question here is
how many positions who watched Andrews
stocks last year from previous years
like recent great so I mean happy to see
what's of hand for the rest of you will
will just I do quick recap for the
prototype that and represent last year
and the will explain a little bit the
working on that prototype that we had in
a cotton team so what issues we found
how we solve them and how it's actually
turned into actual coolies that end
users have saw so that will be
interesting parallels with many things
that are designed for Java language
because you know it's never like it's
always changes from prototype to release
and a little bit how we evolve libraries
style and other things if we have time
we'll talk about future directions or
issues you know challenges they might be
interested to other people who work on
similar features so let's let's do recap
first so the I think await the concept
it was championed by C sharp and then
later adopted by many other languages
JavaScript typescript dark so the key
concept there is a pair of keywords for
a single weight which you mark a sink
marshal functions with marks here in
vacations and the project region was to
issue those keywords and instead go with
functions so instead of doing this
enjoyed its article keyword do them as
functions which gives a benefit of be
more abstract so for example the same
language our concert would be able to
express both async/await and a generate
yield and lots of other constructs with
just a few building things into the
language
and that gives us sensibility this lets
us work on stock gvm and because you
know it's all purely local it just
compiler things and enter unless you're
I mean you even it's your credit talk
you can watch how it's all compiled
state machines etc etc it's pretty local
thing the key idea behind how this works
was that you know when we have any
vacation like to wait something and we
woke it for example we're waiting for
completed future and we want to get
strength as a result of that but having
waited for completable future to
complete we would declare our a weight
function with their suspend modifier and
it would perform some magical
transformation we would add a
continuation in of the Sultan instead of
returning the result and our result will
be worried which is in cotton occult
unit and you know contingents here just
a generic call back so nothing really
interesting like you see resume resume
with exception it's all pretty simple
transformation and the idea if the
project was that if you need to
implement it functionally can wait the
implementation is going to be really
simple or you'll just install for
example inquisitive future case you do
when complete which is a call back on
caboodle future and you process this
call back and if there's exception you
receive with exception and if it's you
know well you using this world and you
know simple beautiful but as you know
with many simple a beautiful ideas it is
wrong and the problem was encountered
interestly
yeah and it's kind of a common case so
we're first encountered in the cotton
team and the end even though the whole
designer project was completely public
like anybody could see in country but
still you know we encourage first before
some other people you know submit issues
you see here's a problem and I'm curious
how common is that in the language
design you know when you make things
public you as documents
still you know you should get usual
discovered by your team because because
you are the ones who work on it all the
time think about all the time and find
problems with it
so what's about the problem so let's
take a look at the particular point of
the particular problematic example so
let's consider this sinc function this
repeatedly wait for something and what
if they work your answer is it's very
fast returns completely future that's
already complete like it doesn't have to
wait for anything so what's going to
happen so we're working in this whole
you know a sinc function compiler head
compiler is a state machine we're inside
this compiler generated method for this
state machine so we're invoking wait on
you know a way then invokes when
complete incomparable future and the way
it is completely future in Java
implemented is actually many at
synchronous constructs in Java
implemented on that way that if it's
already complete it immediately
synchronously invokes the color so it
will actually right here
in work whatever lambda would pass to it
and we'll check you know it's no
exception it's you know well you and
invoke Annunciation resume and that
resume continues is actually implemented
by by the same you know state machine
objects which then delegate to a state
machine class and we get back inside the
same code in woke await again and you
know you see the pattern it's so going
to end with stack overflow error so I
mean the worst thing about this problem
is that it will in practice it will show
I can render places in your code like
under it might you know you write some
code you know do lots of step one step
two step three you know a synchronous
actions and sometimes if it's under
certain timing condition it will Steger
flow others it's not will be really hard
to reproduce and track back so I mean
definitely we can choose to listen this
way we have to find a solution so then
solution turn out to be a like a
multi-step adventure so at first let's
address the core problem the core
problem is that when you look at this
signature suspended function in depth as
they were designed a prototype I mean
all you can do is you can invoke
initiation it basically it's kind
designed for functions that do suspend
and there's there is nothing you can do
if you don't want to suspend so we
change that so instead of eternia would
we started to return what in any
question mark that you Java's object
just anything and in fact this is a
gimmick to represent the unit of the
result time and a special talking called
curtain suspend it lets us distinguish
between two cases so if the curtain did
not actual suspend decided not to
suspend it just returns the result it
does not invoke continuation and if
curtain suspend it returns a special
token and prom will invoke continuation
later on so it's one of the either
you're not supposed to return result and
it all continues you're either return
result in war you say i suspended and i
will invoke continue later with this
conventional place we can uh we can
avoid this sticker of all stuff because
if we don't want to suspend we'll just
return it instead of going into yet
another loop so having change this
convention which always remains is just
to write implementation this await and
because the protocol becames complex i
have to either suspend or invoke
continuation i mean there is an ism
consensus algorithm here because it's
all multi-threaded etc said we have to
coordinate multiple threads potentially
here to make sure why only one thing is
taken I mean we can expect users to
write the code like this I mean this
goes definitely correct but again
religion in such a way is you know low
because you know the whole vision was
that it would be easy to write
suspension functions like this and it's
this kind of is definitely not going to
be easy like people will be writing
definitely will be
wearing the simpler code and falling
into the separate flow trap so that's
kind of start the solution the second
step is let's instead of doing this very
complicated transformation were like you
have to have continuation you turn some
strange stock and you know Union which
is not actually expressible incontinence
types it in later in Java type system
soldiers attack let's actually hiding
this whole complexity let's transform a
wade into its natural signature remember
the way it was invoked on a call site
was just passing completable future and
expecting result so let's express it in
the signature but when we compile it in
GBM let's actually perform the
transformation add this continuation
parameter during compilation so we call
this CPS transformation radiation
passing slow transformation well it's
not like just simple CPS transformation
where you set continues you also have
this additional convention about result
to make too low us say that no we don't
want to we don't want to wind this deck
just return result immediately so then
we have to allow people to write the
code somehow the idea was a word from
scheme so it has a brother called Cole
cc-cold is current situation which
basically what the data basically
captures the continuation of current
execution into very well asset to
subsequent board so we kind of took this
idea and said okay now if you want to
write a way do you want to because like
in declarations it now doesn't have
continuation but you want access it I
mean what you do is you just use this
magic such magic suspend curtain or
return functions that gives you back
this hidden continue so the whole idea
is going to work while you the
convention we had before right but
instead of having you know both your
arguments and continuation in declared
you declare only your actual arguments
and get continuation through this
special magic and Vickie
but how will make this major
communication work so the idea is this
we declare the suspect urgent or return
as in line suspending function which are
cakes takes a block of code this
parameter the block is functional type
takes this receive this contagion
returns our magical talk on this one and
this this function is going to be
interesting in compiler so instead of
HEC income like the current inversion
we'll just teach comparisons in one
magical function and this magical
function will get compiled actually just
like other suspending function using CPS
transformation and but it's so it will
actually gain this hidden situation
parameter and we'll be able just to
invoke the block with this continuation
that that's not but I cannot express the
function counting code so this is
interesting because normal suspended
function don't get the contagion
parameter it appears only through
compilation so this is intrinsic you
know has to be implemented into English
the other thing that has to be
implemented in the language is called
tail call so basically my weight
function makes a tail call to this new
magic function and here we have to
remember that when it compiles my weight
function gets contingent additional
parameters so I don't have it declared
by winning couple on GBM my geum's
signature will have this additional
continuation and we know because what
did the only thing it does it makes it a
little to sustain kuro-chan return our
compiler will just pass on continuation
to the next code so this way I can write
some code inside it will actually will
disappear in completion or just if I
declare a previously so this way we can
turn the new code into the old code
during compilation that doesn't solve
our problem with the complicated code
that you
SURS have to write in order to make it
work and that's where abstraction helps
it so now with all those pieces in place
we can define high-level function called
suspend curtain that it's we call it
give it to shortened name because it's
safer to use what it does and it's just
encouraging function and basically we
seeks a block that's structured simpler
it ruins the unit it doesn't have this
you know suspended you know suspended
talking anymore and it encrypts away the
whole complexity of consensus algorithm
I don't have to like it in abstract in a
way so that I can write my weight in a
simple shape I can use this higher
higher level suspend curtain function to
write my weight function on completely
future and suspend Kirk encapsulates all
the complexities of actually making sure
that I either call protein or return
continuation oratory result so this way
the code looks simple but it actually
works correctly and this is the
recommended pattern that we now promote
to the users like okay if you have
something called a base like completely
futures about the kind of future you can
write just suspending function that
works with it like using this simple
pattern and you know all the
complexities a hidden side questions
here are you following me
so let's recap so we had to introduce
this complex convention to allow to
solve for stack overflow error but we
use toward fidelity between the call
side the Declaration side by hiding CPS
transformation and we've introduced call
CC to recover hidden situation is now
hidden we
- compiler how to do tail calls so we
can code this previously but compiled
code is the same it combines with nicely
combines with scotland's inline
functions and we can abstract away you
know complexities of consensus and hide
implementation details from end users
the final touch here is that you know in
the original prototype we had defined a
weight as you know as function that
takes completing future as a parameter
and in fact what we released is really
this extension that you invoke on a
computable future so this way the code
that was originally looking like this
where you call the weight and of
something would look now like this
something gotta wait and it just Kotlin
style of there things you know this way
you could reads like fluently you know
left to right you start some work and
then you wait for it result it's just
you know and cutting most API sir this
like cognizant language is designed to
be fluent so you can you know you could
reach like your prose but so let's
continue the story this so we've looked
at the evolution of this spanning
function between prototype and release
but what happened to is the way you
build your curtains this is called
curtains builders in cotton and in
prototype you had this pretty
complicated syntax to occur them so
that's how your sync definition have
looked into the prototype and it used a
special keyword to declare the fact that
I think the the body of the sync
function was lambda dispatched to it
well will have will be curtain so it was
yet additional modifier and again magic
signature transformation because in the
code like the block is inside it just
returns some key but you have to hide it
inside
complex you know transformation of this
natural signature into this one to
declare it and it has a magical
incantation of how to start correcting I
mean then you know you can work faster
you're stuck with with all the details
of how eat a working prototype the the
future controller that was supposed to
be to declare it with few special
operators to handle the result or
exception of the curtain
so whenever curtain completes it would
either invoke handle result or
controller or handle exception and you
read some code in case so if you wanted
to return the future you would complete
your future it's it was simple but but
like it all did not feel natural so what
we notice is that the continuation
parameter that we were passing to those
operators was not actually ever used so
we removed it and now this the whole
controller stuff such a tool can special
select intonation just different needs
so we're just basically something you do
after your curtain finishes you know and
so we did that
you know issuing all the details what we
did is we looked at the Essene
declaration and also just like it's now
something that takes contains parameter
behind these things although they have
this would have this you know sepia
transformation that kind of hide
continuation ferment users and so the
way to evolve in the final release is
that now you declare your builders like
this you're right
that if your parameter is just a
suspended lambda it's lovely that you
know with suspend modifier which means
it will take hidden contingent site but
your signature now looks natural yet
signatures your declaration so it looks
the same as you would actually use it at
the call site because of the code that
you would write some block of code that
returns T and I think wraps it into
completable future and returns to you so
not all its natural and we removed a
need to have a
you know no it was a keyboard but but
imagine fire but anyway there's we just
have suspense now we don't have any
place for courage I'm a different
language
and the way we start coaching is the
just end of library has this method
start coaching that you know you give it
a completion continuation like what to
do when the curtain is over and now you
implement it simply your future
controller or name it whatever you like
it is now just implements contingent as
a bonus of all that that we've kind of
normalized all of the features and now
we're using continuation everywhere and
we're using suspending function area
where it became possible to write this
really magical loading function this
function is at the same time a
suspending function so you can use it in
a curtain that's that was the key idea a
sinker weight so like in c-sharp you can
use a weight only in a sync book I think
look start security and the way it can
only be used in it so suspended function
can only be using curtain but you can
also it can also serve as curtain
building can take a block that that's
yet another Croteam and because all of
that works through content generation
interface I can suspend current curtain
and start another inner one passing
continuation of that one is a completion
of my my inner continuation so then
instead of writing my function more work
like a sync function and you know that
returns control future what I can do I
can instead write it as suspending
function that instead of returning
completely future just returns the the
type T in in whatever my result is drink
in this case and so that way I can move
a level of indirection so it's becoming
a suspending function that I can use in
some other place directly
this is all became as possible because
we introduced this tail call till tail
calls we allow one suspending function
to invoke another one and suspending is
just as a spinning function we can now
invoke that's great there is look like
it'll it looks really useful because it
allows us to do in once has been
influenced actually do arbitrary
suspending elevators no just tell just
by adding this suspending function we
can now in the body of it while you just
invoke await which previously was only
de vocable from a sinc functions so what
we actually did we folded this home to
compiler so now in in costly release you
can just say I have a suspending
function that does some work and you
know just do arbitrary invocation side
of it in compiler is smart enough to
figure out oh you're doing non tail in
vacation then I need to create state
machine and all this machinery to do
suspension laboratory places of the
function f if I do just tail in vacation
compared against Martin offices all
you're doing only tail suspend in
vacation I don't need a state machine
stuff I can just pass on continuation
directly so it became some becomes all
hidden inside and this gets us to very
interesting discussion it gets us to
discussion off take lies curtain versus
tack for curtains so if on the last year
stock you saw white table like this one
which is basically gives the contrast
tactful hurricanes and stackless
curtains and you know status routines
are like c-sharp Scala cotton where you
can do suspension only very limited
context and stag fokker jeans are like
waz or java flow that you can suspend
anywhere but let's do an actual
conversion what what you can do in
coffin what can you you can do in closer
in cotton you can suspend anywhere in
function that is marked with suspend
modifier any quarter you can also
suspend anywhere as long as it's marked
with a so suspend exception or
suspend a ball Marcos suspended
voluntary so in both cases I mean you
have to mark functions where you're
going to suspect so does it mean that
now Kotlin after all these changes now
belongs to the same group as quasi JLo
etc so does it mean a ducati now has a
stack for current days or does it mean
that actually it's not like causing
Quadrajet or it's all stackless because
you have to specially mark and the only
two proteins that are truly stable are
in languages less Lisp where you can do
call CC anywhere or like go where
everything around says it cartoons and
any function can suspend your execution
in get switch to another protein I mean
it's hard to answer and I would actually
claim that it's false dichotomy like the
whole is division of stackless tables
it's pretty useless in practice because
I mean it's unclear where to put like
causing or quaza in what bucket
stackless or Stackpole you cannot reduce
weight the other way what I would say is
the only useful distinction that
different Carleton implementations have
a distinction between a sink and
suspended functions so let me go and
look a little bit more detail on that
what what's the difference between a
sync function and suspended functions as
think functions is the percentage return
some kind of a future it may be called a
way table you know tasks something
different languages promise called
different way but conceptually a c
function you know
we turn some rapper of the result that
you will use to weight and suspended
function they just return result but
they suspend execution until result is
available and the key thing is that in
constant you have a choice you can write
your function is the first way in a
sequence or you can write them another
way in suspending way and you have this
interest for example with squads are so
that puts both coughing equals into the
same bucket whenever you call it but for
example if you look on other languages
like the historical adapted seashells
approach like dart you know JavaScript
don't have this choice like the only way
to use courage is there is to write a
sinc function the only thing you can do
there is new facilities to provide
suspended functions and like in c-sharp
working proposal to include courage oh
sorry C++ working prototype to include
to include current in sort of the same
form I mean all you can do is to define
your functions to return some kind of a
wrapper so why it's important
I would actually now argue that so
important that you have to name using
functions in a special way so I would
say that everything function should have
somehow get reflected in the name why
because there is one big problem with
the thing ah when you have an a sinc
function that you can just invoke it in
interval identification it starts the
operation and immediately returns here a
future that you can use later but the
operation works in program concurrently
with your invocation or you can start it
in a wait for it and you know in
languages like C Sharples kind of looks
like a single cause await some operation
in cottages medicine vacation and that
produces the actual result waits and
produces result so the first usage is
concurrent and a synchronous behavior
your program continuous while the other
word happen in the background and the
second usage is sequential I do
something like like a normal code or
something I wait for it I continue like
regular code and in practice where you
write some kind of for any complex
business logic the second one is what
you need like like you like every
programmer they were taught to think
sequentially do these do that if they do
that and second affair should be default
like throwing thing currents and
developers it just just you know just
risky it's it's error prone you forgot
to wait on us in function and
you have concurrence out of thin air
where you didn't want it to have it so
cotton suspending functions
imitates equations you hear by default
that's the idea but by default it should
be sequential you should have you should
be opting into concurrency not getting
it by default and so that's why I would
claim that this really important
distinction that you can write suspended
function comes in which are sequential
unlike why JavaScript where all you have
to do the sinc function in concurrency
is being thrown at you but that's let's
just start in your story so now let's
talk about compatibility of all those
concepts so now we have builders and I
can default the Builder that returns
computable future I can return wouldn't
go of a threesome or future I don't earn
my own future my eventual task I can
define you know suspending function I
can define a wait extension completely
future on with no future on my own to
try anything else and what I actually
want I want them to compose together I
want to be able to use some third-party
library methods that return some crazy
future wait for it inside my sandbox
that wraps it into future that I'm using
my project or just use it from
suspending function that and does not
work do not wrap it into any function
you need to compose all that and a
prototype we were struggling with this
compatibility and the decision was to
make all suspending function composable
by default so we ruled over social
compatibility and we made a synchronous
use case a default one because a
synchronous world it doesn't really
matter I mean what suspending
function you invoke and what kind of
results you produce they can compose
nothing prevents them from composing and
we allow to defend themselves suspended
function anywhere there's no restriction
anymore that they have to be inside
controller and it's like this anything
but there is there are synchronous cases
where you generate yield and these are
synchronous curtains because when you
generate the sequence you want to is you
and produce next element with yield are
in the moments of time that you control
when you invoke next you want curtain to
resume work until another yield and this
synchronous use case it has to be
restricted I can just do arbitrary
suspension inside of such clarity and so
so we made an opt-in behavior for that
so we there is a special restrict
suspension annotation cutting that lets
you define synchronous Kirkenes we won't
go into details but I mean the
integrator that we made a synchronous
use case default because that's the
world were living I mean also people
need those like this what I think await
has up opened their there or two so the
last piece of the compatibility puzzle
that we've introduced is curtain context
so in the prototype there was this
vision that you can create UI bar
encourages that you can invoke some I
think UI function and it will force
everything in its body to do to work in
UI thread how easy because like in
prototype a wait was define it in the
scope of us enjoy and when invoking
Raziel on the continuation you would
first dispatch it to a thread
so all the code you write is new actor
so this way you can avoid Christmas
incorporation and update you UI and
don't worry about ritsuo translator that
was a vision in the prototype but the
problem is that of course it's a special
person builder and a special subpoena
function and scope and we have the same
again composability program are we going
to divide it for every kind of future
all again all this builders it's it's
hard so the way it evolved instead we've
agreed that every builder will define
will be taking a context as parameter
it's kind of a convention basically all
our libraries that build curtains take
this context as parameter so you can
specify what you want with what's
reading behavior you want ah and this
context
have capacity to intercept continuation
so when I come with you it gets it gets
passed through the context that context
can can decide whether it wants to to
dispatch it to its own thread a nod like
it's up to the implementation because of
that we had to a little bit expand our
original continuing to page from the
prototype so we've added contacting the
continuation this way whenever curtain
works it always have a completion
condition will look up all the
information out of there ah the cool
thing about it that's suspend in
functional come it doesn't have to be
aware about that because all this
interception is actually hidden into
language support runtime so you right
away the same way as before like the
weight code I've shown you for
completely future is the actual code you
just work with me high context it will
get dispatch it to UI thread and I can
have two different UI frameworks I can
have different UI context and they will
all dispatch your profile thing so the
other question we face when working with
the prototype and again if you look the
the presentation was here there was an
open question it with the prototype what
about what you do with thread safety
because you know curtains are this are
those thread hoping things like you can
write this code you can create a list
and it will work one thread then you do
some suspended function like a weight
and it will suspend you and after a
while will resume the same code but it
may have an indifferent thread and in
another thread now you can manipulate
your list do we have a data race here or
do we need the question do need volatile
right or is when we spill our state to a
state machine evenly reloaded to make
sure that it's awkward to synchronize
the the answers result in no there is
there actual no Desiree's here because
a weight whatever implementation and
weight does whatever think of it does is
establishing happens before relationship
if you look documentation of say when
complete of a complete of you explicitly
says that there is a happens before
between you know the completion of the
future and whatever happens as lambda
and it's to about every other
synchronization concert that we have in
Java and GBM so so we don't have to do
any extra work like to wait whatever a
weight does will ensure that happens
before is there um unfortunately it's
not that simple and now I'm coming like
you know open questions part there are
still some challenges with the way it's
implemented and I will just name a few I
mean the most interesting challenges for
this particular group so I mean people
who might be implementing some some
things like that so one interesting
thing is how threats and cartoons
interact for example you can write this
code this pretty legal code you can wrap
suspending a vacation in to synchronize
action and what happens actually that my
current role will have been one thread
and what interesting can happen in
another thread because it can resume
another thread what you get you get a
legal my under state exception of course
you know and if it would have been easy
if it happens only with minor and
reminder exit but it's not just it it's
also happens with reinterred locks they
will also to exception if that happens
if you switch this read you can't lock
in one thread and unlocking the other
one it's also happens with thread lock
off and it's also happens with you know
with like things like that rely on
current thread so I realize that I'm
still the same thread there's some
libraries that use recurrent thread and
do something about it but you know after
a while I mean stupid the other thread
so so remember that you know we're doing
what we're doing with the local we're
not catching GBM we're not modifying
using unsafe to hack into thread local
class so
Canha transparently migrated locals with
us so we're kind of we're taking really
safe paths so for example like the quasi
quasi kind of takes a boulder passage
actually hangs you know the locals you
know wisdom translate migrate them to
another threads when when it does that
we don't so we have to provide something
for our users and so that's where
current in context works for us
so granting contents actually is not
just for interceptors is it's generates
map of occurs in local elements that
user can define and this kind of set
local replacement for us so this way if
you want to hacks or locals you can do
it you can you can install your own
interceptor that would you know whatever
context the sewage will happen migrates
with locals to have the fit but we just
don't provide this kind of behavior
out-of-the-box in the standard library
because playing safe we're not touching
any you know hidden API things like that
the other challenge that we have our
stack traces and exceptions so let's
take a dis code so we have suspended
function won't work that it invokes
other suspended function work and that
one awaits for something and get
suspended after a while it will get
resumed and when it gets resumed you
know remember when you resume you invoke
resume function and the state machine in
the work function implements the surgeon
function so the state machine option of
the work function is what provides that
implementation so what now happens if I
resume my stack would contain this
resume invocation and I'm back to work
so now if I throw an exception that's
what I'm god that's what I'm getting in
my GBM stack but the user thinks that he
is in a functional work that hasn't
worked org so there is mismatch now
between the stack the GBM sees in the
gets thrown an exception and what user
thinks and want where and this is by the
way difference between how corrosion is
implemented for example cutting claws
are because quads are restores actually
the whole stack when it resumes so it's
less sort of problem we took a little
bit faster approach so we laser whisker
stack we don't roll so if you're
suspending deep invocation with resume
without restoring the whole stack but if
we had this mismatch problem and it's
really hard to patch the like exception
classes in Java in GM they don't provide
you lots of freedom to manipulate your
kind of stuck and it's hard problem to
solve like you know we would have loved
some features that would let us more
customizable approach to stick races so
we can patch our region of this deck
onto the exceptions that I get its own
and again remember the width in local
transformation we don't want to patch
everybody's code like our
transformations purely local to the
suspending functions that there are so
what else the libraries has also evolved
over time since the time the project
will wrote a lot of libraries support
for Kura teams you know language support
is really small all we have is the
language is suspending keyword some
compiler things and you know they start
curves in suspend code and stuff that's
it a little bit in language itself that
is answers the library so we have a
bunch of you know communication
primitives like our own futures will
force to have a different name for them
because like the word future is a be
used everywhere in GBM like your
reasonable completable simple future so
we looked at the Wikipedia ID for the
synonymous for future in progress let's
use it so we also define the music's
again we can't use lock which Java token
current because that one blocks a thread
if we wanted something similar but that
suspends the carton so we have a mutex
with a spinning function log that would
suspend a curtain until until it's
available we've also implemented in all
channels the classical ones from CPS are
you know with you know synchronous where
in the buffer channels all this
abstractions that say people in some
other languages are I used to like
especially concurrent languages like
languages for concurrent program you
usually have lots of that like built
into the language voice library so we
implement all this primitive Excel
library we also provide a bunch of car
team builders so I think is if what we
started with but it doesn't turns out
not to be the most useful one the most
useful is actual ability just to write
suspended functions or just for example
lunch curtain and forget about it
you don't want any future results you
just want to luncheon forget about it
sometimes you also need to integrate
like you want to block a thread like
your main function while recurring is
working so that's our important period
we also have like with extra facility
integration with lots of reactive
libraries like corrects different
versions towards a corrector all that
it's all a library part of it ah we also
provide like the general selection
facility so we can wait like you see
from multiple channels simultaneously
the way you know do time out do suspend
them you know all this stuff it's it's
becoming just a library and the good
thing about it you don't like it's
really clean it's not like a wait some
delay or you just call delay and it's a
spending function that you later yogurt
you don't have to wait something so
special future that would fire in
certain milliseconds you just say what
you like your code you reads like like
what you want to do like a prose again
you just see what's going to happen
there are some work-in-progress things
that we're still working on on the
library side we're we're working on
civilization of the curtain and
migration of them you can do now few
people has already hacked in using using
you know for using reflection or some
other libraries with we want to build it
like a more supported think so you can
sterilize them we're also working on
migrating this and other content
backends JavaScript and native I mean we
have language support there but both
cognitive and coughing Geocities support
on a language level card
but the library is amazing like all
these actors you know channels are still
have to report it
we're also looking to support all the
pipelining stuff so you can get channel
filtered map it to basically support all
the dataflow programming kind of thing
so you can program with data flows
expressing your data files with the
concise code also working on a IO
library with by channels and stuff that
would be actually suspending so which
instead of installing the calendar you
just say I want to read and will suspend
until the bytes are there it's right now
we have a prototype it's backed by by
Nettie and you know we have a project
cater IO that's a service edge framework
that heavy will realize encouraging
because of we have carving support we
can express the flow of your server-side
application with a simple code no
callbacks no callback l you just write
what you want to do this this go allows
here there it's always step by step code
with intact it's completely synchronous
code when it gets compiled a closing
note on terminology of that
that survived it having listened drawn
talks in cotton we don't use the term
fiber strand green thread which is a
wedding for us the Kerching is enough
and if you actually open Wikipedia on a
fiber it says you know curtain is
basically the same concept so we decided
that we don't want too many concepts to
confuse our users so we just use the
term curtain curtain for us is a
lightweight thread is the synonym for
fiber snow for everything else it makes
it simpler
just less terms to for end-user to
remember so let's serve up I mean I'm
we're out of time now in count
incursions our experimental what does it
mean it means that because the design is
you like it's not unlike like every
other mainstreaming language is not like
we don't have a wait I think key words
that everybody seems to all these days I
mean it's a complete new design and
there are good reasons so we wanted
people to try it for real and there is a
limitation of what
can do while you're playing it for
yourself so we actually released it on a
public with an opt-in switch so it's
experimental you can obtain into using
cartoons but we still guarantee backers
can do it because it's a release a
teacher you know we guarantee that your
code that you compile with current teens
now we'll continue to work tomorrow
because we want people to try it for
real and get us feedback on how it works
we reserve the right to break forward
compatibility so it means that we may
add things so that the new code won't
work with all runtime that's the only
difference between experimental feature
and the normal fish-like for normal
features we support both ways
compatibility especially for minor
updates of the compiler and the
simulator points we'll have to find out
a design there's against too of an issue
with threat some other implementation
details that we'll have to hire now and
at some point we'll finalize but anyway
the old code will still support will
still be supported will provide some
kind of support library when the design
is finalized that's it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>