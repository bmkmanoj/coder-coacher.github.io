<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Streams in the Wild | Coder Coacher - Coaching Coders</title><meta content="Streams in the Wild - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Streams in the Wild</b></h2><h5 class="post__date">2017-10-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xgHGpsubL5M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well I guess we can we can begin welcome
to to these talk streams in a while
thank you for coming I hope you'll enjoy
your next 45 minutes in this room what I
would like to talk to you about today is
of course about the stream API
introduced in Java 8 and especially to
show you
advanced patterns with the stream API
basically based on the splitter ater
API which is a an API from inside the
stream API this will be mostly a live
coding session I hope you all liked live
coding yeah do your previous lines but
at points plenty of bullet points many
many burritos I've got something for you
for that showing that this work is
mostly based on a work I've published on
huge on YouTube on github sorry a few
months if not a little more than a year
ago an API called streams utils which is
basically an API that extends what we
are going to show what I'm going to show
you in a minute to come my name is Josie
and live in a Paris area here are some
links with the some of my works you can
find on the on the Internet including a
youtube Botox my also proud member of
the Paris Java user group in case you
have questions just raise your hand
shout make some noise so that they can
hear and see you and take a question do
not hesitate to interrupt do not do not
wait for the for the end of the talk if
you have questions and if you have
questions afterwards you can use this
hashtag I'm always monitoring it so if
you have it's a good way to interact
offline after after the conference and
that's it for the slides now I know that
some of you probably like bullet points
are I do not want to create any kind of
frustration in the audience so I
gathered a bunch of bullet points here
for you guys
and that's it any Oracle OpenWorld only
people in the room it shouldn't be
saying that imagine the answer is true
what I'm looking at yes this I need to
switch this right and switch to here
this is an ID can you see it sit I will
favorite tool it is the phone big enough
for everyone
yeah could it be bigger I can I do that
print on to mode maybe where is it here
presentation mode is it bigger
not really yeah is it okay for everybody
okay fine so what do we have here we
have a basic list of strings Java 8
style we we could have used the the
wonderful factory method from the list
interface but this is this is still Java
8 code so it's not you all know that to
create a string on this we need to call
the streamer method on it and from that
we can just call for instance for each
to print out the content of that stream
of that stream
okay let us run this code great it does
what we expect it to do where did this
stream method comes comes from it comes
from the default method from the
collection interface that in fact does
two things create a splitter rater here
by calling another default method and
passing this Peter rater to a stream
factory method of the stream support
class which can create stream and what
does this stream support class do it
does once again several things it
creates an instance of this reference
pipeline dot add class which is in fact
the implementation and implementation of
the stream interface itself and pass the
splitter rater object we just created to
this implementation what what if
if I'm showing you this code it's just
to show you that in fact the stream
object as an implementation as a runtime
object is in fact created on two objects
well at least two objects first a
reference pipeline object which is in
fact where all the complex algorithms
the map filter reduce collect stuff
lives on and another object the splitter
rate object that is passed as a
parameter as a collaborator to this to
this implementation and that is in fact
meant to be to be overridden if I go
back to this split orator method I mean
stream support hey sorry guys I'm in
trouble with this presenter mode okay if
I if I go back to this to this splitter
writer object here and see what it does
it is indeed the default method from the
from the collection framework but that
is overridden in nearly all the classes
of the collection framework here's the
the override of this split orator method
from the ArrayList class for instance it
returns an ASP literature that is that
is particular to this to this already
subject and in fact what does this
pretreat object does it does the same
kind of thing as the iterator does to
the collection implementations you know
that we have a released and an iterator
for our list the same for our set and an
iterator for our set the stream API
works kind of the same we have the
implementation where all the complexity
is and we don't want to look into that
and an object that in fact hold the
logic to access the data and this little
rater object is is a little more complex
than the iterator object but it's still
fairly easy to implement yourself either
to connect your streams up to particular
sources non-standard sources of data you
may have in your applications all to
create streams of other streams once
we've seen that we can begin to play
with
for instance a okay I'm going to take I
need to take this code take the iterator
of the subject put this iterator in a
variable and just call create another
stream by calling this stream support
dot stream iterator and pass false the
second parameter is a boolean now this
boolean is true if you want this string
to be parallel and false if you do not
want this dream to be part he I'm not
going into this kind of thing think so
I'm just going to keep this as a as a
false or false value so this is a stream
of string why isn't it happy with it
and from that I just want to catch that
what problem do I have here I really
don't see yes thank you
this is a splitter returning not the
iterator and I'm going to call that
splitter Reiter Reiter all right
let us run this code and in fact it runs
in the exact same way as the previous
one okay so how can we create other
splitter raters starting from this
little Reiter created on that stream let
us do that I'm going to first create a
very simple splitter ATAR that in fact
does nothing and it should be a good
occasion just to visit the interface we
need to implement and see how the method
we need to implement work so I'm going
to create a no operation of splitter
ATAR of string no operation splitter
ater let us create this class real quick
I want to create it in that package
great it implements speech orator of tea
right what do we have here we have in
fact a collection of methods to
implement which are abstract method they
are for them and for other methods that
are default methods that we do not need
to implement in a first step all right
we will look into that more precisely
because there is a there is a trap in
that okay so this is our basic
implementation I'm just going to do a
little further go a little further here
because this knobs Peter Reiter is in
fact going to be created on the splitter
Reiter
of the underlying stream so I'm going to
create this constructor great this is a
splitter root of T indeed and I want to
create that field and this idea is
really great in hand I mean that right
so now I have this no operation splitter
a turd created on another splitter a
turd itself created on an incoming
stream or on an upstream right what do I
have to implement for that I have four
abstract method that I need to implement
of course if I do not do that it will
not work try advanced try split estimate
size and characteristics now you may
think that those methods have kind of
bizarre names on try split-- estimate
size and collection I have a size method
but I do not have an estimate size
method and this is in fact quite normal
and it comes from the the way the
streams work when you create a stream on
a source of object you ought not you do
not necessarily know how many object you
are going to to process through that
stream you don't do not know that when
you create a collection on an array list
for instance so set of object you know
exactly how many objects you have in
this ArrayList but it is not the case on
us of first stream if you create a
stream on on an ArrayList okay you know
the number of objects you are going to
consume but if you create a stream for
instance on a text file and there is the
method for that on bufferedreader class
which is which is called lines
this method reads on the stream on the
lines of this text file even if you know
that there are two megabytes of content
in this text file you do not know in
advance how many lines they are in it
there may be one line or a million line
or ten lines you need to analyze the
text file for that so it's really a
method estimate site that does that an
estimation of the sides of the stream
in some cases this estimation may be
accurate in some other cases it may be
not accurate for the moment what I'm
going to do is just wire this method on
the underlying split aerator so this
estimate size will just return the same
result as the estimate size of the
splitter rater I am creating on this tri
split method will be called if I want to
go parallel going parallel means I need
to split my stream in two parts give the
first part to a given Cove my CPU on the
second part to another core my CPU
process stuff in parallel if I do not
want to go parallel we fight I am sure I
will not go parallel I can return nil
with this try split method
characteristics for the moment I will
not go into details in this method we'll
do that in a minute for the moment I
will just continue to return the
characteristics of the underlying stream
and now there is this trial runs method
this is really where I need to write my
code if I want to do stuff non trivial
stuff later let us state it like that
this try advanced method can be seen as
the equivalent of the next method of the
of the iterator object but it works
differently first it returns a boolean
right and this boolean of force can be
true or false as many billions if it's
false it means that I do not have any
more object to produce with the splitter
rater and if it returns true it means
that I should the implementation should
keep calling this right nonce method
because more objects are coming okay and
now it takes also consumer as a
parameter action
we need to understand that this try
entrance method is going to be called by
the reference pipeline object provided
the splitter rater is provided to that
object so it's going to be called by the
implementation and the implementation
will check if there are more objects to
be consumed and if they are we'll expect
those objects to come at some point but
not necessarily at the moment at which
destroyed ones method is called we're
going to to see examples of that later
so this consumer is provided by this
reference pipeline object and I should
call the accept method of this consumer
with the object I want to consume okay
so somehow well I am on a splitter rater
created on an other splitter rater so if
I want to know what objects are going to
consumed by the stream I I mean I need
to call the underlying splitter rater so
in fact also called
this splitter rater dot try it once
method and do the same that is provide a
consumer to this trade wanted to get the
object produce by the underlying
splitter rater so let us provide the
consumer this is a consumer doesn't do
much this consumer will be called by the
underlying splitter rater the one I am
built and created on and this object
here will be will have to be passed to
the to the reference pipeline that is
calling me so what I need to do is just
call action dot except of T right here
I'm not doing anything I'm just calling
the underlying splitter ater hey do you
have object for me if so just call the
consumer I'm giving you and if my
consumer is called then I take the
object and call the other consumer given
to me with that object and this is the
way an object is transmitted from a
splitter rater to a stream by calling
this this consumer now this try and want
method method is going to return a brand
I'm going to call it as mall this
boolean will be true if they are more
object to consume
and false if it's not the case so since
this literature is not doing anything I
can just return this as more object just
to to complete to complete the process
and now if I check my calling code this
splitter Reiter I can just provide it
here so this stream is now created on my
operation splitter writer and I should
not observe any kind of differences
since my no obliterator is not doing
anything so let us run this code and
indeed I have the exact same behavior as
previously minor op splitter it is not
doing anything but then I can go one
step further by creating for instance a
splitter rater that is going to to block
some objects not transmitting all of
them suppose we create a filter in
splitter rater
of string now let us collect filtering
splitter rater I'm going to create it
just as the previous one in this package
I'm going to implement splitter rater of
T and basically I will just have the
same code as the no operation splitter
rater so I'm just going to copy paste
all this yes this is a consumer alright
I'm going to by the way also copy this
the constructor this is the constructor
of the filtering splitter rater and I'm
going also to pass a predicate as a
parameter predicate of T and I'm going
to call filter and just do that this
filter
equals filter filter create the field
just like that and now in my try
advanced method what I want to do is say
alright I see objects coming out from my
underlying splitter rater as long as I
can see object I will continue to return
true because it means that I can produce
more objects but I do not want to
transmit the object that do not pass
this filter here
so if filter the test of T is true then
I transmit the object if it is false
I do not transmit the object right let
us see what it does
so this filtering splitter rater is
Cribs is created let's see an in on the
know operation splitter rater it needs a
predicate of string
let us select only the strings with
length 3 and run the code okay so I need
to create pass my stream here on this
filter ring of course Peter ater
and you see that this time only the
objects with 3 characters have been
transmitted to the to do to the
downstream we created on the filtering
splitter rater so this you see that if I
show this example to you it just to show
you that it's not because I am returning
true that I need to transmit an object
to the end to do to the downstream to
the downstream splitter ater right if I
return true it just mean that I have
more object to send but maybe not now
maybe maybe later and if you examine the
stream API there are at least two
examples that works like that the first
one the most obvious one is the sorted
example to sort a set of objects you
need to see them all you cannot begin to
to produce object until you have seen
all the objects produced by this that's
dreama so this accept method will keep
answering true without producing
anything
and once the the up streamer is
completely consumed then the sorting
will occur and then the produce the the
transmission of the object will be will
be done and the second example the
distinct also these things were works
with the mental index if an object
resina
do we have already seen the subject if
not then I transmit it if I did then
unblock it it's kind of adaptive
filtering as you as in this case so in
fact this is a very classical way of
using this splitter Reiter Reiter Reiter
stuff ASP literature can also be used to
modify the object transmitted let us
create a mapping splitter rater mapping
split a bit of string I'm going to keep
it simple so I'm going to create the
class once again in the splitter it's a
package I'm going to yeah copy-paste all
this in fact all right not this one
great so this is a mapping flip iterator
and in fact the second element is not
going to be a predicate but let's say a
unary operator which I'm going to call a
mapper and this mapper will be a mapper
so I need to change this one again so
now what I'm going to do is in fact oops
is in fact remap this T object using
this mapper this is my map using these
mappers I'm just going to call mapper
dot apply of T that is I am changing the
nature of the subject I am not changing
the type but I could change the type as
well
and transmit this and transmit this
transform object to to my to my to my
downstream so let us work that on
example I'm going to take my filtering
splitter rater pass for instance strings
to uppercase like that this is my
mapping splitter rater and then on this
little rater
I create a stream and see what it gives
and you see that both the filtering and
the mapping have been applied that is
I've just changed my different splitter
rater in the old chain okay but what I
could do also so so here whatever I have
done I have blocked object I have
transform object but I can also create
more object in the downstream splitter
ater than I had in the upstream spitter
rater let us create a fourth wanna a
repeating splitter rater
of stream repeating splitter return let
us let us create this class
here going to copy paste this code to
make things quicker I implement splitter
rater this is a repeating a splitter
rater and I can for instance pass an
integer as a parameter this repeat oops
equals repeat yeah create the field
thank you and then each time I get an
object what I want to do is repeat that
object the number of time I haven't
passed it so if repeat is equal to three
for instance I want to repeat the object
incoming object three times so I can do
that
I guess like that in stream dot range
from zero to n so you repeat and then
for each index actually accept yes that
should do the trick
right if I go back to this stuff yes I
need to instantiate it new repeating
splitter later on the filtering splitter
return by a factor of two create the
stream on it run the code and you see
this time whoops
what did I'm oh yes I didn't take the
mapping splitter it let us take the
mapping splitter later okay so here you
see that every element has been repeated
twice so you really ask a question
yeah
you mean in try advance
yeah
yeah that's okay that's okay this is
what it's not doctor deprecated that
does not agree with that
why not
so yeah you're just allowed to call the
consumer once I assure that so this is a
bag I discuss about that more I really
wonder how you're sorted method can work
if you do not allow this kind of thing
so you're not allowed to do that hmm if
you change the behavior in 10 that is in
21 10 10.3 all right well it works right
it's pretty well
yes we're not doing power there clearly
clearly there is another point I would
like to raise it at this split orator
estimate size here because obviously I'm
multiplying the the size of this
predator by the repeat factor this is
alone and the estimate size might be
long that max value in some cases so if
I just return repeat time this splitter
ATAR
repeat here time this splitter Reiter
estimate size here am I going to trouble
because this long might become negative
if this estimate size is itself from my
long dot max value so I'm not going to
write this I'm going to keep it this is
just an estimation anyway so I'm just
going to keep it like that I just told
you a few minutes ago that it was that
sorry that implementing those four
methods was was enough to implement a
splitter rater in fact it's not exactly
the case suppose this splitter rater
here becomes sorted right could do that
run this code and here I will get an it
illegal state exception coming from the
gate comparator method of the splitter
Reiter interface and if I check that
indeed the default method of the
splitter Reiter interface throws this
illegal state exception now this gate
comparative method is called by the
reference pipeline object only in the
case of a sorted stream so I have I can
do two things here either I say alright
this stream is not sorted whether I
provide a comparator from that stream
note that here I sorted my stream
explicitly but suppose I have a method
that takes a collection any correction
and I call stream on that correction
that correction could also be for
instance at reset let us do that
quick reset of string created on this
sorry on this released string them pass
this reset here and now since this reset
is a sorted set in fact the stream
produced is automatically sorted itself
and I have the exact same bird Iligan
state exception right so here what can I
do I'm going to my know up splitter ater
here and if the underlying stream of
this node splitter ater is itself sorted
it's quite normal to have assorted beta
beta so what I need to do is provide a
comparator let me override this gate
comparator method by providing this
pizza rater
get comparator method object here and I
will have to do the same in fact for all
my comparator splitter rater let me copy
paste this splitter rater sorry the
filtering splitter rater
quite obviously will not change the
salted nature of the streamer so I can
do the same provide also a comparator
here the mapping splitter rater since it
can change the nature of the object
probably change a string into an integer
or person into the name of that person
it will most probably change the salted
nature of that stream so this time watch
what I should save for this potato is
that the produced stream is not sorted
in any case and to do that I need to
touch these characteristics method here
in fact this characteristic subject is a
word field of bits and each bit each bit
of this word has a meaning there is one
that is the sorted bit so if I want to
say that this characteristics are not
sorted anymore I need to
at the logical end with it to set the
sorted bit to zero and this is the right
way of doing it the repeating speed
generator would probably not change the
thus altered the nature of this of this
trimmer and I think that's it so if I
run this code again now I have fixed all
my streams either it's not so non sorted
either it's sorted and it can provide
the comparator so now I do not have the
back anymore but I still have another
bug in this code beside the fact that
I'm calling accept twice I really think
I can which is which is the following
when I'm when I'm closing a stream in
fact let me what can I do here let me
just comment this code for the moment
like that we'll come back to it later
and just produce the stream here and I'm
going to to just to print out the result
of that stream system that I would
printer so if I run this code it will
print out the result we all know that
but what I can do is set a callback on
the close method on a close call of that
stream sorry let me put this in variable
right call stream on closer provide a
runnable for instance system out closing
okay and closer explicitly and call the
close method on that stream if I run
this code then I will have all the
content of the streamer displayed here
and the closing method the closing
message appearing since this callback
has been called here now if I keep this
callback here so now
we get rid of this code and and come on
that all right so here I'm going to fall
back to this stream here
Cora stream to there under stream to
there if I close my stream to here I set
up a callback did I set up a callback
yes the set up the callback is set up
here this tree set is not used anymore
and I'm just creating this predator on
this stream here and calling the close
method of the of the stream I have built
on this one but if I if I run this code
in fact this code the callback of the
first stream is not cold anymore and it
should be since it's a callback and all
the streams should should call that
close method themselves so every time I
am creating a stream like that on a
splitter ater what I should be doing
really is a stream to call the on close
and call the streamer close method of
the other stream my splitter ater have
been created on this splitter Reiter is
created on the stream then all the other
splitter raters are created on this one
right so this is the stream that I need
to to to the callback has been defined
on this dreamer and closing that stream
created on the other one should also
call the callback of this one so now if
I run my code I have the closing method
that is properly called so in fact when
implementing a splitter ater there is
the technical part implementing the for
abstract method that's okay we saw that
but I also need to be sure that this on
close method should the on close method
well the closing callback is properly
called when closing the new stream I'm
creating on the splitter ater and I also
need to make sure that
I am probably properly and linked salted
the salted stream that may raise
exception if if I do not handle them
properly so those are the three the two
main traps in in handling those streams
in fact questions yeah yes sometimes you
can open streams on our resources which
is the case for the bufferedreader for
instance so closing calling the close
method on the stream should be closing
also your i/o through which resource
that you that you've been using in fact
the stream extends auto crucible so you
can use a stream in in a try with
resource api when you're just calling
streams on ArrayList and you don't call
the close method yourself it will not be
very very harmful but if you're using io
resources then you should definitely do
that other questions yeah
does the splitter return needs to be
thread-safe it really depends on whether
you are using it in parallel or not if
you're using it in parallel the API will
call this tri split method and you
should be returning another splitter
later on a portion of that stream so in
itself it depends if you have a shared
state in it or not but Denis in itself
all the other methods that do not need
to be synchronized and should not be
synchronized by default all right I
think that we are kind of running out of
time so I just added a few slides as a
reference the different meaning of the
different bits of this characteristics
word we just saw during the during the
the the live coding part of the stuff
they are basically self-explanatory and
maybe sighs the mean that you are
opening a splitter later on a structure
that knows the amount of element it will
is going to create think of an array
list for instance or are set and sub
size them which is the other one that is
maybe non-trivial means that if you
split the source of your of your of your
streamer if you go parallel then the
splitting will also produce elements
while sub streams that are sized if you
split an ArrayList in two you can you
can count the number of elements in each
part of the array list if you split an
asset into by by cutting the underlying
array you have in an asset or in the
Nash map into you cannot foresee how
many elements they are in the right path
and in the left part of this array so
the sides for our set for instance is
false whereas it's true for erased and I
also give you a hint at the stream duty
API that you can find on on github your
there are many more sophisticated
operation than the mapping filtering no
op which was really easy one available
like grouping rolling zipping they are
they are I think 20 or 19 operates
different operate on it and you have
also an an operator which does a
collection on a shifting window which is
extremely useful when you have a huge
stream of elements and you want to to
compute an average for instance and on
the shifting window in average it's just
a special case of a fur collection so
you can you can do that you can also the
results I also put an efficient
algorithm to extract the N maxes of a
given stream which is a useful in many
cases so this is the link to the stream
API conclusion yes if you want to
connect your stream algorithm and on
your own sources of data well you can do
that by your fiddling with the splitter
rate or API it's not that easy it's a
little tricky but it's very powerful and
it will it will really allow it really
allows you to leverage all the powerful
algorithm that are in the behind the
stream API which is which is really
great and I also provided the link with
my github account and with that I think
we don't thank you for your attention I
don't know we still have a few minutes
for questions if you have if you have
any yeah please
I don't know if any threshold really it
really depends on what you what you need
to do so then I I never I never came
across any kind of problem with this
with this stuff and I really had to to
manage large amount of data with not big
data side terabytes of data but in
memory large sets of data and I could do
that very easily going parallel is
always a more complexity and I would not
recommend going parallel if you not
really sure that what you're doing
stay stay in a non parallel world as
long as you can because going parallel
might in fact decrease your performance
instead of of increasing them be
extremely careful with that any other
questions
okay so thank you I'll make this slide
on a variable on my SlideShare account
very soon so you can check that and I
will tweet about</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>