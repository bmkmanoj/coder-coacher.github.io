<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Power and Perils of Parallel Streams | Coder Coacher - Coaching Coders</title><meta content="The Power and Perils of Parallel Streams - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Power and Perils of Parallel Streams</b></h2><h5 class="post__date">2017-10-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ia_TP5T57AM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright let's get started welcome to the
session on the powder &amp;amp; pearl of
paralleled screams my name is Venkat
Subramanyam we're gonna talk about some
of the beautiful things we can do with
parallel streams what are some of the
things we should keep in mind when we
start using parallel streams and and
such things so let's get started let's
talk about programming concurrency
programming concurrency is incredibly a
very difficult thing to do
a lot of us including myself have
started programming concurrency without
fully understanding the Java memory
model and it turns out if we don't
understand the Java memory model it's in
the Bleak art to get it right one of the
probably the most scariest book ever
written
Java is programming concurrency by Brian
gets and before I read that book I used
to think that you cannot get concurrency
correct at all and after I read the book
I am thoroughly convinced now you cannot
get concurrency correct anymore it at
complex actually in all honesty because
it's just a way too many things could
potentially go wrong well it turns out
that there are actually two different
ways that we approach concurrency one of
them is what we call as a divide and
conquer problem so you have a problem
you take n divided into two parts maybe
and then you take these two small parts
and you make a decision whether you want
to solve that a smaller part or you want
to go ahead and divide it further and
you can keep going and in sequence
through this the other of course is what
we normally call as parallel arrays so
you have a collection of data and you
want to execute those collection of data
in parallel
well the parallel streams really fit
into the second nature much more
appropriately than the first one while
you can try to use parallel streams to
really do divide and conquer it is not
that convenient or really a bill to
easily do this it's really intended for
the parallel race problem when you have
a collection of data you can easily
throw them into parallel execution very
nicely that's where you get this really
into so why does this parallel stream
really fit in well you have a collection
of data and you want to perform some
operations and you want to really speed
up the computation and you want to do
that in parallel well let's take a look
at how we could actually do this a very
simple example we'll start with right
here let's say we have a collection of
numbers in this case let's just say 1
through 6 for a minute and I want to
perform a very very trivial
transformation I'm gonna keep it
extremely simple so we don't have to
break over you know a head trying to
understand what the code is actually
doing so in this case I'm gonna simply
perform a math operation we're given an
element I'm gonna simply call a
transform on the element and then of
course after that I'm gonna simply print
out the element given to us so in this
case of course I'm going to just print
it out as system dot out let's say print
illan and ask it to print it well we
need the transform method again I'm
going to keep the transform but they're
extremely simple so it's very obvious
what we are actually doing right here so
I'm gonna say transform is going to take
a number let's say and all that it does
is simply returns the given number so
not a big deal at all as you can see so
we printed the numbers 1 through 6 right
here but of course this is running in
sequence as we would expect so I'm gonna
put a little sleep here off let's say a
one-second interval and of course sleep
is just a method I'm gonna write here
and this is going to just give us that
many milliseconds to sleep so what
what's gonna happen in this code when we
run this little example let's just go
ahead and run this from the command from
just to take a look at it and yes as you
would expect it's taking about a second
to run each one of those values and it's
printing those values one at a time
sequential e so that's a pretty simple
trivial example as you can see but I
want to run this let's say fast or
imagine the transform is actually a real
computation not a dummy think that's
returning number maybe it's trying to
figure out the meaning of life it's
gonna take a lot of time and so if
you've got to pass these values and get
the results from it well how do you
really from these operations maybe you
want to speed it up by running that in
parallel so to make this really parallel
there are really two approaches you can
actually take and one of them is to turn
the stream into a parallel stream just
by using the word parallel stream and of
course in this case it's gonna run in
parallel right off the bat let's see if
it really does go ahead and run this and
you can see boom it actually printed the
result right there in one shot after the
second so that's running in parallel
when would you use this approach well if
you are the source of the stream it
makes sense to use the parallel stream
at the source because you have the
ability to create a stream and while
creating it you can say
whether your intention is to run it
sequential or run it to parallel but
what if you're not the souls of the
stream imagine you are really receiving
a stream on your hand and you are the
intermediary somewhere in between then
what do you do well the good news is you
can do a dark parallel right here and
you can convert a stream into a parallel
stream by doing this as well as you can
see right here so this is yet another
approach for you to be in between in the
middle of the pipeline and say that you
would like to really convert this to a
parallel stream and you can do this
again let's make sure that's actually
working so go back and run the code and
you can see it ran it Rylee in one shot
before we go further
one small parallel you have to be very
very careful about because it's a bit
misleading when you are you know kind of
not really thinking about what's really
happening for example you may wonder if
there is a parallel call maybe there
should be a sequential call as well and
it turns out there is as you call that
you could actually use let's remove the
parallel just for a minute from here it
is a sequential team to a stream you
lead you know it you just said
sequential well is it running sequential
well sure enough you can see that it's
running sequential I won't wait for it
so the temptation here is oh this is so
awesome
we could take this map and run it in
parallel and do the for each sequential
e well not quite so the last one
actually wins so in this example this
entire pipeline is going to run
sequentially even though we'd set
parallel in the beginning so you have to
be very careful about it in the case of
parallel streams or in the case of
streams you don't have an ability to
flip back and forth between segments of
the pipeline to run parallel was a
sequential this is purely either fully
parallel or fully sequential so in this
example notice I did say parallel in the
beginning but I'm saying sequential
right after that in the in the middle
but when I run the code notice though in
this example it is still running
entirely sequential II the map is not
running in parallel and that is because
this actually influences the entire
pipeline so from the beginning not just
from that
onwards so we have to be very careful
how we use the parallel was a sequential
but also begs the question if it's so
really easy to create a parallel stream
then why don't they really make
everything parallel that's a question
I've been asked several times by
developers my gosh look at that you can
just say parallel stream and make it run
parallel if it is so easy why didn't
they just do it for everything what I
call this a master switch and the reason
I call it a master switch is they made
it so easy up to the point where they
could have almost done it bid they
didn't do it and then give you the
switch and uttered one word at you and
that word is called think so they want
you to think about this before you turn
on that switch because turning on the
switch is really easy but the
consequences could be really devastating
if you're not very careful about it so
what are some of the things we have to
be careful about we'll take a look at it
so in this case I want to know what
threads are running our little code so
to understand what threads are running
our code let's go ahead and run this
little code again sequential if you will
but I'm gonna observe the thread that's
running this so I'm coming here an
output let's say in this case we'll say
transform and then of course we will say
the number we are transforming plus we
will output let's say thread dart
current thread and we can take a look at
the thread that's executing this
particular piece of code and of course
when I go back and run this little code
as we would imagine it is telling you
that every single piece of that code is
being executed by the main thread
there's no surprise there at all as you
can see I'm gonna suppress this
particular output so we don't have to
really look at it so given the element
I'm going to simply say don't do
anything with it so we can just see the
output of transform alone a little bit
more clearly at this point so we can see
that the whole thing is running in the
main thread that's no surprise at all
but on the other hand of course what if
I'm going to go back over here and
execute this let's say in parallel so if
I were to then do a dark parallel
whether you do it dart parallel or you
create a parallel stream at the source
really doesn't matter as you would
expect when I go back and run this code
you notice that all of them are going to
run concurrently but in warth thread
they're running in the for join pull
thread
as you can see but notice that almost
all of them ran in full join pool but on
the other hand the first one did run in
Maine Maine is a really nice thread it
doesn't sit there and say you all do the
work while I watch you it participates
in that as well in the in fact that is
one of the reasons why the four join
pool usually has one less thread than
the number of course because Maine is
actually a participant in that as well
but you are kind of looking at it like
really why are we so strict about that
count we'll talk about that a little bit
later so let's talk about the order of
execution I want to give you these
things and print the result so going
back to this example right here let's go
ahead and suppress this output for a
minute let's get back to this and say I
want to really print out the result so
system dot out let's say print learn and
then I'm going to print the results out
of this right here well obviously in
this case when I go ahead and run the
sequential e it is going to really
preserve the order well keep in mind not
all streams have ordering some streams
have ordering some streams don't have
ordering how do you know if a stream has
ordering or not well excuse me one way
to know is what is the source of your
screen if you started with the list we
know list is ordered we know a set is
not ordered so the source of a stream
may decide whether the stream is ordered
or not you can also call methods in
between that might impose ordering on a
stream for example so it depends on
whether an stream is ordered or not in
this example the stream is of course
ordered we know that so when I go back
and run this little code you can see
from the output that we get it's
sequential of course but it's in the
same order as you would expect so the
ordering is preserved because we have
ordered collection one through six but
the question is what's going to happen
when we turn it into parallel though
because it's going to run in parallel
there is no guarantee of ordering so in
this case as you can see it gave us
completely arbitrary order if you run it
again
5 4 3 1 8 2 1 3 5 well here's a good
news you got the result really fast but
the bad news is the endpoint is really
not sequential imagine you're creating a
report it doesn't help the customer tell
them good news a guarded really done
as bad news it's all jumbled up go
figure out that's not gonna invite a
good customer so how do you really
manage this well here's an idea there
are certain methods that will impose
ordering on the execution so in this
case I'm gonna say for each ordered and
before run this let's really talk about
it I am NOT suggesting by any stretch of
imagination that these are running
sequentially no actually not they're
actually running concurrently however
the very last step says I will not run
until the guy before me has actually
executed so it imposes ordering ordering
doesn't mean sequential they do run
concurrently but it imposes an ordering
at that particular point the point
really here important is that the map
actually runs in parallel as we will see
in just a minute so if I go back and run
this little code example right now you
will notice that they are all running
but notice no matter how many times I
run this the result is completely
ordered even though it's running
concurrently and that is really good
news that it has an order in postman
well let's make sure that actually
that's true so if I go back and turn on
that print statement on the map method
and run this again you will notice that
they are running in actually different
order notice that from the output 1 4 6
2 but from the output you have 1 2 3 so
the ordering is in the very last step
not in the execution of the map itself
they did run concurrently and they all
kind of come to a grinding halt and say
well I won't go until this guy before me
goes and that's when they are really
being you know in sequence if you will
so that is really a good news that you
can have ordering there are certain
methods that will impose that kind of
ordering for you if you were to use them
so that's you can kind of have the best
of both worlds in that in that situation
but we control the ordering but the
question really is how do things really
work when it comes to applying parallel
you already saw this example I was able
to use map in parallel similarly the
filter will work in parallel but then we
kind of wonder will things like reduce
work in parallel as well well to
understand this let's go back to this
example let's do the sequential e1
more time but this time around I'm gonna
go ahead and call the output right here
but in this case I will ask the very
last step to perform a reduce operation
and we'll say zero comma
total in this case let's go ahead and
say total comma element and we will call
a method called ahead which takes a
total comma element and returns the
result well this add method is going to
take two numbers and add them before I
talk about this in particular let's
understand what reduces actually doing
let's say I want to total the age of
everyone in this room starting with him
isn't it's not smiling at this point I'm
not gonna ask your real age so let's say
we'll start with him so what are we
gonna do I'm gonna give him a zero as a
value that's age of everyone to his
right he takes his own age at zero two
it passes to the next gentleman he takes
the value given to him adds his own age
pass to the next gentleman and then I as
this data passes through the room the
value that I get out of the last person
in the room either is the total age of
everyone in the room or overflow
depending on how old we are in this room
but the point really is that we are
going to have this sequential e the
value is going to trickle through this
room and we get the result over there
that's kind of what a reduces doing it
collects the results and brings us back
to one single value but I'm curious to
look at the ad itself let's go ahead and
once again remove this printout from the
map method but in this case I'm gonna
create a method which is the add method
which takes the value 1 and int value 2
and all I'm going to do is output let's
go ahead and say add + in this case will
output the value 1 and then we will
output the let's say the value 2 and
then finally we will go ahead and output
let's say the thread information as well
so thread dot let's say current thread
and print it well if we do this it's
sequential execution at this point we
start with the value of 0 like I said
he's gonna take his own age and add to 0
and then pass it down so as a result
what you're gonna see in here is that
basically when you run this code you can
see that in this case well actually
accomplish an error but we'll fix that
so in this case of course as you can see
it is going to sequential a run through
each one of these and and get you the
result out of this
eventually so let's go ahead and fix the
arrow right here be nice to return the
result here isn't it so let's say return
in this case value 1 plus value 2 which
is the result of the add function let's
go ahead and try this one more so in
this case you can see that the ad is
being called in the main thread the
value 0 plus 1 and then the result of
that is one comes down here 1 plus 2 the
result of that is 3 comes down here 3
plus 3 the result of that is 6 and then
you can see that it goes through
sequential II but the question is does
it make sense to do this in parallel
let's go back to the example we just
talked about just a second ago I'm gonna
give him a 0 and say let's total
everybody's age in this room sequential
II but then I quickly realize gosh I
don't have to really do this I am going
to give every person on the left corner
my left in this row a value of 0 and
similarly everyone in this corner I'm
gonna give a 0 and say why don't you all
every row total your age concurrent well
at the end of the first step I'm gonna
have one you know several as many rows
as we have in this room I'm gonna have
that many totals on one side and that
many on the other side and I can then
say hey the people on this row total the
values this way and people on this
column total the value this way in the
second step I'll have two values I can
put them together and get the value cut
you know immediately in other words we
could do a divide and conquer of this I
don't have to really do the sequential a
case in point in this case if I go back
here and try to run this in parallel you
will notice right away when I run this
code you can see that it is actually
running that all in parallel as you can
see all that ad is being called in
multiple threads and you probably notice
there are more calls to add than before
as as I said in the case
I'm gonna call add on different groups
of people and then collect it together
as what and the result is use whether
you ran it sequential or concurrent the
result is still 21 okay that is awesome
isn't it because I could run this code
sequential II and the result is 21 and I
can run the code concurrently and the
result is still 21 that is wonderful of
parallelism you cannot get a result fast
stir and say it's okay if it is not
correct right it doesn't make any sense
that result has to be still correct as
well when you when you do this so but
you have to be very careful though the
value that you provide here is not an
initial value got to be very very
careful about it
it is actually an identity value not an
initial value for example or addition
zero is the identity value for
multiplication one is an identity value
this is important to keep in mind
because let's say I'm interested in
totalling my own age to the age of
everyone in this room so I'm gonna say
20 right so you don't believe that okay
so I'm gonna start with that number well
20 plus 21 is the result we really want
in the very end so when it runs this of
course you can see the result should be
a 41 because the initial result was 21
and we see that it's actually 41 but we
are in real trouble now because I did
not give an identity value 20 is not a
value
I must mistook it as an initial value
the result is catastrophic as when I run
this code this time the fight is no
longer 41 it is 141 don't bet on it
could be completely different the next
time because it is feeding all these
parallel values with the value of 20
which really doesn't make any sense so
that is something we have to be very
careful again when we use parallel we
really have to I mean it's no substitute
for knowing what we do in general but
especially with parallel that's very
important and there's no point in
getting a really wrong result really
fast if you really want to get a really
fast
real if you really want to get a result
really fast and you don't care about
whether it's right or not you really
want to go back and program in C++ isn't
it so absolutely this is not the reason
to do it so we really want to make sure
that we get the result correctly as well
not just faster in this particular case
so when we go back and run this if of
course in this case the result is still
going to be the same because I'm
providing an identity value well then
the question is if I really want to add
my eight why do well sure that's not a
big deal because I can come back here
and add it at the very end of this
particular well of course in this case
correct something to keep in mind what
you're sending in as an initial value
makes a huge difference
but that begs the question we've been
looking at these threads
what are these threads really do what do
they really use we really want to
understand it so how many threads do we
get without doing any single work and to
understand this let's look at a little
bit of an output right here let's get
back to this little math function and I
would say for each in this case given an
element
I just want to simply suppress the
output let's go back to the map method
transform method and print that result
out so this will give us a little bit of
an idea how many threads are gonna run
for us now when I go back here let's go
ahead and take a values one through
seven let's say eight nine and ten but
I'm going to repeat this one more time
in here let's say I have the values just
repeated so I have these values even if
we want to really say let's say this is
11 and 12 and 13 I can have these little
values being provided so that we can see
how many threads are gonna run
concurrently well it turns out the way
this actually works is that by default
you get as many threads as the number of
cores on your machine so I want to know
how many cores I have on my machine so
let's go ahead and remove this just
momentarily and I'm gonna go back here
and say output run time dart runtime so
in this case let's say run time and what
are we going to ask for in this case I
don't remember this method right now but
available processors right so I want to
know how many processors are available
and it tells me there are eight
processors available on my machine so
that is a way for you to find out how
many cores are available it is a blatant
false information by the way it's a lot
I don't have eight cores on my machine
but that's what it tells me so in this
case of course it tells me that I have
eight cores I have actually four but it
just wants to calculate as eight well
that's fine but it's going to give me a
total of eight threads what remember
main is part of that as well so the
formed common fork/join pool contains a
total of seven threads when my machine
has eight cores how do I notice well
here's an a little example we could
simply go ahead and say over here for
join puh
a dart common-pool that's the way you
can get access to the common pool and
then you can ask for the details from it
obviously to do you use this I need the
java.util concurrent so I'm gonna bring
that in here so here is concurrent and
what am I gonna do at this point so
notice I'm gonna ask him for details
about the common pool when I go back and
run this little code it tells me have 8
cores but note this right here it says
parallelism is 7
well that's because 7 plus 1 is 8 which
is the total number of course on my
machine main being the other participant
of this particular Club so that is
basically what we are seeing here the 4
join pool is being used now here's a way
to think about it because of the nature
in which these things work this way how
is this going to be scheduled across
those different threads as you would
imagine I have 20 elements on my hand
I'm gonna schedule those 20 elements
over 8 cores on my machine so how many
batches are we looking at approximately
give or take three batches so 8 16 and
the remaining in to achieve the 20 we
can actually see this in motion here
let's go ahead and run this up and burst
of call here's the first after call well
actually if it compiles that is so let's
go ahead and remove this output right
here and try this again so we're gonna
see a first burst of the call right here
so let's see if that's true so here is
burst one burst 2 verse 3 done so that's
in 3 bursts as you can see the output
came through and the reason for three
bursts in fact a little bit easier if I
remove the thread details for you so
pardon me here while I make it a little
bit more easier to see with a little
concise output so here we go that's
burst one burst 2 verse 3 and done so
that's obviously scheduling across those
those eight different is that are
available on my system but that brings
up the question why so careful about
default threads why can't we just go
wild with it
we'll see why there's reason in just a
second so when you're doing parallel
streams you have to be very careful they
didn't select number of cores equal to
number of threads by default arbitrarily
they are very very clever they
said if anything were to go wrong they
want you to take the blame not them
right which is only what I would do if I
was designing libraries I don't want to
be blamed for decisions I make I want to
be very safe in decisions I make so the
safest decision I can make is to give
you as many threads as number of course
but that begs the question why in the
world is that safe well I'm gonna give
you a really silly example imagine there
are monks and you know how monks are the
most polite people right imagine there
are four monks and there are two
treadmills so the four decide to go to a
gym so they go to the gym and two months
get on the treadmill and you know how
monks are very polite they get on the
treadmill and they look down and say oh
my dear God you both are waiting how
rude of me to be on the treadmill and
they immediately get down from the
treadmill the other two monks get on the
treadmill and what do they do they say
how rude of me when you are awaiting
their I am on the treadmill and the
monks never exercise this is why it's
good to be rude in life sometimes isn't
it no just kidding
but the point really is this is exactly
what threats are going to do if your
threads are computation intensive they
behave that like like those monks
they're going to get on the CPU in this
case the ones below are the ones pulling
it down so it's kind of little
controversial in this case but the
threads waiting say hey you get off it's
my turn and the threads running on the
CPU say but I have work to do I don't
care it's my turn get off the CPU so
they eat the CPU only for these two get
on and guess what the ones that got off
do they turn around say you get off now
and they're going to trash each other
we're gonna lose performance we're not
careful so the model of the story is
this so the number of threads that you
always want to give is less than or
equal to and then you can do a little
little quick formula you can say on the
numerator is the number of cores on your
machine we'll start with this and then
one - well then I'm gonna say this is
called the blocking factor so let's say
what is a blocking factor so if I am the
blocking factor is zero less than or
equal to the blocking factor less than
one if I'm a computation intensive
thread then what happens if I'm a
competition item in terms of Ted I'm
running and running and running
I have no
opportunity to take a break I have
nothing to sleep for well my blocking
factor is zero if I'm an i/o intensive
thread I want to write to a database I
want to read from a database I want to
make a call to a remote system I want to
write to a log file I want to open files
and every one of these opportunities is
when I'm gonna say CPU you take it easy
I'm waiting on this file to kick in and
bring the data to me and what is the CPU
gonna do the CPU is like gosh I don't
have any work to do you are sleeping at
the wheel right now you're going to go
get the data well you might as well work
on another thread that requires
processing when I don't have anything to
do so if you have an i/o thread a task
you can have more threads using your CPU
more tasks using your CPU at that point
so if I have a task which is sleeping
for let's say in this case let's work
the formula I am a computation intensive
thread which means the blocking factor
the blocking factor is equal to zero
isn't it then the number of threads I
want to really create is less than or
equal to number of core because 1 minus
0 is 1 in the denominator but if I'm an
i/o intensive let's say with let's say
blocking factor of let's say 0.5 then
the number of threads that you can
provide me is less than or equal to 2
times the number of cores in reality if
I'm sleeping most of the time you can
give me more cores as assuming of course
that there is enough work to do right
and of course if the blocking factor is
1 that's a deadlock you don't want to go
there so absolutely you can give more
threads if I am i/o intensive
fewer threads if I am computation
intensive now you know why they chose
the number of threads default is equal
to number of course because that's a
very safe bet because they don't know
what you're doing they cannot predict
what you're doing so the safest bet is
to say hey your computation intensive
but what if I am NOT well then you can
vary the number of threads you want to
use well here's the formula we just
looked at to decide the number of
threads but how do you really configure
the number of threads that you want to
use in your application this is a
dangerous setting be careful using it
but this setting simply says - V at the
jvm level
Java dot util dot concurrent dot for
joint pooled our common dot parallelism
I love this property finally something
longer than my name so as you can see
here you can specify this property and
ask it to use this right here so how do
I use this I'm a little lazy person I'm
not gonna really tight this all manually
so I'm gonna show you the example by
using little script where I'm gonna use
this thread so here is a run config I
have written for myself where that is
setting that property as you can see the
run configures doing it so I don't have
to manually mess with this if I run the
run method just now as we saw it's using
the default number of threads
that's burst one burst two birth three
as you can see but if I do run config on
the other hand and give it a hundred
threads that's burst one and I'm done as
you can see because it gave us a hundred
threads to run not just one one set of
eight threads be very careful using this
feature because it changes the settings
on your entire JVM not something you
want to do so so quickly without
thinking also if you're using or one
other thing I heard from clients quite
often is they'd be using a third-party
container don't mess with this when
you're dealing with third-party
containers third-party containers are
mostly intended so they can take away
the threading from us so this is kind of
going contrary to that be careful about
it you can also configure this
programmatically as well how do you
change this programmatically if you want
to change this programmatically what you
can do in here is you can create your
own for join pool so for join pull let's
say over here pool is equal to new for
join pool are 50 let's say and then I'm
gonna say pool Dart
shutdown this is one of my things
usually I want to shut it down as soon
as I create it and this is going to
require that you handle exception we'll
come back to that in just a minute and
then I'm going to say over here a pool a
dart await termination and then I'm
gonna say let's say 10 comma time a time
unit a dart let's say seconds so I'm
gonna give it 10 seconds for it to
finish up all this now within does what
I could do is I could say pool darts
submit and within the submit I could
simply go ahead and say
that I want to perform that operation
right there in parallel of course but
notice the call to this parallel comes
from within this right here and as a
result because I'm calling this in a
four join pole this is going to run in
the pool which is native to that
particular call and it's going to do
that of course this won't work at the
moment it complains that I have to deal
with inter interrupted exception there's
a game we always play with Java right
you write some code in Java says you
will handle the exception and you as a
programmer show who's in power by
putting throws exception right so this
is very awesome so basically in this
case you kind of say all right I'm
dealing with that so in this case what's
the thread notice it's no longer the
common pool it's a fourth line pool we
just created right off here that's what
we are really doing at this point so
that is one way you can programmatically
control what is written ice about this
is you can have different computations
executing at any given time and you can
tailor the needs of those computations
separately without one global setting in
your application so that can work really
well for you depending on what you're
trying to do well let's go a little
further to talk about some ways in which
we should really be very careful again
because we can really mess up things if
you're not very careful so let's switch
gears to a little bit of a slightly
different problem here I want to be able
to run things faster but when parallel
may not be really a good thing to do so
to understand this I mentioned that you
have to be very careful the number of
threads to illustrate this point allow
me to bring in a little code here and
I'm gonna go ahead and bring in a
concurrent example right here and in
this case I'll go ahead and say in this
let's say this is a computation that's
what I want to call as and I'm going to
bring in this little computation code
and what I'm doing is a pure example
trivial example when you call compute it
opens up to four loops and performs
square root operation on it and then of
course out here I totally sum find the
sum of all the square root of all those
values in short it's a computation
intensive operation I'm just throwing
this through these loops and running
them in in in in sequence as you can see
right here this is pretty much a
sequential code how much time is it
gonna run to do this
work so I'm gonna just run the
sequential code and I don't know it's
going to take maybe a few seconds to run
I don't want it to be too long and it's
going to come back and give us a result
with the very end of this so you can see
that it's actually taking a little bit
time to execute it but I want to make
this faster I want to run this faster I
forgot to say time on this I apologize
so I'm gonna run this now but I would I
don't want to wait for it but when it is
done it's gonna tell us how much time
it's gonna take in the meantime let's
run this in parallel so I'm gonna go
ahead and say dart parallel right here
and what is it going to do now it's
gonna run in parallel sure but how many
threads as many threads as a number of
course on my machine because I'm using
the default settings so we are hoping
this will be faster than the sequential
run which actually took about 13 seconds
that's what it says right about 13 14
seconds just keep that in mind
so I want to go ahead and run this in
parallel now and see how much time it's
going to take so now that it's parallel
multiple threads are gonna run this hey
notice that we finished in about three
seconds instead of 13 seconds I would
say that's pretty decent because we made
it faster but now I'm going to be that
that person who is jealous I'm sorry I
want more of this so I'm gonna run this
config with a thousand threads why not I
have the power to create threads so I'm
gonna go ahead and create those threads
after all we went from three seconds and
what does it say in this case of course
I forgot to do the time again so we'll
do the time on this and what does it
take to run this after three seconds
that it took earlier it took about four
seconds as you can see so it actually
did not take less time it in this case
actually took more time
I've actually worked on projects where a
sequential code takes an hour to run the
parallel code did not finish even after
we came back from lunch and we really
had a very long lunch actually so the
point really is you could really mess up
things we're not careful with it so
there's a reason for controlling that
one other thing I want to quickly
mention here is we really have to
understand that certain things may not
go in our favor with parallel so to
understand this let's take a slightly
different example but before I go into
the example let's kind of talk a little
broadly
couple of things you need to ask before
you turn your code into parallel the
first question is do you have a lot of
data to really process many parallel is
an answer in that case do you have a lot
of work to do
maybe parallel is an answer in that case
imagine you have two children at your
home and you're running out of sugar
so you yell out saying hey I'm running
out of sugar go get some sugar from the
neighbor one kid goes out to get that
you know get into the bicycle so he can
he or she can write to the neighbor the
other kid jumps the fence do you know
which kid is going to get you the sugar
really quickly the one that jumps the
fence obviously because the neighbor is
just a neighbor right across from the
fence you don't have to go through a lot
of effort to get there jumping the fence
quick on the other hand you say I really
need a bag of rice go to the store or
five kilometres away and get it well one
kid jumps the fence the other one takes
the bicycle the one that jumps of the
fence is probably going to end up in
jail
so you don't want that kind of behavior
at the point so you really have to ask
the question how much distance I'm a
covering how much data am i processing
what is the intensity of the task do
always benchmarking oh by the way I
never trust benchmark anybody else
creates it's gotta be something I do for
my project with the relevant information
on my teams and that's one of the
reasons why I never trust anybody is
much more a benchmark including my own
when I switched between project status
so you have to really try it out and see
if it makes sense but having said that
let me give you one other example I want
to quickly point out here I want to take
an example here of let's say working
with a collection of people so in this
example what I want to do here is I want
to take this create people let's say
create let's say create people list over
here and I got a bunch of people on my
hand and with different names different
agender and different age but what I
want to do here is the following I want
to say in here given the stree a people
collection so we'll say create people I
want to say dart stream then I'll say
filter given a person get me the person
dart let's say get age is greater than
25 well I want somebody who is older
25 then I'll say filter person and I
would say person dot get gender and I'll
say in this case gender dart female and
then I would say dot map given a person
give me the person that get name name of
the person if you will and then finally
what I'm gonna do here is to say you
know maybe convert it to an uppercase so
let's go ahead and say string to
uppercase
so in this case of course what I have
done is I've taken the first person
older than 25 who is a female got the
name and transformed the first uppercase
but then I say in the end find first
and I'm wondering Who am I going to find
really and then of course our else will
say no one found so I want to just print
this and see what the output looks like
in this particular case so let's output
this right here and see what we get out
of this so in this example of course I'm
gonna round this little code and it says
Paulo
well sure it's Paulo because if you go
through the list it's the ordered
collection and Serra and sarra are not
older than 25 Bob it's not tada Paulo is
the first person older than 25 and he's
also female so we got that but the
question is what we did we put in I'll
come back to that in just a minute
but let's go back and run the score
several several times just real quick
here let's go ahead and say run dart SH
just once
it says Paulo but I want to run this
many many many times so here we go and
I'm gonna keep running this you know
several several times so I could keep
going in a number of times right here
and I say run this all and it's going to
be repeatedly Paulo isn't it doesn't
matter how many times I run I know
running this and it's not a proof of it
but just trust me it's gonna be the same
as many times as you run it but on the
other hand there is also a function
called find any
what does find any say I don't care who
it is just find one of them well find
any will give us one of them if it's
available so in this case when I go back
and run this what am I gonna get it
turns out it's Paulo - not fair why
because it's sequential II executing and
it because it's sequential the first one
is always there any as well right okay
that's kind of easy to see but let's get
back out now put it back and find first
again but in this case I'm gonna turn
this in
dark parallel well what's going to
happen now remember this is an ordered
collection and remember we talked about
certain methods being ordered in the
past remember that we talked about for
each ordered
well fine first is one of those guys it
doesn't have the name ordered in it but
it's going to impose ordering in the
very end so you're going to do this in
parallel awesome but unfortunately
though you're gonna do this in parallel
which is great but what are you gonna
get you're gonna get Paulo all the time
you better do right because you want the
first one the ordering is important to
you let's see if that's true let's go
ahead and run this and see it's Paulo
every single time again that's not a
proof just because I ran it 70 times it
doesn't mean it's correct again trust me
on that search on this but what if I
turn this into a find any on the other
hand and run this code now
well this time notice it is still Paulo
but I'm hoping it'll be different
sometime okay it's not in my favor this
is that this is the this is the peril of
a demo isn't it but hopefully at some
point you will run this enough number of
times and okay so again trust me on this
one too right so what what is it
oh it's positive when the answer here
you're saying well okay you know there
are no other feet
I blame it on you okay thank you so
let's make it as you know let's say Oh
Jill what is Jill Jill my friend let's
just make Jill older okay so there we go
so all right try this one more time this
time I didn't even notice about good
good cats there you go thank you all
right yeah thank you for for debugging
that my faith in paid programming was
just restored all right so right there
we got the result the case in point
right but of course if I go back to this
and say this is going to be fine the
first on the other hand you will it
better be polished trying this time
right so in this case of course it'll be
the exact same value every single time
you're with me so far but there is one
thing I love about streams and that is
laziness well let's talk about that real
quick let's go ahead and remove this
parallel for a minute let's just do fine
first if you will and I want to know who
all I'm gonna talk to here's our Jill
who just got older but we have Paula who
is older than 30 to 25 but who am I
going to talk to repeatedly if I go to
the person class right here in the gate
age I'm gonna print out right here I'm
gonna say name while sorry get aged up
and then plus name and then of course
I'm also going to come on name and I'm
also going to output in this case I
wanted the gender as well didn't I so
I'm going to go ahead and ask for that
to be printed right here too so I'll go
ahead and say this is going to be get
gender and print that information okay
that's great so far I'm doing two
sequential e as you can see in here so
I'm gonna go ahead and run this code and
the beauty I'm just gonna do it once so
I'm gonna run this code in sequence and
as you would expect it did not touch
anyone other than after Paula make sense
right because it's lazy it says I don't
need to run this fast I'm gonna just
process it Oh Sara Bob Paula today I got
my result I never have to talk to anyone
besides Paula
never touches Paul Jack Jack and Jill on
the other hand I'm gonna go in and say a
dot parallel right now now what's it
going to do it says whoa look at this
let's get the business we got data in
front of us to do work and it's gonna be
on fire isn't it and as a result what is
it result going to be in the very end
still Paula but it's not going to be
lazy like the way we thought it is and
notice a lot more work being done let me
summarize this in a slightly different
example let's say I was just hanging
around here and I was going around
what's your name sir Tom Thomas I let's
say I left my phone next to Thomas right
so here's what I could do I could say
excuse me is my phone next to you he
says no excuse me' in mephone x2 he says
no is my phone next to you
thank you he said yes and so how much
ever did I take three units how much
time did I take three units of time and
I got my phone after that but that
required a little bit more effort here's
something else I could do right I could
just say into this room saying folks do
do me a favor please
here's my phone next to you how much
time would it take for me to get the
result one unit of time how many people
did i disturb hundreds of people so the
good news I got the result faster the
bad news I bothered everyone good news I
don't care so that is the beauty of this
so that is the model here right the
model here is I don't mind throwing more
hardware at this problem with the hope
of getting the result faster hope that
was useful thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>