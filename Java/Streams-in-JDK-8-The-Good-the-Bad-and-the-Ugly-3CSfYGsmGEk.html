<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Streams in JDK 8: The Good, the Bad, and the Ugly | Coder Coacher - Coaching Coders</title><meta content="Streams in JDK 8: The Good, the Bad, and the Ugly - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Streams in JDK 8: The Good, the Bad, and the Ugly</b></h2><h5 class="post__date">2017-10-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/3CSfYGsmGEk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay right well good morning and welcome
after so it's really good to see so many
people here at half past eight in the
morning
bit of an early start I know last night
number of parties but what we can do
this morning is talk about streams in
JDK eight and we've kind of titled this
the good the bad and the ugly and the
idea of this presentation is really to
sort of help you learn from my mistakes
not Stuart's my mistakes and what we're
going to do is we can look at some
samples of streams code and really this
is kind of tracking some of my learning
process about streams and understanding
how you need to think differently
because as Java programmers we are very
much focused on imperative programming
we understand the idea of loops we
understand the idea of mutable state so
we put things in variables so if I ask
show of hands who here thinks they're a
Java programmer okay that's good we have
the right audience who here would
describe themselves as a functional
programmer yes you see there's only a
few people here and that's that's the
key thing here is that functional
programming is very different to
imperative programming and you do need
to think differently so we're going to
give you some examples of how to not do
things as well as how to do things and
really the sort of idea behind this
presentation came about because I wrote
a blog entry where I explained about how
I'd done some things with streams and
somebody didn't like my code and he kind
of criticized it and so we had a
discussion about that and so this is
kind of how we came about this
presentation so first I should introduce
so I'm Simon Ritter I work for is all
I'm I'm Stuart marks I work for Oracle
on the JDK core libraries yes so Stuart
obviously has had a lot to do with the
development of streams I haven't
okay so the first thing was was dealing
with exceptions because this actually is
something which can be quite tricky when
it comes to using screens as we will see
now the problem that I had was I was
trying to process some data that was
coming through like a sort of web
interface and so the idea is you've got
a very simple you know key value set
that you want to extract information
from so simple thing in few action is
validate key is 10 key is 22 key is 10
key is 33 so what I wanted was results
in the form of action and validate and
then key where I had a set of values 10
22 10 and 33 so the important thing is
that I could have duplicate values in
the set that I've got that would that
was actually quite a an important point
so of course the first thing I do is I
go to stack overflow and I say has
anybody faced this problem before and I
look around and I find that yes
somebody has produced a nice peat well a
piece of code which does this now we're
not going to talk about this because
this is obviously it's rather small and
it's actually not a very nice piece of
code even I would have to admit that
there's a lot of things in this code
that could be tidied up and improved so
we won't talk about that other than to
say that I've looked at that and I
thought to myself no I don't want to do
it that way I want to use streams so I
came up with this and the the thing that
I was really focused on which I
shouldn't have been was making this as
compact as possible so I want you to
squeeze us into literally three lines of
code so as you can see here I have come
up with Perl because it's rather dense
and it's not actually the best kind of
code
so there are three problems with this
and in fact I I came up with two
problems and then Stewart pointed out
there was a third problem associated
with this the three problems are that
this can return a null so that's you
know never a good idea because if you
return and now then you're gonna have to
test for the null when you get the
result and deal with it appropriately so
returning and I'll not a good idea
especially since we have an optional in
JDK 8
the second thing is that split this is
one that Stewart pointed out to me
recently split is called twice so we're
doing the same thing
calling split twice and that's very
inefficient so we need to resolve that
problem and then third thing is it
doesn't call the URL decode decode
method which is used in the original
code and the reason for that was because
I didn't want to have to deal with the
exception because the problem is that
decode throws a checked exception and if
you're using a stream and using the
stream API you can't throw an exception
out of the stream method so do you want
to just yeah a couple things on that so
so one is yeah so the original code had
this had this interesting thing and this
isn't particularly about streams but
it's it's it's about general code and as
we improve the code in general it
actually makes streams much much nicer
to deal with but in this particular case
the the original code accepted a null
and it had to test it and if it if the
input was null a returned null and and
it's like everybody does that and that's
that's sort of a strange thing to do if
you think about it because what you want
is a value which is a map from string to
string Kalista string and you want to
process those and so if you have this I
think it's a bad coding habit Trisha gee
wrote a blog post a few weeks ago at the
JetBrains
she has a blog series about code smells
where she talks about no and it turns
out the code base she was she was
working on every method said oh if I get
null return null and even if that didn't
make sense at all it was sort of a bad
habit that was propagated throughout the
code base and I think that's kind of
what's going on here because if you
think think about the context here
you're you have a URL and you want to
grab the arguments off the end of the
URL so if there are any arguments then
that you have a non-empty string if
there aren't any arguments then maybe
you should have an empty string but you
should never have null so where does
null come from right and then so if you
if you think about getting rid of nulls
you never return null should return an
empty map instead and then whatever
meets the processes it will process
every entry of the empty map which
we'll just do nothing so you just so
you'd really try to think about when you
really need to process null and when
it's just a bad habit of oh I better
check for null and return null oh and
then one quick thing here to the
original code had a regular expression
in the split command which actually
slows it down quite a bit because it's
all it's doing is matching a single
character so there's actually a fast
path in the split method it takes a
regular expression but if it says oh if
I'm splitting on a single character goes
through a completely different section
of code that bypasses all the expensive
regular expression processing so it goes
much faster good to know okay so then
obviously after a bit of discussion with
it Stewart I came up with a better
approach and so the idea here is to to
extract some of the code out into a
method here what we're going to do is
we're going to split the key and the
value and that way we can use the URL
decoded decode method and we can deal
with the exception but we have to do
that in the method so we have to somehow
deal with the exception the checked
exception in that method and so you know
it's it comes down to the design of the
streams API and I'm spoken to Brian
about this in the past about the digit
yes yeah brackets yeah yeah about you
know the way that you don't have the
ability to throw an exception out of a
stream because ideally what we'd like to
be able to do is have a stream and then
at some point something happens in a
lambo Xpression you throw an exception
and then that gets thrown out of the
whole stream but it just doesn't work
that way so what what we have to do is
we have to have a method and in this
case we have to do something in terms of
dealing with that exception so we call
the dqo method it could potentially
throw exception in this case we're going
to do a a warning from the logger and
we'll return null the other thing about
this is that it uses a JDK 9 enhancement
which is met map dot entry so map dot
entry will return you well a map entry
the nice thing about that is that you
don't have to use there's a kind of
class which is buried in was abstract
abstract map that simple immutable entry
yes abstract map dot simple immutable
entry as opposed to the class which we
should have which is called tuple and so
so we ended up with this where we
actually return a map taught entry and
we get one which is a string in a string
so so we extract out the code that needs
to deal with the exception into a
separate method and then in terms of
actually making our code nicer we end up
with this where obviously we made it a
little bit bigger but it's much easier
to read so now we have the idea we're
going to pause the query we we create a
stream based on splitting on the
ampersand and then we filter to ensure
that we don't get any non null or any
null objects so that's a simple way of
eliminating that problem of the null
obviously at that point because we're
calling objects dot require non null if
it's a null ill throw a null pointer
exception but that is at least a better
way of potentially dealing with it
because did you want to say anything
about that yeah oh yeah when you're
finished I'll go back to the previously
okay the opposite so we eliminate the
problem having null in terms of our
value then we call the map and we use
our split key value which is the one
that we've extracted out the the code
that deals with the exception then we
found filth of that to say if that
returns our null then we just ignore
anything because obviously that's not
the information we need so we can
eliminate that and then we use a collect
reduction so we're grouping by the key
and the value
and generating a list so it's a lot
clearer
Oh Nita lot tidier Vann the three lines
of code that I tried to write originally
so if I go back to the previous slide
okay yeah a couple comments on this so
so as Simon pointed out the the the
there's a there's a problem here because
there's a mismatch between AP is in the
jdk that throw checked exceptions and
using those api's in streams which
generally do not allow checked
exceptions and so the sad thing about
this is i went back and revisited this
this it's actually totally unnecessary
to have a checked exception in this case
but the the bug is actually missing
api's in the jdk so so if you dig into
this what's going on is so it's the URL
decode or decode method throws this
unsupported encoding exception that's
because you have to tell it what
encoding it uses and the way you tell it
what encoding to use is by giving it the
string name of an encoding and so
there's the possibility that the
encoding for that string name that you
give it is not present and that's
actually kind of an old-fashioned API
those those were introduced very early
on in the JDK much more recently a bunch
of the api's have been added there's a
there's a char set object and there are
char set constants like charset utf-8
and that's present everywhere so there's
this oh yeah somebody has points that
standard char sets yes so so so anyway
so the those are guaranteed to be
present in the JDK and so if you use a
char set object then you can often call
an API and pass the char set object and
it doesn't throw a checked exception
unfortunately there is no such overload
for URL decode or decode and also for
encode so really what we need to do is
fix up the api's and then this this
whole segment of the problem should go
away and then there's another problem
which which is I'm not entirely sure but
if we're decoding the URL the the actual
character encoding is I think officially
unspecified but it's usually utf-8 so
you might be able to get away if you had
a better API you might be able to get
away with specifying utf-8 here then you
avoid the whole checked exception and in
fact then you could refactor the whole
thing and and it would get much nicer
but we do not have that option today but
somebody remind me to file a bug for
that
okay one more thing oh and then also
there's this split method so so
basically that you essentially want key
value pairs and we split on equals and
so there's this issue here which is so
we use the the overload of split which
takes a limit argument so that means if
they're multiple equal sign in one
string we take the the first chunk to
the left of the first equal sign and
call that the key and the rest of the
string is the value even if it includes
equal signs but there's still a bug here
which is if the chunk we get has no
equal sign this will return an array of
length one and actually we'll throw up
array index out of bounds exception so
so anyway so there's there's a lot of
stuff going on in this code you have to
think about but all right well but we
should move on yeah wise did you want to
talk about the second slide I think no
I'm sure he's going right okay so next
thing is imperative screams if we can
hold questions until the end ya know if
we keep questions till the end because
we got quite a lot to get through so we
don't were kind of pause too much
okay so imperative streams now this
comes back to what I was saying about
how as Java developers we tend to think
imperatively we think in terms of loops
and so when JDK 8 first came out I
decided to write some code that would
scan through all the Java Doc's and find
all places where you had a method to
returned a stream and all the places
where you had a method that would take
an argument which is a functional
interface and therefore I could use a
lambda expression because there was no
kind of sick sink list that was
available so I did that and I thought
right I'm gonna use streams to write
this code and one of the bits of code I
ended up with was where I want to count
how many new or how many class I'm sorry
how many methods there were which
returned a stream so I had a map of
classes two methods and so what I wanted
to be able to do is go through that and
count up how many there were so I came
up with this piece of code and I said
okay let's take out our map and then
we'll get the class from that and we'll
create a stream from that and then
each of those I need to do something so
what I want to do is I'm going to print
out the the method and then I want to
count if this is a new method so I
thought to myself okay so I know that
this could potentially be multi-threaded
so I'm going to use a long adder which
is specifically designed for this type
of situation where you got frequent
writes and infrequent reads so each
thread gets its own instance of the
variable you can update them
independently there's no contention
there locking and then when you need the
result it brings it all together so I
thought that's a really good thing to do
it's new and JDK 8 will use that so I
ended up with this very nice piece of
code where I said okay take the stream
do for each and then I'll take my method
name and then I printed out a check of
its new method and then I'll increment
it okay so I spoke to the steward about
this and he said ah well you see that's
not functional programming this is very
bad this is not functional programming
so I thought okay I'll go with and I'll
have another go at that so I thought
right
I don't need stating this in terms of
external state so what I'll do is I'll
make it a little bit more complicated
and I'll come up with the idea that I
create my stream and obviously I should
have shifted this out into a method but
I'll put it in here just to make it
easier to see on one slide and I'll say
take the method and then I'll have a
variable inside my lambda expression
which is new method is zero then I'll
print out the method and then I'll check
see if it's a new method if it is I'll
set a new method be one I mean I'll just
return a new method so I get a stream of
ones and zeros and I add those up and I
get a count of how many new methods
there are which do what I want so again
I showed this to Stuart he said well
yeah you see this is this is kind of a
bit more functional but it's not
functional because we've still got state
involved so even though we've taken the
state internally we're still modifying
state so strictly speaking I mean you
know as a function it would work because
you could put apply the same input and
get the same output no matter how many
times but there still be state being
modified so that's not the way to do it
so I thought okay I'll go well have
another go at this and so I came up with
a better way of doing it which is almost
functional but not quite so again we
take the stream and then we use this
this handy little method called peak
peak allows you to look at the elements
of the stream as they go past and so
long as you don't modify them you can
you can look at them and you can do
something like print them out so I could
print out the the method names as they
were getting passed and then I passed
that to map tint and no state involved
in terms of having a variable and I
thought right I'll use the conditional
operator and I'll say if it's a new
method return 1 otherwise return 0 so I
still get my stream of zeros and ones
and I sum those up and I get my result
and then Stewart pointed out well
actually there's a slightly better way
of doing that which is to use a filter
so rather than you know doing an if
statement inside a map to int why not
use a filter because I thought it takes
a predicate and a predicate is an if
statement so we can do it that way and
we end up with filter M goes to is new
method and then we pass it to count
rather than sum and everything works so
this is all very good so this looks I
think it's myself look this is
functional code we have done really well
here and then Stuart said no it is not
functional code he said
strictly speaking print line is side
effect and if you're being purely
functional you can't have side effects
so I'm gonna hand it over to Stuart - ok
all right so yeah that was quite a quite
an evolution there and I think that's
true and I think that I think peak using
peak for printing out logging is a fine
thing to do this is kind of a debugging
thing I guess if you want to actually
store the results somewhere you probably
should build them up in a data structure
using a collector or something like that
we have examples of that later on but I
just wanted to reflect on the the very
beginning of this I don't know if you
want to mind back to the to the first
slide of this
so you see that there's a lot of
evolution of the stream going on here
and that one okay
so Simon started off with four each and
the the problem with four each is that
it's it's the easiest stream function to
understand but it's actually probably
one of the least useful ones because I
think I don't want to harp on you too
much but I think Simon fell into this
trap which is there's all this there's
all this weird stuff well for each well
I know what that does so I'll start
writing with for each and the problem
with for each is that and immediately
leads you into side-effects and once
you've fallen into the trap of
side-effects then you really have to
think differently about how to extricate
yourself from that and so that's what
this exercise was about so I think we
have some more for each's coming up
later on in the presentation as well
yeah and that's kind of Stewart makes a
really good point because it's this
whole idea of thinking differently
because the way I looked at it was I
said okay so I've got these elements
coming through and then for each of
those I want to do something so
immediately I've got those two words in
there for each of those I want to do
something oh look there's a for each
method I'll use the for each method and
that's not the way to do it and the way
I kind of explain this when I talk to
people on other sort of lambdas and
streams stuff that I do it's like if you
think if you look at for each and you
think just I'll use for each stop and
think should I really be using that
because there are legitimate situations
where you can use for each but there are
many where you shouldn't and so using it
in a more functional way is the way to
do that so the moment you think about
using for each stop and kind of think
about it very carefully to decide
whether that actually makes sense
okay so right mixing internal and
external iteration so again you see this
is the problem being a Java programmer
and not a functional programmer so here
is the the back so what I wanted to do
was I had a set of data which was a
number of values for each day of the
year and what I wanted to do was to
group them into months so that I could
build a graph of each month and then
have a bar associated with each day so I
could see how much data there was for
that particular day so I went I needed
some we're grouping them by month and
then
having values for each day in that month
so I started off with a very simple
piece of code where I said for int I
equals 0 I less than 12 I plus plus good
Java code simple loop and then I thought
right so I've got a loop I'm going to
use a stream so I put a stream inside my
loop and I'll say the days of the month
for that month is the data that I've got
our critter stream I mean I've got a
filter it so that I say get the month
and check to see if that compares
against then of course in that case you
know it's starting from 0 versus
starting from 1 so we have to add 1 to I
in order to get the appropriate month
number this is where things get a little
bit complicated so we check to see where
it's the right month and then we say
filter that to only get the data for
that month and then we collect it using
a grouping by where we're getting the
day of the month and then the count
associated with that day of the month so
that generates what we need in terms of
the the map that we're creating now if
you look at that ok so that's a little
bit odd but it sort of you think to
yourself ok would that work and the
answer is no it won't for the simple
reason that we're using I plus 1 now
because we're in a stream we're using a
lambda expression and our expressions
can only reference variables from the
surrounding scope if they are
effectively final now because we're
adding 1 to I it is not effectively
final and also because I is changing I
is not effectively final so we can't do
that so I looked at that and I thought
to myself hmmm how can we solve this
problem I know I'll add one more line of
code I will set a new variable called I
and then I'll change the the loop
variable name and I'll set I to BM so
then I is effectively final and I can
get away with that you can notice that
you know I'm not really a functional
programmer here so clearly at this point
I is now effectively final and we can
actually get away with adding 1 to that
in that case so ok that's really not the
right way to do it so what we should be
doing is using internal iteration for
both the the weight what both of the
loops that we
doing here so why don't we use streams
for iteration and so what I could do is
I could do okay
let's create a stream from int stream
where we're going from 0 to 12 so that
gives us a stream in the same way that
we have our loop that goes from 0 to 12
will create a stream of intz which goes
from 0 to 12 and then we'll use for each
aha
are we using the right thing here
immediately we have to ask ourselves
probably not and then what we do is we
say okay take I and then we'll say days
a month I is and then we go back to our
stream for the data so now we're looping
through the data internally and then we
do the same thing we had before so we
have filter month the R of I plus 1
collect same collector so in this case I
is a valid reference so we can get away
with that so this gives us some you know
we're using iterate internal iteration
for both loops but it's still pretty
ugly code so do you want to meet me go
all the way through to the end and then
so then Stewart had to look at this and
you guys mmm okay there's there some
better things that we can do here the
first of those is to eliminate for each
so this is the thing we don't want to be
using for each in a situation like this
so what we actually do is we say okay
we're going to create a map going from
month to a map of integers and Long's so
this is the the second the internal map
is the day of the month and the count
associated with that month and we'll
create results so we take our data and
we stream it okay and what we're going
to do is we had a map to the date okay
that's all good so we get the date for
that particular piece of data and then
we're going to collect but the collect
changes so we use a more a better way of
doing the collector so we said collect
we want to group by and in this case
we're gonna use own date/time get month
so we get the month associated with that
so to group by month and then we're
going to group by the day of the month
and then we're going to count so this
gives us exactly what we want in terms
of a map which maps from the month to
the day of the month and account
associated with that month
and so that is obviously the better
stream solution so Jonah okay so this I
get I'll tell you in a moment right but
let's look at this code for a moment I
think this is the the nested grouping by
I think throws a lot of people and it's
kind of hard to come out with with a
nested grouping by you know right off
the top of your head but yeah I I think
the way to think about it is to build
things up incrementally so why don't we
go back to the to the very first slide
that hasn't has the array
okay yeah that's a fine one because
that's yeah that's logically the same
thing it's just yeah this is the first
the first code that that works because
of the effectively final issue right so
so what's not on this slide is the
Declaration of this this array that's
being assigned to and so if you if you
if you look at this carefully it's it's
an array that has to go that has that
has to have twelve twelve elements and
there's it's I think the array is
actually miss named but it's basically
an array element for each month so the
the the indexes into the array are 0
through 11 because that's what we're
getting out of the for loop and we're
assigning something to each array
element based on the month and so that
should think about this a little bit so
if you have an O and then the element
type of the array is whatever you get
back from that stream and so what we're
doing is we're collecting using grouping
by and so the result is each element is
a map right so that's that's our that's
our count from the day of the month to
sorry that's a map from the day of the
month to count the count and so so in
the inner in in so that's already you
see the inner grouping by there so so
let's just say we're working on one
month right so what this does is it goes
through for that month for each day of
the month uses the day of the month as
as the grouping key and then the count
ends up in the value so that's that's
where you get that that turns into your
inner grouping by but we wrap something
around it which is a for loop which is
for each month but then the result is
this array of entries per month which is
this map and so if you think about an
array this in a different way
this is an array of maps which first of
all mixing arrays and generics is
usually pretty bad and I think you
didn't include the declaration in the
array because it's really ugly because
because you have to you have to use
unsafe casts in order to allocate it but
but really this this should start to
tell you that maybe an array is not the
right data structure for this because if
you have an array going from 0 to 11
where each each array index represents a
month and then you have a value stored
in that array that's actually a map it's
a map from a month to some value and so
that's where we get our outer map and so
instead of looping over the array and
actually kind of another thing that this
does this is imagine this is very large
data set this actually loops over the
entire data set 12 times and so what
what we really want to do is take one
pass over the array and say ah ok which
month does this belong in and classify
it now that we have some piece of data
for this month say what day of the month
is this and so we're classifying it
again and then with that item add 1 to
that count so we're doing these two
levels of classification first by month
at first bite and then second by day of
the month and that's where we get our
two grouping buys so that the so if you
change the data structure from an array
to a map and then you can say oh we're
classifying by months and whenever
you're classifying by some value that
turns into a grouping by that's where
the outermost grouping by comes from and
so why don't you why don't we wind back
to the to the last slide there and you
can you can see that
so so I think this what's what's you
understand see once you've you know
bought into the idea of grouping by as
classifying things into a map then here
we have you know you see the first
grouping by is by month second grouping
by is by day of month and then the count
is the third thing so you get this yes I
mean it's a little complicated but it's
this nested map structure but it's much
nicer than having an array of maps I'll
tell you that and the other nice thing
is that if you remember the previous
slides we well what wasn't on the slide
was the initial allocation of the array
and then the what was in the
intermediate code was assignments to
individual array elements and so again
back to side effects inside of for each
right so if we continue in that theme we
want to we want to we want to avoid side
effects if possible and say okay how can
we construct a value that has the right
properties we want and so that's what
collecting does so we have all of our
stream elements they run through this
collector that does this nested
classification and it builds up this
two-level map and that's the result of
our method so no side effects in here
good okay so the next one is one of the
things that we did in a hands-on lab so
Stuart and I have been the past of and
today yesterday I've run hands-on labs
for streams where people get exercises
that they can work through and they can
see how they work and so one of those
that I ran last year I think it was was
a simple exercise the idea was you had
to concatenate the first character of
each string in a list to generate a new
string so the input was alpha Bravo
Charlie Delta echo Foxtrot so what we
were looking for was a way of getting
ABCDEF okay and the answer to that is
not to use streams it actually uses the
for each method on the iterable iterable
interface so what we do is we create a
string builder and then we say input dot
for each and this is a legitimate user
for each and we say append the character
at zero to ours
Miller yes and then the result is simply
to extract the string from the
stringbuilder
three lines of code does exactly what it
should do and it works perfectly so the
the thing that happened was I was doing
this course and somebody was asking a
question they said well okay so that
that uses that could we do it with
streams and I said well yes I suppose we
could do it with streams let's do it
this way so a correct result where we
take their input we take the stream we
map our used substring 0 1 for this one
so we mapped to the first character in
the string and then we reduce it so
we'll use a reduction the reduction is
where we take an initial value which is
an empty string and then we use an
accumulator which says take the the
partial result a and the next element in
the stream be E and apply some
accumulation to those so in this case
we're just doing string concatenation so
looked at that and it was like okay well
that doesn't solve the problem but it
doesn't do it in a very nice way because
even I can see that we're doing string
concatenation there so there's a lot of
intermediate objects being created and
we'll have a situation where if this was
a large data set
it'd be very inefficient certainly
compared to the previous one so then the
question was well could we do it with a
reduction using a string builder so
rather than you know using a string
concatenation operation let's use a
string builder so I thought right let's
see if we can do that and I came up with
a piece of code to do that kind of
interesting so we create a new string
builder and then we say take the input
stream and then we'll map it to our
substring and then we'll reduce it but
this time we'll use our string builder
in the reduction and we'll say that the
accumulator is to append B and then
returned that as a string so that
creates a new puncture result by pending
B to our string so then we the results
because it's an optional we can't need
to return what the value of the option
is so who thinks that would work okay
yes good well I'm obviously not going to
ask that question if it did work am i
okay so that that fails okay anybody
want to guess what the actual result is
nope second not a different order of
letters now actually what you get is b c
d e f the reason for that is that if you
look at the reduce there you've got a
and b and i've conveniently ignored a
now a is the partial result and when you
first start processing the stream the
first partial result is the first
element in that stream so if you ignore
the first partial result then you don't
get a in your straight in your stream
you don't get the what you need so I
thought to myself I'm not going to be
defeated by this there is a way to do
this using a string builder and so I
came up with this so I said okay let's
be sneaky about this let's say if a
which is our partial result has a length
of 1 that means it's the first element
because it's only a 1 character then
we'll append a to our string builder
otherwise we ignore that and we simply
return there speed append B to string
great and that actually gives you the
right result clearly that is probably
not the best approach
so then we kind of discussed this
further in the class and we said ok well
rather than using an explicit reduction
let's use a form of reduction which is a
collection ok now you can create your
own collector so what we could do is we
could say let's collect and then we'll
say collector dot off and we'll create a
new collector and the way you create
collectors you need to provide a number
of components if you like to the
collector so the first of those is the
supplier what are we going to collect
into so we'll say in this case it's a
stringbuilder so we want to use
moving on to generate a new string
builder so we use the the constructor
reference that's what I'm looking for
then you need an accumulator so sames
maybe we're doing a reduction so we need
an accumulator and in this case we want
to append the string to the string
builder great then third arguments a
little bit odd because you need a
combiner and a combiner in this case is
the same as the accumulator the reason
for having a combiner and an accumulator
is that this potentially could be split
into multiple threads so each thread
will
use the accumulator to generate its
particular result and then the combiner
is used to combine the results of each
thread into a single result for the
collection so they could potentially be
different but in this case they're
they're the same and then you need a
finisher which is how you generate the
result from the the work that you've
been doing and in this case we're just
calling the to string on that now that
obviously works and is fine but there is
actually a much simpler way of doing
this which is just use collectors
joining so use the existing collector
and in fact if you look at the source
code for collectors joining what you'll
find is it's exactly the same as the
previous slide so I ended up doing the
same thing in in essence so okay so can
you wind back to the beginning of this
scenario just a couple brief comments on
this okay so the the segment of code at
the bottom is correct as as Simon
observed but it is quite inefficient
because this is this is this the string
concatenation anti-pattern and so the
problem is that when you reduce this way
the intermediate result gets copied
multiple times because it's producing
strings every time and so if you have n
the strings input that are being
concatenated this way this turns into an
order and squared problem and so this is
a very very expensive way of of
concatenating strings so that's why we
added the the joining method because
this is a common thing and we don't want
people to have to write expensive
algorithms like this okay
once you go to the to the really
complicated one couple Oh actually yeah
that so that one yeah I'll just
reiterate here Simon observed that if
you have a reduction function that
doesn't use one of its arguments it's
very probably wrong and and and actually
but what what you were trying to do
there which which I've also seen before
in other code
is that well the thing that leads you to
not use one of the arguments is that
you're doing side effects in it okay
right and so again this elimination of
side effect or avoidance of side effects
is something that we need to keep an eye
on okay so one one more slide here so so
another one one point about the
reduction function is that it must be
associative and when we get to
parallelism that'll be it that'll be an
issue but don't have time to go into a
full explanation of whether something is
associative but there are a lot of
things that are and if you have
something that's slightly complex it
actually moves you to go through a proof
of of whether it's associative and if
you have side effects in your reduction
function that proof becomes extremely
difficult if not impossible so once
again side effects are are to be avoided
okay why don't we move on to the next
scenario okay yeah I think we're
probably not gonna get through
everything in the end okay so we'll just
do some quick performance examples so
one is extremely reuse good or bad so
we've got a stream here of intz from 1
to 10 print those out so why don't we
reuse it and do you know make life
efficient well reuse that anybody think
that would work again I'm asking a
question which you're probably not going
to be so the answer is no because that
will throw an illegal state exception
because the stream has already already
been operated on or closed so you can
only use the stream once that's the
important thing about that second one
which is better and why so we've got
point stream and then we're doing a
filter map and well for each and so
we're using an explicit lambda
expression here to say that we want to
get is this point in view invert the
point and then print it out same
effective piece of code is functionally
the same stream filter but we this time
we're using the method reference rather
than the lambda expression so who thinks
the top one is more efficient okay who
thinks the bottom one is more efficient
okay who thinks they're the same
ha okay so the answer is that the bottom
one is slightly more efficient and the
reason for that actually if you want to
learn more about that you can come to my
session this afternoon what I'm talking
about lambdas is explicitly but the the
key point is that when a lambda gets
compiled it gets compiled in the the
body of the lambda expression needs to
be put into a method that's associated
with the the place where it's used and
so if we have already a method reference
then you don't need to put it into
another method reference or another
method so it saves a level of
indirection if you know in essence so
that's why it's a little bit more
slightly better in terms of performance
and then multi sorts okay so this is the
bad way of doing things so we what we're
looking is we've got some patience we've
got some information about them and so
we're saying okay if this is valid
record then we want sort by medication
then we want to talk by physical
physician and we sort want to sort by
name so we do it in that sense the
reality is that that would actually be
much better if we do it using then
comparing so we do the same thing in
effect so we're still comparing based on
but we have to reverse the order as well
name physician medication so do you want
to say parallel streams okay let's just
talk about that briefly so parallel
streams are faster surely because we're
doing things in parallel we must get a
better faster result unfortunately it's
not guaranteed and the reason for that
is that a parallel stream you can
guarantee that there's always going to
be more work involved because you've got
the fork/join framework that's used
underneath and what you have to set up
the framework you have to create the
jobs that are associated with the queues
for those threads you have to do all the
work and then you have to collect the
results at the end so it's definitely
gonna be more work it might happen or
might complete more quickly a couple of
important facts about parallel streams
are the fact that they use the common
fork/join pool so there's a fork/join
pool that's created when the JVM starts
up and they will all you in terms of
parallel streams they will always use
the fork/join pool in terms of the
number of CPUs that that uses it
defaults to the number of cores or CPUs
that
reported by the operating system some
people have said it's twice that number
some people say it's that another plus
one if you look at the source code it is
actually the number of CPUs reported by
the operating system one point that's
interesting about that is if you're
using JDK 8 I'm not sure if this is
being back ported but if you're using
JDK 8 that's not see group aware which
means if you're using a docker container
and you run your JVM within that docker
container when it sets up the full joint
pool and this is the same for the memory
that it uses for the heap as well it's
going to get the results for the whole
machine not for the container JDK 9 has
had some changes so JDK 9 on Linux is
now container aware okay so the last
last example very quickly because we've
got about two minutes nesting parallel
streams this is a really bad idea
because we're using the same fork/join
pool which means that although we have
separate queues so we don't get any
corruption of data we're trying to use
the same set of threads to do the nested
parallel stream and you end up with
effectively worst performance because
you're trying to reuse those threads but
so rather than having separate sets of
threads associated with the different
parallel streams it's going to be worse
in case of in the case of performance
there is a way around this
which is you create your own fork/join
pool so you can actually create for
joint tasks using a custom pool of how
many threads you want and then you
submit your parallel stream task to that
and that will use a separate set of
threads so you can potentially get
better performance but you had something
to say about that can you yeah a couple
things about this technique here so so
one is if you find yourself wanting to
use your own fork/join pool I think if
you think very carefully about it the
first is that this is really an
implementation specific behavior which
is that if you submit a task to a
fork/join pool any streams processing
that's that's done within that task will
will be executed in the same fork/join
pool so that's that's how this works but
that's not guaranteed by the spec that's
just how the implementation works today
certainly I mean for all of JDK agents
worked that way and it's at this point
it's not going to change but it might
change in the future release the second
thing is it's like well you might you
might think okay well I'm gonna want to
control this so I'm going to create my
own fork/join pool but you should be
very careful because if you start
creating fork/join pools all over your
code and they have hard-coded constants
in here you know somebody's gonna run
this on a 24 core machine and saying why
am I only gonna get 4x speed up so or
somebody runs it on a few core machines
and there are thread contention going on
because everybody's created his own
fork/join pool each of which thinks it
owns the whole machine or container or
whatever so I mean this this is a valid
technique if you're experimenting and if
you're very very careful about how you
deploy it but it's something too many
things to be careful about here okay so
so that is basically it
so in conclusion streams are very
powerful but with great power comes
great responsibility and the important
thing that hopefully you've got from
this is trying not to think imperatively
try not to think in terms of loops
because whenever you think of for each
you need to step back and say is that
the way that you should do it and as
Stewart said several times during the
presentation side-effects are the things
to be avoided if you can avoid those at
all costs then then do so part of this
the power of streams is the clarity of
the code don't be tempted like I was to
go and try and squash everything into
the smallest possible number of lines
make it readable make it understandable
by other people and as we just explained
parallel doesn't necessarily mean faster
so I think that that's you know you've
got a couple of key key takeaway if you
find yourself writing for each with side
effects look at collectors so thank you
very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>