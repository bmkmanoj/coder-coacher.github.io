<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Richard Bair on OpenJFX and Gradle | Coder Coacher - Coaching Coders</title><meta content="Richard Bair on OpenJFX and Gradle - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Richard Bair on OpenJFX and Gradle</b></h2><h5 class="post__date">2013-05-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aGOFxvGkKqM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright so welcome everybody to the
Silicon Valley javafx user group so many
of you are here for your first time okay
to new members everyone else are
veterans at them eating good pizza so we
meet approximately once a month although
most recently it's been about by
bimonthly on javafx topics I'll give
rich the stage in a sec he's going to
talk about open jf x which is the open
sourcing of the JavaFX to code line and
a little bit about what they're doing
with their Gradle builds they've been
internally converting over everything to
use Gradle and have some good experience
with doing a large project in Gradle and
some of the some of the interesting
stuff they hit so if you're committed
then this is all great stuff because
you're gonna have to deal with it quite
soon a little bit about our sponsors for
the group so this is an opportunity this
is not projecting once this is
projecting people in the room here we'll
see what's online so Oracle provides the
venue and also the food for the evening
ly node provides the hosting for our
website and some other related
open-source javafx projects we broadcast
the live streams on Ustream and also
lube event although not recently that's
more for archival purposes Jay frogs
been helping us out with meetup fees and
then we get a bunch of book sponsorships
yeah let's refine memory
so book sponsorships from a presser
Riley Manning Pearson other folks and
also JetBrains your setup and um yeah
yeah set it back to mirror and also JEP
reigns is one of our sponsors so one of
the attendees of the room here will be
getting a IntelliJ license at the end of
the session so will hold a drawing one
lucky attendee oh yeah as of the most
recent patch of IntelliJ they now have
first class javafx support so we were
very happy apparently we must have
something to do with it because we're at
JavaFX user group and we give out
intelligent licenses they probably
figured it was embarrassing to give all
the JavaFX guys ontology licenses and
not have good built-in support would
seem builder and everything mixed in
okay and there's the website for the
group for those of you watching live we
have a chat window open we're only going
to be monitoring the chat on the Silicon
Valley javafx user group even though
we're broadcasting to both the jug
channel and also the night hacking
channel and feel free to ask questions
or comments and we'll hit rich up at
appropriate times or towards the ends
with what the online questions are
probably just about any time okay so as
stuff comes in well yeah let you know
any good heckling will fill you in yeah
but you have to do it in character yeah
I'll let all that keep do the
impressions alright so floor is all
yours rich alright well I should I
should have introduced to riches all
those of you don't know so rich is
JavaFX chief architect Java client java
client chief architect works for Oracle
and if you've been on the open JFX
mailing lists or been involved with
JavaFX over the years he's he's been at
the center of all the interesting
architectural change which is a papillon
the platform all right salyers Richard
okay thank you I'm going to bring up a
couple I guess important websites about
the project just kind of
show a little bit before I get I've got
some slides to talk about the building
test but I'm going to start off just
talking about the project in general the
open source project and so you kind of
get your feet wet in terms of some of
the main websites and things and so you
kind of know how to follow along as to
what's going on in the project so this
is our main project page and or at least
it's our home on openjdk we don't have a
whole lot of stuff there for the most
part we just redirect to the wiki
because the wiki is a lot easier for us
to update and maintain then this web
pages so this is the if you just go to
OpenJDK java.net and it has all the
different openjdk projects and open JFX
is one of those projects you can see it
here on the list small text on the side
it's one one of the many OpenJDK
projects being a part of OpenJDK we have
all the same governance bylaws structure
and so forth is the rest of the JDK so
on the OpenJDK page here it has a list
of some things on the side that might be
interesting to you one of which would be
contributing so if you go to
contributing you'll see that there's
some text here on how to become a
contributor basically what it is is that
there's an Oracle contributor agreement
you have to sign ascend in which gives
us you know joint copyright on the
contributions which is pretty common
these days and most large open source
projects run by corporate next step is
just you know find something interesting
to to work on get on to the right
mailing list submit patches and so on so
forth so I'll show you some of the other
links but this one just opened JDK
java.net / contribute has the
information on how to get started let me
go back to the main project page this is
the main resource I'd say right here is
the wiki which is pretty nice we just
recently got it in the
last three or four weeks maybe maybe two
or three weeks its public now and the
openjdk has pretty strict definition of
different roles of contribution to the
project there are those who can
contribute source code which is the
hardest level of contribution to get to
and it requires showing some you know
sustained investment or involvement in
the project one of the easier ones to
get is the author and you have to be an
author in order to edit the wiki it's
not that hard a couple weeks of you know
good patches that you send in to update
the wiki or articles or even just being
really well known in the community was
good enough to get authorship in the
project in which case you'd be able to
come into the wiki and edit it so
there's a but there's a few things that
we've got on the wiki it's is still
pretty fledgling I'd say um like really
pretty fledgling some of the sort of
things that we want to put on here in
the future for example we've got
information on some of the different
features for example the tree table
views a new API is added in Java 8 and
so it's got you know document 8 user
experience documentation for example
that shows you know screenshots or
mock-ups of what the component should
look like how it should work how it's
designed and so forth so our user
experience designer is going to be
putting all the different UI controls
design documents up here on the wiki for
example so that you know people in the
community can see how the thing was
designed and and if you want to help
contribute or work on different parts of
the components there are things that are
done that are defined in the spec for
example that we're never implemented
because of time or resources and so
you'd be able to come and and you know
contribute those sort of fixes and and
so forth so anyway this brief look at
the wiki probably the most important
thing when getting started is the
building open JFX wiki page which is
reasonably up-to-date and right now the
main way that we build is with ant
and we're migrating to Gradle so at the
present time you can build with either
and in the you know a few weeks time
hopefully we'll be able to work our way
off of ant will be on Grail full time so
there's it's reasonably comprehensive
page that has a lot of information both
in terms of how to build the thing and
how to run the builds that you've
produced and so forth so this is a good
resource that's out there the next I
guess there's there's two more three
more I guess these are all pretty
critical links the mailing list is just
a OpenJDK mailing list called open GFX
dev we have just the one mailing list at
the moment and will branch out and have
some more mailing lists when the traffic
becomes such that we need to but at the
moment it is working really well I think
having the one mailing list so we have
virtually all the technical discussion
either in the JIRA issues or on the
mailing list and the mailing list is a
great place to come if you're interested
in actual development of JavaFX if you
have questions about how to use it the
best place to go is typically the forums
down here the otn forums and there's
some really great people in the
community who answer all the questions
usually better than I could on the
forums and so it's you know you can
subscribe to it and get mail whenever
you know comments questions and so forth
come through or you can just go browse
and put in your questions whatever you
want but the town forms are really great
resource so that's more of a place to go
if you're using Java effects and you
have questions how to use it open JFX
dev is where you go if you're interested
in actually developing on the platform
and then our bug database now our bug
database is i'd say maybe a little bit
annoying because you have to have a
login in order to get into it but
anybody can get a login you just go and
get your information in register and in
you go and the it's a jira instance so
if you're familiar with using JIRA you
can find you
way around our bug system and find out
you know everything that we've got so
anyway that's the other most useful
place is JIRA we try to keep JIRA as the
one truth so the state of every bug
that's assigned to this release whenever
they're fixed the discussions that are
had links to the change sets and all
that sort of stuff we try to keep all
that in JIRA so that that's the one
place that's always accurate and then
you know on the wiki will have links to
JIRA issues and so on and so forth in
order to keep up with that so in a
nutshell out sort of where we're at on
the project Steve north over and I are
in the beginning stages of doing a
revamp in terms of how we structure the
open GFX project so that it's easier to
find your way around and contribute to
things and so that we are effectively
using all the open communication
mechanisms for all the stuff that we
talked about so that you know everybody
in the community is on an equal level
with the rest of us who are working on
the clothes bits now one of the biggest
things that we've been doing in order to
get everybody else on the same level is
obviously open sourcing code I want to
show you this this is because this is
like totally not intuitive we've got
this horrible horrible thing here okay
so openjdk has is all based on material
right so I'll go to go to RT so here's
here's what you get when you click on
the link and it takes you to our
mercurial repository it's basically
hopeless if you wanted to just browse
around it just lists the most recent
change sets and if you click on one of
those change sets it'll give you you
know a nice little diff in terms of what
happened but if you just want to browse
not so handy you have to click this
little manifest link up here it's
probably like a year and a half of using
the thing before it was pointed out to
me I just figured it didn't support the
functionality because I mean it's not
there right but yeah you got to click
the little manifest guy
and if you click the manifest guy then
you get a whole directory listing and it
shows you all the different bits and
pieces that are in that repository so we
have over the course the last year
really about a year year and a half been
open sourcing all the bits and pieces
and we're close to having everything
open source the last remaining bits are
some Java files related to media java
files related to WebKit or web view and
fonts this is just about it pretty much
everything else has been open sourced
the font engine that we use is the same
one that was used for java 2d it's
called t2k its proprietary and that's
why we couldn't open source it so we're
replacing it with an open source font
engine that we hope to be able to use
also in the final javafx bits so right
now if you're familiar with OpenJDK
there's the font engine that's shipped
with oracle jdk and jari which is this
proprietary t2k then there's the
open-source one which is only used by
OpenJDK builds but not by the closed jdk
builds so we want to avoid that in
javafx so we're hoping to be able to
just migrate off at ttk and just have
the open-source bits and use that for
closed source as well so we'll be doing
performance analysis and some other
things like that to make sure that we
can do it but we're pretty confident
that we'll be able to move off of that
so our goal is to is to completely
develop every last bit that goes into
the Java fex that we ship to be based on
open-source bits so there won't be any
of this you know half open a half closed
business ever again so most of this
stuff has been open source like I say
it's a it's actually a significant
amount of code I counted it up once put
it on my
log I don't remember what the line count
was biz fairly significant there's you
know there's a lot of code involved so
anyway I wanted to point out where you
can you can see what the different
pieces are that have been open source
we've open sourced all the what we call
glass which is our windowing layer so if
you come up and see this little guy
glass he's um if we were to drill into
this thing you'd see that there's a gtk
us lens Mac OS and windows versions of
glass that we've open sourced so far in
decorah is all the effects all the
hardware accelerated effects and so
forth and we have a bunch of different
implementations of it so there's a d 3d
version of decorah so that you can run
on Windows es tu for running on OpenGL
jsw is the basically java java software
implementation which is if you're
running on a platform that is basically
hopeless then you run that one on the
pixel shaders software loops we have an
sse version of the core as well so that
if you're running on pretty much any
piece of modern hardware then it'll use
the SSE intrinsic sin order to get some
better native performance for the effect
loops but it only uses those if it can't
use the 3d or es tu for some reason and
so forth so anyway that's what the core
is and then down at the bottom we have a
bunch of prism prism is the name that we
gave to our graphics library so this is
all the different backends for iOS Mac
when you know x11 egl FB and egl x11 or
for embedded systems arm devices d3d and
so forth so all the different backends
are based on are all it's all prism some
of them like prism mole we don't
actually ship but it's used at
development time in in order to do
performance testing so what it does is
it stubs out all the graphics drawing so
that when you're doing performance
analysis you can say well if graphics
were free well what would my frames per
second be well you can run with the null
pipeline as we call it and find out
so anyway there's there's a ton of stuff
in here obviously most of this stuff our
things that people wouldn't pay any
attention to unless they were packing on
the platform but that's the point of my
presentation tonight is to talk about
what it takes a hack on the platform so
one of my goals with javafx is that
somebody will be able to go from
irritated to patch in as little as a
half hour include yeah
and that would be very simple patch but
should be possible all right so we had a
question on the stream from broj in
chennai and he was wondering if the open
JFX bits get rolled into openjdk builds
yes on a nightly basis um no it's it's
once a week I believe they don't you
take so the way that we have it set up
is that we have several different
forests there's the master forest for
open jf x and then there's a graphics
forest and it controls forest media and
web web doesn't have its own any more
media still has its own but anyway so
there's there's several force once a
week the controls force to synced up the
master and once a week the graphics
force to synced up to master and they
sink and sinking sink and then
everybody's in sync so once a week you
get the master in sync with with what
everybody's been doing for the previous
week promoted builds are made from that
they're tested if it's good enough then
the promoted bits are sent to the
openjdk guys which they use to or with
the jdk guys in which they create the
bundles so actually I don't think with
openjdk the bits are moved over on
openjdk I think it's just for the actual
oracle jdk JRE bits where we co bundle
ok yeah so if you wanted to get the
latest open JFX you should download that
from one of the builds on the open JFX
site and then use it together with the
latest openjdk build yes yeah so I mean
the the easiest place to get um let's
see what's this thing call this called
jdk 8 java.net and so if you come here
and go to the jdk 8 snapshot release
accept the stupid light I mean the
license and then come in and say um you
know on my Mac so I'll download the JDK
it's going to give me a darn dmg I'm
going to open it up it's got an
installer I run the Installer it sticks
on my system and when it sticks it on my
system you will have build 87 of the jdk
plus javafx so you can if you just want
to run the latest java effects this is
the easiest way to get it the latest
promoted if you want to run the latest
and greatest then you'll have to clone a
repo do your own build take what you've
produced and combine that with a jdk of
your choice it could be OpenJDK or any
other doesn't matter cuz you could you
rip it off the huts and builds no
Hudson's not open okay yeah okay can't
get it off a Hudson yet so we're working
on this is the the bulk of my discussion
tonight was going to be on the build and
test system for java FEX we're working
on a lot of infrastructure work for both
jdk and javafx right now and one of
those things will be a place where you
can get regular continuous binaries so I
don't I don't know if in the final thing
Hudson itself will be sitting up there
but there will be some artifactory or
other binary repository available
that'll just have all the latest bits
and that'll be the most convenient way
to get it if you don't do it so the way
but that could be a long ways away still
it's a lot you know in corporations
things don't move as fast as they do
other places so that's what we're
working towards so the so I was saying
that my my goal is that you could go
from irritated to patch in a half hour
now if we're talking about like a patch
to Java Docs that I think that's a
that's a reasonable goal something that
you want to be able to do now there's a
couple big hurdles to get over in order
to make that work the first thing is um
well at least you need to be on
broadband because otherwise cloning the
repository is just going to take two day
long when all the WebKit sources are out
there but right now for me a fresh clone
is you'll maybe five minutes at the on
the worst side so it won't be that bad
it still fits in my 30 minute budget
doing a full build on my machine right
now the including web kit and gstreamer
and everything else is about
18 minutes most of that's WebKit and so
we're still sort of fit into that now if
what you're trying to do is just
contribute a patch then you don't have
to do a full build you just have to run
Java doc and in that case you could
probably produce the javadocs in about
two minutes so anyway so my goal is to
make it easy enough that you can do that
one of the other challenges is that
there's a bunch of prerequisites that
you have to have installed on your
system in order to build because of the
native code a native code so annoying
but on and because we've got gstreamer
and WebKit to build if you build those
you have further prerequisites for
example web kits based on cutie and so
you have to download and install QT
framework because these q make and other
things like that in order to build so
there's there's a bunch of extra stuff
that you have to download install if you
want to build literally everything so
one of my goals with the new build
system was to make it so that you
actually didn't have to download and
install anything in order to build as
long as you had Java and mercurial and
Gradle you'd be good to go so you could
clone the thing and then build it and
the build system would be smart enough
to say oh you know you're missing you're
missing windows sdk you're missing
directx sdk you're missing cutie you're
missing some of these other things I'll
just build the Java for you or at least
give you the option so you could just
say just build the java stuff i don't
want all the other natives just go grab
whatever the latest native binaries are
use those and then just build the job
and go because I figure for most of us
that's what we'll be doing right
there'll be some folks who are
implementing font support on pango but
not very many you know maybe three or
four then you're going to have some
folks who are porting to a new platform
like say iOS okay maybe you'll get you
know 20 or 30 of those people who are in
there cranking away on that but you're
still talking to relatively small number
of people on most people who want to
contribute a patch your experience is
I've got this bug in UI controls is
really bothering me it's not scheduled
for this release
so you know I am so totally annoyed so
what I'm going to do is I'm going to
clone this stupid blankety blank and
then I'm going to open it my IDE and I'm
going to do a thing and I'm going to hit
run and it's going to work and then I'm
going to create the patch and submit it
and walk away and then if I come back in
three weeks and it's not done i'll be
really mad but you know i will have
gotten that experience and that's what i
want is I want it to be that easy that
somebody can just be really upset and
fix something because I figure if you
could do that then that will make you
happy so the so there's a bunch of
things I'm looking at doing one is to
make it so that you can build the Java
only parts very easily another one is
that the IDE support is really good for
for a new structure that we're working
on so that you actually can use an IDE
and another one is that something like
ensemble will be set up as the default
run target in your IDE so that when when
you've cloned and you've built and you
got your IDE up you can make a change
you can hit run and it'll build
everything and it will fire up ensemble
and you can just see if it worked and
then of course the other parts of this
are a wiki page that describes the thing
you know a you know providing a patch in
three minutes sort of wiki page or
something like that it just sort of
takes you right through it and then an
easy way to make sure that everybody is
aware so those are all sort of little
bits and pieces of the contribution
process that that we're working on to
try to get it really easy and smooth so
that people can can not only contribute
but can contribute meaningful patches
that will be easy for us to take and
apply so let me go ahead and start the
slides for building and testing so
there's there's basically you know
leftovers is really short basically
three main sections one is workspace
reorganization building with Gradle
using the IDE and then just some
leftover topics okay so we'll start with
workspace reorganization right now in
our work space we have far too many
projects it's kind of
when I go to WebKit sources and I'm
looking around trying to figure out
where the heck I'm supposed to find
something it's pretty difficult to find
it in the in the mess of things we have
in for us this really bad we have many
different little micro projects there's
about 90 of them overall and it's a pain
to maintain all these things in the
build and we sometimes do weird things
in the code as a result of all these
micro projects so for example
legitimately for any version of Java fex
that's going to run it has to have glass
the windowing stuff prism the drawing
stuff and the scene graph it's got to
have those three things or you're not
going to get any bits on the screen but
for some reason and I know the reason
because it was my fault but for some
reason we've got that split out into
multiple independent little projects and
because they're multiple projects and
you in your build system you can't have
circular dependencies we have some
one-way dependencies that are actually
two way dependencies but we had to turn
them into one way dependencies for the
sake of the build system which meant
that you had to use reflection or some
other sort of hack in order to get it to
build the right way or maybe sometimes
you have some unit tests that want to
use the bits that's in a different
project but it's a circular dependency
and so you have to set it up so that the
unit tests run after the other things
are built and in the builds just a mess
right so this happened over time it
sound like a great idea to have these
little mini modules when we started but
you know turns as a pain in the neck so
in the new structure we have about 12
module projects so we've we've taken
these things and collapse them down to
the actual functional units it's like
you like I say you can't run prism and
glass without scene graph and vice versa
all those things have to be together
anyway so let's turn them into one
module and once they're one module you
can do all kinds of good stuff another
problem that we have is we have way too
many repos now you don't really see this
in the open source because on the open
source side we've been fixing it as
we've gone along we used to have
something on the order of seven or eight
repos there was an app's repo well
there's the root apps media web
Artie Artie closed tests I think there's
a couple more so it's at least seven
different repose in a forest and
mercurial actually isn't very good at
dealing with force it wasn't ever
designed for it forced was an extension
but it's not built into it so you know a
lot of the different mercurial tools
like bisect just simply don't work
because you've got code spread over
multiple repose in a forest just doesn't
work coordinating pushes and pulls can
go wrong you push you've gotta fix that
spans multiple repos you push to
multiple ones but darn it Hudson kicked
off we only got half of your pushes not
the other half it happens periodically
just annoying it's not that big of a
deal but it is annoying I mean if their
party tools like source tree or crucible
etc don't understand it it just views
each repos its own world and it gets
confused by these things so our goal is
to just have one open repo that's it and
that's what we're doing so web media the
sqe tests all that stuff is going to get
folded into RT for the next when we open
our next repo so so right now we've got
the Java 8 repo there when we open 81 or
whatever the next one is there's not
going to be a route and an RT there's
just going to be the javafx repo at the
end one repo has everything in it so our
current project directory if you're
looking in the root project here it's
got all this just this is just a lot of
stuff oh let me fill you a little chat
going on the stream but the usual
question about you know jit verse
mercurial came up oh yeah feel free to
address that along the way well you know
I mean it's out of my hands we're use
mercurial yes yeah right I don't know
what to tell you it's bit jdk uses
material so we use material of so the
current product directory is a bunch of
stuff the new one has less stuff it's
actually even less than that now it's
just consolidation and cleanup is
basically it as chaos is a natural state
of affairs right what is the second
thermal dynamics or something right it's
just normal so you've got to fight at
all that all the time and right now is
the time for us to fight it because it
just got way out of hand so these are
these are our base modules that we have
our core set of modules there's 11 of
them I put 12 in the slide because it's
likely that we'll come up with a few
more as we go along here but you know
this is sort of the the subset so
there's a base module which actually
contains a subset of Java fex that's
useful outside of graphical applications
so this is like the properties and
binding stuff so if you want to use that
on the server side you can just grab the
base module and go and it won't try to
fire up you know any of the graphic
stuff you got the graphics module which
is the other stuff scene graph glass
prism all the things you need to put
bits on the scene on the screen UI
controls swing so all the swing
interoperability stuff is in a module
swt isn't interoperability is in a
module f XML which is the you know
xml-based markup language lives in its
own module excuse me then media web
design time doesn't actually show up in
the external world yet but it's sort of
a we're working on some design time
api's that are used by seen builder such
that when this API is done a it will be
available in the JDK and people would be
able to write third party controls use
this api's bundle that all together into
some kind of a jar or artifact hand it
to seem dollar and seem builder will be
able to understand what you're supposed
to do with your custom panel or your
custom control yeah exactly and see the
live views and in the in the property
sheet it'll get you the right stuff
there was you know javabeans that swing
used had some basics of this stuff we
were at the time working on a
replacement for it called the jsr 273 I
think design time api for javabeans and
it was way more comprehensive this is
based on that work so it's way more
comprehensive than what we had before so
our goal is actually that scene builder
have no internal knowledge of javafx
that it just talk through these
interfaces for everything it needs to
know if we succeed in that we figure
that any third-party control will fit
naturally and natively right into the
scene builder that's not there yet but
that's why it's not public API yet
because we're still feeling that out try
to figure out what the right way is to
do that FX packager is the tool that
ships with jdk it's used for either
creating a jl p or applet or co bundled
application with native installers a lot
sort of stuff so that project lives
there and then jmx which is just you
know some-some jmx m beans that are used
for monitoring and management of your
application so you actually can use you
know some tools to inspect a running
javafx application and find out you know
how many times it was synchronizing and
what the FPS is and Allah sort of stuff
ok so there's a another question going
the thread about artifact management
using something like a vendor bid tray
and inclusion in the JDK is a
first-class bootstrap classpath item dad
again right right now in Java 7 you have
to add the JFX rter to your classpath
because it's 97 the best rep in eighth
it's on the it's on the yeah that's what
that's what I want you to don't that's
what you want me to say yeah so in the
in any of the later aight builds it's
automatically part of the classpath so
which is great if you're user but it's
lame if your developer because if you're
developing javafx itself because the
darn thing shows on the classpath before
whatever the heck is that you've been
working on so you have to do sumfin
angling to make it to work but i'm gonna
handle all that for you so that my 30
minute patch thing actually ends up
working well so anyway this is just some
simplification who cares so for example
these 5 micro projects make up the base
module it's the beans stuff that we
created the converters Adam
actually the animation does not really
belong here it's going to go to the
other one it right now Adam was split
into two parts but we're going to be
getting that stuff out of here and put
it into the other one java fix common
and javafx logging so those things go
there in the graphics module this is
where you see a lot of the little micro
projects disappear just all these things
get rolled up to one module makes a
little easier to manage so this is right
now I could say we're building with aunt
now my goal with the Gradle new Gradle
build and test was to do two things one
was to switch off ant and the other one
was to you know create this wonderful
new structure with fewer projects and
make it wonderful for everybody well
obviously we couldn't stop the whole
world from develop you know stop all of
our guys from developing while we did
that so what we have is there's this
generator Gradle script that you run
that will copy all the stuff from the RT
directory into a sibling called javafx
and then it will have all the sources in
all their new places the way that it
will be when we you know flip the switch
and go to the new structure so what you
need to do is you got to get inside the
RT directory run this Gradle script and
it generates a new world for you that's
all it takes about Don and all four to
ten seconds it's pretty short once
you've got that new world you'll see the
following one is there's a top level
directory that's called apps and inside
apps is where we put things like
ensemble the coffin scheduler brick
breaker and all the other samples demos
and so forth that we write goes into
apps the build directory is
auto-generated there in the build
process and it's got all the bill SDK
javadocs reports and all the other sort
of stuff currently we create a directory
called artifacts but you know since we
went to Gradle and Gradle by default
creates a thing called build we just
said ok we'll just adopt the new
convention and call it build that makes
sense there's a this actually is an old
slide it's not called build tools
anymore it's called build source Gradle
has a special build source
and everything that was in here is now
in build source so build source has like
annotations the Builder processor that
we use to auto-generate all of our
builders and any other tools that are
used at build time but are not part of
the final SDK those things went in to
build source functional tests the
directory doesn't exist yet but it will
when I take the sqe tests out of their
repo and stick it in this one so we'll
have a directory called functional texts
and it will have all of the tests that
are intended to test the entire system
together so this isn't like unit tests
but it could be gooey your non gooey
tests it could be automated or manual
tests will have all those things sitting
in functional tests so this is another
thing that's this not been the case with
jdk development it is going to be the
case with javafx development which is
the tests that we use will be available
to you so that you can develop on an
equal footing with us because I think
that's sort of important otherwise how
we're going to get good patches from
people people will give us a patch will
run it on our tests will say it fails
tests will give it back to you you'll be
mad you'll change it you'll give it back
to me I'll run on a test well say oh it
was too slow we'll give it back to you
you'll be really mad I mean it's just
not a good system so we're just going to
make everything available to you and
make it easy to use it takes a lot of
effort to do that incidentally most I
don't know how it is at places that you
guys work but certainly for us it's
always been like well the build systems
is just sort of working right certain
play with it a bit to keep it going and
then you know eventually gets kinda out
of control i think or it's not working
or snot working yeah i think that's sort
of a normal state of affairs but when
you're trying to do an open source
project and get people to actually
contribute it's not good enough you got
to treat it like a product make it
really nice and easy to use the upside
is if you put that sort of love into it
it'll make the developers that we're
paying more productive okay so two two
questions on the stream so one of the
guys is wondering what the advantage of
is great all over maven and the second
question is the performance difference
between the Gradle build and the
previous aunt bill good questions
so I answer the question on maven in a
few slides so we get to that in a second
the performance difference is okay so
actually let me let me get to both
questions in just a bit i'm going to
talk about the structure and then i'll
get to Gradle and in Gradle I will give
you the good in the bad i've been using
the thing for that on all three months
now i think so i'm i'm starting to
become quite familiar with it and so i
can give an honest assessment i think of
where it's at so a modules directory
contains all the modules that we looked
at on the previous slide they're all in
that little little guy and then there's
various ide files that are generated by
Gradle on demand so if you're using idea
you can generate idea project files but
using netbeans you can generate those if
you're using eclipse you can generate
those as soon as somebody contribute
support for clips and then inside each
one of our modules we just follow the
normal industry standard naming
conventions that maven has popularized
these are different than anything we've
ever done before in the Java group but
figured well actually I did have a
different naming convention at first and
then the guys on the mailing list said
oh you fool just stick with the standard
I was like I hate the standard it's like
18 levels of nesting they said just do
it so I was that okay so I did it and
you know within like three hours i was
used to it so i figured that's what
we'll do we'll just stick as much as
possible to just stock and standard
conventions not make up anything new
you'll save us down the road so you know
for many people who are using maven or
Gradle you'll be able to come to this
and find your way around pretty easily I
think I don't care about that so yeah so
I was originally presenting these slides
to the internal team and since none of
us have ever done this before it was you
know I had to put in some extra
disclaimer about how I had structured
things and to be honest I don't know if
I did it exactly right so if anybody
knows his stuff better you know feel
free to come on the mailing list and
abuse me but you know so you got source
main Java that's great and then
occasionally there's some other guy
who's sitting in there like this version
whoa what the heck is version info well
you know in our build there's this class
called version info and it's got tokens
inside of it and during the build
process we take it we copy it to a
different location we replace the tokens
with information we get from Hudson such
as what the build number is and so on so
forth and then we compile that thing in
its new location and then we take its
class file and bundle it into the
universe and so forth and so any anytime
that it was just not a straightforward
here's your Java sources we compile and
stick in the jar you know I broke those
out into another directory so that we
knew that it was handled specially and
then native we have a ton of native code
actually the vast majority of the native
code is WebKit and gstreamer the other
need of code that we have there's enough
of it but it's not daunting it's fairly
reasonable but we do have native code
certainly more than most Java projects
so for these what I did was I created a
directory under source main called
native or source main native dash and
then some indication of what it's got
the natives for as you know native
sources don't have to be structured in
anything like Java packages there's no
strict structuring convention at present
our code is sort of structured ad hoc
the native stuff I would like to do is
the pass later and standardize the way
that all the native things are
structured so that I could simplify the
build a bit but anyway it's not that bad
so for example all the native decor
stuff that does all the native if it's
if it's using software native loops to
do the effects that code is right here
the SSE box blur etc native glass gtk
iOS lens Mac Windows all those things
are there so if you're hacking on iOS
the sources are all there it's all open
sourcing just go in and see what those
things are native prism prism software
pipeline all that sort of stuff is all
just right there there's a lot more now
to such as the d3d stuff has been open
sourced and some of the es tu so there's
there's a reasonable amount of native
code but it's it's all contained in
little native folders so it should
be pretty self-explanatory when you get
in there so now that the scene graph and
prism and glass and these guys can all
are all in the same module they can all
see each other one of the next steps is
to go in and remove all the useless
abstractions that we had put in there
they actually weren't useless
abstractions there we had abstractions
in there for purposes other than
satisfying the build but none of those
abstractions are really that necessary
anymore so there's a lot of things that
we can do in order to simplify that code
base make it smaller that make it faster
easier to understand so that's one of
the things that will be doing once we've
got to this new structure so for example
right now the way that it works is that
the scene graph talks to what we call
the toolkit through a set of interfaces
and then the toolkit talks to glass and
so when an event comes into the system
glass takes that native event turns it
into a Java object passes the Java
object up to the quantum toolkit the
quantum tooltip toolkit takes that Java
object turns it into a scene graph event
and then post it to the scene graph it's
like why do we have the extra conversion
of the event why didn't we just go from
native directly to java objects that we
pass to the scene graph well the reason
is because the build was separated from
each other and glass didn't know
anything about the scene graph so glass
couldn't do it it had to create an
intermediate thing and anyway it's all
awful so now we fix those things we're
going to be able to clean all that sort
of stuff up so that's good okay now
building with Gradle so here's the
question to the here's the answer the
question why Gradle not maven okay I
think this is very accurate this comes
from their website I think this is very
accurate i don't i don't think there's
any marketing speak in here is this is
my experience Gradle combines the power
and flexibility of ant with the
dependency management and conventions of
mavin into a more effective way to build
powered by a groovy dsl impact with
innovate okay packed with innovations a
bit much okay but there is a lot of
innovation in there but it just you know
packed with it does marketing speak
Grandal provides a decorative way to
describe all kinds of builds through
sensible defaults I think that's an
absolutely true statement um
maven is fine when you're not doing
anything weird but we do a lot of weird
stuff in the build of necessity and I
mean is mind-blowing when you go this is
why it's taken me three months to get to
the point that I'm at with the build
system there's so many little niggles we
build 47 platforms at present 9 in the
near future we build for Linux 32 Linux
64 Mac 64 windows 32 windows 64 arm hard
float arm softly both version 6
incidentally and iOS and Android
although we don't ship either of those
they're just in the source stuff so I
haven't got those in the Gradle yet but
soon I will and then that gives us 9
things that we build for heaven forbid
we should start building for armed
version 8 or something else right it's
going to there's a lot of different
platforms and because we have native
code it's not as easy as just doing a
single compile and having a jar and
sending it out there we have native code
and the native code has different
command line switches depending on which
platform you're building on is whether
it's linux mac or windows completely
different command line switches it's got
you know different libraries that it's
linking against when you're building on
the arm soft float versus hard float you
need completely different tool chains to
compile with if you can't compile with
the normal GCC you got to be using a
special tool chain that knows how to
compile for either the hard floater soft
float you know binary interfaces and so
forth there's a lot of the sort of stuff
that has to be taken care of obviously
how we package the whole thing up is
going to be unique because we're
producing a package structure at the end
of the day the matches with the jdk
produces so for example where does a dll
go oh well of course it's the dl l and s
0 or dy lib depending on what platform
you're on and where do those things go
well it depends it either goes in the
JRE /bin directory if it's on windows or
JRE / lib if it's on mac or JRE / lib /
arm if you're on one of the arm platform
so Jerry / lib / I 386 if you're on
32-bit windows or Linux
and amd64 if it's the other yeah I think
those are the only combinations but it's
yeah it's weird there's a lot of weird
stuff going on okay so Eric had a
question of the stream he's wondering
why he could do those with maven mojos
and I think he's more familiar with
maven so he's not criticizing Gradle he
just doesn't know that much about it
yeah I'm not familiar enough with maven
to know I relied on a lot of advice from
people I met at conferences this is what
I've heard yeah is that you can but so I
you know I don't know I don't know like
even like the version info guy I don't
know how you handle those sort of odd
cases so anyway it's just it's just a
big nasty and this was actually the main
problem with aunt was the aunt does not
give you okay so obviously aunt doesn't
have dependency management although you
could use IV to achieve that so it be
possible to have redone the build system
in aunt and IV um but I hate XML so no
just do it the other thing is is that
aunt you know it's got that what i call
the decorative straitjacket I mean you
just can't do something procedural if it
just makes more sense you just can't do
it unless you're going to go write some
Java code create a plug-in stick it into
the you know the whole ayat system so
forth is just more painful so that's why
I pick the Gradle so some of the other
pluses aside from that the command line
interface is really great I really like
it the IDE support is really good like I
say there's no deck loaded straitjacket
which is pro and a con because somebody
who's working on the build system could
just go crazy and write a bunch of
procedural stuff and do it all the wrong
way if you will and it makes it harder
to maintain but if you if you do it
right it really powerful when you need
it it's got the dependency management
built-in same as maven and it does a
good job on the incremental compilation
the only real problem with Gradle is
that there is there is definitely a
learning curve involved and partly
that's great but in to a large extent
that's groovy I run into groovy problems
every day that I'm just
canet the code saying what the heck is
wrong why doesn't this work I had one
today I was missing a comma nothing told
me I was missing a comma I got you know
blah blah blah closure blah doesn't
accept arguments move I mean the names
of these closures they were auto
generated by great groovy we're like
this long I mean you looking at you say
what the ACT did I do wrong great you
look at the line of code and you're
staring at it and you're like I don't
know and so then I started giving
parameters to these closure arguments
and they are in the the the error
changed it stopped telling me that line
was bad and it was telling me a
different line is bad now I went fix
that one and then it gave me some other
error and it turned out all that was
really wrong was I was missing in comma
between two closures passed to a method
I have no idea what it was doing but it
was a pain in the neck okay so great I'm
mr. groovy is causing me pain is just
yeah sis the way that's been my
experience a lot of things that it does
are kind of nice until you start hitting
edge cases where it's like so for
example they've got these what they call
the g-strings right you can pass in
dollar sign name of the variable or
dollar sign brace variable close brace
and so sometimes I wouldn't use the
braces because I you know is nicer
without it right that's all appointed
Ruby is that you can do things in sort
of a nice little ways dynamic language
or whatever but it had unexpected
side-effects from time to time that I
was just didn't anticipate throw the
braces and all of a sudden it was
working it's like okay I don't really
understand what's going on there also
the fact that when you use those
g-strings then sometimes like for
example there was a method and the
method takes objects and it it was like
map right you're doing a map dot has
property or something like a map map dot
contains key and the keys were strings
but it turns out I wasn't passing it a
string so I always think of it as these
little g-strings inside the string thing
is actually a string it's just syntactic
sugar for adding the string and passing
it in but this is not the case it's a
g-string object and so it was checking
this hash map to see if the g string
object was a key and it wasn't they were
all strings that were keys and that was
just
ask me up you go back to you know quotes
with pluses and life is good so there
are things like this that are just going
to impact you if you don't know groovy
sorry yes you don't know groovy you're
going to have a little bit of pain use a
Gradle not to mention just trying to
understand the syntax so the first time
took a few weeks however on the other
hand I took out the previous slide you
have somewhere on the order of thirty
thousand lines of ant in our build
script and that's not counting any of
the samples or apps or any of that or
tests okay that's just our build system
okay yeah Wow now a lot of that was
boilerplate nonsense that we're
repeating over and over and over again
because we had a zillion little micro
projects but it was very it still is
it's very hard to understand our
existing build system I've been doing
this for like three months straight now
and I've gone crazy it's very hard our
new thing is like you know three
thousand lines of code so it's much more
manageable it's still borderline and
that you borderline I mean it's still
complicated but that's because our build
is complicated so the nice thing is that
right now if you go read the Gradle
stuff it will tell you what our build is
doing and where it's complicated is
because our build is doing complicated
things where it's you know like the
whole version info take the thing
replace the symbols copy it to the
generated sources compile the thing and
create the classes include these class
you know when we're creating an SDK
that's going to run on mac make sure
that you include these packages but
exclude those packages and when you're
building on so those sort of things they
sort of come out at you because that's
pretty much all that's in there because
graybles got good conventions and we
follow the conventions by default pretty
much all you're looking at are all the
exceptions to the rules so there's like
three thousand exceptions to the rules
I'm just saying it's complicated build
but that does also include all the build
logic that I added to generate the
intelligent and netbeans project files
which is significant as well so it's not
all it's not all bad so here's an
example of the command line if you
haven't used Gradle before it's just
this night yeah I mean I just was like
oh look at this nice little touch they
got the colors on there but you can one
of the things that you can do is you can
go to any Gradle project and just type
in
projects and it will show you all the
different projects that are involved in
this project so in our case our route
project is JavaFX and then there's a
project for each one of the different
modules for example so you know it's
convenient it's got the colored output
which is really nice there's a way to
turn that on for aunt but with Gradle
you just get it for free camelcase task
look up so if you want to run a task you
can just put in the camel case letters
and it'll find the right task and run it
you don't have to type in the whole
thing a task in Gradle is like a target
and aunt you know it's by default when
you do a build it spits out the minimal
stuff whereas like our aunt thing is
just like spews that you can never find
what you want you know you can run
Gradle tasks and I'll tell you the most
useful tasks that you can execute grant
projects shows you all the projects that
sort of stuff so it's just really
convenient when you run the tests you
know instead of instead of things just
going whoo zip and by you it's it just
has this little guy on the bottom that
says here's the project you know
controls I'm running the test target on
it or task and so far I've run 4606
tests 150 of them have been skipped and
it would tell you how many were errors
or whatever and it just sits there and
count them up and then when it gets to
the end it goes to the next thing so
again it's just kind of nice by default
instead of having all that text ghost
view now of course you can spew all day
long you just have to pass it some
parameters and it'll start putting out
all kinds of extra crap but you know by
default it just kind of keeps it nice
and tidy so tasks are like I say kind of
like targets these are the things that
you do you can have one task depend on
another task so for example jar depends
on classes same thing as an ant or
anything else tasks can be run in
parallel a great will has support for
running these things all in parallel
however ours doesn't do that yet it's
one of my goals to get to that point so
we want it and it's not just for your
machine although that's part of it is to
you know saturate your CPU when you're
building so that it takes less time to
build but it's also for our whole you
know hudson infrastructure and all these
things right now it takes about an hour
hour and a half to build the full JavaFX
on Windows i586 on Hudson I don't think
that includes the unit tests pretty long
and running the unit tests is like I
don't know 20 minutes or 30 minutes
something like that so it's kind of
problematic because Hudson doesn't get
back to you very quickly what we're
trying to do is to fit the entire build
and test into about 30 minutes now I
could do it a lot less except for web
kit which is hopeless so we're trying to
get it to that point if we can get it to
that point what that means is that as a
developer working on the project you'd
be able to do do whatever you're doing
and when you're getting ready to push
you'd be able to just go do a whole
clean and build it'll do a whole clean
and build on well so the way that we're
going to do it is you work on some stuff
you do some local testing you say yes
this is good you push it up to a machine
which is then going this is a whole farm
and it'll take your patches it'll do
continuous integration it'll take the
latest head it'll merge it in it'll
build and test on every single platform
do we support if it passes that first
set of tests then those binaries will be
pushed to the continuous integration
side to say these are the latest
continuous bits and then it will take
off going through a whole pipeline of
more rigorous tests that ends up lasting
three or four weeks overall but
progressively more complicated tests as
it goes in that part of that pipeline it
goes through nightly tests and produces
nightly artifacts and weekly tests which
produce the promoted under facts and
then more extensive longevity testing
which is just used to find bugs and
stuff like that so it's important for us
to get our building test cycle really
really short so that we can make this an
automated process because you can
imagine if you have you know dozens of
engineers working on this thing and I
can't give you numbers but it's lots of
engineers working on this stuff and it
takes an hour and a half to do a full
build for each person you're not going
to get real continuous integration
because everybody will be colliding with
each other
work so so that's what we're trying to
get to um okay basic tasks that are
available to you by convention clean
hello yeah who would have guessed
assemble which basically creates the
project deliverables build does the
assembly and the testing classes
compiles Jarrah produces jar tests tests
so forth so each one of our little
projects has their own set of unit tests
that's what's run when you call Gradle
test now we'll have other Gradle test
targets tasks sorry eventually for
example I want to run all the functional
automatic tests or I want to run the
pre-commit tests or whatever it'll just
be something like Gradle pre-commit
tests and it'll run the functional tests
it'll do all the build then run the
functional tests they're required before
you could do an integration that sort of
stuff so our entire our entire build
system everything from what we would do
as a developer to what they do in
release engineering before the bits are
finally put out onto the website all
that stuff is going to be inside the
build system and available to anybody
the difference is of course the real
bits that we put out in the web will
have digital signing and everything else
from Oracle certificate obviously that's
not going to be included so that'd be
bad but anyway so so anybody would be
able to produce a build and this is
really important from the open JFX and
OpenJDK side right you want to be able
to produce an open GFX build on your own
local system and it should be exactly
the same as what we would produce if we
were doing it and that's what we're
doing to get all that stuff built into
their oh great I'll clean whatever
Gradle SDK oh boy creates an SDK based
on the platform you're running on dash I
or dash dash info gives you more
information q hides more stuff debug or
dash D will show a heck of a lot more
stuff which is mostly not necessary
unless you're debugging the build itself
this is a simple way to just say I want
to clean only the graphics module so
there's a convention cold separated in
great also you know graphics is the name
of the module colon and then the task
that you want to execute this one will
build all the native stuff for the
graphics okay generates the job Jane I
headers does the compiling does the
linking the whole nine yards yeah right
yeah I'm saying did the Oracle JDK ones
yeah cuz no those won't be available to
that will those won't be available to
hardly anybody inside Oracle it's like
you know two people or something like
that have that um but yeah openjdk has
no signing it's just helpful JDK so okay
how do you deal with different
properties okay Gradle has a Gradle dot
properties file and it's part of our
build system you'll see it right there
um everything in its commented out it's
one of those where you look at it you
figure out which things you wanted to
change copy the thing into your home
directory there's if it goes into your
home directory dot Gradle / cradled up
properties it takes precedence over
what's inside the JavaFX Gradle not
properties file so typically what you do
is you take javafx / cradled up
properties copy it over into home
directory not Gradle and then go
uncomment the things that you wanted to
modify in terms of what's special about
your setup and of course you also can
pass properties with the minus P flag
and there's a bunch of other ways to
pass properties in Gradle you can do it
with minus D flags you can do it with
environment variables there's a bunch of
different ways that you can set it up
but the point is is that we have exposed
a bunch of properties that you can set
in order to change how the thing builds
and the most convenient way to do that
is just stick it in Gradle dot
properties in which case we'll just pick
it up and run with it um so here's an
example if this doesn't work today like
I said the Android and iOS builds and
Gradle aren't set up yet but if you
wanted to build something like Android
what you do is you'd say Gradle minus P
compile targets equals Android SDK and
what this does is it just says
you know what is the thing that you what
is the SDK you're trying to create oh
it's the Android SDK okay that's what
I'll do so this is one way to do it to
pass it as a minus P property the other
way to do it is to like I say put it in
your Gradle dot properties and then you
don't have to pass the minus P you can
just say Gradle SDK and it'll do the
right thing for you so there's a whole
bunch of documentation in the thing that
tells what each one of the properties
are avail you know proper syntax and so
forth so it should be pretty
straightforward how to do that one of
the other things Gradle does nice earth
an ant have a box is the reports that it
produces so there's a bunch of ones that
it produces for free such as Jane a test
reports and also a build profile they
can tell you where you're spending all
your time in the build itself there's
also in the newer versions of Gradle a
way to produce some sort of project
dashboard that has all sorts of
information from all the different
sub-projects I haven't tried it out yet
so here's an example of the little web
page for the test summary you know yeah
that's just nice the profile report is
an example of that and so I'm looking at
the task execution time itself and you
can see that the entire project took 13
minutes and of that 11 minutes and 10
seconds was compiling WebKit yes WebKit
takes forever so there's there's much
more stuff here on sort of I guess
groovy and how Gradle works but I don't
know that it's really worth us to go
through that unless you guys were really
interested in it but there's a few
things that are kind of useful I think
whatever here are their stupid g-strings
they're both wonderful and frightening
at the same time I mean I use them all
over the place and I want them to be so
awesome but darn it it's not a string at
the end of the day it's a g-string
object got to remember that it's a
little hidden thing they're meant to
trip you up I think another one is
dynamic properties right so it's a
dynamic language so you can assign
arbitrary properties to arbitrary
objects great I'll warn you if you try
to do that but there's this magic map
called EXT that lives on the project
object and as it turns out on a lot of
other stuff and
what really caught me too so it's really
annoying but anyway so there's this
principle the Brian gets was trying to
live with when doing lambdas for java
and it was basically you should be able
to take a chunk of code stick it inside
a lambda and it should mean exactly the
same thing before and after that's not
the case with groovy you take code that
was outside of a lambda and then you
stick it inside of a lambda and it could
it could end up doing something
completely different than what it did
before so for example you take this code
that says EXT is 64 you stick it inside
of a lambda it's going to try to assign
that is 64 property to a lambda created
you know some some groovy created
objects associated with that lambda as
opposed to the project object which it
should have captured and been assigned
to I drive me crazy you love it but
sometimes it bites you it's like it I
don't know a gator for a pet that's a
tough 00 anyway but you know there's a
lot of great things about it it's a lot
like I say for me is a lot nicer than a
bunch of XML and there are some things
that are just really powerful like you
can use enums in the thing you know it's
just because it's a programming language
you can do a lot of really cool stuff we
don't care about that we don't care
about that stuff this is all just
basically syntax how to map the syntax
but I don't think that's worth us
spending too much time on here's an
example of one of the groovy closures i
just i love them it's great i can't wait
until we've got this stuff i mean it's
in the Java 8 builds but to be able to
actually program with closures I think
it's going to be really really great
advancement over what we've been been
doing none of these are good examples of
writing a bunch of code there were ya
know those a good example so there are
some good places though where it's like
well this was not bad so basically what
this one does is it says for each JSL
file that you find you're going
to create a new task that says compile
this JSL file so for example our JSL
files these are Java shader language
it's sort of a non-public shader
language that we use internally and what
it is is it's a shader language that
tells us how to do all the decor effects
now from it we generate d3d shaders
OpenGL shaders sse code and java code so
that we don't have to write that four
different times we just do it the one
time generate it so we have a bunch of
these gsl files and so what this code
does is it takes each JSL file creates a
task for it and doing this sort of thing
in Gradle and groovy so easy and
powerful doing this in XML is not so
that's one of the things I really really
liked about it so I de support you can
ask Gradle to generate a project file
your choice you just type in Gradle
space idea it'll create the idea project
files and the idea project files that is
generating have all of our defaults in
it it's got the right copyright header
for OpenJDK files it's got you know
spaces instead of tabs and all that sort
of stuff set up so that when you open
the project file up you should be able
to just start whacking away create a
diff send it to us and everything will
be in the right way haven't done it yet
for Eclipse and the NetBeans one is half
their NetBeans is actually different
beast I'll get to in a second it's
really nice um oh that don't care about
that one so I don't know about that so
here's an example of what it looks like
inside idea you know there's the apps
directory that I showed you before
builds tools which is now build source
functional tests is sitting there
modules with all the different modules
underneath it all the different you know
source directories test directors
everything else it's just a perfect
little idea project set up and ready to
roll NetBeans is really nice in that it
NetBeans has a plug-in that understands
Gradle natively Gradle exploit has a
tools API with it that NetBeans can just
use and so that's really nice you
basically don't have to do much in fact
the only reason that you would say
Gradle NetBeans in order to gin
in a NetBeans project file is just to
create those defaults such as the
project you know the templates for new
files and things like that otherwise you
wouldn't even need to do that you just
open it up and off you go but it's it's
really nice I was really I was really
pleased with it not only that but the
folks who maintain it are super
responsive I mean you know just ended me
more email than I could handle I was
trying to keep up with some say yes this
feature no not that one uh so very very
responsive so is really really nice
experience actually to use netbeans for
that which I wasn't expecting so it was
really great so simple leftover it's
like I said I haven't finished the
android/ios builds I haven't finished
the bundles so when you do a build it'll
give us decays but it doesn't produce
the Zips and the tar.gz s and the other
sort of stuff that would show up on the
website none of the closed tests run
it's just the open ones that run at the
moment I'd haven't done the Eclipse
project generation and I haven't
although I've generated it and opened it
up in an IDE I haven't really whacked on
it yeah you know I haven't tried to fix
bugs in the new world in the new world
structure so yeah but it should be okay
so that's basically what I haven't done
yet some future stuff that needs to be
done is to simplify the build so once
once we've gone over to the new
structure there's a lot of things that
we could do in order to make be more
consistent like for example how the
native code is all structured or built
or what our native flags are that we use
because like right now our native Flags
there's at least four different there
were at least four different authors
involved in writing the make files that
we're using in our existing build script
because you can tell because they're eat
you know of the 25 or 50 different make
files that we have whatever it is
they're all copy and pasted from one of
these four original ones because you can
so you can start trace the heritage of
where the thing came from by how it was
written and anyway bye bye just sort of
breaking these things down and creating
more consistent structure and how things
are done we could simplify
the build further than what we've done
but like you know your left looking at
these make files and you say why are the
parameters that I'm passing to this to
GCC here different from here is there a
reason why there are different
parameters or is it happenstance and it
depends some of the differences are
happenstance Wow somebody decided they
were going to build with these warnings
turned off and these turned on and some
people say they're going to use fast
math and some didn't and in other places
it made a big difference this guy
actually really should not have fast
math turned on if you do you'll get
rendering artifacts well you just don't
really know so there's going to be some
effort to do some you know trial and
error to figure out which which native
flags we actually need anyway and then
find bugs parfait checkstyle there's a
bunch of other things that we want to
integrate into the build so that you
know we get we get more consistent and
cleaned output at the end of the day so
that's actually an area that I think
will be fertile for doing you know for
contributing is for example the London
jug has been very successful on OpenJDK
doing fix a warning days and things like
that they'll set up a day they just get
a bunch of people together and they'll
just hack on the JDK as a group just for
fun so instead of you know me up here
jabbering we just show up and say yeah
that's fix some warnings right and so
you'd run the build and you'd find some
warnings and you'd go fix them and you'd
submit a patch and then over the course
of the next week engineers at Oracle we
go through those things and applying
them and getting those warnings under
control so fine bugs is a perfect
example of that right find bugs is going
to generate a ton of noise and some of
its good and some of its just going to
be noise but it's going to take some
effort to go through all those things so
we're not going to just turn find bugs
on overnight will probably go module at
a time will say well let's go to the
base module let's run fine bugs let's
get rid of all the build warnings let's
get rid of all the fine bugs warnings
lets you know get it all cleaned up and
I think those are great you know those
are the sort of things you ought to be
able to do that sort of thing in a half
hour hour's time period
so so those are really good
opportunities to sort of get your feet
wet and once you've got your feet wet
and and you know how the build system
works and the contribution and people
are on the Oracle side know who you are
and they're used to you then you can
start contributing all sorts of other
stuff and it'll be a lot easier so for
example Tom shindle contributed a bunch
of fixes to controls and we know Tom and
he's been contributing for you know a
reasonable length of time so it was a
lot easier to get his patches in through
the queue because we sort of know what
to expect from him so so if we have
organized javafx open JFX hectic here
who would be interested actually
participating anyone maybe all right so
you snap your the whole thing you scare
you got to fix a button right we list of
a few folks are interested here so yeah
yeah that's it that's all I got yeah
yeah I just didn't get to it so I
figured that there were enough Eclipse
users that somebody would contribute it
so that's what I did that's right
somebody will do it yeah no we do is
cross compiles um so there's a UH i
don't i don't know if it's open yet i
don't know if it's on the open wiki but
there's a yeah i'm not sure anyway
there's a good wiki that we need to get
open if it's not out there yet which has
exactly which tools need to get
downloaded and installed in order to
build so i've got i don't know somewhere
in one of these were my one of my many
things it's got them in there so each
each platform uses different tools
obviously we use a Microsoft compiler so
you have to use
visual studio 8 or 10 what is happening
is 2010 that's so this is 2010 so that's
the visual studio you know it's GCC
obviously on Linux oh gosh hate it when
stuff gets lost in the there we go oh so
I mean look at the name of that thing
this is whatever that thing is that's
what we're that's what we're using for
building for hard float soft float is
this guy here and this one's hard float
as well so anyway the compilers are in
one of those and some of the libraries
and stuff to compile against her in the
other but yeah so we use across the
father in fact there's no reason why you
shouldn't be able to build open JFX on
arm but I don't presently support it I
know that there was some problem
somewhere yeah are embedded guys were
trying it out once and they ran into
some problem besides the fact that it
just took forever yeah forever it's
actually very fast on desktop just crank
just pops them all right out
well you are sayin rescue Lloyd to see
if there's any questions as well so yeah
no I they are all brave souls for your
that are really bored no I think it's
they've been asking the questions as we
went along we didn't call back along the
way so if it's yeah it's been a it's
been a lot of work to try to get the
build system under control but that's
what we're doing it for is for people so
that when when you get really mad at
something you can come flying in and fix
it that's I mean I know it's really hard
to get into a new project and be able to
hack on it and a big part of that is
just getting started once you get the
built environment set up and running and
you can make a change and run make a
change and run see the thing work they
mean you're ninety percent of the way
there then the fixes are pretty easy
after that all right cool well I want to
thank rich for to get an excellent
presentation so give them a round of
applause name I think this is the second
time we've had you speak here right in
this one and a couple times in that room
up there okay so that's your first
alright and we need to give away to tell
jay license to would one lucky member of
the of the audience they look like any
good user group we um we have a very
equitable system giving out prizes so
who needs it the most who actually used
the intelligent licensee doesn't already
have have wood for work or for a
previous jug meeting anybody darn thing
is i got one yeah apparently you
actually like that's your primary is my
primary idea are you still are you still
in talking terms with a prog to you yeah
okay cool i can say then that beats
green sports really nice nobody's
nobody's jumping me I with license you
you're at you're considering oh really
who who who he's man Eric Eric Smith all
right sold sold to Eric I think he'll
we've created one open GFX contributor
because he's going to try the
intelligent project creation yeah yeah
that'll go to a good use all right so
thanks / would we should still have like
food and cookies outside help yourself
and you could wiggle around for a while
because it takes us forever to rip down
the video equipment so thanks for coming
thanks for presenting</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>