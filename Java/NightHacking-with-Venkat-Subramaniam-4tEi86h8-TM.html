<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>NightHacking with Venkat Subramaniam | Coder Coacher - Coaching Coders</title><meta content="NightHacking with Venkat Subramaniam - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>NightHacking with Venkat Subramaniam</b></h2><h5 class="post__date">2013-02-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4tEi86h8-TM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so welcome to the night
hacking show Venkat thank you
so how's your experience been so far at
the Jay focus conference overwhelming
I'm cool this is my first time here and
just thrilled to be here
call your session last last time period
was very well attended thank you and I
heard very good stuff about it from
folks who came out of the session
what sort of technologies and things
were you demonstrating here I was mainly
focused on design patterns patterns for
Mardon jvm languages which I include
Scala groovy showed a little bit of Java
8 in it as well cool so what we're gonna
do is we have a live chat here for folks
who are on the live stream so they can
interact with us we're gonna try to do
some live coding we talked about
possibly doing an example showing some
tail call optimization and we'll also
chat a little bit about things which
you're working on or or interest you on
the technology side awesome
so why don't you tell us a little bit
about something interesting about
yourself maybe a personal anecdote or
something you've done recently hmm well
I live in Boulder Colorado or at least
my family lives there I travel around
the world and when I'm not coding what I
really like doing is to hike the
mountains and we go on long hikes one of
the things that I share with my children
is my passion to do mountain hiking and
there was one time when I was totally
unprepared but that didn't stop me from
hiking the mountains we went on a
seven-hour hike with no water no food
Wow and now the children call that the
death trail as they formally call it and
since then we have done quite a few
hiking we were in Norway in the summer
went up to Bergen and did the hiking on
the mountains over there at that point
that was the longest we had done
and then in the summer we did about near
11 hours of hiking up the Rockies so the
two things I love doing is programming
and hiking yeah that's a good offset for
the sedentary life of being a hacker and
programming on a keyboard and it's
almost a similar interest to you you're
good friends with Arun Gupta mm-hmm as
well he was an avid marathon runner
know that there's a scale here I am the
novice he is the Guru yeah he actually
he ran an event earlier here at Jay
focus called what was it geek the geek
run yes I was part of it yesterday and I
heard that was 15 minutes of very cold
weather running throughout the streets
of Stockholm yeah we it was a lot of fun
because we started and I saw them all
disappear in a distance very quickly and
I got my way lost and then eventually
found my way back to the hotel it was it
was a lot of fun but painful yeah so
currently there was no in the back
trying to catch the stragglers yes they
just they just went off I thought he was
trying to get rid of some speakers
that's what I think it was a block there
is watch I have to say anything too
horrible about you all right cool now
he's a he's a great guy
he is so why don't we take a look at
some of the stuff which you've been
hacking on I'll bring up your desktop
here cheer
all right there's the venkat desktop
there you go
so well I've been playing with languages
and languages have I don't know why but
they are kind of turned into a passion
for me and I can probably program
comfortably in about eight different
languages switch back and forth and one
of the reasons I really like programming
in these languages is languages are a
doorway to design ideas and and one of
the things I really like about
programming languages is not really the
syntax of the language oftentimes when
we get new to introduced to a new
language we ask ourselves how does the
syntax look but to a great extent I
think that's really a wrong question to
ask and what's really interesting is the
idiomatic differences between the
languages now of course this is this is
something that I kind of keep thinking
about you know should I program in a
different language than the mainstream
language that I'm using at work and the
answer is I think it's very important to
do that
because not so because we can switch to
program in a different language but more
so we can bring some of the different
ideas back into the languages we are
programming in and you'd actually
encourage people to experiments or
prototype with different jvm languages
just to get ideas and get a flavor for
different styles certainly different
avium languages but even beyond that
like years ago for no reason obviously I
got excited about Ruby and that helped
me to get excited about
groovy when it came out similarly as 20
years programming in Erlang for really
no good reason really helped me to pick
up Scala very quickly and in fact I'm
able to do a few things in Java 8 today
that I don't think I would be able to do
had I not been exposed to groovy and
Scala for example yeah yeah no I mean a
lot of the new Java 8 features are all
based on functional styles of
programming from languages like Haskell
ml Erlang right and
it was interesting so I got exposed to
functional languages through some of the
courses I was taking in college and it's
a it's an entirely different mindset in
how you think about the problem and you
can have some very elegant solutions to
things which in in Java might be more
verbose but at the same time taking
advantage of features like lambdas in
Java 8 you can get similar
expressiveness it is really exciting to
see a lot of these things coming
together in the languages platform so
one of the things that just to kind of
expand on one one topic here is its tail
call optimization I want to kind of talk
about that so for example and why is
this really even related to functional
style of programming and the reason I
think is the core you know behind
functional language is one of them is
immutability and and once we attain
immutability there is quite a bit of
flexibility we have or we have on our
hands
so I'm gonna write some Scala code here
just as an example and then we'll kind
of switch between languages and look at
this so suppose I want to you know find
a factorial of a number this is purely a
simple Scala code and just to be you
know sheer we'll use a big int here and
I want to just write a very simple
recursion and and a recursion could be
as simple as if n is 1 I simply want to
return a 1 otherwise I want to return n
times factorial of let's say n minus 1
so actually I'm let's go to the
iteration for a second so so all that I
want to do is define a variable which is
really not a idiomatic way in Scala
because you want to do mutable or D as
much as we can but let's go ahead and do
this pretend that we were not being
watched and so let's say for a minute
that I want to say 4 values I in 1 to n
I want to simply go ahead and find the
factorial so we could say factorial x
equals just the value of I so in this
case basically a factorial of let's say
a simple number 5 just to begin with so
so in this case we are starting with oh
this is of course begin to there so
we'll make this a big into as well to
make him happy
so this is essentially a little
factorial and it's not sure why he's not
happy with that obviously a error here
that I'm trying to use this value of n
here so not sure why he's not happy with
1 to N anyway so so essentially the idea
really here is to use a iteration to do
the factorial
now iteration is simple but we are
dealing with mutability on our hand and
we want to definitely avoid the
mutability and so as a result you may
prefer using a simple iteration a
recursion so we could say if n is equal
to value of 1 we could simply return a
value of 1 otherwise we could simply
return let's say n times factorial of n
minus 1 now the currents are really cool
in my opinion because it's very highly
expressive yeah you know that's a lot
easier to read than the previous example
but there's a catch yeah there is a
catch now let's let's go back to a
simple case here of just using an
integer for a second now in this
particular case I'm returning a
factorial this is a more of a scala ism
it wants to tell us what the return type
is now obviously code is very expressive
one of the recursions once we get a hang
of recursion as we can solve a problem
using solutions to subproblems you know
how cool that is
but obviously the currents don't scale
very well for large input sizes and
often times you know in a practical way
when I would use recursion is when the
problem size is complex and big so it's
kind of a defeat in a way that we can't
use recursion when it's really needed
yeah no actually breaking down two
iterative patterns makes it harder to
paralyze the code later on as well so
you're actually moving away from simple
statements of the problem that you can
optimize that's a great point so so
given this if I were to bump up this
value just as an example to go higher we
have the stack overflow exception that's
not that's gonna be end of the party
right we're not going to have people
hanging around when the code blows up
like this so so as a result
as powerful as recursions are they
really lose their benefit when they
really are needed so this is where a
fairly interesting set of techniques
come in one of my favorite books is the
book called sicp
and it stands for structure and
interpretation of computer programs a
sort of hard book to read but but a very
useful book I think to read and in the
book they talk about a distinction
between a procedure and a process and
and a procedure is the code we write and
a process is the code that runs you know
obviously we could say isn't the code we
write the one that runs well we already
know that the code goes through a
compiler first of all a JIT compiler
comes in as well so there's quite a bit
of you know things going on between the
time we write the code and the code that
actually runs so essentially the idea
really is you you're writing a piece of
code and that gets some more transformed
and optimized for it to run and an
earlier I was trying to write us an
iteration so we can write it as an
iterative process or a procedure and
then we run it as a iterative process
but like you like you can correctly
mention while it may be easier from the
way that we are used to it's got the
problems of hard to parallelize hard to
Express over time so recursion is really
a benefit so we could write it as a
recursive procedure but then we could
run it as a recursive process which is
what we just did but unfortunately that
doesn't scale when the input size
becomes big it fails so what this book
that I mentioned structural information
of computer programs they talk about is
to use some compiler magic if we can and
to write the code as a recursive
procedure but then it gets transformed
into a iterative process and with the
covers and when we do this what appears
as a recursion to our human eye really
becomes iteration under the covers if
you're interested we could actually
compile the code and see how that looks
on the bytecode level to kind of get a
feel for it yeah no actually that would
be that'd be interesting
once we've
all right manic you want to make sure
it's actually working so in order to see
that it's working and to get faster to
showing you that example and then we'll
come back to this problem yeah let's
take a slightly different problem so
let's take a foo which is gonna blow up
on our here you know hands and let's say
n is going to be an integer and I'm
gonna write this as a very simple
recursion if n is equal to 1 I will say
throw new runtime exception and we'll
just blow up the stack otherwise we will
say n times 2 of n minus 1 so this is
going to be just a recursive call and
let's go ahead and call this method so
foo with the with the v value and and
see how this is gonna look like
that's an integer so look into this code
it blew up no surprise but I want you to
take a look at the top part of the
screen for a minute if you notice we are
fire levels deep in the stack yeah we've
got 5 called
an equal number of stack depth
- how many recursive calls we have
absolutely which is logical that's what
we would expect but let's change this
just a little bit now before that if you
look at this code the last operation we
perform in this code is is the multiply
so what that means is on one hand you
have the value of N and you're holding
on to it while you're trying to wait for
the result from the call to foo and and
so that's why you're climbing up the
stack but let's go back to this remove
this for a second this country would
example now we are calling foo but the
last call is foo itself let's just run
this code one more time but but you
would notice that there's a difference
in the in the output in this case I'm
trying to get the top part of this
visible here let me lower the font and
bring it out the point if you can even
zoom in and see is that you only have
one level of stack in this particular
case yeah so there's one level of stack
so notice how with the small change here
surely we didn't we didn't reduce the
number of recursions we're still going
through five recursions right yep but we
only have one level of stack in this
particular case and and the reason why
we have one level of stack in this case
is that the Scala compiler was able to
optimize this and say AHA you are not
holding on to any results on your hand
so I'm gonna make this call but only
after I step down from this function so
very quietly under the covers
Scala modified this from a recursion
into a simple iteration okay so if you
put the even if you switch the order of
operations it still happens later so how
would you put the x in back in yeah
we'll come to that in a minute let's
take a look at the bytecode that that I
wanted to show you first that way we can
kind of get a feel for how this is going
to look like so let me go back to this
code so we have this you know function
let's take a look at how this function
is going to manifest so if I say us over
here let's say Scala C and compile this
Scala code for a second this is this is
purely a iteration we have on our hand
up his one is complaining that he
doesn't want to compile it because it's
not part of an object we'll fix that so
object let's say sample we could
actually run the code and get the
bytecode and under it and see it but
this is much easier to do so let's
compile this code so this compiles a
sample class so Java P actually let me
do one more thing let's go back to what
we had a minute ago n n times right so
so compile this one more time so this is
the recursive this is the recursive case
let's go to Java P actually I got a
little shortcut that's got a mess of
things like that's not a bad idea so
Java P let's say look at sample so so
this is going to look at the recursion
there's no surprise here as you can see
it's a invoke virtual back from the call
to foo that's a recursion no surprise
there right yep let's go back to this
code remove the end star compile the
code one more time
and look at Java P this time this is not
quite let me make sure it's so Scala C
so this is gonna be sampled at Scala
it's making a liar out of me it's not
actually displaying the optimization as
you would expect let's go back and call
this guy actually so we can actually see
how this is working let's actually see
if I can call it from here sample dot
actually that won't work because I want
you to be compiled
but anyway so not sure exactly why he
doesn't want to show me this let me
actually do one more one more thing yeah
that's yeah that's the latest one so I'm
not sure why didn't it there's no call
site invoking it that it doesn't do the
could be let's let's put the annotation
on it just to be sure
so Scala also provides a tail call
recursion annotation that kind of says
verify to me that this is actually tail
call optimized the beauty of this
particular annotation is if your call is
really not recursive it'll give you an
error at compile so you got a compiler
support you can kind of assert that it's
actually gonna do the correct tail call
optimization on your code that's correct
so let's look at Java P look at sample
one more time and see if there's any
difference at all all right I give up on
that one oh this could be because
because this could be at a annotation
level so let's look at there we go
that's where it's hiding so let's look
at the sample dollar there we go it was
really hiding behind my back so if you
notice over here this here's the foo
function and but notice the interesting
thing that is a bytecode level
looping yeah right rather than being a
tail call notice there's no invoke
virtual at this I think you know
it's not what you read in the codes
there must be a bug in the compiler
we'll get them to fix that yeah so yeah
so the the beauty of this is the
compiler was able to optimize this for
us under the covers so that what appears
to our human eye as a simple recursion
ends up being a nice iteration out of
the covers so going back to your
question how could we use this for you
know doing the multiply actually I think
there is a interesting pattern here if
we want to call it as a pattern and and
that is if you have an operation you
want to perform after returning from a
function call turn that around as a
parameter an extra parameter to pass in
to this function so so going back to the
factorial example that we talked about
which is this is purely a iteration yeah
a recursion rather where it's going to
blow up the stack all right so you wanna
you're probably pass in the end and do
the multiplication that's correct so so
right in here we're gonna pass an extra
parameter so fact is gonna be extra
parameter we pass in and then if n is 1
we're gonna simply return the fact but
but if it's not we're gonna call the
factorial but this time we're gonna pass
to this fact times n so we kind of did a
partial product and then passed the N
minus 1 so this seems to be a recurring
pattern when I'm trying to convert a
recursion to a tail call recursion is to
take the operation you would perform on
return and then move this as an extra
parameter to pass in and then when you
do this of course this requires us to
pass an extra parameter to this but but
that can be used now to make the call
but but the beauty of this is if you
recollect it blew up the stack for a
higher number it's no longer blowing up
the stack but of course that gave a
value of 0 that's because it's an
overflow but that we can easily fix
using a big integer rather than being an
integer so
you know each of these guys can become
big end and of course that this changes
it to this becomes a big int and as a
result I think that should be a good
start to try this out and that's gonna
not blow up the stack not give us a zero
but really give us factorial for that
very large number so it looks like we
finally hit the point where your
machines doing work and there it is is
the factorial of that numbers so so we
went from recursion to a tail called
recursion this is only possible because
the function is pure it doesn't really
modify any data but but beauty of this
is recursions are back on the table yeah
that's that's kind of cool that you can
rewrite your recursive logic so the
compiler will actually optimize out and
give you iteration without you having to
change your program to be less
descriptive but that's you know that's
nice that Scala does that but what about
Java I mean so the this is what I was
mentioning earlier is learning different
languages really helps us and if nothing
else it uses a few bag of tricks on our
hand so before I answer that question
let me go around looking for an answer
elsewhere for a minute so this was
interesting to see how this is working
in Scala that
what about groomy so I kind of learned
something in groovy groovy does take on
optimization but but not by messing with
the compiler and and the way they do
that is pretty interesting they provide
this as an extra method on the closure
and a trampoline is a function they've
added on closure now of course groovy is
dynamically typed there's quite a few
interesting things you could do so for
example in groovy you could create a
factorial as as a closure rather than
being a regular function and and so in
this case you could say give me a
factorial and the N value same thing as
I wrote in the Scala site so I could say
for example if n is equal to 1 return to
me the factorial otherwise return to me
you know factorial times fact of N and n
minus 1
but you call an ethical trampoline on
this so a trampoline basically gives you
an ability to soso trampoline is a is a
call on a closure and it essentially
does something fairly simple and a
trampoline function says here you have a
closure go ahead and call the closure if
the closure returns back to you a
closure and return go ahead and call it
again in a while loop the minute it
doesn't give you a closure but gives you
let's say a data back then you have no
more calls to make just return the
result so so you didn't go through a
compiler support to achieve this instead
they decided that they can just do a
little trick at the function level yeah
and so this was pretty intriguing for me
because you could call this function and
it just becomes a while loop that
continuously makes the call until the
result eals an object and no longer
heals the closure to be called so anyway
I kind of looked at these two approaches
I was going to are struck by both of
these approaches on one hand the
compiler is doing the work which is
pretty nice yeah another Scala
the Scala style is kind of nice that the
compilers doing the work yeah but it
requires a specialized functional
language it doesn't know this is a
compiler support as well but on the
other hand I kind of looked at what
groovy is doing and I was pretty
awestruck as well because here's a
language that didn't go through the
compiler change but very smartly they
decided to do this at the closure level
so as I was playing with the Java 8 I
kind of asked myself the question you
know how would I do this on one hand
there's no compiler support right now
for tail call optimization so the answer
could be you know simply out of luck or
what if I can do something like groovy
does well it turns out GUI is a
dynamically typed language so there is
quite a few things they can do like for
example they can get a result and say
hey are you object are your clothes your
we can't quite do that in Java because
Java statically
right so so I was kind of baffled by you
know how really to make this work it
took me about eight hours of coding and
playing with things okay so like your
plane flight over here it's the end of
eight hours I had about 20 30 lines of
code to do tail call optimization and I
looked at it and I said this sucks I
really don't like it and then I came
back after about two or three days
looked at it one more time and I was
able to reduce that you know 20-plus
lines of code to about four or five
lines of code still I was not happy and
then I was on the treadmill one morning
you know jogging and it suddenly dawned
on me that I totally missed out on an
opportunity to do tail call optimization
I was thinking about this problem a
little differently I was thinking to
narrowly about how Scala and groovy is
doing but I could turn this problem
around just a little bit so I decided to
turn this problem around as a problem of
dealing with infinite lazy collection
and it turns out java 8 has an infinite
lazy collection and so let's think the
problem a little bit so rather than
thinking about this as call to a
function repeatedly let's set out and
say we're gonna make recursive calls
what we know is we're gonna make
reciprocals of calls what we don't know
is how many recursive calls we have
ahead of time that's something that's
unknown in the beginning in other words
we have a lazy valuation on our hand and
the lazy evaluation is you tell me to go
do recursive call and at that time I
will go in and find out how many calls I
have to make and I'll keep making until
I have no more calls to make so once I
decided to view this as a lazy
evaluation tail call optimization just
fell in place with about a few lines of
code so so let's see how we can do this
with with Java for a minute so let's say
we have a class here let's start start
with a sample class and I want to write
you know of method to do the factorial
let's say just start with an example so
let's say a big integer actually let's
do an int it's going to give us zero but
I think the conciseness of the code is
going to be important here so let's say
I want to do a factorial and the
factorial is going to take let's say a
value of n and and I'm going to simply
say if n is equal to one
you know return the value of one
otherwise return a factorial of n minus
one times n so so this is simple
recursion let's kind of get this past
first here so this is a let's make it a
static method and and let's go ahead and
call this right here so oh let's say so
let's say for a minute we want to call
this factorial and of five like we did
before so this is Java 8 using the
previous versions of Java syntax nothing
to do with Java eight at this point but
like we know if I push up that value we
blow up the stack yeah so same problem a
similar initial yeah exactly
so what do I want to do let's get back
to the value of this first of all so I
mentioned that I want to treat this as a
lazy collection so before we go this
route we'll come back to this there is a
stream in in Java
eight and a stream is an infinite
collection it's an interface it doesn't
do anything until you ask him to get
results so it's very smart in that he
would cash the evaluations and postpone
until you really invoke a method on it
so streams have like two kinds of
methods they have what are called
intermediate methods and terminal
methods intermediate methods will return
immediately saying yep it's done but
they don't do real work until you call
the terminal method when it runs really
all the way back and starts doing all
the work for you
okay so streams basically is a little
utility class if you will and we could
we could go to the streams
and in the streams we could call a
method called iterate and an iterate
basically is a function that returns to
you a lazy collection but what's really
cool about iterate method is it gives
you a infinite collection where you
start with the initial value and provide
him a generator which says how do you
get the next element in the list so I
could say one for example meaning that I
want to start with the value one but if
I want to create an infinite series of
one two three four five six how many
other I want to then I would simply say
given a value n return n plus one they
were using lambda expressions here but
the idea really is
you created an infinite series which
starts with one and keeps counting
forever now of course this is a bit
scary how do you create an infinite
collection but no work is really done at
this point until you ask him to really
do the work yeah and then you could
simply come back to him and say you know
limit ten for example and in this case
you're saying get me the first ten
elements so this would give you one two
three four and so on until nothing
actually happened yet but when you call
the limit get to happen so case that
actually gives you back the results the
vectors okay so at this point this would
give you the first ten elements what it
would do is it'll take this one feet to
this lambda expression which would
produce the value two
it'll then feed it to the lambda
expression one more time which will give
you the value three and it does that
nine times nine times because the first
value is already given got it so and
then it dawned on me that the answer is
right in front of me when I look at this
for doing tail call optimization and the
reason as this could be the first call
to the function I'm making and this
could be the recursive call to the
function I'm making and let the stream
do the hard work of iteration that it
already does so so to do this what I did
was I created myself a tail call
interface and in Java 8 has these
functional interfaces so I created
myself a tail call interface it's
actually fairly simple
there's the apply method which is really
the abstract method of this interface
this is what is going to get implemented
as the lambda expression in the code and
I have a yeast complete method and the
easte complete method simply tells me
whether my recursion is complete or do I
have to keep going further and of course
it is false
my recursion is not complete at this
time and I cannot ask him for a result
because the recursion is not complete so
I blow up if you call that function and
then I have a get function where I'm
using the iterate I just talked about so
notice what I'm doing here I go to the
streams I go to the error rate my
initial seed is this object itself the
one that implements this the next value
in my iteration is what I get from
applying this interface so in other
words we have a generator on our hand
but how far do I go I want to keep going
until I hit is complete is true so as
long as I keep recursing I'll keep
recursing until the recursion says stop
there is no more and so but by default
it's false so this will potentially go
infinite until somebody tells me to stop
we'll see how that is in a minute but
once it stops I simply get the first
value which is the terminating value I
get a result from it then I call the
result and notice the result will blow
up if I call it on the tail call but but
I boldly call the result because this is
not the tail call it's a terminating
tail call so so once we the real core
here is this part this is the part that
took me eight plus two plus a treadmill
to get to that one line of code from
2030 lines of code no mutability no you
know iteration explicitly here fairly
concise yeah actually this is a great
exam
of a functional style of forgiving as
well using functions like filter
applying them on collections that's very
um yep
Pascal asked it did on one hand I was
unhappy because it took me that long to
arrive with this on the other hand sorry
elegance solution it is so it you don't
you don't jump into elegant solutions on
day one I think it is something you
refactor into now how does this magic
work so I wrote myself a utility class
called tail calls which is fairly simple
again I think the call is purely a noise
it's simply returning the call given to
him and I did this just to kind of keep
the code simpler on the other side when
we look at it the real magic isn't that
done function the done function takes a
result of value and it's an anonymous
inner class of tail call where it says
is complete is true because this is a
terminating tail call and the result
will return the value you give to him
and then the apply will blow up because
you cannot apply this anymore because
you've terminated the recursion so
that's pretty much the code you could
tuck this away in the library and put it
in a utility function jar it up and
distribute it and that becomes available
to anybody who wants to use it they
don't have to go through any of what I
showed so they can start using this
alright yes it taking full circle
can you use your tail call interfaces to
solve the initial problem of doing the
factorial what yes so let's do that so
I'm gonna go back and change this now do
a tail call so my factorial is gonna not
return a result but it's gonna return a
tail call that will generate the result
eventually so what if n is equal to one
we're done so this becomes a done of one
but to indicate that by I'm done no more
tail call and to make this happen I'm
going to import tail calls dart star as
a static interface or we could simply
all tail calls start done right and
similarly this one here is the iteration
rather the recursion is still in
progress so I'm gonna say at this point
return a lambda expression for the tail
call where the says if you call me I'll
give you the next guy in the list so
that is the change I had to make to the
factorial to turn this into a tail call
optimization so having done this my
factorial simply says I'm gonna go
around and either give you are done or
keep going as long as there is more work
to do and so this becomes a generator
into the future for us to continue
working now the one of the benefits in
this case is if how would this work so
we give an initial value of n but lambda
expressions can capture their context
that that's what becomes a closure so
essentially these are closure of more
than land expression lambda expressions
and so this captures the context and say
is given a n I'm gonna return to you a
tail call which will do the next
multiply but when you call that this
will do n times but this has to become
the next tail call to evaluate at that
time but but you don't want to hold this
the stack at that point that wouldn't
serve the purpose so let's go ahead and
turn this into a factorial and then n is
going to be the next number to return so
this becomes the factorial I wanna
return when n is 1 and that this becomes
a factorial of fact x and comma n minus
1 so same as we did in this caller say
yeah so how would why would I use this
so to use this I'm gonna simply call
this and and say factorial of let's say
5 1 comma 5 rather and then we could say
if I go back to the tail call for a
second you will notice in the tail call
my terminating call is the get method
that's the one that actually does the
real work
so I'm gonna simply call the get method
and that should return the result back
to us assuming all that kind of went on
really well
Oh tail calls he doesn't know what tail
call says I'm gonna just use the full
Declaration of it because of the imports
here I don't have this in a package and
he's not happy with that but that's okay
oh sorry I forgot the call to the call
right because this should be wrapped
into a call so right there so I think
logically this is easier to follow
because when you're in a tail call
recursion you can say whether you're
done or whether you have more things to
do and that kind of nicely goes back and
forth I think in this call tail call
start call let's see where I'm messin
here uncheck the method invocation
that's not I'm not sure what that means
here in this context so so looks like I
upgraded a version of the compiler and
he's not too happy with some of the
upgrades I did here so I'm not sure
exactly what you know working with the
state of the art code can be a little
messy but that's basically the idea is
to go from a call to a tail call and
achieve that as a as a tail call
optimization so it would be interesting
to decompile this and kind of watch the
flow at a bytecode level and see how
it's all getting executed when you look
at the invoke dynamics and well the
betters the beauty of this is that
invoke dynamic magic would be at the at
the lambda expression level but for the
rest of the code we have back to our
good old programming with the objects in
a sense there's not a whole lot of magic
left behind at the compiler level except
for the treatment of lambda expressions
itself I think yeah yeah that's the
addition here yeah and also this this
relies heavily on Java eight so it's a
nice application of a new Java feature
absolutely and and once we tuck this
away into a library as a programmer you
don't have to go through the details of
all this hey you want to call tail call
optimization just wrap it in a done call
or a call then and you're pretty much
done
so so I think the the whole merger of
the functional style of programming come
together coming together and and having
that feature in Java 8 is incredibly
powerful I think so what do you what do
you think actually let me ask um
Anton's question first so Anton Erica
from Jay rebel out in Tallinn yeah he
he's actually wondering if there any
other languages besides Galois and
groovy which support tail call
optimization oh yeah okay well not jvm
languages but I was going to jump on it
Erlang certainly does very nicely a
closure oh so you got Serge APM language
yep so Erlang does closure does Scala
does did you know about some of the new
jvm languages
I don't think Cortland actually supports
right now I've kept up with it in the
past favors say well not that I know of
okay yeah but certainly closer than a
scholar does and of course we can do
this in Java now without the compiler
support right and say hello to him by
the way oh yeah yeah yeah yeah so the
other thing I was wondering is what do
you think the the overhead is of
creating the tail calls and the closures
as you go through the list it's a great
job
that's a great question almost
everything I have done looking there
Java 8 I have to say well to be fair I I
was a critique of Java and I'm still a
critic of Java I coulda sighs Java
anytime I get a chance
yeah but almost everything I've looked
at in Java 8 I've only been impressed
and performance is one thing that
certainly is a concern for me I have
played with performance to a certain
extent in Scala a certain extent in
groovy and I kind of know when to avoid
certain things because of performance
concerns with Java itself it's really
powerful in terms of how the
implementation takes care of this most
of the time so often time you are no
worse than
and in our class implementation but a
lot of times it's actually significantly
better because the Java specification
itself does not dictate a certain way to
do it leaves to the compiler to optimize
so these don't have to become inner
classes within functions these could be
easily optimized as a static function
within the classes and then you are
really looking at dropping this on the
shoulders of invokedynamic which then
really takes the hit the first time you
call it
yeah but then subsequent calls are
pretty fast for a high number of
iterations you're gonna get the benefit
it's exactly the case so especially when
you're calling this repeatedly you are
actually leveraging and and amortizing
the cost that you incurred so
performance wise it's actually pretty
darn good yeah actually I was chatting
with um Alex Buckley uh a couple weeks
ago and one of the things he was he was
pointing out about closures and lambdas
in the java language is since they well
they design and they write the JVM they
can go beyond what the JVM language is
sitting on top of the compiler do to
implement lambdas in closures and
actually do really really really
ingrained optimizations to get the best
possible performance out of it which all
the language all the jvm languages will
eventually benefit from but it gives you
more higher performance more consistent
semantics but that's one thing that I'm
really pleased about is rather than
rushing through to give a lambda
expression the approach has been to
really provide something that actually
performs really well it's concise so I
used to ask myself and I used to say
what do I care why do I want lambda
expression in Java I do have to say that
I stand corrected
I'm seeing a benefit for this now for a
couple of different reasons one is that
Java actually supports it and millions
of Java developers can use it right away
and the second benefit is that it is
really done well in a high-performance
way so other languages can bear
FET rather than having to go through
oddly anonymous inner class
implementations and having spewed out
hundreds of an atom's in your classes
static footprint so overall I think this
is definitely a step definitely in the
right direction I think cool yep
all right no this has been great having
you on our night hacking show thanks for
having me the shrinks very much and I
hope you enjoy the rest of the Jay focus
conference thank you
for folks on the livestream well first
of all for folks on the recording you
can catch the rest of the videos at
night hacking com
so check them out there and folks on the
live stream can watch more Jay focus
hacking we've got more interviews
another one coming up with Holly Cummins
later today we got the Java posse live
events and we'll also be streaming a
whole schedule of events tomorrow so
join us for that and I'll leave the live
stream running here so folks can watch
people run around the pavilion in the
meantime awesome</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>