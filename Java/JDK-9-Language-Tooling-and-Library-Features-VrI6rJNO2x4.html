<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JDK 9 Language, Tooling, and Library Features | Coder Coacher - Coaching Coders</title><meta content="JDK 9 Language, Tooling, and Library Features - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JDK 9 Language, Tooling, and Library Features</b></h2><h5 class="post__date">2017-10-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/VrI6rJNO2x4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello thank you for coming here today my
name is Jo Darcy I work in Oracle's Java
platform group and I'll be speaking
today about JDK 9 language tooling and
library features in case we don't have
time for Q&amp;amp;A at the end of the talk if
you tweet at this hashtag JDK 9 lying
tools libs I can answer questions there
the last slide of the talk will also
have a URL to the PDF of the slide deck
so this is Oracle's safe harbor
statement it lets you know you shouldn't
put too much trust in what I have to
tell you here today especially regarding
Ford looking statements however since
the talk is about JDK 9 + j TK 9 gist
ship there aren't very many
forward-looking statements in this talk
it might get a bit repetitive seeing
Oracle safe harbors statement throughout
the conference
if you want some tips for alternative
safe harbors in the area I'll be happy
to provide those afterward a quick
survey before we get started which JDK
train are you using in production are
there any very early adopters on JDK
nine yet
I'll let's understand well how about
who's downloaded the JDK 9 JDK alright
that's good maybe some more people after
the talk or after the talks at the
conference will download it JDK 8 in
production alright almost everyone JDK 7
alright about a quarter did ek6 one or
two stray hands now now we're all
friends here so who who will admit to
using JDK five or older in production
still all right a few honest people in
the audience yesterday those are great
releases but we have a main many
features as since then so hopefully
you'll be able to try those out soon
overview of JDK 9 as I mentioned a JDK 9
just ship recently a few weeks ago like
the last few JDK project it was
developed under the auspices of open JDK
so if you're interested in participating
that development following the mailing
list trying out the builds you can find
more information on the open JDK website
throughout this talk I'll be using a
term JEP JEP is it JDK enhancement
proposal these are documents we use for
feature tracking in the JDK and if you
go to the open JDK page for JDK 9
you will see a long list of the Jets
they're about 90 jets we won't be
talking about all of them today but
besides many jets JDK 9 had many bug
fixes this is a comparative chart of a
number of bug fixes in 9 vs 8 so as you
can see JDK 9 has almost 20,000 fixes in
it which is slightly less than twice
what JDK 8 had so a very large release
all around including jigsaw
functionality and many other features
we'll be talking about
so no talk about JDK 9 would be complete
without some mention of modularity
project jigsaw project jigsaw was a very
large feature and the modularity
functionality from jigsaw is to make
programming in the large easier modules
bun together at one or more packages as
a unit of reuse and offer it stronger
encapsulation than jar files one reason
jigsaw was a large project was because
it required changes throughout many
aspects of the platform the language
tools and libraries the language changes
for jigsaw include a new kind of file a
module info Java file which declares
dependencies between modules Java C was
updated to support that new kind of
source file as well as to find
dependencies through modules there are
corresponding updates made to the Java
command and the hotspot run time to
understand the modularity restrictions
and there were also API changes those
API changes include updates to the core
reflection and the language model to
model the new aspects of the platform
now there's much more to be said about
modularity than can fit in a single 45
minute session for that reason the
jigsaw team has 5 45 minute sessions
here at JavaOne some of these have
already occurred they may be being given
again later in the conference so you can
check the scheduling app for that and a
few other sessions are later this
afternoon or later in the conference for
this talk we'll start next by talking
about our approach to stewardship of the
Java platform then we'll talk about the
tooling language and library updates
while some of those features are pretty
distinct sometimes a feature will
involve more than one area and if we
have time at the end some Q&amp;amp;A
so the stewardship the approach we use
for stewardship for the JDK is very
different from the stewardship approach
used by say Denethor and their current
the Kings films who was the steward of
gondor the number one goal of the Java
platform group for the last seven and a
half years has been to keep Java vibrant
part of keeping Java vibrant means
keeping the things that work today
working tomorrow
so that topic is compatibility so the
fundamental policy we have about the JDK
is managing compatibility in a sensible
way the general ushion policy is we
don't want to break binary compatibility
as defined in the Java language
specification that means we want
programmers that link today to be able
to link tomorrow we want to avoid
introducing source incompatibilities
that is where programs stop compiling or
if they compile they compile they mean
something different and we want to
manage the behavioral compatibility what
a method does when you call it now this
philosophy applies to the API changes we
make in the platform but it also applies
to the language features we have for
instance because of this policy we still
recognize old version 40 5.3 class files
generated by Java one at Oh over 20
years ago we limit the cases where legal
stowed code stops compiling in newer
platform releases and we want to avoid
changes in the semantics of code
generation when recompiling so as with
any sort of compatibility policy one of
the trade-offs here is finding the right
balance between stability and progress
so we have three kinds of compatibility
source by any binary and behavior both
behavioral and if we remember back in
physics class we could grab the graph
this is a three dimensional diagram and
different kinds of releases have
different kinds of compatibility regions
that are acceptable so if we take say
the security update releases those
quarterly releases that come out four
times a year they have a very small
region to make changes there's some
behavioral change of course because we
want to fix the vulnerability and maybe
there's a little bit of source
compatibility for a JDK specific API if
we have a larger release such as the
update releases like 8 you xx and 8 u 40
the
was a much larger so they have more room
for behavioral change and more
opportunity to make source changes
however in both of these cases there is
no room for binary and compatible
changes we don't want to break people or
update release because we want people to
use those update releases as soon as
they come out for a platform release
like JDK 8 GA or JDK 9 GA the situations
have been different there's the maximum
amount of rooms make behavioral changes
and more room to make source changes and
in exceptional circumstances with enough
justification there's even the
possibility to make some binary
incompatible changes I'll mention a few
of those that were made in JDK 9 later
in the talk this is an example that
helps illustrate the compatibility
policy and how applies to different
releases so if we look at the
specification for hash that dot iterator
it says you get back in iterator and the
elements are returned in no particular
order that means according to the
specification we can change the
iteration order at any time in any
release and still obey the specification
so how does this change square with the
compatibility policy well this would be
a binary compatible change because we're
not altering the set of methods it's
also a source compatible change because
the compilation of a client doesn't
depend on the internals of the method
body so you can change the method body
and that won't change whether or not the
client compiles however this is a
behavioral compatibility change and we
know people can in do implicitly and
sometimes accidentally rely on the
iteration order therefore this is the
kind of change that we generally
wouldn't make an either kind of update
release but we would make and have made
in a platform releases and the reason
we'd make it in a platform release is to
take advantage of say better hashing
algorithms so this is the terminology
for compatibility just used in the JDK 8
and JDK 9 release guides and
compatibility documents so I recommend
you look at those when you look to
migrate to those those releases so how
is JDK 9 different JDK 9 follows this
same model of looking after
compatibility but to support modularity
a larger compatible
compatibility impact than usual was
allowed include including some notable
behavioral incompatibilities for for
example if you're using a tool that
assumes the existence of RTR you'll have
to update to a newer version of the tool
that doesn't rely on that because RTR
has gone away it's no longer in the JDK
9 image those that information is stored
differently to support modularity there
are even a few cases where he broke
binary compatibility there was an
unfortunate dependency between the
logging framework in between Java
desktop so we don't want to suck in all
of Java Java desktop anytime you want to
use logging and we fixed up I getting
rid of these property listener methods
that weren't crucial to the API later on
in the talk are also talking about the
more muscular deprecation policy we have
with better tools to manage the
transition going forward so now we'll
start talking about some of the tooling
improvements and the first of those
tooling improvements is J shell Lisp
systems have generally provided a read
evaluate print loop as the primary way
you interact with that system so you
type commands and system evaluates that
it gets back to you similar
functionality is found in Ruby and
Python and on the JVM ecosystem
languages also Scala groovy and closure
so what about Java well now in jdk 9 we
also have a rebel and the repple is
called j show I'll do a quick demo of
that the right window up here
alright so the J shell is a new command
in the JDK bin directory so we'll get
that started here so there are commands
and J show of Eli backslash so we can do
help intro as it suggests here and we
get some guidance on using the tool but
if we're using a new language
environment what's the first program you
want to write hello world so we can just
start typing hello world here and we'll
see what happens
now we get back hello world now that's a
nice thing to have not not very
complicated but notice we didn't have to
deal with public static void main string
all those things so if you just want to
do some informal program and get started
you can do it right away
so besides expressions we can define
variables in J show so let's say we
wanted to find a double variable named
tau when you want that to be equal to
twice pi so we know there is a pi
constant in the math class so we start
typing math we can get autocomplete here
these are the alternatives so we can
pick math and then if we look in math
where the variables begin with P we see
there's pi there and if we hit tab a few
more times we'll see that we can get the
documentation for pi and we can see it
is indeed the constant we're looking for
course fields aren't very interesting on
the by themselves you also want method
so we can say define a method name
square that takes a double and returns
the square of it
in besides Auto completing on elements
of the JDK we can also autocomplete on
fields and methods we've defined
ourselves so we can say take the square
of the sine of tau autocomplete and we
have some command line editing so we can
cut and paste that so if we square the
sign in square the cosine is something
we should get something close to one and
that is indeed what we get in this case
and then we can exit out of the show so
going back to the slides here so this is
good for students there's less ceremony
getting started but J shell is not just
for novice programmers it's helpful for
experienced programmers too if you want
to start exploring using a new API like
the new API is in a JDK 9 I found J
shell helpful myself and help publicly
prepare for this and other talks so J
shell has snippets those expressions as
well as Java commands the J shell
implementation is interesting it
leverages many existing JDK technologies
including the compiler API and the
debugger API and there's a user's guide
to help get started now while we might
not have Taco Tuesday at JavaOne we do
have J shell Wednesday so tomorrow there
are 4 talks about J shell the first of
these is by Robert field who is the
architect and lead engineer of J shell
and if Robert hears you like J shell he
might show you how to invoke a nested J
shell from within J shell so you can use
a ripple while you're using a ripple so
and if you don't catch Robert stock
there's other ones to catch here next we
talk about a few changes in Javadoc so
for many years a Java doc has output
HTML 401 a few years ago html5 was a new
standard and now Java doc has a option
to output html5 instead of the older
HTML 4.01 and this is the version of
HTML we use for the jdk documentation
now people might have seen the doc lint
checks in JDK 8 these are checks you can
run from Java doc or from Java C to
validate the Java doc comments
we added some more configuration options
to dockland in particular to select
which packages you want the checks to
apply to so in the JDK build for
instance we primarily checked the Java
and Java X packages because we want the
documentation we published to be free of
these sorts of problems the document
checks range from the syntax of the HTML
tags their semantics and you can enable
and disable them individually if you
haven't finished clearing one category
of warnings from your build yet in terms
of the implementation of the doclet the
doclet api is very old it leads back to
or very early jdk s and with the benefit
of hindsight the API modeling the Java
language could be improved since the
doclet API we actually have several
other reflective api's and the platform
that are better suited to allow language
evolution
so we've reimplemented the standard
doclet on top of a job X Lion Model API
which is supported in the compiler so
this gives us a better base for a Java
doc improvements going forward another
feature we have is a javac search and
I'll go back to do a demo of that
so this is a download of the JDK nine
Javadoc there are few changes to notice
one is that it's divided in a few
sections that are just analyzed Java SE
documentation there's also documentation
for JDK specific classes as well as Java
FX altogether the frames view is still
available but it's not the default and
if we scroll down we'll see that the
primary organization is done by modules
so we have all the Java C modules then
the modules that are in the JDK and so
forth
and at the top right hand corner we have
a search box so let's say we're
interested in finding more about math
this is a math so we we see here that we
get back search results over package
names as well as type names and field
names and from here we can navigate to
those sorts of things now we know in
Java sometimes the names are very long
that that's part of the convention so if
we wanted to find say the equals ignore
case method that would be a lot of
typing but we actually don't have to
type that all out because the Java doc
Search reports camelcase sirs so if you
start typing EQ and then IG we can get
the equals of North ignore case method
straight away all right we'll go back to
the slides
so the implementation is in JavaScript
in the client so you don't have to go to
the server for that if you wanted to
find your own index terms there's a tag
to allow you to do that as well
what it does currently is it indexes
over the names of the you know modules
packages types and fields and so forth
the next two features will are designed
to ease getting from one JDK release to
another the first of these is cross
compiling with the - - release flag -
Java C so for many years the advice of
the Java C mamta age and in blogs i I've
written and others have written has been
to cross compile to an older JDK there
were three things you needed to do you
have to set the source version to the
older release the target version at and
finally the boot class path to the older
release people didn't always follow this
guidance so we get a flow of bugs in
there and we wanted to do something
about that a related policy change was
to limit the range of source and target
values we support in Java C starting in
JDK 8 we don't support all the way back
to the beginning anymore
we support the current release and in 3
back so in JDK 9 we support 9 as well as
8 7 + 6 + 6 is deprecated because we
find to remove that the next time we
remove a release and something similar
will be done for JDK 10 which is
probably gonna be called 18 not 3 or one
of the subsequent releases now why do
you need to boot set the boot classpath
well let's say we have two versions of
the JDK here and there's a library in
the first version there's a foo method
that takes a double and then as an
optimization in a later JDK release we
had a full through method that takes an
integer so that's a perfectly compatible
change according to our compatibility
policy and let's say we have the client
library here that uses foo and we
compile it against JDK n + 1 so which of
the two foo methods is the compiler
going to choose for foo 1 2 3 4 it's
going to choose the food that takes an
integer that's the most specific food
version and that's what language
specifies okay so what happens if we
take that file compiled against JDK n
plus 1 and we run it against JDK n we'll
get a runtime error or something like
this no such method error what the
detail message of the error here is
saying the
is looking for a food that takes an
integer but it's not finding one it's
not finding one in JDK and because it
isn't there there's only a food method
it takes a double so this is the kind of
problem people can run into when the you
don't said the boot class path when you
cross compile so since we still had this
problem we talked about am a java c team
we added a warning if you didn't set the
boot class path when you the older
versions we did that back in jdk 7 but
the problem still persisted and we were
talking about on the team and we said
you know what we know what people
actually want to do here they just want
to cross-compile to the old version so
why don't we just let them do that
directly instead of having to set these
three variables and that is indeed what
we've done now with the Java C dash -
release em flag semantically it's
equivalent to setting the source and
target to the older release as well as
the MU class path however the
information about the class path is
available to Java C so this is shipped
as part of the JDK in a compressed
fashion so you don't have to manage that
kind of state to yourself anymore a few
advantages of this you don't have to
worry about managing those old RT jar
files yourself if you use maven plugins
like animal sniffer that's meant to
prevent using wrong API as you should
have less need for that
another advantage if you're doing this
across compilation is you might be able
to take advantage of newer compile
idioms in Java see their bug fixes in
Java C and sometimes there are very
large performance improvements one of
the projects we had in Java C and JDK 9
was called tiered attribution which
helps speed up type inference in some
sorts of situations
so the steeply rising curve there was
the JDK 8 runtime in seconds and you'll
notice it's a log scale so it is getting
quite slow quite quickly for these very
small programs that we're using type
inference in a particular way so a
straight line on a log scale is
basically exponential growth so that's
not very good if you want to have a
scalable compiler environment so we want
to do something else so we re-engineered
how inference worked and we got these
much faster lines on the bottom so we
both get that using Jade Java Sea from
JDK 9 and we get that sort of
performance using
the Java Sea from JDK 9 using - -
release 8 so if your cross compiling to
8 you get the benefit of the
re-engineering we've done in the newer
compiler the next feature is multi
release jar files so it's inconvenient
if you want to package up a library for
distribution to make one version of the
library for different versions of the
JDK so typically you'll compile for the
oldest JDK you plan to support and then
distribute that instead so if you
actually want to use the features in
newer JDK it's a bit awkward and from
our perspective it slows adoption of the
new features of the JDK and we of course
want people to use them so sometimes you
can get around that by using reflection
to test for the new api's but that's
kind of slow and awkward and the
modularity features put in 9 make some
shouldn't be used api's that are so
tempting to use some of those some not
somehow the star api is out of reach or
harder to get to so what's the what's
the alternative
the alternative here is multi release
jar files in a multi release jar file
there's a shared common area across the
releases and then there directories in
the meditative air iya that overload or
provide version specific class files to
be used in particular JDK releases so
for instance there's a subdirectory for
JDK 9 and then you use those files when
you're running on JDK 9 as opposed to
files you'd use on JDK 8 there are a few
things to do with this one thing you can
do is you can create a jar file that
acts as a regular old jar file on JDK 8
and earlier but acts as a new modular
jar file on JDK 9 you do that by having
the module info doc class files
available in the nine specific area you
create these multi release jar files
using the jar command and we've updated
the other API is that consume jar files
Java Java C and jar seiner to be multi
release aware there's tooling support
for creating multiple East jar files and
and maven have documented ways to do
that and recently Trisha ghee posted a
demo code to create an altar release jar
files and IntelliJ so you can check your
local to tool documentation for details
next we start talking about the small
language changes that were made in JDK 9
back in JDK 7 we had a project called
project claim that added
a dozen small language changes for the
platform and for three of those changes
we have some cleanup work we wanted to
do of work we couldn't quite finish by
the end of JDK 7 so those are the top
three here project lambda which was
added in jdk 8 also had a few small
items to clean up so we kind of group
those together and also fix those in JDK
9 the first of these is safe varargs on
private instance methods
so back in jdk 5 or 6 we could write
code like this we have a list of list of
strings and we want to help initialize
that using the arrays list platform
class so if you were careful about your
compiler warnings you notice you get a
warning like this warning uncheck
generic array creation for var X
parameter of the array saw Tesla's
method so what's going on here this
warning is mandated by the Java language
specification and it's letting you know
that something bad might be happening
the something bad is called heap
pollution which would be a violation of
Java's type constraints and if the
arrays dot s list method was malicious
and not implemented properly it could be
causing this kind of heat pollution
however in this case nothing bad
actually happens already it's not as
listen the platform is not a malicious
method so this errors are false positive
it's uninformative so uninformative
warning messages aren't good
so we addressed this problem back in jdk
7 by adding the safe varargs annotation
type and the safe varargs annotation
type lets you tell the compiler that
your varargs method is not in fact
malicious and it shouldn't warn people
about it so this does two things both it
removes warnings when you declare the
large method and more importantly it
removes warnings every time people call
the varargs method so we applied this
annotation to arrays that as lists and
the other appropriate message in the
platform because of the design of
annotations you can annotations are only
in heret Adhan classes not interfaces or
methods therefore the safe varargs
annotation can only be used on methods
that can't be overridden so what kinds
of methods can't be overridden final
methods static methods also constructors
which from a certain point of view are
just very special static methods so are
there any other
kinds of message that can't be
overridden there are private methods and
we forgot about those ones in JDK 7 but
now we've changed the specification in
implementation to also allow safer RS on
private methods so if you have such a
method you can now use the annotation
line the other next change we made deals
with the try with resources statement so
just as a quick refresher you have your
resource are being managed and behind
the scenes the compiler creates a
implicit finally block for you to call
closed on the resource as long as it's
not null now in full disclosure the
actual code the compiler uses is a bit
more complicated this is the actual to
sugaring here the extra complex
complexity is to give better exception
handling but we don't have to worry
about this the compiler takes care of it
for us so in JDK 7 the resource being
managed had to be a fresh variable
associate with the tribe earth resources
statement that wasn't the initial
proposal however originally you could
use any expression with the right type
which was Auto closable meaning closed
method was there but we found there's a
problem using that so let's say we
initialize our resource R to a new
resource object and then within the try
block we make our point to a different
resource object now we come to the end
of the try block and what are we
supposed to do which object is supposed
to get its closed method called well we
decided we didn't want to have to solve
this problems and the way we decide not
to solve it was to require a final
require that new final variable as part
of the drivers resources statement but
this was actually a little bit stricter
than would need to be so if we already
know that the some resource variable is
final or effectively final why do we
have to declare a new fresh final or
variable to take care of it there's
really no reason to do that and that is
indeed the change now we've made in JDK
9 so if you already have a final
variable you don't have to make a new
one you can just reuse the one you have
so it makes it try our three sources
statements a bit more concise
Dimond in anonymous classes that's the
next feature we'll be talking about
so back before JDK 7 if you had your
list of map of strings integers you'd
clear the variable and then in the
constructor call say ArrayList you'd
have to repeat list of map of string of
integer that was a bit for both so now
you can just have the diamond and the
compiler will infer those type arguments
for you
this was very effective at removing the
need for explicit constructor type
arguments however due to a bad
worst-case interaction we have to forbid
using diamond when you were using
anonymous inner classes the problem is
in the worst case the compiler could
infer something called a non de notable
type
this is a type outside of the type
system we can use as programmers but
exists inside the compiler and the
problem is if you have an anonymous
class that needs a class file and part
of the information in the class file it
needs is the type arguments and if you
have a non notable type inferred it's
outside what you can write in the class
file so that's bad so in other cases
though if you get a D notable type infer
one of the normal types we usually deal
with that could be represented in the
class file so we noted that we had to
forbid Dimond and anonymous classes
working together at all in seven but
when we were finishing up a project coin
we said it's feasible that in the future
we might remove this restriction in the
case when you get a D notable type and
you avoid that worst case and that is
indeed in fact what we've now done in
JDK 9 so as long as you don't get that
worst case outcome you can use diamond
with anonymous classes too in JDK 7 a
diamond got let us get rid of about 90%
of the explicit constructor type
arguments and we feel with the this
cleanup for the notable types we can
address much of the remaining 10% we've
had good experience using this feature
in the JDK codebase it's let us get rid
of hundreds of additional explicit
constructor arguments in our code next
two features are from project lambda so
underscore is no longer an identifier
name back when lambda is added in JDK
eight you could use underscore as the
the parameter name for a lambda that was
to avoid confusion with some features
from other programming languages like
wunderbar from Scout Scala Java Steve
started noting though that if you're
using underscore in other circumstances
as a data file you might not be able to
use them in the future and now that
future has arrived you can no longer use
underscore as a variable name in a as a
jetty k9 so this is not our usual policy
but why are of keeping code compiling
but why are we making this change
well we think there's better use for the
syntactic real estate of underscore a
single underscore for a variable name
and that work is being discussed in a
future JEP JEP 3 or 2 lambda left overs
which is part of project amber one of
our ongoing projects in open JDK finally
we have a private interface methods
another part of project lambda in 8 was
adding default methods that interfaces
these are methods on interfaces that
have code so they're not the abstract
methods we had before and at the VM
level it's possible to have private
methods on interfaces in 8 these were
necessary to implement lambdas however
you couldn't do that in the source
language and now in Java 9 you can you
can have both private static methods on
your interfaces as well as private
instance methods so what you do with
these methods you can use them as helper
methods for the other default method you
have any interface the public method so
this is again very very convenient to
have once you start adding default
methods to your own to your own
interfaces so you may have heard at the
keynote earlier about the new six-month
release cating cadence were
transitioning to for the JDK one of the
benefits we think will have from this
release cadence is that these sort of
small language changes we delivered more
quickly and they won't be backed up
behind a large I which changed before so
we're looking forward to that to get
these sorts of small language cleanups
available to developers sooner their
number changes we made to the language
in related to deprecation the first of
those is deprecation and imports like
any old code base that's been around for
a while at times we had some technical
debt in the JDK
and in years past we've had several
hundred deprecation warnings in the
build of the JDK itself now these
warnings are again mandated by the
language specification and there's three
ways to resolve those deprecation
warnings you can remove use of the
deprecated elements that's preferred but
you can't always do that you can
propagate the deprecated annotation to
the youth sites that's not very good
either because now you're making more of
your code deprecated so if you can't do
either of those you can suppress the
warnings to let the compiler know to not
warn you about that anymore so let's say
you had your client library on JDK 5
through 8 and it was used some
deprecated type in the JDK you compile
this and you get your duplication
warning so I figure no problem I have to
keep using this type so I'll just put
that suppress warnings annotation right
at the top of the class and this will
take care of everything
right now unfortunately if you run the
compiler again you'll notice you still
have a deprecation morning so what's
going on here the warning you're getting
now isn't from any of the code of the
class it's actually from the import
statement at the top and this is
mandated by the Java language
specification you might say well that's
not a problem I'll just apply another
suppress warnings annotation that
doesn't work either you syntactically
you can't allow that so while this
warning may be very thorough and well
intentioned it's really unhelpful if all
the uses all the other uses of the
deprecated type can be covered by the
suppress warnings annotation it seems a
bit silly to force you to do something
like use the fully qualified name of the
deprecated type everywhere just to avoid
this warning so we decided that was a
little little unnecessary and we've
updated the language specification to
not require a deprecation warning in
this location and because of this
language change it is now tractable to
clear a code base of deprecation
warnings and we have an existence proof
of that by clearing the Java based
module and the Java desktop module
amongst other modules in the JDK of
deprecation warnings so if you have such
warnings in your own code base I
encourage you to look into them and try
to try to get them under control now
there's a bit more to say about
deprecation there's been
here's some confusion about deprecation
what does it mean is it deprecated
because it's harmful is it deprecated
because it's going away and if it's
deprecated because it's going away well
I haven't you JDK guys removed things
yet so we wanted to give more
information in this situation and we did
that by enhancing the information
available in the deprecation annotation
type there are two new methods added one
of those is a predicate for removal that
defaults to false so if something is
deprecated for removal true that means
in some relatively near future platform
release we plan to remove it you also
can add a string for the since release
that something was first deprecated
we've updated the deprecation
annotations in the core platform to have
this for removal information and their
supporting updates made in language
specification java c and java talk also
there's a new static analysis tool in
the JDK called J deeper scan that
analyzes class files and rar files for
the use of api's that were deprecated in
the jdk so we have how do these
deprecations including for removal
deprecations so you don't have to
recompile your code though to find out
though if your jar files are affected by
it you can just run j deeper scan on
your jar files instead and you can find
out what's going on next we'll talk
about some of the library updates that
went on in the release first of these
was the new version string the one dot
in 1.8 and 1.7 and so forth has gone
away so if you run a version on your new
download of JDK 9 and it'll just say
it's version 9 and it's you know build 9
+ 1 81 don't get too used to this though
because the version scheme will likely
change again instead of JDK 10 we might
have 18.3 maybe it'll be X or JDK a
we'll see in the coming once what the
final name is but we won't the 1 dot
won't be coming back so if you have
tooling that checks for this it'll have
to be updated if you use Java to talk to
native OS processes there's some
additional API elements to control those
more directly including getting the pid'
a few interesting features related to
strings the first of these is compact
strings where
without any user intervention if your
string doesn't require any of the high
bytes to be nonzero it'll use a one byte
per character representation as opposed
to the old one care one car per
character of representation if you do
need the high bytes that it'll use two
bytes instead so this can give you a
better memory usage for your
applications especially ones using
strings and you don't have to update
your application in a way to take
advantage of that the second feature in
destroy into five string concatenation
is a good example of a feature that
crosses all of the VM the language and
well as the compiler like Java see it's
a very common operation in the Java
platform to concatenate strings together
Java C happens to do this usually with
string builder calls and then the VM has
to notice this idioms used by Java seen
other compilers and kind of try to
optimize that accordingly so since this
is such a common operation instead a new
stable entry point was created in Java
lieing invoke and the intended user of
this API is not programmers but it's
compilers like Java C so there's a very
straightforward way compilers can take
advantage of this to communicate with
the VM and lets the VM have easily have
know the semantics of the code and
generate faster code as a result so this
effectively adds a new JVM capability
without having to define a new bike code
there are a number of updates made to
the security libraries the general
security policies who want the JDK to be
secure out-of-the-box
I mean who wanted to restrict broken or
weak cryptographic algorithms and
protocols now as a cryptographers become
more clever and computers become faster
which algorithms are weaker broken
varies so Oracle's published a crypto
roadmap for the JDK where we announce
ahead of time when certain algorithms
and protocols will be deprecated or
removed from the default set because of
those reasons on that is a document that
does get updated as a situation change
if you highlights this to you at the
Security api's in nine by this secure by
default policy the default key thises
for RSA were increased and so forth also
certificates with weak keys are no
longer accepted by default there are
some system settings you can use to
still have those certificates accepted
if you need them my colleague Sean
Mullan gave a talk about making the JDK
more secure that covers the JDK nine
security lives features in more detail
and the video for that talk is already
up from the conference there are also
updates to the client libraries and FX
in the release like other parts of the
JDK the FX code base most was modulized
they were updates to graphic support in
various in various ways a few notable
projects the marlin graphics render
replaced the previous Pisces and ductus
renderers this removed one of the major
remaining behavioral differences between
Oracle JDK and open JDK so now there you
know the JK's are using the same
implementation code in both
circumstances and for the photographer's
who also used Java there's now support
for TIFF images including the exif
metadata there are a number of talks
about the client libraries at JavaOne
and you can see them listed here few of
miscellaneous library treats as well
first of these is convenience factory
methods so how many times have you
written code like this right at the end
you want to have an unmodifiable set of
strings so what you have to do today you
you know have your half set you call add
add add and then you have the collection
set unmodifiable wrapper that's a bit
verbose for a simple operation so there
are other things you can do you can use
code like this instead where you
initialize the hash set using arrays dot
as list and then you wrap that that's
still a bit long there's also the double
brace it IAM which we won't even show
that some people use so but you don't
have to do this anymore in jdk 9 now you
can just write this
set that off and then what you want to
initialize the set to and what you get
out of this is a unmodifiable set of
strings so this idiom is supported on
sets list in maps and it approximates
the functionality of collection a little
collection little rules collection the
rules were one of the features we looked
at for project coin and JDK 7 but we
didn't have time to do this is a good
way to get most of that functionality at
a small fraction of the complexity to
the platform now we mentioned that the
hash that thought iteration order and
people relying on that unknowingly these
new collections will discourage that by
having a random iteration order sets and
sets of maps not for the list so every
time you create these you'll get a
different iteration order which will
make it more difficult to rely on the
iteration order when you're when you're
using them and for more information my
colleague stuart marx gave a talk about
this feature earlier this morning if you
use Java util objects for common
functionality we did add some methods
there as well some additional null
checking in index checking methods some
of these have intrinsic support from the
VM few odds and ends I am interested in
math so we've had the fuse multiply add
method add it's at the platform this is
a hardware instruction that's becoming
more and more common it allows you to do
two floating point operations with only
one rounding error and it's good for
some numerical tricks and this again has
hardware support on many platforms that
we have intrinsic for those also there
are some array comparisons for likes
graphic array those have also been
intrinsic ID and if you're interested in
things like var handles which is a
common for a concurrent programming
using things like C++ Atomics those have
been added to the platform as well and
my colleague Paul Santos gave a talk
about those at a conference the JVM LS
conference in 2015 there's some other
survey talks about JDK 9 at the
conference if you want to hear other
people's takes about what's what's good
there the first of these JDK 9 hidden
gems focuses more on the VM
performance aspects of the platform in
the video for that is also up online
already
so in summary JDK 9 was a very large
release we've made some fundamental
development changes with modularity but
the changes weren't limited in
modularity we also finished long-planned
improvements to the language from
project coin in lambda and if you're
interested in following future
developments you can do that in open JDK
and you can download the JDK 9 bits to
try out now so with that I think I have
time for one or two questions right so
the question is how does the - - release
flag interact with - source and mask
target and the answer is Java C gives an
error if you try to do both so you can
do one or the other you either have to
do - - release where takes care of
everything or you can use the source and
target Flags explicitly the tools will
have to change the support it yes all
right well I think I said thank you for
coming you today</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>