<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java SE Embedded HardFP ABI Support for ARM Processors in 7U40 | Coder Coacher - Coaching Coders</title><meta content="Java SE Embedded HardFP ABI Support for ARM Processors in 7U40 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java SE Embedded HardFP ABI Support for ARM Processors in 7U40</b></h2><h5 class="post__date">2013-09-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/adrZDsRXmq4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to the screencast edition on the
Java SE embedded hard FP ABI support
I'm Roger brink in this edition of this
screencast we will actually be covering
the new support for hard floating-point
ABI which has come in seven u4t but
before we do that let's turn first and
let's take a look at a Java SE embedded
overview so it really is where we're
talking about Java SE embedded what is
it so Java SE and Bennet is is really
the java standard edition implementation
optimized for embedded devices we're
talking about a reduced static footprint
somewhere around the neighborhood of
sixty percent smaller than the standard
GRE for instance if you're looking at an
x86 Linux environment of Java SE 76
we're talking about 42 mega bytes
instead of a hundred and forty megabytes
additionally there's reduced memory
requirements that occur here so for a
headless system we're talking about 32
megabytes in a headful environment 64
megabytes that are required for the
memory to be able to execute in this
environment and you can configure this
in either a headless or a head full
configuration the architectures that are
supported the hardware which is
supported are the ARM processors the
PowerPC processors in the x86 the key
part is is this is a fully Java SE
compatible system and finally it's free
for development but there's a commercial
license which is required for deployment
now let's take a look at the Java SE
embedded shipping products or the
products that are shipping currently in
the before today the previously
supported platforms and releases and as
you can see here there's the arm v6 and
v7 you can either have it in a headful
or headless state in both cases those
are using the vector floating-point
which came into existence during the
kind of the arm v6 and v7 time period
the arm b5 is actually using the vfp as
well but it's using the soft FP in
environment now actually when we're
talking about all of the ARM processors
those are all using the soft FP a B eyes
also additionally there's
implementations that are for the power
pcs and for the x86 environments so why
all this hard FBA bi fuss if you go back
in history and you look at things from a
historical point of view you find out
that on the embedded systems a lot of
them had no floating-point units so
we're looking at the standard arm b5
chips there really didn't exist a
floating-point unit there wasn't the
otherwise known as the of the vector
floating-point when it comes up to arm
v6 and v7 that's where vfp started to
come in and and floating-point units
were added to the hardware to some of
the hardware in this point so that's
where vfp started to come in so that you
could start using this and either they
created something called the soft float
now a variety of the OS and the tool
change and native apps were supporting
soft float ABI now soft float was good
because you could run this on ARM based
systems that either had vfp or didn't
have vfp and that made it kind of
convenient from that particular point of
view
eventually linux platform started to
come in and and they started support the
hard FP api now what this meant was if
they're actually going to use the FPU
registers all the time in order to do
that you have to have a system that is
going to have vfp on it and so that's
why only the systems that have that will
be able to run these Linux platforms and
the tool chains that are supporting the
hard FP API and then the last piece was
why it's such a fuss is as more and more
of this started to come together to
while the developers were requesting
hard floating-point API support now that
doesn't mean that there wasn't a lot of
support that we had for floating point
vectors if you look at the difference
between soft floating point and hard
hard floating point ABI the first thing
to notice is that the CPUs actually
support a floating-point instructions
and it doesn't matter which one of the
API ABI use that you're going to use
area it does happen that now if floating
point arguments are passed native to
native
soft floating-point API there passed on
the stack and what that means is we have
to do some conversions that occur to go
to the floating-point unit registers
whereas on the hard floating-point API
they're just passed on the FPU registers
the part that's interesting here in why
Java actually performs better than a
native application if you're running on
soft FB API is because when you're when
you're talking about passing
floating-point instructions between Java
methods then it is used on the
floating-point registers the other part
is is that when you're converting
between a a java virtual machine and a
native then obviously on soft FP api
it's gonna go on the stack just like it
was if it was a native native
environment but on the hard FP api
you're gonna go to the FPU registers
what this means is that when it comes to
floating-point intensive apps such as
games and graphics it's gonna be a
little bit slower than it is on the soft
api then and it's gonna be much faster
and on a hard FP api so what's the
announcement that's coming out today
well Java SE embedded su 40 now has full
support for hard FP api for the arm
platform for version 6 and version 7 and
in fact is if you look at the download
page you're going to see this page
exactly the way it exists right here and
you'll see these are the java oracle
java SE embedded version 7 update 40 and
you notice here the first three entries
are for arm six and seven and then the
last one is for arm seven now this is
for a headless or a headful environment
or the other one is for the arm seven is
for the the server environment in all
cases it will use the hard FP ABI a
question you may be asking yourself is
well okay
but what if I'm sitting on a system that
has a soft API that's arm arm six and RM
7 and we still support that those are
still there they're still about valid
download that you can get as you can see
here same set headless client headful
client headless server or arm v 5 as
well so the key part
there is no what the underlying platform
the supports are the underlying hardware
supports when you're going to download
the oracle java SE embedded software and
of course we also support the stealth
support the PowerPC and the x86
architecture well what will all this
mean for developers well the first and
foremost this is the first officially
supported Java SE embedded release with
hard FP ABI support now this will run on
arm v7 as well as arm v6 that's
important because one of the more
popular RB sixes that is out there right
now is a Raspberry Pi you have the
ability to have the card FP support for
the Raspberry Pi now now there have been
other test environments or evaluation
environments for Java SE 8 that
supported hard floating-point API but
this is the first officially supported
Java SE embedded release that you can
use on the arm v7 s and r b6 that have
the floating point support secondly
you're gonna see a lot more om usage so
if you're you if you're writing code
that goes on to an OEM platform and that
OEM platform starts to convert over to
the hard float ABI then you're going to
be able to leverage that and we should
be able to see some speed increases our
Java business mark speed increases that
we're seeing around 5 to 8% improvements
now remember we talked about this and
that's actually a lesson what native
apps are going to get and that's the
reason for that is because we're already
doing some floating within a java
application we're already doing floating
point to floating point conversions so a
native app doesn't have that advantage
it's it's going off to the registers and
then it's it has to do the transfer to
the floating point unit once it gets
there of course results are
application-specific and and they will
vary based upon how much code you're
actually doing an in floating-point the
big key in all of this is that you don't
have to do any code change there is one
exception to that
that is if you're passing any code to
native code you may have to make some
changes in your native code to be able
to run on hard FP and that means that
you're going to have to conditionally
compile because if you're still running
any of this code on a soft FP
environments are hard where you're going
to have to be able to have the option of
being able to do one or the other to be
able to compile one or the other now
here are some of the popular arm and
embedded systems for developers the one
on the left is a Raspberry Pi a very
small type of processor about the size
of a credit card cost is about $35 plus
whatever you would card for a power cord
the one on the left are the one on the
right is a free scale environment the
imx6 q certainly much more processing
power as it has a one gigahertz
quad-core ARM Cortex a9 processor and
one gigabyte of RAM which is built into
it so you've got a great deal more
flexibility in this you know your
mileage is gonna vary it depends on
where you want to put these and and what
environments you're really trying to put
these in as to what will guide what you
want to use but either one of these
platforms will support the hard FP both
of them have the hard fpn of the
software and they will support the new
releases that we had for hard FP in Java
SE embedded here's some resources that
you'll be interested in when it comes to
looking up more information about this
java SE and been at home where you can
find the downloads the various system
requires for java SE and benetton and
then there's the java SE e embedded
community actually it's the java
embedded community as a whole it covers
both ME and SE and you can find a
variety of information if you're working
on embedded platforms and then finally
there's a a new website that we have out
called the Oracle Internet of Things
platform this will give you a great
cross section between the ME platform
and the SE platform thanks for listening
to this screencast and remember make the
future Java</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>