<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java 8 Lambdas Hacking | Coder Coacher - Coaching Coders</title><meta content="Java 8 Lambdas Hacking - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java 8 Lambdas Hacking</b></h2><h5 class="post__date">2014-02-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7vYr12vlwrA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so this is Steven Chen for
another night hacking interview we're
going to be chatting here during the
break at Jay focus and discussing Java 8
and lambdas and my my guest here is
Venkat super super minion and you need
no introduction just recently wrote a
book on Java 8 lambdas which is in beta
right now and you're also a very
prolific speaker throughout the world
well thank you
so you've you've been doing a whole lot
of work with with lambdas but one thing
which I think I get a lot of questions
about is why why do we need lambdas is
it gonna isn't it just going to make
things harder and it's more more
difficult for folks to understand what's
the benefit I think that's uh if you
really look about look look at languages
out there today we ignoring Java for a
second
there's no mainstream language today
that doesn't have lambda expressions I
mean for crying out loud even C++ has
lambda expressions I was gonna give you
like the original C C - well okay
III take your points the mainstream
languages attack you sure you know C++
is really I considered them to be a
combination of C and C++ and in a way
the biggest change in Java is going to
be in the minds of the programmers this
is very high time but to answer the
question what's the real benefit and the
real benefit is that lambda expressions
do correctly a lot of things we have
been struggling to do we all know this
very well
mutability is evil when you look at
mutability we have done mutability in
java for a long time so mutability is
something we're used to sharing is not a
bad thing remember what mom told us
right sharing is good but shared
mutability is pure evil and the minute
we bring shared mutability all kinds of
things happen and even when we deal with
mutability as smart as us as
as human beings we are not good at
juggling things so when we change the
state we easily introduce bugs in code
so the functional style of programming
the functional paradigm really is a sign
moonless programming okay okay so so
your your arguments is about kind of
style and correctness of programming and
how you write I've heard other people
expounds that it's all about performance
well being able to take advantage of
multi-core system so which do you think
is the real well what should Java
developers care about make it work make
it better if my code is broken how does
it matter it's vastly broken right so so
my first argument is let's get the code
correct yeah in in or in a way when the
code becomes less error-prone easier to
express easier to write that code is
easy to make concurrent that code is
easy to improve performance a badly
written code with bugs is not easy to
maintain so I would say I'm not ignoring
performance you cannot have a good
solution to these problems with our
performance but that's not where I want
to start that's where I want to end so
when I can have a cleaner code that's
easier to express easier to maintain I
can get to a better quality code and as
a result I can okay so we've been
chatting for a while and you're you're
claiming that it's easier to write
correct code with Java 8 yeah can you
show me an example of this I'm gonna
start with extremely trivial something's
very trivial when you look at a piece of
code you want to understand what that
code is weighing very quickly and and
the word I want to start out with if we
can start with this word here I want to
start with the word Sri morning
nobody likes ceddy morning ceremony is
what you have to do before you get to
really do what you really want to do and
then we can see this in kids kids don't
like ceremony right they're gonna have
fun Oh what programmers are the same way
you want to get directly to what we want
to do so let's take something extremely
trivial
say for a minute I have a thread and I
have to you know that's a thread class
and sure in 2014 nobody will create a
thread class like this will you do
executor services but ignore that for a
minute let's keep it extremely simple
now I want to start a thread so what
would I do i would say thread darkstar
and then i'm going to launch a thread I
would say thread joy in in this case -
as the trip to Spain oh finish up and
I'm going to simply say over here let's
say in Maine and when I'm done with it
I'll just simply say it done so I want
to try this out but of course I got to
give the code for what I want to do in
this other thread well
let's deal with one ceremony real quick
here we got a deal with exceptions and
I'm just going to throw that in there
because I don't care about that
exception well what about this though
we're going to say new runnable and then
we do this around a bowl I'm gonna say
public void run and within this run
method I'm going to say in another
thread like that so if I try to run this
code and see what it reduces we can see
that it says in Maine that other code
was run in another thread and then we
can see the done happening but if you
look at this code what I really wanted
was this one line of code which I wanted
to send off and run in another thread
but in order to do that I had to write
this part and I had to write that part
that's what a nice ceremony
that's a ceremony right and in a sense
the more complex code becomes the more
fluffy and ceremonious it becomes when
you have a lot of ceremony around you
and you've got a spark of idea and say
hey cool why don't we try this and then
you say oh no you know what
in order to try that brilliant idea I
got alright all that stupid code and if
you would note if we won't take any
offense what we are using here is called
anonymous inner classes I went I want to
call anonymous inner classes as missed
opportunity because in Java 1.1 we had
this opportunity to introduce land
expressions instead of using anonymous
inner classes
we have an opportunity to fix that
missed opportunity so what we can do
here is notice a highlighted part what
are we really saying here we're saying I
want to send to another thread of
function I don't want this function to
take any parameters so the essence
starts right over here everything before
that is a ceremony you and I don't care
about the word run we care about what
parameter are we sending so I'm going to
strip out everything before that
ceremony then I'm going to come back
here and say when that parameter is
received I want to do this operation and
I'm going to remove everything to the
right of that ceremony so we took Java
code and we made it lighter than we had
before and the court still works so my
question is why are we adding fluff when
a simpler code actually can work so in a
sense rather than using an anonymous
inner class we're using an anonymous
function yeah this function has no name
we don't care we can let Java infer the
return type we brought it to the essence
we set here as the parameter that I'm
sending to this function in this case
none and here is the body of the code I
want to execute so so most of us would
argue functions have four things right
we got a name we got a parameter list we
got a return type and the body well name
is not important the body is the most
important we have that highlighted the
parameter list is to the left of the
arrow and of course the return type is
inferred so we got down to the absolute
essence all right so you got to the bear
essence now something I think a lot of
folks struggle with when they first try
lambdas yeah and you can you can help me
out with this you're going to teach me
this so you went from an anonymous inner
class to a lambda and the program
behaved the same but a lambdas not the
same as an anonymous inner class so one
of the difference is like what do I have
to watch out for when I start converting
my code to lambdas that's actually a
real
good question if you look at this code
for just a second and and if you were to
tell you ourselves let's kind of get rid
of some of these guys just to understand
this part better if you look at this
part a minute ago we had a runnable and
right off the bat we converted a
runnable into a instance of ground
ability to a lambda expression so our
initial side we may feel like oh this is
just a syntactical sugar we replace the
lambda expression where anonymous inner
class was expected but that observation
is bit naive when Brian gets talks about
this as let's go home for the dinner
solution where we could have they would
have done something like this and that
landed them in a lot of trouble and the
reason is this so if you go back to
runnable for a second and if you had
written for example the run method as we
did let's ignore the the implementation
for a minute and now there's a problem
inherently in this code so to understand
this let me get back here to my
directory here to see what we have on
our hand so let's take a look at what we
created when we compiled this code so if
I go back and this code doesn't produce
any output but let's take a look at the
what we have here on our hand if you
look at the class's directory you will
notice that ignore all the other things
I have in this example I got sample but
notice sample dollar one yes well if I'm
going to use anonymous inner classes I
might have replaced this goal very
easily with something along the lines of
this little code with just a little
implementation of the lambda which means
I would be prompted to use a lot of
lambda expressions and if those were
really replaced by just the anonymous in
their classes in my code so every lambda
expression I use would turn out to be
something like this well if I try this
to go through and try to do it this way
well actually let's go ahead and remove
these thread for a second part of me
here so
for where to go through and implement it
this way let's just go ahead and say I
want to copy this over well the code
basically compiles but we got a bigger
problem on our hand if you look under
the hood now we got several anonymous
inner classes yes no that's that's quite
a lot of static footprint you're adding
tier well not only is it a static
footprint now you are overheating the
virtual machine because it's got to
start loading up all of these yeah and
that's would be impact on performance as
well not to mention other problems
however the beauty is this if I go back
to this code for a second
and replace this with lambda expressions
and let's just say here you know just an
empty string for a purpose so if I were
to use many of these now so notice even
though we were able to replace the
lambda expressions where anonymous inner
class was used a minute ago now if I go
back and look at it there is quietness
all those inner classes we had went away
so what's really happening well in order
to understand what's really happening
let's go back here for a second and look
at Java P and with the minus C option
which is an alias on my machine and
let's look at the sample class well what
ends up happening here is when we are
making the call to that function it
results into an invoke dynamic so it is
in a sense a feature that was introduced
as I like to say as an act of kindness
for dynamically typed languages and it
being the fundamental feature for
supporting lambda expressions that was
like a person I think I think you might
be misinterpreting the order of events
there okay tell me so you're you're
assuming invokedynamic came along to
help other people and then they're like
oh this would be useful for lambdas I
would assert it might have happened the
other way well with that that's probably
a debate to be had with the people but
you get marked answer that question yes
I would love to hear that absolutely
um but really is this right because Java
7
and lambda expressions I'm sorry uh
invokedynamic way before so we should
maybe call him and ask him and and to me
that that was the aha moment is that a
feature at the bytecode level becomes so
vital to implement this feature so
what's really happening here what it
what happening here is the compiler can
say I can rewire this call directly to
the Met that I'm implementing rather
than going through the overhead of
creating an anonymous inner class and
routing the call to that instance and
and so it's a lot more than syntax sugar
even at the bytecode level and
definitely also at our programming level
as well from the API point of view yeah
yeah no it makes a huge difference and
I've decompiled jvm languages Java six
and previous and if you look at the
amount of classes which get generated as
a result of lambdas and other
abstractions they provide you will be
surprised at how bloated some of your
bytecode gets
yep they're true okay so that's one
difference between the lambdas version
and the original is there anything else
which is what so here I mentioned in the
beginning that the biggest change in
Java
eight is in the minds of the programmers
yes so we have to rewire our results if
you really think about it there's not a
whole lot of syntax to learn I think we
could learn the syntax within about an
hour to two hours but to use those
syntax to rewire our mind to benefit
from this is where the real benefit is
for example you know a common operation
is to read certain content from a from a
directory let's say I want to process
the members of the current directory how
would I go about using you know those
information so for example let's take
the current directory itself so I'm
going to say over here let's say Java
dot IO dot star and over here I'm going
to go ahead and say bring the current
directory so we'll say over here current
dur and equals new file and elect
mention the current directory itself and
I want to loop through and find all the
files in the current directory
so we could say file we could say
children
equals and in this case let's say
current directory dark list files well
once I get the list of files I could use
the traditional form loop to iterate
over each and every you know element in
this collection so I could say file we
could say for example child which comes
from children and then we could maybe
just output maybe a child dart let's say
you know what just output the file
object itself
let's keep simply put this code is
looking like something very familiar
like I might have written a thousand or
a million times nothing to be proud
about but we've done it so many times
but here's one of the key differences
when you look at a for loop a for loop
gives you that there there are so many
levels of details hidden in this if you
look at a for loop a far look gives you
exactly what you asked for
look through sequential e in fact if you
notice this there is one huge
fundamental difference we all want to
claim that Java is oh right but if you
look at this code the word is oh right
because if you look at the for loop this
is not polymorphic at all it says I am
gonna do what I do on the collection you
give me well in a good opportunity
language we would use polymorphism and
what's benefit of polymorphism well
polymorphism says go ahead and call the
method focus on what you want to do
separate or leave yourselves of the
details of how you will do it this code
says this is exactly how I'm going to
loop so as a result this doesn't give
the flexibilities of concurrency and
performance we talked about earlier well
let's see how we going to do this a
little differently so rather than going
through this we could try a very small
difference we could say for example
children
so we could say stream off let's say
children so I'm getting a streams
in Java 8 is a is a very fancy elevator
so we got a stream object so of course
for this I'm going to include over here
a you till dark stream and now that I
have a stream on my hand I'm going to
stay dark for each and I'm going to use
the lambdas that we talked about so file
and I'm going to simply output the file
that we have on our hand so in this case
we took the traditional form loop and
revert it to something very simple which
is simply a for each statement to do
that now it looks like a very small
change but the benefit is phenomenal
I'll tell you how it's phenomenal to
understand this let's say for a minute
we have a static method called process
file where this takes a file as a
parameter just for us for illustration
purpose and then within this let me just
print the file so same change as we did
before so right here
rather than calling this system dark out
I'm going to simply forward this back to
process file and send the file over so
if I had written this as a regular for
loop you'd have done the same thing as
well however the beauty of this is if
this code were to take a little bit of
time let's say so dry and then let's say
thread dark sleep let's say this is
going to take a second to run and just
over here and now if I run this code you
can see it is taking a while to respond
because it's taking the time to run
through all of these you can see the
beach ball spinning now I mean a lot of
cases when you're doing stuff with file
systems or networks or things it's
there's delays and absolutely so but you
come along and say wouldn't it be so
easy to make this concurrent oh yeah I
remember there was this fork/join you
here's this complicated inter-class
thing and before joint is awesome for
what it does but for us to use it I call
it the tax on programmers right it is
something you have to take the burden to
write the code and when you're done
you were nice little for loop is no
longer a nice little for loop it's
turned into a monster in front of you
well how about this we could just say
parallel if I know how to spell parallel
dark for each and now we are asking you
to do it one this as a parallel
collection rather than as a sequential
collection so in other words go back to
the code we had a second ago we had this
a second ago and this was taking the
beach ball and the spinning and all I'm
saying here is now that we realize we
can do this quicker in a multi-core
processor a rather than spinning through
the beach ball why don't we simply ask
him to do parallel so parallel on this
and then we can fire it out and you can
see that the result is going to show up
right away that's a huge difference
difference not a big difference in the
amount of code you have to write to do
it so the programmer you'd probably be
more likely to use fork/join having a
convenient mechanism for applying it
with lambdas right and at the point I
really like about this you're a fluid
writer the point liked about this is
they didn't make concurrency implicit
they made it explicit I called it the
master switch so you had to flip the
switch so you as a programmer is still
in control but once you flip the switch
you didn't have to struggle to modify
the code structure so I don't know I
think that you said that we wanted to
get down to kind of the simplest in the
most elegant way of writing it but that
that lambda still seems like a little
bit superfluous okay so you're you know
you have a file and then you're passing
it to Beth and you're passing the file
is the parameter well if you are into
patterns I have a name for this pattern
yeah notice how we receive the file and
we pass the file here yeah my favorite
name for this pattern is called the
office based pattern office yes
remember in office baisemeaux week Tom
what do you do here I take the
requirements with the business people
and I give it to the programmers so
that's what this is doing so we can
quickly say he
sample process file and replace that
with a method reference and that can
remove for the ceremony in cases as
simple as using the Alpha space pattern
I like the pattern yeah I'm happy now
yeah I got I guess the JDK team did okay
well they did wonderful in my opinion on
long brings us for that good enough yeah
that's that's very all get now and what
excites me about this is the ability to
express our ideas to me programming is
these transitions of aha ideas do seeing
them implemented and removing ceremony
from the code is a way that can get us
there well Java will still have a
certain amount of ceremony no doubt
about it
right because that's the baggage we have
to carry with us but for the new
features we got a lot less ceremony than
we used to and I think that's a very
welcome sign and and this is something
that the Java programmers out there
don't have to say well we can't do it if
they're willing and you know interested
in improving their skills they can reach
out and write really good quality code
so here's here's a different line of
questioning and so you're in this
example you're showing us an existing
JDK API which they've applied lambdas to
make simpler right but how do you see
other third-party or open source or
other projects applying lambdas to make
their own API simpler I think there's
going to be an explosion of feature set
that uses lamp xpressions moving forward
and with into a in two main areas the
first is let's take existing methods
that API is right now one of our people
already have out there so if somebody
has a method let's say for example I've
got a method we call it
foo
for a minute and my method foo is
accepting some receiver whatever that
receiver is going to be and all I'm
going to do within this is a receiver
Dart
let's say call that's all I'm doing now
what in the world is this receiver we
could say for example interface receiver
and the receiver has a method let's say
called call and of course that's an
interface so if I want to call that
method that I have right here the Foo
method so I'm going to call foo imagine
this is an existing library that was
published let's say in Java 1.5 I've
been around for several years
well I can't today come and call this
method I could have said new receiver
here and I would have said void and I
would have said call and then I would
have said something like you know called
here well I can right off the bat take
that very code and I can replace it with
just a lambda expression without any
change whatsoever to that but that that
class library existed before lambdas are
part of the language that's correct but
the when you recompile your code right
here the Java compiler says oh you have
a single abstract method interface and
whenever you have a single abstract
method interface those are called
functional interfaces in Java and
normally in Java 8 you would say
functional interface but this is
optional and they very tactfully made
optional because they want to take
existing interfaces that are single
abstract method interfaces so your point
is that a lot of third-party libraries
you can already use lambdas with
absolutely right off the bat yeah but
the next level of improvement is going
to be where the third-party libraries
say hmm rather than returning a
collection back to you why don't I
instead receive a function from you and
apply the function on the collection I
have so in other words we
being exchanging objects back and forth
now we begin to think maybe we shouldn't
exchange objects instead we should
exchange functions yeah so libraries
will make sure to receive functions
rather than objects and that gives us
lazy evaluation capabilities okay so
let's say I have an existing API and I
want to add some new methods to my
interface which now accept functions yep
but I can't I can't do that well you
keep you already can because we just did
for example right off the bat who was
receiving a function and if you know
this
we passed a function okay so that that
works but if I want to add a new
function absolutely you would have to
either define your own interface yeah or
you say why do I care about a new
interface and Java itself provides some
really useful interfaces one of them is
called consumer where a consumer simply
swallows everything you give it so if
I'm designing an API a library which is
supposed to give you control to do some
stuff but I don't expect anything back
from you then I will design my method to
receive a consumer as a parameter on the
other hand if you're going to give me a
logical A's evaluation of whether I
should do some work or avoid that work
then I'm going to send you a predicate
I'm sorry you're going to send me a
predicate so I'm going to expect a
predicate back from you but on the other
hand if I want to apply a strategy
pattern where I have some work cut out
for me
but in the middle I want to yield
control to you and say hey could you do
this part and give him back a result
then I'm going to give you a function
where the function would take in some
argument do some work a unit of work and
give back a result that I can commute
processing so they've already laid the
groundwork worth's of common patterns
absolute functional interfaces so one of
the things I realized was the design
patterns we are used to programming in
Java just became lightweight yeah
strategy becomes a couple of lines of
code
decorator pattern can be implemented
without writing a single additional
class but using lambda expressions so it
gives a new birth to these patterns in
terms of lightweight implementation and
that is exciting to look at the code
evolve right in front of us and and that
is pretty encouraging in my opinion okay
so getting back to my question about
libraries you probably see them evolving
to take advantage absolutely unplanned
evolving in two ways one we will evolve
to use them in a much more lighter way
already without them doing any work and
the libraries will evolve to start
receiving functions but rather than
objects and then that will give lives
evaluation and other benefits as well
well exciting times for sure yeah yeah
no definitely so what's the response
been like about you know you've been
speaking and talking about lambdas do
you think the Java development community
is ready for this I think that it's like
wildfire um I saw in Java one last year
they were if my count is right six to
eight talks on lambda expressions every
single one of them was packed people in
long lines they couldn't get in and and
so Java it was a huge appeal in the
conference I've been speaking in other
conference since then yesterday I had a
workshop and the room was packed with
close to 300 people in there so
absolutely we were actually competing
against you with a lab and our lab was
packed while your workshop was packed
that that is the that is that shows the
excitement people are having about this
of course there are a large number of
people who are also waiting for Java
eight to actually share but with with
that being so near I think it's
definitely going to be a big win I have
no doubt about it
and and also in all the books I've sold
I'm seeing a huge interest for the beta
of my book as well relatively speaking
more books being sold in the beta than
I've ever seen before so a lot of
interest in folks reading about and
learning
the absolute starting to apply it even
before the release is out absolutely
okay so so I was going to diverge topic
slightly from lambdas anything else you
want to cover and live this what my my
sedition is it's a it's a better way of
programming so here's one thing I want
to mention before we leave this topic
this is not a newfangled idea this has
been around for a good 40 50 60 years it
is new to Java not new to programming
and and so the wrists are extremely
minimal it's a tried out method it's
another step in the right direction and
it's high time the programmers actually
make use of it and I'm excited that they
have the opportunity to do that in Java
today ya know it's a good point so what
I wanted to ask you a bit about is Java
8 is lambdas plus a whole bunch of other
things what else are you personally
excited about um my Java 8 release to me
more than lambdas there are two other
things that are pretty interesting in
Java 8 I'm more interested in the
language features that's what I focus on
yeah not including other things one is
streams now when I when I started
digging into Java I would say lambdas
are the gateway drug streams are the
real addiction because once you taste
the stream you are going to be in it for
a long haul because the power of streams
is simply amazing the way they provide
function composition the way they
provide lays evaluation
their way they provide parallelism it is
amazingly cool so to me more than lambda
expression lambda expression is just
what draws you in stream is the one
that's going to keep you in yeah even
though the stream API is simply a
an API built using lambdas as a feature
my guess is for a lot of people those
will be inseparable in terms of how they
think about it absolutely I totally
agree and the other one I think is
fairly interesting though we still have
to figure out whether it's going to
become a pattern or an anti-pattern use
the default methods oh you mean uh
multiple inheritance well yes
at least it doesn't give you the problem
of multiple inheritance but it's
something that I think is easy to abuse
and I think there is a bottom line use
case where it can be useful yeah and
then that tipping point is really quick
and then we can get into a huge abuse of
the feature so I think for what it's
worth it's useful but we have to be very
careful using it as well I think but
those are the two things that excise
resolves it solves a real problem for
API designers absolutely it lets you do
migration rather than rewriting api's
because now you can add methods to
interfaces but youyou think some people
are gonna cleverly abuse it though of
course I mean a good idea does
programmers I would do that are you
going to talk about our session on that
maybe nix your references other works
maybe next year absolutely I'm sure
they'll be options for in different
patterns and talk about the experience
we learn from it yeah like that's that's
how people learn you have to show them
what not to do
well sure we learned by doing what not
to do as well and then we say oh that
was not a good idea let's not do it
absolutely cool yeah so I want to thank
you very much for the short interview on
the J focused stage here it's always a
pleasure thank you thanks for the
opportunity thrilled to all this talk to
you and yep thanks for having me and I
believe
you have any more sessions upcoming I do
I have one on table 8 today and multiple
languages on the JVM tomorrow yeah and
then I'm doing a week long I'm sorry not
a week long two days Java a deep dive
training on Thursday and Friday as well
cool
very good thanks very much pleasure
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>