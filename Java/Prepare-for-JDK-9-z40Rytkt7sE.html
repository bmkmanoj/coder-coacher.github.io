<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Prepare for JDK 9 | Coder Coacher - Coaching Coders</title><meta content="Prepare for JDK 9 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Prepare for JDK 9</b></h2><h5 class="post__date">2017-10-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/z40Rytkt7sE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to JDK 9 my name is Alan Bateman
I work in the Java platform group in
Oracle a long time JDK contributor so
this session is prepared for JDK 9 um so
I'm going to start by just a quick poll
of the audience just to see how many
people have downloaded and tries JDK 9
ok maybe about a third of the people so
for those that put up their hand how
many people tried out their application
or libraries and everything worked
perfectly not too many hands how many
people that put up their hand a few
minutes ago tried us and we're grumpy
for the rest of the day because
something broke same hands alright
you're in the right session this is the
list of features that are in JDK 9 this
is a screen capture of the all the list
of jep's jdk enhance for proposals that
you'll find on the open JDK mjd canine
project page this big long list of
features this session is not about all
of these features I will cover a couple
of the features but I'm not going to
exhaustively go through all of these
features instead I'm going to be mostly
talking about the issues that you might
run into and when you start preparing
and thinking about moving to JDK 9
there's a lot of disruptive changes in
JDK 9 my colleague Alex Buckley um wrote
the foreword for the book Java Java 9
modularity and in the foreword he
likened the changes in JDK 9 to be a bit
like the the tablecloth trick
we've got cups and plates stacked on the
table and you pull the tablecloth out
from without disrupting the plates and
cups but in Reverse
there are some very deep changes that
have gone into JDK 9 so the big
challenge is to do the tablecloth trick
in Reverse without disrupting the cups
the plates and the heavy power tools
that have accumulated on the table over
the last 20 years and there are a couple
of little breakages and that's the top
of things I want to talk about today so
this session is is actually the first of
five sessions that we have in the
modularity track where since you track
within a track and talk about those
later on at the end of this of this of
the session so before we get into the
into a few specifics I just want to talk
about just the general compatibility
policies and if an application or a
library uses supported api's and works
on release in then it should work on
release in plus one even without
recompilation supported api's can be
removed but only with advance notice so
let's see how we do on jdk 9 relative to
this policy the compatibility policy
that has existed for several years I'll
start with the good news the classpath
has not changed class loading has not
changed you are not forced to migrate
your code to modules I've read a lot of
articles and postings by people that
think that you're forced to move your
and migrate all your existing code
modules in order to move to JDK 9 they
are confused ignore them you may have
heard of Sun Muskaan safe you may not
use it directly in your code but the
chances are some library that you use
that you have on the class path today is
using Sun Muskaan safe it works as
before most existing code actually just
works as before
as we go through this presentation
you'll actually see there really isn't a
huge amount of code changes involved
final point on on the good news is all
the mainstream IDs maven and all of its
plugins are most of its plugins they
already have support for JDK 9 their JDK
9 ready
and quotes um by last week when we
eventually shipped JDK 9 so that's the
good news
the not-so-good news which is a nicer
way of saying the bad news you will most
likely need to upgrade many of the
libraries and the tools that you use if
you are directly using some of the
libraries that are shared some of the
API is that are where there's a there's
a version for EE and a version for Java
C but they're the same library but there
aren't they're not exactly in sync if
you're using those directly you may have
to do some adjustments to your build or
your class path I'll talk about that in
in a few minutes
a number of supported api's have been
removed
they were deprecated sometime ago and
they were removed we're talking about
six methods from the Java C API which is
not a lot we remove those right in the
first build of JDK 9 several years ago
nobody has complained so I'm not gonna
bother covering them in this
presentation because obviously know
people don't really care about them
there's a number of non API features and
some some tools have been removed and
people have not complained about them so
I'm not going to cover them either
because they're not significant things
you will see some warnings possibly and
printed by the runtime because of things
that libraries are using are doing I'll
talk about that in in in in this
presentation so dive into a couple of
items first is the modules that are
shared between Java SE and Java EE so
one of the things about the Java Sea and
the JDK is is that it it's assimilated
many technologies and over the last
couple of years and so a bit like the
board some people have likened it to the
Borg and many years ago where it
assimilated many different cultures and
technologies and while they didn't show
it in any episode of Star Trek I'm
pretty sure that the Borg actually had
regrets from time to time the JDK did
too
this is the Java C module graph if
you've been to Java one before you've
seen any our presentations over the
years on modules you will have seen that
we worked through over the years from a
spaghetti diagram to a relatively clean
directed graph that you see here there
are many modules in this that originally
were standalone technologies or lies the
the the font is small in there but if I
were to look I'll easily spot things
like Java management that includes GM X
that was a standalone technology at one
point I see Java naming that was jndi
and a standalone technology at one point
what we have open the right side of the
the graph is a bunch of modules that
overlap with Java EE and these have not
been completely subsumed so I'm going to
I'm going to start putting a little
label I'm gonna use a black star to
label these these api's are never fully
subsumed in into Java C and you will
actually see that these become
problematic api's when you're moving
from eight to nine because of because of
this overlap so I've put a black star
over four api's that are two of them are
really trouble to them are less trouble
but they're they have equal problems two
of these two of these modules bring
along a body that you have activation
module there's no business being in Java
C but it has ends up being a standalone
technology outside of the JDK and being
in the JDK at the same time like these
four other modules very very problematic
I'm also going to put a black star
against the core of a module and the
reason for that is is CORBA has been a
whipping boy for modules for the last
number of years but the real reason of
course is that korba is actually
dependent on one of these problematic
modules it's dependent on the
transaction API where Java C defines a
subset of this Java EE defines a
that the full API and there's a really
really problematic area and when you
move to modules so this business of
being inside the JDK and outside of the
JDK and at the same time is essentially
technical debt for the JDK and when you
move any big codebase to modules you
probably run into some technical death
this possibly is unique to to the JDK
and but it's still technical data that
we have to somehow figure out you can't
override modules in the JDK by putting
jar files on the classpath you can't
override modules in the JDK by putting
jar files in the indoor standards
override mechanism because that
mechanism has gone the only way to
override modules in the JDK with newer
versions is through the upgrade module
mechanism which is a new mechanism in
nine and only if the modules are aligned
with the modules that you have SE
defines and this is where we have the
problems with each one of these modules
so this is this is a topic that has been
we have been mulling over for a long
time and fundamentally what's happening
is is the JDK was the delivery vehicle
from from any of these api's its 2017
now there's no reason for it to be the
delivery vehicle for these api's each of
these api's has a standalone version and
there's no reason why the jdk needs to
to really have them so the proposal a
long time back in java c which was
eventually accepted was the deprecated
each of these modules and here are the
six here's the names of these modules
Java Korba which is the core of API and
an RMI ILP the driver transaction API
which is the biggest troublemaker in in
the lot here in that because Java C
defines a small subset of the
transaction API to have activation
because it has no business being in here
Javik smell bind which is the xml
binding api this may be something that
you use directly or maybe some library
the use it's probably the most popular
one on this list here java xml WS which
is the web services and so put
attachments all of that stuff 2017
kind of legacy now Jeff XML WS
annotation which is actually a subset of
these of this of this API called the
common annotations a Java EE provides a
subset of that API was defined for Java
C to support web services and it ended
up in Java C and one thing about these
modules is as they are deprecated for
removal this is a new form of
deprecation and that was introduced in
Java C 9 when a module or some other
programming element may be a class or
may be a particular method is marked
deprecated for removal it's providing a
clear intent that it will be removed at
some point the compiler and the Java
language know about methods that and
programming elements that are actually
deprecated for removal it knows to give
you the right warning for example so if
you're using any of these you don't need
to panic and we get into some of these
things in a few minutes but let me just
show you what one other thing that has
happened in 9 so they're deprecated for
removal but we have also made one other
adjustment which will smooth the path to
eventually removing these from Java Sea
and the JDK and that change is that we
will not resolve these modules by
default now you haven't gone to there
are some modules talks yet so you don't
know what resolution and-and-and-and-and
resolving modules means but don't worry
about that what it means is is that is
is essentially it's if you're running
code on the class path it will be as if
these modules don't exist it will be as
if the types in these modules do not
exist and let me show you an example
which acts be just to reinforce what
this means so here's a little code
fragment using using using M Jax Jax B's
API I'm calling a static method on on
mjx XML bind and
Jax be context this a static method to
to get it a Jax be context don't worry
if you've never used Jax be you can just
ignore this the important point is the
next what I want to show you what
happens if you attempt to compile this
code you get a compiler error it will
not compile I'll read out the error
package javax.swing I'll bind is not
visible packaged Avex ml bind is
declared in module java xml bind which
is not in the module graph when I said
that the module is not resolved it's not
in this module graph that the the
runtime has hurt so the compiler has a
none runtime has when it actually starts
up and when you're compiling code a
running code on the class path so if you
get this error when you're compiling
what happens if I've already got some
code that's previously compiled to use
these api's and I try to run it shock
horror I get in no class dev founder
it's as if I'm missing a jar file on my
class path which is exactly what what's
what's going on so this is a new thing
to the JDK and we have never removed
modules before and this is just the
first step and I want to talk about some
of the migration options are that are
around this this is most certainly a
disruptive change but only for those
that are directly using and indirectly
using the API is in these modules
there's a number of migration options
and we've written these up in the jdk
migration guide we have a new
command-line option add modules where
you give it a set of modules that will
be additionally resolved at startup and
this is useful as a short term solution
to get existing code that's using these
api's to compile and run it runs exactly
like jdk age all the way back to 6 did
in the case of this module so this keeps
existing code code working
obvious with the inconvenience of adding
a command-line option each of these
api's except for carbon has its own
standalone version it has its own jsr
that maintains it in the JCP each the
artifacts for each one of these modules
are published our jar files I should say
are published in maven central so
there's alternative ways of getting
these libraries when you use them and
you can deploy those on the class path
or you can deploy them on the upgrade
module path so they're deployed as
modules now they're not all quite there
yet as as modules but the a colleague of
mine is sorting it out with the owners
of all of the these components to make
sure that eventually they can all be
deployed as modules as well so that's
one big important change in nosotros
disruptive change and I want to move on
and talk about strong encapsulation
which for the JDK is all about
encapsulating the JDK internals so that
code outside of the modules these
modules will not be able to get at the
the classes that are not part of the API
and are and also so they cannot get at
the non-public members of classes that
are in the API so this is a this is a
big deal I've got a start by going back
20 years this dusty duct slide dusty
Docs page is from 1996 and I will try to
read it
miss anyone down the back has brought
binoculars and can read it for me the
Java dot star package makes makeup the
official supported public Java interface
the Sun dot star packages are not part
of the supported public Java interface
this says this is what the documentation
said 21 years ago but no one ever reads
these documentation now things dialed up
in JDK 6 when Java C acquired a simple
database the symbol database was enough
for Java C to be able to print warnings
our errors when compiling code that was
making use of of Sun dot star api's or
other internal api's this acts as a
deterrent so I'm going to pick a little
example here of code that has a static
reference to Sun security x.509 X 500
name and we'll see what happens when you
try to compile this with JDK 6 or 7 or 8
you get a compiler warning
what is the warning warning X 500 name
is internal proprietary API and may be
removed any future release we all ignore
pilot warnings I'm sure here so with
ignore the documentation we've ignored
the the compiler warning now let's move
to JDK 9 where things dial up another
little bit with JDK 9 if you attempt a
compiled code with a direct reference to
internal API the compilation will fail
end of story
I'll read out the air
package son security x.509 is not
visible packages son security x.509 is
declared module base which is not which
does not export it to the unnamed module
now we don't know what the unnamed
module is here because we haven't been
to the other and the other sessions but
just assume it's a class path for this
presentation summary is compiling
against internal api's and will now lead
to compilation errors in jdk 9 so what
about one time so this is more
complicated at run time oh I forgot one
order thing J tips very useful tool when
preparing for JDK 9 is to run the Jade
EPS tool and the Jade EPS tool is in JDK
8 and allows you to do a static analysis
of your code or compile code to see if
it has any references to internal api's
it's actually a bit of a Swiss Army
knife you can actually get it to be able
to look at it and analyze all your
dependencies it's very very useful tool
and quick poll actually how many people
here have tried J tips ok that's better
than last year which is good so for
those that are taking photos Jade EPS is
jde PSM so can we often get asked in
presentations just to spell that out so
I'm going to run Jade apps just on that
code example I had in the previous slide
and I'm using J tips - JDK internals
giving it the class I can give it jar
files you can give a class path that's
actually very quite flexible what its
input would be and it's putting out a
message to say that my code has a
dependency on Sun security x.509 X 500
name and it Flags it as an internal API
Jade EPS has been improved quite a bit
in JDK 9 so if you've tried an 8 you'll
actually see some improvements in 9 but
one of the nice things it has is it has
a little table of internal API is vs.
supported api's so for cases where into
any supported API is have been
introduced and it sees a reference to
the old internal API it'll actually give
you a hint in this case there's a
there's an X 500 principal class that
was added and 1/4 which is a much better
way of
dealing with x500 names now I want to go
back to run time again and talk about
the complexity but with the run time the
ultimate goal is to encapsulate all
internal api's at one time as well we're
not there yet in jdk 9 we attempted to
go there in j2k 9 and in fact for over a
year we had early access bills that
strongly encapsulated all of the
internals at runtime
but a lot of code broke a lot of code is
making use of internal ap is a lot of
code is hacking into non-public members
of classes in Java lang
so what is the story for JDK 9 and
runtime now this is a summary of where
things are with JDK 9 now I'll read this
out all packages that existed in JDK 8
are open to code on the class path this
allows existing hacks to work as before
now when I say existing hacks work
before you will of course have
refactoring of internal classes and
things that break a lot of these hacks
anyways and that's just that's just part
of our of life a first and this is this
an important point is the first use of
core reflection that makes use that
hacks into JDK internals are does what
we call an illegal reflective access and
I explain that in a few minutes will
emit a warning to standard error that's
a non suppressible warning and so this
is the first time that we've imaged
warnings at runtime the warning which
I'll show in the next slide is there to
create awareness that there is code that
will break when the internals are
completely encapsulated
the warning attempts to identify what
the offending code is and tells you what
it's actually trying to access them
there is a command-line option - -
illegal access that allows you to debug
further so future debug one of these you
can get in you can get
additional warnings you can get stacked
races you can even have it deny access
to internals which allows you to try out
what future behavior will be when the
the GDK fully encapsulates its internals
so I'm going to use an example I'm using
the example of the Jason ripple and by
the way I'm not picking on Jason I'm
just using it as an example there are
many examples I could have chosen last
year and the previous year I used
examples with Gradle and and GlassFish I
decided to give them a break this year
so let's look what the warning is so I'm
this is an executable jar of the Java
dash jar I get a warning and the legal
reflective access operation has occurred
illegal reflective access by and it
gives me the type name it gives me the
the codebase in this case it's the it's
the jar file with the Jason ripple and
it's trying to access some a member of
Sun and IO CH and this is a selectable
channel implementation internals is
trying to access this the access will
succeed but you get this warning and it
gives a suggestion about submitting a
bug and giving you also hint as to what
command-line option you can actually use
to get further warnings if you want to
investigators so this is a new thing and
warnings at one time now there's lots of
other changes in gene JDK 9 that I want
to talk about him the new version string
scheme chip 223 and you may have heard
of this this is actually quite of a
disruptive change I'm not going to spend
time going through it the chip has all
of the motivations for why the old
confusing numbering scheme is being
replaced with a newer numbering scheme
which is a lot simpler and I hope people
will figure it out a lot simpler so
here's an example ours are just a table
showing JDK 8 vs j TK 9
these are the four five assistant
properties that and reveal the version
and Java version by is the assistant
property that many libraries and examine
to see what they are running on so it's
nice and simple and after 20 years we've
essentially dropped the leading one but
that is an extremely disruptive change I
could do an entire session on code
examples showing bad code parsing the
Java version we've seen code that thinks
it's on JD k 1j tk1 one when it's
running on nine we've seen we've seen
code that actually tries to execute and
and load libraries that had never that
it hasn't run in more than ten years
we've seen exceptions we've seen errors
all sorts of crazy things there's enough
material there for an entire session at
the San Francisco comedy club so many
libraries have already been working with
us over the last few years and have have
affixed the parsing to be able to deal
with nine and there but there's probably
other code out there if you maintain any
code that is parsing Java version now is
a good time to audit to see and whether
it'll actually have issues and moving
from eight to nine so a couple of things
features that are on nine that are
actually avoid having to parse the Java
version is with a new runtime version
API
so finally you actually have a
programmatic way to get the version now
this week you'll hear a lot about moving
to faster releases and maybe changing
the version scheme again so maybe this
API will have to be revisited but the
point is it's much nicer to be able to
use a API to get this information rather
than doing your own parsing we also have
multi release jars and which is is
something I'm going to talk about later
in the present presentation the new
binary structure are for the JRE in the
JDK yep 220 and this is this is all
about
dealing with the moving to a modular
platform because one of the implications
of a modular platform is it completely
blurs the historical distinction between
the JRE and the JDK and this is a
disruptive change and one of the reasons
we got this in early in JDK now in fact
we got it in late 2014 so that the tools
and the compilers and the ideas and
those that are actually dependent on the
layout on the file system could be a
just in advance to deal with this change
so what does this mean it means that the
sorry I'll show you the legacy structure
first just so you have some idea where
we're actually moving from the JDK view
download eight seven six all the way
back to 1.2 where this structure was
introduced you have a JRE directory
within the JDK download that has the
runtime there's a Lib directory where
you have Archie jar you've probably
heard of RT jar there's a Lib directory
at the top level Lib directory where
you'll find additional jar files tools
that jar is probably the the best-known
there are two bin directories one at the
top level one under Jerry
they have copies of the same tool this
is an embarrassing accident the way this
is layout and came came about the Lib
directory is is a hodgepodge of things
and it has some files in there that are
intended to be edited they've provide
configurations like the the management
configuration file our security policy
file they're intended to be edited
there's a whole bunch of other files in
there you touch them the JDK is hosed
you're not supposed to edit them so
there was always confusion as to what
you should change and watch what what
not to change JDK 9 runtime emission
format runtime which is much simpler one
level one bin directory with the tools
the Java launcher Java C and so on it
comes directly with the user editable
configuration file if it's if it's
tended to be edited it's in that
directory if it's not intended to be
edited it's not there so what this means
is the JRE directory is gone RTG are
sorry Archie jars
to that jar is gone so this is a big
change you know I assume most people
here won't have code that's too
dependent on this what many of the tools
that you use probably do is that's one
of the reasons for having to upgrade
your tools now if you go to the module
sessions you'll hear a little bit about
the j-link tool and creating your own
runtime image and by linking just the
modules that you want into create your
own runtime when you use j-link then you
may start becoming familiar with with
with this layout there's many other
changes I talked I said earlier on that
the classpath hasn't change class
loading hasn't changed but there are
actually a couple of changes in this
area the application class loader
is no longer an instance of URL class
loader
it was never documented as such what we
found many libraries out there that
assume this and really want it to be in
a URL class loader all of the core
modules that you that used to be used
where their classes used to be an RTG
are there they're all in modules now
there is no need for a boo class path so
there's some changes there these are
things you probably won't won't run into
too much but if you've got your own
custom class loader and it's a 10 it's
it's the parent didn't know then
suddenly the set of types that are
visible to it ar-ar-ar-ar reduce so
things two things to be aware of nothing
to do with modules but there was a lot
of security defense-in-depth work done
in jdk 9 to move a lot of the non-core
libraries and modules away from the
bootloader where they've where they've
all permissions they've been moved to
the platform class loader or the
extension class loader as it used to be
so this is another thing that
co-creating and custom class loaders may
actually and have may actually observe
one of the brave things that was done in
JDK 9 is to move through the Unicode
cldr
locale data by default now this is a
really subtle change but it's a really
really good change so this is something
that has been preparation for many years
and for for almost 20 years the GDK
maintained its own locale data we call
it and we now call it the the legacy JRE
locale data jdk age was updated to ship
with two sets of locale data and there's
a system property that you can flip flip
between the two of them it did not
change the default JDK 9 switches the
default
and this is this is if you've got
applications that are deployed and I
guess I've reading something there
recently someone someone was running
into some strange formatting of dates
issue and I think it was Australian
English and it was a subtle difference
between the standardised cldr and the
old Gerry locale data
the format was slightly different and it
had been updated a couple years ago and
cldr
so these are little subtle things to be
aware of but what you can do with JDK is
you can configure to you cldr and you
can actually observe then in the
different locales that you support to
see whether you've only any any
differences JDK 9 also took the brave
step of switching the the the default
garbage collector to g1 and which
potentially will change the performance
characteristics of of some applications
I'm not going into all of these in
detail now just really making aware of
things to think about when you're moving
to gjd canine now what i want to move on
to now is just talk about a couple of
features in jdk 9 that really helped
with the migration and i'm picking out
to them japchae 38 multi release jar
files and Gipp 247 compiled for older
platform versions I'll start with multi
release jar files so Java C 9 has
introduced a whole bunch of new API M it
has four handles for example and when
the wonderful things from far about with
var handles is this is you can start
replacing some of the code that's using
some Muskaan safe to use the standard
api but that creates an interesting
thing and an interesting problem for
those that want to have a library that
runs on seven or eight and they would
like to make use of the the new api's
when they're on nine and so that's going
to be interesting how
how do I get that to work another
example is the XML catalogue API
standard API introduced in 9 and that
avoids having to hack into the internals
of the XML parser code which some
libraries do so this is the motivation
for multi release and have jar files
so what multi release jar files do is
they extend the jar format to allow
multiple Java a specific version class
files to coexist in the same archive and
I'll show an example of what this of
this in a second so we start with this
this is a an example using the jar tool
to create a jar file and I'm going to
use the the G RTF to just get the table
of contents this is not new these are
this is these are the legacy options
that you can specify to the jar tool for
the last 20 years this is how you create
a jar file on the command line this is
how you actually get a list of the
contents now let's add some options to
the jar tool because the jar to knows
about multi release jars I've added that
when I'm creating the jar file - -
release 9 + - c and then i'm giving it a
completely different directory where i'm
going to find some compiled classes for
jdk 9 and let's look at the contents of
the jar file and see what's happened the
jar tool has packaged up these classes
and is put them into a new section in
the jar file which is the version
section meta-inf such versions slash and
then the version number it's put them
into versions 9 in this case if you look
closely you will actually see there are
two com Acme stats CLI helper class
files in this jar file one in the base
section one in the version section so
this is interesting I've got classes
that that I want to use a nine in this
version section
now let's suppose I put this jar file on
the classpath with 8 what classes get
loaded the classes that get loaded are
from the base section jdk age and older
does not knew about multi release jars
it will never attempt to load classes
from the meta-inf versioned 9 section i
put the jar file on the class path with
9 and magically what will happen is the
class that's in the version section will
override the class in the base section
so this is actually very useful because
it means I can ship a library as a multi
release jar and I can have it use one
version of the code when it's on eight
and and and use newer api's that are
compiled for nine when I'm running on
nine so this is actually really really
useful migration aid however it
introduces complex complexities because
I'm now going to have M different source
different source trees different compile
trees and but don't worry about that
there are there are some good recipes
out there and Robert Schulte is talking
in one of the other rooms in on this
topic about maven and integration with
JDK 9 I have no idea how they ended up
putting us scheduled at the same time
and but he is going to D is showing an
example at this time I'm using maven and
some of the recipes he has for creating
multi release jar files one other thing
I want to actually want to observe here
is is that I'm now compiling code for 8
and then I'm going to be compiling
classes that are for 9 does this mean I
now end up having to J decays in my
build environment that would be a pain
and this is where the other Jeff comes
in 247 compiled older releases count
comes in because it helps you with this
problem
we take questions at the end so and
historically if you were compiling to an
old release you have to specify three
options - source
- target - boot class path most people
forget the third one and this is why the
Java C compiler has been omitting a
warning I think since 8:00 on this and
because it creates some really
problematic cases with JDK 9 you replace
all of this with - - release and then
the version you can use JDK 9s Java C to
compile to six seven eight or nine and
Java C has enough information to know
what were the public API is in six seven
eight and nine so that it if you've got
some API and you tried to compile it to
seven but that API was introduced in
eighth then it'll actually fail the
compilation so it's a really really
useful thing to be aware of you combine
that one multi release jars and you
actually have a great solution and a
great combination for a migration one
other tool I just want to mention is JD
/ scan which is a new tool in JD case in
J tk9 for doing static analysis like
Jade EPS and it scans classes for
deprecated API s and this is becomes
really really important with deprecation
for removal because you want to know
that you're making use of something that
is marked for removal if you see dr
deprecated are walking around the
conference he wears a white coat and a
stethoscope be sure to ask him about GD
/ scan and he'll talk to you about that
so what can I do to prepare for JDK 9:00
a.m. the most important thing is to is
to upgrade the tools and the libraries
to versions that support JDK 9 in some
cases sadly this might be full stack
upgrade especially if you've got older
versions really old versions of some of
the tools if you only take one thing
from this session you will need to
upgrade the many many libraries and
tools and if you do this before you
upgrade to JDK 9 you will save yourself
a lot
frustration the modules that are shared
which are the EE that I listed out
earlier in the presentation is
properties really really problematic for
those that depend on those those modules
there are several migration options and
you can figure out what way you want to
go the Jade EPS tool is really really
useful to have and be able to analyze
your code to see whether it's using any
any any internal api's try out JDK 9
look for the legal reflective access
warnings and submit bugs that's the
important thing so that the code that is
doing these naughty things can can be
addressed by those that maintain that
code if you parse the class void these
are the the version Java version and
property please revisit that code
because the possibilities is high that
it may not work in 9 and read the
release notes nobody reads the release
notes JDK 9 has has 43 pages of release
notes which is probably any problem that
you learn into can actually you will
actually find a release note would
actually will detail that it does
there's an extreme amount of detail in
there for the map vast majority of that
detail and and the issues in those
release notes is at the same level of
the release notes and the same level of
changes that you will see in in 7 &amp;amp; 8
how do you prepare for post JDK 9 why am
I talking about post JDK 9 this week
you'll be hearing about the proposed in
a new release model where there's a
major release or being a smaller than
what we've done before every six months
and this means that things are going to
move faster we hope and it means that we
will have an opportunity to finally work
through the eventual steps on removing
the the modules shared with Java EE so
that means you will need to figure out
your how you going to migrate to the
standalone versions again run Jade EPS
really really important there isn't a
proposed plan yet how we will eventually
encapsulate the api's at runtime the
warning and allowing code and the class
path to continue to hack will
will is what you have a nine but
eventually we want to get to the point
where the internals are completely
encapsulated running with illegal access
oh I see a type of air that should be
I ll L of course and illegal access
equal deny allows you to test out future
behavior now because it will deny access
it means a code that tries to do naughty
things will get the right and illegal
access error illegal act exceptionally
are inaccessible object exceptions again
audits your code for the version string
especially if the version string changes
again and test the EA bills I think this
is actually we found this the most
useful thing with nine the EA bills
early access bills were available right
from the start every build was actually
published and that allowed cloud
libraries and maintainer to actually
work with us from the start and deal
deal with issues so summary most code
will work online without changes I've
talked about very few changes that
actually require code except for the
partly cloudy and the Java version JDK
nine does include some disruptive
changes I think I've covered most of
those changes and again make sure you
upgrade your tools and libraries in
advance to avoid most of the issues
that's the most important message from
this presentation so more information
and JDK 9 has a an open JDK has a
project JDK 9 and you will see all the
chips that I showed at the beginning of
this presentation
those chips are full of really really
useful information if you have the time
to read it there's a migration guide
which is actually not too bad that
covers most of the main issues that you
potentially will run into there's lots
of sessions about JDK 9 this week is so
and try to attend those if you can now
just a reminder of our sessions so
myself
Alex Buckley Mark Reinhold we have 5
sessions in this room and Alex is doing
module development with JDK 9 here and
at 5:30 this evening mark is doing
modules in one lesson and migrating to
modules in this room tomorrow at 11:30
and 150
and then Alex is back on Wednesday at
9:30 to do modules and services and so
that's that that's the the the sessions
that I want to plug because it's we're
trapped within a track essentially stay
connected and there's a DevOps corner
and that folks here that are working on
the JDK will be around around over the
next few days and some links and there
as well and don't believe anything I
said please don't buy anything based on
anything I said and so that's it so
let's see we have a minute or two for
questions and I don't know whether
there's no microphone here so I will
have to repeat your your question if so
that it's because we're actually being
recorded here okay so the question is is
for this jar file what happens when I'm
on ten and so in this or 18.3 okay so in
this case is this is assuming there
isn't a a section that has four for ten
or 18.3 then it'll just go to the
previous version which is nine so this
case it would it would load the main
class from the base section and it would
load the helper class from the version
section
I'm sorry I didn't quite you Tom about
the size of the jar file okay so the I
think the question is is just as the jar
file get larger with these additional
classes and yeah yes it would be because
it's sizes jar files proportional to
that to the number of entries in it okay
so the question is is for this example
why is the the main class and not in the
inversion section so for this particular
example the the main class does not have
any JDK 9 specific code it's only this
helper class that that is used for this
example I did the helper class has the
nine specific code so there's two
versions of the helper class right
exactly someone that someone actually
just went out is a bit like overlays and
patching okay so the the question is is
as I mentioned some incompatibility with
and the e modules so there's there's an
one you want me to expand on that this
is a couple of areas one is the
transaction API that's really really
problematic Java C you'll need to find a
small subset of the transaction API if
you look in the Javik transaction and
package within java c you'll only see
three exceptions in there that's the
minimal that's actually required by the
java ideal and spec to support the
mapping of CORBA transaction exceptions
to remote exceptions and another
problematic area is the so-called common
annotations where Java C defines is the
smallest subset of those annotations to
support web services so they're really
really problematic areas and so they
they will be the two main problem areas
okay so I think that the question is is
is is about crypto providers right so
they should do it so um crypto for
providers if they're deployed should
work as before yes in it in addition the
jce has been updated to be able to
support deploying crypto providers as
modules as well okay any other questions
okay I think we're we're done okay thank
you for attending</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>