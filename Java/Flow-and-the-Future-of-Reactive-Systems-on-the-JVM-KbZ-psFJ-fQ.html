<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Flow and the Future of Reactive Systems on the JVM | Coder Coacher - Coaching Coders</title><meta content="Flow and the Future of Reactive Systems on the JVM - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Flow and the Future of Reactive Systems on the JVM</b></h2><h5 class="post__date">2017-10-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/KbZ-psFJ-fQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right but Acquia hello hello
okay that's right so welcome to talk
about java.util concurrent flow what was
previously known as reactive streams and
it's gonna be above a quick look back at
what it actually I made a coin or just
to me okay so it's just me if it's yours
echo okay so say Friday so my name is
Carmen offski I work at light wind so
company behind Scala play a go on
distributed micro services and basically
it's called programming language as well
but all of our API eyes have a Java API
which I'll talk about a bit but not too
much and I also did reactive streams TCK
so you'll see what reactive streams
actually is it's not something you can
pick up and use it's more of a just a
standard and we'll talk about why would
you care about a standard like that and
how it actually came to be other than
that I do a lot of community stuff in
Poland like geek on conference like 1200
people each year reports Java is a group
I found it was carly was a group like
white paper reading clubs things like
that anyway so the usual question on
conferences who is not heard of archive
I cans up and I won't be offended
okay who has heard and maybe even used
it
oh cool okay so people lost questions so
who has heard about reactive streams
okay so you know about react issues so
we'll see how much we can skip or how
much not but occurs a bit more than what
we do and distributed computing yeah by
the way we have the ARCA streams
implementation which is a reactive
streams implementation yourself an HTTP
to server and of course distributed
cluster so brief reminder for people who
don't know what a car is that's a number
of the tools we have in the tool set
and we're pretty much pick and choose if
you just want to use our Parker we're
talking about our Parker to Dave it's
like an integrations thing also
streaming right which is why it fits
into today's topic you can just pick
that you don't need to do the actress or
clustering and vice versa so basically
end of corporate pitch let's talk tech
so stream is probably one of the most
overloaded terms right now everything is
streaming even if it isn't streaming
people call it streaming good example
would be spark streaming which is kind
of streaming quote-unquote but
practically speaking it's more
mini-batches and you get very different
semantics between all of the different
libraries which claimed that their
streaming libraries you get for more
dictate oriented things like spark
flaying whatnot and then you get things
like reactor streams which is more on
the level of like an input stream right
sometimes people ask me to compare
reactive streams with I don't know spark
streaming right that question doesn't
really make that much sense because how
would you compare back in the old days
compare Hadoop to input stream right not
not quite the same thing
even though okay both have similar
concept thing goes anything goes out so
this is a bit of terminology and then
we'll jump back into the past to see
where it all came from so this is
archive strange terminology we call
things a bit more specifically than some
other libraries on the same level so an
example would be our X Java for example
value talk about observable and
everything is an observable and our
streams we have source flow sink and it
depends how many inputs and how many
outputs it has so it's a bit more in
your face but this is for consuming data
or this is for transforming data etc and
we have a synchronous boundaries and
visas were reactive streams is actually
a meaning for a new school and what
we'll talk about today so they're
synchronous boundaries between these
processing elements each of those could
be actually
different technology so it doesn't have
to be our constraints and backpressure
service for two main features of
reactive streams it does flow control so
it prevents out the memory errors like
that and it's a standard so multiple
libraries can interrupt between each
other but I want to fast forward a bit
and talk about the second most
overloaded word on the planet right now
which is reactive to West Point
overloaded that I wrote a mini book to
kind of clarify what reactive really is
and it's not just reactive streams which
many people would want you to believe
right now it's a bit more than that
if you remember the reactive manifesto
years ago that's at least how we think
about it why we mean well akka people
right meant people we think it's a bit
bigger than just reactive programming so
forever peacetime Oryx Java akka stream
style it's a nice building block but
that's not my entire story it won't help
you achieve end goal that we had in mind
to an victor kind of initiated a very
active streams thing okay so reactive
apps awesome absolutely topic of today's
talk not vampire thing so there's more
stuff to that like and things like
resiliency and being able to scale out
or down that's also part of reactive
systems at least how we defined it back
fan and very active manifesto so why did
we actually set out to do reactive
stream so people here have raised their
hands but they know attractive streams
was and this but why did it actually
come into our minds that we need this
thing so basically in my team we would
have a lot of customers that come in to
us and basically would be a project
rewrite or a greenfield and they want to
use some reactive technology they pick a
curve they rewrite the system or they
write a new system and it's super
awesome
Andres traffic like a boss great cursing
on sunglasses everyone everyone's happy
they put it for load testing
everything's fine
they put it in production
integrates with other systems and for
other systems
what have ever not been modernized or
just or even not under your control it
could be a third party or something and
some of them don't really handle that
new traffic you slam at them and it ends
up like that so it was really driven by
a need but ok on one hand it's great for
the our APIs so fast and what we can
claim to people ha look at our car so
fast so great
on the other hand we want to integrate
nicely with the rest of the planet right
we don't want to keep crushing the rest
of your company by overloading them just
because we can process things first
revenge some other system so that's the
prime need for flow control etc
specifically an asynchronous programming
so rocket rocket is all about a
synchronous programming just adding flow
control to the thing isn't as trivial as
it is in a blocking application because
in a blocking application you're
basically automatically being slowed
down because you're blocking until
someone has processed right right and on
synchronous app you kind of can keep
going and keep going even while the
thing is not done processing on the
other side so this is the kind of
immediate need that we wanted to address
with three years ago or something
nowadays was a funny pattern that we see
from people I would just slap a calf can
vary a little bit it would be solved
right and I found that very funny
because an offer I think those two
offers in that book and he tweeted that
one issue that keeps coming up with
Kafka Connect so that's that's the kind
of system where you wanna like drain
from a database into Kafka or the
opposite many downstream systems don't
scale as well as comfortable it sounds
familiar right
same story new tech faster than other
systems other systems still valuable
maybe probably even making money your
system not even net making money because
another production so you know it's a
bit hard to argue and if
you would be away and here I'm hinting
it for a pocket project which you will
see what it's all about it's basically
about integrating these various
technologies without having to lock you
in or be very specific about oh yeah we
only like these technologies we don't
like that technology's kind of like
camera but we'll get tipped so this is
the immediate need we kind of wanted to
address react extreme starts three or so
years ago so the reason I talk about
this stuff and you see me talking about
it so it did for TCK ever so of a set of
tests would verify if you actually
implemented it correctly and you'll see
why that actually matters because
nowadays it's part of JDK 9 and that
super core were super excited about it
it was included violent ugly and for jab
266 so the more concurrency updates lots
of very interesting things here but one
of them being reactive streams basically
copy pasted and renamed to each other
concurrent flow but all of the semantics
and rules about how we behave are
versing remember that that's kind of
important point so it's exactly reactive
streams but okay it's not for exact
types so now we'll have to have some
period of time where libraries will have
to support both what because we wanted
to build an ecosystem kind of prove to
Doug and what if a Java ecosystem that
okay this is valuable and now we have to
kind of port all of this to the flow
interface should be pretty easy so if
you're curious about can you already
today use the flow interface and the
great things absolutely and we support
that already Annika we just released a
jar of it can integrate with flow
interface and at the same time you can
still integrate with reactive streams
interfaces so technically it's a
breaking change because package rename
but practically you won't feel any pain
from that so so it's more of an SPI and
by which I mean to say that it's
integration thing
right you have these various
technologies and when we did work the
streams we invited the spring peepers or
project reactor world's great people
that's a bit says : ecosystem specific
the arocs Java project of course with
Ben Christiansen was on board from the
very beginning from Red Hat we had
vertex and all these different vendors
but kind of solve the same problem and
we decided okay let's band together
build this thing and then we'll all
benefit instead of having everybody to
look into very eco system let's build a
bigger ecosystems it's going to be
beneficial to everyone so I think I'll
fast forward a bit River history here
but like I said 2014 we had kind of
three parts to it play sober play
framework had introduced and back
pressured API in play called the
treaties back then it was you were
thinking okay maybe that's gonna solve
it practically speaking it was way way
too complex for end-users to be mice
nice to use we had a nice iolair but
none of these api's were a nice API to
work with so at the bank Christensen
brought to the table was with Oryx Java
a nice API to work with around which we
built on the concept of back pressure
which Oryx Java didn't initially have
then we added it's kind of during this
work together on it anyway so that's for
at ease if you quickly look at it you
can kind of imagine it doesn't speak to
you in five seconds what it actually
does so that's why we scraped that it
would solve the problem of flow control
and back pressure but it was very husky
inspired and didn't quite feel as native
to to Java as corner developers so we
sacked that and when this interaction
began of kind of nailing down what we're
gonna solve talked about that already
and then finally it gets included in
okay right so what does that leave us
it leaves us with these interfaces
currently in the JDK that you can use
right now
but I'll ask you to not implement them
directly because when you look at them
it's basically seven methods or so for
interfaces looks very simple but as any
concurrency thing it's it has a lot of
implications when and how you can invoke
things right so that's the actual
complexity of react extremes that's per
spec I can zoom in on some random rule
and let's try to see mm that's not
interesting not for example as a problem
must be prepared to receive a non
complete signal with or without
proceeding requests core so we can
complete with an empty string for
example right seems obvious but if
you're kind of implementation assumes
ofs always going to be a request before
a complete signal well you would be
wrong
so rather than implementing it directly
I'd recommend using an existing library
can be our customs can be any of our
implementations the JDK ships with one
example published wrong it's not very
powerful but you can get started with it
so let's explain reactive streams in a
single slide the protocol is actually
not very difficult and we settled on the
naming publisher and subscriber was a
big naming debate back then so it's not
pops up that's kind of my problem with a
current names of it when you say publish
or subscriber people think pops up right
make sense but it's specifically a
point-to-point protocol right you can't
do a fan-out thing using this protocol
but when each interaction is going to be
adhering to this kind of rules how to
interact it it's not defined on the set
of subscribers it's on a point-to-point
basis so since we aimed to solve flow
control mechanism here
and it's obviously gonna be a
synchronous with the purpose of it so
usually you do have some kind of buffer
in your system that's drawn here as this
smaller shape and you're processing some
messages what's going on a synchronously
you have something's buffered still and
you have some free space in your buffer
if you think you don't have a buffer you
have a buffer somewhere anyway because
either it's gonna be network or i/o or
something somewhere we'll have some
buffer space and then a synchronous
system so let's say we define that we
talk about elements so unlike TCP we
don't talk about okay give me this many
bytes from this infinite stream of blob
data we talk about specific elements so
it could be person might give me one
person give me three persons so here a
green arrow says I'm requesting three
elements which also can be said as I am
prepared to accept at most three
elements right because you kind of know
your buffer space you see okay if you
give me three elements I will not blow
up and upstream so the publisher even
though it can be faster it can never
signal more elements than it was
confirmed asked for now this basically
and a rule that requests kind of add up
but basically solve a simple flow
control problem with some edge cases
around completion and cancellation error
handling but that's why we have this
back and TCK so like I said ships are
not already so you don't have to wait to
adopt it pretty happy that we were able
to prove it off didn't really need multi
release jars to that if someone's
thinking about how do people adopt his
thing for introducing new API motorist
jars are not that helpful
we're hopeful for changing
implementation
for example if we had using had been
using some unsafe features now we can
move on to other alternatives like VAR
hand drives etc but for introducing new
API if you produce libraries or if you
consume libraries that's not the tool
that helps you out with that
specifically so it's just a normal job
that was linked to us JDK 9 class so
intro up in action doesn't actually work
just a quick example that across a
number of implementations just works
it's kind of boring to demo these things
and show these things because just works
but that's a feature so a bit more arca
streams so we had a brief look at kind
of diagrams but let's look at code and
they used Java here some of the slides
will be Scala but your notice with API
saw very very similar especially with
the lambda and lambda support since Java
8 it's getting more and more similar so
pretty happy about that as you can see
we have syncs flows so flow is like a
function basically and if you're curious
about why do we have free type
parameters here in the flow and to in a
source that's basically because we found
that very often you need to interact oK
we've invested REME it's easy right you
do a stream processing operations you
forward you reduce you you matter but
very often you need to either inject
some control from the outside world or
some observability like a like a
god-like are like a rate meter or like a
fraud ler that you want to control from
the outside so we have that in a type
safe fashion but each stage can produce
some kind of value that has been typed
you have it in your hand and you can do
stuff to it and we have a special type a
type called not used but you can more
nicely expressed that okay I'm not using
this type parameter rather than sticking
void everywhere
this was something that we didn't like
and many Java API but when you didn't
use a value you just use the void upper
upper case void which worked a bit weird
so we have not used and we have done
type again same thing doesn't carry any
meaning our van and being easier to read
so if you get a done value the stream
has completed and a big difference from
other recta streams implementations we
have a lifted representation so that
means by this time you have a source by
a flow to think it hasn't run yet and
only runs when you run it or how we call
it materialized which allows us to do
some interesting either merging of
multiple stages into a single stage and
having this more configurable than not
and not lifted implementations so here's
an example of getting this materialized
value out the sink head is basically a
sink that materializes a completion
stage thank you you can see ok so rerun
with this sink and it gives us back this
completion stage which is what I talked
about this integration with non
streaming world is pretty important and
and here's something that we programmed
this way other ways to do that would be
more side effecting on the side setting
something we thought that's a bit more
clear this you've seen already we have
source flow sink but you can have
arbitrary many ports if you want ok so
that's I think the last talk about akka
streams the door I just wanted to
explain the building blocks we have so
you think about into it in terms of
sinks and flows and sources because the
entire future of reactive streams and
travel to a concurrent flow is in
providing building blocks ok so if if
you have these building blocks and you
know that you're not locked into a
single implementation because they all
inter up you can start thinking about
really picking and choosing parts of
your streaming pipeline
from whatever library is out here and
most of them are slowly converting onto
these types so we have a nice growing
ecosystem and we can nicely encapsulate
them so for example if you have to
explain bees yeah for example like that
you can have some kind of flow with just
processors and acts things from Kafka
and that's maybe from a database you
don't really care it's a blue thing and
on the left hand side that's your logic
would be an application our current
terminology a flow flow terminology
that's a processor one thing in one
thing out and you can easily replace but
for example this is slightly
mind-bending once you see it just in
normal daily code on a picture I don't
think it's so mind-bending so I keep
showing in this picture you can replace
a function with kind of a conceptual
functional flow with independent sources
and sinks and that's actually very very
interesting both for testing or for
example you're injecting some test data
with your source but the sink side is
still your actual logic and instead of
emitting data from your actual logic you
emit it into some assertion collector
and then with assertion collector you
just plug it a bit differently together
and you have this nice power of
composability without having to change
your actual logic and it's all screaming
still because we have this abstraction
that allows us to do it so now if we
talk about building blocks this is the
moment I want to talk about our Parker
project which i think is the important
bit because I talked about ok library
interrupts and that's nice
certainly if you can kind of be assured
that you're not gonna be locked into a
course praying or whatever or you're
specifically with are polka you can't
just use whatever connector that's all
streaming connectors including some IBM
technology
we partnered up servers sometimes or
some I forgot the names of it we haven't
as free compatible API which was
actually very funny to work with because
we thought we will have to write a
specific endpoint to verse IBM as like
as free like API but turned out they
were very compliant with as free API of
Amazon so actually we just reused and
shaped up a bit file as free connector
to be also able to work with our API and
that's interesting because you don't
have to care as user you just look at
your list okay does alpaca have my
favorite technology you use the thing
and it's a streaming connector to
whatever your favorite technology you
have fair and if you don't then building
it is pretty easy and you can build it
using whatever technology you want you
can use our car screams which I would
highly recommend but you can use
anything else as long as it passes well
TCK it's a fully streaming and safe
thing that fits into this ecosystem so
instead of being super competitive and
like being very aggressive about yeah we
have a connector for this we have a
connector for that we kind of invested
in a more helpful environment where if
anyone produces a driver like MongoDB to
the erect extremes driver everybody can
use it directly and how does this grow
if it was among a few months ago just a
number of connectors where some of them
we implemented some of them just people
in the community implemented and this is
today and it doesn't even quite fit so I
had to make the text quite smaller so we
have a lot of things including lambda as
3sn is SQS so a lot of amazon stuff some
google api switch are equivalent to
vendors and things and here's an
interesting bit is okay if you kind of
abstract the way your use of client
library of specific cloud I don't know
let's say this messaging API then you
can more easily swap it out if you want
so again we're kind of helping you to be
more flexible and picking whichever
cloud you want because okay this month
here we got a good price next month oh
we did a price reduction let's use ice
API so and again with always Express the
sources and sinks and flows and you can
always if you have a sink you can always
get a subscriber from it if you have a
source you can always get a publisher
from it
so again complete and drop so let's look
at an example how we would you actually
are we envision building streaming apps
or more integration labs because when
people say streaming apps it's also a
bit confusing because sometimes they
mean the data heavy analytics machine
learning heavy pipelines which usually
spark or or fling technologies back that
were they own the entire pipeline and
they start the stream and they run with
stream directive streams and flow here
is really more about small jobs that
have to be done and it would be nice if
they were streaming and we don't have to
have 50 nodes to do it we can do it in a
single node because that's actually
sometimes faster and now if you've seen
there were a few examples of people kind
of comparing setting and wrapping with
Hadoop in a problem setting and wrapping
would be some simpler and faster but
yeah we want to be enterprise-d and used
for big things right maybe you don't
need to use with big things so it's more
sidenote so how would I build a thing
with our poker you just pick okay I want
to I want to use - kafra streaming is
that include the dependency here I'm
gonna include okay HTTP just because I
like it then basically you pick what
source you want right so we kind of
explained by the name what kind of
semantics we have and at most source and
committable source and we give you
slightly different types here are I
lined them a bit and you can see okay
you get a consumer record or
committable message so if a cognitive
message one you're in charge of hitting
commit on each message and when we do a
cumulative to a given offset commit and
as I said we have this outside control
parameter that you can control this
running stream and ever get metrics out
of it or stop it or pause it things like
that so you picked one of those and then
you basically just need to and they
screwed up the slide a bit but basically
we need to connect some source to
something basically as simple as that
and resonant entire a streaming HTTP F
out of Kafka you just pick a source
because ink runs HTTP server you're done
so this is a bit underwhelming to show
perhaps because okay three lines some
magic the thing is it's actually not
magic it's very boring tech it just
connects because we have the same types
everywhere and it just works because his
under under under under covers agreement
between these different libraries but
once you can realize that this is how I
can plug stuff together I think it's
pretty well call it profit and then you
just change for sources or syncs you can
be an FTP thing can be whatever you want
for just works training and like I said
this is our Parker community again you I
would like you to use it without code
but you can use it before that whatever
you want so pretty inclusive and last
thing that's something people don't
often think about is that an HTTP server
can also be made streaming how do we do
that we do that by expressing the HTTP
server and for HTTP entity again as
reactive streams WebSockets as well wait
a moment because
taking picture so the interesting bit
here is this precise more precisely
models HTTP to van a server as a phone
when the server is a function because a
server as a function kind of implies one
thing in one thing out
hey flow a processor can have one thing
in many things out so that models the
server approach of HTTP to or you get
one request and you start pushing the
assets right away so nice side effect
and then again buffers all the way down
I as I said and we basically propagate
both pushing of the data that's all
reactive streams all the way to the TCP
implementation we have and over active
libraries as well and we propagate for
back pressure or the way from the OS
from the windowing mechanism of TCP into
actually pulling more tweets or not
literally if TCP is getting back
pressure because someone is in a tunnel
and is not receiving data we will stop
pulling the string so it's also from
that site pretty interesting again how
much core code is that source repeat a
tweet okay that's okay HTTP specifics
but that's basically path tweets and
when you complete it with these tweets
as Jason some boilerplate but not too
bad
you start for server you have a fully
streaming HTTP server that we're stopped
streaming the data to the client and
basically emitting this new tweet load
right this could be a heavy operation
this could be pulling from a database or
something so it would stop invoking
first thing if there would be no demand
on the user's phone so pretty cool the
same thing in Scala as I said way over
to API it's a pretty similar a bit more
concise but not too much so you can
stick to whichever you want and adoption
right so and so is this thing actually
getting adoption from the big guys
Amazon's of
as decay announced there will be an
basically exposing all of our libraries
with reactive streams and that again
means they will be compatible with JDK
types we already have a very exciting
project in JDK 10 which is for a
synchronous asynchronous JDBC which is
finally coming it seems and of course
they'll be using those executive types
so that's a flow subscription to give
you streaming data out and into the
database so this is something I'm very
excited about because it was kind of
long requested by many people and also I
was a bit afraid because we wanted to
ship it in 9 which mean which would have
meant they wouldn't have time to adopt
reactive streams thing and it would be a
streaming thing but not reactive streams
my waiting from JDK 10 was actually a
super good timing
véra so they can use a kind of ready
ecosystem and just jump right in it's
more of a slide about akka and how how
kind of complexity and power interact
within one another basically what I want
to say is just don't use threads and
locks directly okay if you think about
oh I have this concurrency problem and
and you start using the low-level
primitives okay could be a fun project
for evenings but don't put that in
production because when we see just
wrong things and verse better tools out
for me it's dreaming or act or so
anything so yeah mmm
we obviously have monitoring focus the
monitoring would be our custom specific
not flow specifically but it's being
ready to adopt and prod absolutely
because over the last three years we've
seen big adoption of reactive streams we
know it's picking up we've seen the big
players adopted so it's only a matter of
time of people hopping onto JDK 9 and
being happy in jail we have a conference
but focused more on the reactive side of
things so it's not a scarlet conference
sometimes people ask me that being you
know kind of related to ask our
ecosystem it's a specifically reactive
architecture conference it's in two
weeks from now if you want to discount
them you know and yeah that's all I have
and if you have any questions I'm not
sure how we're on time I think we're
over time but you can grab me I have
some stickers or would be happy to
discuss or answer any questions so
thanks a lot</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>