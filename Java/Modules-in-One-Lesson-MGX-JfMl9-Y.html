<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Modules in One Lesson | Coder Coacher - Coaching Coders</title><meta content="Modules in One Lesson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Modules in One Lesson</b></h2><h5 class="post__date">2017-10-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/MGX-JfMl9-Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning welcome to modules in one
lesson so this is a pretty quick
overview but a fair bit deeper than I
was able to go in the keynote yesterday
I'm gonna do but mostly live coding in
fact entirely live coding show you some
basics about the module system are going
to take a very simple you know the the
most trivial hello world application and
convert it into modules and see how the
module system works how to how to build
things with the module system how to
build modular jar files see how the
module system enforces both or well as
art much as it enforces guarantees
reliable configuration and enforces
strong encapsulation at both
compile-time and run-time and there's
some other stuff I can show you if
there's time in the end ok so first
things first here's here's my my conical
command line I have a Java here it is
jk9 yay that's good I always have to
show up J shell because it's just so
cool right so J shell if you if you
haven't seen it before I urge you to
check it out it's really handy tool we
can do all kinds of you basically you
type you type Java code at it and and it
evaluates it and it gives you a result I
won't belabor that here the thing I want
to show at this point is is how the
module system is wired in here there are
other module systems for Java in some
cases there have been some of them have
been around for a long time and they're
they're good and they're useful for
certain kinds of applications but not
not all but they all live on top of the
Java SE platform and that's you know
it's one really one reason why we
couldn't use them to modularize the
platform itself the jigsaw module system
is deeply wired in it's known to the its
known that the compiler is known to the
virtual machine so you get a uniform
experience at compile-time and run-time
so here we are at runtime
I can I can make a string save
we know we all know what that's gonna
return right but in nine you can now ask
what is Fu's module and you get back a
thing that stringify Zinda module drop
in a base and that itself is an instance
of the java.lang model class so there's
a new class java.lang module we can go
over here to the Javadoc here's John
easily I mean do you use Java Docs
search another cool feature in 9 that is
in jigsaw just week we've had Java line
class for years well modules are as
fundamental now as classes always have
been so I don't why don't that that
there's actually somewhat confusingly a
package name traveling module 2 but
here's the model class and you can find
out all sorts of interesting things
about a module models has they have
exports opens regio all the things that
you can write in a in a module
descriptor as we shall see
ok so deeply wired in let's look at
something that is not in the base module
you'll know what the base module is
here's the module graph well here's the
standard part of the module graph I'll
pause for the tweets
excellent so there are 26 standard
modules in Java 9 their relationships
are indicated here except some aren't
indicated to get because if I drew in
all the edges it would be really
confusing that special module at the
bottom Java got base that's the one that
contains java.lang object and java.lang
string you you pretty much always have
to have that around so every module even
modules you write implicitly depend on
Java code base whether you want to or
not and Java dot base of course it
depends on the other modules because
well it's like the very core the very
kernel of the system so that's the
module graph
yep okay where was I
all right let's look at something in a
different module let's see here J shells
doing completion even on module names
which is pretty sweet
so make myself a sequel timestamp that's
an instance of Java sequel timestamp duh
and that is in a different module that's
over in the Java doc sequel module which
we look here is a couple steps above
Java to base so there's Drive dropping
at C wool two layers above ganden okay
so the module system is deeply wired in
it's also we've we've taken great pains
as I mentioned yesterday to make sure
that it's compatible if you have code
that uses only standard SC api's and it
runs on eight then chances are pretty
good it's gonna run on nine anybody
remember swingset - this is the swing
step jar file from from jdk five
released in 2004
it works well I'm pretty nice no problem
and click around all of your stuff okay
so compatibility so let's look at look
at our little application here pop into
Emacs here you go
all all-in-one all-in-one little screen
package org openjdk hello class main
it's got a main method that takes an
argument it constructs a string
it uses a innovative method called left
pad to pad Pat it on the left with
spaces to a certain column length in
this case 90 and there you go
really simple all right let's compile
this in the usual way I want glasses not
glazes and packaged it into a jar
and now I've got hello jar run in the
usual fashion no to have a completion
here sorry and there we go hello world
have a modular world hello sunny world
there you go okay so that's that's basic
so we've got trivial hello world in a
simple jar file on the class path just
like we always have let's make it into a
module how do we do that well what do we
need to make it into a module we need a
module declaration we put that in module
info - a module has what does a module
have a module has a name
we're using using reverse DNS as
recommended this module is only gonna
use stuff in the base model I could type
requires Java got base here but I don't
need to the compiler will insert that
for me if I don't
so most people never do so trivial
module it's just named or org openjdk
hello I look at my source tree now I've
got the module info there at the top and
then that class through the same the
same way it was there before okay so
let's compile that compile that module
info and for now we can just do the do
what we did before it's like well it's
just another Java file we just compile
it okay give it to through Pilar
sticking in the class of directory now
we've got a module in for that class we
can ask Java P what's in there and it
says oh well it here's the module
declaration that you compiled let's
let's make our jar file again and now we
have modular jar file
it's got module info class right there I
can ask the jar command to describe it
and it will go we read the module
descriptor and tell me what's inside was
inside there and it doesn't send in a
simple textual form that's easy for
scripts to parse rather than an source
code form so it tells you that this
requires Java dot base mandated means
yeah this is mandated by the specs of
the compiler inserted it for me and it
contains a package named orgh orgh open
JDK hello
so we can now run this in modular form
and in modular form we don't use the
class path right we use the good job
excellent you guys have seen this
presentation before
hello and I tell it my main class there
we go
modular hello world okay well big deal
but what's actually going on there that
there's actually quite quite a quite a
bit of stuff going on here and we'll see
more of that now a cool thing about
modular jars is they've got a module in
for that class but if you need to you
can still run them on the class path so
just like I did before
right then you have that same jar file I
put it on the class path the module
infos ignored this is useful for
migration that means that if you if you
ship a library you can compile all of
its classes if you need to force a JDK
seven just compiled its module info
class for JDK nine shipped out library
users who are running on releases before
nine can just use that jar file on the
class path and abusers that are running
on nine or later can use it on the class
path or on the module path on the module
path it'll show up as a module on a
class path it'll just be oh a bunch of
classes on the class path like it always
was all right to simplify things I'm
going to take advantage about another
feature whoops of the of the jar command
and and in fact another another feature
of the module system you can you can
when you package up a module you can
tell the jar tool to insert into the
module descriptor into module in class
information about what the main class
for the module is you can essentially
declare the entry point so I can say
main class or open JDK hello main
and now when I wrote on the module path
I don't have to do this I can just name
the module that I want to run as work
openjdk okay hello it's basically now
now it's a tiny application module and
and it runs there's no need for me to to
say that all right so we've got our
little one module application here since
this application is so big in order to
make it easier to maintain let's
refactor it into two modules so to do
that we're going to put each module in
its own sub tree of the source directory
let's rename source to org open JDK
hello now we've got a restructured
source tree when Emacs again and let's
do let's do some refactoring so this let
so let this left Pat Metheny obviously
we need a separate module for left pad
right I mean if JavaScript has a
separate module for left path and Java
should have a separate module for lap
pad so I'm gonna make a different module
in this case or open JDK dot txt
make a class in there called patter da
Java copy some of this stuff out okay so
it's text it's public class patter I'll
need to make this public okay now we
have pattern it's a module it needs a
module descriptor declaration now this
module is exporting something for use by
the other module by the hello module so
I need to say exports its package which
is also named work up a JD tag okay open
org OpenJDK text and then that should be
it so to finish up let's see I need go
fix up the main class here so obviously
don't need this anymore but I do need to
import org openjdk
patter patter and change this right okay
that should work you find out
okay to save a little time I've made a
little command called JJ that does Java
C and jar all in one step so let's see
let's compile and package the text
module we've got the text module let's
compile and package the Hello module
whoops I forgot something and the module
system told me what was wrong see I
forgot to change the changed the module
info for org open JDK hello and so so
the compiler is saying hey I don't know
where to find this text thing tell me
where to find it
so let's go back to that module info and
what I need is what do I need
where is open dedicated text
okay so that all compiles I've got two
modules right proper names now we can
see if I ask the jar the jar tool to
describe hello dot jar I can see it now
requires it up at a base that also
requires org OpenJDK text and it still
contains work of org OpenJDK hello so
let's run this guy
doesn't forgot that didn't I
there we go so that's now running as a
module alright so the module path is is
different than the class path the clad
the class path has a couple of
fundamental flaws and that's that's why
it's brittle and error prone if you
think about it the class path is really
it's a way to look up classes its way to
look up classes without any regard
really for what jar files contain them
you know the way the way the compiler in
the VM searched the class path wrote for
a class is look in the first jar for the
class if that if it's not there look in
the next one look the next one and so on
which is why you can get packaged
conflicts and all kinds of other nasty
surprises on the class path the module
path is a way to find whole modules once
the module system finds one module on on
the module path then it will only read
the packages in that mod in that model
from that module if some other module is
resolved and winds up declaring the same
package in a way that conflicts then the
module system will report an error and
stop you know at both at both compile
time and at runtime so let's see some of
those potential failure modes suppose
suppose I somehow misplaced the text
module
if I try to run things now modular open
JD JDK text not found required by org
open JDK hello the module system tells
you what it was trying to do and what
failed if I try to come recompile the
hello module then again a compile-time
error module not found so there's
there's no there's there's no no
possibility for cheating here and we and
we've tried as much as we can to make
both compile-time and run-time work in
exactly the same way they should they
have a except for some obscure cases
they have exactly the same behavior are
great let's let's restore that text guy
make sure it runs again yep there we go
all right so another another failure is
well we already saw the failure with
missing requires so I I don't need to
don't need to show that again another
interesting thing that the module system
guarantees what do you notice about this
graph mm-hmm it's clean yeah yeah it's
it's kind of pretty isn't it yours years
of hard work went into that
there are no cycles very good the module
system guarantees that there are no
cycles so I suppose I go to the module
declaration for the text module and I
say requires org open JDK
hello you know and it might be tempting
to do this if you're modern rising some
existing system and you've got to jar
files then look kind of like modules but
each one needs some stuff for the other
and you can't figure out how to
disentangle them you know it's a natural
thing to think oh yeah I'll just make
each one require the other but in the
long run that's probably going to come
back to bite you so the model system
just doesn't allow it it's it may see it
may seem harsh but in but it really is a
better way to live all right so let's
recommit stri to recompile the the text
module oh dear
yeah save it first mark error cyclic
dependence involved evolving or go p--
and JDK hello so you get reliable
configuration not just at runtime but
also at compile time
alright let's fix that up and then
another failure mode is suppose that I
forgot to export this
what'll happen that so I can certainly
recompile the text module but if I now
go and try to run the application again
I get an illegal access error classwork
OpenJDK hello main in module or go to
JDK hello cannot access or go p-- and
jdk text patter in module or go p-- and
jdk text because text does not or does
not export the text package to the hello
module so it seems kind of remote
verbose but this is basically ought Thea
this is like everything the mantra
system has to tell you and it will
hopefully be enough information to help
you debug the problem the problem
there's a quick question
does it give any warnings no this is a
heart failure right yeah let's let's
take you a after please all right so let
me undo that and now we're back to a
working system all right so a few other
words about what's going on here
as far as the mountain as the modular
platform is concerned there there are
these these 26 standard modules the JDK
itself actually has quite a few more we
can see that there's a handy option to
the Java launcher called Java list
modules whoa
there's 75 in in an open JDK build if
you get it if you get an Oracle JDK
build there are more eventually there
will be the same number in each of them
my after we open source some more stuff
from the Oracle JDK let me make that a
little easier to read so on the Left
column you can see a bunch of the Java
modules of those are the standard Java
SC modules and the right-hand column you
can see modules starting with the
letters JDK those are JDK specific some
of the quite a few of them export
nothing they're just internal
implementation modules maybe they
provide an internal service that that's
used by other JDK modules in other cases
they contain tools for example you know
J shell is in its own module some
internal internal api's are in their own
modules and so forth so so that's all
that that's a lot of modules I already
showed you the modular Java doc let's
just take another quick look at that go
back to the top it's organized into the
front page is organized into three
sections you've got this the 26 standard
SE modules at the top and then the jdk
modules in the middle you can say see
more information about all of these and
then at the bottom we have the JavaFX
modules and then a couple of others that
are kind of in never-never land
they're stated with the these are
oddballs they're standard they're
standard in that they've been
standardized in the JCP but they're not
part of the Java SC platform
specification that's why they're
classified as other
alright one last thing I'd like to show
you before we go into questions is J
link so I did a quick demo of J link in
the keynote yesterday J link is how we
can take a set of application modules
and merge them together with just the
subset of the JDK modules that those
application module needs modules need in
order to create a compact runtime you
know custom runtime image that you can
deploy you can stick in a docker image
then you had to play to the cloud
through a worker pipeline or whatever
and it'd be much more compact so I have
your here's here's my here's my build of
JDK 9 I've been using I can ask how big
it is and it's 347 megabytes which well
yeah okay that's kind of big let me make
a custom runtime that contains let's see
weld will will start which by making one
that just contains the base module for
kicks and grows so J Lang Mon droit you
the files I need to do this are in the
j-mods directory here
so for every module in the JDK there's
one of these J mod files now these
aren't jar files because they contain
things that jar files cannot or should
not contain like native native libraries
you know shared objects dll's whatever
and so we so we had to had to use a
different format for the models of the
jdk itself J mod is a format that's
that's that's documented if you if you
need to ship a module with native code
you can use it yourself but for most
purposes if you're just dealing with
pure Java than a modular jar file it's
perfectly fine anyway I've got my j-mods
let's let's link a little image here
I'll say J link well I gave link takes a
module path just like the compiler in
the runtime I tell it where to put its
results make a directory called JRE you
always have to tell J link which modules
to add in this case we just want Java
updates and nothing else and J modes not
J mods marked boy am i spelling today
horrible okay there's my tiny JRE and
it's only 43 megabytes
now it doesn't get this gets get smaller
still
but you know there it is it thinks it's
a it's thinks it's a runtime but it
doesn't actually have much in it so
let's make a cuss another custom one
that contain a contains our tiny
application take this jailing command
we'll tell it where to find our modules
will output into say HJ r e4 hello JRE
and we'll add org OpenJDK hello and this
this won't work excuse me I just need to
fix one little thing here
there yeah
okay now to work so I run j-link
it's a little bit bigger
looks wrong Jerry use this one right
hello world all all bundled up there
with it with its own little runtime
mm-hmm yeah that's that's curious isn't
it gentlemen front rows pointing out
that aah Jerry Jerry is a little bit
smaller I'm not sure why that's a
rounding error curious must be that link
time optimizations guy I not sure but
it's a good question ought to look into
that we can we can make this smaller
still there are some additional mob
options we can use for example strip
this will make it a lot smaller strip to
get debug information we can compress
class files and we can even ask it to
make a launcher for it for us
takes a little more time because it's
doing more work and now here's our HJRes
e is only 28 Meg's
we look in there we have a handy hello
launcher for a tiny application it works
so 20 megabytes stick that in a docker
image with Alpine the Alpine Linux
kernel it'll get up to you know 3035
drop it drop to play that into cloud and
you can and you have a hello world in
the cloud well you probably want to make
it talk to the web rather than standard
outfit okay
that's the prepared part of this now
we've got time for questions for about
15 minutes I'm happy to demo demonstrate
other stuff or or just answer questions
there's a there's a hand mic here you
want to run around okay great
and oh and we'll run around with the
MyPlate please wait for the mic because
the session is being recorded if you
just shout it out it won't make it to
the recording and if I repeat what you
say I'll probably get it wrong okay hi
Peter hi hi muck so this mean well now
you've got rid of kuba yesterday I
didn't think we were gonna get rid of it
what about java.util date and and
calendar why would we get rid of those
because you've got the new ones the new
date and time since Java right
while we holding onto these or why are
those not going to be deprecated Oh
rather why couldn't those classes be
made into a module in itself okay good
questions so double util date if you
look at it it's actually almost
completely deprecated already I believe
but all all of the troublesome aspects
in Java util date were deprecated a long
time ago because sorry the classes it's
just so bad but there's there's a
there's a cost-benefit trade-off here
right I mean yes we'd like to remove
things from from java SE and from the
jdk that are no longer you know
compelling as parts of the platform
where's parts of the implementation and
you especially you know think things
like you know things like Jax be you
know jax-ws
you the jdk it has never really been the
proper home for those they're maintained
elsewhere they're part of Java EE if you
need them go get them from you know
maven central or wherever wherever you
find the EE artifacts so there's really
you know back it back in the day when
those were added in in Java 6 there was
an argument that yeah ok we think these
things are gonna be broadly used put
them in the jdk because that's we know
that's broadly used and people weren't
so used to just downloading stuff off
the internet but you know we're in a
different world now something like Java
util day-job you look calendar yes I
totally agree their horrid api's I'm so
happy we got better ones in Java 8 but
what would that what would the cost and
benefit be of removing them you know the
the cost would be we would break some
existing code because we know because we
often do scans of like many of there are
files and they've been central to 0 as
there are libraries out there that are
recent that are using these old crafty
api's and the answer is yes so yeah ok
we could we could take those out we'd
break people's code would it save us any
maintenance burden
maybe a little but in the end yeah
probably not that much and it's probably
not worth breaking people's code just
for that reason so instead Mia where
they are deprecated they're not
deprecated for removal but they've been
deprecated for a long time and in in
most cases you know with with a
referencing of go use go use job it out
time over there it's way better as to
why we can't put Java util date in its
own module and then remove that module
that the technical reason for that is
modules cannot have conflicting packages
so Java util has to be in one module
that module is Java dot base we can't
have another you know Java dot broken
dot date module that has Java util date
in it in the same package the module
system won't resolve that so in in in in
earlier prototypes of jigsaw way back in
the day Alan what we'll remember we
actually we struggled with this we
actually had a prototype that allowed
modules to have conflicting packages and
it it became just a hairball to think
about and and reason about and specify
so we just backed off it's you kind of
like forbidding cyclic dependences it's
a much saner world if you just forbid
conflicting conflicting packages in
modules that are related to each other
you know in principle if you have a big
system with a lot of modules you have
module two over here in module over
there and they never see each other they
can have conflicting packages but if one
module you if models are somehow related
in a graph then then they can't all
right yeah hi I had a question regarding
the access qualifiers for example like
in a class you declare public private
etc does it make sense to I mean is
there any plans for heading into the
module so that a particular module can
be either exported or required by
specific modules or so sorry by a model
can let's say you want your model to
only be used by some other modules let's
say yes so some sort of X's qualifiers
like public private protected etcetera
yes there is a way to do that but but
not in the way that you just described
there's a feature called qualified
exports so if I go to go into my text
module and suppose I want to ensure that
only the holo module can use this
package I can say exports org openjdk
text 2 or dot OpenJDK hello
and now the hello module can require it
but have said it but if some other
module requires that that will cause an
error to be recorded and that this is a
facility we used we used throughout the
JDK itself let me show you
so here's the module of declaration for
the base class itself exports a whole
bunch of things what you would expect
Passover services and then it exports a
bunch of things in a qualified fashion
to other modules in the JDK so things
like JDK internal dot loader to Java
instrument and Java dot logging so only
those modules can read again can you use
the api's in in these packages so it's
it's not a facility that many people
will need to use but when you need it
it's it it works quite well now on the
on a service that's it might look that
it's just based on name and you could
think oh well all I need to do to foil
this is a is name my module Java dot
instrument right and then I can get to
the stuff in in this magic package in
the base module that's not true because
there's an additional mechanism built on
top of this you can take a collection of
modules and hash them together so your
winds up recording all the hashes of all
the modules in in the leaf modules of
its graph and those hashes will be
checked to ensure the qualified exports
are being honored in the proper way so
if you so you could try to masquerade
your own module name Java that
instrument but you still won't be able
to do this so that's how that's one way
we ensure the integrity of platform
hello I basically have two questions one
is general and one is more technical so
I start with general in what
circumstances would enterprise
development need to split into modules
in what circumstances in enterprise
development would you need to split
split things into modules well if you
know I guess it depends are you happy
are you happy with the class path there
are tools that does it for me yeah so so
modular right so they're they're kind of
multiple multiple answer two answers to
this
as things stand because Java has never
had a built in module system you know
there are many solutions have grown up
around the platform to solve parts of
the modular development programming in a
large set of problems right so maven you
can think of as sort of a model system
at build time but there are limits to
what maven can enforce because after all
pre nine it's just dealing with jar
files on a class path which are
completely leaky and not really I mean
jar files jar files on the class path
give leaky abstractions a bad name right
there they're just file systems on
sticks so you know maybe it helps it
helps a bit with that if you're building
an EEE application the traditional style
you'll have deployment descriptors and
all of this other other groups that put
that assembles EE applications and that
works what we're trying to do is
establish a foundation for for a better
future right we're not not replacing all
that stuff all that other stuff will
continue to work fine probably forever
but certainly if you're developing new
code I think it's worth thinking about
starting with modules from the get-go so
the so that your code can benefit from
reliable configuration and strong
encapsulation in all phases of
development you can use the linker if
you don't if you don't have modules you
can't use j-link that's you know that
there's enough there's another benefit
to it but you know as I said in the
keynote yesterday Y wide adoption of the
module system is
is going to take time and it's really
hard to take an existing system and
modularize it and if you have such a
system it might not be worth it right if
it works fine as it is and you don't
expect to do a lot of new development
then you know stick with your current
build system and and whatever other
tools that you're using but if you're
good if you're going to start start a
greenfield project then then consider
using modules there are benefits to it
so you got a technical question as well
yes I saw in one of the presentations
there are static requires transitive
cars
yes could you give some description to
use right so so there there are there
are more elements to to module
declarations than I've been able to show
here I'm not sure I'm not sure if Alex
Alex may have covered these in
yesterday's presentation I didn't see
his I didn't see his final really didn't
touch okay core static yeah so so
they're there they're there are
additional things that probably the most
important one is is requires transitive
let me just explain that one quickly in
the little time remaining
right so Rico so requires when you're
right
hello requires text that makes the
exported packages of the text module
accessible to code in the hello module
but suppose suppose Hello itself were
you it was going to explain you exported
something suppose it exports Oracle JDK
hello and suppose there was a class in
Oregon with JDK hello those was say a
subclass of some class in Oregon and JDK
text all right you can do that but now
if some model that requires org open JDK
hello it will have to require Oracle
viniq a text to in order to use that
class you just made so what you can do
is say requires transitive and what this
does is introduce a one step additional
transitive relationship so that what
this means is any module that requires
org openjdk hello will implicitly also
require org openjdk text so if you're
defining an API for other modules to use
and that API contains classes or
interfaces from a module that your
module uses then requires transitive is
you're providing a benefit to the users
of your module by making you know
basically reducing the amount of work
they have to do it is a commitment
though because once you requires
transitive you're basically taking on
the responsibility to be providing those
other packages to any model that uses
your modules so it's so just as with
exports you want to think carefully
about well if I'm exporting this now do
I still want to be exporting it two
years from now or is it gonna come back
to bite me because it's really an
internal API
wait wait wait for the microphone please
recorded that's a good segment towards
like going forward how do you envisage
this to work going forward with terms of
versioning internally in the JDK and
then also externally like once these
modules change and like whatever is in
say open JDK text is different now right
so so some modules in the jigsaw mob
system do not have have versions right
there are no version constraints you can
add version information to a module as a
matter of documentation when I did this
you may it may have noticed there
they're all these at 9s that means the
version number inserted by the build
system for diagnostic purposes is nine
but the module system doesn't do
anything more than convey this
information so that you can diagnose and
debug a system that's not working
properly the important thing in this
design is but modules are highly are a
different concept than the artifacts
that define them artifacts have version
numbers and and that's great and that's
good and tools like maven help deal with
conflicts amongst them but the module
system is only dealing with modules in
terms of their names and if it needs to
ensure integrity we have the hashing
mechanism for that so you know and and
and going forward I expect modules in
the JDK every time there's data key
release we'll have a different version
number but it will not be the case that
what one might think that well if we
don't change anything in in the JDK J
shell module in JDK 10 or 18.3 then
it'll still be JDK or JDK dot J link at
9 in that release now alone though
they'll all have the same version number
they'll be hashed together to protect
the integrity of the platform that
that's that's it we're out of time I'm
afraid thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>