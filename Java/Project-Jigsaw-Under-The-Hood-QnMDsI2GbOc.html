<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Project Jigsaw: Under The Hood | Coder Coacher - Coaching Coders</title><meta content="Project Jigsaw: Under The Hood - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Project Jigsaw: Under The Hood</b></h2><h5 class="post__date">2016-08-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/QnMDsI2GbOc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone so welcome to project jigsaw
under the hood my name is Alex Buckley
I'm in the Java platform group at Oracle
just to say this is a 45 minute well
this is a 45 minute presentation with 55
slides so I'm going to go speedily
through them I would like to not take
questions if possible during this
session there is a workshop at 3:00 no
4:30 I think it is where mark Reinhold
who's over there and I and I guess Allen
Bateman will answer everything you ever
wanted to know and all the things you
don't about jigsaw so it'll be good if
I'm sure you'll have questions
especially you but if you could hold
them until the end that'd be great
so jigs are under the hood in jeddah
canine the main feature is a module
system that lets code be more reliable
and maintainable we've used the module
system to turn the monolithic JDK into
the modular JDK breaking up the RT jar
file as you've heard inside the JDK into
dozens of reusable modules gdk9 also has
small enhancements to the java language
and somewhat larger enhancements to the
standard libraries plus Java gets a
search box and the JDK includes a repple
at last project jigsaw is a project led
by Oracle in open JDK it's the container
for all of our work building a module
system and modularizing the JDK we're
standardizing the module system in the
Java community process through jsr 376
we're also standardizing the structure
of the modular JDK in the java community
process through the umbrella jsr for
java SE 9 when you use JDK 9 you're
always subject to the rules of the
module system that's what's under the
hood and it's what most of this talk is
about though I'll touch on some aspects
of the modular JDK near the end the talk
has four parts the first part explains
how the module system works with the
java language and vm
to improve reliability of your code the
second part is about migrating to
modules the third part explains what the
module system is fundamentally capable
of beyond what you can express in the
language in VM in the language and the
fourth part is about preparing to run on
JDK 9 and how frameworks can take
advantage of the module system so part 1
everyone knows the hierarchy of
accessibility in the java language and
vm it's simple to understand easy to use
and strongly enforced by the compiler
and vm but it has a big weakness the
only way to share code between packages
is with public but they're not sharing
with everyone it's not surprising the
packaged friendship in one form or
another has been requested many times
over the years one goal of the module
system is strong encapsulation to allow
a component to declare which of its
public types are accessible to other
components and which are not the lines
in italic are the levels of
accessibility connected with the module
system reading upwards you can arrange
for public types to be accessible only
within their module or accessible within
their module and to specific other
modules or accessible to everyone now as
usual migration drives a lot of our
thinking we want to make it easy to
place an existing package into a module
and immediately give that package the
benefit of strong encapsulation
we don't want each and every public type
in a package to have to opt in to strong
encapsulation
so public types in a package are not
accessible outside their module by
default that is public on a type
declaration no longer means everyone can
access the type what happens if someone
tries to access a public type that's not
accessible here's an example from
GlassFish 4.1 to be fair this is a few
months old now so it may have been fixed
at the time GlassFish 4.1 didn't start
on jdk 9 because the VM throws an
illegal
excess error the error message is class
comm son enterprise security provider
policy wrapper an unnamed module don't
worry about that yet cannot access class
son security provide a policy file in
module Java base the point is that the
class son security provide a policy file
is declared public but since it's a JDK
internal API it's now accessible only
within the Java base module
sorry GlassFish you need to find an
alternative API anjana k9 modules are
first-class program components like
classes and interfaces here is the Java
declaration of the Java doc sequel
module that contains JDBC it's in a file
called module info Java in a directory
named after the module source Java
sequel the compiler treats it like any
other Java file and translates it to
module info class which you can put in a
jar file as normal we call that a
modular jar the package hierarchy exists
in the same directory underneath jar
sauce Java sequel so module info dot
Java is outside all of the packages in
the module and it's the job of the
module declaration to say whether a
package in a module is strongly
encapsulated or not it's easy to get
strong encapsulation don't mention the
package in the module declaration to
allow other modules to access the
package or more specifically the public
types in the package add and exports
Clause you can export to all other
modules or you can say exports to to
give access to only your friends modules
so to be clear module Java dot sequel
that's the module name the exports
clauses are naming packages the naming
packages they just have similar syntax
at compile time Java C prevents code
outside this Java sequel module from
accessing any packages except for those
listed you get the same compile time
error as when you try to access a
package private type from outside its
package
at runtime the VM throws an illegal
access error like you saw with GlassFish
let's look at the VM more deeply
traditionally accessibility in the Java
platform is about who is doing the
access and what is the public protected
private flag of the target class the one
you're trying to access at runtime the
VM uses the class loader of the
accessing class to find and load the
target class and then the VM checks two
flags on that target class now because
the VM relies on class loaders people
can create loaders that only know how to
find and load classes of certain
packages in effect loaders can isolate
one package from another in the top
picture class PC is trying to access
class QD the load of the PDC knows to
delegate to some other loader for any
class in package cues such as QD only
when that other loader has loaded QD can
the VM check its flags to see if a PC
can access it in the bottom picture the
load of P dot C has been set has been
set up to have no idea where to find
package Q so no access to Q dot D is
possible from PC now technically this
isn't a failure of accessibility because
the VM never gets to check the flags of
Q dot D instead it's a failure of
visibility Q dot d is invisible to P dot
C by reason of class of the delegation
but the effect is still quite powerful
if the class loader of the accessing
class P dot C can't find and load the
target class then it doesn't matter if
the target class is public it's
effectively encapsulated whoever sets up
the class loaders sets up the
encapsulation but encapsulation based on
class loaders is not strong
encapsulation sadface yes sad face it
relies on packages being carefully
apportioned in two different loaders but
that isn't how the JDK has traditionally
worked most code in the JDK is loaded by
the bootstrap loader
while code on the class path is loaded
by the application loader and
spinning up lots of loaders for all of
that code would be you'd have
compatibility side effects like you
wouldn't believe and in any case with
multiple loaders lots of multiple loaded
lots of loaders there's no actual
isolation you can circumvent class
loaders by getting hold of references to
java.lang class objects and once you
have a class object the loaders are
irrelevant and it's impossible to stop
references to class objects from being
passed around so strong encapsulation is
about being able to prevent access even
if the accessing class and the target
class are in the same class loader and
even if someone is using core reflection
to manipulate class objects let's assume
that multiple modules are somehow maxed
at the same class loader can class PC in
module X access class QD in module Y now
another goal of the module system is
reliable dependencies to replace the
brittle error prone class path mechanism
with the means for program components
modules to declare explicit dependencies
on one another in order for P dot C to
access QD not only does module Y need to
export package Q but module X need to
explicitly depend on module Y the formal
name for depends on is readability
readability underpins accessibility in
the Java language and VM the accessing
class P dot C must be in a module that
reads the module of the target class
module Y and the module containing the
target class module Y must export its
package Q to at least the module of the
accessing class so you can see that
accessibility is a two-way streets
module X read module Y a module Y export
package Q to at least module X note here
the accessibility is independent of
class loaders just like before the
module system this is important for two
reasons
it means accessibility
works at compile-time when there aren't
any class loaders and it means you can
reason about accessibility based solely
on requires and exports clauses in
module info Java there's no need to
worry about what class loaders may or
may not be in existence at runtime so in
fact the export part of accessibility is
quite straightforward a packages either
exported or it isn't but our readability
there's more to say when you depend on a
module you depend on a hopefully
coherent set of packages that are
exports in some sense those packages are
the interface of the module inside the
module hundreds more packages may sit
strongly encapsulated waiting to help
implement the interface and more than
that when you depend on a module you
indirectly depend on all the modules it
depends on for example if you depend on
the Java got activation module in the
JDK with its 35 classes then you also
depend on the Java desktop module with
its five thousand eight hundred and
thirty five classes if the watchword for
JDK eight was functional the watchword
for JDK 9 is transitive
you should think in terms of the set of
modules needed whether you like it or
not frankly transitively by your
application and those indirect
dependencies can be as important as the
direct dependencies so let me show you
how readability handles that this is an
example of readability from the graph of
jdk modules the Java sequel module on
the Left that holds JDBC requires the
Java logging module that exports the
packaged Java util logging this lets
code in the Java sequel module access to
public types of Java util logging such
as logger you can see that some code in
the JDBC driver manager class is newing
an instance of logger what if the API of
the Java sequel module rather than its
implementation wants to use the logotype
for example the JDBC driver interface
has logger in a return type
let's look at this through the eyes of
an application module that uses JDBC my
app in order to use that driver method
that returns a logger the my app module
not only needs to read the Java sequel
module but also the Java logging module
which exports that logotype it will be a
pain if the developer of my app at the
top had to remember to say requires Java
logging when using the API of Java
sequel sadface my app has to remember to
write that the good news is that the
Java sequel module can take on the
responsibility of remembering look at
the Java sequel module now it says
requires public Java logging the word
public here means that anyone who reads
the Java sequel module also reads the
Java logging module for free the my app
module which reach Java sequel doesn't
have to bother with requires Java
logging because it read Java logging
thanks to reading Java sequel happy-face
Crossout requires java logging this is
called implied readability and it's very
powerful it's powerful because it lets a
module will be refactored without
breaking its consumers for example
suppose that the Java logging module has
some auxilary packages that we'd like to
start shipping in a separate module log
extras the Java logging module can say
requires public log extras so that my
app up at the top many maybe many levels
further up my app which implicitly reads
Java logging thanks to reading Java
sequel also implicitly reads long extras
my app will be unaware that this this
refactoring is happening so the
readability module supports downward
decomposition any module you read can be
decomposed into new modules and a
readability of those new modules can be
recovered with the requires public
clause in the old module
you can see that the definition of reads
is recursive module X reads another
module way either by requiring it
directly it requires Y or by reading
some third module Q there's the
recursion where Q says requires public Y
and now that X reads y Y can say
requires public Z and now X read Z so
you can keep on decomposing all the way
down not affect the consumers now be
careful once people require your module
explicitly you can refactor it downwards
as much as you like but you can't delete
it there's no way for a module to stand
in for another module by taking its name
as an alias
if someone requires X and X is deleted
the module system won't start everything
so far has been about accessibility in
the Java language and VM where the
accessing class PC and the target class
QD were known statically comfortable but
accessibility extends to dynamic class
references that you manipulate with the
core reflection API java.lang reflect in
this code the parameter C is a reference
to some class object it's dynamic we
can't control what class object is
referred to by C at runtime maybe it's a
class object representing a private
class private nested class of an
unexploited package of an unreadable
module that is a class object that very
deeply represents an inaccessible class
similarly we can't control what ms
refers to maybe it's private methods of
that inaccessible class we want to
ensure strong encapsulation even when
core reflection is used to access types
and their members the only opportunity
to do this is when an operation like new
instance is performed than a class
object or get on a java.lang reflect
field or invoke on a java.lang reflect
method these operations now perform the
same pair of checks as the compiler and
VM does the caller module will read the
target module and as the target module
export the relevant package to the
caller module now
in core reflection for convenience the
answer to the first question is always
yes the caller module is just assumed to
always read the target module this is
because a module can always choose to
read more modules at runtime by
reflecting on itself so there's no point
making the caller module do that dance
to reflect every time so core reflection
works as is as if every module reads
every other module in contrast the
module system API does not allow a
module to augment the exports of another
module a module can only augment its own
exports and if it didn't you can't
reflect your way into it even said
accessible respects strong encapsulation
suppose you have a java.lang reflect
field that represents a private field of
the public class sounds good so far but
that public class is in a package that's
not exported so accessible true will
fail it can't manipulate the
accessibility of it of anything in a non
exported package just like the get
method of java.lang reflect field said
accessible performs the same pair of
checks as the logically performs the
same pair of checks as the compiler and
VM does the call a module read the
target module and there's the target
module export the relevant package to
the caller module again the answer is
yes for the reading part for convenience
so it comes down to whether the target
module exports the package in order for
set accessible true to succeed
that's accessibility and readability you
have questions I understand
let's talk about them at the workshop it
used to be a simple check it was public
all same package leave out protected
it's a nightmare in 9 the accessibility
is used to strongly encapsulate module
internals and the accessibility relies
on the readability relations between
modules which can be direct or implied
and this accessibility fundamentally is
enforced at compile time
runtime and reflection so different
kinds of modules
everything so far has been about named
modules modules explicitly declared with
a name in module in photo Java
what about jar files on the class path
that don't have a module info or class
file they seem to be in a world of their
own to keep the model of accessibility
and readability consistent we introduced
the unnamed module all classes not in
named modules are in the unnamed module
it's as if watch the left everything on
the class path is in one big module
because it's the module we can ask two
questions what does it read and what
does it export what it reads is simple
every named module all of them as if by
magic
for free there's an asterisk after that
we can talk about that as well this
means that anything exported by a named
module can be accessed by the unnamed
module you can turn a jar file into a
named module by adding module in for
class and putting that jar on the module
path when named modules are found jars
left on the class path will not realize
anything has happened because they're
reading for free that named module
youÂ´d is made that's a huge help for
migration the next question is what the
unnamed module exports before that
though we should ask who reads that
unnamed module now remember our goal in
the module system is reliable
dependencies we believe very strongly
that named modules whether in the JDK or
outside the JDK should not read the
unnamed module out of the box it would
make a mockery of reliable dependencies
to let named modules depend on the
arbitrary content of the class path so
you cannot write requires unnamed or
requires class path in module in photo
Java there are no reads edges going out
to the unnamed module of course this is
a huge hindrance for migration because
any jar you turn into a named module
can't access the jars left on the class
path the answer is automatic
Jules you can take a jar say guava jar
and move it from the class path to the
module path this turns the jar into an
automatic module that's all you have to
do an automatic module is a named module
declared implicitly rather than
explicitly its name is derived from the
jar file named in obvious ways putting
guava jar on the module path gives an
automatic module called guava as before
whenever you see a module you should ask
what does it read and what does it
export the automatic module guava reads
everything in the JDK and the unnamed
module it's as if it says requires
unnamed now the hindrance to migration
is gone you can turn a jar into an
automatic module and it can still access
the jars left left on the class path we
asked earlier what the unnamed module
exports the answer is all its packages
all all the packages in j-unit jar and
GlassFish jar and hibernate jar
precisely to help code in automatic
modules which read the unnamed module
there's the arrow going out to it and
because an automatic module is a real
named module another named module can
require it so suppose the myapp module
from before says requires guava so
there's a reads edge from my app to
guava what does an automatic module like
guava exports that's easy
all of its packages so my app can access
all the public guava types my app could
even say requires public guava to
transmit its dependency on guava up to
its own consumers so that anyone who
reads my app would read wather for free
so by moving a jar from the class path
to the module path you get an automatic
module that lets you start building up
your own graph of modules it's not
necessary to wait for every jar on the
class path to be modularized by its
author before you start developing
modules like my app that require it so
there are three kinds of modules
explicit named modules
like Javadoc sequel automatic named
modules like guava and the unnamed
module aka the classpath and you can see
there's lots of readability for free to
help with migration part 3 I said before
that strong encapsulation is independent
of class loaders and if I didn't pretend
I did this means that the model of class
loading in JDK 9 is unchanged the
mechanism of loader constraints is
unchanged the notion of runtime packages
is unchanged the java.lang class loader
api is essentially unchanged in addition
the actual class load is in JDK 9 are
unchanged from JDK 8 there is a
bootstrap loader there is a platform
loader renamed from extension and there
is the application loader some some
people call system not me
traditionally the vast majority of JDK
classes were defined by the bootstrap
loader and indeed critical JDK modules
such as Java dot base still have their
classes defined by the bootstrap loader
for non-critical JDK modules it's
important for security to move their
classes out of the bootstrap loader
modules in the bootstrap loader run with
all permissions which is not ideal from
a security perspective and they can only
be D privileged that is run with fewer
permissions if they're not defined by
the bootstrap loader so in jeddah canine
all the modules containing Java EE
technologies such as Java coober have
been moved out of the bootstrap loader
as well as the JDBC modules Java sequel
and Java sequel rosettes their classes
they're all defined by the platform oder
frankly moving a module as big as Java
koba 1831 classes and 31 exported
packages is no small accomplishment that
the privilege in work of minimizing the
permissions that will continue for many
years now the application loader is then
responsible for every
else a number of JDK tool modules such
as JDK compiler have their classes
defined by the out loader all classes in
modules on the module path whether
they're in a modular jar or in an
automatic module like guava from before
are defined by the application loader
all classes on the class path in
traditional jar files like j-unit or jar
and glass crystal jar are defined by the
application loader so very little in
some ways has changed there are a couple
of things to say about compatibility
first frameworks that delegate directly
to the bootstrap loader to find JDK
classes might break on jdk 9 because
many JDK classes aren't there any more
frameworks should use the new class
loader method get' platform class loader
which returns a loader guaranteed to
provide visibility of exported jdk
classes seconds the application loader
is no longer an instance of URL class
loader frameworks that assume it is in
order to hack into its add URL method
will break on jdk 9 the only supported
way to dynamically extend the class path
is with the class path attribute and jar
files with the agent API in Java
instrument now you may be wondering
where the module system itself lives in
all of this it's important to realize
where the module system isn't
traditionally a module system was simply
Java code that acted as a factory for
class loaders there it is Java code in
the uploader it created loaders the
defined class is found in modular
artifacts and the load is delegated to
each other in accordance with some kind
of modular imports and exports as I
mentioned before there is there are some
encapsulation of classes there because
the loaders can hide classes from each
other a module system that does this
will still work on jdk 9 because class
loading hasn't changed but the module
system in jdk 9 is quite different the
module system in jdk 9 is not a factory
for class loaders but rather a conduits
that allows modules to be communicated
to
vn whoever creates the class loaders is
responsible for using the module system
api to transmit module names contents
dependencies and exports down to the VM
that's how the VM knows enough to
enforce accessibility it's also how the
core reflection API can enforce
accessibility since it's based on VM
provided class objects you can think of
the Java launcher as creating three
loaders and doing that transmission for
modules on the module path you can see
why we wanted the module system to be
disinterested in class loaders the jdk
has been factored into dozens of modules
but it's three class loader architecture
hasn't changed encapsulation is provided
by true the EM level accessibility not
by class loader based visibility so the
module system doesn't need to mandate
one loader per module that can handle
multiple modules per loader just fine
you'll recall I talked earlier about the
unnamed module as a vehicle for
compatibility strictly speaking I was
referring to the unnamed module of the
application loader every class loader
actually has an unnamed module if the VM
sees a class being defined by a loader
and the VM can't associates that class
with a named module that was transmitted
earlier the VM treats the class as being
in the loaders unnamed module and as you
might guess the VM always allows access
to public classes in an unnamed module
everything works as before so this will
means that every class actually is a
member of a module even classes in jar
files on the class path in red are
members of a module that's the the
seventh blue box in the VM on the right
is the unnamed module of the apt loader
so if you have a class object the get
module method will always return a
java.lang reflect module object the
module system introduces the concept of
a layer to associate loaders with
modules a layer is a family of class
loaders that together serve to load
classes for a graph of modules logically
the Java launch
defines the boot layer consisting of the
three familiar loaders it's the boot
layer that associates the Java base and
Java logging modules with the bootstrap
loader Java sequel and Java Korbel with
the platform loader and so on a layer is
created from two things a graph of
modules and a function that mapped
modules to loaders on the left is the
graph from resolving the jdk j-link
module which contains the j-link tool
for building runtime jdk images on the
right is a lambda expression mapping
modules to the bootstrap loader and the
application loader creating a layer
informs the module system about the
packages that will exist in the program
and the modules they'll come from the
module system passes this information to
the VM so that when classes are
eventually loaded and defined the VM
knows which module a class belongs to
and what that module reads and exports
it's like the VM has a shadow copy of
the module graph that it uses when
checking accessibility between classes
now because of how class loading works
which hasn't changed the module system
must enforce certain constraints on a
layers module graph and on the layers
layers mapping from modules to loaders
let's talk about the graph first this is
the graph of modules in jeddah canine
the main thing to notice is that it has
no cycles this is the first and biggest
constraint on a module graph it's taken
almost a decade to detangle the tens of
thousands of classes in the JDK to the
acyclic and relatively sane state you
see here we'd like to keep it that way
in fact one of the motivations for
investing in modular ization of a
codebase is the knowledge that once
complete there won't be any backsliding
into the ball of mud that cyclic
dependencies allow the second constraint
on the module graph is that a module
must read only one module that exports a
package P if a module could read more
than one package if a module could read
more than one module that exports P as X
is trying to do here X are trying to
read Y the exports pain also trying to
read Z which exports P in what in which
module would P be accessed really
there's no answer the module graph is
just broken so we defend against that
only module graphs which obey this
constraint top line and have no cycles
can be turned into a layer that's really
what we mean by reliable dependencies
dependencies are reliable when a module
can access only one version of a package
at a time there are no split packages
like you get when multiple jars on the
class path contain potentially different
versions of the same package now you
might wonder if it's possible for X to
read one version of to read version 1 of
module Y while at the same time another
module reads version 2 of module Y after
all
X and the other module would each read
their own version of Y they'd each read
only one module exporting P the answer
is that it's not possible because it
would only work safely in certain
scenarios and outside those scenarios
it's not clear that supporting it out of
the box which is to say in the boot
layer with the Java launcher and
supporting the Java compiler is
worthwhile but that's certainly
something we can talk about
recall that a layer includes a module
graph for which we saw two constraints
and a mapping from modules to loaders
the main constraint on the mapping is
that if different modules in the graph
have a class called si then those
modules must be mapped to different
loaders perhaps these different modules
in the graph have the same internal
packages so they must go in different
loaders actually more conservatively we
say that if different modules in the
graph have the same package not just the
same class they must be mapped to
different loaders the mapping from
modules two loaders has one more
constraint that's not practical to check
because it concerns how load is behave
at run time but we expect class loader
authors to obey it anyway it's that
loaders must delegate to each other in
accordance with the reads
Reed's edges of the module graph the
reason is obvious if module X reads
module Y then in order for X's classes
in one loader to access Y's classes is
another loader X's loader must delegate
to Y's loader you now know enough about
named modules unnamed modules module
graphs and layers to appreciate an
exquisite interaction between jdk code
in modules and badly behaved jars on the
class path but there isn't time in the
session to go through it so please come
to our workshop today to hear about it
as their name suggests layers can be
layered when a graph of modules is
resolved it's actually resolved against
a parent layer then when the graph
helped to create a new layer that new
layer picks up the parent layer this
allows a graph of modules to have
dangling references that is requires
clauses for modules the module system
will find in a parent layer during
resolution on the Left resolution has
set up not only a reads edge between
modules in one layer but also a reads
edge between modules in different layers
now constructing a tree of layers in
this fashion is the job of a framework
and layers give frameworks tremendous
freedom to organize modules at runtime
without upsetting the frameworks
traditional uses of class loaders it's
like in vote dynamic it's a way for
framework developers to interact with
the VM to reify information about the
shape of program and so one scenario
where layers help out is supporting
multiple versions of modules here a
framework like an app server has created
two layers on top of the boot layer on
the Left the Hadoop layer reify is a
module draft with guava version 11 and
jackson version 1 on the right the
JavaScript layer reify is a module graph
with guava version 18 and Jackson
version 2 each module graph is
well-formed and mapped to loaders in a
sensible way but the modules in the
Hadoop layer are not aware of the
modules in the JavaScript layer and vice
versa but no this is all thanks to a
framework creating that how do the
Hadoop and JavaScript layers the Java
launcher doesn't create layers like this
all it does is resolve the module you
give on the command line then map
everything in the resulting graph to the
application loader with the boot layer
it supports only one version of each
module and the reason is to avoid the
nightmarish problems that occur when
multiple versions of the module casually
come into contact with each other it's
really only safe to use multiple
versions of a module when a framework
like an app server is in control so just
as modules wrap up coherent sets of
packages and interact with the vm's
accessibility mechanism layers wrap up
coherent sets of modules and interact
with the class load of visibility
mechanism there a higher layer thing
it'll be up to frameworks to make use of
layers in the next 20 years
just as they made use of class loaders
in the first 20 years
I urge framework developers to open the
JDK 9 Java doc and look at java.lang
module configuration and java.lang
reflect layer so that was a deep dive
into loaders and layers modules do a
better job of encapsulation than loaders
but loaders are still necessary layers
control the relationship between modules
and loaders and assuming class loaders
respect the module graph the system is
safe by construction no cycles or split
packages zooming all the way out we have
strong encapsulation of modules by the
compiler VM and reflection there are
unnamed and automatic modules to help
with migration and the system is safe by
construction no cycles or split packages
there's still a long road ahead
although the module system is
conceptually simple there are changes in
JDK 9 that probably won't break user
code but might break framework code I'd
like to go through them quickly there
are three areas of incompatibility in
JDK 9
connected with java resi the platform
first we've removed six methods from the
packages Java util logging and Java util
jar their signatures made the Java base
module depend on the Java desktop module
and no one wants that this removal was
announced in the umbrella jsr SE 8 in
2014 in addition we've removed two AWT
packages that were never supported
despite being in the java star package
namespace second the java ee types
shipped with the jdk are not accessible
by default this means Cober Jaxx be
jax-ws the Java activation framework and
the JDK subsets of the Java transaction
api and the common annotations api the
types are physically in the JDK image
but the modules are not read by the
unnamed module out of the box if you're
writing a module if you're declaring a
named module yourself no problem just
require Java clawber or require Java XML
bind whatever but if you're running code
from the class path you need a command
line flag to activate the EE modules
third the version strings reported by
system properties have changed code that
looks for one dots at the beginning of
the string will fail on JDK 9 that's not
a module system feature but I bring it
up because you get system properties
through a Java API and it's a very very
visible thing there are three areas of
incompatibility within the JDK
implementation first we've slimmed down
the Sun misc package some misc unsafe is
still accessible but Sun misc base64
encode and base64 decoder are gone one
thing you can do is run the Jade EPS
tool which came with JDK 8 overall your
jars it'll tell you if you're using
unofficial classes like Sun misc be 64
encoder and recommend official
replacements like the Java util base 64
class introduced in JDK AIDS
second many JDK internal API s are not
exported code that tries to access types
in the Sun net ww package or sun
security x.509 or calm Sun org Apache
xerxes internal Jack's P you laugh we
meet these people will fail with an
illegal access error the only way to
regain access is with a command line
flag third many internal aspects of the
JDK have been overhauled such as the
layout on disk and the implementation of
the three class loaders code that
assumes there's a file called RT jar or
tools lock jar in a particular directory
will fail on JDK nine scripts that try
to patch the JDK with minus X boot class
path /p will fail on gdk9 I mentioned
before code that assumes the application
loader is a URL class loader or that
assumes all JDK classes are defined by
the bootstrap loader will fail on JDK 9
the module system tries hard to support
migration but it takes only one
unmaintained library to prevent
migration to JDK 9 if that library won't
run on JDK 9 nor can anything on top of
it
please don't be that library very
quickly if you own a framework and it
doesn't touch anything I just mentioned
which frankly it shouldn't it should
work out of the box on jennyline suppose
the framework is loaded by the
application loader and it creates its
own loaders that subsequently load
scripts plugins classes what have you
recall there's an unnamed module in
every class loader the application
loader has an unnamed module and any
loader you create has its own unnamed
module all these unnamed modules read
each other and they export all of their
packages to everyone
they're real modules you can even label
them so they appear nicely in stack
traces alongside classes from named
modules like Java base so the framework
starts off in the unnamed module of one
loader the classes it operates on a
bubbly in unnamed modules of other
loaders any dependencies of those
classes are probably in the unnamed
module of some other useful loader
that's the modularized nothing stage the
next thing you can do is to modularize
your framework that is you deliver it as
a named module that's put on the module
path being a named module lets you
strongly encapsulate its internals and
express dependencies on jdk modules
ultimately the framework can be linked
into the jdk image as for the classes it
operates on they can still come from the
class path and be loaded by the same
loaders into unnamed modules
that's the modularized the framework
option an alternate next stage is for
the framework is its accept modular
input the one at the bottom it's for the
framework to continue on the class path
and live in the unnamed module of the
application loader but to accept modular
input that is to introspect on classes
in named modules the classes might be in
the JDK image or in modular jar files on
the module path ultimately the classes
in these named modules are loaded by the
application loader or its parent so
they're visible to the framework and as
long as that named module exports some
packages the framework can access them
to do whatever it needs to do the final
stage modular Rises the framework and
the classes it operates on this means
everything can be linked into a JDK
image and the classes are being operated
on and the class is generated by the
framework can be strongly encapsulated
the NASSCOM talk next we'll discuss
generating classes that support a
language implementation which no one can
access except the framework module you
don't have to change your class loader
hierarchy in any way just to find
modules at runtime to contain the
private classes and associate them with
your existing loaders via a layer last
slide
the single best thing you can do to
prepare for JDK 9 actually is run the J
depth tool which analyzes dependences
it'll tell you if your code or code you
rely on and you are on the fast path
will be affected by changes in jeddah
key 9 also please try the JDK 9 early
access binaries on java.net the module
system has been present and active in
these binaries since March 2016
everything you ever wanted to know about
the module system is discussed in jet
261 I cannot emphasize enough how much
valuable information lives in jet to 61
there's also jet 260 which defines JDK
internal classes which are nevertheless
exposed in jeddah k9 jet 223 which
describes the new version strings that
begin nine dots and jet 220 which
describes how RT jar has gone away
finally
jet 200 gives an overview of the JDK
modules but if you've already read jet
261 please reject 261 I promise you the
answers you seek are there there won't
be any surprises from seeing the JDK
module graph and with that only slightly
over time thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>