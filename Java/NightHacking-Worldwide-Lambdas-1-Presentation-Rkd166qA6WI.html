<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>NightHacking Worldwide Lambdas - 1. Presentation | Coder Coacher - Coaching Coders</title><meta content="NightHacking Worldwide Lambdas - 1. Presentation - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>NightHacking Worldwide Lambdas - 1. Presentation</b></h2><h5 class="post__date">2014-01-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Rkd166qA6WI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">tweet to hashtag night hacking and
Angela's monitoring and we'll try to get
those answered but without further ado
I'm going to turn things over to Brian
thanks what do you what do you have for
us today alright well I'm that I've got
a I've got a prepared talk here that I'm
going to try to keep down to like maybe
30 40 minutes that I'd like to just sort
of give an overview of the language
features in Java 8 so that everybody can
sort of come up to the same level before
we start in on the lab some of you are
you know playing along at home out there
you know have probably seen some this
material before you've probably read
some of it you know online so i
apologize if some of it is a review but
hopefully this should give everybody
these for a big picture overview of
where we're taking java in java 8 so i
have to show this line this is how you
know that I really work at Oracle so and
now let's get on to the presentation so
you know java SE e is this huge step
forward for java a lot of people express
the the opinion that java had kind of
stalled for a little while there were no
big language or library changes since
Java 5 and we've certainly tried to make
up for some of the lost time with that
in java SE eight so it's a big step
forward in a lot of dimensions to big
step forward and modernizing language
we've added a small number of features
that should have a pretty big impact in
particular lambda expressions or
closures and a mechanism for interface
evolution I'll call default methods
we've also done a lot of work at the
same time on the library's to take
advantage of these new mechanisms that
we added to the language to enable for
example both data operations on
collections and much better library
support for parallelism and these
changes were designed together they're
designed to work together and the
overall impact will be that this is a
significant upgrades the programming
model possibly even bigger than generics
in how it affects how people program
every day so
oh the big new feature obviously lambda
expressions if you've programmed in
basically any other language JavaScript
Ruby Python you you're familiar with a
lambda expression it an anonymous method
so it has everything method has it has
an argument list as a return type it has
a body it has a list of throwing
exceptions ah but it has a lot less
syntactic boilerplate so the first
example here on the screen is an example
of a lambda expression it takes as an
argument and object and its body is
evaluate the two string method on its
argument and return that and all of the
you know syntactic elements of the
method that are not necessary for that
have been compressed away a related
feature that we added is called method
references and a method reference is
like a lambda expression I accept that
rather than defining its behavior in
line as part of the syntactic form it
refers to an existing method method by
name so the method reference they are
object kollam kollam to string is
identical to the lambda expression that
is shown on the the first example it's
basically saying here's a reference to a
method implicitly it has won an argument
which is the receiver and its body is
invoke the two string method on the
receiver and so sometimes these are more
compact more readable way of expressing
the same thing ah now like inner classes
lambda expressions can refer to values
from their enclosing lexical scope we
call Mac capturing a variable from the
closing lexical scope so in the example
here we have a lambda that is a person
to takes as an argument of person the--
and whose body invokes the get name
method on p and then compares that to
name name isn't defined inside the
lambda so its value is gotten from the
enclosing scope outside the lambda and
names not defined and a lambda mean
exactly what they'd be in immediately
outside and then the last little bit of
syntax here the fourth example we show
how
you can sometimes I've quite often i
omit the typing information and J and
left the compiler infer that for you and
so that fourth lambda where we just say
Piero p get name is equivalent to the
previous one way as long as it's
evaluated in the context where the
compiler can figure out that yes brought
p is supposed to be a person now what's
common to all it to both of these
mechanisms landed expressions and method
references is that they allow you to
treat code as data and specifically they
allow you to treat behavior as data so
you can take a little bit of behavior
put it in a variable pass it to a method
so that you can create API is where you
can say do this for every element of a
collection do this before you start do
this after you're finished do this when
you get an excel when you encounter an
error etc and it allows you to pass
around the behavior rather than the
result of executing behavior and that
makes for more flexible wha ap is so
just sort of put this in historical
context when Java was created in 1995
most popular languages didn't support
closures was considered to be too
advanced a feature was considered to be
not something that was needed you know
fast forward 20 years later things have
changed quite a lot Java is pretty much
the last holdout among mainstream
programming languages that doesn't have
closures even C++ got them you know in
the last couple years she sharp got them
you know six seven years ago certainly
it's considered essential for new
languages being defined so you know the
the times change and programming
languages have to change with the times
or they become irrelevant so one
focusing on what the point of all this
is so in the code snippet on the right
this is meant to represent a typical
example of the kind of code we write
every day you've got a collection of
things you're going to iterate over the
collection for each element you're going
to do something you're going to make a
decision about whether you operate on it
so in this particular case we're looping
over a
shapes and then for the ones that are
red we're going to color them blue so an
awful lot of business logic that we
write every day looks like this and this
is the other tool that we have for you
know for writing code like this is the
for loop and iterating over collections
and and it's what we've got but it's
really not all that great and the reason
is the semantics of the for loop as
specified by the language are inherently
sequential that you have very little
flexibility about that where and when to
execute the body of different iterations
you can't execute them in parallel on
different Clues you can't execute them
out of order so this is a fundamentally
sequential language construct and it
pushes the responsibility for iterating
through the collection onto the client
you know the this the for each loop that
we're looking at is shorthand for ask
the collection for iterator and then
every iteration through the through the
loop call of a has an axe the next
methods on the iterator to get the next
element and again that's inherently
sequential um so I you know it's what
we've had for 20 years it's what we've
learned to use but it has it has some
problems that affect the behavior of our
programs and it affects the kind of
libraries that we are able to write so
on the next slide I'm going to show the
same code written in a slightly
different way which looks like a really
small syntactic change but actually is a
very big difference so here what we've
done is instead of using a for loop to
iterate over the elements we're calling
it for each method on the collection and
we're passing a little bit of behavior
to the collection saying do this for
every element and wall syntactically it
looks very similar what's different is
we've inverted who's in control in the
previous example the client was in
control it was constantly staying give
me the next element operate on it give
me the next element operate on it here
we're saying to the collection you're in
control here's the behavior you do it
for every element you figure out in more
order you figure out on what Korres you
figure out when
and the client gets out of the way and
this is kind of how it should be the the
client should be in a position where
it's saying here's what I want to do and
the library should be in a position
where it can say here's how I'm going to
do it so when we switch from external
iteration where the client is in control
to interpret alliteration where the
library is control now the library can
use parallelism it can use a double
order execution it can use laziness it
can use all kinds of tricks to get to
the results faster and the client
doesn't have to know the client is just
saying here's the results i want you
figure it out and this this is sort of a
win-win it means that the client can
benefit from better libraries and we
don't clutter up the the code with
accidental detail of how the execution
should happen we're just saying here's
the result we want the key enabler for
that is being able to pass around this
snippet of behavior to the collection
saying here you do this for every
element so by having this mechanism the
language the ability to pass behavior
like this this empowers API designers to
build a p is that can operate on using
internal iteration and take control of
the execution and this in turn gives
libraries more power to abstract /
behavior so we've added a new kind of
expression to the language and so an
obvious first question to ask about that
is well what's the type of that
expression now if you've programmed in
the language like Scala you're familiar
with the notion of a function type by
it's a type in the type system that is a
structural type that means you know
function from long to end function from
string to boolean etc and so initially
we thought well maybe we could add
function types of Java and then we
started to dig into the details of what
that would be and then discovered that
this would in fact be quite an intrusive
operation as we tried to push this down
into the VM and how it affects type
signatures and have an effect the
mechanics of invocation and we realize
that there
is a simpler option sitting in front of
us all the time which is if you look at
if you look at libraries that have been
written historically whenever they need
something like a call back we define a
one method interface like runnable or
comparator or action listener that you
pass in an instance of that the library
calls back to so this is an idiom that's
been in Java vernacular since 1995 and
so we decided we've already got
libraries to do this users are already
familiar with doing this so we're just
basically to give this concept a name
we're going to call it a functional
interface we're going to we already have
some existing functional interfaces in
the library we have run a bowl of
comparator and we're going to add some
new ones out predicates and consumer and
supplier and function etc and this
enables the answer to our earlier
question which is what is the type of a
lambda expression to be its what
whatever the type of the functional
interface we assign it to so we have
them a few examples here while where we
say for example we create a predicate of
spring which is a function from string
to boolean I we have both the lambda
expression form and the method reference
form which are equivalent and the
compiler says looks at the thing on the
right hand side and says well that's a
function of one variable that returns
boolean and the one method interface a
predicate its method as a function of
one variable that returns blue in so
these are compatible and it does all the
work to match them up similarly there's
an example here for a runnable this is
the syntax for an empty argument list
open paren close paren arrow and then
the body of the throttle and the
compiler looks at the structure of the
lambda expression on the right side and
looks at the type on left side and
determines if they're compatible and if
so it just it just matches everything up
so this has a nice feature because
existing libraries to already use types
like runnable and comparator just
automatically work with lambdas you know
without any additional work we don't
have to change the libraries don't have
to recompile them so library
is that we've been building for the last
20 years I get the benefit of being able
to work with lambda just because uh
we're able to bridge the gap between
these one method interfaces and and
lambda expressions so you know it's a
good example of how we could have gone
the wrong way we could have gone and
added function types of Java and that
would have added a lot of complexity
would have interacted badly with a ratio
it would have split the world of
libraries into the old-style libraries
of the new style libraries that we would
have from spent the next 10 years you
know recovering from instead we just
formalized what we've been doing all
along and that turns out to work out
pretty well so it's really easy to get
caught up in the shiny new language
features but it's important to realize
that language features aren't an end
unto itself lambda expressions are not
an end unto themselves they're a means
to an end and that end is I enabling the
delivery of better libraries that if you
can pass behavior between the client and
the library then the library is better
able to abstract / behavior and and and
and be able to manage a more complex
computation and therefore this is easier
to use from the clients perspective and
also often ends up in a more performant
result because the client says what he
wants and then just gets out of the way
so let's take a couple of examples of
how this might change the way with
program in Java so as a first example
I've got some code which is here's how
we would sort a list of people by last
name today you'd call the method
collections done sort which is a static
method you pass it the collection to be
sorted and then you pass it a comparator
and we write the comparator with an
anonymous inner class which is going to
compare to two person objects it's going
to call the game last name on each one
to extract the sort key and then it's
going to compare them and this is kind
of messy first of all there's a lot of
boilerplate code here we're also
the comparator is conflating two
different things it's conflating how do
i extract the relevant sort key with how
do i impose an order on that sort key
and these are really separate concerns
and would be nice to be able to separate
these out so um here's an example of a
new method that we added to the class
library comparator doc comparing and the
the definition of the method actually
looks a little scary because the
generics but if you ignore that what's
going on here is into this comparing
method you're passing in a function
which extracts the sort key from the
thing that you want to source so if you
want to sort people the function that
you pass in takes a person and gives you
their last name and then what the
comparing method does is extracts the
sort key from both the things being
compared and then compares them using
compared to and like I said via the code
here for comparing may look a little
scary but you don't ever actually have
to write that what you're going to write
is the code at the bottom which is
invoking it which is a much nicer way to
write the code that we have on the
previous slide where we say I want a
comparator of person and and I'm going
to invoke this comparing method I'm
going to pass it the lambda that says
take a person and extract the last name
and it's going to give me back a
comparator okay this is an example of
what we call a higher-order function it
takes a function in the key extractor
and returns if a function out which is
the comparator and the client code the
code that you would have to write
comparators doc comparing person last
name is a lot cleaner and a lot smaller
and a lot easier to read than the inner
class example we had in the previous the
previous slide so this is an example of
something we could have written a long
time ago but never did because it would
have been so unpleasant to use that no
one would have ever used it so having
lambdas in your language is kind of a
necessary condition for being able to
write methods like this that are
actually usable but it's a very
straightforward concept
you have a function that extracts your
sort key and this is another function
that takes the extractor function and
produces a comparing function and by
separating these two concerns it
eliminates redundancy it reduces
boilerplate and it makes API is more
composable because all of the
manipulation of comparators can happen
in one place reversing them in composing
them etc and then the the client code
can mix and match between those building
blocks and get more compact code and
more reviews so the the story here is
having lambdas in the language means we
can write better libraries and writing
better libraries means we get more
readable and less error-prone user code
which is the real point we want the code
people write every day to be readable
and have it mean obviously mean what it
looks like it's okay so I'm going to
switch to the other big language feature
that we're adding in in Java hate which
is default methods and the example that
we showed where we iterated over a
collection of shapes used a method on
collection that you probably didn't
recognize for each now in Java 7 and
previous there isn't for each method on
collection we've learned over time that
you're not supposed to be able to add
new methods to interfaces because that
would break all the existing
implementations and this has become you
know the the issue of being able to
evolve interfaces over time has
increasingly been a bigger and bigger
issue for Java as our collection api's
get older the collection api's that were
using lists add map collection at this
point or something like you know 17
years old and they're certainly not the
api's that we would have designed if we
knew lambdas were coming to the language
and you know as you know as we discover
ways in which we'd like to evolve our
API is historically we've been left with
a set of bad choices about how to do it
things and the thing that we've mostly
done is use static helper methods like
collections that sort but that doesn't
get you very far
either so we decided that as the
language evolved to support land
expressions we needed to finally tackle
the problem of how do we evolve
interfaces over time so that they can
remain relevant and our mechanism for
that is called default methods so the
idea here is it's a mechanism by which
you can add a new method to an interface
as long as you provide a default
implementation and here's an example of
this is the actual code for the for each
method this is in the collection
interface it is an ordinary virtual
method just like any other interface
method the differences are that it's
marked with the default keyword that
says this is a method that you can
inherit an implementation from and it
has a body and the body can call other
methods on the same interface and the
default implementation can be overridden
by x sub classes so you know way to
think about this is you can add new
methods to an interface as long as you
provide a default implementation that
existing implementations can inherit
from and then implementations can
override it if they want and it suppose
it's a virtual method just like any
other and from the clients perspective
the client doesn't know whether its
default method or a abstract method it's
just calling a virtual method on
interface as a result adding a new
method with a default is a source
compatible and binary compatible
operation so we're able to go back and
add some of those methods to collection
that we wish we had like collection da
for each so a lot of people look at this
and say oh my god you're adding multiple
inheritance to Java and the answer is
well sort of yes sort of know Java
always had multiple inheritance of types
you a class can inherit from one other
class and multiple inheritable
interfaces what we're having here is
multiple inheritance of behavior that
you can inherit behavior both from super
classes and from super interfaces but
what we're not adding is being able to
inherit state from interfaces and in
languages like C++ this is where most of
the trouble comes from
um in languages like Scala that have
have traits with state they play a game
where they turn fields into methods so
that the same mechanism for multiple
inheritance of behavior can be applied
to state here we're not adding state to
interfaces the only thing we're adding
is the ability to inherit behavior from
interfaces now the primary goal the
private reason we added it was to solve
the problem of interface evolution but
it turns out to be a pretty useful
mechanism in its own right just for
building libraries I just to compare it
to a couple of other mechanisms you
might be familiar with it's a little bit
but not quite like extension methods in
c-sharp in c-sharp those extension
methods are static and you cite in other
words they're injected from outside the
class our default methods are virtual
and their declaration site they're part
of the class declaration if you want to
compare them to traits in scala scala
straights have state are strains don't
um these are more like traits and
fortress and so what this means is that
all we have to do to make everything
pretty is figure out how we resolve
conflicts if the same method is
inherited from more than one super type
and that turns out to be pretty easy we
have three simple rules for us the first
rule is the super class wins over the
super interfaces so if a class can
inherit a method from a superclass
you're done you don't even look at the
interfaces you just take the one from
the superclass and this means that
anything that worked in pre java 8 is
going to work exactly the same way in
Java 8 and that's pretty convenient if
there isn't a declaration in the
superclass we move on to rule two which
is if we have two interfaces that are
trying to provide the same method and
one's a subtype of the other we take the
more specific one so list off for each
would take precedence over collection
Don for each for example and this is
strictly based on the you numerate all
the interfaces and you cross off the
ones that are super types of some other
on list the order in which things are
inherited where the tree things are
inherited doesn't matter we just look at
the set of super types and and
and we would prefer subtypes to two
super types and if we still don't have a
unique answer we go to rule 3 which is
there's no rule 3 and what this means is
if if the compiler can't figure out
which one you want because you have two
conflicting defaults the subclass has to
decide the answer for them just as if
the method were abstract so we've got an
example here interfaces a and B they
both provide a default em neither one is
a subtype of the other so C which
implements a and B has to implement em
or we abstract it and and that's it
that's the rules for off or conflict
management it's it's actually pretty
straightforward that's about as nasty as
multiple inheritance of behavior gets in
Java so when people see this they say
well what about diamonds and turns out
diamonds are easy and here's an example
of a diamond-shaped inheritance
hierarchy where you have an interface
able to default and B and C both extend
a and then D implements B and C and you
know when you look at the interfaces
that D might inherit an implementation
from that list contains a and a so it
fix a done inheriting the same interface
twice is not a conflict so so then
that's that's not a problem okay so let
me show a few examples of how we use
this in api's and you can use this in
your own programs their instance methods
just like any other abstract method in
an interface on the type of this in the
body of a default method is the type of
the interface so in a collection for
example the type of this is collection
and that means it can invoke instance
methods you know from its enclosing
interface so here's an example of the
implementation of a method we add it's a
collection called remove if remove if
takes a predicate predicate looks at
each element and said returns true or
false to say whether or not that element
should be removed and the implementation
is just the obvious thing you grab an
iterator you iterate through the
elements for each one you pass it to the
filter you say should I remove this one
or not if the filter says yes then
remove it and then you just keep going
you've probably all written this code
more than once and by moving it into the
collection API it means you don't ever
have to write it again we can write it
as part of the collection and abstract
over the behavior of which elements
should we be removing another thing you
can do with default methods is
effectively make them optional so here's
a here's the code for java.util.iterator
which has three methods has next next
and remove and when we implement these
almost always removed just throws
unsupportedoperationexception and it's
kind of irritating that when you
implement an iterator that you have to
implement removing and give it a body
which is throw new
unsupportedoperationexception so if you
want to make implementing a method
optional just give it a default that's
good enough and now with this new and
improved definition of interface of
iterator iterators don't have to
override remove if they don't plan to do
anything that that's different from the
defaults so this is something that we
can do to an existing interface adding a
default to an existing method is still
compatible existing implementations of
iterators still work and future
implementations vitter ater don't have
to specify remove if they don't watch it
so that's pretty nice the last example
of the kind of thing that we do with
default methods is here's a method that
we added to comparator which says give
me a new comparator which implements the
reverse comparison order of the
comparator that I implement and its body
is the obvious thing we just invoke
ourselves on the arguments in reverse
order we could have also invoked
ourselves on the Satan that in the same
order and just flip the sign of the
results either what it worked what that
means is if you want to sort a list of
people by last name descending from last
to first rather than first to last we
can take the comparator that we made in
the earlier example where we say
comparator doc comparing of person back
out last name and then just take that
and call the
first method on it and sand and now we
have a comparator that compares on last
name in reverse and this is an example
of what I mean by getting better
composability if we wanted to do this
the old way we would have probably just
duplicated the whole code and flip the
you know flip to sign somewhere or
flipped a comparison somewhere ok so let
me give an example of putting all these
features together so you can sort of see
the effect this has on on the way we
code we're going to take our example
from before which is sorting people you
know by last name first name etc and
here's the starting point we were at
before where we said we want to sort
people by last name so we'll use
comparator not comparing to make a
comparator and then we'll pass that to
questions on sort we can you know this
is already a huge improvement over what
we can do today but we can do better so
the next thing we can do is observe that
the code actually got small enough that
with a little bit of static import we
can get this all on one line which you
know may seem like a small thing but
remember the big goal here is we want
our code to read like it does what it
actually does so code you know that you
can read where you say sort the people
comparing last name makes it much more
obvious what's going on and we can we
can keep going we can are what we can
use instead of using the static method
collections not sword we can use the
default method that was added to list
list dot sort this is a more
object-oriented way of doing this you
know doing the same thing this is how we
would have liked to have done it in the
beginning instead of having to use this
sidecar method of collections that sort
we can actually just sort the collection
comparing my last name so that's moving
away from doing things with static
helper methods which is generally an
improvement it also means that if the
implementation can provide a better
version of sort than collections on
sword we get a performance benefit as
well but we can keep going while we can
replace the lambda expression with a
method reference which is a little bit
easier to read and the code is really
starting to look like the problem
statement now
take the people and sort them comparing
by their last name if we wanted to do
something like sort by last name
descending we could use the reverse
method that we saw in the last slide
where we take the comparator and reverse
it before sorting if we wanted to sort
by last name than first name we can use
another one of these default methods we
added to comparator which which composes
two comparators into a dictionary order
so we can say take the people sort them
comparing my last name and then
comparing my first name and again if we
want to do this the old way you would
have written a new comparator from
scratch that the event that didn't reuse
any other code when you would just do
this all in line and it would be ugly
and messy and all of that so I having
lambdas in the language enables us to
write libraries that allow us to compose
behavior like this and the result is the
code that we write is a lot clearer a
lot cleaner a lot less error-prone ok so
that's the overview of the language
features that we added I want to talk a
little bit about the library features
before we before we move on its and labs
so we've been using this example here
with a we've got a collection of shapes
and we're going to breach a free shape
we're going to say if the shape is read
that we're going to color blue and I'm
going to observe that we can break this
computation down a little bit further we
can break this down into two steps where
instead of combining the two bits of
behavior into 11 blob we can separate
this into a filtering operation where
we're going to select only the elements
that are red and the side affecting
operation where we're going to set those
two blue now this doesn't necessarily
make the code any smaller but it makes
it more cleanly factored because it
allows us to compose behavior out of
smaller building blocks and this is a
powerful tool for expressing aggregate
operations on data which is something
that we do every day in our programming
lives so here's some you know so here's
an example of how we surface this in
the in the libraries we've added an
abstraction called stream which is um
you can think of it as a stream of
values well that you can operate on it's
not a data structure like a collection
that stores the values but you can take
any collection and produce a stream of
values from it and hear what we want to
do is say take the blue shapes and
collect them into a list and the label
to do that today is we create a list we
loop through the collection for the ones
that are blue we'd add them to the
collection this gives us a sort of more
more compact and clear way of doing that
where we're saying take our shapes
select out the ones that are blue and
then for the you know for the ones that
we've got you know blue shapes collect
those into a list if we wanted to make
this query a little more complicated we
wouldn't have to we wouldn't have to
change the whole thing we would just
have to add another stage so for example
if we knew that every shape lived in a
box and we wanted to collect not the
blue shades but the boxes that have blue
shapes we would do a lot of the same
code take the shapes get a stream of
them filter use filter to select the
ones that are blue and then before we
put them into a collection all we want
to map those to their containing box so
the filter method returns a stream of
shape the map method returns a stream of
boxes and then we collect those boxes
into the set okay one more example let's
say we want to add up the weights of all
the blue shapes we're doing the same
thing we take the shapes we make ass
premium we use filter to select the ones
that are blue for each one of those we
select its weight which is going to be
an integer and then we have those
numbers up so you know the kind of data
manipulation that we do every day with
collections where we by hand loop over
the collection and create intermediate
results and all that we can express in a
much more declarative way using methods
on the stream libraries ah now you might
think that because these stream
libraries have a lot more method
implications you have filtering and
mapping and collecting
that they'd be a lot slower but in fact
they're faster and it looks like when
we're doing a stream of operation with a
filter mapreduce that we're doing three
passes on the data but in fact the way
the library works we're only doing one
pass on the data so the filtering the
mapping the summing all happened at the
same time but we are able to specify in
a in a more factored way where each
stage does one thing and we compose a
pipeline by building up these basic
building blocks the benefit is the code
looks like the problem statement and if
you the problem statement changes in a
small way the code changes in a small
way rather than small change in the
problem statement propagating into big
changes in the code there's also a lot
less extraneous noise but the real win I
on the execution side is now the library
because it's in control of the operation
can use parallelism can use a double
execution can use laziness to get better
performance so like I said we added this
new by abstraction stream it's in the
package java.util stream you can look
the javadoc for that it represents a
stream of values it doesn't store the
values the values come from somewhere
else which might be a collection or an
array or generating function or an i/o
channel and the screen provides the bulk
operations where lets you operate on the
whole stream at once rather than one
element at a time and it encourages this
this coding pattern which we call a you
know fluent fluent style where you're
chaining together operations and even
though the operations look like distinct
operations the runtime compresses them
into a single pass so it's quite
efficient as an example of how this can
transform the way we code I've got an
example here of sort of typical kind of
code that we write when we're playing
around with collections so here um you
know what this code does well I'll tell
you about it if you try to read it
yourself it's going to take you probably
10 to 15 seconds to work all your way
your way all the way through it which is
we've got a collection of transactions
here and we're going to pick out the
ones where the buyer is over 65 and then
for each one we're going to get the cell
are under collect clothes into a set
and then we're going to sort that SAT
comparing the seller names and then
we're going to print this at than out in
the order of names if I rewrite this
with with streams the code becomes a lot
more obvious you take the transaction
you select the ones where the buyer is
over 65 for each one you get the seller
you throw away the duplicates you sort
comparing them and your presence so you
know the whole point of this exercise of
having language features and adding you
know library features is to enable us to
transform code like the top block of
code which is very ad hoc and full of
intermediate variables which distract
you from what's going on transforming
that is the bottom code which is cleanly
factored it's easy to follow the flow of
control you're not distracted by
extraneous you know extraneous
temporaries and things like that so kind
of summarizing the benefits of this
programming style we're moving from a
mechanism where we work on each data
item individually to dealing with the
items as a set we're focusing not on the
hell but on the watt and as results
we're able to write code that needs more
like the problem and and doesn't leak
the details of its implementation and as
a bonus now this code could also be
parallel because we've allowed the
library take control the computation and
it can use parallelism if it wants to us
which brings us to the the last topic
and then we can get to the labs which is
parallelism so one of the goals of this
whole exercise was having a better
parallel libraries for Java that we've
had parallel libraries for Java for
quite a long time and that's a good
thing this parallelism is hard and
having the libraries handle a lot of the
details like load balancing and
scheduling and when to create new
threads and all that it's great to have
a library handle that but if you look at
the for joint framework that we added in
Java 7 and you look at the the civil
code for a given problem and the
parallel code for a given problem the
code look nothing look nothing like each
other and what that means is it creates
a burden
when you want to go from sequential to
parallel it's it's a lot harder because
you basically have to rewrite your code
now we'd like for it to be obvious that
something is happening in parallel but
we don't want to have to rewrite all our
code just to get parallelism so you know
the way fork join works is it's a
mechanism for writing algorithms that
are independent of the number of
processors they're going to run on and
it's based on recursive decomposition so
you take a big problem you divided into
two small sub problems and you solve
those problems in parallel and you
combine the results and if the
subproblems are still big then you
subdivide them again and you subdivide
them again and eventually you work your
way down to problems that are small
enough to solve sequentially and then
you combine the results to get the you
know together to the you know the final
result and this is a pretty good
technique and it's pretty efficient and
it scales across a pretty wide range of
processor counts the problem is you got
to write a lot of boilerplate code so
here's an example of how we would write
the sum of the weights of the blue
blocks problem using fork join the code
and rabbit is actually the business
logic of shapes and weights and blue
blocks and such and the code in Black is
just boilerplate that you need to feed
the framework so we like the execution
characteristics of fork join but we
don't like the code you have to write
with fork joint so with streams we've
made that a lot easier um instead of
saying shape stream you say shapes not
parallel stream and you get a parallel
decomposition uh with code that looks
almost exactly like the sequential
version it still explicit you're saying
parallel instead of sequential but
you're you know but everything else
stays the same and that's the way you
want it you're saying what you want to
do and you're letting the library handle
the mechanics and again the library
fuses all three operations filter
MapReduce into a single parallel pass on
the data so you basically get the
execution characteristics of the ugly
code from the previous slide with the
pretty code on this slide so
just summing up why did we do all this
well a couple reasons one is it's about
time all the other languages got there
before we did and we were the last
holdout it was kind of kind of lonely
but also the markets ready for it at
twenty years ago people didn't think
Java needed closures now people do a
programmer different demographics change
and language has to change with it
another big reason is a better way to
write multi core libraries if you want
to write parallel friendly API is you
really need to have it internal
iteration and to have internal iteration
you need a concise mechanism to pass
behavior around and as a result you know
we've empowered library developers to
write more powerful and flexible
libraries which turns into better user
code so um you know a lot of reasons a
lot of benefits and I think with that um
we're ready to start our labs you've
probably already downloaded the
developer a preview and I at this point
alternative to turn it back over Stephen
yeah okay so</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>