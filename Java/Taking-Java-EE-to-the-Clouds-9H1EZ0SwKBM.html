<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Taking Java EE to the Clouds | Coder Coacher - Coaching Coders</title><meta content="Taking Java EE to the Clouds - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Taking Java EE to the Clouds</b></h2><h5 class="post__date">2017-10-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9H1EZ0SwKBM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">already okay thank you very much for
everyone showing up for this talk
obviously there's a lot of options and
I'm particularly actually very
pleasantly surprised that I see a lot of
familiar faces and a lot of speakers so
I think this is going to be an important
talk for all of us hopefully a timely
one and perhaps a slightly over D one
and honestly you know I would actually
request that you consider delivering
this talk so with that said let me talk
a little bit about the motivation of
this talk
this work is is part informative and
frankly part in the myth-busting I
personally sort of got tired of the
propaganda that job ie somehow doesn't
run on the cloud right that the reality
is absolutely the opposite java runs
extremely well on the cloud in fact it's
probably one of the wealth supported
technologies on the cloud today yes and
that's kind of sad that somehow we we
are unable to get that narrative out
there are we gonna accomplish this in
this one talk probably not right but at
least we have to start somewhere as a
Java EE community to change begin
changing that narrative and being a
little bit more balanced to that
narrative okay so that's the motivation
for the talk I'll briefly introduce each
of one of us I have two really fantastic
guys here working with me there they did
most of the heavy lifting of the of the
talk I'll tell you right now and I'm
just so grateful for what these guys
have done for the talk but that's said
I'll let Rodrigo and dry and introduce
themselves hello everybody my name is
Rodrigo Bartolotta I'm a senior manager
with cap tech consulting I currently
serve as the capability lead for the
cloud service offering and obviously
being involved with Java for many years
yes I'm Ryan cupric I'm from the
system's I work in rnd on chemical
formulation software
I run the Connecticut java uses
and co-author on a couple of the books
and my name is Reza Rahman I'm a senior
manager architect at CAPTA consulting
I've been involved in the Java ecosystem
for a little while and yeah just here to
share share some stuff I need to and
this is a necessary evil slide obviously
a Catholic is paying for both Rodrigo
and my expenses to come here so
basically we're proud to work for this
company it's really a great company it's
a nation it's a nationwide full-service
IT consulting company wins a bunch of
awards all the time you know have some
fantastic people working for it like
Rodrigo here unlike myself okay so this
is roughly our agenda
so we're firstly we're going to be
talking about Java EE on the cloud at a
on as a bird's eye view then we're gonna
dive into basically each variant of Java
EE running on the clock so respectively
if you've been around the cloud because
from the none of these acronyms that
broadly surprises to you so
infrastructure on a service docker or
containers as a service there's platform
as a service and also as a variant of
that basically running Java EE on bare
JVM based best solutions and finally
Java EE as fares or function as a
service okay moving forward you know
Java EE in reality has been running on
the cloud forever in fact you know I
have a number of customers that have
been running Java EE on on the cloud
forever in fact it has been possible and
people have been doing it since the Java
EE 6 timeframe so reality is this has
been going on for at least a good five
years and and it's really sad that we
haven't gotten the narrative right yet
is especially you know what happened the
cloud deployments that I've seen on Java
EE so far by and large actually a lot of
it is is based deployments on AWS okay
and I think that's reality for pretty
much most of the technologies out there
there are in fact incremental features
that have been built into both Java EE 7
and Java 8 that benefit the cloud okay
and hopefully there's going to be a
whole lot more
coming up in the next releases of Java
that specifically looks at the problem
of what is it that you actually need in
cloud applications running Java
applications running on various variants
of the cloud so it's running Java jaan
on is is super easy right in fact
running any technology on is is super
easy so Java EE is is definitely not an
exception there at all most of the you
know major IAEA's vendors it's very
super easy to do that namely the big
clear is to players really being as
you're and AWS Java EE plays also
extremely well with docker okay this is
another sort of fad item and and I
really I'd like to like to present a
session on that too and see how
symbiotic the relationship actually is
between Java EE and Dockers so although
the containers are the service providers
that are based on docker because Java EE
works was with which so were well with
docker it works well with those CAS
based solutions as well and in fact
there are many good pairs options as
well I mean really Java EE has the most
amount of pairs options maybe with the
exception of the bare metal JVM it's a
really a number of vendors that are
focused on this you know some names are
openshift Oracle cloud bluemix ruku and
jelastic and in fact I probably haven't
done done a favor done done just as 2/1
which thank you for reminding me problem
which is it's s AP the s IP should have
been in this list as well yes if we
recently certified the cloud platform
against Java EE 7 so to make it up I'm
going to write a blog entry about it so
and believe it or not you know Java EE
also can work extremely well in bare
metal JVM based bastrop platforms I
think this is a very interesting variant
and I'm very happy that that part is
going to be covered by Ryan I think he's
gonna do a really good justice to that
because that's been one of the four
points
fear uncertainty in certain heat out
points is that okay
Java he doesn't work in those
environments which is absolutely really
not true as you'll see it is possible
because we have
a bunch of solutions out there that
allow Java applications to run on Java C
environments some of those names are
wild fly swarm payara micro coma Lizzie
and WebSphere Liberty and even that
isn't actually a comprehensive list okay
so I won't spend too much time on this
slide let me explain what this slide
actually is there's an application out
there called cargo tracker it's so the
intent of that application is to
actually demonstrate solid design
patterns namely two main drive in design
design patterns in Java applications
it's a very handy application that I
find to do all sorts of job eBay's demos
because it's a non-trivial application
it's about 10,000 lines of code it uses
all kinds of Java API is JSF JPA u jb j
ms j batch and the like okay and we'll
probably adding those lists as well it
was part of the job especially official
Java EE project on java.net since that
it's gone down it's a part of the github
Java EE repositories but it's honestly
not in very good shape so what we've
done is we've hacked that thing and we
now have a bearer on a project that we
call j 3e j 3 dot github that io ok and
you'll find the former website that used
to run on java.net running there
temporarily hopefully we fix this
problem and we make it part of the EE 4j
project instead of the j 3e
project okay so a Java EE on on on pairs
on on is what is is is is simply your
data center on somebody else's machine
okay so what you get is basically the
bare by-and-large
your bare bare hardware hardware level
machine provisioning that you instead of
ordering through your department and
have some have your suicide mini install
that for you well that somebody else
does that stuff and you just click on
some stuff you know on a web page and it
creates that bare metal machine for you
okay but most likely using some
virtualization software or the hotel
than somebody physically buying the
machine and sticking it in in the rack
by far this is the most popular path to
the cloud that's the reality most people
that are using cloud are really using
iOS platforms and of course as you know
I think as we all know the big you know
biggest players here are AWS and has you
so Java as I said works extremely well
on is why wouldn't it it's just a yet
another server it just happens to be
hosted on somebody else's machine so of
course you can set up a Java environment
and deploy your application there above
and beyond which we won't cover in to
too much detail in addition to this most
of the big I as vendors actually have
specific support for Java EE api's in
particular they provide images of Java
EE application servers pre-built images
that you can much more easily deploy on
there is base platform so you go onto
Azure and you look at that as your image
library you'll see images for various
job by application servers similarly
there's ami is available on on AWS that
is specifically target Java EE based
application servers so actually this
blurs the line we won't cover it in
great detail but this blurs the line
between what is iis and what is pass
actually the line is blurring more and
more right it's a literally a
distinction between a few clicks as to
how categorizing something as IAS versus
categorizing something as pass actually
I'm going to skip over the pros and cons
for the interest of time because we have
a ton of material to go through so I'm
going to not go over the pros and cons I
think for the most part we are
understand this stuff will make the
obviously the slides available to you
you can take a look at it so that all
said
let me turn over turn it over to Rodrigo
who is going to present our first demo
which is running Java EE on bare metal
iOS platforms
all right and as Reza said this is the
link so everything that we're covering
is available in github and it's live
shares so everybody can look into you
know with more details so the first
thing to go through
you know infrastructure as a service
we're starting with AWS and leveraging
their ec2 service so anyone here
familiar with AWS ec2 I feel a few hands
thank you
so this is basically their virtual
machine option as in already said you
can go with many other cloud providers
right so in this case most call
providers they have some sort of
marketplace that was kind of mentioned
right so you can you know identify one
application server of your choice and
you know I'll start with one very you
know interesting so you can you know
search for one other choice you can have
a pre-configured image and you start and
your setup is in place or you can create
your own right so let's suppose you
start your instance your virtual machine
you make our configuration and then
create your own image you later on to
reuse and that could be very interesting
you could look at it as an artifact
right through your pipeline as you move
around development on the way to
production you could very well have an
artifact that becomes your ami that
spill teeny and package with several you
know pieces that will you know go
through your software lifecycle process
I'm picking up something with Ubuntu you
know nothing fancy here and we're
choosing an instance type which is
pretty much how much memory and CPU were
going to give to this virtual machine
right our next step is network and these
steps they're common to and any route or
machine type of service right so you
define a network you obviously in this
case we want to have public IP available
so we we enable that as this we're just
taking the default configuration we give
some storage so and and it's nice to see
contrast and compare with other cloud
providers how they differentiate
you eye or their api's to make her life
easier as a developer obviously naming
it something that it could be hard but
it's very important because in this case
we're creating one specific route or
machine but if you have hundreds of
thousands of them running in your
environment your workloads you need to
identify and easily try to figure out
what is doing what right so in this case
I'm just you know giving one some some
name so I'm gonna call this my you know
Java one is it to instance demo then the
very next step is to identify a firewall
which is in AWS terms is called a
security group
all right so for that you know we are
deploying a java application that's
gonna be running port 8080 rial so that
applications running on top of a
glassfish so we also want to enable the
console admin on port 48 48 so obviously
we need to make those available and and
for that reason I already have one
pre-configured pre set up security group
here we review things we look at you
know there's no warning saying I'm gonna
pay for it
obviously one thing that's interesting
to note is all the cloud providers they
have a free tier free get started type
of approach all of them so it's really
good to take one user case that you may
have and go and explore across different
ones and then identify what's the best
option for you and and from here we
launch that instance you have to have a
security need to have your Pam files so
you can later on SSH you say launch and
AWS will do something behind the scenes
obviously for interest of time I already
have one that's pre-configured it's
already up and running and now that I
have you know exposed that IP address I
can come in here and say well is there
anything running oh no right so let's
see if I have something on port 48 48
and apparently my internet connection is
not helping me that never happens huh so
let's try again all right
so how can you go into the cloud without
an internet connection huh but basically
the idea is and that we'll see how this
is gonna shake with the next one every
rigor I think the suggestion was to type
in HTTP in front now the HTTP well let's
see thank you
there we go thank you very much so you
know this is you know the admin console
that's available now if I change the
port and obviously you can do whatever
you can do with any application server
right there's nothing you know that that
particular and if I go with my port 8080
I should have a different message here
pointing that saying that in all my
application server is up and running and
eventually my cargo tracker application
alright but as it's lit loads and for
interest of time I think the the the
message here is behind the scene as you
didn't see that I had to set up Java you
didn't see that I had to set up
GlassFish myself so the point being is
there are no changes on my application
was just a war file you need to think
about infrastructure right you need to
think about network configuration
firewall so there are some takes there
and you need to play a little bit of you
know admin role in this scenario so
regardless of the call provider you pick
okay great so the next variant that
we're going to talk about is essentially
using Java EE with docker or containers
continue as a service platforms so what
has happened as Rodrigo mentioned and I
mentioned as well
Amazon has this concept of a mais okay
Amazon images saying similarly as your
has a concept of images right the
reality is these are proprietary images
specific to those platforms so if you
want an image you've got to create an
image and upload to their marketplace
somehow and etcetera etc so the reality
is all that is kind of unnecessary
because docker is becoming such a
commodity right so instead of relying on
their own proprietary ami systems what
the eye is providers and some of the
best providers are doing is simply
saying hey we support docker right so
whatever your image may be get your
image from docker hub or create your own
publish your own image into docker hub
and use that to spin up a server
instance and in fact multiple server
instances in some cases so most of these
solutions that containers as a service
solutions aren't just a matter of
spinning up individual instances with
docker images but they actually have
orchestration built into into that as
well with all of the orchestration
frameworks that are out there to support
dogger principally actually kubernetes
is the most predominant one so most of
the cloud providers are supporting
kubernetes and hence you can essentially
spin up and down you know your cluster
and create a cluster and non-zeros in
just a simple instance in a relatively
automated fashion right so so that's
what's called you know this new model
called containers of none service and
actually it's it's fairly prevalent
already so as I mentioned before Java EE
is actually a very good fit for confer
for the docker model it works extremely
well there are several reasons for that
so this you didn't use to be the case so
some of the fun items around Java EE and
docker are basically outdated
right so this was a
the criticism that is there out there
you'll read on the internet basically
what they're trying to tell you is a
docker image is monolithic right so you
want the docker image to be as small as
possible so that that monolithic docker
image doesn't get too big and it's and
it doesn't get too difficult to deploy
and the like well guess what
the docker guys have figured this out I
figure figure the problem because this
is not a solution there's not a problem
specific to Java EE but guess what if
you have a database server or a web
server that has the same problem right
and they produce large images so the
solution of in docker that's been out
for a year and a half now is something
called docker layering okay what that
means is that you don't deploy your
entire docker image every time what you
deploy is actually what changed in my in
my image right so what this means is you
can follow essentially the natural model
that Java EE application servers has in
in terms of separation of concerns right
so your infrastructure layer is your app
server whereas your wire is only the
Delta that you apply on that's the only
thing that's changing in from one docker
deployment to the other right so the
initial docker deployment yes so that's
going to be large because it'll contain
the app server and your wire but guess
what subsequent deployments of your of
your java application server is going to
be much smaller compared to any other
alternatives because your incremental
bit is very clean namely just that just
a war file okay
in comparison let's say you're you've
done some effort to create a fair Jar
solution well guess what
because that fair Jar solution doesn't
have the clear demarcation between the
deployment unit and the infrastructure
you'll actually actually be deploying a
heavier weight docker image every time
you deploy that okay and the same thing
happens you know again with docker
clustering and docker caching all of
this because of those capabilities work
mesh extremely well with Java EE
applications okay
so then there so what what does that
mean so what does this means is you know
now we should then evaluate well what if
you look at docker however if you look
at the docker ecosystem how well does
that support Java and it turns out it
supports Java EE extremely well
so there's literally docker images
available of every single Java EE
platform out there right there there
isn't one that doesn't have a pre-built
docker image available that you can just
use and run with it and and and keep
going with okay so with that in mind I'm
going to turn it over again to Rodrigo
he's gonna deploy he's gonna show you
how to deployed authorized Java EE
images onto a cloud platform alright and
this is the result that we were
expecting from the previous deployment
right so so as Reza said the first step
is we need a docker file right so we
need to get the war file that initially
we you know had in our infrastructure
deploy to an application server and we
have in this case a blocker file we're
going you know in music payara
which by the way announced today they're
the first or one of the first to support
Java EE 8 so that's you know really
really great and you see three lines of
code we have no payara
we have deployment of our file and we
then you know start our domain this is
available in github there's a reference
for that and after that you can push
your docker image right you create a
docker image or darker billdocker tag
docker push right you need to build it
it constructs the image you need to tag
so you associate your docker image with
some destination with some docker
registry and then you push that to some
darker register in this case we have
that available we're gonna use once
again AWS we're exploring ECS in this
case this is their ec2 container service
for the same purpose as kubernetes or
one of the you know similar it does
offer a container registry so this gets
started kind of walks you through and
very nice and easy way to learn and
understand how you can set up and create
your docker registry so I can come in
here and say you know I'm gonna create
my cargo tracker repo do a next step and
it gives you all the information that's
basically a copy and paste and what
you're gonna do if this is you
your darker image again locally you
tagged you push that becomes available
within da de Blasio system or you can
expose somewhere else if you want that
you know if you want so in this case I'm
not gonna run those steps again for the
interest of time but I have done
obviously that before and I have already
my proposed story here I'm gonna cut my
repost or URL and I'm follow with that
for my next step so once I have my
repository the other thing that I need
to think about in AWS terms but you know
in general that that this knowledge II
gets transferable anywhere else we need
a task definition and what does that
mean
every time you run a container you need
to a specify or may want to specify what
parts you were exposing when you do a
darker one you expose parts you mount
volumes to give environmental variables
so there are set of configurations that
you provide along with that docker run
that you translate that into a task
definition right so in this case I'm
gonna keep since I'm doing part 88 I
will keep that part 88 here obviously
for more complex deployments you want to
let the container Orchestrator to
identify and dynamically assign a part
to you you don't want to tie yourself to
a single port that will bring host
brutal machine constraints so that open
up a lot of questions the last the next
step is a service so once we have a
docker container available in a registry
we define what we need for that to run
now we have a service that will say you
know keep this guy running I need one
docker run or one container running at
all times or ten or a hundred so this in
our cases our cargo tracker service I'll
say that we just need one over here I'm
not gonna put any load balancers or
anything more complex at this time and
then with that my search needs to run in
a cluster right and that clusters not a
traditional in a WebLogic cluster or
application server cluster but it's more
of a think of a higher-level unit where
you can have multiple services within
that cluster and
that will orchestrate and coordinate all
the container placement and all of that
so in this case here's my cargo trekker
cluster we can specify the size of the
rittle machines that will be assigned to
that cluster so once you create your you
know container record trader you you
need to give it some computing capacity
so it can deploy containers Imraan and
whatnot so we're giving here some you
know CPU memory combination AWS terms
for the instance types we say how many
of those will assign again I'll give
them a key pair over here as you know
everybody would we review tasks next
steps and then we would be able to be in
a position to just run it once we run
this it's very interesting because this
you know graphical user interface and
just like everything else AWS is exposed
to API CL is as the case and so you can
automate everything which you should
write if you deploy something in a cloud
that should be a hundred percent
automated and they have something that's
called cloud formation and behind the
scenes cloud formation is managing and
creating out the orchestration of those
services for you I have one cluster here
already set up I have my cargo tracker
service you can see that I have given
one brutal machine associate to it and
since I told it to run one service I can
come in here and say that there is one
blocker which it SS cause a task and
from that task I can get all of its
details and eventually I get to D you
know application so let's see if this
time I'm gonna have more looks so that
works perfect right so I have packaged
with PI R as you saw before I saw before
and if I do cargo tracker here's my
application once again you know
available and an easy to run is to use
as well as it would be the console at me
okay the next stop is
platform-as-a-service so as I said the
distinction between pairs with images
and docker and really pairs is and pairs
at this point is that it that image is
built in as very closely into a UI right
so you don't have to do anything else
just natively supports whatever
application server that is and in many
cases actually the application server
it's always implicit so whenever you're
using that that solution it's just
implied that you're using that
particular application server and that
cuts down some of the boilerplate and
some of the additional steps that you
would need if you weren't using pass
solution so basically what happens here
is that your deployment unit really
becomes just point and click setup your
server and you just deploy your war file
and that's your that's your basically
your deployment unit typically though it
will come with some kind of console
access that you can manage your
application with and of course again you
get in a lot of Java e-pass solutions
available
openshift Oracle cloud bluemix jelastic
nhip also again i'm gonna skip over the
pros and cons i think it's a little
unless maybe besides the point
so that we can get to the demo and where
you can kind of dig in into a bit more
of the details here alright so shifting
gears now and we're going with jelastic
anyone here familiar with jelastic great
several several hands up I think
jelastic you know it's close but I think
it's fantastic right it's it's it's so
easy to set up something I never heard
I've never heard before to be honest
I've never used it before and as and I
think it's that's what I want for our
law provided that's what I want thrown
kind of a platform something that I can
look and easily get started right so
they have the concept of you can import
environments you can export the
environments they also have a
marketplace where you can you know
leverage pre-configured environments in
this case we're gonna go with a new
environment and just like with payara
jelastic is also supporting je8
so that
you know phenomenal what I want to show
here is they have support obviously for
Java and in a PHP if someone's
interesting PHP they have docker and
other stuff but look at this UI right
what we're seeing here is word we can
define and we can use a good selection
of application servers on the Java
ecosystem you know they have GlassFish
they have JBoss payara and and many
others right so this is really good it's
not something that you find in every
single call provider but with that said
up here I'm gonna be no pickup payara I
want to get the latest version of payara
it's loading as you can see here I'm
getting a JDK 8 its latest version of
payara if it brings you here on this
middle box can can you see that well let
me let me give him more right so if you
look at this middle box here it's
already out of the box gives you
scalability so you can have vertical
scalability which is basically you know
how much memory and CPU you're gonna
allocate from the beginning right so you
know in this case I'm saying you know
I'll give you 3 gig of memory with this
much CPU and you can grow up to a
certain level so if your application
under load is under load your your
computing capacity and you know increase
with you and at the same time down below
it's also providing horizontal
scalability so again if you have one
node or if you need multiple nodes it's
just a matter of you know defining what
do you want right the interesting part
here is if you know it's it also once I
add more than one node it created for me
that abstract that that extra layer for
load balance are adding an engine X load
balancer thought so that's very handy
and very helpful you know especially for
those that already have workloads
running on-premises there's a high
chance we're doing this with nginx or a
similar kind of proxy load balancer
solution so that's it's very good they
also have some interesting you know that
they offer you the cost as well which I
think it's valuable and it's useful out
of the box they have some variables as I
mentioned on the part of the exporting
the environment so there is a
pre-configured environment installation
set
process here that will automatically put
your PI R or GlassFish in cluster mode
so before on the other two options we
were looking at we would have to do that
have lifting ourselves right so this is
you know comes very it's very good and
you would have an environment name you
can give that environment name set up so
DNS and whatnot one other thing you can
you know connect your application
through maven in this case I have the
cargo track or war file here I can click
on it I have a cup of environments
preset up and I can define it
understands it's a warrior app it
understands it can be deployed to that
specific environment so again it's it's
the same operation as you would do going
to you know console at the means saying
deployed war file so that also becomes
very very handy the piece that I want to
show you is that I mention I have one
pre-configure instance over here let's
go to it which is the one that I
mentioned about the auto clustering user
and password and I just kind of want to
show that because I think again it's it
does it does add value as we are going
through this so you're looking at the
you know payara
as you see there is a cluster here set
up and I have I didn't have to do
anything and then down the road you can
deploy your application either through
you know the web console or you can just
come in here and you know select the war
and deploy in addition to that it also
gives some of the Messam metrics
oops this is the topology but it does
give some really nice metrics that you
can start analyzing what's happening
behind the scenes it opens you something
that's interesting it gives you access
to some of the files from a folder
structure perspective so again overall
with this with the previous approach you
know we when we did darker we had to
create a docker file we had to have a
quick learn a little bit about a
container orchestrate and whatnot and in
this case we didn't have to change
anything our application it remains to
be a war file right
and the infrastructure knowledge was
very minimal so I think that you know
adds a lot of value for those that want
to explore and go take that path to the
cloud okay
moving forward so although most cloud
providers out there when they're talking
about Java support um they have some way
of installing an application server
either through a docker image or a
native image that they that they build
or it's built into the platform like in
jelastic space however there are a small
number of cloud providers out there that
don't provide that flexibility the only
thing they support is really either
Tomcat or jetty or here you go here's
your jdk environment and that's all you
get right and then you have to build in
the rest of your applications based off
of that
right so there aren't a whole lot of
these really the big the only ones that
have this sort of restrictive
environment is Heroku and GAE well
obviously in this situation all of the
other solutions that we talked about are
isn't going to work because they all
entail some kind of installation or some
kind of reconfiguration of an
application server that's not going to
be possible in this case however what
you can do here is actually not depend
on that because now you have all of
these Java EE nice Java if you are
solutions that you can just create a jar
as opposed to a war file and deploy that
on top of a bare-metal JVM okay so I'm
gonna do a little bit different in the
interest of time here and this is gonna
be a little bit of a surprise for for
Ryan the only reason I'm doing this to
him is because I know he can handle it
sir
so I'm gonna surely just talk about our
final deck here which is our resources
okay and then I'm gonna actually hand it
over to Ryan for majority of the rest of
this time that we have which is we have
about 10 more minutes left so what we've
done here is try to give you a really
good starting point for getting started
on the cloud with Java applications
they're your best resource actually is
the
github repository that that that Rodrigo
showed he actually have has specific
instructions on each other cloud
platforms and some that we didn't show
step-by-step instructions on how to get
started on those in addition to that
there's some that obviously we didn't
have time to cover right so the nice
thing about it is I did actually did do
some research and try to find point
references on those particular cloud
environments of how do you set up Java
EE in those particular environment
similar to what perhaps what Rodrigo
would have written up you know in in his
github repository so those are some
additional resources in addition to what
you have with with Rodriguez our github
repository a final word that I'm gonna
say if I don't get to say anything else
because of time is that you know
basically our aim here is to get you
started on on running Java applications
on the cloud as quickly as possible and
give you you can you can use all of the
resources that we already went and
created so many man-hours to create so
you can utilize that and of course for
those of you who are speakers please
consider delivering this talk we made
and talked such that you can just take
him and run and deliver this talk so
with that I am going to hand it over to
Ryan probably for the rest of this talk
and I will tell you this is what he has
is probably worth a talk on its own
right so really not doing brands Ryan
just as here Thanks so now that we got
that out of the way I guess I'm cleared
to talk to seven right actually actually
this was so simple that it I can I had
to make this longer because it's so
quick to actually deploy the application
this is actually easier than I thought
it would be prior to working on this
presentation I hadn't actually used
Heroku previously thinking that it was
had been at conferences where it was
primarily Ruby developers that were
using it so I thought it was a ruby
platform but that's not the case it's
actually a very good job of platform
Java eight and installed it's a little
bit different than the the stuff that
we've looked at before in that in order
to push your code up there you actually
use git so you'll actually push use get
to push the code to it or you can have
it tied into your git repository so that
every time you push code it pulls from
you does the sync and pulls down for you
it does support add-ons and it's got a
number of add-ons of you know it has
like database add-ons pre-configured so
that you can get up and running quickly
it has RabbitMQ which I won't be using
for this presentation it does support
process scaling everything runs in
isolation it's got a very nice logging
infrastructure so that on the command
line on your computer you can get the
logging back so it's very developer
centric in my opinion it does have a
free tier for experimentation and then a
hobby level that's one step up which
basically doesn't sleep but it doesn't
put it to sleep after thirty minutes it
starts with around 512 Meg's of RAM
allocated to the app that your Java
process gets allocated so dependent upon
your application that you're deploying
you may need to actually move to the
paid tier if it's a larger Java EE
application or parts thereof the
previous part of this presentation we
focused payara the full server in this
part of the presentation I'm actually
gonna look at PI or a micro because
we're only able to basically deploy a
jar file to the server we can actually
copy up a full server although I think
there are ways of getting around that
where you could check GlassFish into
your get repository and pull it down
that way but I wouldn't recommend that
with pyrrha is it's actually it's pyro
or you could have done this I actually
had a separate demo that I was working
on let's warm micro so you could do it
with either of these two Pyro's nice
than that it was easy to get up and
running within a couple of minutes it
implements the if you're not familiar
it Eclipse implements the Eclipse micro
profile about 70 Meg's in size and
you've get all of the services that I've
listed down there by default the
documentation is a little off right now
in that I say EJ be light and EJ be
light means that you don't get message
driven bean 's they actually do support
message driven bean z' so hopefully
they'll get their documentation updated
soon since this was so simple I had to
make it a little bit harder so I decided
to pull in AWS so with pyro pyro micro
you don't get open mq by default so you
don't have a JMS provider fukusa
provides RabbitMQ as an add-on however
there is no AR AR file resource adapter
available to plug into GlassFish or
dénia any other app container so in
order to use message driven bean z' I
needed to find another solution so what
I did was I used payara has a
proof-of-concept RER adapter for amazon
sqs the amazon's queuing system which
meant that all i had to do was create
the queues up on amazon and then add
them to my code the cargo trapper
application thus i'll show the
modifications that I made to the cargo
track for modifications application thus
far all the demos so far there been no
changes to the actual application this
time I actually had to make changes one
to get the cargo tracker off of open MQ
because they had hard-coded settings in
there I'm to be unless that was the
primary primary changes that I made to
it and then the second one was to adjust
it for using the payara sqs plugin RER
file so that's basically that so
starting off this was the initial open
MQ MDB code so I'm basically showing so
this is the starting code where we have
our message driven we have our
destination lookups everything for open
MQ and when I change it over to using
the code that the the the AR AR you have
to change the code a little I have to
change the message driven bean a little
bit to make it work with the
payara sqs are sqs adapter so some of
the changes I had to change it to Amazon
asked us listener if you implement
message listener it actually tries to
fire up they actually tries to look up
em open em cube which is not actually
installed in Harrah's out it took me a
while to figure out that that's why the
application wasn't actually running
because I was like like you know I was
checking I thought I had left a file
around somewhere I've removed all of the
access keys obviously for the
presentation right now they don't have
any there's not an easier way of getting
them in there and then the you annotator
receive message with on sqs message to
receive the message and then in the web
that XML remove all the references for
open mq which is just a delete don't
have to add anything in there and then
so the application deploys on the route
remove cargo tracker so that you can
just go to the the when you open the
application that you don't have to open
another site to then navigate to the
cargo track or application slash cargo
tracker so it just makes it open on the
root of the application the other so the
changes cargo tracker has one class that
basically dispatches events to open MQ
so that class required a little bit of
shame a few changes so this was the Java
EE 7 code for connecting up with the
queues this was the changed code I was
sorry this was the code for sending a
message where it's using the JMS context
to send it all standards so this is the
revamped code to use sqs so as you can
see I have to put I add that connection
factor up at the top initiative a
resource look upon the sqs connection
factory and configure it in the
constructor and then the method method
for sending a message right now they
only support sending text messages so I
had to adjust some of the code in there
that was sending objects to actually
convert them to text the deployment
steps are fairly simple you install the
Heroku SDK locally on your computer and
this gives you a command line to execute
commands so the first one first one you
execute is actually Heroku loggin which
then sets up a session is like doing the
AWS login for the first time on your
local machine so you don't have to login
for all the subsequent commands to
create an application you do who create
if you don't provide a name it makes up
something random for you you add a proc
file with a command line to invoke your
application you then commit your changes
locally to get and you do a git push to
Haruko
so you just say get pushed to Haruko
command line has already set everything
up and your code actually what Haruka
does at this point was it pulls from
your yet it takes the code that you
pushed to it and it doesn't even build
over there so it actually builds the
code it's not you're not deploying build
code you're deploying the source code
file and then it builds it and runs it
right so it's clean you don't have to
worry about something you know is cached
output on your local machine anything up
there so after you've done that you you
can scale it up so I start up one dynamo
to get going and then you do who go open
to open the application and then finally
if you want to see the logs you do log
slash tail now that I mentioned the proc
file the proc file is the magic that
makes us all work so but at the
beginning I have the the web colon that
tells it that it's a web application so
it's actually gonna make sure that I
bind to the port so if I don't if my app
starts up and it doesn't bind to the web
court that's expected then it will say
that the startup failed and it will kill
it so this is the command line for
starting up Mike pyro micro I do Java
dash jar IR a micro that's the pyro
that's the entire GlassFish application
server in one jar file I do - - port and
the dollar sign port is the environment
variable that the port that the that
Haruka wants it to start up on it's not
gonna be port 80 and as I'm gonna be
port 8080 it's gonna be some port that
they made up great they're gonna be
looking to make sure that you Bowden are
serving up content on that I deploy the
AR AR file and then I deploy the track
of war and as you can see I've got the
target slash cargo tracker dot war so
I'm pulling the code that isn't built so
I pushed it they built the code the war
file is in the output and now I run it
and that's basically the demo we're out
of
I'm but that's you know if you can have
your application pushed and running up
there at no time at all if you go
through their Administrative Council you
can set up SSL certificates you can
easily add on stuff on to it so it's
really easy I had to make it more
complicated make it longer I'm doing the
spin up the application sorry
yeah nothing like living dangerously
yeah and the one thing I will say so
okay
I never do this okay so the first thing
I have to do is do a Heroku push and
what you're gonna see is the output from
the server Oh everything is up-to-date
there's nothing to push um so it's
actually already running
um if I was if I was creating a new app
I would do who go
oh great was going to create so this is
creating another a pop up on Haruko
which I'm not on that push to okay so
another app is done the app name is
actually still they created this random
name still rich I can now push my local
because I have my Co doesn't get locally
so I'm pushing everything since a date
and I can do it's actually already
running so you gonna good to see a run
the application should be running okay
well let's up and running basically in
summary next time somebody says Hawaii
doesn't work on the cloud please call
don't walk on it
Java he works on the cloud extremely
well honestly there's lots of more
options and just about anything else and
please on the way on your way out leave
us some good feedback you know lots of
lots of hours and lots of personal
sacrifices to make this demo happen so
please support help us out by giving
some feedback and to get the logs when
something doesn't work right we do
hiroko logs - - tail or the number it's
just the standard tale thing and there
we can see all of our logs so I was able
to pulling back the logs for what's
actually executing up on the server so
you can actually see the app is
deploying right now we're still
deploying what's actually instantiating
the Derby database there we go
now
there we go try the tracker
so that's running and it's sucking too
if we start executing actions the
queuing stuff will be handled by Amazon
okay thank you very much I appreciate it
like thanks for patience hopefully this
was useful thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>