<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>It’s Java, but Not As We Know It | Coder Coacher - Coaching Coders</title><meta content="It’s Java, but Not As We Know It - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>It’s Java, but Not As We Know It</b></h2><h5 class="post__date">2017-10-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PbIBYxVyWNs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">right good afternoon and welcome
everybody welcome to the very badly
misquoted from Star Trek
it's Java Jim but not as we know it
because the original quote that people
like to say is it's life Jim but not as
we know it and that's actually a
misquote anyway but anyway the idea
behind this presentation is to talk
about lambda expressions and so what
I've done in terms of the agenda is
divided up into three parts
first part we're going to talk about the
details of lambda expressions so who
here is using JDK 8 ok good so we'll
talk a bit about the details of lambda
expressions from the point of view of
what they are and how you use in and so
on then we'll talk some about the
performance of lambda expressions
because the way that they're implemented
is not quite how you might expect it and
so there are some interesting details
that we can discuss when it comes to how
lambdas perform compared to the
equivalent anonymous inner classes and
then the last part of the presentation
is how far can we take lambdas this is
where we get into the it's Java Jim but
not as we know it and the way that I've
kind of divided this up is that the
first two parts are what I describe is
interesting and useful the last part is
interesting but not so useful because
nobody is going to program in Java the
way that I'm going to show you at the
end of this presentation if you do
you're doing it wrong right so let's
start then with lambda expressions now
since you're using JDK I eat you will be
aware of some of this stuff but it's
worth talking about this a little bit of
detail so what we had before jdk 8 was
the idea of anonymous inner classes and
what we could do there is we could
create a reference to an instance of a
class that implemented a particular
interface and in the case of this one
it's a anonymous in a class that has a
single in a single method that needs to
be implemented so rather than actually
having to either create a new class
which implemented that in
face and then instantiate it what we can
do is we can simply say create my new
runnable which is the interface and I
want the method of that interface to be
implemented this way by having run and
then we're going to do some stuff and
then we'll start the the thread in the
usual way problem with this is it's
rather verbose because we have to
express it explicitly state that the
interface we want to implement is
runnable we have to have brackets in
there we have to explicitly put that the
method is called run it's a type void
return and then we have some stuff that
we want to do so it's a lot of stuff in
there which we don't really need and
that's what lambda expressions are all
about it's it's a new style of doing
that kind of thing but in a much simpler
form so now we know that we can use a
lambda expression to do that so we have
a single line now where rather than
having all that extra stuff the compiler
infers from where we use that particular
lambda expression what the type is so
the compiler knows that thread takes a
runnable as a parameter so it knows that
the type it's going to have to create is
a runnable and then we tell it what the
implementation of that method is but
without explicitly saying what it
returns what the parameters are and so
on
so much much cleaner much much easier to
use if we dig into a bit more detail
about what that really means what we're
doing here is having a simplified way of
representing behavior in Java rather
than it being state we can assign
behavior to a variable and we can pass
behavior as a parameter to another
method so this has a lot of benefits in
terms of what we want to do and in terms
of where we can use a lambda expression
we can use a lambda expression anywhere
where the type that's it's going to
represent is a functional interface
functional interface is one which has
only one abstract method now prior to
JDK eight it was pretty easy to spot the
functional interface because it only had
one method defined in it in JDK eight
in addition to introducing Lander
expressions there is the idea of static
methods and default methods in
interfaces what that means is that you
now have behavior included in an
interface and the kind of net effect of
that is that you have multiple
inheritance of behavior as well as
multiple inheritance of types because
interfaces allow you to have multiple
types associated with a variable what we
don't have in Java is multiple
inheritance of state so that's the
important thing it's not like C++ where
you have true model inheritance Java
you've got multiple inheritance of types
multiple inheritance of behavior but not
multiple inheritance of state so in jdk
8 if you have a single abstract method
then you can use a lambda expression to
represent that and the key thing about
that is that the body of the lambda
expression is the implementation of that
single abstract method the other thing
about this was that in terms of the
design this is actually a much simpler
way of allowing people to have behavior
assigned to variables and passed as
parameter rather than having to
introduce a new functional type to the
language because that that's another
alternative way of doing it other
languages do have a true functional type
but in Java because it was a existing
language they didn't want to add a new
functional type so they've done it
through the idea of lambdas so in terms
of the syntax of a lambda expression it
is like a method but very importantly it
is not a method so it's not associated
with a class that is a very significant
point and we'll kind of come back to
that in a moment but a lambda expression
is a functional interface type it is not
associated with a class in terms of the
the syntax what we have is the left-hand
side of the lambda operator are the
parameters that we're passing to our
method like object and the right hand
side is the body of our method like
object but not associated with the class
so in terms of its structure it is very
similar to a method so it has a set of
typed parameters it has body
return type and it can throw exceptions
so all of those things are exactly the
same as method but because it's not
associated with class we don't call it a
method the other thing about this is
that it is closure over values not
closure over types what that means is
that if you look at how you can use a
lambda expression you can reference
variables from the surrounding scope so
you can reference variables from outside
of the lambda expression and use those
in your lambda expression but there is a
restriction on that if you go back to
anonymous inner classes the way that you
could access variables in the
surrounding scope was only if they were
marked explicitly as final so their
value could be set once and you couldn't
change it that way you couldn't change
the the value inside the anonymous in a
class with lambda expressions the same
thing applies but the rules have been
relaxed a little bit so now the variable
has to be effectively final which means
that it can be marked final or if it's
not marked final it must behave as if it
was so its value can only be set once
and it cannot be changed right so let's
talk a little bit about capturing
lambdas so a capturing lambda is one
which uses a variable from the
surrounding scope and when I started
using lambdas I wrote a piece of code
which is very similar to this so I had a
class which I called data processor it
had a current value int and then I
wanted to process something so I used a
lambda expression and I did current
value plus plus I compiled it I ran it
it did exactly what I wanted it to do I
thought yes great my code is good then I
thought about it a little bit more I
thought to myself hang on that shouldn't
work because current value is not
effectively final now I've just told you
that we have closures over values not
closures over types so how can that work
how can the compiler do what I don't
expect it to do and it turns out I did a
bit of digging on this it took me a
while to find out what was happening
turns out that the compiler does
something on your behalf I'm not
actually convinced that this is a good
idea because what happens is it actually
inserts
reference to this in front of your
variable now remember that a Lander
expression is not associated with the
class that's not like an anonymous in a
class where there is an instance of that
anonymous in a class and if you use this
it would refer to the instance of that
class under expression if you use this
it refers to the class of the
surrounding scope in this case it would
be the data processor so if we insert
this in front of current value this is
an effectively final variable so we can
then use the effectively final variable
we can indirectly access through that
into current value and we can increment
it so yes it's old was the problem for
us
but I don't think we want the problem
solved because the whole idea of lambda
expressions is we're dealing with
functional programming where you
shouldn't be modifying state this allows
you getting away with modifying state
when you shouldn't really be doing it so
like I say I think this is a bit of a
mmm bit of a if he called because also
introduces code which you're not seeing
in the actual code that you write so
you're not aware of that reference being
inserted method references so this is
the idea that where you have a lambda
expression which is simply using a
method on the parameter that you're
passing to it or some other forms of
that which we'll come to in a moment you
can simplify that by eliminating some of
the extra code so in this case I've got
a file filter X and I want to represent
that using a lambda expression where I
take file F and I'm going to call the
can read meth on can read method on F I
can simplify that by simply saying file
which is the tonic colon colon and then
can read and that's equivalent to the
lambda expression above in terms of the
the way that you can use method
references they're actually three
distinct ways that you can use them in
terms of forming them and so the idea of
the this is that you have a target
reference double colon and then the
method name so the method names going to
be caught on the target reference as I
said there are three kinds of these one
relates to static methods one is where
you're calling an instance method
on an arbitrary type and one where
you're calling an instance method on an
existing object and if we look at the
rules for construction of those most of
it's fairly straightforward so in the
first case if we're dealing with a
static method what you're gonna have is
a lambda expression where you've got
some arguments and then you've got a
class name and then you call the static
method on that with those arguments so
to convert it into our method reference
you simply use the class name double
colon static method name great going to
the bottom where we using an existing
object reference what we can do is same
thing we can say okay we've got some
arguments we've got an expression which
represents an existing object we're
calling the instance method on that with
the arguments so the way we construct
the method reference is basically the
same except rather than using the type
we use the object reference one in the
middle is slightly more complicated
because in this case we have a set of
arguments where the first argument is
the type that we're going to call the
method on and then we have and
potentially more arguments after that
and it's those rest of arguments which
we pass as arguments to the instance
method on the first argument type ok now
that all looks very complicated so I
show you some examples and it makes it
much clearer at least I hope it does so
the first calling a static method we've
got string s as our parameter and we
calling integer dot parseint on s so
very simple we can convert that into a
method reference by saying integer
double colon parse int the second one is
where things a little bit more
complicated so we've got string s and
we've got into buyers parameters and
what we want to actually do an embodied
of the lambda expression is say s dot
substring of I and we can convert that
into a method reference by using string
because that's the type of the first
argument S and call substring on that
which will pass I as the parameter to
the call and then in terms of the last
one if we've got an existing object if
we want in this case we've got an axis a
and then we're going to call get length
which is in the class which we're
actually running in we can use this as a
reference because again the lambda
expression is not associated with the
class of this represents the surrounding
scope and we can call get length on that
so these are the three different ways
that we can use method references right
so now let's talk about lambda
expression performance because there are
some interesting things to understand
about that okay so the first thing is
that as we've already kind of discussed
there is functional equivalence in terms
of the three different types of way that
we can represent a function in Java so
we could have a lambda expression like
this so I want to say for each and then
I'm just passing W as the the word for
example and then printing it out okay so
that's a lambda expression being used we
also do that using a method reference
which you've already seen so we simply
say system dot out double colon print
line great
functionally equivalent to the one above
and we could also do it with an
anonymous in a class bit more verbose
but exactly the same thing so now when
we're saying we have to create a new
instance of a consumer of type string
and we're going to override the accept
method and we're going to print out the
word right the important thing about
these is that none of these do anything
different they all do exactly the same
thing but how they compile is different
so we look at anonymous in the classes
the key thing here as the name suggests
is with that we're dealing with a class
so when that code gets compiled the
compiler looks at what you've done and
it says ah you are trying to represent
an interface but you can't do that
because you need a concrete class in
order to generate an object of that type
so the compiler will generate a class
for you and anonymous class and if
you've got a class like foo then you're
going to see a class which is named
something like food dollar 1 to
represent the anonymous in a class
that's being used by food problem with
this is you end up with what's called
type of pollution so you're generating
lots more types in your application than
you really need what you really want is
a function the other drawback to this is
that because it is a class
at runtime you have to load that class
so there's an overhead in terms of
loading the class there's an overhead in
terms of initializing that class and
then from the point of view of using it
it has to be instantiated that could
place an additional load on your heap
space it could place an additional load
on your garbage collector because you're
generating objects and that might result
in more garbage collection you actually
want so there are a number of things
where anonymous inner classes are not
necessarily the best way of doing it if
you look at the lambda expressions
because of this functional equivalence
you could simply implement a lambda
expression as the equivalent anonymous
inner class so the compiler could take
that lambda expression convert it into
an anonymous in a class piece of code
and then compile that in exactly the
same way that you do in jdk 7 and
earlier and in fact if you look at the
the way that lambdas were developed the
first implementation did exactly that
so you've seen tactic sugar lambda
expression convert it to anonymous in a
class compile it off you go
probably doing that way is you are
forcing an inner class on your code
where you don't actually want it what
you really want is a function and the
decision was obviously made not to him
not to have a function type in the
language but it would be nice if we
didn't have all the extra work involved
trying to make a function type but then
ending up with lots of extra classes so
there has to be a better way of doing
this and there is and the way that it's
done in jdk 8 is through the use of the
invokedynamic bytecode and method
handles the reason behind this is that
if you look at the history of
invokedynamic this is the first byte
code that was introduced in Java since
it started and what it was goal was was
to help languages that were being
developed and compiled into byte codes
that weren't statically typed so if you
look at languages like JRuby for example
not statically typed so you can change
the the types of parameters and return
types of methods at runtime and in order
to do that with a statically typed
virtual machine instruction set you
to do a lot of extra work because you
have to test everything before you call
the method you have to determine which
method you're actually gonna be calling
so invoke dynamic was introduced in jar
se7 to make life easier for compiler
writers who were generating code for the
JVM in JDK 8 he was actually used by
Java because the JDK 7 Java didn't use
it so in JDK 8 lambda expressions used
the invokedynamic bytecode and the idea
behind this is to say ok we want to do
something in terms of using lambda
expression but rather than fixing how we
do that into the compiled byte codes
will use the invokedynamic bytecode and
we'll say leave the decision about how
this is implemented to runtime so then
the JVM can decide how it wants to do
the implementation of that lambda
expression when it's actually running
and that way if new methods are found of
how to do that better performing ones
it's very easy to change that we
couldn't change it in the JVM at runtime
rather than having to recompile your
code and generate the new set of byte
codes so as I tell you no fixed binary
format JVM can provide a different way
of doing that now if we look at how
things work in terms of lambda
compilation first thing is that the body
of the lambda expression has to be
converted into a method now I know of
I've already said you know it's a
function it's not a method it's not
associated with the class but in order
for it to work in terms of being used by
the the JVM it is converted into a
method in terms of its compilation now
that's what's done in one of three ways
so the first is if you have a non
capturing commander non capturing lambda
is one where you don't reference any of
the variables from the surrounding scope
so you know if you're doing something
like print line and well that's probably
not a good example but if you do
something doesn't reference variables in
the surrounding scope it's a non
capturing to do that it's very simple
for the compiler because all it has to
do is generate a new static method in
the class where the lambda expression is
being used where it passes the
documents of the lambda expression as
arguments to the static method it
generates and the same return type
so all it has to do is insert the body
of the lambda expression into that new
method very simple conversion for a
capturing lambda if it captures
variables like static variables and
things like that then again it's fairly
straightforward to use because it will
the compiler will generate a static
method the same way as we do for a non
capturing one but this time rather than
just passing the parameters that are the
parameters of the lambda expression it
will prepend to those parameters any
variables that you reference from the
surrounding scope that's static so that
way when the body of the expression runs
it has the variables as instant those
parameters they're being passed to the
method so it is able to work in that way
the third form is where you have an
instance capturing lambda so the lambda
is actually referring to an object
rather than static very static methods
so in this case
Rawdon creating a static method in the
class in which the lambda expression is
used it creates a truly synthetic method
which is one associated with that
particular class and then when objects
are created there's a method that's of
that so in this case because it's a an
instance method in the class which uses
a lambda expression it's able to refer
to the surrounding object so it's able
to access the the variables that way so
this is how we generate the method one
of three ways we now have a method in
the class which is using the lambda
expression where you use the lambda
expression a call to invoke dynamic is
generated and what this is called is the
lambda factory so the idea is that you
you make a call to the invoke dynamic
and that will return a reference to an
instance of an object whose type is the
functional interface that the lambda
expression represents so that that kind
of makes sense so we need some way of
getting a reference to the the object so
that we can then call the method on it
and in fact do that we also have a thing
called the bootstrap method which is the
lambda meta Factory and that uses the
Java claimed or invoke lambda meta
Factory class the important thing about
this is in terms of the the way that the
lambda expressions work is the cool
science of the lambda expressions where
we use the meta Factory or if they
evaluated in a lazy way that means that
if you don't use that lambda expression
you don't have any overhead associated
with it so this is quite an important
thing from the point of view that unlike
an enormous in a class where classes get
created and classes will be loaded and
things like that from the point of view
if you don't use a lambda expression
then you don't have the overhead of
actually calling the lambda Mehta
factory so it's it's ignored which means
you get better performance by using
lambda expressions in that sense the
next thing is if we look at the
differences in terms of implementation
between lambdas and anonymous inner
classes and you can break out what both
of these things do into three distinct
sections in the case of lambdas the
first thing is how you link to the
reference to the the class which is
going to give you the method which is
going to be called as the lambda
expression body for an anonymous in a
class the equivalent of that is loading
the class that you need to call the
method in order to execute the anonymous
in a class method now from the point of
view of comparing these two Oracle did
quite a lot of performance analysis and
there's a there's a video online that
you can find which talks about this
thing in quite some length so the team
in Russia did a lot of work on this and
what they found was that if you look at
the kind of comparison of these two from
a lambda point of view once you get
through to what's called the hot path so
once everything is kind of settled down
and you use these things a few times
linkage in class loading is about the
same so so the the effect of using
lambda expressions performance wise is
about the same as anonymous inner
classes so you don't get any advantage
for using either
but from the cold path which is where
you start up so if you're only using a
lambda expression a few times obviously
that's going through the cold path
rather than the hot path then lambdas
win so lambdas actually have much better
performance in terms of the first
startup bit because class loading is a
lot heavier wake operation than the
linkage that you need for the call site
of the lambda expression so the net
effect of that is that lambdas win
because in the first startup bit they're
better and then once you get to the sort
of stable state they're about the same
as anonymous inner classes second part
is capture and instantiation so capture
for lambdas how we deal with captured
variables instantiation for the
anonymous in a class and what they found
there was if you look at the two they
perform about the same if you're using a
single threaded environment so both will
be about roughly equal if you start
using multiple threads and you've got
more cause in terms of what you're doing
with though that particular part then
lambdas will win so lambdas perform a
lot better as the number of threads
number of cores increases anonymous
inner classes don't get the same benefit
in terms of the Stan she ation addresses
of their the capturing the other thing
that we was found about the way that
lambdas work in comparison to anonymous
inner classes is that if you have a
non-static anonymous in a class then you
actually need 50 percent more space to
represent a reference to a captured
variable than you do in a lambda
expression so again this is a small
thing but it means that lambdas again
come out on a head in terms of
performance and then the last bit is
where both of the different ways of
doing things invoke the method since
they're doing the same thing they're
invoking a method there's no difference
between those two so overall what was
found was that lambda expressions come
out on top in terms of performance which
is what you would hope now in terms of
like rules of thumb non capturing
lambdas automatically optimized just the
way they work is that they're they're
better in terms of optimization second
thing is that method references are
slightly more up
the reason for that is that as I
described to you earlier one of the
first thing that has to happen where
lambda is compiled is you have to
generate a new method which has the body
of the lambda expression in it if you're
using a method reference you don't need
to do that because you already have a
method reference so you don't need to
create a new one to put a call to
another method in it so the compiler
will simply ignore having to create a
new method and we'll just use the method
reference directly so that way if you
use a method reference it's actually
more efficient than using the same code
as a lambda explicit lambda expression
the other thing that they found in terms
of doing their analysis was that tiered
compilation gave better results with
lambda expressions now the point is that
tier compilation is turned on by default
so the advice really is don't use -
tiered compilation don't turn tier
compilation off if you want better
performance from your lambda expressions
right so that's performance okay so now
we've had the interesting and useful
section now we're going to move on to
the interesting but also useful section
right so the idea here is how far can we
take lambdas now I have to give credit
to somebody else for giving me
inspiration on this because it was last
year at conference in Switzerland there
was somebody called Jarek or an attached
key who did a presentation on lambda
expressions I sat there and I watched it
he did it in an IDE which was was just
blew me away
so he did it into IDE and he kind of did
all this this Java on the screen I
looked it I thought I have no idea what
he's doing and I had to think about it a
lot and I had to go and sort of I talked
to him afterwards and I we kind of
chatted about it and I and so this is
this is where we come from right so the
first thing is we call all these things
lambda expressions why do we call them
lambda expressions and the reason is
because of Alonzo Church so Alonzo
Church came up with the idea of lambda
calculus
back in the middle of the 1930s so
clearly you kind of think to yourself
well what does that have to do with Java
which didn't actually come out until
1995 so you know 60 years later Java
comes out
then it's another what is it like almost
20 years before we get lambda
expressions now the thing is that alonso
chose the lambda calculus was a
mathematical way of representing any
sort of way of processing things with
functions and so the interesting thing
about Alonzo Church was he was also this
supervisor for Alan Turing when Alan
Turing did his PhD in Cambridge so this
is the kind of interesting connection
between lambda expressions which is
functional programming now ensuring who
obviously did a lot of work on the
design of the modern computer so this is
where we get into what I call exploding
head lambdas as Java programmers we are
very much accustomed to imperative
programming so we like to deal with
loops and we very much like to deal with
state so we have variables in our
program we have for loops we have while
loops and so on but the problem is that
functional programming is not imperative
so I like to ask this question and so
everybody here's a job program I'm sure
so who would also consider themselves a
functional programmer yes you see
there's a few people but not everybody
and that's really quite telling I all
the audiences I'm I talk to this is very
common there are a few people who have
done functional programming in other
languages but a lot of Java programmers
are not functional programmers and it
does take a different way of thinking
about things to actually do functional
programming properly I would believe you
I learned that the hard way if you came
to my streams and lambdas talk this
morning with Stuart Marx you'll see how
badly I can write code using functional
programming anyway so the interesting
thing about lambda expressions and
lambda calculus is that lambda calculus
and chewing machines are completely
equivalent now Turing machines if you
have a Turing complete language Java C
C++ even javascript is Turing complete
then any problem that can be solved by a
computer can be solved in that language
lambda calculus is equivalent in terms
of the way that they work to the Turing
machine so that means that any problem
that you can solve with computation
can be solved using lambda calculus but
it will give you a headache believe me
at least it did me and I'll explain a
bit more of that as we go through so the
idea now is what can we do in Java if we
only use lambda expressions so we're not
going to use any primitive types we're
not going to use any operators we're not
going to use any now we're not gonna use
any objects either so literally only
going to use lambda expressions and
we'll have one functional interface we
have to have a functional interface in
order to create a lambda expression so
what can we do with this right so the
first thing is our functional interface
so we'll call it very originally a
lambda okay and lambda is going to have
one method one abstract method called
apply apply takes as a parameter a
lambda expression and returns a lambda
expression so that way we can chain them
together very easily good so now we have
to start off and think about how can we
do things in Java if we're not only as
primitive types we're not going to use
operators well the first thing is we
need a lambda expression to represent my
density so identity is where you pass
something and you get the same thing
back great so we can represent and we
can create a lambda expression called
identity and that returns a lambda
expression where you pass it a parameter
and it returns the same parameter so it
just gives you back what you give it so
far so simple and in red I've actually
used the the lambda notation because
sometimes he actually gets a lot easier
to understand in the land of notation
than it does the the Java code right so
we have a lambda identity for the first
couple slides I'm also going to show you
the equivalent anonymous in a class
because sometimes that makes it a little
bit easier to understand so in this case
we're creating a lambda called identity
which is a new lambda which then has an
implementation of the apply method which
takes a lambda X and returns X okay all
good so next we need some primitive
types so we're gonna create boolean
representations true and false so we'll
start with false and in this case false
is a lambda expression which always
returns the lambda expression which we
have for identity
okay so we're getting a little bit more
complicated so we have a lambda
expression F which returns another
lambda expression which is the identity
lambda expression and again if we just
look at the equivalent anonymous inner
class we've just got two layers of
lambda expression there so nothing
terribly exciting but I'm not going to
show you any more anonymous inner
classes because it does get way way too
much code the opposite boolean false is
clearly boolean true so in this case
we'll have a lambda expression which
returns a lambda which is never going to
be identity so in this case we can say
okay so it's the opposite of true the
opposite force is true great so we have
an lambda expression which does that so
now we've got billions right next we
need numbers so there are things called
church numerals church numeral we can we
can sort of take some mathematical
inspiration here and we can say that the
identity for addition is 0 if you add a
subtract 0 from any number you get the
same number back so it's the same as an
identity we already know what the lambda
expression for identity is so what we'll
do in this case is will use the lambda
expression for identity to represent the
number 0 that makes sense it's also kind
of logical from the point of view of
using our boolean true and false if you
think about C programming C language if
you if you don't see in C there isn't a
boolean type so if you evaluate an if
statement then the the false value is 0
true is anything other than 0 so in this
case true is the same as the identity
expression so it's also the yes so we
end up with 0 and so it kind of ties
together great the other thing is that
you can think of it in this way that the
function f is being applied to the
lambda expression 0 times now you might
look at mango okay what does that mean
if I point isn't 0 times but it becomes
clearer if we look at 1 okay so the
lambda expression for 1 is a lambda
expression where we take X and then we
apply X to the function f that we're
passing like I say this already starts
to get a little as a Java program it was
already starting to get a little bit
complicated here so that's what we did
we have apply the function f to X and
make that part of our lambda expression
and the key thing here is if you look at
lambda calculus lambda calculus doesn't
use loops so we would never use a for
loop in lambda calculus lambda calculus
does things repeatedly by in effect
recursively calling the same function so
if we look at the lambda expression for
2 what we do is we apply the function
recursively twice so now we have X goes
to F dot apply of F dot apply of X great
set and you can continue with that as
many times as you like to represent
numbers greater than 2 I'm not going to
do that because I think twos enough you
get the idea right now we need to look
at how we can do some mathematics so how
about if we want to increase the number
that we have by one well that's actually
not too difficult because if you think
about it what we need to do is we simply
need to apply the function to that again
so the the lambda notation shows that is
that way and in terms of a successor
lambda expression we end up with n which
is our number and then we want to apply
the function f to that one more time so
we get F dot apply of n dot apply of F
dot apply of X okay so the successor is
fairly straightforward if we simply want
to apply that function one more time
the predecessor a little bit more tricky
because what we're doing is we're
actually removing one call to the
function so that that makes life a
little bit harder and I'm not going to
explain this I'm just going to show you
what it is
so that's the lambda note that's the
lambda notation forever because then we
start getting all sorts of extra letters
involved so there's G H and U and X and
the equivalent Java code becomes this so
it becomes quite sort of nasty in terms
of our gates n F X and apply GJ over
that we're not going to use that so I
figured that that that's some rather
complicated if you really follow it
through it does actually work and
guarantee that so then let's look at how
we can add two numbers together almost
into the the kind of bit where we're
going to do something interesting so
addition is simply repeated incrementing
so if I want to add n to M it's the same
as saying add 1 to M n times so you
already know how to add 1 to a function
so all we're going to do in this case is
add 1 to the function n times so you end
up this slightly more complex way of
doing things that we've got m n FX and
all the applies right subtract which
again we won't bother with going into
too much detail we'll use the
predecessor function to to shrink down
some of the code but we can do the same
thing of repeatedly applying the
decrement operation to decorate ok so
then I thought right we want to do
something simple with lambdas let's add
2 plus 2 only using lambdas right so we
know the lambda for 2 is apply the
function twice recursively and so that
that's that straightforward
F X F dot apply of F dot apply base and
we know that the lambda expression for
plus is MN F X but a lot of up right we
need to combine these two and
interestingly we can do that by saying a
simple thing and this is Java code
lambda 4 equals Plus which is our lambda
expression and then we apply to that 2
and we apply to that too so we're
calling it recursively twice with two
values too and if you kind of write that
out just as the the mathematics you end
up with 4 equals plus 2 2 and this is
what's called polish notation I don't
know about you know
for those of you old enough to remember
like very early calculate P calculators
I think used a reverse polish so this is
forward polish rather than reverse
polish notation but you get the idea
that in order to add things we can we
can actually do it only using lambda
expressions so we can say lambda for it
was plus dot apply to apply to write how
do we know that that works okay so this
is where like it's interesting because
what we'll do is we'll follow through
the stages of how to actually show this
and I have to say that one of the things
that when I was doing this I was sitting
at the table and my son who was 10 at
the time he came down me scribbling out
stuff and I try and work things out and
he said to me what are you doing daddy I
said I'm trying to work out what two
plus two he looks at you looks at me
like I was stupid he said well that's
easy daddy it's four
so I said I'm trying to use lambda
calculus for this so I showed him that
the writing that I was looking goes no
no it's four so anyway so so what we'll
do is we'll take our Edition lambda
expression so we have M and we have n
that we're going to add together so in
the case of M we're going to replace M
with the lambda expression for two so we
get a slightly longer lambda expression
I've highlighted in red where we replace
M with the lambda expression for two so
we also take em away from the front
because now we're in effect applying
that to the the function and then what
we need to do is the same thing for n so
n is 2 as well so we'll replace the N
that we have there with the lambda
expression for 2 and we end up with
quite a long lambda expression but it
doesn't quite look like for yet so we
have to do some reduction on this so if
we switched that what we now need to say
is okay so we've got FX and then we've
got this we've got this bit here in blue
where we're saying f is the lambda
expression which is returning X goes to
F dot apply of F dot apply X dot apply
of F the nice thing about that is that F
is we're applying F to that but F is the
variable if you like so it's quite a
simple reduction we just in essence
off the apply and remove F so now yet X
goes to F dot apply of F dot apply of X
and if we do the same thing here we've
got a lambda expression here we've got F
and we want to apply F to that lambda
expression then we can do the same thing
which reduces down so we get X goes to F
dot apply of F dot of 5x then what we
need to do is we take that which has
been condensed down but we still got F
goes to X goes to X goes to our f of
apply and so on but we need to apply
this whole blue and it's actually in
within the apply we're going to apply X
again X is an easy one to to eliminate
because it's the same variable so we end
up with F dot apply of F dot apply of X
but now things are a little bit more
complicated because we have to apply
where we have X the whole of this lambda
expression F dot apply of F dot apply X
and that reduces down to yes so we get
that we reduce that X changes yes so
then we reduce that and we end up with F
goes to X goes to F that apply of F that
apply of F that apply of F that apply of
X which is four we have proved that two
plus two is four and we've shown that we
can do it only new zealander expressions
like I say did take me quite a while to
get that straight in my head so just to
summarize then lambda expressions very
useful very powerful a nice succinct way
to represent behavior so you can pass it
as a variable you can assign to a
variable capacitor as a parameter
better performance than anonymous inner
classes so if you're thinking you know
in terms of like performance programming
then lambda expressions are better way
of doing things than nonnamous inner
classes method references are even
slightly better than a then lambda
expression explicit lambda expressions
and as I say here you can use them weird
in wonderful ways but I certainly
wouldn't recommend trying to write all
your code only using lambda expressions
if you want to do two plus two in Java
use the primitive int type use the plus
operator much much easier more
information like I said my inspiration
came from the Eric's presentation
there's a video of him doing this at
devoxx in a box in Zurich and there's
also what Jarek based his work on which
was Dickson Yang's blog who works for
Microsoft and he did this in C shock so
it's a similar kind of thing but he's
got a lot more detail about how this all
kind of works out so with that thank you
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>