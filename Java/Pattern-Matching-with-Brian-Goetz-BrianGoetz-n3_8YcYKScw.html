<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Pattern Matching with Brian Goetz @BrianGoetz | Coder Coacher - Coaching Coders</title><meta content="Pattern Matching with Brian Goetz @BrianGoetz - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Pattern Matching with Brian Goetz @BrianGoetz</b></h2><h5 class="post__date">2017-08-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/n3_8YcYKScw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm going to talk a little bit about the
work that I've been doing the last year
on adding pattern matching to the job
language although very little of this
talk is about the language it's mostly
about the the language runtime and which
I hope will be usable by languages other
than Java as well so you've all seen
this slide a bunch of times that's how
you know I work for Oracle so okay
what's pattern matching a lot of
languages feature pattern matching which
is a primitive for tests and D structure
you have some target that you want to
match against and that pattern match
combines does it have the
characteristics you want with if so
extract the bits of state that are
interesting to you and this is a feature
that we've seen in languages building
back probably 40 years so languages that
were designed around text processing
like snowball supported pattern matching
on strings it's something you see very
commonly in functional languages so if
you if you're a functional language that
has structural types like tuples and
sequences of you you will say things
like does this match a tuple of a and B
and if it's a tuple it binds a to the
first part and B to the second part or
so or does this match a sequence of ABC
and if so it'll bind a b and c to the
first second and third elements of the
sequence
you also see pattern matching in
functional languages that have nominal
data types so haskell data classes you
know which have the names have the types
of names and the components have names
you can say is this a pair of x and y
and if it's a pair it will bind X and Y
to the you know the first and second
element and if you used Scala Scala
called these case classes basically the
same thing so this is a feature that has
shown up in a lot of different languages
and it's also something that is being
added to a lot of other languages not
just Java but c-sharp or tom has pattern
matching in the most recent version as
well so this is a feature that's not
just a functional language feature it
fits very nicely into object-oriented
languages and so you know if we're
interested in adding pattern matching to
Java the first question we asked
- you know how do we make it work is are
there pieces of it that are not Java
specific that other jvm languages would
be interested in using as well so most
of this talk is about features in the in
the jdk libraries that can be used by a
compiler to target you know to make it
easier to do pattern matching so i'll if
you haven't seen it I'll go through a
few examples if you have seen it I
apologize for the redundancy but a
pattern match combines as I said in
applicability tests do you match this
pattern with the destructuring bond get
gets a little bit sad of the target and
bind them to new variables and this is
simply doing programs all the time and
in fact it's you know Java it's quite
quite repetitive so the way a pattern
match might look in Java is maybe we'll
have a predicate called matches and
we'll say if this thing matches this
pattern and the pattern you know that we
show here is a destructuring pattern the
applicability test is are you a point
and if you know so it will do an
instance of under the hood and if you
are points it'll go and get the x and y
field at at that point and bind them to
the new local variables x and y and then
you can use x and y in the code that
follows and the thing evaluates to a
boolean so if it doesn't match obviously
nothing gets extracted and you move on
now we could do this today in Java of
course what we do we'd say if X instance
of point and then if it was if that's
exceeded we would cast X to a points so
X as point equals point X and then we
would extract the field you know XS
point X and X is what point off Y which
we do all the time and yuck right I mean
it's it's I I just asked you of an
instance of the net end and the next
thing I have to do is a calf well what
else would I do after an instance of
right so in some sense this is syntactic
convenience but there's also a lot more
to it one of the interesting new things
that comes out of this and this is not
something we've had in Java before is an
expression that Purdue
new variable bindings as a sort of
linguistic side effect right that you
know the variables you know the binding
variables x and y in this example
they're not declared in the enclosing
scope they just spring into existence
if the pattern matches and that's kind
of a new thing now there's a lot of
really interesting language design
questions here like you know what is the
scope of these variables x and y and we
have interesting answers to those but
that's not the subject of this talk so
we're going to talk mostly about what
what does this mean for JVM language
implementers okay let's do a few more
examples before before we move on so
this is code that we've all written
where you have some objects all you know
it's an object and you know maybe it's
an integer or maybe it's a string maybe
it's a float because it came out of the
you know the JVM constant pool so you
know it's going to be one of those
things so the first thing you do is you
do an instance of test and if that
succeeds you cast it and then you use it
and so we've all written this code
because we all have to write this code
but like everything about this code
sucks right so first of all there's a
lot of repetition and boilerplate and
unnecessary coding right I just did an
instance of test why do I have to cast
it couldn't you figure that out for me
right um there's the the business logic
is sort of obscured by all the
boilerplate of into the turbine casting
so it's not even obvious what's going on
actually very easy to make a mistake you
know and and if that mistake happens to
be in a branch that has been taken very
often then you might not notice that
mistake might not be caught in testing
it's a it doesn't exploit definite
assignment necessarily you know very
often when you do something like this
you want to do exactly one thing in each
of these arms but the if-elsif is a very
general language construct so we're
using an overly general language
construct and hoping we get it right and
that's often a source of bugs and it's
also accidentally sequential right this
code is going to be o of n because you
know absent like extraordinary you know
heroics by the JIT
it's just going to march down the you
know the list in the order that you
wrote it when in theory it should be oh
of one so you know we really hit the
trifecta here right it's like verbose
error plone and slow woohoo okay so we'd
like to do better so here is a step in
the right direction if we had our switch
statement and it's supported type test
patterns we could write it like this so
what's happening here in each case label
we're saying case integer I that's a
type test pattern the applicability test
is are you an instance of integer and
the destructuring part is well casted to
an integer then and bind that new
integer to the fresh variable I in this
example so step in the right direction
we eliminated the pair of instance of
cast and we fused it into a single
operation that's an improvement it makes
the code a little bit easier to read ah
and now that you can read the code
because some of the garbage has been
taken away what you see is I'm actually
doing an assignment to this formatted
you know result in every arm and
actually I'd like to compiler to prove
that it was going to do that for me that
I'm going to make that assignment
exactly once
I want definite assignment to work for
me so really what I want to do is turn
switch into an expression not a not a
statement so and you can do this this
you know that you know this is pretty
pretty straightforward so this is what
it might look like if we replied if we
allowed switch to also have an
expression form we get with a bit of the
breaks we get rid of the intermediate
assignments and now the compiler is
working for you that says well it better
be one of these there'd better be an
expression of the right type on the
right-hand side of each one of these
things and at the end of this it's going
to have assigned one of those to format
it right so this is a you know much more
compact representation of the same thing
than we had two slides ago and if the
code is more readable
it's gonna if you know it's going to be
harder to get wrong right so that so
it's not that we can't write code like
this in Java today it's just mechanisms
we have guide us towards an overly
verbose
and error-prone and potentially poorly
performing idiom so let's fix that
here's another example of how of how you
might use pattern matching in a job like
language you know imagine you have a
tree represent you know an expression
represented by a tree so you have
expression nodes which might be an add
node or multiply node or negation node
and you want to evaluate the thing so
these are somewhat more sophisticated
patterns these are destructuring
patterns which not only combine the the
instance of test and the cast but also
reaching in grabbing the field and
binding them to new variables so if you
have something that is an add node of
two other nodes
it'll take the left and right nodes bind
them to the local variables left and
right and then recursively call the
evaluator to evaluate each sub node add
them together and and return that so
again this is something we could do with
a switch or a visitor but it would be a
lot more error-prone so you know and and
with visitors it would be you know a
page and a half of code and you have the
double dispatch which you know makes it
harder to follow what's going on it's
really easy to make mistakes so this way
what you want to do is front and center
code reads like the problem statement
one more example of you know how this
how this might look is you know
supposing you want to take one of those
expressions you want to simplify them
using a bunch of algebraic identity is
like zero times something is zero and
one time something is whatever you
started with and zero plus something is
whatever you started with you could
easily do this with visitors now we're
at like five pages of visitor code you
can you know fit this in one page on you
know with using patterns where you're
saying okay are you an int node okay
we're just going to pluck the you know
the integer value out of it that's easy
are you integration node who the thing
being negated is also a negation node
patterns compose so the thing you know
when I say case neg node open paren neg
node again the thing on the inside is
another pattern what I'm
are you integration node if so extract
the the thing that your integration of
and match it against the pattern
negative it again right so if you want
to say negative negative something is
just to something this pattern will
match that and if you're negative of
something else it won't match that and
you'll move on to the next case which is
a more general case which is negation of
anything okay so patterns patterns
compose really nicely right so this is a
you know the things that are inside the
parentheses of the d structuring pattern
themselves can be patterns and in fact
like the one that says 0 plus something
equals something is actually nested 3
deep I'm saying are you an add node
whose left component matches in node of
0 well that's a pattern and the 0 itself
is a pattern that's a constant pattern
constant patterns only match the you
know the constant 0 so I I can express
something that would have taken 3 levels
of you know of it then very compactly
and again code looks like the problem
statement right so you know just imagine
how much fun this would be with visitors
right so so patterns are cool there are
multiple kinds of patterns that you can
have type test patterns constant
patterns see structuring patterns and
they compose through nesting which
allows you to say what you want all in
one go so ok good feature we like it
alright how do we implement it so you
know you can think of you know you can
think of this as being the complement of
the kind of polymorphism that we get out
of class inheritance right so you know
the polymorphism that we get in Java has
to do with classes declare methods
classes get extended by other classes
and those classes can override methods
from their super types and then a job
gives us dynamic dispatch on the
receiver type and so this polymorphism
is encoded in our class hierarchy and
very often that's exactly what we want
you know and in fact in the example I
gave before about node evaluation we
might very well have had an eval method
on node
and you know the implementation of the
eval method on AB node would have been
evaluate these two nodes and add them up
and return that that's a very sensible
method to put on your in your node
hierarchy um you know and but there are
also operations that we tend to do on on
trees that aren't necessarily sensible
to actually put in the hierarchy
themselves right so you know if I wanted
to answer the question do I have a sub
node whose which evaluates to 42 that
would be a stupid kind of thing to try
to pollute my hierarchy with other
languages approach polymorphism from the
other direction from the used sight
direction where the picking of pattern
matching is a way of simulating dynamic
dispatch by saying here all the cases I
care about in one place and these two
things complement each other it's not
like one is right and one is wrong some
you know the declaration side approach
makes a lot of sense when this is an
operation that is intrinsic to your you
know to your type hierarchy there are
operations that aren't intrinsic to the
type hierarchy but we still want to
perform on on a tree which is usually
when we weeks for the visitor pattern
today so this is you know provides
serves all the purpose that a visitor
pattern did but with an awful lot less
boilerplate less error-prone and more
optimizable so I sort of see this like
use site versus declaration site
polymorphism as being complementary
they're not competitive it's not that we
want one or the other one is better than
the other but they're each they're each
good for you know for different
different sorts of things okay so if we
think about this more abstractly about
how this fits into the object model the
examples of destructuring that I showed
are the dual of construction right a
constructor takes a bunch of arguments
and produces an aggregate so new point
of you know three comma four I take the
state of my point three comma four I
call the constructor and it gives me a
point that in caps you know that
encapsulate that state when I did a
match against a point I was doing the
opposite of that I'm taking the point
and I'm exploding it back into its
constituent parts
and while not all objects naturally
support this kind of reversible
construction and in fact for some
objects we don't want to provide
reversible construction because we want
to keep our state more tightly hidden
for a lot of objects especially those
that represent just ordinary data it's
very useful to be able to go back and
forth between the state representation
and the aggregated representation so if
we define you know a destructor and mass
as the as the dual the complement of
construction you know these things can
work with each other right they compose
pretty nicely if I take an object D
structure it into its constructor
arguments and pass that back to the
constructor I can just compose these as
functions and that's basically a clone
operation if somewhere in the middle I
destructor something I encode it into
some you know XML JSON string form
whatever I pipe that into you know
something that decodes the elements and
back into the constructor that's a
serializer right so you know these two
things you know work very naturally as
complements that as part of the object
model and I think that the pattern
matching fits much more deeply into
object-oriented programming that a lot
of people give it credit for
so our thesis is this is part of the
object model let's make it so let's you
know make it possible to expose
deconstruction is a first-class member
and you know deconstruction just like
instruction might entail arbitrary logic
but usually not usually it's you know
pluck the fields out and and and move on
with it okay so the obvious question
that we ask ourselves is you know is
this a language feature or a VM feature
or more specifically is there some part
of this feature that we would really
like to have VM help with so if you you
know think about you know how we you
know we process a method call today you
know there's there's two sides of the
Declaration and the use and and the
mediation between the Declaration of
these and the end use is
is nominal dynamic linkage right so the
call side says here's the method and
descriptor I want the Declaration says
I'm a method with this name a descriptor
and at the first cost call the VM looks
for the method matches the parameters up
and and links them so we would like to
be able to have that same kind of
mediation for patterns when we do you
know say does P match this you know that
this D constructor we want that to go
through the same overload resolution
mechanism and dynamic dispatch method
mechanism as we do with methods and they
look a lot like methods in fact if you
squint
they're almost like methods except
they're really more like like anti
methods because method has multiple
arguments and one return and a pattern
has one argument and multiple returns
right so they really are a complement of
each other so some patterns are so
simple that the compiler can generate
them for us you know like in the point
example we might we might have the
compiler generate a Deconstructor based
on the field um but at some point things
might get complicated and that's what we
actually have to write some code you
know maybe we have to transform from an
internal representation to a different
representation you know Cartesian to
polar or you know RGB to CMYK or
something like that
so if these things kind of like look
like methods and we want them to be
linked like methods we'd like to get the
benefit of all the other things that
methods have like access control and all
of that so you know our thesis is they
are kind of like methods they're just
not easily representable methods let's
treat them as class members and give
them all the treatments that class
members get now they could almost be
methods and if you look what other
languages have done with some
compromises other languages have managed
to turn them into things that look like
methods you know on the JVM so for
example in Scala the way you declare a
pattern is by writing a method called
unapplied and the way they deal with
returning multiple things
is you box those things into a tuple and
the way they deal with
well maybe the pattern doesn't match the
target you wrap that in an option and
you know that's not a terrible way to do
it if you you know but one thing you
give up on from that is the ability to
overload you can only have one on apply
method because you can't overload you no
methods on return type another
compromise that you get out of that is a
lot of boxing primitives get boxed into
boxes values get boxed into tuples
tuples get boxed into an optional and
they and they've made some progress in
reducing the boxing overhead in in in
recent in recent versions but it's still
a visit performance compromise c-sharp
has more tools at their disposal
so they've managed to avoid both of
these pitfalls because they had out
parameters so they've modeled P
constructors as extension methods with
multiple out parameters so they don't
suffer the overloading problem they
don't suffer the boxing problem
unfortunately we don't have out
parameters so we can't play that trick
so the basic limitation that we're
bumping our heads up against is a JVM
limitation that a method can take
multiple arguments but can only return
one thing and we could cheaply implement
patterns as methods if any of the
following were true the JVM supported
multiple return well it doesn't do that
JVM supported unboxed tuples nope
doesn't do that either JVM supported out
parameters that's kind of like multiple
return isn't it if we had value types
well we almost have value types but
where we'd kind of like to shift this a
little sooner than value types or we had
box elimination that was so awesome that
we never worried about boxing anymore we
don't have that yet either so or if we
just didn't care about performance and
unfortunately we don't have that luxury
so we had any of those things and the
ability to over load and return types we
could model these things as methods but
we don't have those things so
we still want to make some progress so
let's write out some requirements and
see if we can figure out how to do this
we want to be able to encode our
deconstructors as class members so that
we get all the things you get from class
members overloading access control
reflective access a clean object model
you know etc you know we want
indications of patterns to be you know
mediated by you know by symbolic linkage
and we want to be able to invoke these
things without too much boxing people
don't like it when language features
create garbage you know they they if
there's going to be garbage created they
want to see the letters any W in the
source code right they want they want to
own that garbage so we try not to try
not to voice garbage on you know on our
users if we can so all right well we
have basically one magic hammer right
what is it well of course it's method
handle so let's let's grab that and
start swinging and see what we can do
actually we have to magic hammers
there's the method handle hammer and
there's you know the computer scientists
best friend which is the another level
of indirection hammer so between the two
of these I think we can do something so
instead of saying addy constructor is a
method that takes the target and
deconstructs it how about if the method
were a factory for ad constructor thingy
now this is a trick we've done before
right how many people recognize this
trick can you lambda that a factory
anybody recognize this trick right so
rather than um you know rather than run
for having runtime that creates lambdas
for you we have runtime that links a
call side to act as a lambda factory
right and that trick was a very powerful
trick in lambda so we you know it worked
then let's give it a try see if it works
again so let's model addy constructor as
a tuple of method handles it's got one
two look at the target and say do you
match or not and that thing returns
boolean and if that said yes it has a
bunch more method handles that each
extract one components which probably
are going to be field access or method
handles and you know if we do
that's right we should be able to avoid
all the boxing and we should also be
able to support a you know dynamic
linkages separate compilation and good
composability
of patterns so let's see if that works
we can start with an observation which
is even though some patterns will get
very fancy the the common case is going
to be very simple I'm matching against a
point my applicability test is instance
of my extraction of each of the
components is a field access there's no
complex computation to determine if you
meet the test there's no overlap between
the computation of fetching acts and
fetching why that's the happy case that
we want to optimize for we want to make
sure that that's really cheap and then
we want to make sure that the less
common case which is a more
sophisticated test or having common
computation between the components is
something that is reasonable okay
so like you know here's an example of
the less common case where if you want
to know if something's a power of two
well you know you keep dividing it and
for as long as you keep getting zero
remainder you keep dividing it until you
get down to one you say yeah it's power
of two and then okay what's the exponent
oh damn I should have been counting as I
was dividing shouldn't I right so that's
an example where you'd like to do some
pre computation where the result of the
pre-computation encodes both yes I
succeeded and here's the result you want
but that's the uncommon case right so
let's focus on the common case first we
also because of separate compilation
need to make sure one can migrate
between these cases where maybe you
start out with the default e constructor
and then you migrate your code over time
you add more complex Deconstructor logic
you want to be able to migrate from one
to the other so to support the uncommon
case you generally need at least one
word of state that's carried from that
first computation are you a power of two
to the extraction well what are you two
to the you know to raise to raise to
what so we call that a carrier
and from a language runtime perspective
we don't care what the type of that
carrier is it could be an end a tuple
whatever that's something that should be
private to the Deconstructor
implementation so we have a couple
choices we could say well forget about
that let's just recompute these things
redundantly and hope that most of the
time common sub-expression elimination
saves us from ourselves and that might
actually work or we could say we're
going to gather intermediate results
into a carrier and then and then pass
that on to the the next method handle so
here's another example of a computation
that has some you know that would that
would involve some redundant computation
if we just did it sort of a naive way
this is converting RGB color to a CMYK
color where first you have to compute
you have to scale your RGB value and
then you use that to compute K and then
you're going to use K in the computation
of each of the CM and Y computations
right so we could conceivably just do it
the dumb way and there's a good chance
that it would help us out but we don't
necessarily want to rely on that okay so
here's my strawman example we say that a
Deconstructor handle is parametrized by
some types its target type what am i
deconstructing and a bunch of types for
the bindings what are the types and each
of the things I'm extracting and then
there's also this hidden carrier type of
what's the intermediate value that this
funnels through while I'm doing the
computation and then I can I can
decompose that into n plus 2 method
handles where n is the number of
bindings I have the first one says do
some pre computation which is enough to
determine do you match or not and if and
if so compute the carrier the next
method handle looks at the target in the
carrier and said well did it match
that's generally going to be a fit we're
going to be fast and then each of the
component method handles takes the
target of the carrier and says alright
get me the ice component down in the
happy case you know the the match
predicate is just an instance of test
and the component handles are just
filled accessors but in the complex case
there may be some state that gets
carried through this computation
so I've modeled that with an interface
type here the Neff it handles are the
bottom pretty things there's a function
from the target to the carrier there's a
function from the target of the carrier
to tubulin to determine if you match and
then there are n functions from target
and carrier to the binding variable and
notice also we can sort of encode this
as the opposite of a method type as we
kind of squint where the we take a
method descriptor and the the parameters
describe my output variables and the
return value describes my target so and
this turns out to be a useful encoding
if you're willing to cheat a little bit
okay so now we have to have some way of
dynamically dynamically linking to one
of these things we can't just declare
them as methods because we want to be
able to to overload them but how many
people here read John's blog entry
called symbolic freedom in the VM okay
so it generally it's it's an encoding
strategy for addressing the problem that
you have strings that you want to encode
as VM identifiers x' that can't
necessarily be easily encoded in the vm
instruction set so sorry identifier
identifier rules so we can use this
trick we can say let's take the name and
the descriptor and let's encode that as
a name that the VM can can represent and
that's going to be a pretty stable thing
because that's usually what we link
against right is names and descriptors
so if we encode that using you know
using this encoding you get something a
little bit horrible-looking as an
identifier name but the users never
going to see that that's just what goes
into the class file and this becomes a
static method that doesn't actually do
the deconstruction but it serves off one
of these Deconstructor handles right on
so for the for the matcher
that you know whose types are whose
binding variables are int an int you
call this method you get a D constructor
handle that describes that matcher
and and the body of that method it's
just an LDC you
in constant dynamic so the thing that
comes back is a constant so that's nice
okay
what is it voguing look like like well
there's that ugly method which like I
said the user is never going to have to
see compiler writers can deal with it
but we you know we do that kind of stuff
and we have again the constant dynamic
bootstrap whose arguments are the class
name the the name of the D constructor
and the method type that is descriptor
and the bootstrap goes computes that
ugly name looks to see if there's a
method by that name if so calls it and
because these these Deconstructor
handles are just constants we can use
that or use a constant dynamic for that
as well
so that you don't have to keep fetching
that Deconstructor in that other class
every time you're using it as the first
time you use it the the constant will
get resolved and and then it's there
after it's just a constant and then the
matching gets translated pretty
straightforwardly you know you do a load
constant of you know find me the
appropriate D constructor that call the
pre process handle I then pass the
result of that to the matches if that
succeeds great I keep call the component
zero I call the component one I get the
the bindings out and I use them and in
the common happy case its carrier free
its allocation free I've done all the
hard work through constant loads so I'm
not going to do those redundant ly every
time I match and in fact like I can push
more of this work into the constant pool
the expression that describes the method
handles DC def pre-process + DC
component 0 DC component 1 those are
constants - I can use constant dynamic
to put those in the constant tool also
so this is going to you know you can pay
a little bit of cost of link time to set
this up and then everything is going to
in line beautifully because what are
these method handles they're instance of
and field accessors so you're going to
end up with when it comes out of the
other side of the jet you're going to
end up with like the handwritten code
that you would have had you know it
without without any additional overhead
so that's
all right let's see some more nice these
things are constant tuple of functions
because they're constants and functions
compose if we do our job right
destructors can compose also and this
composition can again be done with
constant dynamic at length time so the
overhead of doing this you know it all
becomes a one-time overhead so for
example I have a Deconstructor whose
descriptor is d and i have a method
handle whose descriptor is d and
remember the descriptor of the d
constructor is really an inverse i can
compose these two things using method
handle Combinator's and the result is a
method handle that takes a tea extracts
the components passes them the other
method handle and returns whatever that
second method handle you know returned
so if that second that's a handle where
a constructor then this is my clone
operation and you know if that second
method handle was something you know why
that it encoded it to a string this
would be a serialize ER so the
destructors deconstructors compose
nicely with other method handles they
also compose nicely with other
deconstructors so you can have more
sophisticated patterns like does this
match pattern what p and pattern q well
i can write a Combinator in about ten
lines of code that takes pattern P
pattern Q as Deconstructor handles and
produces a new pattern that implements
do you match both of these and if so
give me the bindings for all the
bindings from P and all the bindings for
Q similarly I can have a Combinator for
or pattern do you match this or that as
long as the binding variables have the
same names and types or in the nesting
example like what I had are you an add
node whose left node is 0 I can take the
constant pattern 0 I can use a nesting
Combinator to say nest 0 pattern as the
first argument of the D constructor
pattern and it will give me back another
D constructor which again is all
constants and this'll all be done at
constant dynamic bootstrap time so these
things you know these
composed really nicely and as a compiler
writer it means I don't have to generate
very much code at all right all I have
to do is you know my source code and
codes like an and pattern so I generate
some you know some bootstrap calls out
to the the pattern runtime to say give
me the n pattern and then all my
deconstruction goes through that same
inner fence one same interface that I
showed you so it moves a lot of work
from the compiler writer to the language
runtime so that's pretty cool huh
so that's invoking one pattern what
about invoking a whole bunch of patterns
with switch
ideally we'd like for our pattern
dispatch to be o of one not oh of n
right if I'm saying are you an integer
are you are you a string are you a float
are you a double these are mutually
exclusive things so I should be able to
use some kind of hashing strategy to
pick one of those without having to ask
too many instance of questions and you
know a lot of languages translate
switches into long chains of
if-then-else and you know our prototype
does this too right but we'd like to do
better and you end up with something
that has o of n time time complexity so
what we'd like to do is say well let's
take this this from this more complex
switch lower it to a switch on integers
whose case labels are 1 2 3 4 5 6 7 and
then have a selector function which is
an invoke dynamic that's going to return
one of these numbers and what's the
argument list of our of our
invokedynamic
well it's a bunch of pattern constants
which is really cool because patterns
are constants and the the argument list
of invokedynamic bootstrap has to be
constant so I just you know load my
patterns out of a constant pool pass
them you know to my invokedynamic
selector which at linked time is going
to build a decision tree and then I call
that thing and say well which one of
these might have been it'll say well
definitely not 1 2 3 or 4 so start at 5
right so there's a whole range of
translation options but you know of how
fancy we get
much work is done by the bootstrap
versus how much work is done by the you
know the generated by code so we haven't
quite figured out where we're going to
land on that but it's it's really nice
that you can pass a complete description
of all your patterns no matter how
complex you know to one bootstrap and it
could you know if you've got fancy
enough just build the decision tree you
know at first invocation time so here's
an example of what I mean this is the
same source code I showed you you know
at the beginning where I'm doing a bunch
of matches on are you an in node are you
a add node are you integration node on
and so you know the way the way I might
translate that and the scheme that I
just described is okay so for each of
those case labels il DC up one of my
destructor handles and then I lower my
switch from being pattern label to being
in labeled and I have I call the
selector function that I invoke with
invoke dynamic whose static arguments
are the list of all the patterns and I
call it on with my target and it gives
me back an int and then I just switched
right into that and the VM implements
table switch really efficiently so I'm
done so that's pretty cool
all right what about binary
compatibility right when we invoke a
method you know we want you know that
and the methods in another class and
that other class has been separately
compiled we would like chain you know
reasonable changes to that method to not
break the other that the call site in
the client and we'd like the same thing
for pattern in vacations right so and we
would like to be able to for example
change the carrier type of the pattern
or go from no carrier to having a
carrier or go from reference carrier to
a value carrier without breaking
existing clients because we don't want
to say gee if you recompile this class
you have to recompile all those other
classes we don't like to ask people to
do that so this is something we're still
what still working on some of these
transitions work some of these
transitions don't quite work yet and
we're we're bashing our head against
that
but I think we'll get there but this is
one of the you know one of the
characteristics that we want to have a
you know for this mechanism is the
ability to separately compile the
pattern specification from the client so
okay so let me just sum up this is not
just about what we're doing in a java
language we're putting most of the guts
of this in the jdk runtime this is a
trick that we use to great effectiveness
for lambda when we put lambda mehta
factory in the jdk very quickly a lot of
other compilers made of such as Scala
started targeting lambda meta Factory as
their back-end which you know not only
means that they get to use stuff that's
already in the the JDK that they don't
have to reinvent which is great but also
a benefit of interoperability across
languages so we're hoping to play the
same trick again provide a nice runtime
for pattern match and dispatch have it
be efficient have it support you know
binary compatibility across separate
compilation and have that be usable from
in Java Scala whoever wants to use
pattern matching so with that I think I
have a few minutes for questions Eric go
ahead
so so the question is the the component
the component call the component method
on the destructor handle just returns a
function and and that function takes the
target type which is a you know what am
i extracting from and the carrier type
which is just an implementation detail
and returns a strongly typed components
but method handles in the JVM are there
strongly dynamically typed so we don't
have to write down their types in the
Java type system you just have to make
sure that whoever is calling them and
whoever is implementing them agree on
what the types are and since the types
of the components are come from you know
the source of the pattern you're saying
here's a pattern that yields up an int
and an int the the client will generate
code that expects an int the
implementation will serve up an inch and
the handshake gets done at linkage time
so you don't need to pendant type so you
just you just need to be careful which
is the same trick that you know
basically any you know of any language
using the invoke dynamic or method
handle runtime has to have to put up
with okay Remy
I am implementing pattern matching in a
dynamic language that you invoke dynamic
so the problem you have you will create
your world 300 but by example if you
have a pattern that need a class but you
don't match it constant things you will
load the types too early so the concern
which you should bring to the expert
group meeting on Thursday is well I've
got a pattern that whose components are
types a B and C but maybe the the client
site doesn't need the third component
and we don't want to load classy well
first of all Class C will probably have
been loaded as a result of loading the
class that has the pattern declarations
but even if not let me let me finish
Remy even if not what the client is
going to do is it's going to invoke a
Deconstructor handle Combinator that
says drop the third parameter type
because it knows that it doesn't want
that result you know because the source
code said you know a VAR a VAR b you
know nothing dropped yeah and so that
method handle will never get will never
get invoked and that type doesn't appear
in the class file for the client so that
won't trigger unnecessary class loading
somebody else gets okay ask a question
you can bring those things relating
andrey and no no no no no good get Remy
please please and you can get lots of my
time to do go ahead on J thank you so so
what do you ascribe depends on constant
dynamic great I does it could be
implemented without constant dynamic
using invoke dynamic so the way we do
lambda meta Factory today is if you have
stateless lambda which is a lambda that
doesn't capture anything instead of
linking the call site to the
structure for the lamda proxy we invoke
the constructor once and we link the
call site to always return this
constants and so you can simulate
constant dynamic with invoke dynamic
whose bootstrap links that links the
result to a constant Combinator so we
could do this without confident so my
question was do we have to wait until
constant dynamic is there to have this
feature or not so I hope we are not
going to have to wait very long at all
for constant dynamic okay hey Dave for a
lot of different languages hopefully but
can you speculate on the Java syntax the
syntax for the the matching or the
declaration of a matcher
so I think it will look a lot like the
examples in the in the early slides here
that's my current thinking here I'll
pull those up so that a that a statement
switch would look like this that a
expression switch would look like this
and that nested patterns would look like
this that's my current thinking this
will be this is being discussed on the
amber mailing lists
amber dev and amber spec experts so
there's been some examples posted but
that's if you have thoughts about it
amber dev is the place to bring those
the deconstruction is a harder problem
how you would describe a Deconstructor
is a kind of stuff ten pounds into a
five-pound bag problem because you have
two argument lists what's my target and
what are my binding parameters and you
have an extra bit of state of is this a
matcher that always succeeds and that's
useful to know or is this a matcher that
might fail you know does it return
boolean or or what have you so it would
something like a method but it's it's
its header has a little too much junk in
it to be qualified as a method so we're
currently exploring various permutations
of stuffing 10 pounds into various
smaller bags yeah that in a constructor
you're used to saying this dot x equals
x de staat y equals y the dual of that
is x equals this dot XY equals this dot
y where you know x and y are the binding
variables and then the question of how
they how they compose like how you would
compose the d constructor with a super
what we're working on that not there yet
I don't have pretty examples to show you
I wish I did so the question is do you
expect to have default constructors on
so we talked I talked yesterday oh I
guess maybe Monday at the workshop about
data classes which were a sort of lower
ceremony data carrier abstraction where
you would automatically get constructor
equals hash code to string and D
constructor
I think there was a question in the in
the back did you think about the partial
deconstruction scenario I want to take
four fields out of one class movie to
three fields on the other class mostly
like data binding scenarios so a
Deconstructor doesn't have to serve up
the entire state of the object just like
you can overload constructors you can
overload deconstructors that have
varying numbers of binding parameters
and so you can say just get me this
portion of the state that's fine on the
client side you can say ok well I'm
calling the D constructor that serves up
three ends but I only care about the
first one so there will be some token
you know a lot of language these
underscore and for the I don't care
token and by saying that the compiler
will generate code to fetch it
so this partiality that comes through
the Declaration of the D constructor and
you can have multiple overloads
and there's partiality that comes from
yeah
I'm calling a Deconstructor that returns
three things but I only care about one
of them so just give me the one and in
the kind of follow-up question if you
thought about doing it from the outside
and not by the implementer of the class
because a lot of times I'll get the type
from a library I don't want I can
sometimes go and add stuff to it and
it's much easier to have an external
system that goes and does nothing for me
yeah so the question is what if I have a
class who's you know author didn't give
me a Deconstructor but I know how to get
to the state well just as you can write
a static factory method to delegate to a
constructor like that you can write a
static Deconstructor that will delegate
to you know the getters for the various
state and and serve them up together so
yes they basically wherever we have
different kinds of methods in the object
model constructor static methods
instance methods there are sensible
analogues of all of those for
deconstructors if I construct something
with a constructor I expect to be able
to deconstruct it with a deconstruction
pattern if I construct it with a static
factory method I should be able to
deconstruct it with a static
Deconstructor if I construct it with a
builder I should be able to deconstruct
it with a none builder there's a very
nice duality here okay one more question
to here speaking about this simplified
sample doesn't have the default branch
for the case when nothing matched
an excellent question so the question is
ah your switch here isn't exhaustive and
an expression should be exhaustive so
yes I could have a default branch or
maybe the compiler can prove exhaustive
this for me how might the compiler prove
exhaustive nasaw Karen talked in her
talk about access control she talked
about how nestmates
enable us to do sealed glasses where a
class can say I am abstract node and the
only subtypes that are permitted are add
node multiply node negation node and in
node
if the compiler knows that it can know
that this is an exhaustive
deconstruction and not force you to
write a default method now you still
might get extra tight through separate
compilation so the compiler would admit
a silent you know default arm which
would throw some exception saying well
something showed up that wasn't one of
the choices at compile time go fix your
code buddy which is better than like you
having to write that stupid that you
know default which you wouldn't do as
good a job as compiler does because
you're already mad you have character
fault you know so so yes if the compiler
can prove exhaustive this for you you
don't need a fall Clause so last
question Eric school and I think in
Scala too you often want to combine the
pattern matcher the condition so you
want to like match on points X and Y and
then X should be larger than Y or
something are you going to extend this
index for the switch statement as well
so yes a question is sometimes it's nice
to have guards where you know you can't
quite nest one pattern in another
because your guard condition can't be
expressed to the pattern but you want to
be able to say you know does this thing
match this pattern that extracts a
string where the string starts with ABC
so that's called a guard that's pretty
easy to do we think we want to do that
we're like going back and forth on the
syntax
unfortunately the code is never very
readable when you do that because you
have this like you know you have the
pattern and then the guard it's not
clear where the pattern ends and the the
consequence begins but we think we'll
probably go there yeah yes once you have
guards unless your guards are really
trivially screwed about you know the it
undermines the compilers ability to do
exhausting this checks but still if you
have like a you know case string a swear
blah blah blah blah and then you have
another case string s that's
unconditional you know the unconditional
string dominates the guarded string and
so if you're doing you know it exhausted
its analysis by type enumeration as
long as you have an unguarded version of
each type you'll still get there so all
right cool well thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>