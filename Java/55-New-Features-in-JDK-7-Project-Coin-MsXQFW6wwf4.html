<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>55 New Features in JDK 7 - Project Coin | Coder Coacher - Coaching Coders</title><meta content="55 New Features in JDK 7 - Project Coin - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>55 New Features in JDK 7 - Project Coin</b></h2><h5 class="post__date">2012-04-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/MsXQFW6wwf4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome and in this series of screencast
we're going to talk about 55 new
features in Java 7 that you probably
didn't hear about well you may have
heard about them as I go on we're going
to do this in a series of a probably
four screencasts normally when we do
this presentation it takes about 55
minutes 55 slides we do this in a very
quick format we go through the slides
and when the minute is up we go from
there but when we take a look at this
the PRD for Java 7 had almost 2,000
changes and we're going to talk about 55
of the of the better ones that are there
so we're going to start talking about
the changes of Kaman project coining and
of course the first change that we talk
about is binary literals and binary
little literals are a new piece that
were it was added in very simple type of
thing where you can add binaries to a
mask bringing in your literal in there
to an int or to a short makes it very
simple to to add those binaries in there
you could do this once before so as you
can see in the case here we all know
that whenever we can use binary little
literals we could create things like
happy faces so kind of a cool feature
there for binary literals the other
feature that was in project coining a
JDK 7 is underscores in numeric literals
so following along the same sequence
here but now it allows you to be able to
put these underscores and it again makes
it very easy to be able to read this I
don't know about you but when I would
take a look at that first line where
we're doing a mask if if we were reading
that as just ones group of letters
without the other scores in there it
becomes very difficult to read that
environment take a look at a credit card
we can see where it's much easier to see
that we can look at the Social Security
number how that comes out there makes a
lot of sense to be able to do that the
thing is is that you have to do these
things in the right location we could
take a look at some of the eval advise
that are down here so you know pointing
out putting an underscore in exactly the
wrong place right before like when
you're dealing with a Social Security
number before you defining the L
work strings and switches one of the
next pieces it's kind of an interesting
new addition that's a JDK seven and it
gets a lot of wow factor with whenever
we do presentations in this area you
would think after sixteen some odd years
that Java was out that we would finally
figure out that strings are literals
especially when we're dealing with
switch cases here and this just makes
the code much easier to write but not
only does it make the code easier to
read and to write but it also makes it
more efficient it's a much more
efficient byte code than if we were just
doing if-then-else statements and
certainly uh you know much more
productive especially if we're dealing
with several thousands of these in this
particular case we would only have 12
but even with 12 there's there some
performance improvements that we would
see there turning down to the next one
which is automatic resource management
so one of the problems that you would
have we really want to copy from one
byte buffer to another byte buffer you
can see the simple code which is
included right in this area here and
that's basically all that we really want
to do but in order to handle that before
JDK seven came along we probably had to
create almost five to ten times that
amount of code to be able to handle that
and so what we've added now is this new
try with resources and as we kind of say
automatic resource management put in the
new try block say the input stream is
this the output stream is that and then
they'll automatically be closed for us
and that auto closeable is something
that was a new super interface it was
added it they went back and actually
retrofitted all of the JDK to where that
could be included in fact is even things
like JDBC for that one were included
either you could use that if you want to
as well and the great advantage to you
there now suppress exceptions is an
output of some of the stuff that comes
with that automatic resources because
what would happen if you had you were
you had a problem with closing in and
you had a problem with closing out and
the previous thing that we saw there
and so the suppressed exceptions means
that even if you get two types of errors
it will show up you'll be able to get
both of them now and and that's
something that we weren't being able to
track before because we can only tell if
there was one error that had occurred
and and now you'll be able to find out
which ones are suppressed you could
return the throwable of those or you can
add suppress to a throwable multi catch
so try with multi catch is a really nice
new addition in it makes it a lot easier
to understand the code we don't have to
clutter it up as much in this particular
case in the first catch we're going to
do a class cast a class cast exception
on e and we'll do something clever but
for the rest of them in the stands he
issued exception or no such method
exception or an invocation target
exception if we're doing a generic
action in this case just logging E and
then throwing E we could use all three
of those and and what's nice about this
is what he is going to throw is either
an instantiation exception you know such
Buffett nothing exception or an
invocation target exception so it's a
nice new feature then it's come in will
reduce the amount of code that you had
before it is simple addition they're now
more precise we throw prior to Java
seven if we look at this this code that
we have here so throws we have probably
public foo string bar throwing the first
exception or the sex exception
try sub code they throw both up first to
the second exception so you know prior
to JDK 7 that this code certainly
wouldn't compile at all
the types of the throw would have to
match the types of the catch and and foo
would would have to throw an exception
it can't throw a specific first or
second exception so now because we could
catch that either first or second
exception we could just say hey catch
the exception throw the exception and
you tell me what it's going to be on the
back side so you know JDK 7 added
support for this as long as the try
blocks all exceptions all
the exceptions are in the throws Clause
but you know take a look at it give it a
try
diamonds operators so diamond operators
are nice piece here it took me a while
to be able to figure out why they call
it diamonds and obviously because it
looks like a diamond and what we're
doing here is is using the left hand
side of the operator to equal what's of
the right hand side of the operator so
we should only have to define this once
this especially useful you know when
we're trying to go through and and we
have these log definitions or we have to
make changes it makes it much easier in
this environment now this is not simply
a you know look it's more complex than
just having the compiler perform some
string substitutions for certain cases
the type inserted is not represented by
the string in the variable declarations
wildcards or maybe a good example of
that and the cat the compiler has to
infer the type parameter for the
information from the type parameter of
the variable declaration so there's a
lot of stuff that happens into the cover
with the diamond operators finally the
last one that we have here is the VAR
our warnings in erasure so let's take a
look at this code a little closely and
as we get it unchecked generic array
warning there's a heavy use of static
method as lists from arrays class
defined as a public static list as list
and it returns a fixed size list backed
by a specified array now let's go back
to this code here and take a look at it
we're defining two months in two
languages one of them in English one of
them in Italian and they're returning a
list of the strings now of course what
we call a raises list with January in
February in this case it seems to be an
array as a list of a list of strings of
a list of strings and we expect to get a
result of a list of a list of strings
and that's that's what's expected based
upon our type of definition here so why
are we getting this warning well what's
what's happening is this generic type is
it CH eiated in Java and the
be back up here for a second so you can
take a look at this yeah this generic
type is a Sienna driver the compiler
removes all the information related to
the type parameters the type arguments
within the class of the method and what
this happens it was primarily done to be
teed but binary compatibility you know
before we actually had generics but you
know basically what's happening here is
we're expecting to return a list of a
list of question marks and what happens
is we lose the street definition to
there so if we want to get around this
the way we could do that is use suppress
warnings or we could use safe varargs
and I thought it was kind of cute when I
was interviewing Joe Darcy oh this are
actually when he was doing his Christmas
greeting he said they all your varargs
be safe well that's all that we have for
this particular session of these 55 when
we get back next time in the next
production that we're going to do this
will probably cover nao - and we then
will continue I do some stuff with
concurrency API s and then look at a
variety of smaller type of changes that
got into the JDK 7</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>