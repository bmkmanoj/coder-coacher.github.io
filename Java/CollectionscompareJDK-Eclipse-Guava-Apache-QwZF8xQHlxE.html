<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Collections.compare:JDK, Eclipse, Guava, Apache | Coder Coacher - Coaching Coders</title><meta content="Collections.compare:JDK, Eclipse, Guava, Apache - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Collections.compare:JDK, Eclipse, Guava, Apache</b></h2><h5 class="post__date">2017-10-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/QwZF8xQHlxE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi thank you everyone for coming to our
come elections compare talk and it's a
interactive session if you don't like to
ask questions please do otherwise just
speaking long enough that we can repeat
it back is being retype it okay and I'll
briefly talk about our guests our
speakers first you know for medical
order don't not please
hey so I welcome everyone my name is
Donald robb
I'm a managing director at Bank of New
York Mellon based in Jersey City New
Jersey for those that don't know me I am
the creator of a little framework called
Eclipse collections which means this
talk will be completely unbiased also as
a member of the jsr 3:35 expert group
which you know was the thing that got
lambdas and streams into a Java and I've
been at various conferences this is my
fourth Java one speaking I've been at
devoxx jvm language summit did so on and
so forth so yeah I'm Leonard Lima and I
work at Viacom it's a company I'm
Brazilian company that does induce rely
or tea and I'm currently living in
Austin Texas
and I was awesome and and I am currently
the CTO at Viacom where I let the
software development and that's how we
got these talks started was they trying
to say well you should use our framework
and I said why and then you compare
collections that's how we got started
so my company's also representative at
the GCP Executive Committee and I did
lead a GSR 363 units of measurement hi
I'm Nicole Nani Radhika I'm a vice
president at Goldman Sachs I'm based out
of Salt Lake City and by academic
education a master's in mechanical
engineering are actually not written
even HelloWorld in Java till July 3rd
2012 July 2nd 2012 was my first day at
Goldman so that's my journey starting
March of 2017 I started owning Eclipse
collections the big framework which he
created so now it's pretty much my
responsibility to make sure I only merge
those things which make sense
for the framework and that's the reason
why all three of us are here because Lee
leo comes from a background where he he
does not want to use Eclipse collections
we want him to use Eclipse collections
and then it ends up happening where he's
showing us what all things are available
in other frameworks all right and that
ends up like sort of having a nice a
symbiotic relationship I should say
where we are looking at other frameworks
and actually comparing and that led to
this talk yep so again my background is
you have a developer have been
developing for 12 years more than him
less than him and I've been using Java
YouTube collections for forever and ever
since they come out and so I always use
it and I I don't know about you but I
like my projects to have as little
dependencies as possible it's less code
to worry about so I said well what's
available on the w2 collections and and
it's been around for a while so it since
98 and with a very basic but critical
support for collections and it has kind
of two main interfaces Maps and
collections so there are different trees
on this implementation collection this
is everything but maps so lists at qdq
or they are all collections and they
implement in collection interface and
maps are just Maps Cheryl the JDK
provides a bunch of basic
implementations of these interfaces and
they when Java 5 came out with
concurrency it they released the
concurrent versions of them as well so
you can use them on a concurrent code
and they do have some algorithms for
doing basic stuff with all with a
collection so like sorting shuffling
data manipulation like adding removing
searching and all that stuff and some
people are really new to the language
and that's like if not the first the
second thing you should do after hello
world is to work with a collection and
they have very good tutorials on Java
website on Oracle and here we have links
for their simple in the concurrent
tutorials and I think I think it's very
nice to show how the collections
framework evolved since it was launched
so that we can see where it were
war and how stuff evolved over time so
again um almost twenty years of
evolution and you can see that from java
to java v so from 98 to 2005 not much
has changed but then java 5 came with
generics in for loops sorry for each
loops and and that that brought that
brought a lot of improvement on code
readability and
doing more with your collections than
you thought it was possible with the
generics you didn't have to do so much
casting and and they added some
concurrency utilities as well so it was
a huge improvement that i saw and when i
when i my reason to move java 5 was
generics and i loved it and i stayed
forever there it was like really good
and then on java 6 they added more a
little bit more stuff and then java 7
not so much and then Java 8 was like
them another major overhaul so it took
like seven years from Java to 2:05 or
more seven years in like nine years to
to get lambdas and method the references
and a bunch of other extreme interfaces
which I guess you all if you didn't see
last years in the years before Java ones
there's a lot of string talks and how to
use streams on this on this libraries oh
sorry in these interfaces and in 2009 oh
sorry in Java 9 2017 D launched more
even more stuff on the API so I saw huge
line on immutable collections for 4h
overnight and this is something we're
gonna talk about in this talk and still
they are not as as wide-reaching as
possible and i'll show you how the needs
of why i use something that is not Java
you to collections so for example
sometimes you're comparing things and
you want to have them sorted by their
name so if you have people and have you
want to tell you how many people's are
with the same first-name and then you
want to iterate over the people with the
same name to show their last names and
then we'll do a very nice table how do
you do this in
in Java you to collections you have to
have a map string of list or offset of
string again or off object and as you do
these more and more and more you get a
very long bunch of diamond operators all
around and that's really not glean and
another collection is you have multi map
that's what that's why when they said
hey you should use our collections as
well how do you guys handle multi maps I
know that Apache Commons collections
which is the other row library that I
usually go to they have that and so
that's how we got started talking about
so what are the other collections
available what what else is out there
that people can use with Java 5 6 8 9
that that can be used to address the
collections needs and I think that's we
chose for I think these are more for the
for more columns and we compared to Java
8 collections we didn't had time slash
experience on the Java 9 collections to
do a proper work of updating this
presentation to G over 9 but Java 8
besides Java we have a partial comical
actions currently on version 401 that's
what I used most outside of Java Eclipse
collections that was before
Goldman Sachs collections that's how
that's why Nikki was taking care of it
and formerly Don was working with him
and he brought it to the open source
which is really nice move and Google
guavas Google guava new offer who rather
roll I didn't even know if I say it
right but it was Java slang before they
both have collections frameworks they do
other things not just collections but
they do have certain collections so
sometimes I was using guava for
something else and I needed a multi map
boom there it was already you don't have
to bring Commons collections just for a
multi map so again we're gonna have this
posted and this has very good links to
their user guided documentation and I
think that's one thing you have to
consider if you're looking for something
that doesn't have a good good
documentation you should steer away
because it means normally that no one is
using
and I think these guys and all these
others are using a very good job in
maintaining their documentation and I
think you wanna explain out is how
evolution I think you're the best guy to
to talk about this so I come down here
join you all done here
so if you look since you know Java 2
came out and we first got the Java util
collections library initially in the
space she had Java collections and then
had Apache Commons but if you
fast-forward through the the last you
know almost 20 years what you see is
that there's a lot more stuff going on
in the collection space right and really
since Java 8 coming out with the
addition of lambdas now there's the
ability to do a lot more interesting
things right and you're seeing I think a
kind of a revival in the collection
space in terms of functionality that's
available so you know all the way you
know since Java 9 has been released if
you look this year in 2017 you've got
you know two new virtually three new
versions of guava you've got three new
versions of Eclipse collections you've
got now Java slang has become become
Vava and you've got volver point you
know point nine and actually they're
working on I think a current the current
snapshot of Apache Commons you know 4.2
actually there's work actually going on
there so you've seen this increase in
the space and two you know Leo's point
there's there's a lot going on there and
there's a lot that of stuff that's not
available in the JDK collections today
and other you know things are providing
those types of features so what we're
gonna do today is actually take these
five different frameworks so Apache
Commons guava Eclipse collections Volvo
and Java eight streams and actually do a
comparison and the domain that we're
going to use during this comparison it's
pretty simple it's a deck of cards so we
have a card everybody know deck of cards
like playing cards if I go fish or you
know solitaire or any other game so so
what do you have in the domain you have
and this is the common part that domains
on the bottom you have card every card
has a rank in a suit so rank is like you
know ace through ace through King and
the suit is a you know spades clubs
arts and construction of cards is pretty
simple it's actually just the Cartesian
product of those two things right and
it's interesting one thing I like to say
usually is you see I came down off of
the stage it's very apropos to this
domain I was shuffling the collection of
speakers that we have right okay I'm
sorry
uh-huh so anyways I digress
so the problem statement we're going to
talk about today we have a bunch of
different operations that we're gonna
actually use and if you look in the the
deck of cards itself the thing that's
going to change between the frameworks
we're gonna have store the cards as an
immutable list and then we're actually
going to group the cards into an
immutable list multi map
now if framework has the types we're
going to use them if not we're going to
simulate them with the types that are
available in the framework so the first
thing we actually have to do is create
the deck of cards and I said before
creating a deck of cards is easy we have
an enum of rank and an enum of suit we
just have to do the Cartesian product of
those things so we're going to show you
what that looks like
once that's done we're gonna store it
into an immutable list then we're gonna
group the cards into an immutable list
multi map then we're gonna do different
operations we want to get the number of
cards by by rank and by suit and we're
gonna return those either as a multi set
or bag depending on the types available
in the frameworks that we're using and
then we're gonna deal the cards now to
deal the cards we have to shuffle them
first and then we're gonna deal the
cards out of the deck and we're going to
return the cards as an immutable list of
assets five cards each okay so on this
slide what you see is what the
definition of each of the deck of cards
are so once again I told you like you
have the common domain of card rank suit
that doesn't change the only thing that
changes is the deck of cards so we have
starting with JDK you see we have the
definition of JDK deck of cards we
define a list and then we have card and
then we have a map of suit to list of
card right so that's what we're gonna do
our grouping for Apache Commons we've
got a list of card and then petty
Commons actually has a multi map so
we're going to use the multi valued map
from suit to card
with the clips collections there's an
immutable list and there's an immutable
list multi map so we're going to use
those types
similarly in guava they have an
immutable list they have an immutable
list multi map we're just gonna use
those types with Volvo we're going to
list and map there's no multi map type
what's interesting is in the case of
both JDK 8 and Apache Commons you see
with the list interface we don't have an
immutable list in either of these
frameworks so we have to actually we're
gonna simulate it via unmodifiable
collections right so we're gonna
actually create something in a rapid as
I'm modifiable and evolve are the types
that you see here list and map these are
not the JDK types so they have the same
name but they're actually the Vava types
they are immutable by default so there's
no immutable in the name but they're
actually both immutable types so first
thing we're going to do the Cartesian
product so as I was working through this
code and it's funny because we've
actually given this talk now I think
this is the third conference the first
two times that we gave it we used a
completely different set of data
structures we used a mutable sorted set
an immutable sorted set multi map so we
wanted to try it out and see like hey if
we try change it to a mutable list what
its gonna look like
now as I was working through solutions
on this stuff what I realized when I was
doing the Cartesian product first thing
was I realized hey its Cartesian product
so I can you know I should actually use
that and then what I realize is there's
this common code that I can actually put
in one place and share across a bunch of
the solutions so what I did was on the
card class itself there's a stream cards
method which I then call another method
on a card called Cartesian product and I
take an enum set of ranks so both of
these are enums so I take any number of
the ranks enum of the set of the suits
and then I actually implement Cartesian
product here so this is what a Cartesian
product implementation looks like you
basically do flat map with map right
once we do this when I call stream cards
I'm going to get a stream of cards out
and then I actually have to put that
into an immutable list with Eclipse
collections we actually have a Cartesian
product method and actually this is a
more recent version of that where our
old Cartesian product used to return a
pair object right and I wanted to
actually make that flexible enough so I
could actually return the type I wanted
so actually now have a Cartesian
product that takes a function so we just
use that with Eclipse collection so I
can say like you know card new the
method referent or constructor
references are going to get mapped to a
function and then I can just call
Cartesian product here we were ordered
so it has to go through the Mike sir
sorry sir and I think this and if she
said like now we have it and that's
because of us as is like we were talking
and we were evolving the API and that's
what I like about open source project
that everyone can get started and using
and it's a really good way of you
helping open-source developers is to
give them use cases so if I never
contributed one line of code to eclipse
collections but I help them give him
like use cases and how do we do this and
let's move change the commentation to
show better how to do that so I think
that's that's a really good thing that
people don't normally say and you get to
learn and work with people that you
would never work together and like be
where they work in banks and I work in
IOT so has nothing to do but we are
working and learning with each other on
this project so I think it's really nice
and if you guys are not involved into
any open source project even just
reading the commentation and give in
trying to your use case you should okay
so we're gonna well while going through
the slides of collections compare we're
not only going to compare the way the
code looks like but we want to have some
metrics around it and we're going to
look at two basic basic metrics one of
the jmh metrics and the other ones are
memory tests so looking at the
performance benchmarks it's Java micro
harness it's it's available in the open
JDK and what jmh does is it you have a
few options in which you can run your
benchmarks and you can either run it as
operations per second or you can run it
as second power operation so I mean if
you want to run it as operations per
second you can
you can be rest assured that hey the
higher the better so basically if the
number is higher that means that
particular collection is better and it's
very important for any benchmark
especially a performance benchmark to
know on which machine it has run so we
tried to keep it on that exact same
machine which was my laptop and it's a
four core Intel i7 and we ran it with 50
warm-up iterations and 30 measurement
iterations on three folks so it was
basically 90 iterations on which these
numbers are based on so the the next
metric which you're going to look at is
the memory test as a part of JDK 8 we
have an internal class in nation' called
as object size called calculator the
object size calculator gives you the
size of the complete object so if you
have a list or a map then it will also
have the memory of the objects or the
elements contained inside that list so
part of the thing which we are doing in
the memory test is we we take that size
and then we subtract the size of those
particular elements so that all the
sizes that you will see up there are of
the data structure I'm right now we're
actually including the cards okay so
they're using the same object so it's
apples to apples comparison so for
memory tests it's smaller numbers the
better because you want to use less
memory and we test the size of the data
structures created in each code example
so looking at the actual metrics so the
first one was immutable list so this was
for the the group the create the deck of
cards the Cartesian products operation
so you can see in an alphabetical order
from left to right you have Apache to
our and all the frameworks are pretty
much comparable but Eclipse collections
is about 235,000 operations per second
so it's it's slightly edging up but it's
it's not like a very significant change
and partly one of the reasons for that
is whenever we create an immutable list
in Eclipse collections you have to first
go from the mutable side to the
immutable side and let me just
say something with these performances
that we're showing as well when you see
something that shows 187,000 you know
operations per second it this is
obviously not going to be in a common
use case you're looking at you know base
I would say base decisions for your
application on right that's a lot of
operations per second right this is all
in memory this is never likely to be a
bottleneck for you right so the
differences they're interesting to look
at but I wouldn't say like you know hey
I have to use that because my code will
somehow go faster this may not have any
impact you at all so then this is
something which will definitely have an
impact on you so it's the memory use it
so you can see that from left to right
again it's Apache two-hour and I'll keep
on reminding that on memory side on the
memory test the smaller numbers the
better on jmh test the higher numbers
the better so it's like inverse this is
the memory side so the lower numbers the
better you can see that Eclipse
collections and guava are pretty much at
par at about at exactly at two hundred
and seventy six two hundred two thousand
seven hundred and seventy-six bytes for
the whole the whole deck of cards but
the the salient point is we are not
starting at zero because we need to make
it comparable so it started at
twenty-seven hundred so it's not I mean
they are like they have an advantage but
again not that big of an advantage and
we'll see why in the subsequent slides
yes what I'm gonna do now is actually
show you the code that you have to write
to do both operations doing the
Cartesian product into an immutable list
and actually then doing the group by
first thing we're going to look at JDK
and zoom in on the code that we actually
have to use just to create the immutable
list so we're gonna do is we're going to
initialize the cards variable by calling
card stream cards so that gives us that
stream of cards you know doing the
Cartesian product and we're going to
sort it so each card actually has a it
defines a comparator is implements
comparable so it'll get sorted in the
right order and then we can actually
call collect and we use a collector to
list and then we're actually wrapping
this with a modifiable list to make it
effectively immutable what's interesting
is I've tried this a number of different
ways you can actually try and use like
collectors with collecting and then and
it works and actually looks kind of more
fluent but it actually winds up being a
little bit Messier on the screen so I
went with basically the simplest thing I
could show here which was actually doing
the wrapping on the outside with Apache
Commons
collections similarly we're going to use
the stream cards and I'll zoom in and
sort them and we use the same collectors
to list from the gatk
patchy Commons has a classical list
utils and we're going to call this
details on modifiable list to actually
wrap wrap the list to get you know
pseudo immutability with the clips
collections a set of calling stream
cards are now going to call lazy cards
so lazy cards gives us a lazy iterable
and then what we can do on that is use
the API for two sorted lists so we've
now got a sorted list that's mutable and
we call two immutable and now we have an
immutable list getting stored into cards
with guava if we zoom in we get the
stream cards we then call sorted on the
stream and then there's a special
collector that guava gives you on a
mutable list the class there's actually
two immutable lists so you can do sorted
dot collect and then you know passing a
mutable list to to a mutable list with
Vava we zoom in we're taking the same
stream cards and then we call sort it
again and then Vava also has its own
collector on its list class which can
call list collector and that actually
gives you the immutable list okay so
that was how we create the immutable
list right pretty simple
okay next thing we're going to do is
group the cards by suit in an immutable
list multi map so first I want to
explain what exactly a multi map is so
like Leo mentioned before a party hard
it's multi maps and everything so
basically a multi map is a multivalued
map so it's gonna have one key and it's
gonna have a collection of values a
normal map is gonna have one key and one
values one value but a multi map is
where it has multiple values or there by
the name so if you look at the group by
operations
you can see that to get a particular
multi map you're essentially grouping by
the key that's why we're mentioning this
to be a group by and you can see that in
a performance test the higher the better
so you can see that wah-wah is oh sorry
the JDK is the clear winner and partly
the reason for that is JDK does not have
an immutable multi map so and we will
see much more in in detail in the in the
codecs whereas as opposed to the Eclipse
collections as well as guava have their
multi Maps so does I think so so does
Apache and if you see again the the the
performance metrics are like JDK blows
through the charts I mean they pretty
much just go through it and that's
partly the reason because of the
immutability aspect of it but if you
compare with the actual space used then
again all the frameworks are pretty much
compatible so all I'm trying to say out
here is if you're looking for an
immutable a really really immutable
multi map then you have to be cognizant
about both besides the performance as
well as the memory to memory side on the
memory side it's pretty much comparable
out there for okay so now we're gonna
focus on what the group by code looks
like right so once again we're trying to
create an immutable list multi map and
since we don't have that type available
in the JDK
we have to make sure that when we create
the map with the lists that the map is
both unmodifiable and the lists are
unmodifiable right so we take we take
the cards we then and you can see we're
using the collectors collecting and then
here so we do a grouping by we group by
suit and then we map you know based on
identity and have to do collectors
collecting and then create the list and
actually make sure that each individual
list inside gets wrapped in a none
modifiable list and then that final
collecting and then this is where I told
you before I use that remember I used
collectors unmodifiable arts art
collections that I'm not a fiber list I
could have done that with unmodifiable
map but I wanted to show you like this
is what
collecting and then looks like right so
you got those two options either I could
have wrapped the whole thing in a call
to collections done find a file map or I
can use the collecting in them which
does it as well
and I could have zoomed in here but it's
funny because on this page it doesn't
actually get you know much bigger on the
slides it doesn't really help with
Apache collections what we actually get
to do is we create a yes we're gonna go
back okay we got a stream of cards first
thing we had to do is say collecting in
them which means we're going to collect
something and then we're going to do
something to it after we collect it
right that thing that what we're going
to do is first we're gonna do a group by
right so we're effectively going to
create a map of you know lists the keys
in the map are going to be the suits
lists are gonna be the cards for that
suit and what we're gonna make sure is
that when we're collecting up those
lists yes and the face that you're
making is exactly the face you should be
making he likes to be responsive this
slide yeah so the the point is they make
to me is that this is long and is is
hiding some some implementation or
characteristics from the interface or
actually the other way around it's
exposing stuff there so it's not really
beautiful I like because even though you
have a mood a modifiable list you get a
list that has an ADD method yeah you
don't want to return a non-modifiable
map that has mutable lists in it right
because then it's really not immutable
right yeah really complicated to do like
this is the case where because you don't
have a data structure and you try and do
things through algorithms it becomes
more complicated right it would have
been better served via data structure
and one more thing to add about the
unmodifiable aspect of it is whenever
you are doing something unmodifiable
versus immutable it's different if
you're going from an from a mutable side
to the immutable side then that's always
an O in operation because you have to
make sure you have a copy of the
immutable because an immutable list or
an immutable collection is has to
maintain its state all over the place as
opposed to unmodifiable where you just
add a wrapper on it and then all it's
going to do is for all mutating
operation it's going to go and throw
grunting so you're comparing oh one
versus Oh n and that clearly shows in
the performance benchmarks
okay so fast forwarding to Apache common
so they do have a data structure here
right and it's interesting because the
list valued map that we created here
using multi map utils is a mutable multi
map and then we iterate over the cards
just using for each calling put into the
multi map so put on a multi map has the
effect of finding the key in the multi
map and basically adding to the list
that's at that key but then there's a
utility class and Apache Commons called
multi map utils and we can actually wrap
the whole multi map in and unmodifiable
you know multi value map which is a
little bit less complex than what we had
before still taking something that's
model you know mutable and then making
it immutable at the end so the clips
collections since we have an API for
group by and since all of our methods
are covariant we on an immutable list a
group by will we return an immutable
list multi map so we just have to say
cards group by card get suit we get back
the immutable list multi map do you want
me to explain this that's like the
selling points like you its if you need
something that it's not there we put it
there and then use it and reuse it
please remember this was this was faster
this was faster I ran you last time this
was slower but it wasn't slower for me
to write right yeah okay Google guava so
in guava there's a class called multi
maps which has an index and this returns
a very specific size and this is the
downside of using static utility you can
only return one type out of here our
group by is covariant so it's based on
the type you're eating over index always
returns a mutable list multi map but it
works well here so I can use multi maps
index takes an iterable which we just
passed in cards and then we do card suit
and it's nice and simple and it is
amitabh alyssum all team up with Volvo
similar to eclipse collections bobbers
group by actually returns an immutable
map it's not a multi map but gives us
the same effect so I can just say cards
group by card get suit so in the
interest of time
is gonna breeze through this one because
this is like one one shot where you're
seeing on the left is the deck of cards
so that's actually when you sort of
superimpose do some math you end of the
two things on the right you'll get that
but no we actually ran the test so
there's no math involved in there it's
what the the actual performance tests
look like so you can see that all of
them on the left to create a deck of
card is the sum total is same all right
but if you look at the immutable list
and the group when I say same it's
similar if you look at immutable list
and group by however the JDK is breezing
through but it gets compensated because
of the immutable list again you're
looking at modifiable versus immutable
so keep that in mind it's Oh n vs o one
and we're gonna again the memory is
comparable and one of the reasons why
our has the highest memory usages
because of the way they're immutable
lists are implemented because they're
linked lists at underneath the covers
yeah now obviously these numbers aren't
interesting from your application
perspective but if you consider the deck
of cards as maybe something that would
be represented in your domain maybe you
know customer order and you've had
millions of those things right what you
can see then is that you know what is
now measured in bytes on these slides
could be measured in either megabytes or
you know if yet enough of them could be
a you know who knows gigabytes right
okay next thing we're gonna do is get
the number of cards so there should be a
little bit easier we're gonna count by
suit and count by rank so we have the
basic concept called as a multi set or a
bag so what that means is if you have
one element then how many of those
elements are are there in that
particular collection so for Eclipse
collections we have something called as
a bag a patch a has a multi set and the
bag
they're basically the same thing Wow
guava has a multi set though the
difference between each of these is our
bag is actually implemented underneath
the covers as a primitive map so it's an
object in map and if you look at the
that's that's one of the reasons why the
the way we created we pretty much are
really fast but that's really really
significant or it's apparent when you
see the memory test now these are
starting at zero okay so for the whole
guns by suit for all our suits which are
there you end up getting the memory
consumption to be just 408 bytes for
eclipse collections and the JDK and
wahwah are at par and Apache and guava
are pretty much at par as well then
counts by rank so again same thing
underneath it's the multi set and the
back difference but the difference
between counts by suit and count by rank
are the number of keys that you will
have so that ends up impacting the
performance test and more so it it is
very apparent on the memory test but
again because Eclipse callenge Eclipse
collections is bags are underneath an
object in trap we end up saving the most
memory okay so I want to serve the code
for these you know performance stats and
what you see is if we want to count by
suit count by rank with the JDK what we
do is we take the cards we called that
stream we're then gonna call the collect
method on stream and use collectors
grouping by collectors counting and
we've seen this code before well that's
the first time okay this is Oh Maurice
you've seen this code before you've
probably given you know this code in
talks before right maybe not with cards
so anyways this is how you actually you
know count something right if you want
to count them by a particular key so
here we're coming the cards by the suit
and we get back a map of suit too long
right
same thing for kind of a rank we still
call the stream collect collectors
grouping by use the different key we're
gonna use card get rank and then
collectors counting with Apache
collections kind of interesting Apache
collections has both the bag and a
multiset they are the same thing right
just two different names it historically
had bagged multi stet was introduced
more recent I think since versions four
so it's kind of surprised to find it so
in this case I used both because they
were both there hey you know I like one
I like the other I like both
right so what we're doing though here as
we stream we then map the attribute
either gets suit or get rank and then we
collect into the target collection
either the hash bag or the hash multiset
this is going to have the effect as
we're adding into a hash multicenter bag
the the data structure itself keeps
track of the counts internally so we
don't actually have to specify the
algorithm like we did with collectors
grouping by collectors counting with the
clips collections and this is a new API
into the LEAs point before it you know
as I was writing these you know this
talk for dev ox I was like seeing I was
like you know I'd really be nice if we
had a method called count buy because
when I show people that you have to use
as lazy collect back to bag what's as
lazy what's collecting what's to bag
right it doesn't make a lot of sense if
you don't know what these things are and
I have to explain them to you
but I can show you mat the count by and
that actually probably conveys a little
bit more meaning as to what's happening
here just a little so we call this stuff
cards count by and specify what we want
to count by and we get back a bag of
soup now you may still ask about well
what's a bag and you can imagine
underneath a bag is a basically map of
suit to sum count or in this case in the
other case bag of rank map of rank to
sum count guava has a multiset they do
not I've also have bags so I only use
multi sub but here same thing I did with
a patch of Commons I ate over the cards
using stream and I collect and guava has
this collector on a class called multi
set so and it's interesting this is one
of the things that as a as the creator
of a collections framework it's kind of
interesting to put on a someone else's
pair of shoes and go into their
collections framework and try and
discover how to use it and it actually
helps you develop a little bit more
sympathy and empathy to developers who
have to try and discover your API right
it's like how do you find this stuff and
where's the documentation and oh my gosh
like nothing's of Allah it's too hard
how can I give up
so anyways I discovered Maltese that's
existed and you can do collect you know
into multi sets to multi set you specify
what you want to effectively count by
and you can actually here specify a
count function as well so I'm just
mapping the element to one I'm counting
by ones and then into hash multi set
Evolver was interesting barber doesn't
have a bag or a multiset and it didn't
really have a good way for me to also do
the work in their own maps so I
basically just delegated out to using a
Java util map now it's interesting you
see the problem here in that I was
coding it in a class where I had a map
that was Volvos on a map that was java's
and now I have to basically solve the
problem of two things with the same name
and I have to use packages in the names
on the on these methods but guava
I'm sorry Vava has a method called
collect directly on their type and what
it is it's a shortcut to get to stream
collect so they give you basically a
shortcut to that right so you know I
don't know if this day this knock card
is that stream collect I can just say
this card's collect pass in a collector
I'm doing the grouping by counting and
this is effectively the same thing that
the JDK and Apache Commons did and now
we're gonna deal some cards do you want
to skip this slide we've just four six
minutes ago okay
dealing cards is fast okay so when we
deal cards what we're gonna do is return
an immutable list of sets of five each
and what you see here is we're gonna
take a stack and in the JDK case we're
using the recommendation for a stack we
actually use a deck loser a deck we're
gonna pass in that deck the number of
hands that we want and the cards per
hand and we're gonna use create an
unmodifiable list wrapped around calling
in stream range map to object we're
basically this is going to give us the
hand each of the hands so we get the set
and then we're gonna actually then
return that as the list wrap doesn't I
modify the list it's a mouthful by the
way all this code is available online
and you can go see it and try it
yourself as well we'll have it at the
link at the end for Apache it's pretty
much the same except for that list utils
thing right with codes collections we
have instead of int stream we have our
own into interval I do one two hand so
this is the number of hands I want it's
one two five then collect up the the
sets of hands that I want so
this deal returns a set and then because
we are collecting over what some
effective Liana mutable int list in the
case of interval that actually winds up
returning and immutable list
automatically with guava similar to the
JDK an Apache except for we use a
different collector we're gonna collect
into the immutable list at the end and
then bobber that's I'm trying it's
interesting bothersome types are by
default immutable and what you see here
is they actually have an immutable stack
and I think actually a bug on our slides
here I should actually change that it
used to be called stack in Java slang
and it has changed to just be list so
--lifts it's immutable and what it means
is we can't actually change it so
imagine you have an immutable stack
right how do you push and pop to it well
every time you do an operation on it
you're gonna have to get a new stack and
the thing that you've popped off right
and that's what you see is actually
happening here every time we do
something we get back a couple two of
the thing that we wanted and you know
then we have to keep you know passing in
a new copy of the stack effectively
right so this was kind of hard to reason
about it first and to think it's like I
just wanted an immutable stack I mean
are mutable stack but uh you know I used
what they had available
yes yes I did that is not that is not my
code so to repeat the question the
question was do they have methods with
underscore in their name yes so topple
to does have an underscore one and
underscore two we have we also have like
a pair we just call it get one get two
but that's a naming convention so they
went with underscore one so okay with
that
we have this comparison table so what
everybody wants to know is like what's
the best framework for me right and of
course the answer is well that depends
what are you looking for right and what
you see is that we tried to weigh things
across the frameworks based on features
that we were thought were interesting
and then we tried to rank what we
thought were for each of those features
the top three so if all you need are
lists set and map JDK is great use it
what what do you need anything for right
it's got a lot of functionality
especially now with streams if you need
bags and multi maps and buy maps well
there are frameworks available that can
give you those right so you've got a
patch you've got guava you know you've
got Eclipse with those things you need
the stack
well you can they use deck if you want
or you know you can use immutable stacks
from bravura or you can use mutable
stacks from Eclipse collections any
trees or tries or tables you know these
are available and you know you know
certain frameworks not available across
the others but if you need things like
immutables and you know primitives and a
really fluent api it really once again
depends on what you're looking for and
you can kind of see like you know what's
available we've kind of ranked we've got
green checkmarks for yes red Xs for no
and then green checkmarks and boxes for
kind of and then the you know orange x's
and the boxes for not really right so
for state check boxes those are awesome
right alright so anyways that's a kind
of the talk week a stick some quick
questions but here's the link to the
source code it's going to check it out
and there's multiple implementations out
there there's the immutable sorted set
implementation which we used in our dev
ox talk and the immutable list one which
we've done today
kind of see like what the code looks
like and you know I would experience you
know say experiment for yourself the
things out there try it for yourself try
different data types if you want to
measure it if the performance is
interesting to you you know you can use
the the jmh benchmarks and you can use
the Nass horn you know object size
calculator if you're curious what the
memory footprint of something is yeah so
including our performance benchmarks our
memory tests everything is out on the
tree people will be pushing these slides
out on the Java one speaker deck as well
so they would be made available as well
along with that we might put them on
SlideShare but if you have any questions
I mean I know we are almost out of time
if you have any questions you can always
tweet to any one of us and we will start
redirecting who is an expert in which
collection or in which framework so to
say and we will be here at JavaOne
downstairs and the developers lounge
area as well as tomorrow around there so
if you have any questions you can just
tackle us and we'll we can talk more
offline and I think you know I like to
echo what Leo said before as well right
all of these frameworks are open-source
if you're going to use them and you like
them you know as someone who you know
maintains an open-source framework I
love when people contribute the things
that they need right yes it'd be great
if I built everything that you needed
for you I've built most of what I needed
but if you have you need something to be
great you know really appreciate
contribution and we're here to help you
do that right it's like you want to do
that we can help you you know in github
you know in terms of doing the coding
getting code reviews and actually
getting your contributions merged into
the repos and contribution is not just
by code if you find a bug or if you want
a feature please do request us because
for Eclipse collections 9.0 we had a ton
of user requests which we ended up
accommodating and uses other than done
so we so we we do look at that and and
we like it when our users tell us to
improve the framework because that's the
we can't reach the whole spectrum of our
own code and do not forget to vote I'm
totally fine if you were down with us
but just come back and tell us why
you're down voting because it will help
us improve our next stop yes again we
won't take it personally
don't worry about it and thanks
everybody for attending how great Java 1
yeah
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>