<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Chops: Recipes for Simpler, More Expressive Code | Coder Coacher - Coaching Coders</title><meta content="Lambda Chops: Recipes for Simpler, More Expressive Code - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lambda Chops: Recipes for Simpler, More Expressive Code</b></h2><h5 class="post__date">2017-10-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bG3VvAUlfL8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay it's a quarter till get started
with these shorter sessions gonna have
to keep moving quickly so going to be
talking today about lambdas and ways
that you can use them to simplify your
code quick agenda so you can decide if
you want to leave right away we'll start
off with a very quick review of lambdas
I'm assuming that most everyone here I'm
hoping everyone here has seen lambdas
worked with them a little bit in Java
eight but we'll do a really quick review
first and then we'll show some neat
tricks you can do with them take a
little bit of time out to talk about how
to deal with checked exceptions and then
talk about some ways that you can take
design patterns and turn them into
library methods and then finally show a
few ways that you can maybe increase the
static type checking of your code add
some type safety using lambdas now I
want to stress that the idea here is not
that you walk away with the specific
techniques I've shown I'm showing
although you're certainly welcome to do
that what I really want you to do is to
get inspired and think about other ways
that as you are doing your daily jobs or
your you know nightly hacking you run
into things and think hey lambdas can
make this better so a quick word about
me I work at myriad genetics where we do
testing of genes to determine a person's
predisposition to getting cancer been
working in java for about 17 years
occasionally I'll tweet occasionally
I'll commit code and occasionally I'll
speak here at JavaOne okay last thing
before we get rolling I want to make it
clear that not necessarily everything
I'm showing you is the most performant
way to do something if you're writing a
real-time life-saving application these
this might not be the right strategy to
use although it may be however in most
situations for example if you're in an
application that also has to talk to a
database or do any other sort of i/o
wait the extra penalty that might be
incurred by using lambdas in these ways
is
going to be miniscule but you know if
you're concerned do some benchmarks
check it out okay so first of all what
are lambdas well they obviously they
were introduced in Java eight they
they're more than just anonymous inner
classes with some syntactic sugar
although if it helps you to think about
them that way go ahead because it'll
give you a reasonably accurate model of
how things end up working out the key is
that they're represented a lambda
expression is represented by a interface
that has exactly one non default method
you can add default methods to the
interface all day long
but it has to have exactly one method to
be introduced otherwise a single lambdas
not going to do the trick wouldn't know
which interface method you're talking
about so in in in full generality they
look like this they say hey I've got a
function from string to integer I take
in a string s and then what do i do I've
got this block of code to get the length
but we can of course you know get rid of
the the string repetition there and we
can for that matter get rid of the curly
braces and the return and and we're
already feeling a little better and then
we realize that S has no purpose being
there so we can just say this so if this
is new to you I apologize the rest of
the talk might be a little bit difficult
to follow okay
most likely when you first saw lambdas
introduced you saw them introduced in
the in the form of streams and you you
probably saw some example like this you
saw yeah let's say I've got a bunch of
employees and I want to find the
salaries of just the engineers and I
want to do it
average by city and so you you write
something like this first I can filter
out my engineers so I'm just looking at
my employees so I'm just looking at
engineers and then I can group by the
employees city and then finally I can
average their salaries up and this is
really nice I mean we're looking at five
lines of code here that in earlier
versions of Java would have taken easily
two to three times as many lines
code now the only on the bright side
though you would have had to write more
code it would have also been harder to
read and so your job security would have
been increased but at least at least now
if we're comfortable with our job
security we can we can be a little bit
more expressive it's also easier to see
whether or not there's bugs and of
course the the original motivation for
adding all of this was to support
parallel processing because there's
nothing in here that can't be done in
parallel should you choose all right so
streams are nice but that's really not
what we're gonna be talking about today
instead I want to talk about some other
ways so first thing null safe navigation
how many of you have ever programmed in
groovy a few so you might recognize what
this is up here it's it sort of looks
like Java code I'm invoking a get
address method but there's that little
question mark in front of the dot and
and then with each subsequent method
chain call there's that question mark
and all that means is please invoke the
method that I'm saying to invoke on the
object that I just mentioned unless that
object happens to be null in which case
never mind just giving me no back and so
the idea is if you're in a space where
where anything might be null and you
need to be careful then you can use this
mode of you know getting data and and
and not worry about getting a null
pointer exception now of course if you
if you haven't or have programmed groovy
but you also like Java you think you
know it's actually not that big of an
advantage because in Java it's pretty
easy I just have to check is the
employee null or not and if if the
employee isn't no oh I should check the
address as well and and then I should
probably check the city of the address
of the employee and and and ok once I've
figured all that out I can actually
safely invoke it and so you know after
you after you write this sort of thing
you get sad and and and you're sad
because I mean you're looking at this
you're there's a lot of repetition
there's of course you know I mean the
more methods you chain it's actually o
of N squared code that you
- right unless you do some other tricks
with temporary variables either way it's
not happy so in Java 8 the first thought
you might have is let's refactor the
domain entirely to use optional anyplace
there could be a null and if you can do
that that's great and that's probably
the best route but if you can't do that
if you are gonna have to deal with the
domain where there can be nulls we can
still use optional or at least maybe
abuse it I haven't quite decided whether
this constitutes an abuse or not but it
sure is convenient and basically what we
do is we use optionals of nullable
method at the start so that that'll
either give me a present optional with
an employee or an empty optional if
employee was null and then we start
indicating which methods to invoke this
is optionals map method which will
invoke the method if it's a present
optional and obviously not if it's an
empty optional and then when we're done
we'll say or else know if that's what
you want you might want to say or else
throw if it's a if it's a big problem
but the idea here is that now we have
type safe navigation and and the reason
this works is because we're no longer
saying okay here's what I want to do
right now I need to call this method
than this method instead we're saying
here are some things I'd like to do but
I'm not going to do them I'm gonna ask
the optional class to do them for me and
it can smartly decide whether or not to
do them and that's kind of be a
recurring theme throughout throughout
this but in any case you know this makes
us happy so so that that's good another
example and I apologize for moving
quickly here with the new 45 minute
length trying to get through everything
if possible another thing sometimes you
have a list of objects and you want to
sort of take the first one that's not
null you know the the first ones better
than the second the second better than
the third but nulls not better than not
null so you know there's various
libraries that can do this commons Lang
is one of them it has an object utils
class which has a first non null method
and it kind of does exactly what you
think it would do it takes in a bunch of
references and says the first one that's
not null that's the one I'm going to
give you back
and if they're all no I'll give you no
back so this is fine as long as all the
data that you're providing or at least
all the data after the first instance
are cheap to provide that it's cheap to
compute ahead of time but that's not
always the case for example if you're
running an e-commerce site and you say
all right well I want to get some
recommendations to the customer to
convince them to buy even more things
they don't need and so the first thing
I'll do is I'll look at what's in their
shopping cart and see if I can get some
recommendations based off of that and if
that doesn't work then let me see if I
can get recommendations based off the
customer history and if that doesn't
work now let me just give up and show
them some of our bestsellers so that's
all nice and good but the problem is
that each of these activities might be
fairly expensive to do and and moreover
I mean if we're trying to sort of
minimize the amount of work we do then
if it turns out the cart was able to
give us recommendations then we wasted
time computing the other things
conversely if it turns out that the cart
recommendation process takes a long time
to come back and say no well then you
know all that time if I wanted to give
my customer a very good experience I
would have been already calculating
other possible sources of
recommendations so with and again the
problem here is that we did all this
work before we call it optional and so
when when you do that in Java a bunch of
arguments it's going to calculate the
arguments values in a defined sequence
so this this you know it makes us sad
but what we can do instead is we can say
all right I want to have first not null
be a method that takes in lambdas in
this case these these would be suppliers
and so now we simply say here's the work
that I want done and I want to get the
first non null thing and this starts to
make a lot more sense because we've got
suppliers we can either say don't do the
work if I don't need to or we can say I
want to paralyze it do it all at the
same time to maximize responsiveness and
the method to do this is is really
straightforward I mean I'm sure there's
a library that has it but it's hardly
worth looking for a library for this
amount of code basically you take the
stream of the values that are passed in
which are really suppliers and then the
first thing you do is you say I want the
I want to invoke the get method and then
I want to filter out the ones that
aren't know and then finally take the
first element and if if nothing's
present then I'll just I'll just return
null and of course because of the way
the streams work if I do this in serial
it's actually not going to do any extra
work beyond what it has to and if I do
it in parallel then everything you know
if fork/join works out the way we want
it and so forth everything can can get
done quickly ok so you know once again
we're happy ok one problem that you can
run into sometimes though one of the
great things I should say about Java is
that with with the introduction of
lambdas any interface that had just a
single method automatically became
eligible to to be lambda eyes or
whatever that word would be but some
methods of course have more than or some
interfaces excuse me have more than one
method that they specify and so if I've
got a something like this you know
there's not really anything I can do I
can't I can't do a lambda expression to
create an instance of this interface but
what you can do is create helper methods
and these helper methods can take in one
or more lambdas and construct an
instance of the interface for you so
that you don't have to go back to the
old days of anonymous inner classes so a
way that such a method might look
one-one sort of full bore examples we
say all right well the the visitor
interface requires the file visitor
interface requires four methods there's
the do I want to recurse into the
directory the pre visit directory then
there's okay here's a file I want to
look at it and then what do I do if I
tried to look at the file and it failed
and what do I do if I try to look at the
directory and it failed and these are
all functions because at each stage you
have
returned constant indicating whether you
want to keep looking at more stuff or
not so if I create a method like this
that you know once you've written the
signature the the of the method the
implementation kind of writes itself
where we know we're gonna need to create
some new say anonymous inner class and
then for the first method you know
pre-visit directory what do I do well
gosh I was just given a path and some
file attributes and I have a lambda
expression which will accept both of
those and it will return whatever I need
to return so just invoke it and the
other four other three methods you do in
exactly the same way except you don't
put them on the slide because they don't
fit so that's nice but it's a lot of
work maybe in your typical use case you
want to just recursively go through an
entire file tree you want to look at
everything and you always want to keep
going and in that case the visit file
method is the only interesting one so
instead we could do something like this
where we just take in a single lambda
expression for the thing we care about
and then the others can have default
behavior it turns out there's a simple
file visitor class that makes it easy to
have default behavior for the methods
that you don't want to override do
something like this so this this is a
nice improvement because you're back in
being able to sort of you know express
yourself functionally there is one
problem hidden in it though and the
problem is that there's a good chance
when someone is given a file or a path
and I apologize that this is a the
generic really almost is always path
when you're when you're given one of
those there's a good chance that you're
going to want to do something that might
involve IO and that means there an IO
exception can be thrown but what we did
before was we were using the standard
Java interfaces in Java util function by
function and all of the interfaces in
Java util the Java util function package
none of them declare that they throw
exceptions and so we're gonna run into
trouble and this is this kind of goes to
a problem that was called accept
and transparency exception transparency
was supposed to work is that you could
do something like this I want to do
something for each file file create a
new file can throw an i/o exception but
that's okay because I say that I can
throw an i/o exception upon upon the
method here so that that's fine that's
great but unfortunately it if you try to
compile it you'll if you write it in
your IDE you'll go to the red squiggly
and it could try to compile it you're
going to get an error because we're
saying we'd like to throw an i/o
exception but it's incompatible with the
lambda the the lambda interface that
we're trying to the functional interface
that we're trying to convert it to and
well gosh that's a real bummer and it
really is a bummer if you've worked with
lambdas much you've probably run into
this problem you're trying to do stream
processing and suddenly you you you run
into this problem and so well the first
thing that you could do is you could oh
I should mention they did try to fix
this but tight theories hard and it's
especially hard with exceptions because
they're neither covariant nor
contravariant and they're a union type
really because you could throw perhaps
either an i/o exception or an
interrupted exception and it's
fascinating to read through the list of
the mailing lists to see how they they
tried to solve this and in the end it
just really was not going to happen so
what are we gonna do well one thing that
we can do is is we can just say well
we'll catch the exception in our lambda
expression and if we get it we'll
convert it to a runtime exception
standard trick that you know you see
pepper it all throughout java whenever
you have checked exceptions i don't know
about you but i don't feel so good about
this
this took my one-liner and blew it up
into a I don't know seven eight liner
it's got a whole bunch of stuff that I
don't care about it you know somewhere
buried in there is my create new file
call but everything else is is just it's
just making me miserable so you start
thinking well that's unfortunate and and
then the next thing you think is well
maybe they didn't try hard enough on the
exception transparency from what if we
use generics
so we say hey instead of using consumer
let's try an e consumer that can throw
some exception type e and while you
can't catch a generic exception type
you're certainly allowed to declare that
you throw it so this works out and then
we could even imagine hey if Java had
done this in some sort of bizarro job
and then the iterable interface instead
of having a for each method taking a
consumer it could have taken an e
consumer and then everything would have
just worked out the way that we want it
to and and the funny thing is that this
actually works but it you'll you'll
notice right away the signature for each
just got a little bit more confusing
because I suddenly have to put in this
extra generic parameter information but
you know on the whole I mean it does
work it doesn't work if you have more
than one type of exception that you need
to be able to declare that you throw you
can try making your your thing generic
and two parameters and type inference
will just bail out on you completely and
so that that's not happy and and and and
generally in the end you just decide
it's it's probably not worth it and and
so you're sad and then you think you
know why am i sad I'm sad because of
checked exceptions and now you think
gosh checked exceptions and and how
you're angry and and when we're angry we
sometimes do rash things and one of
those rash things can be just to get rid
of the problem and the solution is to
just get rid of the problem so there are
multiple libraries that can that do this
I like the the Juke lambda library or
just the jewel library you can call it
what they've done is for every
functional interface and the java.util
function package they've created a
companion interface with the name
checked preceding it and that companion
interface has the same method but it's
allowed to throw any throwable and then
they've provided a series of static
methods that will take in a for example
a checked consumer and it will invoke
the checks consumer and if any exception
gets thrown it'll free throw that as a
run a runtime exception otherwise just
carries
and so what this means is that now you
can write code like the following and
all I have to do is say unchecked
consumer and surround my lambda
expression with that and I'm back to -
you know where I can actually use things
now it's a little bit problematic
because I I'm no longer actually
throwing or declared to throw it an i/o
exception I mean I could say that I do
but I don't really anymore and so that's
that's a problem unless you want to
catch it and reconvert it so you know if
you think that there's a value in
checked exceptions then that that's not
so great and it's also a little more
verbose so maybe not happy but at least
you know we're no longer sad we're kind
of ok next thing I want to talk about is
design patterns so what's a design
pattern if you go to Wikipedia it says
gosh it's a general repeatable solution
to a commonly occurring problem Wow it's
it's general it's it's a solution that
sounds great and and it's for things
that commonly happen what's what what's
not to like Stewart Holloway on the
other hand says it's a code smell they
tend to point to deficiencies in the
language and the reason it's a smell is
because of the third word and the
definition repeatable when you do a
design pattern you are repeating some
code that someone else has done and
you're repeating it over and over again
a lot of the patterns are of the form
here right this boilerplate code then do
the thing you actually want to do and
then write some more boilerplate code
and if you look at this with lambdas in
mind you think ah I think we've got a
solution
so show a couple examples first pattern
resource management sometimes called the
dispose patterns so back in the days of
Java 6 or earlier whenever you want it
to deal with say an input stream you had
to go through all this work you had to
first get it and then you had to do a
try block and then remember to close in
the finally block not in the try block
because you're not guaranteed you get to
the close statement otherwise you have
resource leaks and then everyone's
unhappy and so ok that that was bad and
in an attempt to both make this problem
less painful and also forestall the
introduction of
lambdas into the language josh bloch
said well why don't we why don't we have
the new try with finally our issues to
try with resources syntax and so this
gets a lot better in Java 7 when I do
this I don't need to worry about closing
the stream at all but there's a problem
and that is well I don't know about you
but I'm getting old and forgetful and so
I just might write something like this
where I simply say hey let me just pass
open stream into process and and and be
done with it but now I'm not closing it
and I've got a resource leak and it's a
poor API that lets people make mistakes
so let's look I mean that that that's
not good and there there's actually
another problem too which is that this
whole language thing that was introduced
only works if you implement Auto
closable so for example if I'd want to
use it for managing a lock I'm dealing
with some bank account and I need to
make sure that I'm exclusively accessing
it while I well I mess with it and I say
hey let's let's use try with resources
for this and I am told that lock cannot
be converted to auto closeable which
means that this language feature that
was introduced to help doesn't help me
and so I'm sad but if you stop and think
about this really even this was
problematic because not only could I
forget to close the lock I in some sense
you shouldn't be able to get a hold of
an account and do something with it
unless it's safe to access it and so
maybe instead of thinking about locks
all the time
let's let's have someone else manage
that for us and we get something like
this we say ok here's an account manager
class and there's a lock inside and
there's an account inside but note
they're private the public thing that we
offer the API that we offer is the
ability to work with the account and
this API will handle getting the lock
and then doing the work that is
specified and then finally unlocking you
can do exactly the same sort of thing
with with the iostream example from
earlier
you've and this has actually been done I
mean hibernates done this in the session
API if you want to get the underlying
sequel connection you do something
similar to this sort of trick and the
code now that I write actually looks
really sweet because I just have to say
what I want to do I want to work with
the account and what do I want to do I
want to debit much more expressive much
less error-prone everything's nice we're
happy okay so you know we're so happy we
think gosh maybe I'd like to take a
break because I'm feeling lazy and and
laziness is another thing that there's a
pattern for there's the the it's the
double check locking pattern that you've
probably seen where you have to if you
want to have a lazy evaluated if you
want to evaluate something lazily you
you first get a lock or first you check
and see if it's already been evaluated
if it hasn't you grab a lock and then
you check again because memory models
and then if you still don't have
anything you go ahead and compute it and
you need to make sure to store it in a
volatile variable or it doesn't actually
work so it's a lot of work to do so we
would like to be able to put that into a
library and in fact this has been done
so another good library out there for
dealing with lambda expressions is the
Babri library it used to be called java
slang but then Oracle said Java slang
that contains the word Java in it which
is copyrighted so they turned the word
Java upside down and got Barbara it
works when you look at their logo better
and it's got a good lazy implementation
so we can we can just see how this works
real quick so I can I can fire up Jay
shell if you haven't used Jay shell you
should be using Jay shell even if you're
still on Java 8 have Java 9 sitting
around so you can use JCL and then let's
see I'd better do some imports so import
everything I need and then I'll create a
lazy string here and and the works to
compute this string is I'm going to
print out some something to say that I'm
thinking so we can see if the works
being done and then finally return some
value and since we're trying to be lazy
it says write back to us we're a bum but
that's okay and I can actually say lazy
is this lazy method actually evaluated
yet and I'll say no it's not
but if I say lazy
get it says I'm thinking and then it's
it gives me back the answer and that's
great and if I if asked it's been
evaluated now it says of course it has
been and if I say get a second time it
doesn't have to compute it again so you
know another good example of a something
that was a pattern before and is now a
library method and when you think about
all the code that had been written using
the double check locking pattern before
people realize that it didn't work
unless it was volatile and then people
had to go and change all that code if
the same thing had happened here it was
one library method that needed to be
changed so big improvement lots of other
design patterns admits similar
approaches but the the next thing that I
want to talk about is ways that we can
increase type safety through lambdas
there are a lot of api's in Java which
rely on the these API is typically are
ones that are using reflection in some
way and they may rely on the use of
strings to tell them what to reflect for
this is a not strongly typed code it's a
string ly typed I don't remember who
first said that but it's a perfect way
of phrasing it and it's it's a problem
because refactoring tools don't really
know that you're talking about a method
name if you've got it in quotes and the
compiler doesn't know so it's not going
to be able to catch typos at compile
time which means you're deferring things
to runtime which typically might happen
you know during a demo to your boss or
something like that or in you know
actual live production which not so good
but lambda expressions offer a great
alternative here and in fact the first
example of this let's let's take a look
at what it takes to make a comparator so
if you remember the contract for
comparator it's a little bit complicated
because you need to make sure that
there's sort of this anti symmetry and
there's this consistency and there's a
bunch of things and so it's easy to
write a comparator and get it wrong so
it's good to have some sort of library
that lets you do it that'll do it for
you excuse me and so the the common
beans utils package from Apache Commons
has an API that allows you to do
and you have to build a comparator chain
and then you can say well first let's
say I'm comparing people let me compare
on last name and if if I get a tie let
me do a tiebreaker based on the first
name and unfortunately this was done
without great attention to generics
probably was done before generics so I
actually have to cast it to get what I
want so this doesn't look so good but a
lot of that is not the fault of Java
that was just the API we could have had
a better looking API that said ok here I
just want a comparator chain on the
person class and I want to you know use
last name and tiebreak on first name so
this is definitely an improvement but
it's still string ly typed there's still
opportunities for problems and problems
make us sad it turns out this one is
actually solved in the jdk itself the
comparator class added a few new methods
the most interesting one is the
comparing or the most interesting pair I
guess is the first is comparing the
static method that says I want to create
a comparator which compares based off of
some function which Maps my being or my
whatever to something that is already
implementing comparable and then the
other great method is the then comparing
method that says and if that doesn't if
that can't you know distinguish the two
things then let's try and let's try this
other method so you can create now a
comparator in just a couple of lines of
code and that couple of lines of code is
completely typesafe your ID he's going
to know about it your refactoring tools
are going to know about it code analysis
tools assuming that they're there
they're up to speed on lambdas are all
going to be able to handle this
perfectly well and and so again you know
that that's great it's taking out a look
at another example so this one is I'm
gonna be talking about J unit 5 because
it just recently came out and it looks
kind of Boston actually and and they
have a way of a few ways of doing
parameterised tests one way is to just
have an annotation above your test with
a series of strings and each string is
supposed to somehow represent the
various data that you want
providing to your test I should mention
a parameterised test is basically a test
that runs with different values and you
sort of provide the values one by one so
it's a way of writing a lot of tests
without writing a lot of code so that's
nice the the the annotation approach
where you list all the parameters in the
annotation is not that flexible it only
works if you've got one parameter so
more generally they have this thing
where you can say you've got some method
that returns say a stream of arguments
where arguments are basically some sort
of tuple and then you can write your
parameterize test that looks like this
you say I it's a parameterised test
instead of a regular test and the data
is gonna come from this method string
int values and then I've got my test
that I actually run I want to verify
that if I if I parse the or excuse me if
I take a the integer and and turn it
into a string that I get what I'm
expecting to get so so that's that's
good that this is very good but it is
string ly typed and and so there's a few
problems the first is I might misspell
string it values obviously but there's
another deeper problem here which is
that while my test int value of method
takes a string and an int I have no
guarantees that that's actually what's
returned from the string and values
method it's just a stream of arguments
and those argument instances might not
have a string and an int they might not
even have just two elements might have
one or three so leaves a little bit to
be desired but it turns out there's
another thing in J unit five which is
really awesome that allows us to fix
this and what it's called is the dynamic
test so dynamic test in J unit is
basically a way of creating tests at
runtime instead of completely specifying
them at compile time and the funny thing
is that in this particular case we can
defer things to runtime in a way that
gives us more compile time type safety
which is an irony I just love and and
the way we can do it is well for the
example we had before first of all on
and I'm gonna use the the tuple class
from again jook lambda
lots of different libraries provide
tuples these days but it's a nice type
safe class it's parameterised in the
generically parameterised in the type of
the first and second element of your
tuple and so I've got a stream of tuples
of string and int and then what I want
to do is I want to take each one of
those and the the first map is a map
from the stream class the second map
that you see here is a map from the
tuple class which is a little bit weird
and try not to worry about it too much
right now but the upshot is once I'm
down to something that takes a string
and an integer then build my dynamic
test and when I build my dynamic test I
need to first say what is that the test
should be called so that when it passes
or fails it shows up nicely on the
output and then secondly the actual test
and this works and it's great it's
typesafe but it's a little bit messy
because there's this weird map tuple map
thing that's going on that I don't want
to have to think about and I don't know
I it doesn't feel as clean as it could
be to me but if we create one small
static helper method we can make things
a lot better so here's a method
parameter and this this one takes in
functions with two arguments and then
you could create a similar version for
three and four and five and so forth
arguments but the way it works is you
you say well I take in a test that I
want to sort or a test creator that I
want to run and and I take in some data
and I do that funky double map thing
that I did before and the idea is you
write this once get it to compile and
then never worry about it again and
instead write tests using it so now if I
want to write a parametrized test i say
i've got my test method and it's it's a
test Factory and I'm gonna use the
parametrized method to let everything
work out nicely and I'm just going to
start off by saying what's the test it's
a dynamic test based off s and I I'm not
even bothering to specify the types here
compiler inference is doing all of that
for me and doing it correctly and so as
before the first thing I do is give my
to name and then I say what I actually
want to do in the test and then finally
the last thing I do is I provide some
test data now I don't know about you but
this makes me this is the way you want
to write tests if you're writing
parameterize tests because now you're
just saying what you want to do and you
don't have any of the string ly typed
mess that was going on before and in
fact I like this stuff so much that I
wanted it even before J unit five had
really been built and so I ended up
writing a quick library for J unit four
it's a it's a test runner called Lam
data Runner I don't have the URL but if
you google it it's going to be the only
thing that shows up under that and it
basically has an API that lets you do
pretty much the same thing it does
require the use of a special test Runner
which can cause problems and because of
the way it works
certain J unit rules don't work out so
nicely so it's not perfect but it's it's
a nice way and I've actually found it
quite useful and again not a lot of code
to take something that is painful and
turn it into something that's really
nice and and better type safety okay
last thing I want to talk about is a few
best practices for for API design the
first is and this goes back to the file
visitor example if you're creating new
interfaces if possible create them so
that they only have one method it might
actually be better to have four
interfaces each taking in a single
method than one large interface if you
can get away with that and barring that
consider providing people factory
methods to create instances of your
interface so that they can use lambdas
and enjoy them next rule don't create
any interfaces at all instead use the
ones that are already out there Java
util function has a number of great
interfaces in it and because they're all
type current generically parameterised
they're gonna work for probably 80% of
your use cases and then another 10% of
your use cases they would work except
that you have checked exceptions you
need to worry about
and so then you can use say the Juke
lamda library again to manage those
checked exceptions this is nice you know
less classes to load in less things for
people to think about they'll say Oh a
function yes I know what that is I don't
need to go back to the drawing board and
try to figure out what this new
interface that you gave me is I already
understand exactly what it is another
thing so sometimes you want you you have
a method and let's say I've got an API
that has a method in it to do some work
and it takes in a runnable and then I
think you know checked exceptions that's
gonna make people sad so let me also
accept a checked runnable one that won't
throw any checked exceptions it's a
weird naming convention in my opinion
but whatever and this seems like a nice
thing to do but the problem is that both
these lambdas from the compilers point
of view have the same shape they both
take in no arguments and return no
arguments and throws clauses aren't
considered which means that if I want to
pass anything into this as a lambda the
compiler is gonna say it's ambiguous and
it's gonna force me to instead cast my
lambda expression as either a runnable
or a checked runnable which just feels
ridiculous so we knew overload methods
make sure you don't overload methods in
a way that you might force your callers
to actually specify which kind of lambda
flavor they're passing in um if the land
does have different shapes it works out
fine so for example if if one of these
was a runnable and one of these was a
callable well those have different
shapes because callable actually returns
something as whereas runnable doesn't or
let you know different parameters and so
forth but try to avoid that the last
best practice that i can recommend is to
fill out the session survey always
really appreciate feedback I mean
obviously if if you if you liked this
talk then I'm glad to hear about that
but I also want to hear about it if you
didn't like it what I could have done
better and I even want to hear about it
if you're really angry so with that we
have a few minutes if there are any
questions yes the question was do I ever
think Java will move all the checked
exceptions to runtime exceptions
theoretically they could because in some
sense it wouldn't break any existing
code but from what I've heard people
like Marc Ron mark Reinhold and Brian
gets and now it's buck we say in various
forums it's probably gonna be a cold day
down below before that happens so you
know fortunately increasingly when
people create new exception types they
extend runtime exceptions so you know
it's not getting a lot worse yes
question okay so the question what if
I'm processing a stream of data and
there's one piece of data in the stream
which is kind of a poison pill it's
gonna cause a runtime exception and now
my entire stream processing is upended
and and and thrown out and how do I deal
with that well it's a little bit tricky
I mean obviously one thing you can do is
is swallow the exception but that
doesn't feel quite right so maybe what
you want to do then is if it's a map
operation for example instead of mapping
to the result you're interested in you
could map to something that is either
the result or an exception so you can
kind of accumulate all those exceptions
at the end I think I think bobber might
have an either type that you can use for
that sort of thing so yeah if that's
something you're worried about it that
that's what I would recommend is is have
some way of collecting the exceptions go
from there
other questions all right well I
apologize this talk was so fast I was
worried about not being able to finish
in time and ended up actually finishing
a couple minutes early but that means
that you all can get into the the wait
list line for your next favorite talk
and thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>