<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JavaOne 2017 Keynote: Oracle | Coder Coacher - Coaching Coders</title><meta content="JavaOne 2017 Keynote: Oracle - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JavaOne 2017 Keynote: Oracle</b></h2><h5 class="post__date">2017-10-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Tf5rlIS6tkg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">over more than 20 years over two decades
Java has continued to bring value to
developers and enterprises worldwide
thoughtful evolution has helped Java
grow into the most vibrant programming
language on the planet moving forward we
want to ensure that Java is
well-positioned for modern development
and growth in the cloud and our next
speaker is uniquely qualified to talk
about how Java future direction will
help you through this transition he was
a lead developer on AWS at its inception
and he led development at giant for just
long enough to have been cured
completely
of any node.js religion he came to
Oracle debt and he architected the bare
metal cloud and now he leads overall
strategy for Java and and the cloud and
container native please put your hands
together and help me welcome Marc
cabbage
all right thank you all of you thank you
George thank you Intel we were super
excited to be here
Java and Java one really or by you and
for you we have a ton of stuff to talk
about or there's a lot of new content a
lot of fresh faces including mine and
we're gonna talk about the future as
George said right because those stats
that he put up they're fantastic but
they're today we need to be building for
tomorrow and actually even if we take an
honest look at where we are today right
we can apply that actual famous red muck
quote that we all know and love
right when when companies grow up they
turn into Java shops that tells us
something though it tells us that people
are writing is something else first and
rewriting in Java we need to change that
right maybe it's no js' which apparently
you can be reformed from maybe it's
something else but when you want the
next decade to be Java first Java always
all right that's how we want you to
think about it
so we're talk about how we're gonna get
there there's four themes we're gonna
come back to again and again throughout
this keynote and really there weren't
used as guiding principles for ourselves
in the java group number one is openness
right this is self-evident to
technologists transparency is important
in today's world it's more important
than ever and actually we're just going
to show you about this we're not gonna
talk about it that much we need to
evolve evolution is actually really hard
right it's like it's very easy to add
things it's hard to change things it's
nearly impossible to get rid of things
but you have to do it right with the use
cases it existed 22 years ago aren't
relevant today the things that exist a
year ago may not exist next year so we
have to change way to get there really
quickly you have to be nimble as we do
this right we get things wrong we have
to get it right to get it right quickly
last we need to continue to scale right
scale is easy for us as engineers to
think about but it's petabytes of data
or requests per second or a number of
JVMs that you manage but it's also about
people right George head up that there
are 12 million Java developers out there
which is awesome but tomorrow we want
there to be a billion developers so
that's the world we need to be building
for let's talk about how we're gonna get
there start with Enterprise Edition all
right this is huge news from us this
year eight here brings you modernization
of the platform there's amazing stuff in
it HTTP to to a sink API is reactive
api's helps you modernize the platform
but that's not good enough
right we actually need to do a lot more
to modernize to get you to that world of
cloud and micro services and serverless
because
reality is EE is the bedrock of mission
critical systems it does power
enterprise and if we look at why it's
not getting us there actually we apply
those themes it's actually pretty
self-evident right is it open well no
it's a vendor consortium the last I
checked those aren't that open is it
nimble well shift four years ago that's
not very fast so we're gonna change
everything about this right we put out
this news a few weeks ago people have
been very very receptive to it we're
super excited about it we're
fundamentally opening up Java Enterprise
Edition right cool so we're moving it to
the eclipse foundation right we're gonna
change everything we've got actually
gotten a lot of questions about this I
don't think people are quite clear it's
gonna be everything right the reference
implementations the tcks that was a huge
run people didn't expect authorship of
specifications importantly control we're
gonna be heads down over the next few
months getting to a1 dot over or at
least there but it's gonna be that's
that's there's gonna be a new day for it
right so that's gonna set it up for the
next decade to help us modernize but I
want to make sure you don't just hear
this from Oracle right you've heard this
kind of stuff from Oracle before I want
to make sure you hear from all of our
partners right so what I'd like to do is
bring out three of those leaders of the
community along with us you hear all of
us saying this together so please
welcome David Blevins Rami tribe Iain
Robinson from IBM and Mark littell from
Red Hat
alright thank you guys so much for being
here
so we'll kind of do this as panel style
so we all you know here we all say it
together brothers-in-arms David we'll
start with you right so you've been an
open source for over 20 years
you've built a fantastic career or
fantastic company out of it what's your
perspective on what this change means to
the community you large well I think
that when you look at our industry
we're filled with so many passionate
developers some of them quite young the
thing that I can't help but take away is
you're inheriting EE and so in a very
real sense
EE for Jay is AE for the next generation
and the other thing is collectively you
make the biggest investment in EE which
far exceeds what we collectively put put
in it and so you having access to the
tcks that if you have a problem you can
go straight to the test and get them
improved it raises the bar on us so this
effectively makes our largest investors
enabled to fuel EE and we can all go
faster I think in the end awesome
alright so Ian IBM obviously one of the
largest vendors were probably one of the
two largest vendors of Java and Java
Enterprise Edition on earth what's your
perspective on what this means moving to
the Eclipse Foundation
well the Eclipse Foundation I think is a
good choice it's the one that IBM picked
for example when we open sourced our j9
job a virtual machine we've had called
j9 but it's actually been IBM's JVM
since the Java 5 days so I think having
you know both the low-level JVM and the
Eclipse and the enterprise platform both
at Eclipse is a really strong
endorsement for Java development top to
bottom at Eclipse and I think there's a
you know there's a there's a couple of
there's a couple of advantages I think
that yeah that that this has to people
from a couple of different perspectives
David already mentioned the TCK is
access to the TC case which is great for
developers but for for people building
solutions on top of java re' I think
having you know having this new
community fired up with energy and I
think is you know it's it's it gives
them encouragement I think that the
future of Java EE is strong and I think
the only word of caution I would have
is that having just open-sourced open j9
and our Enterprise open Liberty runtime
that took us a lot of work that took us
a year to get us there so you know
there's a lot of work ahead but but I
think we're going to be successful there
is a lot of work and we have a lot to do
right so mark RedHat
obviously instrumental in creating micro
profile along with these guys on stage a
lot of people in the community what's
your perspective from micro profile and
Red Hat on what this means I mean you're
right we we create micro profile over a
year ago moved it to eclipse we've seen
a great groundswell in interest and
participation since we moved it to
eclipse for very reasons that you
mentioned earlier that we can be more
nimble and we can react to changes a lot
a lot more quickly moving e4j to eclipse
I think allows these two big communities
to come together and help to drive
Enterprise Java
into the next decade as you mentioned
earlier awesome ok so what I want to
make sure you all understand with all of
us on stage is
please come participate right we cannot
do this alone it cannot keep being a
vendor consortium so the Charter is open
at Eclipse Foundation please come check
it out there's a mailing list there's a
Twitter foundation there's a panel which
I'm sure will be action-packed right
after this importantly stop by the Red
Hat booth that Tomi tribe booth the IBM
booth the Eclipse booth the Oracle booth
please come talk to us please come
participate all right thank you guys so
much for being here thanks
all right so let's move on let's talk
about Java SE right so 9 is here 9 is a
transformation release for us right it
brings you over 150 new features
streamlines the JVM importantly there's
a lot of support in there for things
like Linux containers gives you better
on management honoring of cgroups memory
settings also it has modules which come
sure you might have heard about and
modules really are this amazing thing
they're gonna let us turn the corner let
us evolve right for you they mean you
can get just enough Java just enough JVM
in your life you can right size the JVM
very important for a cloud world for a
dynamic world for us that means we can
finally evolve the platform in ways we
could not do before literally couldn't
so we think modules really are this this
linchpin that's gonna get us to that
future but again is Java 9 enough no
it's not what if we apply those themes
again look at those frets talk about
openness first I came to this group what
I was told was open JDK that's a place
not a thing that's not open enough so
now open JDK is a thing going forward
we're going to be producing open JDK
binaries under the GPL license you truly
now have a free and open java that
you've never had before it's number one
number two you might be saying well the
open JDK the Oracle JDK that's one of
those is better than the other maybe I
have to use the Oracle JDK today that's
true right the Oracle JDK is commercial
features in it these things parley
powers some of the most gnarly systems
on the planet some amazing technologies
for help you run Java at scale but today
they're only available to an elite few
and for that billion developers they
need to be available to everybody so
going forward we're going to open source
all of the features in the Oracle JDK
there will be zero difference between
the open JDK and the Oracle JDK that's
I got one more cool so we truly now have
an open Java right but it's actually
still not enough cuz we think about pace
right the last time it shipped was three
years ago that is not fast enough so now
that open truly free Java that we just
spoke about it's gonna come at you every
six months right so now this we think
actually starts to change the future of
Java this we think starts to put job in
the forefront of everyone's minds
certainly ours but also people that are
not currently writing Java we think this
brings it to a new future that is not
previously existed before so what I want
to do those make you not hear this from
just me not from Oracle that actually I
can bring out mr. Java Renaissance
himself James governor from Redmont to
give you his perspective James come on
out
I only have one slit you only have one
slide all right I'm not gonna have a
next slide mom all right fine
thanks hey everybody how you doing
pleasure to be here the last time that I
actually stood on the main main stage at
JavaOne was bacne the distant past back
in 2004 so who all was here in the Java
ecosystem at that time yeah I think this
probably some of you that haven't
haven't quoted admitted but you've been
around that long but um I sit here and I
said something that was kind of
contentious at the time I said that the
JCP was the worst form of governance for
software apart from all of the other
ones that we've tried now it's kind of
interesting we've seen this long path I
mean at that time obviously son was was
still around
things have changed pretty dramatically
and in fact what I think is interesting
is that things have changed in the Java
ecosystem probably more in the past
three weeks than they have in the
previous 13 years this open source move
I think we really can't underestimate
the significance of it if we're gonna
have a chance for the community to
flourish if we're gonna have a chance to
really expand I think the ecosystem it
was necessary that Oracle took these
steps I think one of the interesting
things that's happened over the past few
years is the adoption of java by the web
companies so first generation web
companies have been obviously amazon
very much a Java shop Google tons of
Java obviously they have go and other
languages now but what's perhaps more
surprising is those web companies that
said look actually we don't like Java
we're gonna we're gonna be Ruby and you
know Twitter we're gonna do Ruby we're
gonna do Ruby that was until Ruby
wouldn't scale far enough they adopted
Java Facebook again they came out from
the wall say oh no we're not interested
in Java
until they became one of the biggest two
Duke shops on the planet there's been a
big change but it's very very important
to those web companies that have an
opportunity they're all making open
source contributions now things like in
tracing Zipkin across the board we've
seen
contributions Kafka began as a project
from again LinkedIn so the fact is is
that you've got large web companies that
want to make contributions they want to
be part of this world but they haven't
really got involved with Java because it
wasn't as open as they might expect they
also felt that it wasn't moving as
quickly as they might expect you know
they're coming from world of continuous
deployment well if you tell me it's
gonna be three years before the next
version they're not so interested in
that you know developers tend to have a
certain degree of a DD they want
something new they want something bright
shiny and fast so I mean one of the
things as Java developers that you want
to think about is where do we go from
here
am I the new to the ecosystem where I've
been around for a while how relevant are
my skills so Redmont my company we do a
programming language rankings that is
every six months we do it it doesn't
necessarily change that fast so we've
we've kept it at that time frame and
basically what we do is we scatter plot
the conversations in Stack Overflow
against what's happening in github and
it's been very very interesting to us at
a time when a lot of people would say oh
perhaps the job was not as much a part
of the new world you might expect that
it is performed with strength over time
and continues we generally see Java and
JavaScript at the top of the rankings
there are tons of cool new languages out
there there's developers that are like
oh yeah everything's gonna be rust or
everything is going to be go Copeland's
this cool new thing in Java but the
simple fact remains the jobs the
language and not just the JVM are a
thing so let's talk a bit about the JVM
I think why did those web companies
decide that they needed to adopt Java
followed because of the skills there are
so many skills available if you're
hiring people out of computer science
chances are high they've got Java skills
there but it also gets back to something
that I I mean you know it's it's it's
all very well and good to talk about you
know move fast and break things but who
likes to sleep throughout the night
there you go so I have three kids and so
I've had various times in my life in
which I don't sleep through the night
but but generally you want something you
can rely on something that's stable and
what those companies found was that in
fact
in terms of observability performance
traceability and just the ability to
manage something overtime Java and the
JVM had a real value there isn't really
anything out there that replicates the
power of the JVM today so we can
accelerate the language development and
begin to make it more like the modern
developer expects and that's what the
challenge is for Oracle then you know
this this sort of there's plenty of
runway to go and I think that's that's
the lesson it was very important that
the open sourcing happened and yeah
we've got a new version of Java coming
out and that notion of a six-month
cadence is going to be a big big deal so
hopefully in a couple of years we'll be
here we will have had the low-hanging
fruit done and a lot more development in
Java the language thank you
all right it's it's actually super
validating for us to hear that I hope
you're as excited about the future of
job as we are what I'd like to do now
after hearing that from James is
actually move on a little bit and talk
about cloud I talk about job in the
cloud as George said at the very
beginning there's 55% of JVMs today are
connected in the cloud somehow we need
to build for a world of a hundred
percent right that's tomorrow cuz clouds
pervasive doesn't matter what you work
on cloud is in your life if it's not
already now you come to conferences like
this or you know open world or
technology conferences in general you're
gonna hear a lot about the business
value of cloud right things like optics
and capex and elasticity and all those
things are true let's talk about it
means to be developer developer right
this is a developer conference to me
when you boil it down cloud is about
building a distributed system at the end
of the day all right those are hard
they're actually super hard the change
of the way you have to think that
changes the way you have to tool changes
the way we build deploy scale operate
our services this is what I'd like to do
is actually talk to you about what's in
the ecosystem and what we're gonna do in
Java itself to help you in the cloud
what I'd like to do is make sure that we
have a common frame of reference for
this right talk about one of those hyper
scale web companies that James mentioned
the week that we all think about so
they've never been a job of one before
their new face as I said there's gonna
be some fresh ones of those but they're
gonna come talk to us about their
architecture the challenges they've
faced
what was hard what's still hard and
importantly why they've used Java so
please welcome to the stage Nicholas
Gustafson he's the principal architect
at Spotify
thank you so much for coming necklace
thank you very much hey thank you very
much for having me
Spotify is a music streaming service we
aim to provide our music you are users
with the music they love on the
platforms where they exist platforms
that might include the ones you see in
the picture here but also embedded
platforms like TVs or Playstations or
stereo receivers we also want to give
our users the features that they want in
order to be able to discover and listen
to the music they want since we launched
in October in 2009 as a small Swedish
startup we've grown pretty quickly and
we're now at in in 61 markets around the
world having most recently launched in
in Thailand we're at more than 140
million active users but if you ask me
what I think is even cooler than that is
that we handle more than 3 billion
streams per day and we have more than 4
million requests to our back-end per
second now dealing with this scale turns
into pretty interesting and challenging
technology problems as you might imagine
Spotify
started out as a Python back-end and you
already met James he heard mark
mentioning this this quote of his and
this is very much true for Spotify while
Python was an awesome way for us to get
started and to build out Rebecca as as
as we were a young company
we ran into some pretty constraining
scalability concerns we had one service
though at the time there was implemented
in Java it was our search service it's
actually still around we noticed that
during the scalability incidents that we
had it behaved in a much more stable way
than many of our other services and the
JVM had this nice property where we
could actually observe what was
happening in runtime if that was
collecting runtime metrics on the
platform itself or if that was profiling
the service while
in production both were very effective
ways of knowing what was actually
happening to the service one of the very
early and argue the best decisions that
we've taken architecture wise has been
to design our back-end as a set of small
single responsibilities sharing nothing
services what the pattern that is now
known as a micro service architecture as
we decided to start exploring Java and a
little bit later moving over to Java
being able to do that incrementally
serviced by service as it made sense was
a crucial way for us to to be able to do
that that changed
having small services also means that we
can as humans easily understand and
reason about them we can scale them
independently different features that
Spotify is very different interaction
patterns and that the services that
powers the features needs to be scaled
in different ways we also have it also
means that we have limited impact when
we actually have failures so a service
might fail for whatever reason but only
a subset of the feature set of Spotify
or only a subset our users might might
notice like if the search service would
fall over that will only affect search
functionality no Spotify not streaming
or play listing or whatever might be the
case and lastly it enables us to have
ownership of a service firmly within the
team that builds that service so you run
what you build and that closes that
important feedback loop in between
developers and operations the picture on
the right in this slide shows a very
high-level view or architecture you can
see the perimeter services which are
exposed to the internet they're very
hardened and they manages things like
authentication of requests to our
back-end and we'll route requests down
to services further down the next layer
is what we call the aggregation layer
this is services that deals with things
that are very close to
what you would see in our clients that
one-to-one representation of the views
in our clients these services are
stateless and they don't do anything on
their own so they fan out to the lowest
layer where we have services that do the
actual data processing and storage then
as responses get back the aggregation
services will create the view that we
serve back to the client in a format
that is easily consumable by our clients
all of this runs in a complete clone in
multiple data centers around the world
for us to be close to our users to have
low latency but also to be able to do
full data center fail overs during
large-scale maintenance or or incidents
and this is something that we do
actually fairly frequently we're not
only using two JVM for our back-end
services we also use it for our data
processing and machine learning our data
processing framework is based on Scala
it's called Co it's been open sourced
it's a way to build pipelines that run
on tops of Google's data flow and
bigquery cloud products we schedule
these using you know another open source
framework called sticks which is a
docker scheduling framework and this is
it has enabled similar to what I
described from our micro services for us
to scale data processing and machine
learning to the scale that we're at so
this is a logical equivalent to our
micro service architecture for it but
for data processing if any of this
tickles your interest I'll be running a
session in just a few hours so feel free
to come along if you want to hear more
details around how we think and build
our back in services and thank you very
much
all right thank you so much Nicholas so
if you've been in the space for a while
I've been working on cloud systems for a
while you see that like an architecture
of the sneak peak that Nicholas gave you
you realize we all have the same
problems right we all have to build
effectively the same thing to solve that
same challenge again and again right we
don't need this like this thing that
helps us get a distributed kernel a
distributed substrate if you don't
already have one and you're asking what
should I build or you have one it's long
in the tooth and what should you next
our opinion to Java our opinionated
Oracle is you should use kubernetes but
it is the right open-source building
block that abstracts away clouds
abstract the way infrastructures gives
you this distributed substrate to help
you build resilient microservices we're
taking a big bet on it we've put a lot
of people on the kubernetes project we
announced several kubernetes focused
cloud products early today on the other
side of the fence at open world we're
doing a lot with it we actually think it
can do a lot for Java to the sort of
like to do is have you hear from a
subject matter expert on kubernetes why
this is right for Java developers why
this is the platform you should build
micro services on so please welcome
Craig McKee Craig is the CEO and founder
of hep do hep D o is the startup focused
on bringing kubernetes to the enterprise
but what makes them as an expert is
Craig was actually one of the cofounders
of the kubernetes project during his
time at Google so Craig thanks so much
for being here
stages yours
well thanks so much for having me here
folks it's really been an exciting
three and a half years since we started
the Koopa news project and what we set
out to do back in the day was to bring a
lot of Google sensibilities around
building and running applications to
developers like yourself
I personally was really inspired by the
idea of providing a better framework to
run applications that developers can
focus on code and expert systems
underlying the the application languages
could deal with a lot of the mundane
ities and challenges associated with
writing those applications when we set
out to start this project we knew it
wasn't enough to just write a letter
from the future to enterprise developers
we knew that we needed to create
something in the open and make sure that
it worked as well with relatively
traditional workloads as it did with the
forward-looking progressive dynamic
workloads that ran inside a technic
company like Google and so kubernetes
over the last three-and-a-half years has
emerged as pretty close to a standard
and it is an open source container
Orchestrator so for those of you aren't
familiar with it it's worth just
breaking down those three words open
source obviously is critical it's
becoming increasingly important to
organizations of all sizes as they're
making decisions about the technologies
they know that open source provides both
an incredible force in terms of driving
innovation but it also buffers them from
vendor lock-in which is increasingly
important containers have become an
amazing way to simplify the operations
process as you're building applications
they provide a medically sealed highly
predictable unit of deployment so you
can take your application in this case a
job application package it up with all
of its dependencies and predictably
deploy it out into a variety of
environments effectively decoupling it
not only from the environment where it's
running but also in some ways from the
operating system that it's running on
there creates very high levels of
portability and then orchestration is
the final piece and this is where much
of the magic is by using a dynamic
Orchestrator you can rely on an
intelligence system
to deal with all of those operational
mechanics deploying scaling monitoring
and reasoning about your application now
what this means through the Java
community is actually pretty significant
if you think about the old world you'd
have middleware that would be
responsible for writing your
mission-critical enterprise applications
what we're starting to see is that
middleware getting teased apart almost
polarized into two different pieces
we're starting to see the emergence of
systems like kubernetes as a standard
way to run a lot of the underlying
distributed systems components
effectively stitching together a large
number of machines that can operate as a
single logical ideal computing fabric
and then what we started to see is a lot
of the other functionality getting
pushed up into application level
libraries that provide a lot of the
immediate integration that you need to
run those applications efficiently and
outcome of that is pretty significant in
that it now opens your java applications
up to a polyglot world they can coexist
side by side the applications are the
languages if you want but more
importantly it opens up them to a natraj
Mis world where you can enter leave
these Java applications with a lot of
dependencies that they might rely on so
you could run a Cassandra database for
instance on the same core infrastructure
using the same underlying Orchestrator
that your application uses which is very
powerful what that means at the end of
the day is that as you have a lot of
enterprise concerns like governance risk
and compliance you can rely on a simple
single consistent underlying framework
to deal with those problems for you and
as a result kubernetes is effectively
creating this distributed systems so
this is a distributed systems operating
system a natural environment we can run
not only Java applications but anything
else and you can do that in a way that
is perfectly decoupled from your cloud
provider it works just as well on
premise or in the cloud gives you a
great degree of choice and flexibility
around where you want to run those
applications now as we look to the
future there are a set of challenges
that exist when you're starting to move
away from relatively traditional large
structured applications into this more
modern micro services based environment
that kubernetes naturally pushes you
towards the first and foremost of those
is the weight of Java if you want to
move into this environment that is
intrinsically
more bite-sized it makes sense to have a
more bite-sized runtime environment and
it's very heartening to see some of the
work that's being done to reduce the
weight and sip enough time associated
with Java so that you can actually get
these more dynamic applications running
another result of that intrinsic
dynamicism is the need for higher levels
of ant read introspect ability you start
to live in a world where JVM your java
application is no longer tied to a
single physical machine so to really
understand what's happening and to be
able to diagnose things in these new
worlds you need higher levels of logging
observability you need to have access to
structured information about the
application to have a better sense of
what happened after the fact without
necessarily tying that to a single
physical machine it's also hardening to
see some of that coming out in this very
conference the third thing that I think
a lot about as we look at this
environment and and the needs moving
forwards is the libraries themselves as
I said kubernetes provides essentially a
distributed system environment and
operating system for applications and
while it is relatively uh opinionated it
does offer up a certain set of
primitives that are necessary to allow
an application to find another
application access it and consume it and
I would love to see over the coming year
or two a lot of focus on making much
more natural Java Runtime environment
integrations with the underlying
kubernetes substrate the final thing
that I think about a lot when it comes
to the Java community is a little bit
nuanced when many people start looking
at Linux application containers they
think of them largely as a replacement
for a virtual machine just a way to
package up and run something but if you
look back at their origins historically
they provided a very robust and rich
resource isolation framework a way to
tease apart the set of resources that
would be a scientist something and allow
you to pack very densely a number of
applications onto the same set of
physical infrastructure and one of the
most heartening things that I'm seeing
coming out of conference is a lot of
effort to make cgroups integration much
more natural into the java runtime
environment so I'm very excited about
the future of kubernetes I think it's a
very natural environment for you to run
your java applications if you're
interested in learning more I'd
encourage you to go to the website
kubernetes dot IO
and if you want to get closer to the
community feel free to take a look at
the cloud native computing Foundation
which is a vendor-neutral home where the
kubernetes project and a lot of new
cloud native technologies are being
honed thank you so much for your time
and have a good day Enterprise needs to
get some kubernetes in your life call
Craig before we move on what I'd like to
do is give you some helpful information
about how to get started with java and
current Nettie's we've put this together
so worker Oracle acquired them earlier
this year it's a fantastic container
native CI CD service lets you get some
containers in your life importantly get
some kubernetes in your life it's where
we've launched all those kubernetes
services I mentioned we've actually put
together our they're a curated set of
Java getting started guide tutorials
quick steps libraries to help you get
some Java into containers and into
kubernetes so this by the way there's a
community edition completely free no
strings attached there will never be
strings attached
so hopefully you find it useful if not
let us know if so please let us know
all right this Craig said he told spoke
a lot at the end about observability and
operations I think that's where we
should talk about next we talked about
cloud services because operations are
fundamentally hard they're one of the
hardest parts of building distribute
systems and importantly if you don't
really know this or you've never done
this before operations are actually part
of your product they're literally part
of your service and you have to think of
that well I know that we think of them
that way now importantly though like
observability we always need more
information we need more insights where
we can never have enough we have tons of
data but we need real-time information
now the set of the beginning of this
talk that we're open sourcing all of
those commercial features in the Oracle
JDK one of those things happens to be
Java flight recorder if you're not
familiar with JFR JFR is this amazing
like super Swiss Army knife to let you
diagnose any JVM or any job application
right you can see in real time what's
happening up and down the stack you can
do with no performance overhead so it's
fantastic but we need to help you scale
in the cloud and they help you with this
in the cloud so what I'd like to do is
actually give you a sneak peek at a
service we're building in the cloud to
help you manage JVM to scale help you
give you real-time diagnostics so please
welcome for my team Varun Madden and
George Matthew to talk about this thank
you Mark
we're super excited to be here today and
share with you all a service that we've
been building for a while now the
service is focused on making container
narrative development in Java simpler
debugging any issues that you guys run
into much easier and just helping making
your applications more performant I'm
sure almost everyone over here how to
deal with profiling applications and not
kind of refer to this Java flight
recorder makes this really simple for a
single JVM but the problem grows as we
move to the cloud and even more to
micro-services as we all are doing right
now the issue is no longer just what is
my performance issue but we need to know
when it's happening and where exactly is
it so I would like to introduce a
container diagnostic service that helps
you do exactly that
this service runs in production it's
always on provides real-time data with
very very low overhead it gives you the
depth of data that JFR provides and the
breadth across the service Gorge here
will actually give you a live demo of
the service now boom thank you very
there's my screen so quick note about
the setup for this demo I have three
replicas of my service running on a
cobra Nettie's cluster with the
diagnostic service gathering continuous
chair for recordings of my service now
one thing I'd like to re-emphasize that
Verne already touched on is that this
diagnostic service is a very low
overhead service that's designed to be
running continuously in your production
cluster because like he said you don't
know when the problems going to show up
where it's gonna show up or that you
even have a problem now JFR has this has
a lot of very useful and deep data but
today I'd like to focus on the on the
issue of memory leaks so if you look at
this graph up above it shows you memory
usage by each of my pods right after
garbage collection and it looks like two
of them are doing okay down here but one
of them is having a little too much fun
and using that more memory than it
should probably means it has a memory
leak now we do a lot of interesting
analysis on this data that we gather
from JFR so that we can find the
problems for you and you don't have to
go looking for them
so let's go look at this analysis tab to
see what we found I know how we did find
a memory leak and as you suspected it's
only affecting one of our pods jf4 has
this cool new feature that tracks the
lifetime of a sample of allocated
objects and using this data we can tell
which objects are hanging around on the
in the JVM for longer than they should
so let's dig in and see if we can
pinpoint the source of this leak it
looks like in this case we have some
samples of a byte array hanging around
for longer than they should and if we
click into an individual sample we get
very detailed information we get a stack
trace showing us exactly where in our
code this object is allocated and a
reference change showing us the chain of
references that's preventing this object
from being garbage collected so let's go
look at the code so it looks like line
63 here of my leak appropriately named
leak work item class is where I allocate
this object
let's go to line 63 right there is where
allocate the object no surprises there
let's go back to the reference chain it
looks like this hash set right here in
progress items is where I hold onto
these references and if you look closer
it looks like I do add reference to add
these objects to the hash set and remove
them but it turns out that I forgot to
override equals and get hash code in
this class which is causing the leak now
if you've ever had to troubleshoot a
memory leak issue in production before
you know how incredibly difficult that
can be and how much easier this is and
this is just the tip of the iceberg when
it comes to the power of JFR and we're
excited to bring you all of that power
to troubleshoot your production systems
thank you thanks Josh this was just a
sneak peek of a small little thing that
we demoed over here if you guys are
interested there's a much more in-depth
session tomorrow morning 8:30 I know
it's early in the morning but believe me
it'd be worth your time thanks everybody
thank you
oh cloud which is service alright it's
not everybody's mind today but if you're
not familiar where the service is this
compute abstraction that takes away all
notion of infrastructure from you as a
developer might applies to many things
applies to compute databases to storage
but importantly we talked about applying
service to our code to what we deploy we
think of it as functions of service
right and it's it's kind of a beautiful
model right because it lets you focus
purely on the logic of your code purely
on business logic not worrying about
infrastructure not worrying about that
like muck that's in your system and
importantly gives you an amazing
economic model too but again having
worked in the cloud space for a while
you look at this and honestly where we
are in the space of the industry is
actually pretty nascent right what's out
there today is literally triggers for
the cloud right every cloud providers
got one of these things something like a
VM goes up the VM goes down it publishes
an event to a bus you get some code that
executes so you can take some action the
super helpful it's amazing for that use
case but it's easy to be tricked into
thinking that's an app dev platform when
it's not right the fundamentals of
computer science are always with us
right things like concurrency and
synchronization and state management
these are hard for any reasonably sized
application or reasonably sliced micro
servers you need something better to do
that what you need to solve those
problems is what Java was exists
invented for in the first place right
you need a language 22 years ago Java
solved this problem as why it is where
it is today for running on top of an
operating system whether there was linux
solaris windows whatever we talked about
the distributed operating system right
then going to the cloud we need a
language to help us with those problems
so we're super excited to talk about
what we're doing next we're gonna talk
about an open source project we're
creating that is container native
completely language agnostic but there's
importantly an exciting java layer that
we're putting into it to solve those
problems so what I'd like to do is turn
the stage over to chat ever for my team
to talk about what we're doing so Chad
stages yours
thanks mark my screen I am super
thrilled to introduce to you the FN
project the FN project today consists of
three components number one the FN
server the FN server is the foundation
of your functions as a service platform
it's what enables developers to build
deploy and scale functions in a multi
cloud environment it runs locally on
your laptop so you can get dev prod
parity working locally both in the cloud
it's fast scalable and container native
number two we're announcing the FN Java
fdk or function development kit the Java
FDK allows you to easily bootstrap your
job of functions it gives you a data
binding model to bind the input to your
functions two common java objects and
types and finally we're announcing the
oh and finally it gives you a test
harness to test all of your functions
using j-unit rules so i don't want to
forget that and finally we're announcing
FN flow flow is a system that enables
developers to build higher-level
workflows and orchestrate your functions
in a more complex environment you get
things like sequencing and chaining
parallelism fanon fan-out air handling
state management all from the language
of your choice today of course we're
announcing that Java is the first
officially supported language that's
actually what I'm going to demo today so
in order to show this we built a demo
app called Vista if you look at this
application it consists of five
functions and basically what it's doing
is pulling images from Flickr of cars
detecting the license plate on that car
getting the actual value of the license
plate used in the open ALPR library
which is an open source library and then
it uses open CV to draw a box around the
license plate and send all of that
information to both Twitter and slack as
you can see we have a number of red
arrows here and those are no no's that's
where we have hard-coded invocations of
each function from the previous one in
order to call them it's almost an
anti-pattern when it comes to micro
services and
functional developments enter FN flow FN
flow gives us a programmatic way to
remove those hard-coded indications and
move them into their own function called
a flow function what we've done is
decoupled all our functions from each
other and now we're back to the proper
architecture for functional development
let's take a little bit look at some
code the first thing we'll notice here
is that it's short sweet and simple it's
really a great thing if you look at the
top we have our scraper that we invoke
little lag here once we integrate once
we invoke the scraper we get back a flow
future object that flow future object
implements the standard completable
future API that was introduced in Java 8
along with that API comes a number of
promises like methods that gives us all
the nice workflow that we want such as
then compose then compose add steps to
the compute graph and returns a future
that represents the completion of those
steps once we do that we get basically
the nice fan-out capability that I
talked about before so then we fan out
and we run the plate detection and we
also run draw and once we're finished
with that we run all of which gives us
both a Twitter and the slack function
which posts to those and when it's
complete we have a win complete method
which then tells us whether it was
successful or it failed that's actually
something that I had no concept of
before in the first version of Vista
because we had no concept of a complete
workflow so a couple things I want to
point out of course this looks like a
single Java program in fact it can be
reasoned about just like a single Java
program we can test it we can use j-unit
we can put breakpoints we have our
familiar IDE it's a single function
codebase but behind the scenes it's
being broken up into sometimes hundreds
if not thousands of function invocations
in fact every step is a different JVM
that we're running in a massively
parallel environment so you get all the
benefits of a functions as a service
system such as the economic model of
only getting charged for the
milliseconds that these things are
running massive parallelization and also
the operational benefits without the
complexity of dealing with a
functions of the service system and one
other thing to note any variables that
were created inside the enclosed scope
whether part of the heap or the stack
gets reconstituted in all future
invocations of any functions inside that
scope so it's a very powerful concept
that no other workflow system gives you
today so I quickly plugged in the
internet right as I came on stage so
we're gonna see if I have Internet but
we're gonna try and run a demo yeah I
was on the Wi-Fi before don't ask me why
so if you look here all I have is a
simple payload JSON file it's just your
standard JSON three input variables
license plate car USA we're gonna pull
20 of them and because FN the functions
actually take standard in as their input
it's very very simple I can actually
take that payload and I can pipe it
right into FN call FN call is a wrapper
around curl which hits the server which
in this case happens to be running
locally on my machine and then my app
name is my app and it's flow so once it
starts running the first thing we'll
notice on the left is a number of
functions are starting to spin up we see
that we already have a couple running we
have a number of complete and in the
middle this is the flow UI which shows
here I'll make this big which shows the
fan out so at the top we have let's make
this bigger we can see now we're
starting to fail this is a visual
representation of all of the functions
that are being sequenced and ran from
each other including the nice fan-out
capability if I click on any particular
node for example this one I can actually
view the entire call stack of how this
particular function was called this is
really extremely powerful I have it was
composed from detect plates here's the
log that I got from detect plates I can
view all the way down to the scraper
which is what the first function is in
our sequence all the way down to the
flow function and if we look on the
right of course it's already finished I
wasn't able to show much but we get all
of our images in slack and finally it's
finished scraping so I know this demo
was extremely fast but I hope that you
got to see just a sense of how powerful
the f-m project can be and why we're so
excited to announce that to the Java
community
today thank you
this is gonna be open source right
that's the plan mark is it open source
right now it isn't well it probably
should be like weird Java one I say we
do it let's do it all right open source
the Efrain project right now oh there it
is
here we go all right I think we do this
was gonna happen well I'm in the danger
zone all right hopefully my too fast oh
no wait don't worry
that's an advertisement for one password
boom it's open its open source right now
thanks all right so please go try it out
we're really excited about where this is
going
FN project I owned by the way if we
didn't say the name so please come try
it out please give us feedback please
come participate in it now one thing I
want to say about this like the last
thing I want to say in this chat showed
you this demo it's a super amazing demo
I I get chills every time but you talked
about the completable futures API right
and I think the way to think about this
is think of this is like a v1 right this
is our first step we talked about
setting up java for the next decade
imagine we can do we actually apply the
language to this in a much bigger way
which is actually an excellent segue to
the next of our talk so what I'd like to
do is now transition to talking about
where we are at Java 9 and the VM and
where the language might be going and
who better to do that then the one you
know and love Marc Reinhold the chief
architect of Java Marc come on out
thank you Mark hello everybody welcome
to Java one Java 9 is here that means
yeah
that means the jigsaw is here III heard
those boos in project jigsaw we set out
nine years ago believe it or not to
solve two fundamental problems in the
Java platform one is the brittle and
error-prone class path the other is the
massive and monolithic JDK these two
fundamental problems we address both of
these problems together by employing our
standard recipe for evolving the
platform identify the missing
abstraction figure out what it ought to
be add it to the platform in a way that
fits it well with everything else that's
already there and of course while doing
that preserve drop is key core values of
readability simplicity universality and
compatibility for these two problems the
missing abstraction as we all know by
now is modules what is a module well
it's actually pretty simple at a high
level a module is a set of packages
designed for reuse in jigsaw modules are
a new construct of the java programming
language they work the same way at
compile-time and run-time because
they're known to both the compiler and
the virtual machine this greatly
simplifies development you declare a
module in a module declaration it's a
little bit of Java code you give your
module a name you name the packages that
it exports for use by other modules the
modules that depend upon it and you name
the modules upon which it depends whose
packages it will use where do module
declarations go well they're Java source
codes that they go in little Java files
by convention these are named module -
info dot Java files what do we do with
Java files we compile them you compile
one of these files you get a little
class file the use of class files here
is intentional it was somewhat
controversial but it's intentional
because it makes it basically it makes
it easy for existing tool chains to
adapt to this new world to package up a
compiled module for distribution all you
have to do is make sure that the module
info doc class file is in your jar file
right there at the top level then you
have what we call a modular jar file so
the module system helps escape from
classpath hell because it provides a
cleaner and safer alternative to the
class path that is the module path when
you put modular jar files on the module
path the module system can guaranteed
two key properties when you compile or
run your code these are properties you
can't even express on the class path
much less ask to be guaranteed the first
property is reliable configuration
reliable configuration means if one
module requires another then that other
module will be present and none of the
modules presence will conflict with any
others as an example here we have our
module comp who live again note their
use of reverse DNS for the module name
that's the convention we're trying to
establish confu lib requires a model
named com2 util so the module system
goes off and finds it and establishes
the proper connection between them now
suppose the confu Lib also required some
other module called confu whatever but
there is no com2 whatever well what
happens when you try to compile this
module at compile time you get an error
message error module not found com2
whatever if maybe come for whatever used
to exist but now it doesn't at runtime
you'll get an exception module com2
whatever not found required by confu lib
the second property guaranteed by the
module system is strong encapsulation
strong encapsulation means the code
outside of a model can only access the
classes and interfaces in the packages
explicitly exported by that module this
means you can conceal your internal
api's and change them whenever you want
to to continue with our example suppose
there's some code and comm to Lib that
instantiate some secret internal class
in the compo util module while you try
to compile that you'll get an error
error message sorry that's not
accessible
if you matter if you've somehow managed
to run it because maybe come through
what it what compute and come through
foo util used to export that package but
now is it now it doesn't then you get an
exception illegal access error and note
in these exception messages we put a lot
of information to help you diagnose what
went wrong so reliable configuration
strong encapsulation this is a much
saner world than the brittle and
error-prone class path the module system
helps with the massive and monolithic
JDK that's because we've taken the
module system and applied it to the
platform itself starting with this
spaghetti bowl of tightly coupled
platform components after years of
painstaking refactoring we managed to
divide it into a set of 26 standard Java
SE modules I'd like to call your
attention in particular to the Java base
module there at the bottom you might
notice that there are no connections to
the Java based model module I haven't
drawn them in because every module
implicitly requires the job at our base
module that's the module you always have
to have it has important classes in it
like java.lang object and java.lang
string so all those connections aren't
draw but Ron but basis already is always
there and of course base does not depend
on any other modules the JDK of course
has these modules plus many many others
including modules for the standard
development and debugging tools service
providers and JDK specific api's since
we have a modular platform we now have
modular dock Javadoc which I'd like to
show you
there we go so this is the front page of
the of the Java 9 dot Java doc II it
gives you some guidance up front is
divided into three sections SC the JDK
and Java FX at the bottom you can see
it's organized this frit therefore this
front page is organized by modules so
you can go click around let's look at
look at the Java base module here we go
there's the base module it's got a bunch
of the usual stuff in it Java Java Lang
was all those important things we can go
back say and look at what's another web
no not that let's look at a more
interesting module Java dot sequel
rosette so see Quattro set is more
interesting model because it depends on
some others we can see that here the
export the packages that it exports and
then later on we have in the Java doc a
specification of what are the additional
modules that it requires in turn and if
you just want to get to want to learn at
a glance what's going on you can go up
here and there's a little hover bowl
thing here you get the an image that's
shown you and this is actually generated
by the JDK build you can zoom in on it
if you like that shows you the subgraph
of the module graph for just the java
sequel rosette modules means if you
require Java sequel rosette you're gonna
get all of these others ok if we go back
to the deck please
all right since the platform is modular
it's now scalable most applications
after all don't need all of these
modules and now we can reliably
configure consistent subsets of them for
example if we have a module that just
needs the job at at sequel module and
whatever else
Javad a sequel happens to need we can
configure a custom runtime system that
contains just those all the other
modules just fall away we produce these
new these custom runtime systems with a
new tool in Java 9 called j-link job
finally has a linker it's it's an
optional step but it's a very important
one you can switch back please
all right so I packaged up a little demo
here let's take a look at it it's org
open JDK hello hello world I know very
very original let's take a look at the
code so this is a tiny little web
application about the smallest you could
possibly make here's here's that here's
the main class the only class in fact
this uses the built-in Thomson net HTTP
server API it's been in the JDK for a
few release is now very handy if you
just want to want to whip up a little a
little app that talks to the web I want
to explain all the boiler boiler plate
here but the important part is the one
the method that makes the content and in
response to any request it doesn't
matter what it's gonna build a little
web page that that says hello modular
world tells you what time it is and
gives you a list of the modules in the
running image so it's just using the
stream API to get a stream of all the
modules and then format them nicely it
uses the Java sequel timestamp class
just for amusement in order to show the
time of day let's take a look at the
module info here we go
very simple module he requires two
others Java Siegel jtt JDK HTTP server
and it doesn't export to any API is
because well it doesn't need to it's an
application okay let's compile that I've
just prepackaged up the steps here to
make it easy now we've got org open JDK
hello jar we can look at that look at
that and we see inside we've got just
not only the traditional manifest but
our module info dot class okay now I
could run this directly but what I'm
actually gonna do is run it in a docker
image I'm gonna make a little docker
image here there's a little docker file
that just runs this this hello world app
on the class path using JDK 9 this is
using that the early access build up JDK
9 that you can get from Oracle for allit
for alpha and Linux so it's it's more
compact let's make that docker image
don't worry their message is normal goes
off it does the doctor thing add stuff
read stuff da da da whoops
no let's run it and let's see if I go to
localhost
hello modular world this message brought
to you by all those modules only a
handful of which we're actually
necessary alright so let's look at
something let's do something better
let's make let's link a custom image
this custom image will have just the
modules that we need so I'm using the
Alpine Linux build the J mods from there
that's that's what this deaths with this
the module path up here is specifying I
add the modules that I need I tell it
just for amusement that there's a
launcher command named hello and I do
some compression and drop the header
files and skip debug information to make
it small so I've got a custom Gary here
if I look in its bin directory it's got
a little hello command along with Java
and well keto Tiki tool because and it's
nice and compact 33 megabytes right
whereas if I look at my docker image
images that I just image that I just
built about a minute ago
it's 266 megabytes ouch okay so now I
can make a docker image containing just
this
and that new image is a mere 38.9 will
round up to round up to 239 megabytes
and I can run it and now we see we
relived this page tada it's just the
subset of modules only the modules that
we linked in alright if we can go back
to the deck please
okay so the modular platform is scalable
and that's scalable in a technical sense
not the not the people community sense
that Mark mentioned earlier but it has
additional benefits strong encapsulation
means that we can conceal the internal
api's of the JDK this makes the platform
more secure by limiting the damage that
malicious code can do it improves
platform integrity by ensuring that
libraries and frameworks and apps don't
depend upon the internals of the JDK and
finally it helps make the platform
faster link time is an excellent
opportunity to do whole system
optimizations such as resource
compression early verification and ahead
of time compilation plus a whole slew of
others we've implemented some of these
in JDK 9 there are more to come we have
a module system now in a modular
platform you might be wondering well
what about existing code do I have to
convert all my code into modules in
order to run on JDK 9 no you don't
earlier I described the module path as
something that's better than the class
path but it is just an alternative the
class path is still there in fact the
two can peacefully coexist jar files on
the class path can even refer to api's
that are exported by modules on the
module path ok good so the clasp bonus
path is still there it still works but
you might have heard jigsaw breaks
everything that's not true
jigsaw breaks some things
remember one of Java's core values is
compatibility we took this extremely
seriously in project jigsaw that's one
reason why it took so long if an
existing application runs on JDK 8 and
if your code only uses standard Java SE
8 api's then it will most likely work on
JDK 9 without change I said most likely
here for a reason there are some minor
differences we removed a few obscure
rarely used methods and mechanisms to
enable a clean modularization of the
platform otherwise it simply would not
have been possible
we deprecated these ahead of time in
Java 8 now what if your code does use
some non-standard or JDK internal API
and by your code I mean not just the
code that you write yourself but the
code and all those libraries that you
downloaded from maven central over the
years but if those libraries use
internal api's or depend on other
internals if your code depends upon JDK
internals then it may require change
even though many of these changes are
pretty obscure they have obscure they
have affected some popular libraries and
frameworks and tools happily in many
cases they're maintained errs have
already fixed them I wanted to get an
idea of what is actually ready to run on
JDK 9 today so I asked a question on
Twitter last week do you maintain a
popular Java library framework or tool
if it works fine on JDK 9 then please
reply with its a name and version thank
you to everyone who replied here's a
list all of these things work fine on
JDK 9 probably a lot more stuff does but
these certainly do there are some
important things in this list for
example all the major build tools ant
maven and Gradle are there J unit tests
and gr they're essential libraries like
Jackson log4j hibernate bide buddy and
so forth and yeah the whole spring
framework itself just released runs fine
on JDK 9 so I keep talking about
internal changes you might might wonder
exactly what do I mean well let's look
at a couple of examples one is our old
friend arctic jar our key jars is a zip
format file it's been in the JDK since
1.2 contains all the internal classes of
the JDK this file no longer exists in
JDK 9
it no longer exists because we replaced
it with a file in a much more efficient
format and there was just no reason to
keep it around but they're a bunch of
tools that read this IDs in particular
use this to figure out what's in a JDK
so what we did was we provided a
supported way to get at this information
there's now nyow virtual file system at
the jrt uri you can open that up and
grumble around and it just like used to
grumble around in our queue are another
example is the Sun security x509 x500
name class for manipulating X by X 500
distinguished names this has been around
for a long time there's actually been a
standard replacement for it for quite a
while in fact that standard roof
replacement has been there since 1.4
nonetheless there are many libraries
that still use the internal class and
the problem is all the sun security
packages are strongly in capsulated now
what does that imply in JDK 9 well in
general if your code uses JDK internal
api's then it will not compile on JDK 9
and it may generate warnings at runtime
now wait a minute
you you might be thinking why won't I
get errors at runtime like you showed
earlier for the secret class in compo
util if I have a jar file built with JDK
8 that goes and tries to construct one
of these X 500 name things why don't I
get an error message like this the
answer is a lot of developers deployers
and users just aren't ready migration
takes time migration from bad habits
especially can take time
so we've deliberately relaxed strong and
capsulation of legacy jdk internal
packages in jdk 9 at runtime only so
that old code will continue to work for
a while but I do mean for a while
eventually we went to JDK to enjoy all
the benefits of strongly capsulation
that I've mentioned earlier so we will
eventually re-strengthen that so the
addendum to the statement is in a future
release code like this will not run to
help you get ready for that future in
JDK 9 there's a new tool called Jade EPS
that you can run on your own code if you
run Jade ups with the Jade with the JDK
internal
flag against a jar file or a class file
it will go do some static analysis to
figure out most uses of internal api's
and suggest standard replacements if
they're available I highly recommend
that you check it out it's been a long
road to jigsaw it's been a long run to
design and deliver it it will be a long
road to it's wide adoption and that's
perfectly fine many of you will make use
of the newly modular modular nature of
the platform long before you use the
module system in your own code using
module and new code is relatively
straightforward modularizing existing
code however can be a lot of effort as
we learned with the jdk itself if you do
modular eyes jigsaw does make it try to
make it easier by providing tools to
support both top-down and bottom-up
migration you can modular eyes your own
applications before all of their
dependencies have been modularized and
if you maintain a library or a framework
I encourage you to publish a modularized
version of it as soon as you can but not
until all of its dependencies have been
modular eyes from the bottom up jigsaw
is a strong foundation for the future of
Java it also supports the broader themes
we've discussed here today it's scalable
as we've seen it's easier to evolve and
it's easier to evolve more nimbly we can
now remove entire obsolete modules we
can deliver new yet non-final api's and
incubator modules for early testing and
feedback and thanks to strong
encapsulation we can change the
internals of the JDK whenever we need to
jigsaw of course has been part of the
open source JDK project developed in the
open JDK community so it's open as well
we've received tons of valuable feedback
along the way thank you everyone who
contributed good insights and
experiences and I'd also like to thank
the long-term contributors to jigsaw who
in some cases have been on this project
for almost as long as I have for more
information you can visit the jigsaw
project page in the open JDK community
if there are links to all of the jep's
the JDK enhancements proposals and the
jsr for the standard parts of the
modules
in itself my colleagues and I are giving
a number of sessions this week
these are the times they all happen to
be in Moscone Rhett West room 216 you'll
notice the prepare for JDK 9 by Allen
Bateman was given this morning there are
likely to be repeats of all of these
sessions they just have not been
scheduled yet so pay attention to the
online schedule and you can probably
still see it at some point
Alex Buckley will present the middle two
and I'll present the last two for an
even deeper dive I highly recommend a
new book just out from O'Reilly Java 9
modularity by Sandra Mack and Paul
backer it's a comprehensive and
pragmatic guide to both the module
system and the modular platform and of
course there are other books that cover
jigsaw 9 and they're either available
now or or will be very soon so jigsaw is
here it's part of Java 9 but it's not
the only part there are many other great
features in 9 large and small I'd like
to show you a few of them right now
all right so the first is J shell I know
I talked about it last year but it's so
cool I just have to talk about it again
J shell is finally Java has a
redeveloped print print loop woohoo you
can type little expressions at it
you can declare variables and assign the
values it has tab completion I can do a
hit tab right here and it says oh
there's a length method you can invoke
that you can even show you the
alternatives that you have at any given
point
so here's substring and now I can type 0
comma 3 and just get foo you get the
idea J show is extremely handy for just
doing exploratory programming and
figuring freaking out what's going on
before you write actual code not gonna
work now of course it's not is that yes
and it's got history so you can go back
actually save your history for a long
time your stuff I did like three days
ago okay that's cool so another another
cool thing in Java 9 is collection
factories how many people wish job ad
cad literals for collections yeah it's a
pretty common request going back many
years well we thought about how to do
that and it turns out there's no great
way to do it but we now have collection
factories that makes they make this much
more convenient you just need to create
a little collection that's got constant
content in your code today what do you
do well you do something really boring
like a raised dot as lists of you know
what do we what do we do or you do this
you know when you think about its kind
of stew because it makes an array can't
they need these two strings and then
converts them to a list it's like oh
well that's dumb yeah we can do that
what if you wanted up what do you got
what if you actually wanted to make a
hash set well you can do that new hash
set and yeah that works but oh yeah you
wanted to make that unmodifiable because
well it's a constant constant hash set
it shouldn't it shouldn't be modifiable
collections dot um modifiable whoo set
tab completion for the win
now and now it's an unmodifiable even
worse suppose you wanted to make a map
how do you make how do you how do you
make a constant map well there's no
there's no syntax for that there's this
really gross dirty ugly hack some people
call it the double braced idiom I'm
gonna show you this but you have to
promise not to use it
yep why did you run no no oh yeah thanks
see history is great okay I just made a
hashmap but at what cost I had to create
you know there's a there's an internal
left there's an anonymous class created
just for this purpose
oh geez it's it's it's insane so happily
we have a much better way to do this in
Java 9 there are some convenience
factories on the private the primary
collection interfaces I can now say
lists list of it makes me list I can say
set of I can even say map of and there
you go maybe not quite it quite as slick
as built-in as lent built-in language
feature for it but it's just about as
good okay another cool feature is Java
Docs search you might have noticed that
my browser got tripped up on this little
earlier let's go back to that Java doc
page Java doc now has a search box you
can type it you can type things up here
it's all--it's it doesn't talk to any
servers this is entirely in the browser
shows that JavaScript actually is good
for something so suppose we wanted to
see the Javadoc of that mapped out of
method that we just used it does does
you know search ahead tells you all
their all the alternatives means here if
you look carefully how we implemented
like the first ten combinations as
explicit methods Justin just to be
efficient but in the worst case it'll
take an array of elements so map of
click on that
whoops click on this and boom there you
go you can find the entire module
suppose you want to learn about goggle
the new module java.lang module contains
API is specific to the module system
there you go there's java.lang module
you can scroll around in it learn about
what's in there
you can also yeah let's let let's look
at a couple other other modulo here's
here's here's a popular module
so here's korva it's got this little
graph you can find out what things that
exports what things that requires it's
all that all that information is there
now something I'd like to point out
about this is this annotation the
Corbett module as well as some others
have been deprecated in Java 9 we've
enhanced the deprecated deprecated
annotation to include a since value
identifies the reason release in which
it was deprecated and for removal if
we're removal is true that expresses the
intent to remove this so beware CORBA is
on a limited lifespan ok could we switch
back to the deck please
ok so that's just skimming the surface
of some of what's in 9 of course to use
to use 9 you know most people won't be
like me and use emacs in the command
line most people use an actual IDE all
of them all of that well sorry IntelliJ
and Eclipse already support support Java
9 and that means I'm told will support
it pretty soon to demonstrate how
IntelliJ IDEA in particular supports
Java 9 I'd like to welcome you Jean
Petrenko from JetBrains
hey Jean what have you got for us thank
you for having me
so I have a demo with IntelliJ and
currently I use IntelliJ 20 17.3 this is
an early access build so anything can
happen okay so this is a small
application and just prints hello world
it prints the version of the Java
machine and then it prints the module
which is associated with the cause as
you know in Java 9 anything is a ativ
cast is associated with the module even
if it's on a class path yeah exactly so
little tricky yeah and here have a
really nice thing this one is associated
this main class is associated with an
unnamed module and here's why if we take
a look closer in the combine we see that
IntelliJ still runs it with a cross path
so it is deftly the same way is we tend
to start our applications like years for
years and to benefit from our modules we
need to turn this application to module
our application so for that we can
simply create the module info in the
root of sauce folder like this so we
call it some kind of org demo for
example and in here you have anything
what we need anything which we use to
code completion for example it helps me
to write anything I need and so on
so if we turn back closely to the my
example we have we have a compilation
here over here and the problem is that
the MX beans on the little green and
Java the base writing some Java
management module right yeah right so
and if we take a look on on a highlight
so it shows us that we need to include
this requirement to make it work and
instead of typing it manually I can
simply click here and say please include
it for me and if we switch back we see
that there is now I requires that does
the trick for us so now let's start this
application once more so if I started
here we see that the module of my main
class is now exactly the same as a
sapphire over here and if we take a look
closer to the conga line what we have we
see that intelligent stands that this is
a medieval rest application so do you
model path minus P for sure any module
to start it that's it
and of course dealing with one module is
not that interesting so let me switch to
another example here so I have some more
information here and if it's tricky to
understand what's going on here I can
just navigate between modules for
example I can take take a look one into
Java sources if I need some information
or insight for example what packages
that experts or what services it uses I
recognize that model declaration here so
and if we need to take a look like from
the height how how am I dependencies are
so I can do this one so I can any
diagram I see that my module depends on
some three modules there are transitive
dependencies sound static dependencies
for example I can navigate over here and
see this aesthetic Aquarius this is
transitive requires and so on so and for
example if I decided to add some more
requirements for my applications say I
decide to use that one I can switch back
and take a look how it looks like now
and if you take a look closer to this so
far we see this highlighting this is a
really nice feature Java 9 and it's
called it's an ability to say in a
duplicated annotation that it's going to
be removed so it's not it's it's kind of
various thing that IntelliJ shows it's
figuring that out and striking this out
- yeah think about using something else
but of course it would compile but still
it's quite verbis now and you see the
year over here and the right top corner
showing that there is a problem here
cool cool and I really like this one I
tend to write Java code for years and if
I need some unmodifiable wait I told you
not to use that oh really
sorry I can I gotta fix it now yeah
horrible an idiom - a new API excellent
yeah okay thank you very much Eugene
that's great
so Java 9 is here at long last what
comes next
to understand more about the future
let's take a brief look at the past for
20 years
Java SC in the JDK have evolved in large
irregular and somewhat unpredictable
steps each release has had one or a few
really big features and the schedule of
those releases has been adjusted as
needed
sometimes more than once in order to
accommodate those big features that's
good for the big features that gives
them time to bake but it's bad for the
smaller features because that means it
take can take a long time to deliver
them even if they're ready long before
the big features are finished so we wind
up with releases that are grand and
majestic but they're just rather
slow-moving for Java to remain
competitive in this day and age it must
not just continue to move forward it
must move forward faster that's why
we've proposed doing a new feature
release every six months on a strict
time-based model and this bottle
features go in only when they're ready
if a feature misses the current released
that's okay because it's only six months
until the next one it's not that big a
deal we think this is a good balance
between fast enough to deliver
innovation at a regular pace and slow
enough to maintain a high level of
quality so the next feature release is
five months away March 2018 the one
after that will be September 2018 when
after that will be March 2019 there will
be a long term support release every
three years starting in September of
next year so if features are going to go
in only when they're ready then we need
a pipeline of features that we're
working on so that when a release comes
around we can light bind to it and
figure out okay what's ready let's let's
put that in and ship it we've even been
investing in that pipeline for years in
the open JDK community here's some
examples project Panama seeks to improve
the connection between Java and native
data and native native code project
Valhalla is about specialized generics
and value types project Amber is right
as about right sizing language ceremony
and a new project not yet proposed but
being discussed right now is project
loon which will aim to bring
continuations and fiber
to the Java platform to greatly simplify
concurrent programming to help us learn
about one of these projects please
welcome Brian gets our java language
hey Mark hey bright so project amber
what do you mean exactly by right-sizing
language ceremony well you know as you
might have noticed Java has a bit of a
reputation for being a little bit
boilerplate intensive maybe it takes a
little too much code to do a lot of
common tasks and so you know project
amber is a is really a collection of
smaller features that are aimed at
reducing the overhead or the ceremony of
things that we do every day streamlining
you know everyday coding but also making
code more readable and more reliable and
you know these are features that we can
deliver over time and I think a lot of
them are a very good fit for the kind of
programming models that are popular in
the cloud like the function as a service
demo we saw earlier or reactive event
event based systems you know like
message based systems or actors right
right so I know I know what when one of
the sort of sub projects of amber is
called local variable type inference
yeah what's that all about
okay so local variable type inference is
is a feature that we've seen in a number
of other languages you know before Jabez
had type inference for many years and
we've used it in in some places in the
language and we've expanded the set of
places that we use type inference so you
know over over time type inference is
basically just the compiler figuring out
the type of something without you having
to write it down and you know it can
make code more readable by getting
unnecessary information out of the way
and so we you know this next iteration
is simply extending that to the way we
declare local variables you have an
example anything yeah so here's some
typical Java code so you know the way
you have to you know declare things in
Java is you say the type first and then
the name but one of the things that
we've noticed is that at least in
well-written code the name is actually
more important than the type because it
talks about how the how that variable
what it means in your program not across
all programs and so if we allow the
compiler to infer the type for you well
the effect the effect that it has is to
sort of bring the name more front and
center and put some more important
information where we can see it like
this like this exactly
so the almost the first thing you see
are the names and of course if you pick
bad variable names then your code will
be unreadable but we might never pick I
never I never do that either no no but
this is not dynamic typing or this is
not dynamic typing it's full static
typing that were the same static typing
we've always had it's just the compiler
figure
out the type of thing from information
that's already in your program great
okay um when can we have this so it is
already committed this will be you know
either this has been committed to the
JDK ten repositories and should be you
mean you mean eighteen dr. 18.3 yes that
right there's the actual commit message
from last week Maurizio's commit so it
will be in a production release in March
excellent
that's very cool so what else is going
on in amber okay so the next thing I
want to talk about is actually a much
bigger feature and it's a feature I'm
really excited about it's called pattern
matching so a pattern matching is a
feature that's been around it's been
associated historically with functional
programming languages and more recently
you started to see object-oriented
programming languages like C sharp and
Scala adopt this feature as well and we
think it's a really good fit for Java
and so sort of to motivate would you
know why we think pattern matching is
interesting Minh has the ability to
simplify the kind of code where you have
to do multi way conditional operation
write code like this code code like this
so your hands in an object whether it's
a parameter or you've read it in from a
socket and it's gonna be one of ten
different things and if it's this you do
this and if it's doesn't do that and
this is how we write this code today and
on the one hand there's nothing wrong
with this code cuz it's really kind of
what you have to do on the other hand
there's like everything wrong with this
code right so it's verbose right it's
repetitive and the problem with
repetitive code is it tends to be
error-prone you know we do this by cut
and paste was that a secret and I said
that yes it was and it's easy to make
cut and paste errors and you know the
repetition is is it's really
overwhelming right so not only are we
saying are you an instance of this or
your instance of that but after we do an
instance of test the next what's the
next thing we do absolutely cast it like
but what but but no what else were you
gonna do right so so there's a lot of
repetition in this code and as a result
these are places for bugs to hide we can
do better we can do a lot better so
morally the code on the previous slide
wanted to be a switch but switch is
really pretty limited switch can only
switch on certain types it can only
compare against constants and so you
know if we enhance the switch statement
to deal with patterns
is what we've done here we can make this
code a lot easier so what's the new
thing that's going on here are these
case labels they're not constants
they're patterns and a pattern is a
combination of an applicability test are
you an integer with some kind of
conditional operation that you're gonna
do if the test succeeds cast it to an
integer and bind it to a fresh local
variable which in this case is called I
notice and so already the code is
becoming more readable and it's more
obvious what's going on because we've
eliminated a lot of the Krofft
but you can still see there's still some
repetition here we're kind of doing this
in a very roundabout way where since the
switch is a statement not an expression
we have to make an assignment in every
arm of the switch statement and it's
easy to forget to do that in one arm and
if your tests don't have good enough
coverage you just have a bug that that's
long around so we can make this example
even better by turning switch into an
expression like this right exactly like
this and so now this is probably the
code that whoo that you had in mind when
you were writing the code on the first
slide in the first place but you
couldn't write it like this so you had
to write it in this very round of that
way so this is code that's more readable
more maintainable much less error-prone
and as a bonus faster because you know
the first code was a linear chain of
tests but by expressing it as a switch
the compiler can turn this into a sition
tree that's probably gonna be faster as
well so you less verbose less
error-prone
faster great perfecto so so pattern
patterns are cool but these seem fairly
because somewhat limited can they be
generalized to bigger cases yes so this
is a really simple example but more
commonly when when we're called upon to
make a multi-way decision
we're handed complex objects which we're
gonna destructor and take out their
state and then do something with so you
know as an example like let's say you
know we have a hierarchy like this where
you have a shape and you have circle
implements shape and it has a center and
a radius and square implements shape and
it has a corner and an edge and let's
say we want to like calculate the the
area of one runs things so we know it's
gonna be one of these three things we
know we're gonna have to take them apart
so we can use what are called
destructuring patterns to to rip through
all the boilerplate that we would have
had to write right I mean so if we were
writing this the old way it would either
be big nested ugly if-else or even where
visitors yeah so pattern-matching lets
you express this in the sort of direct
way that you want it in the first place
so you know what we're saying is we're
switch on the shape and we're saying is
it a circle if so cast into a circle
extract its center and you know radius
set up properties and then use that to
compute an expression for the area of
the circle and similarly for the square
and similarly for the rectangle so it's
it's kind of saying what you mean
without all of these layers of
boilerplate very nice now that now
that's up that's a much bigger thing
than var right so it's gonna take some
time to do this how are you gonna do
this given that features are only going
to be feature releases will only be six
months apart so you know we're gonna
break it up into smaller pieces right
you know so you know the the first
example we showed was type test patterns
we can do that first and then we can add
more different kinds of patterns more
different places in the language to use
patterns over time although no way it
makes the job harder because we have to
be really sure that we're laying the
foundation first the thing we ultimately
want to do yes we do yep all right thank
you very much Brian thanks mark
the project amber is just one of one
example of the long-term investments
we're making in in Java there are other
large projects not just the ones listed
here but but but many others there's a
continuous pipeline of smaller features
that are smaller but no less important
we hope that all of this work will not
just keep Java moving forward but moving
forward faster thank you very much
all right thanks mark and Brian well as
promised
you got to see a lot of interesting
things today and there's a lot more
interesting stuff to happen at the
conference one of these things I will
mention tomorrow there is the Oracle
code keynote it's at 4:15 at the
Marriott Marquis and you won't want to
miss this
Patrick Dubois is generally regarded as
one of the founders of modern DevOps and
Buster Benson is from slack please go
and check it out it's free for all
JavaOne attendees thanks everyone and
enjoy Java one
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>