<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JVMLS 2015 - Code Coverage Instrumentation | Coder Coacher - Coaching Coders</title><meta content="JVMLS 2015 - Code Coverage Instrumentation - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JVMLS 2015 - Code Coverage Instrumentation</b></h2><h5 class="post__date">2015-08-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IXimJsjpeLg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is me my name is Eric Bjerknes
I work as contig on the region ite
consultancy and I'm based in Trondheim
Norway and as most of you know Norway is
not the capital of Sweden it's actually
they are separate countries so in
preparing for this talk I've been
watching most of or maybe all of the
videos I could find online from the from
the language summit and there seems to
be a recurring theme or at least a
recurring slide which is the legal slide
I could not afford a lawyer so I had to
make my own legal slide and here it goes
the following is intended to make my
mother proud unfortunately she is not so
happy with Java because every time she
does internet banking there's a new
security update OMG there are some sharp
brains in this room I'm not nearly as
smart as them will they see me for the
fraud I am or will I be able to fake it
let's get this talk started and we'll
find out but first we need to update
Java and we're ready so one of the
things that I really like to do when I'm
not in front of a computer screen is to
hike and climb mountains and sometimes
when you look at the mountain for the
first time from afar it can really look
really hard or maybe even difficult or
maybe even impossible to get to the top
and but then you you sort of text take
small steps and eventually you reach the
summit and you can look down and be
proud of your achievement and for me
that's also the same in software and for
me code coverage tools it was 10 years
ago it was one of these difficult
mountains to climb and I really wanted
to to be able to stand on the top and
know how it all worked so in 2005 I
created my first code coverage tool it
was called
Dec was very basic I just proved that I
could make it
and this progressed into a more
feature-rich - I think one of the
innovations of this tool was that I
would display each line of each class as
a vertical line and each line of code as
a pixel on that line on that vertical
line and color them by not run run and
and recently run so when you start your
application it would look something like
this where the coverage would be
visualized and if you reload your code
you will sort of see the code glowing in
the dark as it's being used then came
the next step which was dogmatic MVC
everybody has to create their own web
framework it used to be a very popular
thing of the day and it's called
dogmatic MBC because it enforces that
you have tests for your code and that
these tests have a hundred percent test
coverage and that your tests actually
find injecting bugs so here's a
controller in dogmatic you annotated
with a request handler and in this case
we have we write hello world if you're
from a remote address and hello local
host if you're from 170 27.0 that's here
that one so let's say we run this from a
remote IP we should expect to get hello
world so let's try that
okay dogmatic has intercepted our
request and it says seriously no tests
we're sorry but the dogmatic and we see
just doesn't trust untested code please
create a test class add the test with a
notation on your handler method so let's
do that we add a test ok so now we
should get to the world no we don't your
test coverage is too low your coverage
is 66% and
needs to be 100% and it shows us the
line that it's not covered so we add a
test for the local host conditional so
now now do we get hello world no we
don't we get this which is saying that
you're not asserting much in your tests
huh we inserted some bugs in your class
your tests did not catch these bugs
please add some more assertions to your
tests and we add some assertions and now
finally we get our hello world so the
feedback I got from this after
presenting it to a user group in Oslo
was please don't open source this to my
manager will force me to use it and my
life will be miserable I do not care I
open sourced it anyway so I think an
important lesson for me from developing
this tool is that you can claim to have
100% test coverage but it doesn't really
mean anything until you know how how
well-suited your tests are to uncovering
external bugs in your code having a
hundred percent test coverage usually
just means you're you're exercising
you're cold you're not deserting so the
next step was revoke and a new thing
with this tool was that it's
browser-based it has an embedded web
server and it pushes your updated
coverage data live over WebSocket to the
browser application and in this tool I
started focusing on performance and when
you focus on performance this is what
happens to your code it gets really
really ugly unreadable and maintainable
and I'd like to say that experimental
optimizations it's like sea fog
covering your cold it's hard to see
what's what's really going on I think we
can all we have all experiment
experienced this from working on
optimizations so what do you do when you
have coded yourself into a corner
yes that's Jason I I go to the winter
tech forum it's the conference in
Crested Butte Colorado used to be called
the Java potty roundup and this is brew
cycle is organizing this conference it's
an open space conference so we have open
space sessions in the morning and in the
afternoon we have usually snow related
activities and on Wednesdays we have a
hackathon day and this is where you can
suggest the project and you can gather a
group of people and work on that project
and in the evening there is a demo and
the presentation so I suggested that we
made a live code coverage engine from
scratch in one day and a few brave souls
joined me DJ Demetria Todd Jack and
Marshall who's in the room Marshall
there and in one day we created sky bar
which is next version of the code
coverage tool the name comes from
someone said that we were setting the
bar really high
and I thought in Crested Butte the sky
is really the limit
so that's sky bar and 30 minutes before
our demo we got this from hotspot it's
Bloody Mary even though there yes you're
there yeah I reported this bug I turned
out to be already a reported bug but
Vladimir was very helpful in analyzing
it and helping us figure out what was
going on going wrong so thank you yeah
thank you for upping
yeah so for me it's been a kind of a
progression of tools I think that was
about making it work dogmatic committee
was about making it fun
Reebok was about making it fast and and
sky bar was about making it sane making
it maintainable understandable usable so
this talk is going to focus on Sky Bar
and revoke and performance aspects of
those tools so the code coverage problem
is actually pretty simple you have some
lines of code and you want to know how
many times does these lines or branches
if you dimensional a branch coverage how
many times has each line being executed
some tools sort of cheat and they don't
they only they have a boolean flag
telling if the if the line has been
executed or not I want to count the
actual number of times the line has been
executed for reasons that we'll discuss
later so the design of sky bar is pretty
simple it's a Java agent that has a
closed file transformer which will
instrument the user white code and this
user this intermitted code called back
with counting to registry which is made
available through the embedded web
server which pushes updated data as JSON
over WebSocket to the browser where
there is a JavaScript based application
so a simple way to to create a
comparative is to instrument to look for
line number instructions and then inject
a method call which will count that line
line 18 in this case as being executed
so that's pretty simple but the
interesting part for me is how do you
make this run
as fast as possible and when you look at
a simple method like this it takes an
integer and returns the absolute value
the naive and simple straightforward
approach would be to just inject for
each line number instruction in the byte
code the byte code needed to recall
account method for that line and this
works well for simple methods but if we
have loops and tight loops in particular
this can be very very expensive so here
we are looping over integral Max value
number of times so that should give us
four billion invocations of the count
method and that's not good so what we
can do to improve this is to inject
local variable counters for each line at
the beginning of a method I'm not
covering that but we can talk about that
later yeah you need inject these
counters and then you use the I Inc byte
code to increment the count per line
number and then in the end in this case
we have only four invocations of the
count method one per line so this saves
4 billion invocations which is pretty
nice
so not all methods are really that
simple I don't know if you can see
what's going on in this method at line
11 there is
arithmetic exception division by zero so
if we report at the end of this method
our return is really never reached so we
would lose the count from line 9 10 and
11 we would get no counting of that
method so to solve that and to make our
to a true correct we need to wrap the
whole method in a try finally block or a
try-catch block in byte code and in the
finally block or the catch handler we
need to do reporting of all the lines so
if the method exits normally it will
exit through the instrumented return
otherwise it will be instrumented or
counted through the finally block
however many methods are or most methods
I guess don't throw exceptions
they're quite boring they take some
money from one account and they steal
some of that money and make a profit and
then they update the account with a new
amount and maybe they do some auditing
and it's all pretty unexceptional so in
general I think we can say that most
code lines when executed will not cause
an exception and most code lines are not
inside a loop and I think most it's safe
to say that most code lines will run
once and only once per method execution
I don't have proof of this but it's just
an assumption so I we can assume that
all lines are run once and this allows
us to save
counting because we can count the method
as being run and then we can statically
know which lines of code would be
executed as part of running a normal
normal execution of that method and if
there are exceptions to to our
assumptions about a code a line of code
is running only once then we can report
that line as if it hasn't been executed
as low as running minus one time which
will cancel out the account from the
method I can explain that later maybe
tomorrow evening yeah I'm not over 40 so
I think that's the reason so many
methods are complex and dirty and ugly
they have loops and they throw
exceptions and they have multiple return
points exit points so I think the
assumption that every line is run only
once it is a very weak assumption it it
gives us a bit of performance but it
doesn't really give us good performance
for complex methods so then I got the
idea can we statically analyze a method
to try to figure out at load time which
lines must have run and which lines
can't have run and if we can avoid
counting those lines we can save a lot
of counting so in this method these
lines must have run exactly once when
returning from line 20 and if returning
from line 18 then line 20 cannot have
been run so it must have run zero times
and then there's the the lines that are
inside the conditional or inside the
loop and who knows how many times these
lines have been run and those lines we
need to report but the other lines we
know statically that they have been run
once or 0 times yeah this just repeats
that same point basically we can skip
reporting for statically known lines so
how can we implement this I sent an
email to the ASM library mailing list
describing this problem and asking for
input on possible solutions to this and
I got a response from Elliott moss after
some discussion and he says something
about dominators or actually post
dominators and then he says the details
would need a little bit of work and this
was May 23rd in 13 so Cochlear's ago I
looked on Wikipedia on the page on
dominators and I thought hmm hmm and hmm
and then two years later I had this
epiphany that was that I don't really
need to understand this algorithm I just
need to be able to implement it in Java
and I'm done so it worked the only issue
is that as any sheep can tell this
algorithm is not cheap it's a quadratic
to the number of nodes in the control
graph so I have not been using it we
have been using it in Skybar it
partially implemented in revoke but it
needs work before it can be practically
practically used for large methods
because it will slow down the startup
time of your of your program question I
I have not considered that doing that
because I want to sky bar is a Java
agent so it sort of this time to to but
yeah it's yeah yeah it's definitely the
possible thing to do yeah sure yeah
question excuse me I didn't hear that
I'm I don't know what that is we need to
talk later yeah so so this part of the
talk we have discussed optimizing the
instrumentation of accounting and now
I'm going over to discussing
implementing the counting itself so the
speed of the count registry so the that
problem is basically for each line you
need to look up the counters for that
class then you don't need to look up the
counter for the line and when you have
that you need to add some number of
executed lines to that count and you
need to write back the updated count and
of course all of this needs to be done
in a thread safe manner so I think the
the first approach that I tried was just
having a map of maps where each
using the class name or the source file
name and pointing to a map of line
number 2 num number of executed
execution times for that line and then
just wrap it in synchronized and yeah
unsurprisingly that's pretty slow it's
about as slow as cobertura if anybody
has been using cobertura it's it's this
slow yes slow so one way of improving on
that is to not use map of maps but to
assign an index to each class as it's
being loaded so in this case we can say
that the abstract singleton proxy
factory beam has index 0 and at line 9
which is the first line of the test code
gets index 0 and so forth and this
allows us to have instead of a map of
maps we can have a two-dimensional in
array and we can replace map get
sandwiched with array load and erased or
instructions and that improves things
quite a bit so a bonus trick related to
that is that we can move the lookup of
the class data to generated class
initializer
I think it's called in byte code and
this has the additional benefit that
you're also moving the synchronization
on that array to class loading time and
we get to replace the array load with a
get static field which I think might be
faster I'm not really sure but I guess
there's there's people in this room who
would know it is yeah ok at this point
Java 7 came and I read about invoke
dynamic and
as normal Enterprise Java developer I
couldn't really find any use for it in
my day-to-day job so I really wanted to
see if I could use it in a code coverage
tool and I thought about it for a while
and then it occurred to me that what
these tools are doing is they're
reaching out from the instrumented code
trying to get to the counters so that
the counters can be updated and that's
expensive so maybe we could use in more
dynamic to get the right counter at
bootstrap time and speed things up that
way and it turned out to be really
simple so in the bootstrap method or one
of the bootstrap methods of Skybar it
looked like this we are looking up the
long adder for that line of code and
that source file and we look up the add
method of long adder and we bind that to
the to the long adder and return a
constant call sight and then we send in
the source file name and the line number
as which trap method arguments
so one of the interesting things of
working on performance on code coverage
tools just been concurrency and how to
make this run fast on multiple threads
and I think there is I had two
requirements
I want the tool to count correctly so
not not lose counts and I also wanted to
count fast or as fast as possible and if
you look at it
adding a counter for each line of code
in your program it means that you're
introducing mutable shared state on
every line of your program which is
expensive so the first approach was just
to use synchronized to protect the
updates and that turned out to be slow
as mentioned so the next natural step
was using the lock free atomic long
class and that works well until you
start getting into contention it's based
on compare and swap compare and set so
if there is high contention it you spend
a lot of time retrying so with java 8
came long adder which from my
understanding it has multiple cells so
it can sort of spread the updates over
several over more memory and this makes
it slightly less atomically accurate I
guess but it improves performance a lot
under contention so this is the fastest
way I've been able to define until now
but I still think that there is room for
performance improvement of code coverage
tools besides using long adder and I
have some ideas for how that could be
done and yeah let's revisit the
requirement must account correctly this
I think we can change this to must
eventually account correctly we don't
really care if the counts come a few
hundred milliseconds late because our
tool is not equipped to do anything with
that kind of low latency information so
what we need to be able to count
correctly like eventually so one way of
improving this is by using thread local
memory so this allows each thread to to
update or to keep counting in a buffer
which is thread local which saves the
volatile reads and writes to two shared
or volatile memory so the threads each
thread can keep counting on their own
and at some some kind of interval they
will decide to commit their counts into
shared memory and this needs to be done
atomically using the long adder as
mentioned previously so initially when I
looked into this I I got into a problem
which is that getting access in Java to
thread local memory it's really not all
that deficient because its thread local
is implemented using a map which is fast
but it's still a map and it's it's not
super fast which I wanted so I was
looking into ways of trying to
reduce the time needed to get access to
a chunk of memory for that further
running thread yes but all benchmarks
are lies and I don't want to lie to you
so I don't I haven't brought any
benchmarks here today I don't have
numbers but yeah I could probably find
some numbers for you but not now you
know how to fix it okay so interesting
this is a nice conference okay so thread
local trade local map was too slow I
started digging into thread the Java to
see if I could find any state that I
could exploit and I found this there is
a private runnable target field which
keeps a reference to the runnable that
was given to the constructor and this
field seems not to be used at least by
the JVM after the thread has been
started so I was able to replace that
using with runnable that was actually a
buffer at the thread local buffer so
don't tell anyone that I did this let's
keep it a secret
yeah question
okay I did not hear the question I did
not hear the answers but it seemed like
you were able to resolve it okay so
which we should write this down or you
need to come to me afterwards and tell
me about it so a question here is
knowing when to commit from thread-local
memory into shared memory and that's
turned out to be a bit of a tricky
problem you could measure time or use
System nano time but that's just in this
context that's just too expensive in
itself one trick that I tried was to
have a thread that constantly rights to
and up to a volatile that writes the
current time to a volatile field that
incurs the cost of a volatile read and
write or at least three which was too
expensive in this context so what I
ended up with was either keeping a count
of how many times you have written how
many counts you have done and use that
as an approximation of time or to keep
track of the your current stack depth
and do the commits on certain stack taps
so this would typically be useful for a
let's say a servlet where your request
comes in and when it ends it exits up
the stack and you can commit once per
request basically
you're talking about using the time or
writing the time yep okay yeah yeah I
guess we don't need to update time more
than maybe if every 100 milliseconds or
something like that so that could be
interesting thing to try out in the end
for Skybar I just figured this was all
too fancy we ended up using just the
long adder it could be something to
revisit but I don't want to sky bar to
turn into the complete mess that Reebok
was so let's try to keep it tidy so a
couple of things that have caused me
grief and yeah stack map frames I think
I've spent quite a few evenings nights
weekends trying to get my instrumented
code right so that it would not blow up
with verifier earths it's very brittle
it's very hard to get right it's hard to
the documentation is not really all that
easy to digest for me at least but in
the end it's there and we just need to
deal with it another thing that I spent
I don't know how many days
but it was the counters in my tool in
Revit was counting the wrong line and
I've learned to to kind of blame my own
code first so I started looking into my
code trying to debug trying to analyze I
just could not figure out what was going
wrong and I was able to finally to make
a reduced test case and it turned out it
was a bug in Java C and I think this I
must have been there for many many years
and the reduced test case is as simple
as this and the bug was that if you have
a static in your class you would yeah
sorry
thank you
yes that's a nice such a nice place to
be again okay whatever whatever happened
here from the static would ever inner
class something was that the Java Sea
here will generate a constructor for the
class test and that constructor had
wrong line numbers so the line number
from the static class empty leaked over
to the generated constructor of the
outer class which caused everything to
fail spectacularly and this is
documented in JDK eight zero six one and
seven seven eight bug report it was
fixed in no time so thanks for that
okay forward-looking statements it's
quite bar what's next I think for now we
have a speed that's sufficient that
allows us to run the tool in a live
environment
I think code coverage tools they have
traditionally been used as something you
generate and show to your manager that
you have some kind of test coverage and
it's it's all just not very useful I
think you think it being able to use it
in production on live running code opens
up the new set of possibilities for new
features and I'm going to discuss a
couple of them
and these are things that have not
really been implemented yet so I would
like your feedback on these IDs the
first is what I call exploratory
coverage so let's say you have a certain
state a certain count and you take a
snapshot of that a copy and then you do
some action in this case we have called
the dew post method and we take a
snapshot of verse count state at that
point of time we call that B now what's
interesting is to take the difference of
DNA and what we end up with then is is
really the answer to the question which
lines of code were touched by triggering
some action in your program I think this
can be very useful you can find some
button in your user interface you can
click a button and the coverage tool
will tell you which line were executed
as a result of clicking that button so
this can be useful for like if you have
a huge legacy code base you don't really
know where to to start navigating it it
can you can maybe be helpful in
exploring a code base so building on
this idea there's something that I've
called comparative coverage which it's
the same idea but you you run an action
with a different set of parameters so in
this case we're logging in but we're
conditionally enabling the remember me
feature so in the first case where we're
not using remember me in the second case
we are using remember me and if we have
the coverage the differential coverage
for each of these we can compare them
and we can find the lines
called that differ when you are using
the remember be feature so you can sort
of track the user interface into which
lines of code implements this this
feature question you mean statically or
at runtime yeah that's so actually the
next slide which is about detecting
production dead code which is code that
I mean you can statically analyze the
code base and fine code that is not
reachable but sometimes it's more
interesting to alright it gives you an
additional insight if you can watch your
program running and find code that is
actually not being used in production of
course it's it's hard to say because
eventually it could be used it could be
some kind of yearly report
let's run once a year and you don't want
to delete that but it can give you
insight into not only that the code is
dead but the code is rarely used or used
less frequently than you had imagined
yes for dead cold yes you need only once
but for knowing how many times an API
function has been called thank you yeah
yeah I think that that's an interesting
thing because I I'm not a JVM engineer
I'm doing consulting work so I I'm not
intimately I don't know the JVM but if
people have ideas for how this can be
implemented better using tricks from the
JVM that's very interesting for me to to
learn about and part of the reason I'm
coming here for this conference frankly
okay so yeah I think this tool is partly
a profiling tool partly a debugging tool
called exploration tool and I called
quality to its current kind of hard to
say which what type of tool it really is
and if there are any more questions I'm
happy to answer them yeah yes
it works sometimes most of the times
yeah
but not always and that's not good
enough I tried using it but it failed
with exceptions on where it could not
find a commons there's a method called
get common superclass which tries to
find this the common superclass of -
yeah yeah so if you have multiple class
loaders you're yeah I try to do it and
then I decided I don't want to go there
so Skybar is not using what's the
feature of ASM where you enable this X
managed expand frame six something like
that yeah I turned that off so now I'm
hand coding all the steps that my frames
subtlety's when when I just understood
that I I can't use get common superclass
it took just a couple of days for me to
to figure out how to do it without it so
but I guess that's for my case because
I'm just wrapping code I'm not
introducing a lot of new I'm not
changing the stack much
yeah thank you and that's that's a great
feature we haven't implemented it I
guess that would be could be solved by
just triggering re transform and then
removing the transformer yeah
yeah I've also been looking into or
thinking about using the guards in
invokedynamic to sort of maybe collect
some runtime information about how this
method is invoked and then optimizing
the instrumentation strategy based on
runtime information that could be done
yeah
yeah I don't want to deal with that
common superclass for the rest of my
life so yeah okay and we're done
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>