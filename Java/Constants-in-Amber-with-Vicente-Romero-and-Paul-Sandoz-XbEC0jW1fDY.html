<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Constants in Amber with Vicente Romero and Paul Sandoz | Coder Coacher - Coaching Coders</title><meta content="Constants in Amber with Vicente Romero and Paul Sandoz - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Constants in Amber with Vicente Romero and Paul Sandoz</b></h2><h5 class="post__date">2017-07-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XbEC0jW1fDY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so this is actually although Center
myself for talking this is actually a
whole team effort it's not just me and
vicente in fact this mostly not me it's
Lois and there's marriage she Owen is
Brian and there's a little team effort
here doing it so this is actually quite
interesting I didn't realize when I
doing his presentation how deep you can
go into Constance and go down the rabbit
hole of just this area so there's
another rabbit hole for lawyers if you
want to but but that's more interesting
this is from Jeb Dinkins
a resident gook artist so this is Duke
encrusted in amber think of bejeweled
constants in your constant pool and
don't mistake this for thinking that
Java is trapped in the past in time it's
certainly not as you see in this
conference Java is very much moving
forward in very interesting ways so the
goals of this is really to enhance the
definition declaration use of constants
in the whole Java platform it's a nice
vertical slice through the run through
hotspot for libraries and through the
language and through Java C and stuff
like that so at runtime we want to
dynamically declare any constant value
in the constant pool of a class file and
usually reference those values lazily
like we can do with some constants today
and we want to do the same for language
you want to declare rich constants fold
them and use these so we can have
language level support for what we have
a bytecode which is load constants lbc
or actually put in the language
invokedynamic how many people were on
invokedynamic in a language Remy any one
that I do LDC is interesting too so if
we can up the level and do this in the
java language it's not for everybody but
it's for a core set of java developers i
think will become very interesting and
they'll start using it in interesting
ways so here's the runtime runtime code
so it's project amber
hence trapped in amber I shouldn't say
trapped incrusted bejeweled in amber so
if you want to get the code you can do
this HG incantation and switch to the
condi branch
build it and make it so it's all what
I'm going to talk about is actually
implemented that you can play around
with in if you're interested I really do
encourage you to do this and there's
other we'll get to the bit of the
language side later but amber has a
bunch of branches with bunch of separate
projects like local variable type in
here and pattern match and Brian will
talk about and stuff like this a lot of
activity going on in this code base so a
bit of a path to what can we do with
values today so there are about three
areas where we can reference constant
values today in the bytecode and at
runtime so one of them is a static field
initialization with constant value
attribute this stills like a bit of an
anachronism to me in the byte code a
little bit the way it works there's also
the instructions the LDC instruction and
LD c2 and that point to the limits where
you have in the byte code we have today
which is 2 to the 32
we can't reference more than those in
the console I'm not going to directly
address that today and of course we have
a special LBC 2w just for Long's and
doubles because they're kind of special
and annoying when you write stuff
because I always forget that they're
double slots and my code crashes first
time and then we have bootstrap method
arguments so you can actually reference
constants in the static arguments that
you pass to invoke dynamic there's
actually also other byte codes at
reference constants and there's console
directly embedded in the bytecode
instructions when you push values onto
the stack so it's actually embedded in
the instructions there that we're not
going to talk about those so we have a
bunch of constant types that are
supported we have about oh one two three
four six eight of them they map to stuff
in the in the java language so for
example constant class maps to the
java.lang class so for like that some
constants are actually resolved they
require work to take it from that
symbolic information and transform it
into a java instance and that's where
errors can occur because the class might
not be found it might be ill formed and
you can do it's a method handle method
type where has bunch of classes so one
of those classes might fail and a method
handle has a target type method which
takes a method type and a method handle
might be in
exactly like virtual and Natalia can
happen there too when linking so for
flight that the interesting thing is
constant integer we can't represent
bikes or chart directly in the byte code
so we Inter's used to represent narrower
forms and also the boolean value the 0
or 1 so if we look at what what Aries
can use these constants we see this
constant value which is used for static
static fields it can only represent
any-any you sort of reference primitive
values this is very very tied with java
c if you're ever familiar if you use
static final in x equals 1 you'll see if
you look at java p output you'll see
that this actually being used there this
is something that John John Rose talked
about containment and this is where I
get my hook in here that this these
values here are not necessarily
contained within the compilation unit
they tend to leak across compilation
units and cause binary incompatibility
probably compatibility issues and I
don't think we should use these going
forward to strength stuff in other
things into is just leave it and park it
off to the side and leave it gently on
its own whereas all the others they can
reference these them values it but I
note that LDC can't lay the byte can't
leave the char and the same for
bootstrap method arguments it's kind of
restrictive so use 8 types here it's
very restricted and when people start
doing stuff they tend to more
complicated stuff what do they use to
encode stuff the only thing they can use
with this with a variable length is
string here so there starts with
funneling things through string you can
encode anything in a string utf-8 string
if you want to but it can be pretty ugly
in here a Z base64 it and so for that
she thinks of stringify things so this
is not the great state of affairs but
you can you can work around it if you
want to which you hold you know so it's
very limited you see what we have here
both in types essentially in the in era
T or get on to the moment and resolution
control so constant values are limited
to 8 Java types as we saw so therefore l
DC is limited there for bootstrap method
arguments are limited therefore india's
limited
let's remove its limitation here also of
note is that the bootstrap method
arguments we have when we do an invoke
dynamic is limited to 255 - your metal
handle receiver - you look up plus your
name and plus your type let's get it rid
of that - John did a sweep through
perspec and just blasted that one array
away recently so we should be able to
have as many arguments as possible and
even get over the limit of the
restriction and a number of arguments in
a method call as well by packing stuff
into internet and a viral array if we
want to as well and also know there's no
control over resolution of your
bootstrap method arguments here when you
get called all all stuff is resolved or
it's an error you have no control to say
I want to control the resolution of
these things later on and control the
way I do the error you don't get a
choice there as well so it's pretty
limited in terms of types arity and
resolution control and what about this
there's a whole bunch of stuff we cannot
represent in the constant pool what
about imp dot class how many know that
int dot class can't be represented in
the constant pool i if you don't know
identity to compile and see what java c
does it's kind of interesting i didn't
know at first and I looked at gosh
goodness me look at the other C's code
having to do that so there's also
true/false bye shorts and so forth a
bunch of stuff there's also enums we're
blocked read spread state block cannot
be representing the comfortable if you
actually want to use that type in the
content pool there's regex patterns we
can't represent those we can't use bar
handles in a constant pool that I wanted
to do and in general we can't rep you
can call any sort of factory matter that
we might want to it returns something in
a constant and we can't sort of compose
method handle chains with constants as
well so there's two generalizations here
but we might want to do so what about
just use static final feels that's kind
of what we do today this is example of
our handle in the counted completer
so what we do is in our static
initialization block we look up the bar
handle and sign it to a static final
field and then in the code adds a
pending count we actually reference that
static final field and do some work on
it but that's that's not lazy at the
last initialization time we do work here
that
softly and is a whole ceremony and set
up here where things can go wrong and if
there's a bunch of stuff going on here
and if you're looking at multiple
handles you might not use them all at
once so there's a cost that performance
cost for start-up that could be
amortized over time when you use these
things if sir lazier so Doug Lee hates
this code he households in those many
writes it can we do better yes we can we
can make Doug Lee hold his nose even
longer what you do is you stuff it in it
in a static in a class to make it lazy
so that's equally as horrible as well
you don't want to be writing this kind
of code so the idea is what you want to
do is somehow LDC this far hand will
give them some static arguments and then
just call the method so it's lazy when
you use it we wanted to do this with a
bar handles jet but we we didn't want to
go all the way to putting just bar
handles in the constant pool that's a
lot of work we should be able to do
something better here and then sensei
will talk about this and say how it's
done in using the language instead so
here's another what if what if he had a
complex Java source expression that
could be compiled into a group of
constants which are then resolved on
demand as it sounds abstract that I
don't think that's a theoretical
question because what Brian will talk
about with pattern matching and switch
expressions is is pushing on this button
quite a lot here and we think we can
leverage the constants and constant
dynamic that we're going to talk about
with pattern matching and do something
really quite interesting we could we
could do this do this using invoke
dynamic why can't we just use invoke
dynamically constants so we have a
constant in begg'd anomic with a
specific bootstrap method we define
returning a constant call site holding a
method handle accepting no arguments so
and invoke returns a constant value of
the specified return type that is a
mouthful it sort of suggests as a smell
there they're not really first-class
members of the constant pool you can
roll this yourself and it's a blurry
semantics here should LDC reference a
constant invoke dynamic can bootstrap
method are going to do it it's kind of
smelly we need to uplevel this and make
it more fundamental concept so here in
Enter
dynamic so it's a new constant pool
entry in the constant pool we've
assigned that a tag number 17 now if you
are aware of the tags that exist already
in the comfortable 17 sits between
either method type of method handle I
can't remember and in dope dynamic there
was a slot reserved for this already a
couple of years ago some people in the
invokedynamic group were really smart so
he wanted this we just didn't have time
to do it maybe if they had time method
handle and method type wouldn't exist
directly in the constant pool would you
be using conde instead so this is
trade-offs in terms of time
implementation here so Colton hammock is
to invoke dynamic as still descriptor is
to method descriptor we're leveraging
the name and type but the name of the
type in there is a field description
sort of a method descriptor and we can
represent by LDC or a bootstrap method
arguments including those in constant
dynamic so we essentially can get a sort
of recursive references going on here so
the bootstrap method it can represent
int doc class and so forth like that so
if I if I just go back to here we see we
want to represent dot class I'm looking
for a bar handle to an infield in that
class has to be represented as a comic
because you can't represent it directly
so what about bootstrap method
invocation so we've improved this so is
essentially equivalent to invoke with
argument semantics which is like endowed
with an ad type no polymorphic
transformation here so essentially it
allows us to support an unlimited set of
arguments within constant pool limits so
bootstrap method invocation don't know
is driven by arity and bar I've only
really it's not explicitly typed to the
name and type and this enables quite a
lot of reuse when you're using bootstrap
methods so if we look at this table here
we can see a bunch of examples that I
extracted out from the Javadoc of of the
types of the shapes or signatures of
bootstrap methods you can have you can
have a bootstrap method for invoke
dynamic but basic sets that takes of our
odds of args and it will stuff in the
lookup name and type where you can
explicitly mention those in the first
one I have borrowed at the end or you
can explicitly type the stuff that you
want at the bottom like that it's very
very flexible in how you invoke these
things and you have to return a call
site back and that could return object
instead and you just it just do runtime
checks at the Java level at the end
doesn't care so we can do the same for
constant dynamic and instead of
returning a call site we return an
object and the exact same types of
signatures apply except for the third
argument here is not a method type it's
a class it's that it's the type of class
of a constant you actually want to
return back and so that's it so it's
very very similar slots in very nicely
within D and if you're feeling
particularly advantageous you could
actually use a BSM both the conde and
invoke dynamic if you really want to
probably recommend it but you could so
there's new signature forms we added for
bootstrap methods so the first one is a
con DB SM and we can actually because we
can now use conde we can use condé
itself to represent like enum constants
in bootstrap method arguments for
example the fredbot state I showed
before we can have a pattern like a
regex constant and so forth like that
same applies to India as well we're up
leveling it so India gets improvements
too
we could return a char constant instead
if we really wanted to or the latter one
is something more interesting which gets
around the constraint on resolution is
we can have just two arguments the arity
is fixed to two
garrett ebay securities to and they VAR
args then it's a bootstrap call info and
this allows us to pull constants from
the sort of the bootstrap method
arguments and pull them on demand and
resolve on demand rather than getting
them all at once and creating a
resolution error and this gets more
important I think if we're looking at a
pattern matching and so forth like that
where we we may not not all cases in
your switch or pattern switch will get
hit and you don't want to create a sort
of resolution error for all of the
switch statements up above when you're
dealing with the path and you were to
create your resolution
hit the right case so with this we might
be able to do that over those various
ways we can do that though this is one
way to do it
so bootstrap call inference head is
driven by Garrity and just have a look
at how much time I've got the how much
time do I have
ok I got about eight I'll speed up it's
driven by arity so example here is pull
BSM though so we look at the parameter
count it's two and it's not of our args
that's that's essentially the trick what
we're doing here so that's that and we
pull and the scope of resolution can be
expanded beyond the method call we could
return the bootstrap call info in
something we're returning in a constant
which then can do the work later on so
we're going beyond the scope of the
actual bootstrap method call here in
terms of resolution which is it may be
quite an interesting thing to control so
the constraints we have here is here's a
problem here's a gentleman's agreement a
gentleman's agreement we have in streams
and so forth about that John showed
before well we got a mutability problem
in Java but obviously what is returned
should be constant but we can't actually
enforce that so there's a gentleman's
agreement it sort of ruled out arrays
naturally until we have frozen arrays
and also you shouldn't be returning
something like a modifiable collection
like ArrayList and so forth like this so
you have to be very aware and careful of
what you return I think this we really
do need some form of immutability better
immutability in in the platform perhaps
that frozen arrays perhaps that's a way
to freeze array list as well perhaps
that's persistent collections perhaps
there's a way we can build up stuff in a
thread or fiber kind wave and freeze it
and say this is a persistent collection
if you add stuff to it then you don't do
a full copy you just do a little copy
there's lots of ways we can improve this
story but we can't actually control it
maybe we could later on if we have some
forms of detection that we might need to
run time checks as well as John was
saying there's also limit in the name
remember we said there's a name and type
there's a certain limitation in the
field descriptor in terms of characters
you can't have certain characters so you
can't use that for all forms of regex
expression if you want to pass a regex
expression
have not compiled constants or stuff
like that so you might have to use an
extra additional Paramus you have to be
careful there yeah that's what they said
there so a couple of constraint and the
bootstrap method is deceptively simple
to implement be if you really do have to
be careful in terms of how you deal with
exceptions how you potentially deal with
binary compatibility and how you deal
with security we've been hit to be
careful what I say that we've been hit
with a few interesting security issues
with our own bootstrap methods for
invokedynamic and it's probably the
strongest security climates for us in
the JDK than outside the JDK but you do
have to be aware of this is it's
deceptively simple to write but you've
got to be careful and we also need an
API to generate constant dynamic byte
code and/or language support that we
need who wants to add ASM support for
conde I mean we also have Richards
bytecode API which is super neat i've
been using that but we do need something
just even for testing which in sente
there's another thing here is why why
don't we just instead of using a
bootstrap method can we represent a
static method directly in our constant
dynamic instead of a bootstrap method
and just call it with the arguments we
could do but we think that using a BSM
wrapper is actually almost as efficient
in terms of bytecode savings but a
little bit more boxing going on and so
forth like this but the cost of the VM
up calling down again is probably going
to be larger so maybe that might this
type of thing might depend on some
performance analysis I think on on what
we do there so we could short-circuit
the assembler any factory method become
a method to return a constant which is
obviously has its own danger because it
might not be a method that's been
designed to return a constant so you
have to be careful with that too there's
just a few more constant types that we
could add we could add constant octet
which is a way to sort of say here's a
here's a bunch of bytes we could map
that to nearby stuff and that might not
be limited to the constraints of to 232
it could be a whole section of bytes
stuffed at the end of the class file and
then
nabbed in a desert peasant there's a way
we could group constants together as a
stream constant offset from those in the
constant pool it could be segmented
constant pool aspects - we could do that
and there's the interest for constant
value of constant type which you'll see
merits you and others tour getting a
thread talk about in terms of how Europe
same value types how you represent
classes value types and unions of these
things together so you'll see that
mentioned later on and with that I will
hand over to the center well thank you
very much
yeah well so now continue with the part
for the change in the in the language
per se which is more of the constant
folding project as we call it and okay
before Paul was commenting out the
repoer
the Conde working and there is a in the
same amber ripple there is a branch that
somehow contains that this is fork on
the bluff the constant folding project
and we call it condi folding so these
are the the the commands to to go on the
repo and build it so what's the
motivation for for the constant folding
project now so basically Java is making
an increased use of finding on so we
sitting in done that there is a string
conquered and there is more to come and
at the same time I mean right now we can
invoke we can use these facilities in
Java code but we have to go to
reflection or by code spinning and so
this is kind of hard to test it so you
have a feature in the language that you
can't really test really
easy now so there is a a very good
example which is the in defied test
written by by young rose and it's
actually kind of companies a very very
good example of how complex it can be to
to test this kind of I mean invoke
dynamic in you can also use the dynamic
invoker and in your code but still you
won't be testing the same bits now there
is no if you use use a reflection there
is no actual invoke dynamic in the
bytecode so this is an example of how it
goes for for testing Indy I mean in the
using reflection and we can see I mean
all the steps we have to go and this is
a kind of complex of old and is very
error-prone so you can make mistakes in
the metal type or the metal handle or
but in the argument actually I mean to
to write the distaste for for the
presentation I have to go several
through several of those errors not so
it's kind of easy to to make mistakes
and and again I mean you are not
expressing the same code so kind of the
goals for the project was were to as
Paul mention to expose in both dynamic
and lvc to to gel developers so and also
this will expose conde as a side effect
for example ah is possible to to replace
the the initialization of an axis of
static field with an OVC and to get to
this we define nominal descriptors that
we call consoles
for for content pool entries now and the
idea was that already existing content
could be also is pride I mean could be
also considered consult so we do that
for frontier and extreme for example
that are considered consoles in the in
deployed so what's the current support
for for content specimens in in Java so
we have basically pre-medicine and three
literals are considered concentrations
and then combinations of them and these
are also considered concentrations but
there are some limitations for example
we can represent stuff like method type
directly in the using the language and
have that actually be represented in the
console pool as a constant and so first
we define the console interface very
simple it resists I look up object so
you can have access to to check what
what code can created the consoles are
fully nominal there is no validation
there is no class loading so they are
really really like so the idea is that
telling from that console class we can
create you can define class content
which implements console and this is
this is a very limited
summarized definition of the class which
we have ma a method to create the class
constant is interesting here the tracker
an addiction will be we can talk about
that later
and they are as I was mentioning there
are also other concern I mean we have
the metal type concern we have the metal
content they basically have some similar
methods now in the case of metal handle
content we have all the flavors now of
static adverbs of exchange rate to
create different metal handle content
and as I was commenting a string also
implements
constable string into your implement
consult of interior etc so we have
defined new concentrations in the
language now this this part is
interesting now so we have that now an
effectively fine a lot a local variable
can be consider can be a console so if
you use it as an effective local
variable you the compiler will track it
and if you compare account group that is
effectively final you can use it as a
constant pressure but we have limits the
the console to behave as contents only
inside the computational unit because we
didn't want binary compatibility
implications with these now and and
there is no change to releasing content
like strings and primitives so for
example if we want to create a class
constant we have this construction where
we I mean you can define and say class
constant off with the factory and there
is the scripture and the result is a
sequence called content and the compiler
will track that that class account that
console and we check all the use you
make of it now there are also other
concentrations that we consider and our
instance methods for example in the
second example we have
of the same class constant we we just
create and we can create an array of it
and that would be also another console
or we can get a component in Felicia an
array and and and that component we
would also be a console of course this
means more work for the compiler they
compare you have two more checks you
have to track and propagate all those
new concentrations and remember the the
ionization also going about before so
it's a metal is annotated with that
annotation that will means as a message
to the compiler okay track me and so the
compiler has to reflect invocations of
those methods obtain the content and and
start tracking things can go wrong if
the if the the argument I mean at some
point you can have some invocations a
failing this is of course reflective and
we have to check that all the argument
passed to an intensified method are all
constants prescience and also as I was
mentioning new consoles can't can skip I
mean can go beyond the borders of a
computation unit that's another check
the compiler has to to do non so that
means that a console depending on how
it's used and for not how prodding word
is used it will be a console or no no
okay
consoles and by some point we have to go
to cogeneration and so the idea to
actually go to the cogeneration was to
define a new class with two methods
invoke dynamic and LD see that the
compare the user have to explicitly use
to actually tell the compiler okay a one
and evoke dynamic to be generated for
this and what on
this is to be generated for these now so
this is the Buried clicks it no magic
and and this is for example the
definition for for DC we have a DC
receives a console and the idea is to
actually make this call to be
intensified into an LDC and actually
have that in the in the white coat with
the restriction that the argument has to
be a constants pression it could be any
string or primitive literal or a box of
that it could be a console sorry or it
could be an effective final variable
pointing to to one or the other if the
argument is not a constant that the
compiler will reach a compiler error so
for example we have here two two very
similar examples but in one of them I
mean the first variable C local version
C is effectively final in your case we
assign now to the variable so it's not
exactly final and in that case a
compiler when it sees the LDC as you can
prove that it's not effective finally
what it will issue an error this adds
some high complexity because I mean the
compiler can't prove that a variable is
effectively final Tillinghast on the
flow analysis of the code so the idea is
that we are supposing I mean work kind
of assuming that this could be
effectively final during attribution
then after flow if we now that we know
what is effective final of what is not
then we can prove if all LV C's are are
correct or no no
the definition for invokedynamic it's a
definition in the Indian context class
or we have it was just a supplier
argument and invocation name and an
array of object arguments sorry
so idea is that they should they should
generate an EVOC damage instruction the
code with the following restrictions the
FIR argument I mean the Gujarat
specifier has to be a constant
also the the invocation name and there
is no restriction on the on the argument
in the indicate we have static arguments
which are representing in the boosters
satisfier parameter and we have also a
dynamic argument so this a quick
definition of the abstract specifier
class now is simple if use a metal
handle with some static argument
that has to be constant as mentioned so
we got we're going into to an example we
have seen before in the in the
presentation so here we have a class
content and we have we are explicitly
calling the lvc methods in increases
quacks plus sorry
and this is the the generated code and
as we can see there is a an LDC actually
in the right code so it's very handy to
okay to expose the OVC and
what-you-see-is-what-you-get know in
this game sorry so somehow the code
before the ALDC is redundant in this
case actually improves a versions of the
other of the project we were just
generating the LDC and I mean doc who
actually decreases
the volume of the bytecode but it was
decided to to release magic and to
actually represent the what code was
happening but I wondered that it could
be interesting for some people to to
actually go directly to to the LDC so
this is an example of the use of indie
in the in the source code this is very
similar to the first example which is
making use of a string Concord in the
first sample we were using reflection
here we are using the invoke dynamic
drink intrinsic we can say that the code
is kind of similar in complexity but
before we were not actually generating
the invoke dynamic here the compare is
actually generating the employ dynamic
could this big simpler I well we were
storing ways to simplify the goal even
even more and we are working on that but
but the thing here is that you get the
real thing I mean once you go to the
bytecode
you actually see the invoke dynamic
Jeremy without having to spin the divide
code etc so this is really powerful
I mean and something that of course we
couldn't offer to Java bombers before so
we got to a point where we have all of
these we have several consoles with
methods with the the annotation to
import the compiler to track some of
those methods so what now if I need to
know to add a new console method
what if I need to add a new factory or
it's a very new concept I mean
do I need to change the compiler well
there is no I mean the answer is no
using using the D annotation you can
inform the compiler please track the
result of this method and make sure that
any argument to this method is actual
actually a consonants pression for
example this method does 96 in the in
the API is something I make up and but
just adding this interface and API and
having the the trackable Contin
annotation will be enough for for it to
work not without adding any other
modifications to the compiler okay this
part seems easy but what about
cogeneration suppose a new console is
added now that we want to support it but
let's suppose that a new console is
added or just an existing content
content is renamed we should be exactly
the same affection so do I need to
change the compiler well there is a
understanding between the Java C and
consoles and we have provide an API so
that when the compiler doesn't know how
to write a constant work on sample it
acts the content to write itself to the
to the constant pole this is very handy
and it kind of closes the circle so it's
easy to modify consult renaming whatever
without actually having to modify one
line of code in the in the compiler and
so this is a the partner of the of
consoles and Pawlak you want to to make
this summary I can just not get a read
the slide that it just summarizes what
we just said tell them what you told
them the interesting is really
foundational technology I think
we can use to build other stuff on top
of and come up and remove the
limitations we currently have both at
the VM level and the language level and
I think that's going to sort of open up
things not just for us but for other
people if we do this right
I think the API is going to have to go
friend of a couple of rounds of API
grinder review I think that's good and
now it's now it's best people to use I
encourage people to go and do that
I really we want feedback on this and at
the moment it's very low level there
could be a bunch of different levels
depending on how much sort of
initialization you might want to do with
things that could be fluent api's and
really explored that I think that's a
good area as well but also a nice thing
about this project is it's a nice
vertical over the whole Java Runtime and
that's what I love about this is a bit
in Java C there's a bit in core
libraries in Java C interacts with core
libraries pre reflected calls that
really surprised me the core libraries
Interactive's with the VM and up call
it's like a holistic piece of
functionality in the whole Java Runtime
and that's really to me that if you can
get that right that's a really solid
project and a lot of the projects we do
are around that that holistic value I'd
like to see more of that okay yeah I
think this is the first time that we
have a kind of interaction between the
compiler and the and the libraries yeah
kind of
during the the compilation invoking I
mean reflected invoking a method and
getting the result I'm doing affecting
the compiler I mean the result of the
computation with that yeah that was burn
through sync okay so there's a workshop
afterwards on java.lang invoke where we
can take crashes and what are we running
out of time we have a few minutes
okay let's take some questions now we
can flow over the more
how many times people before people
realize that it's a macro system yeah
all right
you just realized they were now real
like walk
spill it and what about recursion
recursion that the BN the county level
of the language level I mean when the
compiler will call some codes that do
infinite recursion secondly
gene amaura yeah it would be nice to to
have an example of that but I mean I I
think that should be I mean we can
enforce way to to fix that I mean to
avoid that now but right
I don't see any
when the compiler of
core of an arbitrary method and yeah
it's contained yeah can't leak hell so
I've been the first guinea pig to be
using this stuff so you know then I just
wanna make a couple comments about what
this is good for so there are two real
big advantages that come out of this one
is how many people here have written any
good straps before right it's kind of
like programming with boxing gloves
right you're really limited to the types
you can use this makes indie programming
a lot more like regular Java programming
it's so your bootstraps can be more
expressive and it also means that there
can be more likely to be binary
compatible and then the other thing you
know the other hidden benefit of this is
it allows us to move even more
computation for an invocation time to
link time so the range of things that we
can describe is the M constants and
Gantt lazy initialization from the DM
load constant mechanism grows hugely and
and it's each time you think oh okay I
found all the constants in my code no no
there's a whole another way of things
that can you know once you've made this
stuff constant you can make more stuff
constant based on that and really it's
quite nice says so compiler writers will
really like I like to just inject into
that as well it might help us break
cycles at bootstrap more more more
laziness there in a more formal way than
having to put stuff in in a static
classes or so forth like that which
helped us rearrange and extract I can
get faster startup to especially if you
can attach a constant full reference to
a constant conde constant to a static
final constant and then treat that
especially with lazy semantics Brian was
just being very modest this this whole
thing of Constable thing is I think his
brainchild because I remember him
looking at my in defy code
and just vomiting all over it quite
justly and saying surely we can do
better than this and so he embarked on a
multi-year quest to surely find what
could be better I think John you told me
that this this in defy test irritated
Brian so much it's because I start
thinking about this yeah that's that's
one thing that probably I didn't stress
during the presentation this is going to
be open to to create I mean no consoles
for for free and also it would be
limited to some methods than the the API
in the JDK
just in term of API I think you can get
rid of the interface constable basically
what you want is a kind of serialization
you can do that with an annotation and
you can retrofit string method type and
so on by attaching this annotation I
mean I would like to work an example and
here and try to break it try to to make
it a fail because of a business it will
be interesting</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>