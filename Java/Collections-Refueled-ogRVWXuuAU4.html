<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Collections Refueled | Coder Coacher - Coaching Coders</title><meta content="Collections Refueled - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Collections Refueled</b></h2><h5 class="post__date">2017-10-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ogRVWXuuAU4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning thanks for coming this
morning I know it's an early start but
thanks for coming in today
my name is Stewart Marx I work at Oracle
on the JDK work in the core libraries
team and one of the things I do is
maintain the collections framework and
so the title of this talk is collections
refueled so I'm going to be covering the
collections enhancements in JDK 9 and a
little bit of a glimpse of what we might
be working on in the future so let's see
this is only a 45-minute session and so
I had to trim this down from an hour I
might or might not have time for
questions at the end but if there's a
question that you have that you don't
get a chance to ask me in the session
then please tweet on this hashtag
collections refueled and I will try to
get to it after the after the session
alright so one slide on history of the
collections framework so in JDK 1.0 in
1996 there were there wasn't anything
called the collections fairmark there
were some collections there which we we
now retrospectively call the legacy
collections those are the classes like
vector and hash table which you might
remember I hope you're not using those
although I did see them in a stack trace
in the in the keynote yesterday hmm okay
so in jdk 1.2 now that was when the
collections framework was actually
introduced so joshua bloch designed to
develop those and integrated those into
the JDK back in 1998
so the collections framework is a little
bit younger than Java so it's about 19
years old at this point and so that's
what introduced the set of interfaces
that we that were so familiar with
collection list set math and so forth
and also the collections that that
probably everybody uses like ArrayList
and hash map and so I don't have the
reference on my fingertips but there was
some paper that did an empirical study
of of collection usage and ArrayList and
hash map are by far the two most
frequently used collections in Java
programs so it's pretty amazing now
these these classes have been
reimplemented over the
but the the basics of these classes were
introduced nineteen years ago and
there's still the most among the most
popular collection classes in use today
now the next big step up was in 2004
with Java SE 5 when generics were
introduced and so as part of the
introduction of generics to the
programming language the collection
libraries were upgraded to be genera
fide and so you got better type-checking
when you put elements into and removed
elements from collections and in Java 8
the language was once again operated big
upgrade to add lambda in the streams
library now the streams library is kind
of not officially part of the
collections framework but basically it
it the the most frequent stream source
and stream destination are collections
so the streams library works very
closely with the collections framework
but there's another language feature in
Java 8 which is default methods on
interfaces and so that got slipped in
there you probably are familiar with
that but one of the things that did was
add a bunch of methods to those old
collection interfaces like collection
list set math and so forth and so what
that did is that had the effect of
enhancing every single existing
collection even if that collection
hadn't explicitly been upgraded to Java
8 the default methods really added a lot
of power to the collections framework
without changing the collections
framework at all so it was actually very
interesting enhancement now along the
way there have been a few other classes
added collections implementations added
here and there such as priority queue
and array deck and so forth but really
these are the highlights of the history
of the collections framework up until
now alright so in Java 9 the main
enhancement to the collections framework
is called the convenience collection
collections convenience factory methods
so they're factory methods for creating
instances of new collections and so
these are the three main goals here
convenience and brevity space efficiency
and unmodifiable 'ti so I'm going to go
through those in some detail
all right so a bit of history here this
is a library only API and so a mark what
was this no this was actually in the ask
the architects session yesterday so so
one of the things that other languages
have is something called collection
literals and so there have been efforts
to add collection literals to the java
programming language but there's some
problems so the way that Java is
designed is the core aggregations if you
want to aggregate certain data in the
java programming language you have
arrays which are built into the language
and you have classes which are built in
a language you can add fields to a class
and that's how you that's how you group
unrelated data into into a higher-level
construct that that creates a
relationship between them but kind of
higher level abstractions like a set or
or some higher level data structure is
really delegated to the libraries in the
way Java has been set up and so if you
created a language feature call that
that allowed you to write a that allowed
you to declare a collection in the
programming language that would tie the
programming language to the library too
tightly and they're a bunch of design
issues that fell out of that but I don't
have time to go into detail so you do
something simple but that would be
unsatisfactory if you wanted to avoid
that that solve the problems with that
cause it turns out that it would get a
lot more complex and so we set aside the
notion of adding collection literals to
the programming language and decided to
focus on making collections easier to
use using only library API construct all
right and so here it is this is a quick
rundown of the the new API that were
added in JDK 9 so there's a family of
methods named of that have been added to
the list method these are static methods
on the list interface so list dot of
with 0 1 2 all the way up to
ten arguments or there's also a varargs
version so you can pass an arbitrary
number of elements to the list dot of
method no officially they're actually a
let's see zero through ten plus VAR arc
so that's there are actually 12
different overloads of list dot of but
when you write the code it doesn't
actually matter you just say list dot of
and just a comma separated set of
elements and those get added to a newly
created list same thing with set dot
ah've there are a bunch of fixed arg
overloads and VAR arg overloads but
mainly just say set thought of and you
provide a comma separated list of the
elements for the set now map thought of
is a little bit different because unlike
set and list map has different types for
the key and the value so what we did
instead of was he said math dot of and
then alternating key and value elements
now the problem there is that you if you
have things of different types you
really can't have a varargs overload of
that and make that work the same way so
instead what we had to do is if you want
to create a map with an arbitrary number
of elements you first have to box the
key in the value into a map entry so we
added another we have added a static
method called map entry it's a method as
distinct from the type mount dot capital
entry and that takes the key in the
value and puts them into an instance of
math dot entry and then you have another
method mount dot of entries which takes
a varargs
list of those so you can create a map
with an arbitrary number of pairs
alright so this is what it looks like in
the Javadoc so you can see all the
overloads there and it's amazing how
people react to this when when this when
this first got posted there was a
discussion about this on reddit and
somebody said is this a joke but no this
is not a joke but i think the main point
here is this yeah this this is a certain
amount of ugliness in the api but you do
not see this ugliness when you program
because you just see in the source code
what did I what did I use here math dot
of mapped out of or list out of or
whatever you just list the arguments and
the fact that they are fixed Arg
overloads and variable argument
overloads is immaterial to you except in
the in the math case and I'll show an
example of the map case later on but the
point here is that in in the library
when we are developing the core
libraries and the collections framework
we're willing to take on some of this
ugliness so you don't have to so it
really makes your code much more
convenient so let me show you some
examples of this in action so I think
mark Reinhold might have demonstrated
some of this in the keynote yesterday
but if you wanted to have an
unmodifiable list with a few elements
you could you could wrap up those
elements in arrays not as lists and then
wrap wrap that and turn inside of
collections on unmodifiable list and so
in Java dot 9 it's just list dot of ABC
that's really nice makes your code
pretty compact I'm sorry I don't have to
I don't have time for questions but if
you're on Twitter please tweet and I'll
get back to you all right so with the
set interface again there's something
very similar now it's a little worse
because you have to if you have certain
elements going into a set you have to
take those elements and the only way to
pass multiple elements to initialize a
hat is to put them inside an array using
arrays dot as lists then put those
inside a hash set then put those inside
of an unmodifiable set and so once again
it gets much more simple in JDK 9 you
just say set dot of ABC alright so
here's here's where I have a slightly
different example from what Mark did in
the keynote yesterday this is kind of a
conventional way at the top of the slide
a conventional way to initialize a map
just create the map empty and then call
put on it several times
I think everybody's written this code
they're variations of how to do that a
bunch of advantage that this manages but
this is the most straightforward way
once you've finished adding things to
the map then you can wrap it in an
unmodifiable wrapper and so that's
pretty tedious and so here's where the
big win is in Java nine I just say math
dot of a comma one B comma two C comma
three and you can see here we're mixing
types of string and int for the for the
key and the value now so this only works
for up to ten key value pairs so if you
have more than ten key value pairs that
you want here's where we have to use
that that extra thing I was talking
about
so the math dot entry static method so
here I kind of made up this type called
token type we have a map from string to
token type and we want to have more than
ten entries there so there instead of
just having strings and token types side
by side we have to first wrap each one
of those up into a map entry and then
pass all of those as varargs to a new
method map dot of entries all right so
so I just talked about the API but I
haven't told you very much about what
gets returned from these api's now these
the implementations that are returned by
these conform to the list set and map
interfaces but there are different
implementations from what we've seen in
the past so you don't get a regular
array list or a hash map out of these so
they have quite a quite a number of
different characteristics from from the
existing collection implementations so
in particular they are unmodifiable and
there's well I'll go into all of these
in detail we disallowed nulls randomized
iteration or that's a big deal I'll try
to spend some time on that we disallowed
duplicates in the list so probably it's
a programming error if you if you put
duplicates if you're listing out a bunch
of elements explicit thing you have
duplicates for sets and maps I think a
very interesting point is that they are
much more space efficient than the
existing collections particularly hasha
and there are some wrinkles to do with
serialization which I'll cover all right
so the new static factory methods all
returned collection instances that are
unmodifiable and so by that we mean it's
the same old interface but and so you
can say get or you can iterate over the
collection or whatever as usual things
that read from the collection work
exactly the same as they do with a
conventional conventional clock or the
the existing collections however if you
attempt to add or remove or set an
element in one of these collections it
will throw an unmodified unsupported
operation exception and then it's very
similar to the behavior of the
collection you get when you wrap
something with collections dot
unmodifiable list or or map or something
like that so I've talked a lot about
unmodified unmodified bility what good
is because G don't you don't you want to
create a data structure so that you can
add and remove things to it well often
you do and in that case you probably
should continue to want use one of the
existing collection implementations but
it's actually very common case where you
want to initialize a collection from a
known set of constant values and then
never touch it later on and so you could
just make sure in your program that
nothing ever modifies it later on and
that and that would be fine but if
something modified it by accident then
that might be a source of subtle bugs so
you might go the extra step of wrapping
it in an unmodified will wrap ur and
that would be helpful that would
probably be a thing we would recommend
that you do in Java 8 and earlier but
with these these new convenience
factoring methods you get a none
modifiable list automatically now if you
want to pre initialize a a collection
with a set of elements that you might
later want to modify or add to the these
collection factors they're still useful
as initializers for the existing
collections so if you had if you wanted
to pre initialize something like like a
hash set you could say new
set with lists of ABC or something like
that so even even if you want to modify
something later on these are still
useful for initializing the conventional
collections there are other there are
other reasons too to use unmodifiable
sets if you have a class that has an
internal data structure which is
represented by a collection I got a list
of something and you have a getter that
that gets that list of something well
you could just hand out the list but
that would let the caller modify your
internal data structures which is
probably not what you want to do and so
again you could be very careful and make
sure that none of your callers ever
modified that but if by accident or
malice actually unfortunately we have to
think about that the caller decided to
modify the list that was returned then
that would create some subtle bugs or
even security holes so a class can
protect itself if it has a unmodified
has a collection that's using internally
it can wrap that in an unmodified little
wrapper and then pass it to the caller
which is then prohibited from modifying
it so with the new collection factories
you kind of get that for free so if you
pre initialize a data structure it's
unmodifiable already and so you can just
hand it out with impunity and you know
that nobody else can modify it and
corrupt your internal data structures so
there's another aspect of a collection
being unmodifiable which is that the the
the conventional collections like hash
map are geared towards general-purpose
operations including updates and so they
have to handle a bunch of different
cases that an unmodifiable collection
does not so on the implementation of an
unmodifiable collection is actually can
actually be quite a bit simpler than one
of the conventional ones since it never
has to be modified so in particular the
implementations we have in JDK 9 are
packed much more tightly because wait
once once something lands in a certain
place it never needs to move and it
never needs to be replaced so we just
don't have
to worry about that case so we can take
advantage of that and make the data
structure much more compact and also the
the code complexity is is much reduced
so so there is a distinction here though
between the unmodifiable wrappers like
collections dot unmodifiable list and
the unmodifiable collection you get from
list dot of so in the first actually
actually i'll cover that on the next
slide so so here so I'm talking about
the unmodifiable list wrapper versus
list thought of so so let's take this
real simple code example here we have we
have a list inner which consists of
integers 1 2 &amp;amp; 3 now we create 1 list
which is an unmodifiable list wrapper
around that list and then you create a
second list which is list dot of 1 2 3
now what's the difference between those
well first let's talk about what's the
same so you can certainly read from both
of those you can do get you can do even
you can do for each loop over them and
so forth however if you attempt to call
add or call the set method both will
throw unsupported operation exception so
in that sense they're both unmodifiable
that's why I'm using the same word
unmodifiable to describe both of those
but there is a difference which is that
list 1 is an unmodifiable view of the
other list which i've called inner here
now so so it's actually a bit subtle the
list named inner actually is modifiable
you can say inner dot set inner dot set
0 17 it'll actually it'll actually
change that value there so it's it's
actually a common point of confusion is
that people often think that the the
list return from arrays dot as list is
is unmodifiable or even i've even heard
it called immutable that's not correct
you can actually change
the elements in that set although you
cannot change its size which which gives
people which I think leads to that
confusion but anyway so so back to the
wrapper though if you have lists one as
a wrapper around the inner list so if
you change the contents of the inner
list then list one can see those changes
so if you have a reference to list one
you can iterate through it and look at
those and then some some other piece of
your code changes the inner list and if
you iterate over list one again its
contents are different now you can call
methods on list one and you cannot
modify it so that's why we call this an
unmodifiable view so it has a view of
some other collection which might be
modifiable but you can't modify things
through this view and so so the
unmodifiable views have have existed in
in in the JDK for quite a long time I
think going all the way back perhaps to
one point to now what's new is that in
JDK 9 we have these new collections that
are themselves unmodifiable they're not
a view of something else so list 2
contains the elements itself and it's
unmodifiable so there's no other
collection floating around somewhere
that could be modified that this is a
view of Solus dot 2 is the list itself
and it is unmodifiable so you if you
look at other materials on the web that
that I've produced previous talks I've
said I've used the term immutable to
describe these collections and I've
moved away from that I think I deserve
to give you a little bit of an
explanation for that you there's a lot
of material out there on the web that
other people have written we just copied
me that have called these immutable
collections and list2 is in fact
immutable but only because its contents
are immutable so these get boxed into
java.lang integer classes which are
immutable so if you have immutable
objects inside an unmodifiable
collection the whole thing is immutable
but imagine if you took some string
buffer instances and said list out of
ring buffer one string buffer two string
buffer three you can modify those string
buffers so in in no sense is list not of
returning an immutable collection
because everything in it is modifiable
so really so that's the explanation for
why I've started to steer the
terminology over to unmodifiable so we
say that the collection is unmodifiable
and that's a completely separate
statement from any statement you might
make about the contents of the
collection okay so moving on so one one
design decision we made was to disallow
nulls
in the new collection instances so if
you attempt to say list out of one
common all comma three or something like
that it'll throw a nullpointerexception
so I in retrospect if you if you look at
the collections that were introduced
originally in JDK 1.2 they did allow
nulls so you can put nulls in ArrayList
you can put nulls in hashmap but it
turns out that no other collection
supports that well very few other
collections do in fact most of the
collections that were introduced after
one point two do not support nulls none
of the collections in java.util
concurrent support nulls and there's
there's a reason for that well one is
null as bad we've probably I should
probably give an entire talk about null
at some point
although we do have to talk about
optional on Thursday which is closely
related but there's but there's another
reason which is that nulls make things
hard to program so if you look at the
map dot get method you pass it a key and
it returns the value corresponding to
that key well what happens if that key
is not present in the map well it
returns null okay now what if in that
map in a hash map that key is actually
mapped to the value null it also returns
null so if you say map get and you get a
null back you don't know whether the key
was present or absent and that's a
fundamental ambiguity that arises from
allowing null and
as an actual value instead of using it
as a sentinel which it actually is so so
that occurs in several places in the API
where it's hard to tell whether no means
well the actual value is null or there
is no value so that's a fundamental
problem with semantics of no also no is
very very useful inside of
implementations as a sentinel value so
the the collections implementations we
have use null to mean there is no
element here and so if you look at the
set implementation it uses closed
hashing in a single array so it's very
compact but null means the absence of an
entry so searching can stop at that
point
so there's no possible if well we can
only do that if we disallow no as of an
actual value that can be present in the
set or in the map okay moving on to two
other issues randomized the iteration
order so this is a this is a bit of a
controversy so if you look at the
history of most most of the collections
particularly basically the hash based
one so if you look at hash map for
instance if you read the specification
carefully it says the elements if you
iterate over the entries of a hash map
you will get the elements in no
particular order and the problem is that
the order actually was quite predictable
even though it was not specified and
even worse most often in hash map the
oft-used key type in hash map is string
and strings have a notoriously bad hash
code so if you put a bunch of strings in
they'll actually and and if you put a
bunch of strings into a hash set or hash
map and then iterate over them they'll
actually come out in sorted order and so
the problem is if you start to depend on
that order and then somebody adds
another value that which you weren't
expecting and causes the the hash map to
to rehash itself and put things in
different buckets then that order
changes and it might break your code
now maybe you've you you might have
designed your code to be more resilient
to that but actually in in practice what
happens is that once a hashmap is loaded
with something it tends not to change
that much so what happens is the code
tends to build up an implicit dependency
on the iteration order of the keys of a
hash map now the other problem is that
from time to time in the JDK we change
the iteration order of a hash map right
the specification says they're not
returned in any particular order so we
might change the iteration order of a
hash map in order to optimize things or
in order to protect against security
vulnerabilities and so forth and this
does happen from time to time with the
frequency of JDK releases being fairly
low this didn't happen very often and in
fact it happened with about the worst
possible frequency it would happen so we
released a JDK a bunch of code would be
written that depended on the hashmap
order in this version of the JDK years
later we'd change the iteration order of
hash map and then it would break
everything and so there would be a bunch
of complaints about it and you know
maybe rightly you know you can only get
so far by saying I'm sorry if you read
the spec your code is wrong you'd have
to go fix it right
that gets tiresome after a while it gets
tiresome for everybody and so and the
problem is and and and and it seeped
it's very easy to say you guys need to
fix your code and so I don't want to say
that because our code has the same
problem we had a we had a bug in the
compiler that was due to the exact same
thing and it was mystifying and so we
said you know let's change that to a
linked hash map and the problem went
away so it's clear there's a there's a
very serious problem which is code all
too easily depends on implicit ordering
in a hash map so that's all introduction
to what we're doing here with the new
collection implementations of set and
math in JDK 9 the iteration order is
randomized so at the start when it when
it when the JVM starts it cups up comes
up with hash seed and uses that as part
of the hash computation
so from one run to the next the
iteration order of a set or map that you
get from these new api's is is going to
be different so you might say oh oh my
gosh this is gonna this is gonna this is
gonna break my code yes I wanted to
break your code while you're developing
it and testing it so that way you you
don't get broken when you upgrade to the
next version of the JDK so I think that
the the the principle here is that the
specification allows the implementation
to change but we made this sort of
implicit promise with hashmap not to
change it very often and I think that
was a mistake
and so what we're doing here is we have
the same promise which is the elements
are returned in no particular order but
we were going to change it pretty
frequently to make sure that code that
uses this is resilient to changing of
iteration order and I'm hoping that
everybody has a continuous integration
system that runs the tests frequently
that'll flush out these bugs before
before they reach production now there's
there's also an investment here too
which is that we may want to change the
organization of these new set and map
implementations and so now if we believe
that the code that's using these is
resilient to changes in iteration order
we can completely rewrite this data
structure to make it even more compact
or more efficient or something like that
and if that changes the iteration order
doesn't matter because all the code out
there is already resilient to whatever
iteration order that that it's presented
in now if you are still worried about
iteration order then first the existing
implementations like hash map and hash
that are not changing however there's
still a possibility in the future
release of the JDK we might need to make
a change that that does change the
iteration order if that is a problem
then you should use linked hash map
because that guarantees a particular
iteration order or you can use something
like a sorted map
that that also guarantees particular
order but there's some additional
expense having to do with that so but
that's something to think about that has
has been a problem recurringly that that
hasn't gotten enough attention all right
I covered most of this already I do want
to say that Java is not unique in this I
think other systems have have proceeded
along the same lines in particular the
go language has had math.random actually
randomized iteration order since day one
I believe or at least since one point
now python is interesting it's gone back
and forth in the Python 2x there was a
single implementation of a dict and it
had some predictable iteration order
between versions 3.0 and 3.5 it was
actually randomized 3.6 they got a new
implementation that was much better but
actually provides predictable iteration
order and so they have some you know
like us they've had some very long
discussions about whether randomization
was good or predictable iteration order
was good it's actually it's interesting
to watch those because I'm you know it's
a completely different system from Java
but they're having the same arguments so
again I want to reiterate that the
randomized iteration order applies only
to the new collections that you get from
set thought of and math thought of so
the existing hashmap implementations are
not changing as part of this all right
so moving on so if you think about the
the the the origin of this feature was
in collection literals so the idea there
is you want to declare a collection of
some type and explicitly list out the
elements that would be in it so certain
things like well set and map again what
should be the behavior if you list the
same same element multiple times
so if you're writing out the elements in
the collection literal that's probably a
programming error now what what many
other systems do is they they apply some
rule like last one wins and I think what
what that tends to do is is let subtle
bugs creep into production so if you
have if you have a map actually yeah
there there are a couple other systems
that that actually detect duplicates win
at initialization time but let me show
you an example here so this is a very
similar example to what I showed earlier
where you want to initialize a map with
a bunch of math entries now it turns out
there's a duplicate in here and if you
have sharp eyes you'll be able to spot
it pretty quickly but there are a lot of
them and in if you are just initializing
a map using the put calls then the the
later one would would would replace the
previous one and so you might I actually
don't know how many elements are how
many entries there are in there maybe
they're twelve right so you might you
might count the lines in here and say
there are twelve entries and then
there's some weird problem in production
and you go to debug yet and it's like
huh this map has only eleven entries in
it why is that and then you go back and
you stare at this and you might spot the
might might spot the problem immediately
or if it were like 1:30 in the morning
because you got pulled out of your bed
by a pager call it might take you a long
time to see this and so so what we do
instead is if you're listing out the
elements like this it's probably a
mistake if you have duplicate elements
because what it means is that you put
something in there that is actually
being ignored so what we do we can't
catch that at compile time unfortunately
ideally it would be but we do catch it
at run time so as soon as map dot of
entries or map thought of tries to
initialize a map with duplicate keys it
will throw runtime exception and the
same thing applies to set dot off
alright let me talk about space
efficiency now so one thing you might
notice is that this is a departure from
the from the API of the previous
collection frameworks the the way that
that the collection framework existing
classes work is they would expose a
public class that was an implementation
and there were there would be a variety
of constructors for it so if you wanted
if you wanted a hash map you'd say new
hash map and then you could initialize
that with a size or you can initialize
that from another map that would copy
the elements in and there are no public
class names for these new
implementations and then that that's a
little difficult because it makes them
hard to talk about so I always have to
say the collections implementation
returned by this nut off because because
they have no names now obviously if you
look in the source code they do have
names but but those names are not public
and there's a reason for that which is
that preserves the freedom of the
implementers namely me to completely
reorganize things in the future in a
fully binary compatible way so in
particular I'll tell you about the
implementation we have in place today
which is four sets and maps are actually
four four lists and sets and there's a
slight variation of this for maps but
for listening sets the selection this
don't have an array at all so if you
look at an ArrayList an ArrayList stores
this element in an array which is a
completely separate object inside even
if you have one element it creates a
whole array for it and stores that one
element in there so since we know these
chain these collections are never going
to be modified if you want a set that
contains one element then we just have a
particular implementation that that
contains that element in exactly one
field and so for special cases zero one
and two we store the elements of the
collection in a field there are actually
different classes that implement those
now for more than two elements we go
ahead and create an array and of the
right size and and populate it
but there's nothing magical about 0 1 &amp;amp;
2 you can't tell this by looking at the
API you can only tell by if you use a
reflection or something to go in but the
benefit of course is that the the amount
of space required for storing these in
memory is much reduced compared to the
conventional collections and they're
less spread out in memory so the
locality of reference should be improved
so let's run through an example very
quickly here so let's say that we want
to have a set with two elements in it
and store that in an unmodified map in
the conventional Java Java 8 fashion so
we create a new hash set which has three
buckets because we don't want it to
resize so it has to have three buckets
in order to store to two elements we add
the two elements to it and then we wrap
that in an unmodified ball wrapper
okay so let's count the objects that are
there
there's the unmodifiable wrapper there's
the hash set now it turns out that a
hash set is implemented in terms of a
hash map so a hash map sorry a hash set
contains an instance of hash map so
that's our third object now a hash map
has an array which is the table of
entries and an array to another object
so that's four objects and then each
entry of the hash map is stored in a
node object so now we have six objects
and so here is a diagram of what that
looks like we have we have the set
reference pointing to the unmodifiable
wrapper at the hash set the hash map the
table which is an array and then two
node elements so that's that's your six
that's your six objects no note I'm not
talking about the the the contents or
the payload itself right so I'm not
counting the strings and there's a
special there's a special value there
when you for a hash map when when it's
implemented as part of a hash set I'm
only counting the things the objects
that are created as overhead for the
collection itself so there's six objects
there alright so how much memory does
each object take so in a typical JVM
every object has a twelve byte object
header plus about four by
for every object reference or int field
or smaller smaller primitive field and
so these aren't exact it depends on
exactly what you're using what what your
JVM configuration is but this is a
ballpark estimate so it turns out with
six objects with with all of with all of
other fields and so forth a set with an
unmodifiable set with two elements takes
152 bytes that's surprisingly large but
we've lived with that for a long time
and and amazingly it hasn't really been
a problem until recently I'm not quite
sure why but this is this is gaining
currency which is that I think people
are trying to pack more they're trying
to get more efficiency out of their
systems if you if you're running
thousands of instances in a cloud then
if if you're heaps are too large that
means the number of instances you can
run on each physical node in the cloud
is reduced and so people are
concentrating on reducing their heap
sizes and so forth so that's how this
this issue has started to come up a lot
all right so let's compare this to the
to the new implementation that's
returned by set dot of so the code here
is we say set dot of foo bar so the
source code is nice and simpler but if
you look at the objects that are created
there's an internal implementation
called set two which is a set that has
exactly two elements which are stored in
the field and so that only takes 20
bytes so if you have if you have a data
structure like this you can reduce your
space consumption from this is again
this is overhead you can reduce the
overhead of storing these these data
items from 152 bytes to 20 bytes so we
think that's a really really useful
space optimization in particular the JDK
itself has started to use these
implementations as part of its internal
startup and as part of the internal data
structures for say the module system and
those guys are pleased this punch with
this not only does it make their source
code nicer but it actually reduces the
space that's consumed so we can we can
deliver a JDK that has
reduced heat consumption at at the
beginning of at the start of Maine it
actually uses well it's doing more work
because of the module system but it's
it's less this is less and it would have
if we had used conventional collections
alright a quick word on serialization
yes the elements are the the collection
implementations returned from these
methods are serializable people really
use serialization but we use a
serialization proxy mechanism to keep
those internal implementations hidden so
we can reimplementation remains
compatible with itself I think the main
thing the main takeaway is if you are
serializing existing collections like
ArrayList or hashmap the those will that
those will continue I mean those are
serializable they'll continue to work
between JDK 8 and JDK 9
however if you create instances of these
new collections and serialize them they
cannot be deserialized on JDK 8 and
earlier and so you think about it well
these classes didn't exist on those
early releases but if you have an
environment where your serializing
things and going across different JVM
versions or JDK versions you probably
should stay away from these until every
until every instance is up on JDK 9
alright a quick word on some things that
I'm working on for the next release JDK
10 no I guess it's actually called JDK
18.3 now it's it's actually pretty
difficult to create instances of these
collections with arbitrary elements that
are computed if you list them out I
showed you the API is for doing that but
sometimes what you want to do is read
them from somewhere or compute them from
somewhere and and get get a bunch of
elements and then load them into an
unmodifiable collection and so i've
proposed adding new copy of methods that
will copy from an existing collection or
map
and then also at the end of a stream you
might want to do with dream computation
and then dump the elements that come out
at the end of the stream into an
unmodifiable collection so I've proposed
a family of new collectors so again
these are not in Java 9 unfortunately
but they are proposed for the next
release which is there's going to be
some discussion about this but our
working number is 18 point 3 so JDK 18.3
these are proposed for alright quick
summary and then we might have time for
one or two questions collect the
collections framework is 19 years old
and so it's almost as old as the rest of
Java but it still has a lot of legs I
think it's very useful I believe
everybody's using it today and so we're
continuing to enhance it and make it
more useful the highlight of JDK Nine's
collections are the new collection
factory methods which i've just met the
past 45 minutes talking about and JDK 9
is now shipping it was quite a quite a
pleasure to update this I've been giving
this talk for a year or so and now I can
say JDK 9 is really out there and you
can download from either open GT open
JDK or from Oracle's Java website so you
can contact me on Twitter or you can use
the hash tag in the upper right corner
and you might have time for one or two
quick questions before we're out any
does anybody have any yes right there
right okay so is that the question I can
hear you but but we're running out of
time so let me let me let me try to
respond and then I can talk to you
afterwards but the question was about
about the duplicate duplicate key
behavior that does not apply to hash
math hash map java.util hashmaps
behavior is unchanged so the the
duplicate key is only for the new api's
math dot of math dot of entries and yeah
there's there's some controversy about
that but why don't we talk about this
afterwards and I might be able to help
you with it
one more question
okay so this question was about the
internal implementations why did I stop
at two fields instead of ten well so in
a sense it's arbitrary
I believe there's kind of an exponential
decay of the number of elements in a set
so the the space advantage you get from
having five fields or ten feet yeah you
know a specialized set implementation
that had fields for five elements would
be much less useful than one for say
zero one and two elements because you
know sets with with more elements occur
less frequently but the you know as we
gather more data we may come across some
case where somebody says you know I use
sets with three elements all the time
and we pay this extra cost for storing
those in an array so we might add a
third a third set implementation for
that or actually we might even go the
other way there's some other reasons we
might want to reduce the number of
classes because it affects JIT
compilation and in a particularly
obscure fashion so the point is we can
change the implementations completely
transparently and and compatibly and so
your code doesn't have to change you
don't have to recompile and the API is
don't have to change either all right so
at that point we're out of time thanks
very much enjoy the copy</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>