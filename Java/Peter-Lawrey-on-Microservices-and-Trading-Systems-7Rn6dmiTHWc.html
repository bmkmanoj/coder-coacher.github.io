<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Peter Lawrey on Microservices and Trading Systems | Coder Coacher - Coaching Coders</title><meta content="Peter Lawrey on Microservices and Trading Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Peter Lawrey on Microservices and Trading Systems</b></h2><h5 class="post__date">2016-06-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7Rn6dmiTHWc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome to night hacking at the q con
new york conference my name is Stephen
chin I'm the Java q new manager and i'm
joined by peter lorre are you doing
Peter the end I'll too bad it's been
them good good conference so far ya know
this is this has been pretty nice q con
always does a good job with getting
solid technical content yes at their
events and speaking of solid technical
content you were you were doing one of
the many microservice talks here yes so
the focus for my talk was to provide a
different perspective from the direction
of FinTech or financial technology and
in particular what can microservices and
trading systems learn from each other
and the main takeaways there was that
microservices can offer some standard
tools some standard terminology and some
good methodologies for getting yourself
up and running quickly one of the things
that is often done in trading systems is
that they're often custom-made and
ad-hoc sometimes that's a good thing but
sometimes that's not necessarily adding
any value you may as well stick with
what it which is already available yeah
my guess is a primary concern for
trading systems is going to be high
performance like low latency high
performance yeah that is the primary
concern but that that's usually the core
part of the critical path that you need
to worry about the core part of your
system needs to be fast but the reality
is that there's a lot of tools and
functionality that goes around this such
as monitoring deployment issues your
deployment doesn't need to be so fast
your monitoring only needs to be so fast
your management tools build tools all of
these things are common across software
packages and they don't really need to
be customized only a small sections of
your code which need to be tuned to
death and that might be as small as 10
to 20 percent of your entire code base
so okay so if you can use openframeworks
for the rest of the
actually non-critical path and actually
take advantage of some stuff being built
for micro services which might also
apply then exactly you can gain a lot of
efficiencies yeah so another thing that
I've come across again and again talking
to clients and banks is that there's
sort of this feeling that I we're at a
bank we can't have nice things but in
reality a lot of micro services is
bringing together of best practices from
that have been around for some time and
in fact they will actually be using a
good percentage of those techniques
sometimes it's as low as forty percent
but it's it's a decent percentage and it
by rebranding what they have already or
at least taking a different view on what
they have already then they can see that
they are doing a lot of these best
practices already and in particular they
can see where the quick wins are so with
very minimal effort they can benefit
maybe take that forty percent to fifty
or sixty percent it's still not perfect
but that often that ten or twenty
percent improvement doesn't come with
much effort and so there's an
opportunity there to get improvement
with the low risk on the flip side
trading systems have been building
distributed systems that are highly
performant with asynchronous messaging
for a long time they tend to be
independently deployable although that's
not always a priority but certainly the
the ability for event-driven
asynchronous messaging is is a fairly
standard practice in US and
well-understood concept and where this
is significant is when it comes to
debugging and testing these kind of
systems which is something of a
challenge for a lot of microservices how
do you test and debug how do you deploy
these how do you even get understand how
to model an asynchronous service as
opposed to a synchronous one where you
used to request response things like
rest for a pis and I these problems are
solvable they have been solved and I
think it you shouldn't sort of reject
microservices on the basis that well
these are
these are issues and they're not always
handled very well because they can be
you just need to learn how to do that
okay so possibly something microservice
frameworks can learn from financial
trading yeah a lot of this is about
methodologies I'm very keen on
methodologies rather than necessarily
you install a piece of software and all
your problems are solved you do need to
understand what it is you're doing and
by using a methodology you can that's a
little unique is then you don't have to
change your products necessarily you
just use them in a different way okay
that makes sense so you also the second
topic you think it'd be fun to chat
about yeah so I'm a topic that I'm
working on at the moment is exception
handling and I know it's not in a very
exciting topic but it's one that's often
under undervalued or under looked
because developers spend so much time
trying to get their happy path to work
they don't actually have time or the
bandwidth to concentrate on well what
happens when things go wrong and so
often the answer is usually the answer
is it doesn't go right yeah well usually
answer is I don't know what to do so
I'll just log it and it'll become
effectively become a DevOps problem I
just kick it over the fence and they can
worry about it the truth is that this is
often the case and often the case is you
can't don't know what to do with these
exceptions but the reality is that that
doesn't have to be the case you there
are many situations where you can do
something about it and you should
probably spend a bit of time thinking
what are the alternatives to just
logging it how can i what i would think
what would be an example of a situation
where perhaps you could log it but
there's something better you could do
well a very simple one is if you're ever
thread that's been interrupted so you do
with red dot sleep one common pattern is
to reset the interrupt flag on the
thread so instead of sleeping you you
bail out of whatever it is you're
waiting on but you continue but you
leave the thread in an interrupted state
it's very common for people to consume
interrupts and then effectively making
it that they
it's a bit random it's like a random
shot if you interrupt a thread and then
then it becomes not a very useful
functionality whereas if you preserve
interrupts that will cause it the thread
to run through but without any pausing
and sleeping and keep that state and it
actually has a chance of shutting down
the thread cleanly that once not very
it's not very often that this is the
case but it's a very simple solution
yeah and probably in most systems it's
completely unreliable to use thread
interrupts just because of the way they
handle it that's that's that's very
unfortunately the case is that a lot of
third-party libraries you don't know
what they're going to do where you were
to interrupt them or if they will do
anything at all so that's that's a bit
of a challenge in using it but if you
know want to know how to make a good
interrupts handle them properly then in
this case for interrupts interrupt
exceptions you can reset the flag and
continue on a bit the best strategy is
if you can find some sort of fallback
mechanism where after a particular
exception occurs you take an action to
try and correct for whatever it is that
failed so a common one is if you're
doing say socket handling if you fail to
read from a socket you'll close the
connection you try again you reconnect
after some suitable time out period and
then attempt to continue on so there's
often suddenly when did a review of our
code base and then it wasn't certainly
was not perfect and and we made a lot of
changes but we ended up having nearly
twenty percent of all exceptions being
handled by a fallback position so
they're not just consumed they're
actually being handled automatically by
the code but it was only twenty percent
at some somewhere close to near eighty
percent or okay you were too yeah
actually close to fifty percent were
actually either logging recording or
just consuming somewhat close to
discarding but not necessarily yeah and
that the way we dealt with that is
rather than logging it we a call a call
back the next
caption handler the idea of the
exception handler is that you may just
want to log it in production but in unit
tests we can see every exception that's
actually run but it could while that
test was running and we make sure you
could actually check to make sure you're
using for the exception cases yes
because often these exceptions might be
thrown in another thread yeah so they
weren't necessary even if it blows up
that thread that test may actually pass
but the reality is you should never have
got that exception in any thread because
that won't necessarily get past back to
the current thread another thing that we
actually do is when a certain exceptions
occur and you're running in debug mode
it actually will pop up a stack overflow
page or that exception so it captures
the version of job you're running the
exception its message and then opens an
appropriate occasion to go straight from
the exception to Peter Lori's comments
about how to fix this something like
that yet it's something that you we do
anyway so it just saves you a bit of
time it's it's surprising the first
couple of times it happens but it's a
bit of a time saver because also because
so many people when they get exceptions
they just don't know how to make sense
of them and by bringing up a page that
attempts to decode it for you it can
look quite helpful well if they're good
they're probably are pasting it in
Google and searching for exactly so yeah
we have some exception handlers one for
stack overflow one for Google nice so
did you find that try with resources was
helpful when you're doing the exception
refactoring of your codebase we use try
with resources in quite a few places but
not so much the exception refactoring
probably the main one that we had was we
added lambdas that can throw exceptions
okay so we had code that's sitting
inside a lambda but it may throw a
checked exception and they these two are
not don't work very well together
unfortunately but what you can do is we
have a throwing suppliers throwing
consumer throwing runnable and these can
throw a checked exception and that way
the call the code that's been called
the lambda can throw a checked exception
and then have a consumed by the caller
and it comes through transparently yeah
so the other question I was going to ask
us with a good opinion about checked for
a son checked exceptions so well a lot
of people don't like checked exceptions
and I think that's because they don't
know what to do with them anyway yeah
and that's just annoying them so we we
sort of take a little bit of a bet both
ways I think checked exceptions are very
useful for developing libraries and to
give you an example I took one of our
check unchecked exceptions which was a
runtime exception and I temporarily
changed it to be a checked one and what
I found was that there were all sorts of
places that had been documented as
throwing this exception which didn't and
vice versa there was a lot of places
where it was actually being throwed but
not being documented and there was no
way to trace that through no practical
way of tracing that through without a
blue compiler helping you through that
process and i took some satisfaction in
a number of cases where it said catch
this runtime exception re throw it with
an assertion error saying this should
never happen and in reality the compiler
could tell me this never actually does
happen so i was able to eliminate that
those those sections of code so i think
is it very useful when i did that review
for this one exception i ended up 16
fixing 6 bugs and changing 65 files and
that would be the one also back to a
runtime exactly because actually the
reality is that i don't necessarily want
callers of this code to have to worry
about handling it because there's a good
chance they won't know what to do with
it anyway but for for developing the
library internally it was very useful
and in fact i actually have a hacked
version of some common built in runtime
exceptions to do exactly the same
exercise because i use illegal state
exception illegalargumentexception i
even try not as useful but i do it also
for nullpointerexception as well okay
it's pretty cool and then the
documentation will actually match the
unchecked exceptions that you
can actually get all right well thanks
very much for the interview Alicia Peter
and thanks everyone for joining us for
the night hacking lunch session here at
Keuka New York you can watch all the
live recordings at night hacking calm
and I will see you guys at a future
event such as Jake Reed very good all
right thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>