<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Three Microservice Patterns to Tear Down Your Monoliths | Coder Coacher - Coaching Coders</title><meta content="Three Microservice Patterns to Tear Down Your Monoliths - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Three Microservice Patterns to Tear Down Your Monoliths</b></h2><h5 class="post__date">2017-10-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/84W9iY3CwdQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so hi guys it's nice to see that you are
here so many people today we're going to
talk about three micro service patents
that you can use to tear down your
monolithic s-- and there are some
challenges we micro-services yeah of
course micro services are good but how
do you manage you notes how do you
coordinate you notes and how do you
ensure that you have your consistency
throughout your notes and how can you
test them and how can you really create
erroneous States I mean we are
programmers so we never do anything in
Fault to do we or not
at least I'm yeah exactly
that's that's good the blame game is
important so we're going to talk about
three patterns here we're going to talk
about event sourcing we're going to talk
about something called materialized
views and siku orest which stands for
command query responsibility segregation
I'm going to just briefly mention what
it is now so event sourcing is that
rather than writing the result or
something for example if you increase
someone's salary with a hundred dollars
you don't say
salary is equal salary plus 100 but you
say the salary increased by 100 that is
a difference you can replay that event
later on and you can see and trace the
entire state that followed up to a
certain salary for that person
materialist view consumes these events
and produces something that you can view
that is the current salary for example
and command query responsibility is that
you basically write and read from
different objects so the writing and
reading is decoupled and that's very
important so Emily here is going to show
a demo of a booking system by the way
ampere I invented a bunch of stuff I've
been working with Java
since 1.0 live here in Palo Alto in
California and I have a blog make sure
to check that out with millions of of
reads yes my name is Emil fortuned and I
also work at the same companies perahera
Speedman's and I'm also developer living
here in Palo Alto and my blog is called
age of Java but I would also like to
introduce our mascots
that's an open-source mascot that lives
on github and has three years of mascot
experience and you can check him out
later yeah cool yeah so what is speed
Matt Speedman is something that can
produce sequel queries from streams okay
don't leave omits know I should so if
you have a stream and a stream it can
produce equal so you don't have to write
your own sequel queries you can just use
streams and streams are nice as we all
know by now since the job eight and even
with Java nine they're even nicer so
that is basically speed meant and when
you look at it there is a more
remarkable resemblance between sequel
and the stream operations so you can
really construct basically anything from
a stream to sequel and you don't have to
live in this world of both languages so
that and I wrote and I wrote an article
about this in the recent issue of a Java
magazine so if you want to know more
about this you can go online and check
that out you recognize the table for
example there today we're not going to
talk about this so much because we can't
talk into more about microservices so I
just want to mention what it is it
converts the stream to sequel it does
lazy stream so if you create a stream
that only consumes maybe three or four
elements you don't have to pull in all
those result sets from from the database
it only pulls in elements as they are
being consumed we have complete type
safety because when you construct your
your stream you can't use an int if it's
a string and vice versa for example and
one cool thing is that you can use with
parallel database queries that is
something really really difficult to do
with JDBC and it's pure Java and it
supports both Java 9 and Java do it so
go to github and and try it out and with
that I will hand over to email for
pretty much the entire presentation
today so yeah thank you I'm gonna want
to do this most of the microservice
stuff so first of all I would like to
explain a few terms that I'm going to
use throughout the presentation used to
make sure that the the general language
and vocab
and confusing anyone so whenever we
speak about a client's you might think
that we mean an end-user but when you
talk about micro-services a client is
everything that can invoke a service so
another service could be a client so you
don't make any distinction towards
another service calling your API or an
end-user calling your API there are all
clients you also have services and
services are things that can be called
by a clients they are some kind of
business logic and it exists on its own
can either be deployed by its own or
deployed in the same machine or
something else but it's still its own
service a service can exist in multiple
instances which means that you can scale
it up and scale it down independently so
when we speak about an instance we mean
an instance of a service and services
can be accessed to an end points and
endpoint is the kind of the URL that you
use see it's the way you interact with a
service so that's just some some short
terminology so during the course of this
presentation we are going to be talking
about sorry I'm a bit too old for this I
think we're going to talk about
something called a booking system so
this is our our application that we're
going to build here tonight so the
baking booking systems purpose is to
allow users to book resources and we
don't really define what a resource is
because I want you to be able to imagine
its into any kind of situation that you
normally work with but it could be car
rentals it could be renting the laundry
machine that you're living a housing
compartment it could be any kind of
thing that you want to make sure that
users can book and we also are going to
support multiple users so there are
multiple users out there and there are
multiple resources that can be booked
and we can only ever allow one user per
resource per time slots which means that
our system must make sure that we can
never double-booked anything users can
also reschedule
things they can say that oh wait I
mentioned I wanted to book this on
Monday I actually want to make it on
Tuesday is that or they can compete to
cancel bookings at end time so this
means that the system must be resilient
to change
that the user can change the conditions
throughout the lifetime and we are also
constraining it so that every user can
only have a maximum number of bookings
open at the same time so these
conditions pose some some challenges
when working with micro services since
its requires us to keep a synchronous
state between different machines which
is not really how you you tend to do
things so the most easy way to implement
this system would be to create a
monolith out of it and basically one
single java application that stores
things in a relational database and
whenever the user sends a request like a
post get put requests and so on we
basically just authorized requests see
which user is doing this then change the
database depending on what the user did
and this is stateful which is not
restful even if we're using post and get
and so on to expose it so this is the
kind of thing we're trying to get away
from monoliths that are difficult to
maintain they're difficult to test they
are hard to trace what is actually
happening because once the database
state has changed you can never really
go back unless you start trailing audit
logs or something like that so it's
difficult to kind of get a sense of what
did happen on August 23rd when that bug
occurred and that is kind of lost into
the logs and whenever you want to do any
kind of maintenance like you you're
regularly updating these products you
have to take it down or temporarily
replace it by another service and this
can be quite difficult to maintain in a
continuous integration environments so
this is the thing that we want to get
away from so if you were to visualize
this kind of system it looks quite easy
I mean it's only three things that are
interacting with the children are very
nice and clear away so this should be
great right well it turns out that once
you start managing these kind of systems
it's not as easy as it seems because
first off you want to scale it up you
have to basically scale up the entire
thing you can't scale up one individual
functional tenets so that means more
licensing costs it means more machines
for doing things that are maybe not
really necessary
you also it's not very responsive for
end-user because every time the user
does something we every time the user
wants to do something they have sending
a request and it has to go all the way
down to database and all the way up
sometimes multiple times to respond to
that single query to authorize the user
to make sure that you're allowed to do
that and all those things so a lot of
systems I've seen take several seconds
to complete a single business
transaction simply because you have to
go several turns down to the database
back and then people complain over the
database but it's not actually database
that's being slow here it's the general
design of the system all the users yeah
or the users so this is the kind of you
know just reimagine the system we have
today so that we have a potential
creative improvements and we also have
no graceful degradation on failures so
if I were to you know unplug this one
machine and the entire system goes down
and the user gets you know strange error
codes in your browser so we want
something where a single failure doesn't
affect the integrity of the entire
system basically you can plug any kind
of system out of the wall and the system
will continue to work so instead we
combine these three design patterns that
we're talking about here tonight and
that's event sourcing materialized views
and Sagaris command queried segregation
responsibility and command color spots
build to segregation yeah all the way
around it so instead of storing States
we're basically storing changes so when
the user wants to book something we let
them book it we don't control if it's
you know acceptor or not we take every
event that comes in and we register it
in the database so the database is
simply a log of events that have
happened then when a an event is
consumed by one of the services that
service has to evaluate was this event
accepted or not so this is a bit of a
weird mindset I know you don't want to
store things in a database if it's not
supposed to be there right well it turns
out that these solves actually a lot of
problems and because if you have one
single log of everything that has
happened and you let every single
service for themselves
subscribe to this log
events and evaluate them every time they
read them it means that you can scale
the services up to as many instances as
you want because all of them will have
an eventual consistency they will
eventually be at exactly the same states
so to allow the user to in turn interact
with the system you have to allow the
user to to get access to this event
stream and allow them to subscribe to
events as well but the user doesn't
necessarily have to evaluate events they
just need to know when an event has
happened at the victim and then they can
request that from one of the view
services and to get a more recent view
of the situation and the materials views
is basically as it's taking the stream
of events and evaluating events and if
accepted integrate them with the current
States so they have a States they take a
new events check is this event correct
corresponding to the states and if so I
integrate it otherwise I throw it away
and in that way you only handle one
event at a time you'll have an eventual
consistency and and this aguar is part
the last part you have to keep the
writers and readers separates you can
never the writer can never know the
current states and the currents the
material of you can never know it can
never affect the the current States you
have to keep these two cool concerns
separates otherwise you will get
dependencies that are going to be very
difficult to it unravel so with the
booking system and if multiple users go
in and try to book the same resource at
the same time what is supposed to happen
and what will happen in this system is
that one of them will succeed the other
ones will fail however there will be a
period of time before they all know who
got it and who did not so that's where
the event log comes in the user needs to
be able to subscribe to the event log to
kind of see that oh my event is actually
being processed right now but here is a
nice message that shows you that we have
taken the event and we're considering it
and and if two bookings are changed at
the same time into the same time slots
so both want to book the same resource
at the same time but the book is already
existed that we just modified one of the
bookings should be modified and other
one
remain the way it was before so they
could be concurrently modified across
the system so at first when you just
visualize an event or system like this
booking system it looks a lot more
complicated than it did and when we had
a model live so you can see that I have
mapped out see the clients in this case
it's the end user and I've mapped out an
edge service we have a service discovery
service we have it some kind of
streaming service we have idea what we
call a calendar and a booking service
which is the they read and write
services we have the DB and then we have
a config service the stores
configuration settings all over the
place there's like seven services there
how can this be simpler and what we had
before well you have to take into
consideration that every one of these
services are really tiny in code because
they only have one single purpose so
it's a bit to get your head around what
they are all doing but when you actually
look at the source code for them you
find that most of these services are
trivial implements you can basically
just copy-paste them from the web and it
will work in your case it might have to
change a few parameters because when you
get each service down to this particular
one purpose it's really easy to test
theory sees released implements so if
you just visualize what is happening
here say that the user wants to say we
want to deploy this system first all the
us services need to register themselves
at the event discovery at the service
discovery service and in this case I'm
using Eureka but you can use any kind of
service here well what does it mean by
registering tell me more about that
yeah so when I serve the registers
itself it tells the service discovery
service where it is located and what
kind of service it can serve so it tells
it hey I am at this IP address I have
this porch and these are key at rest
endpoints that I can fulfill and the
service discovery service doesn't really
do much of this information it basically
a sends that information to the edge
service says that hey a new service has
been discovered and it has these these
at these endpoints and then the edge
service kind of keeps a ledger of these
where can I route people that comes in
what services do I have
instances of those service exists and
then whenever a user requests something
at service knows where to send that
request so the nice thing with this
design is that services never has to
know where the other services are
located or if they are even up and
running and because they all have to use
to communicate with the service
discovery service and then the edge
service is the one that is responsible
for routing traffic so you a decline
here once to a book a resource so it
contacts the edge service which is the
only service that are publicly available
for the user the edge service turn
routes that a request to the booking
service since its it's about writing
something it's about booking a resource
for a particular time and the booking
service done at the same time it sends
it kind of pushes the the information
down to the database creating the event
in the database as a new row and it also
at the same time sends back a receipt to
the to the user that says that I have
received this event you have been
assigned this particular sequence number
and that's really important because the
client needs to be able to know when
that event is being processed what is
happening so the booking service does no
evaluation it doesn't say that this
event was allowed or not it basically
has registers and a return packet
receipt the DB then the information goes
from the PDB down in the calendar either
by a push or by a pool it doesn't really
matter for the design of the software
and says that oh there is a new booking
event here then it's a true calendar if
it decides to accept or deny events in
either case it sends it down the de
stream and in this case the stream is a
WebSocket so the client can subscribe to
it and basically that this is the event
I received I have decided to accept it
or I have decided to reject it and that
then goes down to the client if the
event was accept that the client can
then add in look at event and see that
oh my request was accepted so I want to
see the most recent view of the system
so I send requests that I want to see
the latest calendar view
it's like the last week of our events
and where my event should be located it
goes down to the calendar view and the
calendar is returned with the modified
states so this is the basic setup of the
system and what you get for advantages
from this is that a services can be
scaled independently if you notice that
a it's the you know getting a response
from the calendar service that's the one
thing that takes time from the system
you don't have to scale up a booking
system you don't have to scale up the
configuration server or the database you
can basically just scale up the calendar
service so if you notice that some part
of the system is taking more time than
something else you can scale up that
individual service so you mean that you
can just add another node and that will
go to the service discovery and will be
a part of yes so and if the calendar
goes slow you just deploy a new instance
of the calendar service it will be
discovered but it's got the service
discovery and the edge service will get
a notification of this it will start
routing traffic there as well as the old
one and then you have basically double
the amount of capacity now and so yeah
that's really nice and the user also
gets immediate feedback I mean the user
doesn't have to wait until the event
goes all the way down to database and
back being a very evaluated and all that
the user can get a response immediately
from the first the booking service that
says that your event has been accepted
and it's being processed so that allows
the front-end developers for example to
show a nice animation for example if
while waiting and it allows them to get
a really responsive feeling of the
system and services can also be
maintained separately so if you're
working on the system and you're
implementing it and if you're working on
the book mister system you don't even
have to have the source code or free
kallergis its system running and if you
want to deploy a new instance you're not
affecting the already running instances
and you can kind of hot-swap them at a
new instance remove an old one and the
system will remain intact also if
something goes wrong if one service
fails for example there was a bug in
working systems so suddenly an errand as
input kima and all the booking services
went down okay
well the user will still be able to see
the calendar since they can still access
the calendar service so this is a really
important thing for the resiliency of
the entire system that one error should
not affect the others so of course there
are some services that are in this
design more important than others so if
the service discovery goes down for an
example and soon all the services will
not be able to recognize each other but
the edge server might still function for
a while while the services have the same
ip address as they had before so the
system can remain intact even without
the service discovery for a while unless
your start killing processes say
organiser so if we're going to design
this as a booking service instead of
having a relational database with
multiple tables for every kind of entity
in a database we try and put everything
in the same table and this is really
important because we have to be able to
replay it in one define order so we only
have one table called booking event and
it contains all the information about
that event that happened a the the one
service that can exist in multiple
instances but one service that writes
through the database does no evaluation
it might be able to sanitize some you
know HTTP requests or something like
that but it never does anything that
requires it know about the state of the
system and so everything that's a valid
just HTTP request is basically input it
into the database the database then
numbers difference so that they can be
read sequentially so the database gives
every new event the number so that they
we know that all the clients
independently of where in the world they
are located they will all consume the
events in the same order and another
service evaluates all the incoming
events when they have been numbered by
the database and they materialize them
into a view that the user can query and
the system is eventually consistent
across all the instances so to describe
a little bit more about the first
pattern here event sourcing and so we
have mentioned that the relational
database doesn't store any States
it never stores that this user has this
username or anything like that it only
stores the dish information that has
changed since the last state
it also doesn't store if the state was
accepted or not it's only stores that
this is the thing that I that the
booking service saw happening so you
don't need any update or delete
statements you only need insert and
selects because you're never going to
change anything since that was the truth
at that time okay so you're saying that
the database is basically a cue yes so
the databases handle is one big
persistent cue you'd also don't have any
indexes except potentially the primary
key which is the sequence number because
indexes in this case only tends to slow
things down if the database has to
update the index every time it doesn't
insert it's going to slow down the
writes and the reads are not going to go
through the database anyway they're
going to go through the materialized
view so your entire database design it's
collapsed down to one table with no
indexes and no joints it's quite an
simple assignment and
you don't have any trouble with conflict
resolution since the only thing the
database has to do is basically just
increment an integer and an insert so
the database can handle thousands of
writes per second even if you're using
an open source database like my sequel
and since events are evaluated when they
are read the reading of the events does
not affect the the reading can be scaled
up independently and the writer does not
have to know anything about the current
States so you never have to synchronize
with the rider the rider can just sit
there and know nothing about the system
you can just write everything into the
database so - the second pattern the
materialized views and the end user
never queries the relational database
they only query the view so one request
to the materialized views does not cause
the request to the database and that's
an important thing to get into your head
because that means that the scalability
is extreme and is you can have tens or
hundreds of millions of users paying in
the system and a database can still use
time because the database does not get
any requests per a request from the user
it only gets requests
at the time interval when when the read
services D materialized views are
querying results when a new service is
started a new materialized view service
and the it loads all the events that
have happened from the beginning of time
from the database and this process can
take a while
in some cases we with our service it can
take several up to a minutes to load all
the events and that's ok because there
are usually other services that are
available and can take in traffic
I'm not sure answer the question but you
were wondering if it wasn't a coupling
between the writer and the reader
yeah
if you want to change the schema
structure you do have a carpeting in the
sense of the design of the system and
I'm going to explain how to solve that
later on it's not a materialized view in
a database it's not materialist view in
the memory some people might think that
there is a concept for certain databases
that it's called a materialist view but
this is another concept yeah
yeah then you start to have a lot of
coupling so we don't want that we want
really simple services that can really
do a very small thing and if you
introduce a monolithic like coherent
caching I think then we're pretty much
back to square one but it's definitely
something that we can discuss afterwards
and so in this case once every second
events are being pulled from the
database and merchants review and now
some people might be thinking well
pulling and pulling is a bad thing we
have had bad experiences with poling a
database especially at timed interval
and so I just want to take a moment to
kind of put up the math here when you
don't have any indexes on a database and
you don't have any joints you're
basically is having one table with an
incrementing integer how many requests
per second do you think that database
can handle say that you're running a
single instance of my sequel for example
just throw out a number here then one
there's 5,000 per second yeah not
reasonable to think 5,000 per second
should definitely be able to handle on a
laptop yeah or a laptop and so if you
have 5,000 requests per second as a
capacity it means that you can have
5,000 materialized views polling this
database if they are you know polling at
some at different time intervals yeah so
if you can have 5,000 materialized views
and every materialized views it's just
an in-memory view of the current state
and every materialized view should be
able to handle quite a lot of traffic
you can kind of get a sense of the total
amount of users you can have in this
system and that's just with one single
note of my sequel so polling the
database is usually a bad thing but not
if it's pulled from an internal service
that can exist in a few thousand
examples so when events are evaluated if
they're accepted they are merged into
the view so it means that the the
materialized view service has to have
all the rules regarding what to expect
from an event it has to be able to
evaluate that and that's kind of the one
thing that's a bit tricky to get right
with this kind of design
because the rulesets tends to change and
you have to kind of be be careful when
you change it to make sure that you're
not affecting previous events so also
views are eventually consistent across
all the instances yes when an event is
consumed by the and it's supposed to be
materialized in the view then you apply
all the business rules for this event so
say that event says that a user one try
to request the the laundry machine at
this date and another event said that
user to try to request the laundry
machine at that date and what the
materialized view does it takes the
first event and sees is the laundry
machine available at that time yes it is
okay I accept that event and then when
the second event comes in it looks at
loaner machine and look so it seems to
be booked at that time so I rejects that
events so that's what I mean with
accepting and rejecting and that's done
when when materializing it's not done
when you are entering inter database I
would registered in the materialized
view I would not register it in the
database because that will create a
coupling from the materialized view to
the database and it's only booking
service that's allowed to write through
the database so yeah so the third
pattern Sagaris it comes into this
particular query and so it stands for
quite clear responsibilities decoration
a command is something that's writing
something to changing the states and a
query is something that's interested in
the states and the general idea of this
entire design philosophy is to never
allow those two to be on the same
service so the writers they are never
allowed to know about the current states
because that requires them to query
something and that destroys the pattern
the reads are never allowed to write
anything like you say they are never
allowed to register anything in the
database because that creates another
dependency so both services can exist in
as many instances as they need and they
never need to synchronize with each
other because they all the materialized
views are eventually constants
and the writers are not not allowed to
look at the current states which means
that the information can go in one
single direction all of the time and
yeah we just used the relational
database as a persistent queue nothing
more so some of you might be wondering
why do we use a relational database at
all why not no sequel and so it
basically comes down about the same
thing when you take away all the things
that are slowing down relational
databases like joins foreign keys and
indexes and such things when you're
simply writing - it's the performance is
usually about the same as writing to a
new sequel database so it comes down to
a matter of taste actually what is
easiest for your team to manage and to
deploy and since the the performance of
the relational database is very rarely a
bottleneck in a system even if you were
to see some some performance gains by
replacing the database that's usually
not what be the best way of improving
this performance of the system and so to
the implementation of this booking app I
know that you've been waiting at
disability for this and I'm going to a
go a bit you know fast-paced overts but
I want to first say that's all of the
source code I'm showing here today it's
available around github page so if you
want to look at it afterwards you can
just go there and there is a repository
called event sourcing demo where you can
see all of these and but first off we
used my sequel to store the event log
and spring boots to create a REST API we
use Eureka for the service discovery and
a Netflix tool for the edge service we
also use Project Lombok to reduce the
boilerplate own system and Speedman's
our own products to write and query the
database reusing your ID streams it
looks like everybody put up their phones
so I'm going to stay on the slide for a
little while by the way the repository
that Emily mentioned is under github
slash statement yeah
yeah so short how he works if you want
to scale anything up you just launch
those processes as new spring has been
configured to generate the random port
for its service you can basically just
launch as many services you want
potentially in AWS from google cloud or
something like that and when a new
instance comes online first it starts by
downloading the the event log from the
database so we'll start pulling in data
and about a thousand events that never
have a stupid question again so what if
we have like millions of event loaves or
trilliums yes so that's when we use
something called snapshotting
snapshotting is not covered yet in this
example they just didn't have time for
it but if you want to develop a snapshot
service it's really easy to introduce in
this model it basically doesn't have the
REST API that's itself use Prem
subscribes to events from the event log
every now and then like once every hour
once every day it just saves the
materialized view down to file and then
when somebody requests that the most
recent file used serve it to them so you
mean you can restart from that position
yes you can restart since the order is
always the same of the events it's quite
a trivial tasks to start from from one
particular time and be in the sequence
but I might get to do implementing that
service as well
so when the new service starts it
downloads all the events up to the
current time from the database and
sometimes this might take up to a minute
or so the service discovery then picks
up that the notice there is a new
instance of the service available so
I'll send a notification to the edge
service to start routing traffic there
and the edge service will continue
routing traffic there until it starts
getting weird exceptions that the
service is not no longer available and
in that case it basically removes it
from from the routes so it's an easy way
to scale up the system easy to scale
down you just start processes or kill
processes and the system will remain in
what capacity it can during those
circumstances so the for the sequel
table that we are using as the event log
there are a number of things here that
are interesting to note first off we use
something called a sequence
that's basically the number that the
database gives gives every incoming
event so that they can always be
replayed in the same order and this is
also the primary key in this case we
also have a column called verson that is
something I learned the hard way that's
if you don't introduce a column called
verson it might be really difficult to
change the database schema later on and
I think that was what one of you were
were kind of hinting at if you want to
change the database schema afterwards it
can add some some trouble implementation
wise so what I recommend in those cases
that we've been doing is that you
basically update all of the materialized
views at first one at a time to support
both the old schema and a new schema and
separate the events by using this value
of the version then when all of them has
been updated you can deploy them one at
a time since they can both handle both
worlds then you change the persistence
logic and a little then you change the
database schema to to support this new
version making sure never to lose any
information because you can never remove
anything from the event log so you can
for example add a column that has a
default value for example that's allowed
if you increment the the API version and
then when you've done that you update
the D writers so if the writers came
right by this new standard and in that
way you have a coordinated way of
updating the system but as you can
imagine making changes to the database
schema adds a lot of pain so try and
ever use it unless you have to so one
way of making sure that you don't have
to do it unnecessarily is to not store
anything that might change in the future
in the event log also a truth learned by
experience so in this case you might
notice that it's not really storing any
vital information
it's just storing binary sixteen which
is a varieties in in my sequel so you're
basically storing that there is a
booking somewhere with a particular ID
there is a user somewhere with a
particular ID and there is a resource
somewhere able to put a particular ID I
don't know what the name of the
resources I don't know what the username
of the user is or anything like that
I only know that this is an end user
that I can identify and if you start
adding other information to the log you
might get problem a problem later on and
we also store the book from and book 2
basically because we need that to
evaluate events that are coming in if
they are allowed or not so for
implementing the D relational mapping
and we use Speedman's which makes it
really easy you just run a single maven
goal and really generates all of the
classes that you need and it's maven
Speedman : tool i had two talks earlier
on this the other one about that so I'm
not going to go into any details here
but the this short version is that
Spirit generates booking a booking
implementation booking managers and so
on and it's similar to how APA does
things except that with speed mint we
generate the boilerplate for you which
APA generates the database from the code
so it's the other way around and speed
with is designed to work with the stream
API which works really well in this case
and so when Spearman starts you connect
to the database in a graphical dialog
you just press generates and you have
95% of your application time already
yeah so yeah that's basically the things
we said oh and the last thing we also
have an open source plugin for
integrating with spring so if you use
that plugin will also generate all the
spring configuration needed to setup the
database and everything that's been used
today is open source okay so the booking
service nothing new here two things to
note we enable service discovery and we
make it a spring boot application that's
just to set up the application then when
we want to implement a controller for
actually inserting things in the
database we just Auto wire in the
manager that Speedman has generated and
then we use a spring configuration
values
that's called API version that defaults
to one just so that we can easily change
it in the future if you want to
programmatically add a new API version
when we want to we also use Lombok here
to kind of set up a boilerplate for the
booking request and a booking receipt
the
the two things that are sent out from
the booking service so when a request
comes in we want to return a booking
receipt and we want the request to be
formatted as a zone so we use Jackson
together with Lompoc here so this will
generate all the getters and setters for
us and D we also add a few helper
methods it's called a new booking event
this creates new events sets the like
the use of resource and such from the
request coming in and I use the the
other eight time API here you might not
be familiar with it but
basically the user specifies if you look
at the previous one at times as an
officer type date it's time which means
that they can specify which timecode
they are referring to when they say that
I want to book that at 8 o'clock and
then the server localizes that time to
its own time zone before inserting into
the database and then of course you need
to make sure that the server is running
on the same time zone as the database
creating a booking is from the remember
the rest api is very simple we wrap a
speeding request to persists the row
into the database in a crate receipt to
get a response to send back to the
clients this is all the logic required
to do persist things in the database you
might also notice that we set the type
to create booking we never do anything
other than persisting which means that
if the user wants to updates a booking
we don't update any existing rows we
basically persist a new row and set the
time to update booking and then we use
the same booking ID as the previous one
when you want to delete a booking or
cancel it
what you do is basically send a delete
request with the UID of the booking that
you want to handle and then we notify
that as a canceled booking request so if
we want to test the service right now we
just do a curl command that URL and we
say that hey I want to post to the
booking system I have this user this
resource this booking from and is
booking to and I want it to be persisted
and if you want to add security like you
probably should do this I would suggest
you use JSON web tokens to handle it
because that's a really restful way of
handling user authority and it has
built-in support in spring security so
in this case when I send this request I
get a response back with that is nicely
formatted with the location tag set to
where the booking is going to be located
once it's accepted or rejected as well
as the the sequence number and the event
ID given to it so this allows the client
to hook up to that URL and start to show
a nicely formatted message to the user
the calendar service works similarly we
just enable the Eureka and we enable
spring boots and we then set up a
booking view which is going to be our
materialized view I use scheduling so
enable scheduling and service to make it
a spring service and then you can see
here that the materialized view comes
down to use the basic hash map which
bitmaps from the UID to the booking and
I also have a few listeners to be able
to send them further onto WebSockets
without Hocking the the optical loop so
then again is Lombok to create the the
booking and a booking confirmation
that's going to be stored interview used
to avoid all the boilerplate of setters
and getters so the booking confirmation
is what is sent back to the client over
the WebSocket to be able to notify the
user that's the booking has been accept
through tonight and it's just an enum in
there with accepted or denied as well as
all the information about it I also
added a string message at the bottom yes
so to allow the server to to add
information to the user like the the
request was denied because somebody else
had booked this resource also to make it
easier to develop a front-end that's
showing relevant information and then I
added the post construct to be able to
load from database when when the service
starts before it's going online and I'm
scheduling appall every second
the actual loop that is appalling
you saw dat Paul for events method it's
using the spinning stream suggest
streams over the demand you're handling
events filtering out every that has a
sequence number greater than the last
events limits that to a thousand
elements and it rates over them oh yeah
yes it notes the it materializes the
data into memory so if you have a lot of
events regarding the same booking they
are going to be collapsed down when
materialized but yeah it loads in memory
that's the hashmap different so why do
you have a limited one thousand Lari yes
it is basically because i don't want to
hang on database too long so we noticed
after a wild when you start a new
service for the first time and it might
take a while to reload all of the events
that being processed so far unless you
snap shopping so this was an easy way to
allow other logic to to come into the
loop and not hang too long and so it
just takes a thousand at a time and then
the years since an atomic boolean to
kind of switch back and continue working
in case there was more events it's just
a a small hack to to get that repeated
loop you can also see down in the right
here the sequel query that's been in
generates so it's really actually a
nicely formatted query even if you use
the de predicates and limits yes the
calendar service is quite easy we just
out a wire in the booking view the one
we created earlier and then we expose
two different rest endpoints for
requesting all the bookings or
requesting bookings by particular UID
and we also have so you can book by find
all the bookings for a particular
resource and or all bookings for a
specific user it was just something we
added to to make it a little bit more
interactive so when we test this we do
it by using curl again just say that hey
i want to read this booking and we can
see that the booking has been accepted
by
seeing these tears of 200 and then we
can see the information which user was
that book this what was the resource and
so on
it looks like I've spoken too much but I
was always done with the presentation
please feel free to look up
Speedman afterwards the the library we
were using to do the database logic here
and like I said all of the examples here
today are fully working on on Gita so
yeah thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>