<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java EE 8: What’s New in the Java EE 8 Release | Coder Coacher - Coaching Coders</title><meta content="Java EE 8: What’s New in the Java EE 8 Release - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Java EE 8: What’s New in the Java EE 8 Release</b></h2><h5 class="post__date">2017-10-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/FCsqchsK9UA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay guys finally sorry for all the
technical difficulties here well beyond
our control before I get started full
disclosure I've been dealing with a
nasty cold if I lose my voice I
apologize in advance that may happen so
welcome to the session on Java EE 8 I am
Linda de McHale I'm one of the
specification leads for the Java EE 8
platform and in this talk I'm going to
be talking about the new Java EE 8
release what we accomplished what some
of the new features are this is very
much a high-level overview talk at the
end of the talk I'll be giving you a
list of pointers to sessions to where
you can hear about many of the api's
from our spec leads in greater depth at
this conference I'm not used to two
windows anymore so I hope I'm not going
to fumble this too bad so I'm gonna
start with a brief overview of some
background a little bit of the history
of Java EE 8 why it took so long perhaps
and then the bulk of the talk I'm gonna
be talking about the jsr s and M ARS
maintenance releases that we addressed
as goals in Java EE 8
I'll say a few wrap-up words about our
current status and our plans for the
future if you went to one of the
keynotes this morning you may have had
heard some things along those lines and
then finally I'll leave you with some
pointers to other presentations so Java
EE 8 is the next and probably last step
in the Java EE brand in the development
of the enterprise platform for us here
at Oracle so the platform has been
getting bigger obviously we have the web
profile if you don't need the full
functionality of the full platform in
this release we've kind of we followed a
lot of the goals that we set for
ourselves in Java EE 7 namely a focus on
web tier technologies making sure we're
modernized with the web tier
continuing our trend towards ease of
development largely through leveraging
the facilities offered by CDI and then
another item that we wanted to address
for a long time was modernization and
simplification of the security api's so
quick overview of the history here we
started this work on this release when
we filed a SRS back in 2014
unfortunately there was a period of
hiatus almost a year as some of our spec
leads got diverted to higher priority
tasks internally and it looked like we
weren't making a whole lot of progress
so in 2016 when our resources again
freed up we took a step back and we
looked at were we really focused
appropriately how do we get a release
out with a high priority items
accomplished in the timeframe that we
thought we were going to address namely
by 2017 so what we did was to try to
focus on those items that we thought
were the most important so these were
the original goals for Java EE 8 in
terms of the jsr s that we that we filed
but after we got over underway we
realized that some of these were less
important for new trends in the cloud
and in micro services and perhaps we
should down prioritize on those so what
we did was we conducted a Community
Survey the goals of this were to
validate whether our intuitions for how
we should refocus we're really
appropriate
indeed the survey did we thought that we
should focus on web tier technologies
modernizing for the web tier and that
other areas like JMS which was a
relatively mature technology that is
less important for cloud environments
the management API that we wanted to
address again the existing
management API well this would have been
a good modernization of it was not
heavily used so we said okay maybe we
don't want to prioritize there and MVC
which was a new jsr a lot of
applications in the cloud of course ship
headless so MVC seemed to be less of a
priority for us well we did with the MVC
jsr is we hand that off to members of
the expert group and that has been
successfully completed MVC 1o although
it's not part of the Java EE 8 platform
per se ok so this slide reflects the
changes that we made dropping the
efforts on JMS and management and then
cutting loose on MVC ok so now I want to
get to the meat of this talk which is a
survey of the various J afar's
as I said before our focus areas are
gonna be on web tier enhancements ease
of development through leverage of CDI
and then simplification and
modernization around the area of
security so of these most of the focus
was indeed on web tier and leveraging
CDI in the process so I want to start
there ok Jason processing the Jason
processing API was introduced as part of
Java EE 7 it was the new technology then
we want it to continue to evolve it to
keep pace with emerging standards and
there were three standards that were
produced by IETF that we wanted to track
and incorporate into the api's for JSON
processing namely Jason pointer Jason
patch and Jason merge patch we also
wanted to add classes and methods to
better utilize the java SE 8 stream
operations so that you could leverage
these in in your quote unquote JSON
queries
okay so Jason pointer it's what its name
suggests it's just a pointer for
pointing into a Jason document for
referencing a JSON value it has a string
based syntax and it's got methods to
allow you to extract the value or to use
the pointer to transform your jason
document with add remove and replace
operations so if we look at a simple
example we're creating a pointer we have
a document on adjacent array on our on
our right and it's got two elements one
representing Duke the other representing
Jane they have phone numbers and so on
so we create a pointer the pointer at
this point is just a pointer it's not
yet referencing into our document so to
do that we we pass the reference to the
Jason document as an argument to the get
value method of the pointer and then we
use that to extract them sorry we use
that to extract the relevant value so
here's our document again this time I'm
going to use the replace the replace
method of Jason pointer to transform the
document and I do so in the obvious way
replacing the value of the first element
of the document with a new mobile phone
JSON patch patches itself adjacent
document and it expresses a sequence of
operations that you apply to a target
document and IETF defines the exact set
of these operations namely operations to
add remove replace to move or to copy so
what you do is use the JSON patch
builder methods to create the patch so
you construct the patch and then you
apply it to the document with the apply
method
I'm the to Jason array method allows you
allows you to do you convert your patch
so here's another example so we use the
patch builder to construct the patch and
then if I can see this without moving
around so much and then we use the
replace method - we use the Builder
method to construct the patch and here
the patch has two operations one to
replace a value and then the second to
remove the second element of the array
now when you execute a patch these
operations are applied in sequence so
the subsequent operations of the patch
can reference what was done in the
previous operations of the patch if
that's what you want so here we build
the patch and then when we apply it the
first thing that happens is the
transformation of the phone and then the
second thing that happens is the removal
of the second element so merge patch is
another one of these IETF standards and
the way this works is somewhat
differently you basically compare the
value in the patch to the value in the
original document and then depending on
how they relate you produce your output
so if the if the element that the patch
references is in the original document
then you transform the value that's
referenced if it's not existing in the
original document then you add it to the
document and if it's got a null value
then that says remove the element that's
there in the document and then finally
I'd like to talk about what we did with
regard to support for sc8 stream
operations excuse me
so here we've got we can think of as a
JSON query we're using our contacts
document again
so we're filtering here for those
elements that are of female gender and
then we're extracting the names and
we're collecting the results so notice
that using a built in Java SE collector
where we're extracting these as a list
but the result is a list of strings so
we're outside the JSON world so the
solution is obviously to introduce
specialized JSON collectors so this is
the same query if you will but instead
of just extracting as strings we're now
extracting in terms of a JSON array so
that you can in general apply subsequent
operations or continue in the JSON world
with your results okay do some binding
this is a new API that we added in Java
EE 8 what it is is it's a jax be like
api to Marshall and unmarshal between
Java objects and JSON documents so it's
attended as a natural follow-on to
augment the capabilities of the JSON
processing API so like other mapping API
s that we have things Docs B or JPA
we designed this so that for convenience
one there's a default mapping between
the classes and the Java the Java the
class is an adjacent document and then
there's a rich set of customization
possibilities so these customizations
can be achieved either through
annotations which could apply to could
apply to single properties or fields or
a class level for some of them or if you
want to do something more general and
even more customized than the
annotations provide there's a
configuration API that you can use to
execute certain transfer
nations or customizations at runtime the
other thing I want to mention is when we
started this work there were already a
number of Jason binding or Jason binding
implementations out so we want it to be
flexible and allow you to choose if you
have a preferred Jason binding provider
you don't necessarily need to know used
to use the built-in one you can choose
the provider that you would like so a
couple of key api's here one is the
Jason B builder which is the clients
entry point into the binding API and
this gives you operations for setting
the provider implementation and setting
configuration properties and it's also a
factory for the Jason B class and the
Jason B is an abstraction over the
operations of the framework so this
gives you your operations of from JSON
and to JSON your serialization
deserialization operations so a simple
example we have two cars we're going to
put them into a list in Silicon Valley
maybe there are just Priuses and Tesla's
I mean they're pretty common here and
then using the JSON B api's we use the
Builder to create an instance of the
Jason B class and then with Jason B we
invoke the to JSON method to serialize
these these instances to a adjacent
document I've cheated a little because
I've done the pretty formatting a I know
I don't know if that's a built-in
customization or not there's certainly a
formatting customization option you can
use so you can do other things there's a
default naming for property and fields
you can use annotations to change that
if you like you can use annotations to
change the null behaviors whether you
want or
don't want nulls to appear in your
serialized JSON and then there's a rich
set of customization options and these
run from naming to ordering what
sequence you want things to appear in
null handling what you want to ignore
what you want to bring into your
document or classes formats for data
numbers and coding and adapters adapters
the adapter API lets you define custom
mapping so you you implement two methods
adapt to json and adapt from json and
then these will get invoked for you so
here we're using json config we're gonna
you know do our pretty formatting and
we're going to use a car adapter that's
going to do our transformation and then
we pass this config to jason be builder
and it will be used when we when we do
our serialization and deserialization we
could also specify here again using
builder that we want to use a particular
provider so this is just an intermediate
step
in the configuration
okay so jax-rs has been another really
successful API for us there were two key
areas where we wanted to provide
enhancements in this release one
providing a reactive a really reactive
client API leveraging what Java SE eight
at it and then support for server sent
events server sent events were specified
in the HTML html5 standard and then
there's some other more minor
improvements support for Jason B entity
providers to facilitate your mappings
and HTTP patch requests so this is the
way things looked in Java in jax-rs - Oh
stepping back a little bit in terms of
client api's jax-rs - Oh introduced a
client API that you could use either
synchronously or asynchronously in this
case we're using it synchronously so you
build up a request and then you you
issue the request so that's not terribly
interesting but it was a step forward
and you can specify in the client API
that you want an async invoker rather
than a regular invoker and this allows
you to get back your results in terms of
a future
or perhaps more flexibly you can pass a
you can pass a callback to give you
notification of the results of the of
the request with a completed method here
or if the request ends in failure then a
failed method so this gives a little bit
more flexibility and then you can you
can check the status of this using the
future so what Jax rs21 does is it
offers an improvement over this style
which gives you more flexibility namely
an Rx invoker which gives you back
instead a completion stage so in this
simple example we're passing a method to
the completion stage that just basically
says print it out that's not terribly
interesting but things get more
interesting when you look at the few the
the real capabilities of completion
stages namely that you can execute
multiple requests you can combine them
you can sequence them you can choose
which one your you're going to go with
and then at the end of the day we're
finally going to accept and print out so
in this case what we're doing is we're
taking the the two results the the
completion stage results here we're
combining them we're concatenated them
and we'll get out some kind of printout
that looks like hello bonjour at the end
of the day
so server-sent events is targeted
allowing the client to subscribe to a
sequence of event notifications from the
server the way this works is that the
client establishes a connection to the
server this is an HTTP connection but
it's a long-running connection that's
held until it's closed by the client and
it's reused for multiple notifications
from the server you designate this with
a special media type an event stream
media type and then an event object
itself is structured it has a payload
which is our corresponds to the data
field and it has other information a
name which can be used if you will to
identify a channel perhaps an ID which
you might use for some sequencing
operations or keeping track of what's
coming back retry and comment fields so
there are two sides to this API in in
jax-rs to one the client-side uses these
are the most important interfaces at the
client side the event source which used
to open the connection to the web target
and then subscribe your consumer it's
Auto closable but you can close it
explicitly and the inbound SSE event
which is what you're going to use to
extract the notification that's been
sent from the server so on the client
side you might have something like this
we're constructing we're getting back an
event source and then with us event
source we're registering we're
registering the method that we want to
have invoked when the event comes in and
then to kick off the flow of
notifications from the server we open
the connection with the event source
open method
the server-side has an event sync as you
might expect this is injected as a
recess a parameter to the resource
method on on the server side the
instance corresponds to a single client
HTTP connection and the server uses this
to send the event to the client SSE is I
guess you can think of it as a factory
class for creating new events or
creating event broadcasters and for
configuring the events so on the server
you might have a resource method that
looks like this so notice that we've
designated the media type the media type
is again the text event stream media
type is what the service and events Maps
to and then in our SUBSCRIBE method
we've injected the event sync and we've
injected this SSE factory method and
then we're using the event sync to send
the new event over to the client
another big-ticket item that we're
addressing in the servlet API and
servlet for oh because this was a fairly
major undertaking was support for the
new HTTP protocol this is another recent
standard from IETF and the goals of HTTP
2 are to overcome the limitations of the
existing HTTP one-one protocol namely to
reduce latency to support parallelism
without requiring you to have multiple
connections as a workaround to achieve
parallelism to address the head of a
head of line blocking problem basically
many performance improvements while
retaining the semantics of HTTP 1 1 so
this looks more or less transparent and
what makes this work there's
request/response multiplexing over a
single connection with a binary framing
layer and the binary framing layer
allows the frames which are sent over
this connection to be identified as
which streams they correspond to so that
you can so that you can demultiplex on
their receiving in and extract the
stream of messages that that are a
consistent stream of messages
it also can contains a server push API
so the server can optimize by pushing
data to the client in advance of the
clients request for it so then the
client can cache this information so for
example if you're sending over the data
that's been requested for an HTML page
you know or you can anticipate that
maybe you want to send the CSS data
early on you want to push that out or
you want to push out other needed
information before before other
information
there's also facilities for header
compression to again make this protocol
more efficient so this was the
big-ticket item for
servlet for Oh support for HTTP to the I
believe the there's a talk on servlet
for Oh later in this conference I'll
give you the pointer I believe the the
main or only user application visible
feature here is the server push API so
that you can configure your pushes on
from your servlet and that looks
something like this there's a push
builder API so you can construct the
push referencing what you want to push
and then headers or other other
information that are appropriate for the
transmission of the push and then you
can push this out to the client JSF is
certainly a mature technology this was a
2.3 release which I think indicates that
I'm not going to say much here except um
the expert group addressed an enormous
number of smaller feature requests and
JIRA items when I initially prepared the
slide the spec Lee told me that
something like 600 some JIRA items had
had been resolved in this release so
certainly non-trivial from that point of
view but some of the things that this
contains are improved integration with
CDI support for WebSocket integration
Ajax method invocation and then
leveraging being validation and the new
date/time support
okay so speaking of cd-i which is a key
technology for us
CDI 200 was a big release but one of the
main focus areas of CDI was not so much
Java EE as providing support for use of
CDI outside of Java EE namely with a
bootstrap API to let you bootstrap a CDI
container in SZ environments the expert
group wisely split the spec into three
parts when they were doing this a core
CDI which is used both in EE and SC
environments and then those api's that
are specific for use in SE environments
like this bootstrapping api and then
those api's that are used more in Java
EE think session beans because CDI does
in fact speak of EJB session beans and
how they're used in CDI from an EE
perspective I'm going to talk here
mostly about the improvements that were
made in observers and events there were
a number of other features that were
done annotation literals which are an
ease of use capability alignment with
some of the new SC features the stream
API repeating annotations lambdas use of
completion stage and many enrichments to
the the CDI spi okay
events and observers this is what things
look like in CDI 1:1 or EE Java EE 7 you
construct an event and you fire it and
when you fire it the observers are
invoked synchronously there they're
invoked in the same thread as the fire
method and they're invoked in whatever
order the CDI container chooses to
invoke them in
in CDI to OCD I made two improvements
here first of all it gives you the
ability to order synchronous events
using the priority annotation so
priorities and annotation in common
annotations it didn't use to apply to
two parameters we updated the common
annotations with an M R so that you
could do this and now you can order your
observers so that you know when an
observer triggers if you want to
leverage what was done in that observer
you have this determinism the other
improvement that was made was support
for asynchronous events so when you fire
an event asynchronously you're
guaranteed that there's at least one or
more threads that are going to be used
for for the firing of the observer
methods that are responding to this
event and the way you designate those
observer methods is with the observes a
sync with the observes they sync so as
you might expect it would be non
portable to specify priority with a sync
observers because of the nature of being
async you're not going to be able to
order them in any deterministic way so a
couple of things to note with this one
the same type of event can be fired both
synchronously or asynchronously
but the observers that are eligible for
being notified of the event depend on
whether they are synchronous observers
which would be notified for a
synchronous event or asynchronous
observers which would be notified for
the asynchronously fired event with an
asynchronous observer is called in a new
life cycle context and it and a new
transaction context so they can't be
transactional in the sense of the
synchronous observers okay how am i
doing on time
okay beam validation so this is another
two oh I think for good reason it
includes many useful new features its
modernized to to leverage what Java SE 8
provides it's got support for the Java
time api's repeatable annotations you
can apply constraints to collection
elements to optionals and it has a host
of new constraints some of these were
already there and hibernate validator
and I think they had gotten a very
positive reception there so the requests
were made to add these into the standard
beam validation as well so a host of new
constraints so some of these passed
repeating annotations when we did all of
these J SRS and the maintenance releases
that I'll be talking about we've been
opportunistically introducing repeating
annotations we haven't read specs just
for the purpose of adding repeating
annotations but I think most of our J
SRS have undergone enough changes that
we've been we've been leveraging
repeating annotations so that's now
pretty consistent across the entire each
platform constraints within container
elements such as here where you want a
map of a valid customer and a valid
account or with optionals the last
example here illustrates the the new
annotations the fact that your list
should not be empty at the result of
this and that you want the customer
emails to be non blank strings that are
configured appropriately as email
addresses
okay the new Java EE security API this
is something that was requested for a
long time so there are a number of key
new api's that were added here I'm going
to talk about these three security
context the HTTP authentication
mechanism API and identity stores so
part of the goal or a large part of the
goal is simplification of security in
Java EE common approaches common
mechanisms and leverage of CDI to
specify one how these work and two how
they're configured so security context
this has methods for authentication
authenticate would be used in the web
tier get color principle and get
principles by typing is call a role if
you're familiar with the servlet and EJB
spec you'll notice that we didn't have
uniform naming across these api's which
is you know generally a source of
confusion and typos I guess when you're
trying to write your applications so
these are intended to supersede the
existing inconsistently used method and
consistently named methods which of
course you can still you can still use
so to have a common API across the
different container types the HTTP
authentication mechanism is designed
specifically for the web tier for the
servlet container only it's modeled on
the jaspe server off module SPI but what
it is is it's an intended to capture the
just pick is quite powerful but it's
very complex and we've had you know
number of people concerned about the
complexity the awkwardness to use so the
goal here is to provide something that
is much more user friendly in terms of
how you how you use it how you define
the
hey VIIRS so the key methods of this
interface are validate request which is
provided to allow the caller to
authenticate so you can extract this is
called before due filter or cert or
service method so you can extract
information from from the HTTP header or
the request parameter and so on secure
response which is invoked as you might
expect after and that would allow you to
do things like I guess encrypting your
response if you want it to do something
they're clean subject lets you clean up
get rid of any any caller specific
information cookie state perhaps or
anything else that would you would not
want to have propagated any further so
you could package this with the
application you can package your own HTT
HTTP authentication mechanism
implementation with the application or
you can use a container supplied one and
there are rules for the prioritization
of these and the configuration of these
so this api in turn can delegate to the
identity store api which is used to
interact with the stores that have user
information both for authenticating and
retrieving information like user group
information the security API spec
identifies a number of types of identity
stores I believe these are extensible so
LDAP database there used to be embedded
I'm not sure whether that got pulled or
not in the final release you can find
out more in the security talk that's
later in the conference but this is used
for authentication or authorization or
both the main methods here are validate
so you can validate a
as to whether or not that is valid and
the user can proceed or you can extract
the caller the caller groups for further
authorization if in fact that is
supported by the identity store identity
stores can support authentication or
authorization or both and you can
determine from the identity store which
it supports the HTTP authentication
mechanism can leverage multiple identity
stores so it can go through several
identity stores determining whether
whether based on a credential the caller
has the has the right to continue so you
can combine the results of the identity
store the identity stores as they're
produced so as I mentioned we did a
number of maintenance releases as well
JPA most of these are quite small JPA
was probably the the more significant
one of this list Java Mail had a number
of small improvements common annotations
mentioned for priority and repeating
annotations interceptors was just a
cleanup and WebSocket was done a while
ago we also completed a number of
maintenance releases for Java SE 9 and
these these are included in the
glassfish reference implementation so
when you use GlassFish you'll see the
results of these but they're because
these are SC api's they're not included
as pursue in Java e8 per se which is
based on Java SE 8 so I promised our
team I talked about JP a.22 in
particular what this adds is as
repeating annotation support I think JP
a was probably the the poster child for
annotations when it was released so I
think they're now
sixteen repeatable annotations and JPA
support for date/time what we decided to
do here was support mappings for those
Java time types that are supported
underneath by JDBC we didn't want to get
too massively created here creative here
with a lot of customizations but rather
to build on what JDBC provided so namely
these five Java time supports local date
local time local date time and offset
time and offset date time and then the
ability to stream the result of a query
execution so get results stream method
added to both the query and typed query
interface and then finally CDI injection
into attribute converters we had
previously had CDI injection and entity
listeners but we had a number of
requests to add this to attribute
converters so that's also there okay so
where are we right now so we just
released September yay it's done finally
so this chart illustrates those api's
that underwent jsr new jsr s in Java EE
8 the ones in in dark blue our existing
API s that were revved the ones in
orange down below these are new api's
that were added to the platform in Java
EE 8 if we look at the web profile which
is a subset notice the addition of both
Jason B and security comment about
security here the security API leverages
the just pick servlet profile so we
needed to add jaws pic also to the web
profile but only the servlet
profile support is required okay so
where are we going well where we are
going is to eclipse so we're moving as
you may well have heard we're moving
Java EE to the Eclipse Foundation I
believe that the name of this is ee for
Jay at least that was the latest that I
heard and we have the great support of
IBM and Red Hat in this move we
approached them first to make sure that
just to validate that this was the right
direction and we got very strong
agreement here we think that this will
lead to a more agile and flexible
development process more open it will
allow things to move more quickly
perhaps the details are still being
worked out we expect we expect this
process to go fairly quickly we're being
quite aggressive and trying to get this
worked out so this is the future we
think it will be more open going forward
we've gotten a lot of positive feedback
on this move so there's a lot of
excitement and I think we're off to a
good start a couple of the details here
we're transitioning GlassFish the our
eyes the tcks the product docks the
mailing lists I think and Oracle will
continue to be providing support through
Java EE 8 - to our customers into the
community and then we're often running
under Eclipse so I'm just going to leave
you with a couple of pointers here where
you can learn more if you want to stay
in this room
I notice that Ed Burns who is one of our
spec leads for the servlet API and Ching
Y Chen have just come in so they're
going to be talking here about servlet 4
oh if that's what interests you and then
later today there's a panel discussion
on the moon
of Java EE - the Eclipse Foundation so
participants from Oracle IBM Red Hat and
the Eclipse Foundation will be present
there and then as the week goes on we'll
have other spec leads describe some of
the some of the new features of many of
the other api's in this platform I'll
put in a plug for the JCP buff tomorrow
night that's going to include a number
of the spec leads I hope to be there as
well where you can ask questions and
interact more informally with members of
the community so with that I don't know
if I have time for any questions I think
I need to leave to get these guys set up
but I'll be in the hacker garden this
afternoon so if anybody wants to Corral
me there I'd be more than happy to to
meet with you and and answer any
questions so thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>