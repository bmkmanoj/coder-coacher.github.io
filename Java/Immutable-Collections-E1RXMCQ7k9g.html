<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Immutable Collections | Coder Coacher - Coaching Coders</title><meta content="Immutable Collections - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Immutable Collections</b></h2><h5 class="post__date">2017-10-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/E1RXMCQ7k9g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so thank you for attending this
presentation not quite as early as
Stuart's presentation earlier actually
curiously how many people were in
Stuart's presentation earlier today so
okay quite a few so we can compare notes
afterwards okay so there's the
obligatory legal statement so what am I
going to talk today about today so I'm
gonna do a bit of a recap on the
unmodifiable collections in the JDK just
to say what we have there at the moment
I'm gonna give a brief overview of
immutable collections in external Java
libraries and JVM based platforms and
then I'm going to talk about immutable
collections leveraging persistent data
structures so when I refer to
persistence I do not mean database in
any way whatsoever or persisting to
non-volatile memory or any of those
things it's a very confusing term but
persistence is sometimes easier to
understand than immutable when people
hear mutable and immutable and they
can't differentiate between the two so
sometimes people refer to these as
persistent collections rather than
immutable collections so when I refer to
these immutable collections I'm making
no claims whatsoever as to the
immutability of the collections element
so I'm not talking about immutability in
the large in the language or forcing
immutability all the way down deeply
into these structures I'm just talking
about the collection structures
themselves this is a huge bike shed area
you can talk about this for months and
months and months and months so I'm just
trying to arrange sort of enclose the
scope in just two collections for this
for this talk so as there is a huge set
of advantages to being immutable I think
the first fit occurs to me is if I don't
have to think about data racers I'm a
happy person if I have to think about
data racers I get a headache it's if
you're dealing with concurrent stuff and
you know that what you're dealing with
is immutable you can safely trust that
and you can understand that and that's a
lot clearer but having to deal with
sometimes with data races and the
headaches and debugging that actually
that that's a huge advantage it's also
if you have things for their immutable
and are trusted to be immutable you know
that nothing else can scratch on them
either on purpose maliciously or by
accident and that's a nice property as
well so if a library that you're using
uses these data structures you know you
can trust this library and they have a
bunch of properties in terms of
optimization they're effectively
constant so that gives a lot of
opportunities for the rajah the run time
hotspot to optimize these things and
treat them as constants in line and our
constant fold them when generating when
hotspot generates hot hot little bits of
code that are optimized and they're also
had properties that you can optimize
these things in the java implementations
over space and time if you have a small
collection you can choose to use a
different data structure and if you have
a large collection and Stewart Marx did
some of these kinds of optimizations for
his collections list off set of map
table for smaller collections were more
optimized they save space they trade-off
some space versus time and you can do
these types of tricks with even when you
have immutability and your collections
so this is my wish list for immutable
collections if I were going to do this
in the JDK which is no this is no
commitment to doing this in the JDK but
if I were going to do it this has been
this would be my wish list here so I
think the first one to me is if you're
coding using immutable collections I'd
like to see that in the type name I'd
like to see that in the API so when I
read the code I know this thing is
immutable I have to treat it differently
to say list or map if it was a mutable
list or a mutable map I can treat that
differently I know it has a different
API I know I have to consider this
slightly differently when the way I use
my algorithms or a I develop my
algorithms incidentally has anyone
programmed in closure at all whew
it's kind of mind-bending because it it
is totally a new table for the most part
and the
it's kind of mind-bending at first if
you use used to the mute mutable way not
in you to a beautiful way of coding your
algorithms tend to change and I think
that's it's worth actually experimenting
with languages like Clojure and Haskell
to see how you can code in immutable
ways rather than immutable ways or pyth
it really changes the way you think
sometimes these collections I think
should be sealed and what I mean by that
is only trusted parties can actually
extend these collections so I wouldn't
want to let anyone else extend my Anu
tuple list because I don't trust them I
don't trust them to do it properly I
don't trust them either because they're
there being a black hat or a white hat
in terms of what their motives are or
because they've made mistakes we've had
this with our own collections in the JDK
they're open and we have to write
defensive code against incorrect
collections people who have extended
ArrayList people have extended hashmap
and so forth like that we don't
necessarily do the right thing I want
needs to be closed and only we can
implement them and then we can guarantee
the immutability of these things I would
like them to provide a bridge to the
mutable collections so you have to opt
in and say to lists or to mutable lists
rather than extending from list if you
extend from list then you can easily
pass it around to something that accepts
list then it just becomes into the old
collections mutable collections world
where you might operate on it and do a
mutating operation get an exception I
don't want that I want to explicitly
something in the code that says to
mutable list or something like so you
really know when you're transitioning
from the immutable to the mutable world
and I want efficient construction
updates and copying so if I have a new
to the list and I add an element to it I
want a new a mutable list but somehow
underneath it shares a bit of structure
between the previous collection and the
new collection so we can save some space
maybe trade off some time and save some
space but we get structural sharing
underneath and we can do efficient forms
of copying I want a way to build these
collections up in a confined mutable way
and then
freeze and say now your immutable I may
forget time to show you some stuff what
we're doing there on that so that's my
wish list I guess you could describe
them as goals if we formalize them a bit
more so what have we got in the JDK so
the JDK has a notion of unmodifiable
collections everyone know what they are
you've used these things before so
unmodifiable is a runtime property of a
collection so if you have an
unmodifiable collection the modifying
methods like add put remove throw
unsupported operation exception and
there's no way to directly query this
and you might ask why would you want to
directly query it well you might want to
know if you need to make a copy or not
if you've got a list how do you know
it's unmodifiable well you could do an
instance of an and looks at some
internal JDK Corrections but I wouldn't
recommend that so if we wanted to add an
efficient copy method to the JDK we
can't actually do this and let third
parties opt in if they're going to opt
into that
unmodifiable view as well for example
guava which I'll get onto in a moment so
non modifier your wrapper is essentially
a source to a backing collection so you
you've all done this collections dot and
modify the list source list so if the
source list is modified it will be
reflected in your wrapper as well so
they're not really immutable things in
this notion here it's just what you get
back is an unmodifiable view over your
source and you can have directly
unmodifiable as well with the list of so
if you there's there's no source here
that you can observe or see you're just
creating a collection kind of like a
collection literal in a language and
you're getting back an unmodifiable list
back so how do you get immutability with
these things well usually what you do is
you do the unmodifiable list you clone
it because you don't know where the
source is unmodifiable or not you have
to take a clone a copy and then you wrap
it and then you throw away the source I
don't want a reference to that because I
don't I don't want to know what that is
I don't want to modify that at
or another way to do that is using
stream so you can use color collect
collecting then two less than then wrap
it in a list there and I'm throwing away
the source implicitly here so it's not
going to be reference from outside
anymore
and of course list of and friends are as
if the source is never accessible so
that's the way I kind of describe a
modifiable collections to myself and you
have to jump through hoops if you want
to get something that's immutable and
you knows immutable but it's not
reflected in the type system and so
forth like that so if I go back to my
wish list and look at the JDK
collections but they're not doing very
well here there's no types to indicate
that you've got an immutable thing it's
not sealed you can open it up
tautologically it provides a bridge to
itself and there's not really any
efficient construction updates and
copying if you get a list and you want
to make sure that no one scribbles on it
you have to take a copy and if you want
to make sure no one else scribbles on it
when you return it you even make a copy
you you wrap it and hold the source to
yourself tightly so no one else can get
it so I think unmodified there's a
reasonable extraction abstraction for
mutable collections but it's not really
good for immutable sorry did I say
mutable or immutable I'm going to fixed
up so good abstraction for mutable
collections but not for immutable
collections there that would be my
argument it doesn't mean we shouldn't
improve this notion in the JDK but I
think if you want to get to truly
immutable collections we have to have
something else so what does guavas
immutable collections do anyone use
guavas collections they are really quite
popular very well-designed
so guava has a bunch of sealed types
such as a mutable list and a mutable map
and these implement our corresponding
JDK mutable collection types a mutable
list implements lists and copying is
kind of smart it knows the copy of if it
takes you of a collection and it will
know whether it's an immutable list of
its own kind or not and decide to return
it back or do a copy so in some sense
it's kind of smart
whereas when we're doing the
unmodifiable case or we're in the JDK
without these things we have to program
defensively and take off
so I'd say that manifests immutability
it's sealed it doesn't provide a bridge
so you don't opt-in explicitly in sauce
it because it extends list you can pass
it around to something that accepts list
I don't like that I'd prefer explicit
opt-in to know you're transitioning
between the two so it's sort of as soon
as you pop up to list you're in the
unmodifiable world again and it kind of
provides efficient completion copying a
bit of efficient construction through
builders but it's it's not what I like
they they're a good compromise they they
have some good properties with them but
to me it doesn't go far enough
there's eclipse collections how many
have used these these are previously
goldman-sachs collections this is I
described as something for everyone it's
quite a cornucopia of various
collections out there and you may find
something very useful in these kind
doing these types of collections from
what I what I've looked at here I'm not
an expert on these collections they
manifest immutability they are not
sealed they do provide a bridge as far
as I can tell and they have similar
issues as guava does in terms of
efficient construction updates in
copying so if I look at Vava previously
called Java slang people heard about
that nice functional library closure
Scala maybe Kotlin too but I'm not as
familiar with Catalan I think these tick
all the boxes all the goals or wish list
that I had they often may manifest in
mutability they're sealed they provide a
bridge and they also provide additional
construction updates and copying I
haven't verified this fully but that's
my gut feeling here and what these
provide so let's look a bit closely at
the efficient updates so what is going
on here
all these collections some of these
collections v's libraries or platforms
provide leverage something called
persistent data structures predominately
for map sets and vectors vectors are non
linked lists they're not Java util
vector which should be deprecated
that possibly never removed is it
deprecated already Stewart no no yeah
same for a hash-table as well so they
they leverage something called and we
call persistent data structures so what
is a persistent data structure so absent
data structure is something that
preserves a previous version of itself
where modified now you can easily write
your own persistent straight data
structure by doing a copy-on-write
that would be terribly inefficient and
that's what we have to do today to code
defensively in the JDK but what these
persistent data structures do they all
have a common theme underneath and
that's called hash array map tries or
ham tease for short and they are the
basis of efficient persistent immutable
map sets and vectors so I think they use
were pioneered in part by phil Bagwell
who worked in Scala and worked at
typesafe and and I think like Bend and
what she's passed away now but I think
he he pioneered some of these
implementations and designs in Scala
first of all what's good about these is
these allow you to provide structural
sharing between the new and previous
version of a collection so they instead
of taking the whole copy of something
you take a copy of only the bits that
you need to change and then you can
share the other bits and because it's
immutable you know that those other bits
aren't going to get modified they are
effectively constant time effectively
constant time bit of wiggle room here
for many operations and they can be
cached friendly as well so if you're
traversing over them you're often
prefetching stuff from the cache and so
you get good good performance they won't
beat something like a ray list ArrayList
is damn hard to beat but they trade-off
some performance for some structural
sharing so what's the basis of this if
you know what a tri tree is I copied
this from Wikipedia so you can go to the
Wikipedia page instead if you want to so
this is an example of a tri tree so a
tri tree basically it stores a bit of
the keys if you're making a map it
stores a bit of a keys in each node
you go down so if in the example here
you've got a try for keys a tutti Ted 10
I in and in and then numbers for the
values so you basically traverse the
tree saying oh t okay I go to this node
and oh I go to two and so forth like
that and you need to store a prefix of
your keys in your tree for all of the
entries that you actually have so it's
quite an that it can be quite an
efficient mechanism and data structure
and often these kinds of data structures
use when you're when you're typing
something in and you do word completion
you might be using a try underneath to
do to select the possible words that you
might want to complete against so
essentially a try here you have a you
have an alphabet here we have the
alphabet A to Z lower and uppercase and
you have a string and a string in this
case would be unbounded because it would
just be a word but we can use the same
techniques in hash array map tries so
hash or a map try is essentially a
symbol instead of a letter of the
alphabet you can say it's a symbol of a
five bit sequence it's just a number
from nought to 31 and you can say the
string is fixed in size of length 32
bits consisting of seven symbols and
just the last symbol is just truncated
to two bits so the string in a hash
array map tri is essentially the hash
code of an object which is the key so
we're sort of laterally transforming a
domain to a 32 bit string and chopping
it up into a little bit of symbols and
that's a sort of a symbols our alphabet
and a string is of fixed length of size
and if here's an example here so say we
had a hash code of cafe baby here and so
our symbols will be going from right to
left symbol one will be the first five
bits symbol two will be the next five
bits and so forth and so on down so we
have maximum of seven symbols
essentially a tree depth of six does
that make sense what you're doing is
taking five bits off each of a hash code
so essentially we have wide branching
factor here so each each node in our
tree instead of if we go back here in a
tree each node without have a branching
factor of 32 and you go down for a depth
of 6 so the depth is actually controlled
you're not going to go down like depth
of 64 or 32 it's pretty pretty
constrained and it's effectively
constant time for look at what I mean by
effectively constant time if you're
going to do a lookup of a key and a
value is essentially log 2n over 5 which
is almost o 1 you can say for most cases
so these things provide good structural
sharing I will show later on visually I
show some visualization of this
structural sharing to get this across
more I hope but because of this they're
good for updates they're also
potentially good for merging and
splitting so in our collection in our
streams when we do a parallel collection
to say to list or to map potentially we
could use these structures underneath do
more efficient merging than we currently
do today because we have a code it's
actually a little bit inefficient what
we do when we do collect two lists in
parallel or grouping by and these
structures could be very interesting in
terms of allowing you to collect in
parallel and then merge them efficiently
together because we know some structures
are different in each part and some
structures are shared and we can do a
little bit of merging just on the shared
bits they provide good memory usage as
well which I hope to explain and good as
I said good cache coherency and this is
the basis for vectors that rich Hickey
coded in closure and where fill bag well
also extended his research to look at
relaxed radix balanced trees for vectors
and it can also be used for multi maps
at JVM LS this year the presenter talked
about how he could use these structures
for multi maps as well so the quite
versatile and they can also be applied
to mutable collections as well and this
is what interests me for efficient
building of something before you turn it
into something immutable and I think
they can be efficiently implemented in
Java they can be efficiently implemented
in Scala but actually Java I believe in
closures are actually Java
implementations and Vava is another
example of these collections as well
being implemented so here's a real naive
implementation of how you might go about
this CP map is a persistent map so I
have a thirty two way branching factor
and I'll have a key value I need to
store my keys and values as entry so
what I'm doing is they've got a node
here object array and I'm storing 64
it's a site length of 64 key value key
value key value key value and some of
these entries might be null because the
value there might not be an entry
actually there and it might be a sub
layer there so if I look at the get
method here for finding a value for a
given key I might I want to ask what is
my symbol at my current depth so
remember the symbols of the five bits
going across the hash code here so I've
got to say well how do I index into that
array of nodes well first of all I've
got to get my symbol for my hash code
and essentially the method symbol at
depth is there all it does a shift down
by the depth times five and chopped off
and get the first five bits that's it
and that's my index into my array I look
it up I see if it's a sub layer node I
Traverse down otherwise otherwise I see
if it's present and I return an optional
say whether it's present or not know
that that's pretty simple but that's
like 64 entries I might not have all 64
entries in there that's a pretty
inefficient representation there so you
can do something better and what you can
do is you can use a bitmap to express
which entries are present at my level in
my tree and I can have a number an array
an object array of nose that contains is
of length of a number of bits set in my
bitmap so that's a more compressed
representation and that's a technique
that all these persistent collection
implementations use so if you look at
this implementation you'd have the same
symbol at depth as before you check if
the bit is set or not and if it's not
set then you turn optional empty it's
not present but then you have a
an operation which says how do I index
into this array but all you do is you
essentially chop off the bitmap for that
for all the bits before the symbol
you're interested in in count the number
of bits using bit count and then there's
your index into your array quite nice
and the reason why this can be
implemented efficiently in Java is
because integer bit count is an
intrinsic and that that compiles down to
a pop count instruction on x86 and
before that was intrinsic ID in the jdk
these collections were a lot slower
because they had to do a lot of bit
twiddling going on I get I get to this
point later on hopefully there's a lot
more we can do to optimize these things
so I think this is a better
representation as I said the space is
required only for present nodes using a
bitmap and that's made possible with
hotspot optimizations there's further
refinements you can do here and
trade-offs sub nodes and entries could
be separated for more cache friendly
traversal stained or fur talked about
this in his champ work and hash codes
could be cached as well I wasn't caching
hash codes here as all sorts of
trade-offs and experiments we can try
and the API is slightly different so if
I have a persistent map API it might
have a familiar for each might have a
get that returns null or optional it's
up to you but the put method instead of
returning the the previous value of null
it might have to return a new map
because I'm I'm not modifying the
existing map I'm returning a new map
with the same things as the previous one
but the new entry inside it and the same
for remove in terms of removing
something so the API is actually
slightly different here to what you
might get with a hash map
so although there's modifying methods
return a new collection the
implementation will actually share
structure underneath and to do this
efficiently when we're building we need
we need mutable builders to construct in
a confined manner so what we want is a
really when you're building something up
you want to confine this to a closure or
a Fred so it doesn't escape out and then
when you're done you construct them
freeze and you've got an immutable thing
and closure has this con ocean of
building I'm not sure about Scala it may
well do as well so I'm going to show
some demos now now let's see how
successful this will be actually before
I go and did anybody have any quick
questions on the explanations no well
good okay so I'm gonna wing it a bit
here let's see how this goes so first of
all I'm going to I'm going to run J
shell start this up okay this is
actually J shell running Java 10 or 18
dot free as we like to call it nowadays
I'm not going to get into discussion on
version numbers so we can use var
so I've there's a github project here I
sent a link to this is all online on
github you can check this out and play
with it yourself and get an idea of how
these structures work what I've written
is buggy it's not performant but its
function enough to experiment with so
you finally bugs in it send me a push
request pull the request and I will I
will accept it and fix things it's in
the open open JDK saying licenses open
JDK so if I just create a very simple
map like so VAR m equals P map valve
like that I can visualize this like so
what that's going to do it's going to
look at the structure it's going to
create a dot file convert the dot file
to SVG and load it up in the browser if
I can get my okay so here we go this is
our first visualization of the map it's
not very interesting
but it's useful to explain what's going
this I have one entry in my map I have
the key of one and a value of one I
haven't one node at the top here with a
bitmap that says of 32 values so this is
this is my bitmap I showed earlier the
int the int bitmap and it's and it's
essentially got one bit set the size of
one and there's a prefix here for one
the key is one any any integer value
under 2 to the 16 is actually the hash
code is itself essentially that's it
that's what you need to know here so but
the hash code of 1 is 1 and so I have a
prefix here the first applied bits of 1
and the total hash is this going from
least significant bit to most
significant bit here so does that make
sense
so I can add some more here so I can
visualize two things instead so we can
we can put another value here like so
and we can visualize two things so now
we get now we get the previous map and
the new map like so so we still have one
node 1 node depth we have the previous
map with the key of 1 to 1 and we have a
new map with 1 &amp;amp; 1 &amp;amp; 2 &amp;amp; 2 so that's the
Muta book there's no structural sharing
here because we were at the same depth
here which we essentially got the the
two arrays can't be shared so we had to
structurally share when we when we go
down in terms of nodes now that but you
can see here the prefix here is
different the hash is different so for
that so it's very easy to visualize and
play around with these things so I can
show a few more complex examples here
okay so here is here is a good example
of what I reckon you'll see that so i
zoom in here's an example of building up
a persistent map and this is a common
thing you might do in least jdk code you
might have the the symbols for your
primitive types in byte code BD fi and
so forth mapping to the box types and
that you might create a map for that so
what I'm doing here is I'm creating an
empty map rather than putting my first
entry in my second entry for identity
for veggie all immutably so I'm creating
all these structures and throwing them
away and throwing away creating all
these structure until I get the one I
want that's not the particularly
efficient way of doing it but we can
visualize this and see what see what
happened so I'll just run this test here
and it should do the same thing as
before
okay so this is getting harder to see
can you see that not really but the
point being is that this actually
there's no collisions here there's no
sub knows it all maps at one level deep
here and we can see the various prefixes
and hash codes here and we can see the
top node here as there's nine entries
and there's nine bits set in my bitmap
like that and there's no there's no
conflicting prefixes here so we're not
getting down any any level deep so
that's actually quite a nice property I
just packed in essentially eighteen
eighteen entries in my object array
knows no spare space if you're using a
hash map you probably need to get you'd
have to have a hash table a bucket size
about thirty two to stop the collisions
so you're already saving some space here
and it's all nicely cache coherent
because it's all in a single array so
when I traverse that I'm going to get
the prefetching working as well the only
thing I don't have in here is I'm not
sharing and not storing that I'm not
caching the hash codes so I'm going to
take a hit in terms of time when I when
I compare my hash codes but there's ways
to cash flows too so that's an example
there let me show you the concept of
building instead so I showed it building
structurally immutably and I'm throwing
away arrays every time I put here as
they create a new one so creating some
garbage collection here but I can do the
same instead by saying P map of and
instead I get it essentially what I call
a builder a P map builder here and all P
map builder does is has a put method on
it all I can do is add stuff to the map
and I'm doing it in a closure here and I
want to confine this builder so it only
operates within this closure and within
the same thread if I operate it in
another thread it will throw a legal
state exception if I somehow cache it
outside the closure by storing it in an
array or in a field or something like
that and operate on it when I'm outside
the closure it will float legal state
search and something I'd nicely confined
this thing and then I can mute ibly
update this safely because I know no
fred's will will turn on it and I know
that if I if it
so nothing will happen bad will happen
to afterwards and this is quite a
powerful concept we did the same thing
with the stack Walker API if you've ever
used this to get stacks and traversing
the frames using the stream API in a
closure and in a confined way using
closure like this and I think this is a
very interesting pattern because I can
build up something mutable and not throw
away and create a bunch of garbage and
once the closure finishes I freeze of
collection and it becomes immutable
again I'm doing some interesting tricks
with JD some misc unsafe here if you
want to look at the code I'm actually
rather than doing a copy of the data I'm
transforming the class header from
something that I can write on in terms
of fields to something that is the same
structure with final fields later on if
you want to look at the code you
shouldn't be doing this at home but this
is these are the kind of tricks we can
do in the JDK and we as long as we can
test it and we trust our code we can we
can do these types of tricks and and and
no one else can do these types of tricks
outside that's an advantage to us and
that's one reason why these things are
in other interest to me is we can
optimize the heck out of these things
anyone can write these things on top of
a JD get reasonable efficiency I think
we can do a better job if a in the JDK
itself so that's one advantage so I
showed that I can we can just run that
two just to show that it will build a
map like so okay same thing as before
it's no different
I get the same structure out immutable
structure there okay let's show
something more complex let's show this
one here so I'm I'm not building
efficiently here but I'm just creating a
bunch of entries of fruit to color like
this and I'm going to visualize the map
I built but I'm also going to visualize
the one with blue the blueberry entry
removed let's see what happens
yeah so this is going to create quite a
big map here so if we just yep is quite
big but if you notice here we're getting
some structural sharing between the two
maps because we've got a sub node that
conflicts on the first PI bit prefix so
the first fight bit prefix here both
banana and plum share the thirst by bit
prefix of 0 0 0 0 0 so we can
structurally share that between the two
maps that we modified so this map will
have so it has blueberry in but there's
only one blueberry here there's not in
the other map we removed it but we can
structurally share this sub mode layer
here so when you got more complex layers
there's more structural sharing you can
actually do here and this is interesting
this is makes it also it makes it easier
to split because there's a natural split
point both in the array and this one
here too so hopefully that gets it
across a little bit here we can see that
the prefix here we now have 2 5 bits
here the first 5 bits and the second
five bits or two symbols and we can see
that it's always a prefix of the total
hash code here when you're comparing
these these values
so we can do something more complex so
let's see so here's his system
properties so system properties is it
essentially it's a map of all the system
properties in the JDK maybach so let's
visualize this and see what this looks
like this would be a more complex one
okay so you get an idea of the structure
here there's more sub nodes happening
here let's scroll all the way down yeah
so we see a prefix here shared prefix
and other symbols down and so forth but
it only gets down to about the depth of
two maybe three at the end here so it's
still quite shallow so if you're going
to look up something it's going to
traverse a little bit but it's not going
to traverse too deeply and that's why
it's almost constant time what you're
doing so there's a good structural
sharing here and reasonable efficiency
in terms of access you're probably not
going to be a well sized hashmap here
but I'd argue that potentially hashmap
will take up more memory see potentially
trading off space and time here a little
bit but very actually good compromise I
don't think if you're using these things
most people won't notice or won't need
the extra performance that's my theory
anyway I don't know if it's entirely
true would have to verify that we'd have
to do good performance tests on these
things too but they just to express as
showing a good good good set of
properties here we can look at some more
degenerate cases here so what happens if
you have a collision so two hash codes
to two entries two keys share the same
hash code what do you do then so I have
in here an int key which essentially
sets the hash code of these two things
to zero so I have an entity whose key is
one and an int key is key is two but
their hash codes are the same I'm just
concocting this there with one and two
so in this case we have a collision here
signified by a red box so what do we do
when we have a collision we could use a
linked list we could use a red black
tree like we do in hashmap today or we
could change for the hash algorithm and
go and use the same ham T structure with
a different hash code algorithm to and
go down as lots of options we can
experiment with so let's look at another
let's look at a generate case of how
deep we can go down in the tree so what
I'm doing here is I'm concocting
integers that just so happen but I know
the hash code algorithm internally to
create the Hat to create the actual hash
code values I'm using in my map so I'm
creating I want to set the two top level
bits
remember it's fight it's six symbols
with the two two top-level bits most
significant bits only at the end setting
their values I'm also setting their
values here because the hash code is is
slightly shifted a bit so I'm but way
I'd calculate the hash code is the way
you do it in hash map you shift the hash
code by sixty and XOR it with itself so
I want to I want to cancel out the ones
and just have the hash code to the top
top two significant bits here just to
show the degenerate case and so what
happens here we get one two three four
fire depth of six when we get our four
values right down at the bottom so if
you're traversing this structure you
have to go down sit all the way down all
the way down not very cache coherent not
particularly very efficient inefficient
but you're bounded but a level of 60
you're not going to go further and
further so if you're writing if you're
adding algorithms for this and you don't
want to use recursion you can allocate a
stack on the heap of just six it's very
very nice property that I mean we see
the values in there so that's the worst
case you can possibly get which I'd
argue is is not going to be very common
ok I think that's it if you want to
check out the code and have some fun
with this or send me fixes and that I'd
be very interested on on that stuff okay
so to summarize so I think unmodifiable
is a reasonable abstraction for mutable
but not immutable I hope I persuaded you
that for efficient immutable collections
we need persistent collections without
sort of arguing guava gets you so far
it's reasonable but I think we could do
better and other languages and platforms
actually do do better and sets maps
vectors using ham teas have been proven
to be effective in these libraries and
platforms I think so they've proven
their worth so what about Java this is
where it comes a bit speculative and
more my opinion I think we'll definitely
continuing to prove on unmodifiable in
the JDK and Stewart marks is already
working on some stuff like this he's
already got one thing in review on core
libs dev and open JDK and there's some
other stuff in the pipe to make some
good improvements here but what about
say selective sedimentation I love that
word that's a mark Reinhold word but he
uses that we have the luxury to look
outside there other languages and
platforms and see what they're doing
stand back ponder them and take the best
bits from each could we do that with
persistent collections in the Java
platform
perhaps we could a claim I say it's
possible to optimize these collections
very very aggressively with internal
api's hotspot and safely contained
unsafe mechanisms but I talked about
when I was doing building there are
there there are ways that we could
leverage more intrinsic as I showed you
about pop count at the JVM a less talk
by Stein dauther he talked about multi
maps and he was using AVX style
instructions to do bit manipulation of
these multi maps to make them efficient
as well as stuff we can do there too
there's a lot of research here but my
claim is that we can optimize these
things like no one else on top of the
JDK can optimum
today and that is the end of my
presentation and there's some references
at the back here I'll upload this
presentation and tweet about it
there's some references to some of the
papers write about these data structures
as especially like to recommend stein
daughter's thesis I think he's done some
interesting work build a gun ban on
Bagwell and if you're interested look at
closures vector and look at the the
stuff in Scala the implementations of VR
BB vectors as well and there's an
interesting one at the end it's it's
using these hash hash hash array mapped
rice for concurrent collections and as
by Pro kopeck are very interesting
leveraging these things for concurrent
collections which have similar
characteristics to concurrent skip lists
okay I think I'm done any questions no
questions
you all understood that right okay thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>