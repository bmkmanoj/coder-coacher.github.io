<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Modular Development with JDK 9 | Coder Coacher - Coaching Coders</title><meta content="Modular Development with JDK 9 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Modular Development with JDK 9</b></h2><h5 class="post__date">2017-10-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gtcTftvj0d0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone it's 5:30 and we only have
45 minutes so I'm going to get started
thank you all for coming my name is Alex
Buckley I'm the spec lead for the Java
language and VM at Oracle JDK 9 is here
and there's a lot in it some of the
features are performance improvements
such as compact strings some our tooling
improvements like the search box in Java
doc that Mark showed in the keynote and
the new J shell tool strawpoll has
anyone downloaded JDK 9 yet right answer
has anyone played with J shell also the
right answer is it the coolest thing
ever
yes good some of course on this vast
list are updates to existing features
such as support for Unicode 8 but the
main feature and the one that's taken
many years to come to fruition is the
module system the module system is a big
deal because it enables modular
development all the way down the java
language and the java virtual machine
understand modules very deeply so that
the applications you write and the
libraries you consume and even the jdk
itself can all be developed and tested
and packaged and deployed as modules
with clear api's and well protected
internals making everyone play by the
same modular rules has great benefits
for reliability maintainability and
security as we'll see in the rest of
this talk so with the theme of modules
all the way down in minds we've got
three parts the first part explains how
modules are alive at you building block
in the structure of application code the
second part is about how applications
and the libraries they depend on can
migrate to modules that is it's about
how you can mix modular and non modular
code and the third part is about the
structure of the modular JDK including
some of the compatibility issues that
arise from that
so programming in the large
in object-oriented programming the
traditionally the basic unit of reuse is
traditionally the class Java has
wonderful mechanisms for promoting reuse
of a class inheritance for reusing
behavior interfaces for reusing
abstractions separate compilation
dynamic linking and access control down
to the level of individual fields and
methods and we've had nested classes
since 1997 so it should be possible for
a single top-level class to encapsulate
a vast amount of functionality with that
in mind it seems that an application
could be a single package containing a
few very rich classes all sharing data
and fields accessible within the package
and where a handful of public classes
form the entry points or the API of the
application right not really
how many people work on a code base that
consists of one package literally no
hands two packages just your own
codebase not the dependencies three
packages how many people work on a code
base that is on the order of 10 packages
some hands 20 packages wow this is going
higher than it did it the last time I
gave this talk 50 packages and this is
just your own codebase probably 3 or 400
in the front that's why you're in the
front row taking notes because it yeah
so this has made my point far better
than I could have made myself programs
do not consist of a handful of packages
anymore even the smallest microservice
wouldn't be expected to fit into a
single package programs our packages not
classes in Java
unfortunately the Java language kind of
gives up once your program is bigger
than a single package just imagine how
difficult it is to control reuse within
a really large code base it says here
like the 217 official packages in JDK 8
but what's 217 to your codebase
the only way to share code between
packages is with the public modifier but
then you're sharing it with everyone
it's not surprising that packaged
friendship in one form or another has
been requested many times over the years
a package is a a great way to organize
classes but most people wish there was a
way to organize packages to modules let
you do that a module is a set of
packages designed for reuse this is a
long overdue building block in the java
language in effect modules record the
structure of your program so that the
packages you want to be reused can be
reused
while the packages you don't want to be
reused can't be reused a program built
of modules will be more reliable than a
program built from a loose set of
packages in jar files that can access
each other freely and that exposed to
many AP is to the outside world
in other words in jetty canine packet
our programs are modules here's a module
that everyone will soon be familiar with
Java base it's the foundation of every
Java program like java.lang object is
the root of every class in blue are the
packages of Java base intended for use
by code outside the module these are its
exported packages in red are the
packages internal to Java base they can
be used by code inside the module but
not by code outside the module these are
its conceals packages a module is
declared in a new kind of file called
module in photo Java it gives the name
of the module and its exported packages
by exporting the java.lang package it
means that the public classes of
java.lang are accessible from outside
java base and a package that is not
explicitly exported such as calm sun
crypto provider is concealed its public
classes are not access
table outside Java base so this is the
first feature of modules in JDK 9 strong
encapsulation a module isn't just a set
of packages it's a set of exported
packages and concealed packages the
public classes of exported packages are
accessible outside the module the public
classes of concealed packages are not
accessible outside the module
this means that access control is more
powerful in JDK 9 than in JDK 8 in
jeddah k9 you can arrange for public
classes to be accessible to everyone or
accessible only to other classes in the
same module or sort of a halfway house
where they're accessible to classes in
the same module and a limited set of
friend modules so if we're looking at
public on a class declaration it no
longer means that everyone can access
the class access depends on whether the
class's module exports the class's
package
since Java base is a module let's reuse
it with the module of our own here's a
class in the package comm example hello
very simple class and let's declare a
module for it hello world at the bottom
in module in photo Java for sake of
argument let's export the calm example
hello package with the exports directive
now you're probably wondering how the
hello world module knows that it has a
package called comm example hello after
all nothing in the package seems to
point to the hello world module it's up
to the tooling to decide during
developments which module each package
belongs to in practice your ID will take
care of it you'll create a modular java
application and be asked the name of the
module then every package you create
will be part of that module
if you run Java C by hand then Java C
figures out which module each package is
in that's why module inferred
is at the same level as the comm
directory in other words if modern I
forgot Java is at the same level as the
package hierarchy then Java C treats
those all those source files as one
module the benefit of relying on tooling
to decide module membership is that it's
really easy to place an existing package
in a module and immediately give that
package the benefit of strong
encapsulation
we don't want each and every class like
say hello to have to opt in by declaring
the module it belongs to that would
invite errors such as classes in the
same package trying to join different
modules and that's a big no-no for
reasons I'll mention later one more
thing the say hello class imports the
java.lang package where is that package
imported from now you might say the
answer is obviously Java base because
you told me a minute ago that Java base
exports the java.lang package and you're
right in general but how does the
compiler know that should it search the
file system looking for modules which
export the imported package
what if multiple modules export the
imported package if we intends to reuse
the Java base module we should document
that fact actually since we're writing a
module ourselves we must document that
fact this is the second feature of
modules in JDK 9 reliable dependencies a
module isn't just a set of packages it's
a set of packages that reuses the
packages exported by other modules so
the HelloWorld module specifies that it
reuses the Java base module with a
requires directive in its module in
photo Java
this means that code in the HelloWorld
module can import any of the packages
exported by Java base
what happens if code in the HelloWorld
module tries to import any of the
packages concealed by Java base such as
Sun security provider
read here's a real example of some code
that does that last fish for point one
it doesn't run on JDK nine because the
VM throws in illegal access error the
error message is class comm son
enterprise security provider policy
wrapper in module unnamed module don't
worry about that cannot access class son
security provider policy file in module
Java base now a glance at the open JDK
repository shows us that the policy file
class in Sun Security is declared public
but because that package is not exported
by Java base policy file is only
accessible from code in Java base itself
to be clear in jetty canine the
GlassFish code cannot access this public
policy file class at compile time or
runtime it's exactly like trying to
access a package private class Java C
gives an error and the VM throws illegal
access error sorry GlassFish you'll have
to find a supported API not one of these
conceal Sun dot star api's I'd like to
return to the hello earth to the module
info dot Java file that declares the
HelloWorld module it's really important
to understand that a module exports
packages but requires modules the reason
is due to an old software engineering
principle the unit of reuse is the unit
of release this principle is ultimately
about separation of concerns you reuse
someone's code not by copy pasting it
into your own source tree but by
depending in some way on the black box
artifact released by someone else now in
the Java ecosystem there's no question
that the unit of release is the jar file
that doesn't change with modules a jar
file simply carries the module info dot
class file produced from module info to
Java alongside the ordinary class files
we call this a modular jar so when
someone releases a modular jar for the
hell
world module it's reused by someone else
writing requires hello world in their
own module in photo Java the reuse er
benefits from an explicit coherent API
consisting of precisely the green
exported packages and the releaser
benefits from strong encapsulation of
con sealed packages inside the module
which support the exported API so even
if there's high coupling inside a module
there's loose coupling between modules
another good software engineering
principle okay so you're requiring Java
base from your HelloWorld module and
you've built a modular jar for your
module where do you put a modular jar
jdk nine looks for modules in the system
image and on the module path the system
image is in the JDK installation
directory that contains Java base and a
few dozen core modules the module path
is set on the command line like the
class path except that the module path
points to directories containing modular
jars rather than to the jars themselves
so Java P Java - P mods specifies that
modular jars are to be found in the mods
directory and - M HelloWorld specifies
the module to run the key point then
about modules requiring each other is
that the module system can check the
requirements and validate that a modular
application is sound once the compiler
or runtime has found the initial module
HelloWorld in the system image or on the
module path it performs process called
resolution resolution means inspecting
it requires directives and finding those
required modules in the system image or
on the module path then recursively
resolving them we're building a graph
whose nodes and modules and whose edges
are the requires relation and to be
clear in jetty Cana and we do this at
compile time and
time.if resolution succeeds you get
three guarantees first every module that
is required is available okay pretty
obvious but a big improvement over the
class path where you don't discover
these identity lists missing jars until
later second modules don't depend on
each other
in a cycle cyclic dependencies leads to
code that is hard to maintain and we're
taking the opportunity to prohibit them
in modules from day one of JDK 9 now
some of you are thinking this is just
dependency management doesn't may even
do this who is thinking that some hands
okay you know that's fair now bear in
mind that maven only works at compile
time and this resolution process works
at runtime as well but more importantly
let me come to resolutions third
guarantee if code in one module imports
a package then the package package is
exported from exactly one other module
this guarantee relies on exports as well
as requires so you won't find it in
maven it means there are no split
packages which is what happens when two
jars on the classpath contain the same
package and you load some classes from
one jar and other classes in the same
package from the other jar split
packages are a huge failing of the class
path mechanism because they lead to very
difficult to debug scenarios thanks to
resolution they're completely impossible
in a modular application which is
obviously good for long term maintenance
and this is what we we really mean by
reliable dependencies the dependencies
in a graph are reliable when each module
can access only one version of a package
at a time the guarantee of no split
packages is a big deal for performance
as well because we know precisely which
module exports which package there's no
need to scan every module in the system
image and on the module path when trying
to load a class contrast that with how
you load classes from the class path
here's the classpath for hadoop the
compiler or runtime has to do a linear
search through 110 jars whenever a new
class is needed of course the
implementation can speed things up by
caching the classes it found when it
wasn't looking for them but there's
still this nasty half here half their
problem of packages being split across
multiple jars how would you even find
out that that's going on if you think
about it the class path is pretty crazy
with a hundred and ten jars there are
over 12,000 possible interactions
between classes in different jars each
one starting a linear search the class
path is the ultimate in erasure whatever
you know about the structure of your
application the class path throws it
away and connects everything to
everything else with modules you are
telling resolution what you know about
the structure of your application those
requires directives and it uses that
information to provide both safety and
performance at compile-time and run-time
the prohibition of split packages in
modules has an impact on application
design as well one reason that a package
might have been split across jars was to
allow different parts of an application
to share package private code while
allowing the parts to evolve
independently now these jars can't be
turned into modules because they would
all be exporting the same package
however the module system has a better
way to structure the application than
splitting a package let me set up this
scenario in a bit more detail assume all
of this takes place in a pre JDK 9 world
so on the Left the application has an
API intended to be globally accessible
it's the public foo interface in package
P the application also has some helper
code which creates or assists
implementations of the API ideally
without being accessible by users of the
application
it's the pee helper package and finally
on the right the application has
implementations of the API again
intended not to be user accessible those
are classes x and y which live in
different jar files and implements the p
dot foo api in order for the helper code
and the implementations to work together
they need to be in the same package the
implementations are definitely you would
definitely make them package private so
that user code can't access them now the
helper class foo helper is then packaged
private - it could be public but then it
will be accessible to users and we don't
want that there's a bunch of problems
with this setup which is really the only
way you had to structure an application
prior to 9 for one thing you've got to
make sure that the implementations in
the P helper package don't tread on each
other's toes there can't be any class
name overlaps between the
implementations since they all
contribute to the same package P dot
helper despite living in different jar
files a second problem is that you can't
make effective use of sub packages as
these implementations grow larger it
will be natural for them to introduce
sub packages but some packages can't
access the package private code in P dot
helper so you really would need a public
class in P dot helper to act as a
backdoor for some packages living in the
implementations but then of course
anyone in the world can get to the
backdoor as well a third problem of
course is that anyone can make a jar
with classes in the p dot helper package
and start relying on the helper code in
the api jar and the details of classes x
and y in the implementation jars
what's really going on here is that the
package P dot helper is being overloaded
it started life as a simple namespace
for code that helps the API but now it
finds itself being the unnatural home
for all kinds of vaguely related things
what was the developer meant to do in
JDK 8 the only structuring mechanisms
were classes interfaces and packages
splitting the package across jar files
was seen as acceptable but you can see
that it has a host of downsides in
jeddah canine the structuring mechanisms
are classes interfaces packages and
modules modules take the strain of
encapsulation and concealment
so that packages can focus solely on
being namespaces that are meaning that a
meaningful to the developer so here's
the same application developed as
modules let's turn API jar into a
modular jar by adding a module
declaration I'm going to show it here
the module called API exports the
package p2 everyone that's the main API
and exports the helper package P dot
helper to its friend modules import one
and imple to the second export directive
of Petr helper is called a qualified
exports any module in the world can
require the API module and access the
package P but only the friend modules
can access the package P dot helper now
I'm not showing the module direction I'm
not showing the module declarations for
the friend modules but they will
obviously require the API module in
order to access the p dot foo interface
that they implements the friend modules
won't export anything and they can
organize their concealed packages as
they wish now the P dot helper package
isn't overloaded with implementation
classes
multiple jars the naming of packages is
much clearer throughout all three jars
and more implementations can be added
smoothly in effect modules make packages
as cheap as classes and then control the
reuse of packages very precisely so a
module is a set of packages designed for
reuse they offer strong encapsulation
and reliable dependencies and the
tooling the command-line tool in VI des
will be a big parts of modular
developments part two will talk now
about how to take an existing
application and migrate it to modules
since it's impossible to modularize the
Java ecosystem all at once we're going
to be living with a combination of
modular code that's modular jars on the
module path and non modular code
traditional jars on the class path for a
while that's fine and JDK nine can ease
that migration that's what this section
is about we'll start with a simple
application that we want to migrate from
the class path at heart a typical Java
application has three layers at the top
are your application jars there might be
one or more of these at the bottom is
the JDK and in the middle there's a
bunch of library jars downloaded from
the internet and thrown on the class
path does this look familiar to anyone
some nods yes now I've hinted that we've
turned the JDK into modules and so in
this part green boxes will represent
modules you've already seen the Java
base module and you won't be surprised
to learn that there are modules for
logging database access XML processing
etc here they are but our application
isn't modularized and nor any of the
libraries should we modularize our
application obviously it's up to you you
could just run it on the class path like
you did in JDK s but we modular eyes the
JDK for a reason to improve security
through strong
halation and stability through reliable
dependences applications might want to
benefit from that
just like the jdk does so let's look at
how we might turn the application into
modules let's imagine our application is
two jars with main code in my app car
and helper code in my Libby R let's also
imagine that the soup of library jars is
limited to Jack's on the JSON processing
library Jackson comes as three jars core
data bind and annotations and we have
the modulus JDK at the bottom this is
how we'd run the application today we've
got to set up the Lib directory to
include our application jars and library
jars and point the classpath at them
maven does this for me well yes but it
does this and it's good to know what
it's doing under the covers
then we run the application with the
Java launcher one of the things we gain
by modularizing is not having to list
dependencies on the command line so
let's look at one scenario for mod for
migrating this application the top-down
scenario here we first modular eyes our
application jars without touching the
library jars now in general if you're
depending on third-party libraries you
are depending on them to modularize and
we can make it easier for libraries to
modularize but we we all have to wait
for them to do it no one can force them
so it may well be that some of the
libraries you depend on are not
modularized yet that's okay for your
application jars the obvious path is to
turn them one-to-one into modular jars
where each jar file has a module info
dot class file this is not always
possible especially if the application
jars have cyclic dependencies between
their classes but let's go with it for
now if we're going to turn each
application jar into a modular jar we'll
need to write a module declaration in
module in photo Java recall that a
module declaration gives a name and a
list of exported packages and
list of required modules the names are
easy we'll call them my app and my lib
but we don't yet know what each module
depends on we could make a manual
analysis of either the source files or
the class files but there's a better way
the Jaidev tool Jade EPS scans class
files which are files and tells you what
code from other jars they depend on Jade
EPS actually came in JDK 8 and there's
an improved version of JDK 9 so whilst
this analysis it can't be a perfect
solution it's a pretty good start so
we'll run Jade EPS on the application
jars with the jacks and libraries on the
class path we see that my app jar
depends on two of the jacks and jars
which remember are not none of these
modules yet
and of course on my live jar plus my app
dot jar depends on the JDK modules Java
base and Java sequel Jade EPS knows if
you're using the JDBC API that it's it's
coming from the Java sequel module maile
a block jar it turns out depends only on
Java base so that's nice and simple now
we have what's needed to write the
module declarations we'll start with the
easy one my Lib we know it depends on
Java base we can write requires Java
base and I showed that earlier though
actually we don't have to it's always
put in for you by the compiler because
every Java program ultimately relies on
java.lang objects you can't write a Java
program that doesn't indirectly rely on
java.lang object so you don't actually
have to write requires Java base it will
always be put in for you now from the
Jade EPS run we know that my app jar
depends on my lip and if we'd run J
depth with more options we'd have seen
that my apt or jar needs a particular
package in my lib so we could write
exports for that package in this
declaration to allow anyone to access
the package but as we saw earlier with
the qualified exports
if we're sure that no one except my app
needs to access this comm my app util
package we can use a qualified export to
maximize the encapsulation let's turn to
the module declaration for my app it
requires my Lib which we just wrote and
some JDK modules Java based and Java C
call and we know it's going to use
Jackson but we're not sure how to write
the requires directives yet for Jackson
because Jackson is and modules does that
mean that we have to turn Jackson into
modules before we can modular eyes our
app that would be very unfortunate since
we don't I don't mean we I mean you
don't control the Jackson jar files if
only there was some way for the Jackson
jar files to somehow become modules
automatically we don't know what their
dependencies and exports would be but we
have a pretty good idea what their names
would be they'd be the same as the jars
Jackson core Jackson databinding Jackson
the annotations it's obvious from the
jars if we could do that we could finish
writing the module declaration for my
app we'd have a lovely module graph with
my app depending on my lib and Jackson
core and Jackson data bind and also on
Java base and java sequel the good news
is that we can do this with automatic
modules an automatic module is a module
whose declaration is inferred by the
module system from a jar on the module
path so if we have jars that are not
modular jars we can still put them on
the module path and the module system
will turn them into modules in effect
automatic modules are a feature that
means yesterday's jars are already
today's modules once automatic modules
spring into existence for Jackson core
Jax and data bind and Jackson
annotations the module graph looks quite
different
the automatic modules basically say
requires for everything that is they
require each other and all the modules
in the JDK and all of your modules as
well and they export all of their
packages now whilst this may very well
not be the set of requires and export
directives that the maintainer zuv
Jackson would write by hands it's
actually a feature because it it
emulates the behavior of the classpath
it provides the maximum possible
compatibility surface for code in jar
files and actually overall this is
better than when everything was a jar on
the classpath for example if you look
carefully there's no arrow from my lib
to my app so there is no danger of code
in my lib accidentally reaching into the
apps internals on the classpath code in
my lib dot jar could access code in my
app dot jar quite easily without even
knowing it and that's what causes
maintenance headaches down the road so
when thinking about migration each
application jar is usually a good
candidate to be a module each library
jar will modular eyes at its own pace
but automatic modules mean you are not
waiting for the weakest link now I'd
like to turn our attention in this final
section to the modular JDK 20 years ago
the Java platform was small just a few
hundred classes and the organization of
the JDK was not a problem but every year
the platform grew bigger and now it's
tens of thousands of classes the JDK is
huge and worse it's monolithic now in
reality the Java platform is not one
thing it's more like 25 separate
frameworks including the swing UI
framework the crypto framework a
scripting framework multiple XML
processing frameworks and so on there's
no reason these separate frameworks have
to be tightly coupled
one download in fact it's an impediment
in developing the JDK the overly tight
coupling perhaps accidental raises
development and testing costs which
turns into slower platform evolution
plus the larger the surface of your
platform the harder it is to secure and
it's an impediment to a lot of users
both those who want to run their
applications on smaller devices and
those who want to run more instances of
their application on large systems even
if you only wanted a part of the JDK you
had to take all of it that all changes
in JDK 9 we've taken the monolithic JDK
and broken it up into a few dozen
modules some are part of the Java SE
specification some up just parts of the
JDK implementation here's a graph of the
Java SE modules at the bottom there's
Java base which everything depends on
and which depends on nothing itself
we've broken out the various frameworks
into their own modules instrumentation
logging XML scripting desktop which you
can require or not require as your needs
dictate there's a Java SE module at the
top which has no code in it it just has
dependencies so you can say requires
Java SE and be guaranteed to have all of
these modules available now it's worth
mentioning that merely finding these
module boundaries and relationships
which might be obvious in hindsight was
a tremendous engineering efforts you'll
find in your own code that decoupling a
monolith is much harder than building a
loosely coupled system from the
beginning
the good news going forward is that the
discipline imposed by modules will
prevent all of us from accidentally
recreating a monolith from backsliding
into the big ball of mud
I'd like to quickly review the
expectations of compatibility from JDK 9
first up there are various technologies
from Java EE that ship in the JDK as
well as in app servers the list of Java
EE modules in JDK 9 includes CORBA
Jack's B jax-ws and common annotations
these modules which were not on the I
didn't have them on the previous slide
to keep it simpler but they are in JDK 9
are deprecated in JDK 9 and will be
removed in a future release because of
that they are disabled by default in JDK
9 if you're running code on the
classpath you may need to use the add
modules command line flag to enable
these Java EE modules seconds a lot of
tools and libraries try to access parts
of the JDK that are meant for internal
use only
unfortunately it'll take a while for
tool and library developers to move away
from this practice so JDK 9 temporarily
allows access to JDK internals but
prints a warning when it happens now
there's a command line flag to avoid
these warnings so please check with tool
and library developers about how to
deploy on JDK 9 or just searched a Cova
flow where people have been asking for a
few weeks now
why isn't stuff running what is this
exception what is this warning what do I
have to do and the answer is temporarily
add opens there are also miscellaneous
changes in JDK 9 that are unrelated to
modules but might affect code that ran
on JDK 8 and I want to be upfront about
them notably code that assumes the Java
version string begins with 1 dots or
assumes that the JDK lives in a file
called RT jar will fail on JDK 9
again please check with tool and library
developers about which versions are
needed to run on JDK 9 you can't assume
that older versions of tools and
libraries will run on JDK 9 so in the
modular JDK its modules all the way down
JDK internals are accessible temporarily
in JDK 9 and you may need to upgrade
tools and libraries to their JDK 9 aware
versions in sum a module is a set of
packages designed for reuse automatic
modules assist with migration to modules
and you may need to upgrade tools and
libraries to their JDK 9 aware versions
there is a huge amount in the module
system that I haven't had time to talk
about you can encapsulate resources in a
module not just classes you can express
optional dependencies by programming
with services you can build custom
system images with the j-link tools so
you can physically drop CORBA right now
if you want to and you can spin up
multiple versions of a library with the
module layer API if you're interested in
this kind of thing I recommend two books
the first is Java 9 modularity out this
week it's a pragmatic walkthrough of the
entire module system and the modular JDK
and the other is java application
architecture from 2012
it is a principled look at constructing
modular applications it's nothing to do
with Jada q9 logic saw and it has
fantastic advice that applies whether or
not you use this module system OSGi is
in the title it's it's it's general
advice about structuring large Java
programs so JDK 9 is here it's on JDK
dot java.net today if you're a library
maintainer please run Jade EPS to see
what JDK internals you rely on you can
do this right now even on on JDK 8
installs
everything you ever wanted to know about
the module system is discussed in JEP
which is jdk enhancement proposal 261 I
cannot emphasize enough how much
valuable information lives in Jeff to 61
there's also JEP 260 which identifies
the JDK internal classes that are
temporarily exposed in jetty 9 jet 223
which defines the new version strings
beginning with 9 and jet 220 which
discusses how our Tiaras gone away and
the structure of the modular jdk and
finally jet 200 gives an overview of the
the java SE and the jdk modules but if
you've read jet 261 there won't be any
surprises because 260 one's already
talked about the modules and the class
load ism how you compile against them
and patch them etc and with that thank
you very much
we have three minutes for questions that
was a question here to be fair that my
Alan I don't make good thank you in the
keynote it said that we were gonna be
going to a six-month cadence does that
mean that our warnings will will become
errors in six months or like with incue
bation
so the question is if the JDK has been
released every six months and we're
printing warnings about temporarily
allowing access to something does that
mean that clock is is counting on a
six-month deadline
nothing is ever set hard-and-fast we
don't say it's than exactly the next
release the the it'll be the the the the
encapsulation would be dialed up but in
a soon the future will be here sooner
than we think
let me put it that way this video is
available you actually don't the slides
because you need the notes as well so
the video is the best thing yeah hey is
there any way to depend on a package
without specifying the module is there
any way to basically require a package
yeah and not a module no the dependent
the granularity of dependencies is
module to module so you can have two
modules that provide alternative
implementations of a package you can do
that with services I meant to you my
talk on Wednesday about services
there's a question at the very back
hello
so do you know anything about the future
of OSGi regarding the modular station of
the JDK No next question what about war
applications ask the e4j initiative okey
mr. Robert Schulte has a question what
could it possibly be so can you spend
some words about migrating libraries and
about the automated model name the
question is what about migrating
libraries libraries are just Java
classes at the end of the day if they so
happen to call set accessible okay quick
strawpoll who has used core reflection
in their recent lives okay to be fair
some hands who who including said
accessible ah it's like a set accessible
support group in here okay so I sort of
want to ask you what do you call he's
had accessible on but we're out of time
so for libraries if libraries are trying
to defy define classes into the
application class loader they should
create their own class loader that's a
specific piece of advice if just to say
son Mis gun safe is still accessible in
JDK 9 if you are using a four off heat
memory access you should be using var
handles instead and then you should be
using multi release jars to put the var
handle code in a separate directory for
nine and then what you were doing on
eight and there's a whole there could be
entire presentations about that is there
a specific because no one here is a
library maintainer right one hand two
hands okay well it's all about
keeping the amazing ecosystem McLean's
so if you are a library builder and you
want to refer to Josh which are not yet
modules please only refer to them if
they have a module name with the
manifest file and not based on their of
jar file name that is an excellent point
that you gave me every opportunity to
make and I failed to do so the point is
that libraries library maintain errs
even if they don't declare a module
explicitly should go should should
indeed put it in their palm and specify
the automatic module name manifest entry
that is a way to commit to a name for a
modular jar without actually putting
module info class in the modular jar and
committing to a stable name for a module
is a huge deal and we encourage library
maintainer x' to do that even if they
haven't looked in any way at the
encapsulation story or the nato or what
they're gonna export or what they're
gonna require may be one very quick
question was there one there no one very
quick question from the back
I wheeze the Java cryptology extension
for like bouncy castle and we have to
sign that with a digital certificate
from Oracle to be able to deploy that
what changes will will have to be made
to do that if any so this is really a
question about signed modular jars yeah
Allen can best answer that on the
microphone your answer castle should
workers before the the security
configuration file is slightly changed
in that you actually give the security
provider name broader than the class
file but there's a backward
compatibility that just keeps existing
providers actually working I can't give
you the full answer on the signed crypto
provider as packaged as a module because
there's there's a couple of issues there
that is just way beyond the scope of
module time but there's a security bar
tomorrow night that actually Sean Mullan
is is is legal that will be an excellent
place to bring yourself right thank you
again</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>