<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Designing Functional Programs | Coder Coacher - Coaching Coders</title><meta content="Designing Functional Programs - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Designing Functional Programs</b></h2><h5 class="post__date">2017-10-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/KhdGMcVhrQU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright let's get started welcome to the
session on designing functional programs
my name is Venkat Subramanyam we're
going to talk about how do we approach
some of the concerns we normally have
when it comes to designing functional
applications just to quickly set the
stage where this kind of talk came from
I've been giving talks on programming
with functional style in Java for a
quite a number of years now and almost
always when I finished my talk I would
have people come up to me and ask some
questions and there was a very common
theme of questions that happened almost
every single time I gave a talk it's
like oh I've heard this question so many
times and so I said well that really
means
it deserves a talk on its own so I kind
of grabbed some of those questions and
create a talk out of it so I'd really
want to talk about how do we really
approach you know designing some
functional systems also what are some of
the deficiencies of the functional style
of programming in Java where it may fall
a little flat and where we may have to
do a little bit different this is not
about functional programming in general
this is pretty much about how do we deal
with this in Java because the tools we
use often constrain what we can do while
there are concepts and theories and
practices out there we may not be able
to do all of that the way we want it to
do depending on what tool and
environment and language and framework
and libraries we use so this is pretty
much about the world that most of us in
this room live in which is hey we're
programming in Java we have adopted Java
8 we're programming in functional style
but how do we really approach it that's
kind of what I really want to focus on
in this talk so in terms of functional
programming so what is really functional
programming well we are trying to do a
function decomposition that's what we're
really trying to do one of the things
that really frustrates me when some
people who are practicing functional
programming go out and say gosh this is
great we don't have to do objects
anymore to me that's trying to throw the
baby with the bathwater right I don't
have a problem with object-oriented
programming I have problem with the way
people use object-oriented programming
so the problem is not in oh the problem
is and how it is being used by a lot of
people and and I strongly have benefited
from object into programming so
I don't want to throw it away but in
that regard I want to look at it a
little differently so what am I really
trying to do when I try to program in
function style what am I really
approaching so if you really look back
in about twenty years of Java
programming we all can agree that we be
in programming in object-oriented
systems right so we've been doing
object-oriented programming so that's
that's kind of summarizes that's what
we've been doing but let's be really
honest about it there's nobody who has
ever written object-oriented code with
only objects it's impossible to do that
because when you create objects what is
the next thing you do you create methods
and fields maybe and then when you
create methods what do you do well how
are the methods going to be implemented
well we gotta write some code for
implementing the methods so what we've
been really doing honestly is not
object-oriented programming we just keep
saying it what we've been doing really
is imperative plus object-oriented in
all honesty right because that's what
we've been really doing imperative plus
object of the programming is what we've
been doing all these years because the
methods we write and how we work with
multiple objects all of them have been
imperative and and to me there are parts
of oh that really is bad but there are
parts of oh that is very powerful very
useful and I don't want to let go of
them that's just my personal choice I
know I might my anger is not an object
into programming right but so the
question is what are we really trying to
get to well where I'm gonna still
continue doing object into programming
but I'm gonna do it with functional
decomposition plus object or in the
programming so all I'm interested really
here is replacing that part not the
right side because the right side is not
my main problem the sure it can be done
in a very poor way I'm not saying that
people don't do in a poor way but if I
do oh oh in a really good way then my
problem is not to throw it oh oh my
problem is to throw out the imperative
style or at least replace it with a
functional style so in Java
today and other languages for example
you know Ruby and Scala and groovy just
Java is not the only language that does
this a lot of different languages you
can actually use object oriented
decomposition
can mix it with functional decomposition
as well and you can benefit from best of
the both words and that is one of the
really rewarding things for us to do so
so uh what I'm trying to do over the
years is really get better at this part
where can I apply object into
programming and where can I apply
functional programming and put them to
really good use and benefit from each
one of them because I find value in both
of them and of course on occasion I do
have to admit I do use imperative style
of programming also to me these are just
tools I'm not biased towards one two
versus the other
I prefer functional style programming
where it makes sense where my life is
easier where I can actually benefit from
it but there are times when may be an
imperative style is better for the
problem at hand and I don't mind really
using that in that particular context so
so in that sense what is really
functional programming you know espouse
what does it really provide well the
very first thing we hear about
functional programming when you start
reading over function programming will
start learning about it what do they
tell us the first thing they tell you is
hey you should not do any mutability
right assignment less programming is
extremely important don't do assignments
don't change anyway variables and values
there are a good number of languages I
classify those languages as so I
classify languages into a couple of
different ways within this context I
call them as purely functional
programming languages languages and and
then of course there are languages what
I call as a hybrid functional languages
just like in object-oriented programming
you had fully object-oriented languages
but you also had hybrid object-oriented
languages one example of hybrid optical
language was C++ even though people will
argue whether it's object-oriented or
not but but I'm not really interested in
that argument it is in hybrid language
as for some concern because I could do
no objects at all in it right pure C pro
code in it if I want to or I can mix and
match it whereas if you take a very very
purely object-oriented language it will
not all of you to really have anything
outside of objects it'll enforce that
and objects are really becoming the
paradigm in that case of course you're
still being imperative but but they're
not entirely procedural on the outside
much like this there are certain
languages which are purely functional
programming languages these languages
will not allow you to
anything period there is no syntax for
modifying a variable once you create it
you can spend hours and days together
there is no way you can change it I
teach a course on programming languages
and in the in that course I usually use
about eight languages but my students
are way better than me
collectively we use about 20 or 25
languages in the course it's very
rewarding course to teach because I come
out learning a lot from this course but
in one semester a student with about you
know 15 years of experience came to me
and said you know I've used these
languages but I actually like a purely
functional language better than a hybrid
functional language he said I said why
do you say that and and and the reasons
he gave could be taken in two ways and
he said the reason is when I sit down to
write code I come from imperative style
a background object of silent background
when it's down to write code when a
language is hybrid I struggle with it
for 15 minutes I cannot figure out how
to do it I quietly go back to my old
ways of doing things and the language
quietly lets me do it on the other hand
this purely functional language beats me
down right it takes me and beats me on
my head and says it's my way or the
highway and I cry I complain I curse and
seven hours later I'm still stuck and
then I go take a break come back the
next day and finally things begin to
work and after all this frustration I'm
beginning to see the light of how to do
this so he said from that point of view
I really like languages that beat me
down and tell me this is the way to do
it I said that's exactly the reason why
I also prefer hybrid languages because
when I'm at work my boss is gonna beat
me even harder right when I don't get
the word done so I'm really happy to say
you know what this purity is all great
but I've got this in production now we
can come back and refactor it I'm a
really pragmatic person rather than
being a perfectionist yeah I really want
to do good things but at the end of the
day I still have to you know continue
releasing products as well that's kind
of the reason why I like these kinds of
languages because they do give you an
escape route when you're stuck with
something so in that regard there are
some languages that don't have
mutability at all available so here
surely one of favor immutability but
that's one of the things that function
programming languages really espouse the
other thing is
higher order functions what in the world
is higher order functions well let's
think about this for a minute again in
the context of Java and what we've been
used to
what are what have we been doing so far
we may pass object to object to
functions I am I'm purposefully not
using the world method so just clearly
to get it get it out of the way to me a
method it's just a function a method is
a function that has association to a
class or an object so a function could
be a free-standing function a method is
a function that's tied to a class or to
our to an instance so I'm just going to
use the word function in general we may
pass a object to a function we may
create a create after all object within
function so here we can do that too we
are already doing that in languages like
Java and then finally we may return
object from function I'm not trying to
be grammatically correct here for good
reasons so so this is what we've been
doing we're used to doing this what is a
higher-order function after all
higher-order function is where we may
pass a function to a function we may
create a function within a function we
may return a function from a function so
that's basically what makes a function a
higher-order function is that we can
compose functions using other functions
to put things together so we are using
higher-order functions to build stuff
around it so a higher-order functions
give us the ability you can still take
objects as parameters you can still
return objects as results but in
addition you could also work with
functions receiving them creating them
and returning them as well so that gives
us an ability to program with
higher-order functions where you are
raising your bar you're saying I'm not
only going to receive objects from you
or data from you or primitives from you
I'm also willing to receive functions
from you as well that's basically what
higher-order functions give us well this
leads just to some really powerful
things and to me while I'm really
excited about immutability while I'm
really excited about you know
higher-order functions but to me these
are not the most important things to
really work on for example if somebody
comes to you and says hey what's really
so cool about object-oriented
programming
I'm not suggesting object or programming
is the one that introduced all of these
but
what is really cool about object into
programming well we could say that
object of programming is where we really
honor abstraction right sure absolutely
and then we honor encapsulation so
absolutely we want really to really fill
in for some capsulation and then of
course we want to really have
inheritance and then of course what is
the last thing polymorphism but if you
really think about it in among these
four things which is the most important
thing so polymorphism which is the most
important thing well abstraction is not
new to object into programming at all
we've been doing abstraction for many
many series even before we thought of
programming right
Plato introduce the concept of
abstraction if not being one of the
first definitely one of the first people
to do this we've been using abstraction
every single thing we do in every
language we have ever written we have
abstraction some form or the other maybe
lot not all languages give us the user
defining the datatypes but we can say
that's great we can have that well so
discard that encapsulation well sure
encapsulation is extremely important but
you could do encapsulation even within a
function whatever local variable you put
in a function is encapsulated right so
this really extends and gives you other
forms of encapsulation that's absolutely
useful I'm not saying it's not useful
but I'm not going to oh just because I
can do encapsulation sure that's
extremely welcoming
what about inheritance the only thing we
inherit is pain because in this case you
mostly this is really a cause of problem
than a cause of strength there's really
a good variety of object under languages
that don't even care about inheritance
unfortunately when we program in one
language predominantly they blind us and
they sincerely do unfortunately because
they really blind us we're not able to
think beyond it this is one of the
reasons I really want to learn different
languages that way I would not think
about anything in one particular way
right so there's no one real way to
think about things there's so many
variations inheritance is not really
required in a lot of lot of ways and
it's usually part of a problem than a
solution most of the time but that
leaves this polymorphism though
polymorphism is not unique to object
under programming
I really do poly object programming for
polymorphic behaviors because this is
what gives me extensibility in my
software so to me
but oh really what is it we are really
after polymorphism is to object-oriented
programming so this is what I'm really
really after when it comes to
programming a polymorphism means to
object of programming as and what am I
really going forward so similarly when
it comes to functional programming what
do people normally tell us well they
tell us in the functional programming
world immutability is extremely
important this is like saying
abstraction and encapsulation all those
good stuff similarly they tell us that
higher-order functions are really
important oh yeah absolutely I
completely agree with that higher-order
functions are important but but the real
charming feature of functional
programming in my opinion really comes
from two things one is function
composition and the other is lazy
evaluation so these are the two most
charming features our functional
programming and this is what I wake up
every morning to enjoy when it comes to
functional programming these to me are
the pathway to get me to this I cannot
do this without these two but I'm not
doing these two without getting these
two right that's what I'm really after
so I'm gonna say function composition
and lazy evaluation is to functional
programming because that's what we
really are after in in terms of what we
are our goals are to to cherish as an
important feature
why because function composition gives
us expressive code it's able to be able
to really express the code as a series
of transformations it removes accidental
complexity the reason are not happy with
imperative code is because of the
complexity it brings them the accidental
complexity it brings into the code
whereas the function composition that
removes that accidental complexity it
makes the code expressive it makes the
code easier to follow it makes the code
easier to understand and that is one of
the biggest gains I get out of it but
unfortunately though I cannot just sell
you that function composition is great
and go home because you're gonna go try
it and say are you a idiot because this
is going to create objects after objects
after objects and we could have really
problem the more garbage you crew
the more garbage you have to collect and
we're not going to have good performance
for large data set if we keep creating
objects but in all fairness there's a
lot of languages that do just exactly
that they give you the functional style
the function composition but they do not
give you the lazy evaluation in those
languages when you create a large
collection and go through a function
pipeline you will create a lot of
intermediate collections along the way
but they don't seem to care about it for
a couple of reasons because most of the
time people you work with really small
collections
it doesn't hurt performance and again
pragmatically speaking I don't want to
complain about things that don't affect
me hey my collections are really small
the performance is reasonable why bother
be happy about it but I'm personally
working on large data projects these are
these days I deal with millions of data
performance is the most important thing
everything else comes after that having
the laziness gives a way to really be
efficient and expressive at the same
time that's one of the really because
benefits we get out of it so in other
words the immutability and the
higher-order functions are really nice
very useful very critical but where what
I'm really after is is those two
function composition and lazy evaluation
that's what I'm really really after when
it comes to these languages what does
this really help us what does the purity
help us with and and let's understand
how this can be very useful I love
languages for what they do because when
languages know that a certain construct
is very pure
there are optimizations languages can do
let's take a look at an example of this
real quickly one such language is
Haskell our Haskell is probably one of
the languages that really amazes me
because I actually rejected the language
a few times I tried to learn it three
times I gave up every single time and
the third time I sat down and said you
know all my friends tell me it's a good
thing I trust them I want to learn it
and here's what I had really hard time
learning Haskell every single time I sat
down to learn Haskell I was trying to go
through the the static typing and I
could I'm not smart enough to even get
it and I just can't get get failing
every time and then one day I realized
oh my gosh I've been doing this wrong
Haskell cares less
about me telling what the type is it's a
language that has a very powerful type
inference it can figure out what the
type is very smartly and here I was
trying to tell it every single detail
and I'm trying to really hurt myself and
I nowadays I don't put any type at all
mostly when I write Haskell code it
doesn't seem to care and we're really
good friends now and that's not the way
we started out so the beautiful thing
about this is the language is actually
very powerful in that regard but I want
you to think about one thing
defaults and there are languages this is
purely a language fundamental right
there are languages that do save
defaults and then there are languages
that do unsaved defaults so I really
spend a tiny bit of time thinking about
it look at languages like Haskell it's
save defaults everything is pure if you
want to make something impure you have
to beg and say please this one time
please only this afternoon let me make
this impure and Haskell will say not
today and it's like really really really
hard to make things impure right you
have to work extra hard to do it you
know languages like Java everything is
unsafe mostly you want to go to Java and
say could I please make this immutable
this time please this time and Java says
ok I'll think about it so it's a
complete office opposite spectrum of
where things are isn't it and and in
that case when a language can enforce
purity there are things it can do I'll
just give you one example of this where
just to share an excitement I have
witness let's say I have an ad function
where ad a B this is a Haskell code is a
plus B well cured this is a very simple
example a plus B but there is something
that Haskell knows that languages like
Java would never know and that is
Haskell knows that this is a pure
function because variables are immutable
in Haskell by by default you cannot
change them and as a result Haskell
knows that this is a pure function if
you write the same code in Java Java
says I gosh I don't know what you're
doing in these functions I can't
guarantee purity at this point a could
change elsewhere B could change
elsewhere
I can guarantee that for you then I'm
gonna say over here in this case let's
say I'm gonna say oh let's say evaluate
value equals value again a really stupid
silly example
then I'm going to say Maine right here
and in the Maine is when I'm gonna
introduce some impurity and this is
basically saying hey I really want a
sequential execution of this code
I got dependency on the ordering stuff
like that so in this case I'm gonna go
ahead go to a print and then I'm gonna
say evaluate and then I'm gonna pass
through it and add one and three well a
very simple example as you can see but
when I run this code it produces a value
of 4
but languages like Haskell can do
something really different than other
languages in the case of Haskell there
are two distinctive evaluation models
one is called the normal order and the
other is called the applicative order so
applicative order and in this case a
java and most of the languages we are
used to do what is called the
applicative order you know it's really
funny we call it normal order because
it's pretty abnormal very few languages
actually do this in reality in a normal
order functions are evaluated not in the
order in which you apply them so if you
were to look at this in your eyes of
Java program if I asked you when will ad
be called
you tell me ad is going to be called
right away because and it's going to be
called right away and the result of ad
is going to be sent evaluate and the
result evaluate is going to be Haskell
says never mind aren't gonna call ad
what are you gonna do with AD well gosh
I'm gonna send it to evaluate what I'm
gonna do with the evaluate I'm gonna
send it to print okay that's a good
reason to do it
it's absolutely lazy right and it
postpones it but it can postpone it
because I had one and three will never
give you a different result in a million
years it's pure and that's one of the
properties of pure functions it's gonna
give you the result the same result
every single time you call so I want to
prove to you that this is actually not
going to call ad you know until you
really need it
how do I prove it well in the case of
job I often put a print statement if I
put a print statement Haskell it kind of
scares that minces are really you're
trying to do this so I can't do this I
never thought I would use a debugger to
prove a point I feel it enough shame so
pardon me for doing that so in this case
I'm gonna go ahead and stay over here
just bring up the GHC i and this is a if
I know how to type GHC I so this is the
repple that I'm gonna use for Haskell
and I'm gonna say
load here the sample sample dot HS and
I'm gonna just blue load this file here
then I'm gonna say break I'm gonna put a
breakpoint on line number one character
number 16 so I'm gonna say 1 and 16 well
now that I put a breakpoint I'm gonna
call the main function well as you would
see here it is waiting for me on line
number 1 at character 11 and 15 it says
I'm gonna wait for this and okay thank
you for waiting
continue and she or it gave the reserved
a for I didn't really prove a whole lot
right now did I well let's come back to
this but I'm gonna go back to this code
and say when you call evaluate value
equals I'm gonna return a 42 when I run
the code notice that I surf this 42 but
Haskell is very smart
Haskell says what do you want to do you
say Haskell call add it says why because
of what a pass the result to evaluate
why because I want to print it okay
let's just print the result of evaluate
it comes in at runs evaluate reevaluate
returns 42 notice you never cared about
value and Haskell say is gosh why do I
waste time doing stuff that has no
meaning I don't have to really waste my
time let's be lazy but laziness becomes
from purity so I'm gonna show to you
that ad was never called but how do we
prove that ad was never called well that
actually turns out to be really easy
after all because if I go back here and
run the GHC i again go back can put the
breakpoint one more time on that line
but this time it called the main method
and in this case of course oops sorry
I've missed appear let me try this again
so in this case of course I'm gonna go
back try again so let's go ahead and say
load the file again so I'm gonna load
the file let's load the sample dot HS
got it let's put a breakpoint on line
116 I'm gonna call the main function and
notice it never ever stopped on the add
function well that's really
optimizations that can come through when
a language begins to know that you are
following honoring purity of functions
and and this goes a long way so purity
is really the reason I want to do it'll
keep things pure and follow these things
is because of greater efficiency I get
out of it and that is really the
motivating factor for me to really go
towards that well that brings up the
question then if functional
purity is so important how in the world
can we make those things happen
you know if I'm programming in Java you
have to work extra hard to make these
things work because the language may not
be there to safeguard you all the time
you have to have fairly good code
reviews you have to have other tools
that check for these things you may have
to do a little bit more work in terms of
determining these things so how do we go
about doing this well one of the things
I want you to think about is when you
write functions as much as you can make
those functions pure so this is
something you and I can actually do one
way actually we can help doing it is to
keep the functions relatively short some
people have the tendency to write very
long functions long methods long methods
are evil in several several ways and
long methods are really hard to prove
what nefarious things they are doing
under the hood
so you definitely want to keep methods
really short so it's easier to examine
them and show that we can also use tools
that can verify for purity as well but
when it comes to purity of functions we
have to really enforce purity and and I
and the reason this is so critical like
I mentioned is because you cannot get
better performance without having the
purity of functions so this is why it
becomes absolutely critical but from the
point of view practical wise how is it
practical to achieve this well the very
first thing is when you write methods
make sure those methods that you are
writing a as much as possible are pure I
came into work one fine morning and and
a buddy of mine said hey the code worked
really well sequentially but took a lot
of time to run I made it parallel I
don't even have to tell you what the
result was it what the speed was the
result is wrong and and yeah but the
result is wrong it doesn't matter how
fast you got the wrong result isn't it
so I immediately said you know what I
haven't looked at the code yet but I can
tell you what's happening you have a
variable somewhere and it's a field in
your class you're calling a method and
the method is mutating that field and
each tear some name says so that's it ha
your wisdom is like yep that's it now
the fun is to go find that out and we
started just looking through the code
and sure enough 30 minutes later we find
exactly that one little variable being
mutated in this one function
about an hour to refactor the code we
run it we get parallel results much
faster of course incorrect and and
immutability really makes it hard to
make it parallel as well so lazy
evaluation and parallel requires purity
of functions well if that is the case
how could we really achieve this
practically in a program so when it
comes to designing a fab
application I I try to use the slogan of
a circle of purity but the ring of
impurity around it so what what I mean
by that is I'm going to take a circle
and I'm gonna say everything in the
circle is going to be pure so it I'll
build a library of functions and these
library of functions will all guarantee
purity for me and when I'm in this
library of functions within the circle
that circle of purity I will not mutate
any variable I will not mutate any
global state I will not mutate any value
given to me I'm not going to touch on
and change the state I take an input and
return an output that's what I'm gonna
do and around the circle of purity I'll
build a very thin ring of impurity and
the stinking ring of impurity is where I
would read from a data base if I want to
I'll do logging I might do work like for
example talking to a web service so a
lot of things I can do in the ring of
impurity but the minute I grab the data
that I want to work with from moving
forward once I enter the circle of
purity
I will not mutate anything and I will
wait until I exit the circle of purity
and then once I get out of the circle of
purity I can start mutating things again
because practically the language like
Java does not have this concept of hey
we're going to really enforce you know
immutability for you we have to build
that around with the limitations that we
are gonna have in languages like this so
having that model of purity versus
impurity where a circle of purity is
where I'm not going to really cause
anything impure when it comes to this
purity as well we have to be careful not
only to not mutate variables but not
also to depend on variables that would
otherwise be mutable so that's one thing
we can do in terms of this of however
there's one major concern we all want to
as programmers and that is if I'm going
to do immutability one way I can do a
mute
we used to copy objects well wait a
minute if I'm gonna copy objects isn't
that gonna be silly because we're gonna
end up with a large number of objects
and that would be not very good in
performance at all so how do we really
put it well this is where we can enjoy
from some what I would like to call as
functional data structures for example
if you really think about lists if you
will the list in languages like Clojure
and Scala the lists are completely
immutable so you cannot modify a list
once you created so immutable but when
you look at a list these lists all
sufficiently provide certain operations
where you can add elements to the head
well it's not it's not mutable but what
does it mean to add well when you go to
a list and you add here's an example of
a Scala code if you have a list let's
say of one two and three let's call it
as val list is equal to now you can
simply say zero and then you can put a
list into it and this will be let's say
list two that you get out of this
well list one is immutable list two is a
copy that you get from this given list
and as a result what did they actually
do here's a very interesting way to
think about how this works imagine that
the list of people on the front row
imagine that list is immutable I cannot
change that list what I can walk up to
the front of the list and declare myself
as the first person in the list with all
respect they cannot do anything about it
and and so I because the list is
immutable I can declare as myself as the
first person in the list and if you ask
the gentleman over there how many people
are in your list he's probably gonna say
I have five people in my list but if you
ask me I'll say I have six people in my
list because I'm generously going to
share the list that's there and that's
exactly what these languages do they
share existing data because the data is
immutable
they can do that effectively but of
course you're adding to the head and
potentially removing from the head to
collect a create another list well if
I'm always adding and removing to the
head what kind of data structure is that
well that's obviously a stack so a lot
of stack based algorithms fit really
nicely into this and and similarly what
you can actually do is use
structures like trice a gentleman named
Phil Bagwell created this and a trice is
a data structure with a very large
branching factor and with the tries
essentially these are called persistent
data structures and it's called
persistent because they are immutable
you're not going to change it twice
itself was not immutable but Ritchie
submitted enclosure and suggested that
we can actually make use of it but
because of a very heavy branching factor
the cost of making changes are creating
a copy if you will is extremely small
Ricky calls this as effectively constant
or are practically constant well it's
practically constant because it's order
of let's say a log n where the order of
log n but the log of n in this case is n
is not the number of elements n is the
number of levels if you will so in this
case of course if you have four levels
because the branching factor is really
huge a branching factor is when you can
have many number of children tries
usually have thirty-two or more children
within a four level you can literally
pack more than a million elements and to
make a copy of that particular million
elements collection you are going to
spend an order of log four which is
practically a constant I ran some
examples with this I took the vector
which is in Scala which is a price
implementation ran it from within Java
and I found out for a hundred thousand
elements the cost of creating a new one
where I changed something right in the
middle was something like 33 33
nanoseconds and it's been a few years
since I ran this actually but it can be
really really fast as well so we can
start using some of these ideas but if
you really have to poke the data
eventually that's where the circle of
purity was a circle of impurity the
circle of purity versus the ring of
impurity can come in really effectively
but there's one other issue that we have
to deal with we have to think in
functional style for this a
recommendation is to think declaratively
first and then you are saying well now
that I know how to X was the problem in
words I'm gonna try to try to write
functions for it the JDK has a slew of
methods that can help us with this there
are so many methods in the JDK that we
can use to do these kinds of
transformations you can take a
collection in
from memory you can take a files content
and you can start looping through them
you know in a functional style so
there's a lot of different things you
can do with functional style of
programming and as you start writing
code itself to ask the question how do i
express this in functional style but
last thing I want to cover is one very
sticky point and that is exceptions and
I'm sure many of us have felt that pain
right so when you go to a stream for
example if you go to a stream let's say
we have a stream with a collection of
numbers and in this case I want to
perform a scream
operation so what are we going to do
numbers dart stream and I'm gonna
perform a map operation given an element
transform the element let's say and then
I'm gonna say let's say for each and
then I'm going to simply print out that
value that's been given to me so given
the element I print it out but what is
the transform method really going to do
for me well in the case of a transform
method
what if transform was going to give me
an exception well notice in this case
let's start with baby steps a public
static let's say int transform takes a
number and all it's going to do let's
say is simply return the number right
now so here is a return number imagine
this is a computation that's gonna take
some effort we don't have to worry about
it right now but what if I do something
like this what if I end up doing if
number let's say is equal to o let's say
7 then I'm gonna say throw and new
exception and I'm gonna throw some kind
of an art exception so let's say oops
something went wrong just like we get
exceptions in our systems right and I'm
gonna say that it went wrong well what's
going to happen at this point this could
be a very specific checked exception I
you know I whatever name you want to
provide for it at this point the Java
compiler gives you an error and it says
hey you cannot throw an exception from
this code because on line number five
you have to say you're throwing an
exception this is only going to get
worse as we go through
now you say throws exception now what's
going to happen Java now complains on
line number 14 it turns out a lot of
these methods don't deal with checked
exceptions at all why
is that well the functional interface
simply does not have the function
functional interface predicate consumer
supplier none of them deal with checks
on one hand you could say gosh they
didn't deal with checked exceptions but
there is actually a really good reason
why they didn't provide checked
exception because doing it is actually
not part of a solution it's part of a
bigger problem so what do we do about
this let's think about this for a second
if we weren't going to step back to this
and say okay I want to really handle
this what do we do some people will
suggest to you a very dangerous solution
in my opinion and that is to come in
here and paint the exception that really
happened you know potentially you're not
the one throwing this exception maybe
this exception is coming from a lower
level when you're calling that other
method that's blowing up with a checked
exception what do you do well so you
probably took this number and you did
some other work right you called another
function calculate over here and the
calculate function maybe you passed the
number over it and that blew with that
exception so they may suggest to you
something like this they may say oh
here's an idea put and try and a catch
around it and then grab that exception
whatever that exception is and then of
course then do a wrapper on it new
runtime exception and they will even
give you convenience methods to do this
and then wrap it there is a very easy
way to describe this this is called a
bad idea well then why is this a bad
idea well the reason is we didn't really
solve the problem we just quieted the
compiler if you really think about it
that's what we did right when to the
competitor and said be quiet now and the
compiler is like okay I'm happy I won't
complain the problem did go away the
compiler just quieted out this is a
disaster what is the reason why this is
a disaster well think about where we are
right now we are in a function pipeline
now in the function pipeline you might
have filter over here you might have
more filters right here and you might
have other operations like for example
oh let's say a few other map
operations who-knows-how-many how long
this function pipeline is going to do
well this is a pipeline you are in right
now and when you visualize the pipeline
look at this as a stream of data flowing
through from one stage to another stage
to end of the stage now in this pipeline
if one of things blow up what do you
really do so the problem with exception
handling is exception handling oops your
call stack I'm gonna go out on a limb
and say exception handling and
functional style of programming are not
orthogonal or completely disconnected it
makes no sense to mix them together in
that context why is this a problem let
me give you a very stupid example of
this imagine you are driving on the
freeway and you are about two miles away
from your eggs and you have a flat tire
what's the worst thing I can tell you
I'm going to tell you you had a flat
tire now drive in Reverse go back to
where you came from now dude get out
safely and pull to the exit right so in
other words you always face downstream
you never go upstream and you don't try
to jump out of the freeway that's not
safe also so think of this as a stream
when you're flowing through the stream
you don't exit from the stream
abnormally you still have to exit the
stream in the bottom so when you have a
stream where you go upstream to
downstream how do you deal with it
well the question is how do you deal
with it with this in java let me say i
am really a fan of streams I truly love
streams I am going to tell you that I
enjoy streams I love it I use it all the
time but that doesn't mean it's perfect
so ask the question how does streams
handle exceptions they handle exceptions
with two beautiful words they're called
good luck so essentially there's no
answer really other languages provide
other solutions but Java quietly said
deal with it so there's no really good
answer how to deal with it so how do you
really deal with exceptions if you're
going to deal with it well you can go
the hard way and you can deal with it
one of them really is so this is the
difference between the functional
mindset versus the imperative mindset so
Java 8 streams
doesn't give you a good answer one thing
you could potentially do here s you
could take on the data well essentially
what you really want to do is you want
to treat exception or error let's put it
as error you want to treat error as
another form of data that's what you
really want to do it is just another
form of data and things do go wrong
things do go mess up and it's okay
you don't want to be smacked on the head
when something goes wrong just deal with
in a very civil way so what are we gonna
do in this case well okay I'm flowing
through this processing the data but
something went wrong here so I'm gonna
go push that down as an error so you can
deal with the downstream so in other
words but how do you really do this in
Java sadly there's no real easy way to
do it in the streams API because if I
take this in the streams API well I have
to now create a structure where I have a
data and I have an error and I want to
push them down and Java doesn't quite
give us anything like that there are
other languages that provide constructs
that deal with these kinds of couples of
data and errors but Java doesn't have
one so we could maybe look for solutions
elsewhere and such place where we can
look for solution is in JavaScript
promises this is exactly what your
completable futures in Java do as well
because after all completable future in
Java is nothing but promises in in a
sense so what do completable futures and
promises do well completable futures and
promises say well when you have data
will flow the data through in other
words the promises and completable
futures I like to say that they have two
channels and the two channels they have
is a data channel and then they also
have what is called an error channel
that's the way I view this so in other
words this pipeline right off the bat
has two channels to work with you have a
data channel and you have a error
channel or you can say it is a right
channel and a left channel well as
things go really well
you are just transforming through the
data Channel or the right channel when
things really go bad you go to the error
Channel and you deal with it so by by
structure both completable futures and
promises are built with these two types
of channels this
more elegant in my opinion as a really
better way to handle it because it
promotes that model of let's deal with
things downstream so you give an
opportunity for transforming data but
you also given opportunity for
transforming errors as well one of the
ways in which this works is if things
are going well you keep marching on the
right side if things are not going well
you come to the left side and you're
dealing with an exception but if you're
able to handle the error you can go back
to the right side and so you can really
recover from errors as well and that
gives you a really nice way to handle it
but that unfortunately doesn't answer
our questions because a promise
literally is still zero our one piece of
data our completable future is a zero or
in piece of data so through a complete
one future you may have one data going
through our art none goes through but in
a stream you have n pieces of data that
go through so you're gonna have n pieces
of data that go through you cannot
obviously rely on promises to do it what
could we do this is where the observable
ideas begin to take a bit of a route so
observables are flows depending on what
you are using observers are flows really
are kind of like promises except that
they could be 0 too many pieces of data
so one of the things I really like about
observables is they do have a data
channel so just like what we had in the
other case they have a data channel they
also in addition have the error channel
as well but in addition to it they also
have a third channel which is our
completable a completed channel so the
completed channel is through which you
send a message saying I don't have any
more data so you can do your clean-up
operations but more important you have
this again the data channel an error
channel through the promises and
completable futures at most one data or
one error go through through the
observables on the other hand any number
of data may go through and of course if
something were to go wrong your error
channel will carry the error so you
treat error as data just another form of
data and so relying on some of these
structures gives the opportunity for us
to deal with errors downstream rather
than trying to disturb the call chain by
throwing exceptions so this is one of
the
I would sincerely think when I start
programming in functional style is we
think about my strategy on how I handle
with exceptions because fundamentally
throwing exceptions is really a it
doesn't make any sense in the world of
function of style of programming you
really want to deal with error as if
it's just another form of data and you
want to just push it downstream and
handle that so this is one of the places
where I normally start with streams on
my projects I enjoy streams and I use it
but when when my project becomes a
little bit more complex and we have to
deal with a fairly complex amount of
exceptions and errors that's when I
consider really looking at something
like a observable or flowable because
there's a really better answer in terms
of how we can continue using the flow of
data a stream of data but the data can
flow through downstream and we can
handle it and and so that is a
rethinking of how we want to handle the
exceptions so to summarize what we
talked about when it comes to functional
style of programming your language like
Java give us the ability to write
lambdas they give us the ability to
write streams but that's when the real
fun starts because we can't just walk in
and start doing from programming in
language like Java because there are
other constraints other things we have
to be really really careful about and
and unfortunately keep in mind as as
much as I love what job is doing as much
as the power it gives you it's the
language that will not protect you all
the way through when you're dealing with
in variables and mutability so you have
to take the personal responsibility to
make sure you're honoring immutability
where it makes sense you have to control
those things and you have to also take a
stab at dealing with things like
exception as well in in designing the
systems and the circular purity and the
and the ring of impurity may something
help you as well hope that was useful
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>