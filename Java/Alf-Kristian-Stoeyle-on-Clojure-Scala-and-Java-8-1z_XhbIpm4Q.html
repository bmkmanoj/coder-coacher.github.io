<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Alf Kristian Stoeyle on Clojure, Scala, and Java 8 | Coder Coacher - Coaching Coders</title><meta content="Alf Kristian Stoeyle on Clojure, Scala, and Java 8 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Alf Kristian Stoeyle on Clojure, Scala, and Java 8</b></h2><h5 class="post__date">2015-09-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1z_XhbIpm4Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">being live interviews all yesterday and
today and um you're not you're not
Martin
no your elf yes but we're gonna we're
gonna chat about something extremely
interesting at least I think so so let's
let's start about chatting about your
name you're probably faster at typing
your own name than I am well you don't
have I don't have the proper European
keyboard so and then um what are we
gonna talk about today I'll fill in the
other part so I would like to talk about
my talk which was experience leader in
closure Scala and Java whites and Java
nice nice and like I said in my talk
like actually saying that I have
experienced with Java 8 is sort of a lie
because I don't play with it
well I mean I think most most folks are
at the stage where they're converting or
doing things that Java 8 so you're
probably you're probably at least as
knowledgeable as your audience I should
hope so
yeah at least I do have experience with
both Scala and closure and know a fair
bit about functional programming so that
nice sort of the background for the talk
so yeah yeah so what's your what's your
experience been with Java a how do you
like lambdas streams API
I assume that's that's in the olan
coming so they they're I think the way
that it did it is is is pretty good what
I don't like about it is is that they
they sort of introduced this functional
thing and it's not really functional so
it's you have lambdas and that's great
and you have streams where you can can
manipulate your collections with lambdas
yeah but the data structures aren't
immutable and and it they're actually
lazy which is I think it's kind of weird
for a very site affecting language like
Java so yeah well I guess you could make
a case that the skeletons I mean they
have splits between immutable immutable
objects there's a lot of mutable coding
in Scala
so most
let's go call it experienced scholar
developers would not use the mutable
parts yeah you very much it's like very
very limited but it's very accessible
it's very easy to do
yeah and that's sort of been a complaint
with Scala for long time that you can
like to easy drop into to do immutable
stuff I think closer I've been done a
lot of closure if I think that force is
you more into it does a beautiful so you
really have to want to do stuff mutable
if you want yeah and and also if you do
so there are these built-in constructs
that you do it with and they are at
least they have strong thread semantics
so you you're not really it's not really
possible to do it incorrectly with
regards to concurrency and in that
respect you can of course get race
conditions to stuff like that but it's
not like threading issues that you get
with shared mutable states that you can
have in Java or you have all the time in
Java and sometimes in Scala
yeah yeah but I would say I don't know
I think lambdas are a step in the right
direction I think compared to where we
were with Java Java 7 and earlier I just
my wish is that they would have made
streams immutable and I don't know and
why they didn't but because I think they
actually made it was an effort to not
make them immutable it's not that so if
you have a stream and you call dot
parallel element and you actually change
the stream you don't get a new one yeah
and those kinds of things is coming from
a functional sort of background that
that's just weird why not just give you
a new witch because that allows a lot
more sharing of code and it gives you a
lot more flexibility on how you want to
to structure your code yeah so my take
on Java is that it's a really good
introduction to functional programming
so can sort of get a little bit more
more what it's about
and hopefully it will then make it
easier to to start looking at stuff like
Scala enclosure which which does this
stuff a lot better
yeah I mean they both have the advantage
that welcoming closures modeled after a
lisp yeah and it has those routes and
Scala was a ground ground-up effort it's
kind of MLS sure sure yeah but it takes
a lot of inspiration from ml and other
things and of course lots of inspiration
from Java as well yeah by me I think
it's a lot easier to do those things
when you start with a clean slate
whereas the the challenge the the JVM
team has is they they have to take an
existing language which they have to
maintain backwards compatibility with
and find subtle ways to introduce
paradigms which are better for parallel
programming sure sure so I think they I
think from those goals they've probably
done a really good job with with what
they were given because it's quite
challenging to start with you know Java
most Java programs are highly mutable
yes absolutely they are and and doing
computation with laziness when you have
a highly side affecting language I think
that can be interesting yeah so yeah I
think there are like subtle bugs that
you can run into and subtle like stuff
doesn't necessarily act the way you
expect sometimes and and are there any
examples of like weird glitchy things
you run into where you expected to
behave one way but because of the
immutability it don't get different
results so if you if you if you are
relying on side-effects happening and
you should of course never do that and
yeah in the stream computation but if
you do that and of course I think it's
called method handles you can just add
method handles pretty simply and those
things can do side effects and if you
sort of rely on that happening it's it's
fairly easy to do the incorrect thing so
I surely understand their trade-offs
here it's just it's just that I sort of
wished that they made it immutable and
and that maybe laziness
so within comparing Scala and closure
Scala actually took the the the stance
that stuff should be eager by default
mm-hmm and that's because it's Scala
doesn't prevent you from doing
side-effects
yes but they basically said that it's
it's it's easier easier to figure out
the result you if you have things be
eager because at the time you do it yeah
yeah closure has taken the other stance
that stuff should be lazy bolts but it's
immutable so it makes sense so it's
easier but of course you can do side
effects there as well there's nothing
preventing you from do that so you can
easily shoot yourself in the foot but
yeah it's a very different way of
thinking and since the closure is lazy
by default your mind is always thinking
about that and make sure you do the
right thing but yeah so in in Scala and
in Java you the general thing is that
it's not lazy it's younger but so Scala
introduced this I'm sorry you're jolly
introduced lazy streams now so that
blows your mind a little bit yeah okay
so what's your what's your go-to
language do you like doing a lot of
closure I do absolutely and so in my
talk I really wanted to focus on that
these there isn't a better language
they're both great languages they have
different trade-offs they have different
backgrounds and and like setting them up
against each other is is is sort of
unfair because well they both sort of
embrace or this both embrace functional
programming but in different ways and
apart from that they are really
different and saying that one is better
than the other becomes incorrect in my
in my view at least and and so if since
I have more experience with Scala for
real and my go-to language would
probably be closure because just to get
even more organs yeah right now I'm
coding Scala every day so
but if I were to choose one of the
languages for for my team for a project
basically that will be up to the team
what they would prefer not not my
preferences I like them both yes I did a
big DSL for JavaFX and in Scala and that
that level of kind of language
manipulation wouldn't have been possible
in in Java simply because of the rigid
syntax lack of operator overloading
inability to like do which might call it
type type well the whole Scala type
system is beautiful this yeah it's also
some would say that it's too complex
I believe the Scala type system is in
itself a turing-complete but of course
since Scala builds very much on Java it
actually has to take into all of all of
these Java types as well and that
actually in itself builds a lot of
complexity for instance in it needs to
deal with nulls everywhere and and that
complicates things but we rely on tips
as well sorry primitives as well yes
which appear object oriented language
wouldn't have to deal with now yeah yeah
okay that's a good I think it's a good
comparison so I mean for folks who who
are just getting introduced to
functional programming you'd recommend
they pick up maybe closure Scala kind of
get a more some more pure yeah
absolutely absolutely and but there are
there's only my talk I talked about the
there are different learning curves for
these languages and yeah that's kind of
important to know with Scala it's I
would say for at least for Java devs
it's really easy to get started because
you can you can very much program like
you do in Java in Scala
so all they need to do is sort of figure
out the good syntax and then you're good
to go yeah although it perhaps you're
not taking full advantage absolutely not
so when you start to get into it there
are there are like really steep hills to
climb because there are a lot of quite
abstract concepts that you need to
figure out and to start to take a whole
potential of the line
but it's it's something which is pretty
easy to get started with closure on the
other hand is at least for people that
don't have Lisp backgrounds it's it's
very oh yeah the parentheses gotta get
to me when I need color coding for my
friends disease to figure out what level
I'm at that's actually sometimes there
are fewer parentheses in closure than
there is in Java so it's just that you
have that one very well fewer fewer but
higher levels of nesting
sure and and I think the nesting is
probably even like a bigger problem and
and and also the fact that you need to
like keep your friends balanced all the
time yeah and then you need to have an
editor to help you do that it's required
yes but so the parentheses they that
that's what most people complain about
when starting out but after a very short
while you stop seeing them yeah I mean
that's just initial syntactic but yes I
also I experimented with doing a DSL
enclosure for the same thing and
actually it turned out you didn't
actually need to do as much as you do in
Scala to build that up with the macro
system and everything you could actually
do it very simply and elegantly
enclosure you can put lots of
parentheses you know is write the macro
to remove them if you want yeah it's
there are there many things that you can
do well but the learning curve for
closure is really steep when you start
and it like becomes not that hard and
then maybe you run into meta programming
with macro which is steep but then it's
it's yeah I think it's easier once you
get started so Scala has a easy way to
get in closure does not but Scala has
like steeper yeah it's you once you hit
some of the complicated things would
type inferencing and the type system and
all that stuff then you just yeah yeah
absolutely it's complicated okay
cool now this is a good introduction of
closure Scala Java it is interesting to
hear like a fresh perspective on the
Java eight lazy mutable data structure
yeah
cool thanks very much sure elf it was
good chatting with you for folks
watching the livestream you can watch
the recordings or also the livestream at
night hacking comm interact with us on
Twitter tweeting to hash tag night
hacking and thanks for our live audience
here great to have folks chatting with
us and interacting thanks yep thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>