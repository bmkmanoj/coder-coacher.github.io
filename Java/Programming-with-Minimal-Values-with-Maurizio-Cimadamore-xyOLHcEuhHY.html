<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Programming with Minimal Values with Maurizio Cimadamore | Coder Coacher - Coaching Coders</title><meta content="Programming with Minimal Values with Maurizio Cimadamore - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java/">Java</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Programming with Minimal Values with Maurizio Cimadamore</b></h2><h5 class="post__date">2017-07-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xyOLHcEuhHY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Amarista I work for the compiler team in
Oracle and the store today is going to
be about minimum value types I like to
think of minimal value types as an
intermediate point in our journey called
Balala and logistically there are going
to be two talks about minimum value
types one is the one I'm doing today
which is more about the origins of me a
minimum value types where do they come
from and what the programming model
looks like then there's going to be
another talk on Wednesday by Frederick
and yon and this is a much deeper talk
in the sense that it's going to explore
what it means to add value types in
enough protein in j9 so what it means to
add a value type support in an existing
VM so as usual we're going to need a
word from our sponsors because that's
but please don't rush him buy your
products based on the ocean contents of
these lives and as I was saying I think
of this as a journey we started three
years ago
the goal was adding value types to the
Java language and we did this for two
reason or at least who works project
exploring the space for two reason one
was to allow the VM to efficiently
allocate data structures in a way that
was free of interaction so to achieve
flatness and more denseness and density
and also to remove one of the nastier
nastiest scenes in the language which is
basically the distinction between
primitive types and reference types so
by adding values our our dream is to
unify references with primitives and the
motto for value types is it causes a
class and works as an int which is a
good motto but this also gives us some
understanding of how things should work
when you start using values so I stole
this from Brian of lights from last year
so that's what the object layout looks
like today of course you're familiar
with it so if you have a podium like a
class point which you field and you want
to create an array
and then you store four points inside
the array you get an adder for the array
and then each element of the array is
going to point to a different location
in the Java and in each location there
will be another object with is with its
own header so the problem with this
layout is that locality wise is not
great the objects are going to spread to
to be spread all over deep and it's very
likely that you're always not going to
feed a processor cache line so if you
try to traverse the elements of the
array performance is going to hurt the
layout we want with Balala and we hope
to achieve that by simply adding the
value keywords on top of the class point
is to ever basically an array with all
the x and y coordinates nicely flattened
inside the same object so a single
letter and all the coordinates in place
why do we have all these pointers and
all this indirection
well it's a little bit of a tricky
questions I'll try to answer as best as
I can in this life the the root of all
the problems is caused by object
identity and the meaning of identity
comes from a leading word identity it
identity is a concept that defines
basically what the what defines and what
an entity is and what it means for an
idea for an entity to be what it is and
if you think about cars like everybody
everybody likes cars we can have to cast
same brand same make same color same
license numbers but I can see I can
still see them as two different cars I
can reason them as being two different
things and the same is true for objects
in Java so I can absorb this they can
have the same values in the field they
can appear equals but I can still have
ways to poke at them and reveal the fact
that they're different objects
I will object identity implemented in a
VM
well using memory addresses which means
two objects are the same if they'll
store in the same memory spot and since
we are using addresses to encode
identity that means as well we are
basically back to pointers in in
directions of course the just-in-time
compiler can sometime Elsa it can remove
the interaction it can remove the IMP a
location but only if it can prove that
we are not using identity outside day
lining context we're in so there's some
escape analysis going on in the so
called colorization optimization and if
everything is well you don't get any
publication at all and the GC is the
spine but if you're using identity or
the digit suspects you may be using
identity in some other place then you're
not good and your performance is gonna
be bad so the big question here is what
if I don't need identity what if I
program in such a way that the identity
is not needed and speaking about not
needing identity in the decade we added
this concept of value based classes so
there are some classes within G in the
DAT book like optional local date/time
which are simple data carrier and this
class is our symbol and they are meant
to be used in a simple way so you
shouldn't rely on identity when
operating on those classes you shouldn't
lock or notify on such classes you
shouldn't rely on reference equality and
this restriction are meant to be used as
a way for us to say well maybe today
they look like ordinary classes but
maybe tomorrow we can start handling
them even in a more efficient fashion
and that's basically our ramping up the
story for value types because
essentially this is what value types are
value types are just a glorified version
of value based classes value based class
is just a-- the commentation contract it
doesn't mean anything the VM cannot just
optimize based on that
but if we introduce a new construct
which is basically our restricted subset
of all the things we basically leave out
all the things we don't want from
regular classes and we we get to a core
which the VM can then optimize
efficiently and reliably then we get to
a very good place
the problem with identity is that it's
like one of those invasive species so
it's a very nd hook on which to hang all
sort of internal state GC beats runtime
class of an object locking information
was not so if we dropped out identity or
if we give people freedom to opt out of
identity guess what
other things will not work anymore
polymorphism is gonna suffer null
ability is gonna suffer you can tell me
the ability of course because basically
identity is essentially there to support
MIT ability in a way so we are going to
lose all these other features as well
but we have a good programming model
that we think is gonna give us decent
performances and that's kind of how we
approach this problem we have this
mighty beast that we are trying to slay
and we think goodbye value types are
going to provide us the sword that may
slay the Beast once and for all reality
turns out to be a little bit more
complex as we shall see in the next few
slides the first problem you encounter
when we you add values on top of the
java language is a problem of table
types so in Java every reference type as
a top type traveling object and you can
pass references around when an object is
respected no problem what about
primitives primitives don't have a top
type right and by extension since values
works as an int values don't have a top
type either so how do I write code that
works on both references and values and
the trick here is that well I could use
object but
we'll introduce boxing so I want to be
able to express a routine that works on
anything without boxing that's the
challenge and they may also want to
express a routine that works on anybody
without references and also on some
subset of buttons so maybe only the
values that are comparable so we think a
solution is going to be to allow values
implement interfaces as I said in the
previous slide values are not allowed to
subclass but with interfaces we could
kind of make up for it and we can have a
story for providing and injecting these
top types in the object hierarchy so
because there may be an interface on top
of object and we could have an interface
on top of all the values the problem
then becomes a migration problem as I
will be talking about in a few seconds
I'll do we reinterpret all the existing
code that is expressed in terms of
objects to work in terms of this new top
tile and that's a big challenge generics
is another big challenge generics are
implemented in term of arranger which
means all the type information is
basically thrown away during compilation
so when the VM gets at loading a class
doesn't know anything about generics at
all that works fine is actually if
you're working on references it's
actually nice because nice because you
get a lot of code sharing but with
primitives again we are in a bad spot
because there's no way for you to share
the same representation that works for
us straining to make it work for a
primitive type such as int okay yes you
can work on a list of integer if you
wanted to store int but as I writing
this line the primitives plus generics
equal boxing basically to store this ins
inside an a list of integers you need to
store to to box it on the way in because
the underlying array if you have an
array list is going to be an object
array so there's no way around it you
need to box on the way in and unbox on
the wheel
with values they work as an in again you
will get the same issues so values and
generics don't play well together we
think a solution is going to be generic
specialization so having different
runtime representation for primitive
list of in and reference with a
parameterization such as a list of
string of course types of specialization
is a problem worth its own told I'm only
going to touch upon few problems in this
slide the first problem is that you're
going to need a complete byte code
overall because well generics are not
expressing the byte code today so we
need a way to encode type information
generic type information in the constant
pool in some form because the VM is
going to need to inspect that there are
also a lot of my code of symmetries if
you think about that
there the opcodes are dependent a lot of
pop codes depends on the carrier types
that you are operating on and certain
operations such as comparison are
expressed in different ways depending on
which carrier you are operating on and
that's going to hurt big time if you
want to reuse the same class across
primitives and references another
problem is that we will have specialized
I variables and it is very likely the
specialized type variable Algor are
going to add their own set of hope codes
so those those will need to be added to
for example to do comparison then
there's all the language the language
side of the problem which is how do we
express the commonality between
different special specialized lists so I
have a list of int a list of string I'll
do a write a method that can take both
do I use a white card here yes we think
there's a story but we have not run the
percent sure that we can see the light
at the end of the tunnel and as Karen
was mentioning earlier access check
becomes a problem as well when you have
different runtime classes because if I
am inside a list of string and I want to
access a private field on a list of int
is that allowed
if yes well the VN for the VM they are
just two different classes so does that
work we think nest mate is going to give
us an answer there and also statics we
know what the static field is today a
static field is shared across all
instances of the same class but if there
are different runtime class for list
what does that it means does it mean
shared across all the lists or only
shared across a list of ink and those
are big problems and I haven't even
started talking about migration yet
right that's our favorite subject of
course Java is an existing language we
would like to for people to be able to
exist to to use those features on top of
the existing code that they have already
written and that means for example if
you have a value based class you would
like to be able to turn that value based
class into a full value type we think we
have a goodbye foot trick up our sleeve
here so we could use the cue letter to
denote the value Ness so Q local date
time means the value l local day time
could mean the box version so in this
way we can preserve some form of binary
compatibility but the source
compatibility part of the story is still
problematic because value based classes
are knowable value types are not how do
we do that you know can we specialize
existing collections that would be nice
everywhere everybody would love to be
able to write a list of in for real
well the death of course is problematic
both from my bytecode perspective and
from a source perspective because we
already had a class file with a
descriptor like L list what does the
descriptor mean in this new specialized
word does it mean reference list or
doesn't mean any list and at the same
time at the source code level if you
have a list or a list or a list of
question mark what does it mean does it
mean that if I reckon pilot it will
chain
semantics to the band and API are going
to be problematic too because if you
look into a collection there are a lot
of methods that basically rely on the
assumption that those collection are
working on objects so the primary
example for this is map get with
regulations that you can return now if
there is no mapping for your key now if
your map is storing values no now so how
do you do that yeah well you will need a
a signature that says optional and so we
need some way for people to migrate away
from bed signatures and that's how we do
that is still an open question we think
we have you good ideas but we are still
not sure about the answer so as you can
see it's a complicated process to add
value types to the language and so forth
we think it's basically time for a
reality check we've been exploring this
design stage for three years I think one
thing that I can say is that we are more
sure now than ever that the direction of
bilal is actually the good direction
there is a lot of demand for value types
we have seen vector api all the interest
on vector api panama GPU experiments big
data all this thing are asking basically
the same question how do I handle a lot
of data without too much need GC
pressure essentially under the end
though adding value types job is a lot
of work it basically requires a complete
redesign of the platform from the
compiler to the hot spot compiler
runtime compiler optimization ecosystem
byte code libraries and even programming
model in a way so the programmers will
have to think in a different way for a
certain extent so it will realistically
take several releases for us to get
there so does it mean that we don't do
anything in the meantime or maybe we do
something smaller so that people can get
started with this new programming model
and they get a feel for it
maybe they report back about what their
experience
experience actually is so let's go back
in to 2009 let's rewind the clock a
little bit on 2009 there was a big
discussion in the 292 actor group for
invokedynamic
and the discussion was revolving around
what is the role that invoke dynamic
should play in a Java programming
language should there be support for a
more dynamic in Java or not and I know
that Remy was was a strong supporter of
I want invokedynamic in Java of the camp
and one idea that I remember vividly
from the time was basically a proposal
to add a fake interface call
invokedynamic
without too much fantasy if you will and
whenever you call the method on this
fake interface Java C will say no no you
don't really want to call a method on
this interface what you want is a
network dynamically generated more
dynamic for you with a particular name
and those arguments and that was fine
for a prototype really but it had two
problems one is that it was it was a
stylistic problem really it was using
the generic syntax to encode the return
type of both dynamic and it kind of gave
the false impression that you had
primitives in genetics even though you
didn't the second problem which was far
more serious was that as soon as we are
the static arguments in a nimble
dynamical side then the Java syntax fell
apart right there's no way for you to
encode two different argument lists in
the same method call in Java so okay
scratch that we abandon the approach and
we said okay what about we make in what
dynamic a VM only feature
maybe Java developers don't care at all
about important enough or maybe they do
but not as badly as being developers and
in fact I think we were right because
that gave immediately something to play
with for people like Charlie that wanted
to write a better - Robi runtime and it
also gave us a way to implement better
runtime support for lambdas insyndicate
Nasr on other things started because of
the decision
and inside it was the right call to make
at the time that doesn't mean that we
don't care about Java as we've seen this
morning we have plans to add
invokedynamic to Java but not just at
that particular time we did make some
few cosmetic changes to the language so
we have the support for the polymorphic
signature methods but since those
methods are not really you can define
them outside the GDK so most people
didn't really care about those or didn't
even notice that we were making those
changes so in retrospect I think the
coupling the VM changes from language
changes was a winning move and so can we
learn something from it and I think we
can and that's the idea that John had
last year after repeated restaurant ugly
asking for some kind of support for
value types and the goal is basically to
double down on the approach let's change
the VM first and let's add the language
follow later but okay if I want the
values in the VM but I can declare them
in the language of the a comma is
supposed to even create a value so the
idea is that we let the VM derive a
value type from an existing ordinary
Java class declaration so you rank your
folder which is very similar to the one
I shown you before and when the VM loads
it it will magically generate a value
type for you
okay but then you have to operate on
these values and how do you do that if
you don't have language support well two
ways both indirect one is to spin my
code because the VM will provide you
extra bytecode to operate on values and
the second is to use metal banners and
that's really all there is to it so just
to make a comparison of what the
different programming models are here in
valhalla when you have a value class the
source for a value class which is
denoted as we see here you compile it
with the balala compiler and you get a
class write for that value declaration
then when the VM loads it it gets the
runtime class for that particular value
declaration
with minimal value types the picture is
a little bit more convoluted so you
start with the VCC which means value
capable class that's the terminology we
are using you compile it with the
vanilla Java compiler so you don't
require any language modification you
just compile if you get a class fine but
since there was an annotation on that
value capable class you know what the VM
will load it by the time it will load
that class file it will also spin this
magic derived value class for us and
that's really the interesting part of
MVT of course I'm not here to propose
that this is the language I want people
to write in ten years from now this is
just an intermediate step in the road
that basically should lead us to
Valhalla and full value types in the
programming language so this is just
everything that you see in the following
is life is going to be temporary and
mostly a means for people to get started
with values so here's our view the clear
a value capable class as you can see is
a very simple puzzle a class point two
fields x and y and the important thing
is that you must put some notation the
notation is called value capable class
because while it's a valuable class and
there are some restriction on value
capable classes which are similar to the
one we have seen for value based classes
so they should be final the fields must
be final other than that they are just
regular classes so they can have
constructors and they can have methods
the restrictions are not actually
enforced by the compiler because there's
no compiler does no language change but
in the Valhalla prototype as we shall
see later there are some options that
you can turn on in order to tell the
compiler to actually verify those
restrictions so that you don't get embed
places when the VM loads the value
capable class it will spin something
like this a new class file you can see
it's name is pointing dollar value the
name is not specified anywhere it could
be anything
and the important thing the first
important thing to notice here that is
that the minor version is set to one and
this is really what tells they be end to
basically unleash all the value type
magic so that we can start using the new
opcodes the new concept we'll entry
mangling and all that's associated with
battles in fact as you see here these
classes be marked with a CC value to say
that this is actually a true value there
is a super tag that has been injected by
the VM it's a super type it is common to
values it's something that is a little
bit of a knack at the moment it is any
for the interpreter is not terribly
important and it's actually outside the
spec I think at the moment and as you
can see one magic thing of Athens here
there's only fields here which means
this the right value is really just a
struct you have only fields in there all
the Constructors and the methods have
been dropped by Divya
this will lead some limitations we shall
see and then you can also notice that
there's some name mangling going on so
there's this class field of the bytecode
is pointing to something that says so
semicolon cue point dollar value and
this is basically required because the
verifier needs to know whether it's so
creating on an entry that contains a
value versus an entry that contains just
plain reference class and speaking about
closing for a closing for have quite a
bit of overloading going on at the
moment because they are used both to
represent class files and to represent
types so for example if you take the
inner classes attribute the class info
in there is used to denote a
electrically enclosing notion which is
pertain to class files but if you look
at the instruction such as get filled
check out instance of those instruction
all speak about classes in terms of
types this will work well if your class
file and types have a one-to-one mapping
between them it's kind of
same as we discussed last year with
reflection but if you start having
features that produce multiple runtime
representation from a single class file
then you run get the problem because you
have an ambiguity what does your custom
for me does it mean the Box version the
reference version does it mean the class
file so longer term of course we would
like to tease apart those relationships
and we would like to come up with
different class file
sorry constant pool entries for
representing a class file versus the
type but of course shorter term is
minimal value type the number one goal
is to be pragmatic so we just resorted
to some a key name mangling scheme
working with what values reminds me of
the plateau allegory is key because well
values belong to the vm world the user
never see them and to operate on values
well it has to operate them through
shadows either a methylene or some micro
spinning but the interaction is never
direct so if you choose to go down the
bytecode way you get some new op codes
from the vm opcode for doing that a
movement of course you need to be able
to load store return a value there are
some opcodes to do a field update on
values you may ask what about reading a
field well that I will get to that later
then you can construct a value you can
do array access of course and then you
can do box and box and that's very
important you need to be able to go back
and forth between the value
representation in the reference
representation of value so a on top of
new op codes you also get some
overwritten existing upwards so get
field has been given a new semantics so
if you get field is pointing to a value
class in for entry sorry to our field
reference entry whose owner is a calcium
for that user value then it will behave
as a value get field and the same is
true for a new array multi knee array
maybe plan to support also other
operation but not now so check out maybe
make sense maybe not as I said before Q
denotes value Ness so whenever you see a
cube either in a type descriptor or in a
class info that means it's a t-top
really gonna value designing the OP code
set for values is not an easy feat
because there are a lot of constraints
first of all there are not many of God's
lots left in the BM secondly the code
size is important so different choices
in how you express operation is going to
affect the size of the code generated
majority third if you get too smart and
try to reduce existing of course you
know what the V I mean complexity is
going to increase or maybe the verifier
context is going to increase and we
don't know what that we don't want that
either so as an example if you have a no
code that already takes a constant
program such as gate field you have
basically two choices you can introduce
a new opcode called V gate field to stay
that is operating on value or you can
just reuse an existing approach such as
gate field and exploit the fact that the
constant pole enter is going to reveal
the difference and we choose the latter
approach volatilization up a bit if
however your opcode is not taking any
constant pole entry such as we load well
a lot instructions Pro matically doesn't
have a constant plenty so how the heck
am I going to extend it well I can again
either add an instruction reload or I
can and Brian abuse great idea with hold
ever prefix up code called type that
will point maybe to some constant pool
entry and it will as an effect basically
update the type state of the VM so that
the following instruction will execute
as if and operating on a value so even
though the following instruction here is
saying any load since there was a type
before I know that it's going to operate
on a value we think that at the moment
the complexity of the type the inst
action is not work because we are only
operating on values but we think that
with the feature such a specialization
type can come back very handy because
what we care about with the
specialization is to be able to have a
single class file that can represent the
operation for both primitives and values
and references so having a way to also
parameterize the data movement operation
seems like an easy fit so in sama how do
we work with values well the short
answer is with good method endles the
long answer is that basically you need
to retrieve an instance of the value
type class this valid type you should
think of it as the equivalent of a
method endows / method and also to look
up so it's what gives you a lot of
factories for constructing method and
OHSAS operate on values and once you get
those metal handles you can combine them
using the standard Combinator API and
one important thing about the children
to support for minimal value types is
that boxing and unboxing adaptation has
been added as part of the standard
method and adaptation which means if you
are using an invoke or an involved with
arguments those boxing unboxing will be
performed by default rather on time so
you can go back and forth between the
value type and the box representation
this is the table that shows you that
basically whatever operation you can do
at the bytecode level is also available
in terms of some method and low in the
value type class so consider the second
row for example get field yes you have
to get filled up code that can operate
on a value but you also have defined
getter method and all that you can
basically retrieve from the value type
class and that's basically one method
and for each operation that you can
think of in the Bible of course this
analogy at one point is going to break
out because there are operation that are
just to fine grain to be expressed as
method endows and those are the
autonomic operation and conversely there
are operation there are to a level so if
I want to do a food
persons who values it makes sense to
have a map lender for that but it
doesn't make a lot of sense to have an
alt code for for expressing that or
maybe it does but we we don't know that
yet so how do you create a value to
answer that question I want first us to
focus on how do we create objects so you
create objects typically by calling by
using the new opcode and that's gonna
create an elysian uninitialized object
and to put that on the stack what I mean
by an initializer object well it does
not this but the verifier keeps track of
the state and thinks it's uninitialized
so there is this sticky bit in the
verifier that says oh I can't really
trust this out there for now then an
inbox special happens the constructor is
called the constructor we'll do some put
filled in in the middle will initialize
one of the fields of the object and then
the constructor returns and by design
the constructor returns the verifier
we'll know okay
now the object is initialize there are
two problems with this model one is that
this model is based on mutation so you
need a lot of good fields to initialize
the contents of an object but the second
and most important problem is that those
an initialized object can escape the
context of the constructor Java
developers are always surprised to find
out that uninitialized object can
actually leak outside the constructor
maybe through exceptions so this is not
a model that we would like to expose for
values for values what we'd like to have
is something more stable where we start
off with what we call a default value
which is really a value of the right
width with all zeros inside that's the
default value and starting with that you
basically update one field at a time but
this update operation is not a mutation
based update example it's an update that
takes an existing value update a field
and gives you a new value with the
data's field and we call this wizard so
you start with the default you apply a
bunch of wizards and you end up with
your
and the good thing about this is I
haven't used mutability anywhere and
there's no need to track and initialize
things around so there's no such thing
as an initialized value anywhere so I
think we've improved the model
significantly how do you create a value
by spinning by code this is what the
byte code actually looks like so you
start off with an opcode V default be
the fourth is actually what tells they'd
be able to give you the default value
for that particular type in this case
pointing dollar value which is the the
derive value class the DBMS generated
then you store a bunch of coordinates
inside the point for x and y with a
bunch of B with field so be with field
if the O code that you need to update
fields of a value and then you can be
returned and that's how you do it
if you want to use Java well if the
situation is a little bit more
convoluted because you need to use meta
Venice but it's still manageable first
off most importantly you need to
retrieve an instance of the value type
class and you can do that starting from
the value capable class so you pass the
Java line class for that then you obtain
a value type and then you can start
asking this value type the method endl
for the default value the wizard and
then you can combine them all together
to form the factory that you want to get
here so you want to make Lendl that
takes a bunch of coordinates and gives
you a point with for those core games
and you can use those the regular method
angle Combinator API for this lambda
forms that's a tricky problem as you
know materials are compiled down to on
the forms which is good because it means
that different method endles
can share the same underlying
representation but the way this is done
is through erasure once again which
means the debt limit renders the
signature of sorry the signature of
lambda forms don't make any distinction
between whether
are operating on an inn or on a train
versus a runnable they are all the same
line of London Fog can be used so the
question now is what should we do for
value types should we arrange value
types or should we not when we deal with
run the forms if we don't raise value
types then we are back to the original
problem with method endows that
basically we have a lot of bikers
preening going around but if we do a
race value ties what do we erase them -
if we use object we are basically doing
boxing if so we need some other type and
we think that right now the type we are
using right now is the underscore
underscore value which is the special
super type that all values know about
but this is of course an active solution
we think a more and better longer term
solution should be to use the so called
Universal type that I'm going to talk to
you about in a moment
I'll do you call methods on values well
in Molalla that's easy
there is an opcode that is called invoke
direct which allows you to take a value
in column ethel in it this awkward is
particularly magic because if you are
calling a method that is defining some
interface because it's a default method
it will also do some boxing
transparently but in minimum value types
there is no such thing as a method on a
value as we have seen the VM will
basically prune away all the metals and
constructors so how do you call a method
on a value well easy.you box and then
you call the method on the box it's of
course not great but one one good thing
about this boxing is that this is not a
while it's still create a Java object a
regulars about the non deep the C to
compile ur and the cheat in general is
way freer to optimize the way this kind
of boxing because you know that the
identity that is being introduced here
is completely accidental
so this is our you : method on a value
you first load the value using B load
then you do B box and then you just want
to appear from that just works I'm not
showing the code with method endles
because it's just silly because we
method and
of the VBox happens from sparingly so
you just need to retrieve the the method
vendor that does the the call that you
want you just pass the value in the
boxing will happen so as your as we have
seen so far basically boxing boxes
classes and values are just separate
classes in minimum value types the only
thing they have in common is this box
and unbox op code that allows them to go
back and forth between one and the other
longer-term we would like to have a more
fluid notion where basically both the
box and the value class can be the
finest projection of some common entity
and that's an idea that John ate about
attaching to each type a mold so we
already know about the cue mode which
means value we already know about al
mode which means reference but there we
think also a third the interesting mode
which is called u where u stands for
union or universal it's basically a
karyotype a new karyotype that basically
can be used to store both a value or its
box and the cool thing about a you is
that when you store a reference type
inside the U it's a boxing that
preserves the identity so when you get
back the reference object you get back
the same identity that you started with
and another cool fact is that when you
store a value inside that you don't need
boxing because U is big enough to also
encode values underneath so you don't
need to allocate all seven-league we
think that this is going to be a very
important instrument for our experiment
first for lambda forms because U is a
natural array type for values in lambda
forms and secondly because it will give
us a way to express things such as code
that needs to work polymorphically on
primitives and references in thai
specialization so we think with you ties
we have a way to O bright
the method body once and for all and
then to let it run both on primitives
and on references of course you can do
also more complex code in Molalla you
can for example take an array of points
and maybe you want to compute the sum of
all the norms of these points and if you
have values in the language that's easy
you just write a for loop or maybe a
stream and the reduce reduce operation
whatever you prefer but what if you
don't have values in the language well
this is starting to look ugly doesn't it
I mean we can still see what's going on
we need a for loop Combinator and there
are many pieces that goes in there but
it took me an hour to put this light
together and make sure that the example
actually worked because there are a lot
of types that are just dynamically in
present there's no support for I mean
the compiler doesn't check that what
you're writing is actually correct and
maybe spinning bytecode could be a
better option when you need to generate
more complex code but at the same time
first you need some good tool chain
support for value type so I asked Raimi
please give us some support for lassen
for working with values but secondly
it's still a dynamic approach so by the
time you're writing your code you have
no confidence that this code is
verifying or it's even doing what you
thought it was doing in the first place
so the lesson here is that minimum value
type is a point in our journey is not
the destination of course the
destination is to have a full
programming model with values in it and
that will give you all the benefits of
having better layout for data structures
and also having programmers a better way
to express the constraints that they
want MVT is basically a way for us to
give you guys something that you can
play with and report back some
experience on what you think about the
value support in a JVM so speaking about
what's there now
so first well basically we are looking
to ship MBT as an experimental feature
as an experiment of the end feature so
we will probably adopt a model which is
close the incubator model described in
JP lemon so there will be a so-called
value capable models and the set of
value capable models can be expanded
through a set of JVM incantation flags
there is going to be a stack addendum
for value types and the delivery former
for the fiscal DVD but we do have aspect
thanks then for putting that together so
we do have a full spec for values and
that's a really important piece and we
also do have a prototype that 99%
matches what the spec says that there
are some difference with the ordering of
cross loading but that those are all
details the eye order this is the
rewards and you can write all the
examples that I shown you in the slides
and they just work and they actually get
good performances too we had some
preliminary benchmark and the results
are looking very interesting so far the
supporting this prototype includes full
runtime interpreter support but there's
also a JIT optimization in place only
for the CE to compile and only for the
linguist x64 platform there is also
support for the method and runtime and
all the combinators methods have been
adapted to also work on value types and
there's also an experimental extension
to the Java C that allows you both to
generate a value types directly that's
useful for testing and also to enforce
extra checks when you declare a value
capable class if you want to be extra
sure that you are actually doing the
right things of course I only suggest
that you go out there you practice and
you try to write whatever that you have
right now using the MBT and report back
on what your experiences this is kind of
team that I had the pleasure to work
with or the last year
as you can see those are pretty there's
a lot of smart people in here so it's
been an honor for me to work with them
and that's the last light I have so
thank you for your attention</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>