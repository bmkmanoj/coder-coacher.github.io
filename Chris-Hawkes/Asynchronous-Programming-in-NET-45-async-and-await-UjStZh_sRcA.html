<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Asynchronous Programming in .NET 4.5 (async and await) | Coder Coacher - Coaching Coders</title><meta content="Asynchronous Programming in .NET 4.5 (async and await) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Chris-Hawkes/">Chris Hawkes</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Asynchronous Programming in .NET 4.5 (async and await)</b></h2><h5 class="post__date">2015-09-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UjStZh_sRcA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey guys what's up so in this tutorial
video I want to give you a quick
introduction to a synchronous a sync in
a way in c-sharp 5.0 and it's a feature
that uses essentially tasks to fire off
tasks and each task is an ax synchronous
call which needs to have a synchronous
tag on the actual method signature and
within within that method of every a
synchronous task you should always have
in a wait statement that is actually
awaiting some sort of long-running
process some sort of new execution that
way you can run multiple tasks
simultaneously in each one of those
tasks will end up having some sort of an
a weight that they can be waiting on but
it allows multiple multiple program
functionality to be you know executed
simultaneously so it's a concurrent
parallelism type of programming paradigm
that is much easier to do than the old
school background workers and spinning
up new threads that you people used to
have to do and C sharp and other
languages so let me go ahead and show
you a console application here to give a
demonstration and here is just a simple
console app that is spun up by Visual
Studio when you create a new project I'm
gonna go ahead and create a method
called my method a sync and it's going
to use the special keyboard the asynch
keyword and it's gonna be a task method
so the way I would do that is a public
static and has to be static because it's
a console app so static method calling
another static method and I'll say a
sync and that's the keyboard that I was
talking about and this is just gonna be
a task and then I'm gonna call it my
method a sync and typically any time
you're writing in a synchronous method
it should carry the asynch keyword it's
just by convention it's not something
that's mandatory but it's something that
you should probably get in the habit to
do because other people might get mad so
let's run just do a console.writeline in
here and this is where we're gonna say
our sync math
has started and then under here what I
actually want to do is I'm doing a wait
see because before I give you a wait
you're gonna notice that visual studio
is complaining that there is no wait so
it's just gonna be run synchronously so
like your base or synchronously I'm
sorry so it's not going to do anything
special there so a waiting is the
keyboard that it's looking for so what
we can do is um before we even do the
wait let's go ahead and we're going to
end up waiting a new task that's gonna
be called and we'll just call this
method our counter so this is gonna be
another cast method so let's go ahead
and say a public static a sync task and
we'll call this counter and this is
going to take an integer number to count
to alright so that'll tell you passing
an integer to that and we'll go ahead
and just do a console break line so we
can see where we are in the execution
and we'll say we're now running the
count method and really I don't even
know why I'm calling a count method
because I'm not I don't plan on making
it count to anything what I'm gonna do
is actually have it a wait and it's
gonna just use the keyword task and then
delay and then this is um we're gonna go
ahead and just say number account to
which is the variable that got passed
into the method times 1000 since it's
milliseconds so wait a stelae so now
this doesn't complain anymore it's in a
synchronous synchronous method that has
in a wait statement in it so it's
satisfying everything that c-sharp
thinks that it should do so now let's go
ahead and call this method from up here
so to satisfy this complaint we can now
say a wait counter and then pass in
something like 8,000 or no about 8,000
that would be way too big so we'll do
eight because it's gonna be eight
milliseconds in fact that's going to be
too much too
so we'll do five so they don't end up
calling this method a synchronously and
just after the await statement let's go
ahead and give it something that says
console.writeline
dang it and we'll say execution has
completed so now obviously in our main
we're not even calling anything that the
program wouldn't do anything so what I
want to do is actually create a public
pool at the top of this program so it
needs to be static on once again like
everything else and we're just gonna
call it a start or stop and we'll say it
equals true by default okay and then
let's go ahead and run our let me think
here now one of the things with c-sharp
is your static main method cannot be a
synchronous so what I'm actually gonna
do is create a new method down here and
this is kind of hacker she wouldn't
really do this in real life well this is
just as an example but I'm gonna create
a start method so I'll say public static
and this will be synch I think - and
I'll say void start so it's like a
return anything and then start is
actually gonna be we'll do a quick
message here console dot write line will
say this is our stuff to do before a
long-running process and then you guys
can't see that very well and now we're
gonna go ahead and doing a weight on the
my method of sync and then start or main
needs to call start so we're gonna call
start here and then I don't want the
program to just exit immediately after
running so I want to do it just a simple
while statement it's a while start or
stop and does nothing and then I also
want to do a console dot read line so
that way I have to press a button before
the program executes or disbands and
I'll show you why and
so anyway I'm just to recap we have the
start method which is like I said it's a
hackish thing it's a synchronous method
it's gonna be called synchronously so
there's not going to be any sort of a
wait because you know Maine is not an a
synchronous method so it'll call start
and start isn't a synchronous method so
this will immediately execute it and
then it's going to wait for this so that
means it calls this this will
immediately execute this will then wait
for this method so then you should see
this message appear then you're going to
get the delay then it's going to come
back and it's going to print this last
so if everything goes well based on the
execution of our program and the fact
that we have simultaneous things going
on at the same time certain things that
are being awaited for and then your
subsequent calls and things like that so
the way everything is set up here this
should be the last message unless I'm
looking at this wrong so let's go ahead
and run the program and you can see that
this is the stuff to do before the
long-running process our sync method has
started and we're now running the count
method execution has completed so see
now if I hit a no actually no it's well
true I don't have anything to kill the
program but you can see that what I said
was accurate that the last statement
that got printed to the screen was
execution has completed so really this
whole sync thing is a little bit
confusing a sync method should be tasks
and the tasks they can return values
like I can have this if I wanted to sync
to return an int I would return it that
way
and obviously it's going to complain
that there's no returning in but I could
say return one and now it's satisfied so
this could be a task that does a bunch
of crap and returns a big string which
could be a webpage or something like
that and maybe you know going across the
network it takes a long time but in this
case um you know these these tasks are
turning anything specific so let's go
ahead and I'm gonna add a another method
here that actually kills my program so
I'm gonna say this is just gonna be our
simple private static void and we'll
call it kill program and I want to do a
simple thread dot sleep in here and
we'll do it for 2,000 milliseconds and
I'll just give a quick message saying
we're killing the program now and now I
can say starter stop equals false which
we'll get out of the wild true statement
at the top so then this this is where
the console.readline I said I would
explain that because otherwise the
console would immediately close but I
don't want it to do that so by saying
console dot read line it keeps the the
application closed even after this has
been called so now obviously something
needs to call kill program and we're
going to do that after this long-running
delay so we'll we'll say kill program
and just call that alright so now if we
run the program again this is obviously
the last statement that we're gonna get
after five milliseconds of waiting we'll
get the second-to-last string which will
display in just a second and then
immediately following it just execution
has completed and now we're gonna get
the final string after actually you know
what I'm sorry I said that completely
wrong I meant to say that this is
actually run first because it wasn't a
synchronous now if this wasn't a
synchronous method it would also be
delayed but because we don't have the
asynch in the awake keyword on this it
was executed right away so that gives
you an idea on you know the purpose
behind the await because this is saying
hey I'm waiting this but it immediately
called this because the method that was
invoked was in a synchronous method so
it's not waiting for anything unless you
specifically state that it should now
kill program is not even in a
synchronous method so if I wanted that
to be a sink
have to label it as such and then
instead thread I would say tasks tasks
tout delay and then now this is
complaining that there's no wait so I
want to say a wait TAS not delay and
this would have the same effect because
this would be called this would be
called and then so watch
so now this has the desired effect so
hopefully that is somewhat of a you know
brief and introductory introduction I
guess to to a single weight it can be
confusing it's a lot I think to wrap
your mind around it's really I think
it's really different just from normal
you know standard top-to-bottom
execution or even object-oriented
programming it's not multi-threaded
programming a lot of people will get
that confused they think that every time
and a sink and a weight it's spinning up
a new thread that's actually not the
case so there is a lot of misconceptions
out there and this tutorial was just a
very basic beginner level introduction
introduction and you should probably
look into the documentation there's
quite a bit of it out there and I think
in a way it can be very very complex
depending on how big and large your
application gets but definitely is a an
exciting feature of c-sharp and that's
something that's really cool all right
guys thanks for watching and please
subscribe bye</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>