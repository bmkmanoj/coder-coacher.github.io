<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Code Review vs Pul Requests by Marcus Bertrand | Coder Coacher - Coaching Coders</title><meta content="Code Review vs Pul Requests by Marcus Bertrand - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Code Review vs Pul Requests by Marcus Bertrand</b></h2><h5 class="post__date">2017-04-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/98KWUIxaAo8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay going so everybody had good lunch
is full still awake cool
I'm Marcus I work at Atlassian and I've
been there about five five and a half
years now and I've spent the majority of
that time with the bitbucket team
actually so I work on bitbucket cloud
now I've been a back-end engineer with
bitbucket only since 2014 so I really
have my roots and support and it kind of
gives me an interesting and unique
perspective I think since I've had a lot
of time before I was developer working
with bitbucket and helping people coming
over from other code review tools and
other just other methodologies in the
past like subversion and moving over to
get and starting to use pull requests
now of course pull requests aren't the
only thing that we've ever done into
lasya as a matter of fact we used to
have no code review back when we started
in 2002 it was just our founders and
they were working on Jared just side by
side and as they hired more people they
kind of kept kept with and adapted the
extreme programming methodology of pair
programming now this is where two people
might sit at a keyboard together they
collaborate on code it's sort of like an
instant code review now of course this
changed over time as we added a lot more
people we eventually also acquired a
company called sync wa-now sync we'll
brought with it three very cool tools
that have changed a lot of how we
operate in Atlassian since then
the first one is clover which is a code
coverage tool as he might in here
actually use clover okay couple people
cool
I'd also brought over fisheye who's
familiar with fisheye oh like 80% of the
crowd cool and also Crucible who's
familiar with crucible about the same
amount of people and you know usually
people get fisheye and crucible together
so now of course time progress get
material became more popular and in 2010
we acquired bitbucket so at the time bit
bucket was just a material hosting tool
but very soon after we added support
forget turns out that was probably a
good idea and is now we have about 10
times as many git repositories on bit
bucket as we do mercurial more than just
a get host we
also we also had got pull requests with
it and pour requests have really changed
the way changed the way again that
Atlassian really works it was actually
so popular that a couple of our team
members who work on our server products
got together in 2011 and made a
self-hosted get hosting tool called
caviar and they built this during a
shipit' which is one of our quarterly
hackathons and it was lucky enough to
win but caviar wasn't a very great name
so about a year later when we finally
released it to the public we called it
stash now staffs when it first shipped
was just to get hosting tool with some
security around it
not too soon after that we went ahead
and released - 2.0 which brought pull
requests so at this point now we have
pull requests basically being used by
just about every team in Atlassian fast
forward a couple more years after a lot
of iteration on pull requests and both
bitbucket cloud and stash we decided to
go ahead and rename stash to bitbucket
server and then since then we've spent a
lot of time iterating on pull requests
to really improve try to improve
people's workflow and also bring in some
of the better some of the better things
that we've learned along the way and of
course more than just pull requests
we're here to talk about a couple other
things so today we're actually gonna
cover four different styles of code
review and different tools that you
might use to do those so the first one
we're going to cover is pre commit code
review so this is where you might send
around a patch to different people for
review and then it eventually gets
merged in or committed in later by a
maintainer post commit code review so
this is where your codes probably
already been merged into your mainline
it may have already even been deployed
but you want to go back and take a look
at it we're going to look at Garrett
which is kind of unique into itself and
the way it works so we're going to talk
about it by itself and then of course
finally we're going to talk about pull
requests the way we're going to evaluate
each of these our talk about each of
these is based on a couple of criteria
so first of all creation so how easy it
is to actually create the code review
iteration so once you get feedback how
easy it is to contribute changes back
into that same code review collaboration
of course which is people making
comments it's going back
and forth and then finally history so
what's your codebase kind of looks like
at the end of the code review process so
let's start and talk about pre commit
code review now pre commit code review
is usually found in pretty large open
source projects where you're trying to
contribute but you don't have write
access so what you'd normally do is pull
down the code make some changes and then
email them into a mailing list where
then people will collaborate back and
forth with you make some comments and
then eventually a maintainer will take
those changes from the email and commit
them for you to master and of course
this enables you and them to pull down
those latest changes so let's look at a
slightly more concrete example of how
this could work so let's say we were
working for an airline and we found a
nice open source project to help us
calculate our fare taxes and fees so we
found a small bug though so if we notice
we're adding our emigration fee our
customs fees but our federal transport
texts might be being calculated a bit
wrong for our fare everyone see that so
we've probably want to contribute a
little fix make sure that we don't
reduce the fare and so the way we do
that in a mailing list workflow is
actually go out to get just my preferred
tool and use get format patch and get
format patch we'll actually spit out a
nice little differs that look like they
belong in an email you can then use get
to email that patch to a mailing list
where then the maintainer x' will look
at your patch make some comments in line
with your changes you might reply with a
few more comments and changes and this
could continue on for a while as a
matter of fact if you have a pretty
complex change or there's a lot of
comments this could get pretty unwieldy
pretty fast and it's maybe not ideal so
once that everyone's done and you're in
the maintainer is ready to commit your
changes they're going to take the final
patch and just the final patch and
create a single commit now this is good
for a clean history but it might also be
a little cumbersome if you have a lot of
people that have worked on a feature or
contributed to a patch there's only
going to be one author and one
mitr that's going to be associated with
this change in the destination repo now
the mailing list workflow definitely
isn't all bad there's a certain large
open source project out there that uses
mailing lists exclusively to operate and
I think that Linus likes his mailing
list workflow quite a bit as a matter of
fact he said that he doesn't feel that
the mailing list is in any way a
hindrance to working on the linux kernel
as a matter of fact the olynyk's kernel
has about two to three hundred emails
per day going back and forth with
patches and comments and so on in a
recent release there were probably about
13,000 patches so that's all the emails
another project that uses the mailing
list workflow actually is get itself so
even though get is what provides for the
pull request workflow get still is
maintained via mailing list by a single
maintainer and a set of core
contributors who make comments and
address patches so that's pre commit
review sort of in a nutshell some pros
it's version control agnostic it's very
Universal diff format you can send it
around from any tool you use whatever
tools you choose it's very simple again
using your own tools it's probably
easier for everyone it's very easy to
keep hundreds or maybe even thousands of
people in the loop depending on how many
people are subscribed to a mailing list
there's also some downsides it might be
a little difficult to iterate so if you
have a lot of changes going back and
forth there's gotta be a lot of inline
comments you're going to be contributing
new patches into the mail and then
people are gonna be replying to those
it's gonna go back and forth quite a bit
another problem that you could write
that could arise is being able to
actually visualize the code so a plain
text diff has no colorization there's no
syntax highlighting so it might be a
little difficult to see what's going on
and of course as I said a minute ago
there's only one contributor per patch
so for large teams or teams that are
looking for detailed accountability this
could be a problem and then finally you
have to manually merge in those changes
so that's pre commit code review so
let's talk a little bit about post
commit code review now most post commit
code review tools offer some sort of web
UI that allows you to see the diff it
sort of colorized like this
where you have a red line for what's
been changed or removed and a green line
for what's coming in a lot of tools also
allow you to make inline comments or
threaded comments and then of course
this is a screenshot from bitbucket
server by the way a lot of tools do show
you all of the files that are that are
involved in a particular code review now
before we get on to talking about
bitbucket and pull requests let's talk a
little bit about crucible and how it
helps you do post commit code reviews
the crucible in addition is showing you
all the things we just talked about adds
quite a few interesting features so the
first one is being able to actually
assign an end date or a due date to a
code review so what will happen is all
of the reviewers on your code review
will receive a notification that they
have a specific due date and they'll get
reminder emails leading all the way up
until the due date so that's pretty cool
and then out of your reviewers crucible
is actually doing something pretty neat
in the background and it's watching it's
watching you watch the poleward of sorry
of the code review and it's tracking all
the time that you're spending so if you
have if you have crucible integrated
with JIRA you can actually turn on time
tracking and get this time automatically
added back to the to the source tickets
in addition you'll also see that there's
some percentage reviewed notes on here
and that's whenever you're looking as
you're scrolling through files Crucible
is actually tracking what you haven't
haven't seen so that it knows how far
along the poll the decoder view is to
completion and then as your reviewers
are working if they detect certain
things that maybe are a defect they can
flag those and actually open issues
directly in crucible of course all this
gets summarized nicely over on the left
side where you can see how far along
your review is and how much work you
have left to do another cool thing that
crucible allows you to do is actually
kind of pick and choose how you want to
build your code review so you can start
with an individual commit you can add in
whole branch from some other location
you can add in individual files from
elsewhere in the repository that maybe
weren't even directly related to the
changes you've included in the commits
you can even upload individual patches
and crucible will try to detect what
those patches belong to and anchor them
accordingly
and finally something else cool you can
do is you can actually include multiple
repositories so if you have a big
feature or maybe you're working with a
micro-service architecture you can bring
in changes from lots of different
sources into one code review so another
thing that crucible allows you to do is
iterative code review so as you come in
and as you're viewing and and crucibles
tracking or what you viewed it is going
to actually auto adjust this slider and
then of course at any time you can come
back and readjust it and crucible will
remember where you left off so this is
pretty helpful if you have a really
large change or a really large set of
things to review now slight drawback is
that crucible is not a host for version
control meaning that your code must be
hosted elsewhere so that could be
bitbucket that could be anything else
you have and what crucible will do is it
actually reaches out to all the
different sources and pulls it in and
creates a nice abstraction layer on top
of that so it can be kind of
double-edged so on the one hand you have
this nice abstraction layer that allows
you to bring in maybe code from
subversion from get from perforce but
then on the other side of it it's all
read-only so when you need to make
changes you need to go back to wherever
the source lives make those changes
resubmit them update the code review and
so on and of course once you're done if
you're reviewing code that hasn't yet
been merged into a math main branch you
do have to go that you have to go and do
that elsewhere so let's take another
look at post commit review in review
so scible supports lots of different
popular version control systems it's
very flexible to review content you can
bring in things from just about anywhere
it's pretty easy to iterate so as you
make changes you go and update the code
review and so on and it's tracking those
changes so your team knows what's going
on but on the downside you do need to
host your code elsewhere that could be a
problem for some you have to manually
merge your work and this kind of results
in it being a little hard to enforce
process so some teams have requirements
that maybe they need a certain amount of
sign-offs on code before it goes out to
production and this is going to be a
little bit disjointed from your actual
merge and from the tool that you're
using to host your code so that's post
commit review
so now let's take a quick look at
Garrett
so Garrett's a pretty unique tool so
Garrett was it's actually a fork of a
subversion code review tool though it
was named right veldt and it was
actually spun out of an internal google
code review tool that was built on top
of perforce named Mondrian so Garrett
has an interesting history
Geir was initially built by Sean Pierce
and this is who built Jake yet so Jake
it is a reimplementation of git and to
get protocol engine Java and they built
it to serve at Google to serve the
Android Open Source project but now it's
used in a lot of open source projects
like the go language and some
professional teams but so well something
to note about get or Garrett actually is
it's very giddy and what this means is
that to actually configure Garrett you
have to create get configuration files
so you need you need a little bit of
deep knowledge about how it works under
the hood to actually be able to
configure and use and administer Garrett
so Garrett is a code hosting tool so it
works just like anything else you'd
expect you can fetch from master you can
pull in changes from various branches
that it hosts but when it comes time to
actually submit things for review you
have to send things to a special branch
called four slash master or four slash
whatever your destination branch might
be called in which you and at that time
you're sending a single commit now as
the code review process carries on you
can integrate with other tools to make
sure that you have a required number of
reviewers you can verify that builds are
passing and that that is provided
through integration with things like
Atlassian bamboo or any other tools that
you might have for building testing so
as Garrett looked like is it so as you
can see just like just like in crucible
on the left side you have read for what
has been changed or removed green for
what's coming into your repository and
then you have the ability to leave a
score so rather than just a flat
approval or rejection you can actually
configure a score range to decide how
good or bad or maybe required some
changes that this particular review
needs so the typical setup is like a
plus 2 to minus 2 so a plus 2 might be
yeah this is approved I really like it I
want you to merge this in immediately
and a minus 2 is more like now this is
terrible please go back make some
changes make all the changes or maybe
just never never merge this in so how do
you actually create a garrett code
review so after you've initially created
your actually excuse me after you've
initially created your garrett code
review and you want to go back and make
changes you'd go and make your changes
locally you'd go and commit them they
need to try to push back to that same
ref that you did earlier so as I noted
earlier there's only one commit allowed
so what Garrett's gonna do it's gonna
actually reject your secondary push so
you can't easily update your code review
instead what you need to do as it says
is squash your commits so Garrett really
expects that you're gonna have a clean
history in the end so it expects that
each time you sub to the four master
branch there's only going to be a single
commit so what you have to do locally is
make your changes push initially then
every subsequent time make your changes
squash it together and then force push
into that branch I'll have some
questions at the end that's okay you can
also do that as well yep of course you
carry on force pushing or amending your
commits as you go now this is pretty
similar to the way the patch set
workflow works with a mailing list and
that's sort of sort of what it's related
to the Garrett UI even goes as far as to
call these patch sets now as I mentioned
earlier this provides a pretty clean
history very similar to the mailing list
and is definitely preferred by by many
and in some larger projects like Android
golang project actually also uses this
and syndicates the patch sets over to a
mailing list as well so with Garrett you
get some pretty sophisticated policy
enforcement
that's through external integrations and
and its own review tools it is free and
open source it's built on Java it's
built on top of jacott so you can make
changes as you like
and it definitely provides the clean
commit history now some downsides that
Garret is get only so if you use
subversion or use other tools still with
other repositories you're not going to
be able to use Gerrit without converting
to get or using some sort of or get
conversion it is a pretty steep learning
curve you need to know a lot about how
it works iteration is a little awkward
needing to either amend or squash your
commits every time and of course there's
just do you have the one contributor for
patch issue which if you have a lot of
people contributing to the same change
or the same fix that could be a problem
for you so that's sort of Garrett in a
nutshell
so let's talk about pull requests now
now pull requests on bitbucket work a
little differently than in a crucible
code review for instance the main thing
is the pull requests do not allow you to
pull in arbitrary files or arbitrary
commits from different sources
it is very strictly branch to branch
only so you have a source branch you
have a destination branch what a good
side of this though is that it's a very
simple UI to be able to create a pull
request very simply you just select your
source branch select your destination
branch or destination repository and
away you go now another cool thing that
you get whenever you go with sort of
this linear merging two different linear
histories together is you get a little
more visibility into what issues may
have been involved in those in those
particular commits and whether or not
each of the commits along the way was
built and something we added recently in
bit buckets server sometime last year I
believe is iterative code review so
we've sort of are trying to bring in the
better the best or better parts of
Crucible over to bit bucket
so what iterative ruin bit bucket does
is it actually allows you to walk each
commit and see changes as they've been
at it it also tracks where you have
looked what you've looked at so as
people make more changes and submit more
changes to your pull request you can see
those
you'll see those and you'll see those
highlighted in the UI now more than just
a code review tool creating a pull
request or complete completing a pull
request actually means that you're
merging your code from a development
branch probably into some sort of
production bound branch and the reason
it's called a pull request is because
you're actually asking your team to pull
in your changes into the main line of
code and because of this we've decorated
pull requests with quite a few features
to make sure that your code is actually
production ready for example with branch
restrictions or merge checks depending
on which whether you use bitbucket cloud
or server we actually disable the the
merge button based or can disable the
merge button based on whether or not you
have passing builds and passing tests or
whether or not a certain number of
reviewers have signed off on it and kind
of all of that goes through to make sure
that your code is ready for deployment
so just a quick look at there guys a
quick look at branch permissions in
bitbucket cloud we just recently added
this it's been in bitbucket server now
for for a little while about probably a
little over a year and it works very
similarly allows you to request
different numbers of approvals certain
number of successful builds and all of
these again just make sure that your
code is actually ready to go out and
another cool thing that you can do is if
you have if you have JIRA integration or
you create branch a branch per issue you
can actually integrate this with JIRA
and automatically transition issues so
as you create a branch that has that
certain issue key JIRA will
automatically move it over to in
progress and then of course once you
create a pull request
it'll transition that issue to in review
and finally either when the pull request
is merged or when your CI tool is done
and you've started deploying you can
actually move that issue to done
automatically as well now of course with
Jared as many of you may know has almost
an infinite number of options for how to
how to transition issues and how many
different statuses those can go through
so sort of to reiterate though pull
requests are definitely the gateway
between development and production so
they're the boundary between code that
is alive and code that is dead
when you merge a pull request you're
pushing code out of the nest and out
into your customers hands and in a truly
automated tool chain everything is
really going to hinge on you pressing
that merge button now of course there
have been drawbacks found with the pull
requests workflow especially by default
merge commits so merge commits on a very
large and complex project can make a
graph of your repository look a bit like
a complicated level of Guitar Hero and
if you compare that with a very clean
and linear history of something like
mail a mailing list or get you can see
why people might prefer one over the
other thankfully with reasons of recent
versions of bitbucket server and very
recently with bitbucket cloud we've
introduced merge strategies and merge
strategies give you a little more
flexibility and how you merge your code
whenever you're done with the pull
requests and it gives you the option of
choosing exactly which method you won't
get to perform now merge strategies on
bitbucket cloud are relatively new and
we only have one option but I want to go
ahead and talk a little bit more about
bitbucket server and its various options
so ignore the wall of text here we're
just gonna cover the basics what's going
on here so you have five merge
strategies available no fast forward
fast forward fast forward only squash
and squash fast forward only so let's
drill in and kind of talk about what
each of these do so if you use git merge
fast forward which is this default and
get assuming that all of the code that
is in the master branch is on your
branch when you go to merge it will
simply update the pointer of master to
your commit and without getting into too
much detail get under the hood every
single branch is just a reference to a
specific specific commit somewhere in
your history now if the changes that
you've made have diverged from master
and you don't have the latest commits
from master on your branch when you go
to merge instead of it fast-forwarding
and updating the pointer it's actually
going to create a merge commit now this
can result for some people and a little
little bit of a mystery as to why
sometimes you're getting a merged commit
and sometimes you're just getting a
fast-forward so the next thing is no
fast-forward so no fast-forward actual
forces there to be a merge commit for
every single merge whether or not you
have all of the history from master and
this is actually the default in
bitbucket cloud and bitbucket server and
what we built both products with
initially and the main reason we did
this is because we felt that it was
important to have a logical mapping
between your pull requests your issues
and your branches for example all of our
merge commits if you'll notice the
message usually includes the pull
request number and what branches may
have been involved in that in that
particular merge and then there's
fast-forward only so when you
fast-forward only it assumes that you
already have all the things all of the
code from master and all the commits
there and it will create just updated
pointer but if you've diverged now it
will actually reject your merge it means
what you need to do is go back and amend
or rebase your changes back on top of
back on top of the latest commits of
master and of course once you do that
it'll be happy with you again and allow
you and go ahead and move that pointer
forward and finally just get merge
squash or second almost finally actually
and what this does is it this works a
lot like Gerrit so when you go to merge
or pull request what we'll do is
actually combine all of your commits
together and all of your changes
together into a single commit so this
this is if you want the same kind of
workflow that Gerrit could give you or
mailing lists workflow where you just
have single commits going into your
master branch they're very clean history
this is definitely the way to go now of
course if there are multiple authors and
multiple people contributing changes
along the way you're gonna lose some
visibility into that and then actually
finally is squash and fast-forward only
so this works exactly like we just saw
with squash where we create a single
commit but if you've diverged from
master now you actually can't you can't
create the merge commit or you can't
create the merge so instead what you
need to do just like we saw before with
no fast-forward only just go back and
rebased your changes and then you can
then give a light a squash and make your
changes
so what do I think you should use well
last thing we use quite a few different
things so the merge commit offers you
kind of an ugly history so you have all
those merge commits you have every
commit but you have full traceability
and it's pretty hard to mess up with
fast-forward only emerges
you have no merge commits you have a
pretty verbose history and but it does
require rebasing which could be a little
tricky for some people and then of
course with squash you get a very
concise history but you lose a lot of
context about how things evolved and now
that lassi n' as i said we use a little
bit of everything so but we mostly stick
with the defaults that's we built it and
we use it that way I know it's how we do
it on the bitbucket cloud team is we
just let the merge commit happen and
that's how we know when when things have
hit our main production branches some
teams prefer the fast-forward only and
that's what they like and then of course
there are a couple of teams including
some of our external libraries that we
use on bitbucket that we prefer squash
just because the library is pretty
simple we want a simple history we don't
need we don't need all the details that
have happened over time the summary pour
quests offer really sophisticated policy
enforcement between merge checks and all
of the integrations that you get there
you get quite a lot of ability to to
restrict how code is going to go into
your branches into your main branches
you have your choice of merge strategies
as we just saw and of course multiple
team members can offer code under review
and then lastly if you're using bit
buggy cloud you get get or mercurial as
a choice and you're using bit bucket
server you get get of course major
drawback is that it's a lot less
flexible than something like crucible
you're stuck with just two main lines of
branches that you're going to merge
together so who do I think should use
which ones so if you if you have a need
to review multiple repositories at once
or maybe cherry-pick files then you
definitely want a more traditional code
review process with something like
crucible if your teams not on get
not ever not old material it could be a
problem if you have a really heavy
iterative workflow meaning that you've
got maybe you've got to do due diligence
on on a large product project that
you're evaluating you may have code from
a lot of different sources you may have
a relatively large code review you
definitely won't want to probably use
something like crucible finally it's a
bit of a joke if you are afraid of
branches or forking I know some people
prefer just to merge straight into
master and we've given at the last thing
I think dozens of talks on why you
should use branches but you know it's up
to you and it's your code base so if you
don't use branches and you might not
want to use you might not want to use
something like pull requests they think
literally everyone else should probably
use pull requests if you have a pretty
simple history or you're using just
pretty parallel branches it's going to
work just fine and of course you can
always combine them as we said earlier
that crucible is not a host anyway and
it can reach out to any particular other
host and bring in code so you can use
crucible for your more complex code
review or maybe you're after commit or
after deployment code review and then
pull requests to kind of gate check
things as they go in seem to have hit
the end pretty quick so if you're
looking for more information you can go
check out bitbucket org you could check
out our blog we've we've definitely put
a lot of content out there lately if you
want to know more about crucible you can
go check that out and of course Gerrit
we don't make we're not involved in but
we're happy to happy to tell you where
to go find it and finally you'll notice
that my twitter handle is on up there
and that's mostly because I post
pictures of cats and things like that
you don't want to follow me but my buddy
Tim Patterson he works for us and he
loves get and he talks quite a lot about
it and gives quite a lot of talks around
the world about git so if you have any
complicated or interesting questions or
you just want to follow and get the full
story on what's happening with get
definitely follow my buddy Tim so with
that I can open up for a few questions
actually I'm not sure I believe it is
though I think nope
so the question was whether Garret
allows you to have more than one team
member submitting to the four master
branch and can you repeat your answer
one more time
dr. anybody else over there so the
question was what are the difference
between github and bitbucket
as far as pull requests go I think one
of the main differences is our merge
checks and branch restrictions
I know github recently introduced some
similar tools but we've had we've had
quite a lot of integrations with other
tools for a while and our pull requests
that allow you to kind of gate check
being able to merge and on a variety of
criteria also being able to enforce
approvers is something we've had for
quite a while I think now they've come a
little closer to us so that's pretty
cool so I think there's there are some
differences and we're some similarities
as well any other questions sir
this is a great philosophical debate we
mostly don't mind having the the full
history that includes all of that
information and I think you'll find that
a lot of teams are on a lastname feel
that way there are a few that don't but
they're kind of far and few between or
maybe they're on or maybe they try out
different things on certain sub
libraries or sub projects of our larger
products for us no I don't think so like
the the bitbucket cloud codebase has has
we have quite a large team now so
there's just a ton going on our graph
looks a lot like that Guitar Hero graph
and it doesn't really doesn't really
bother us that much and we can still
find what we need to find when we
digging around in our history you may
else have any other questions sure
so the question was they've had a few a
few instances where where the questioner
has worked where crucible hasn't scaled
very well and he's asking how how are we
working on that and how do we handle
that inside Atlassian it's honestly
there's a there's a lot fewer teams
using crucible these days but we do
still have people devoted to working on
crucible and improving the performance
of both fisheye and crucible and I know
there have been quite a few changes made
in probably the last two years or so to
improve performance and scalability and
if you want to talk about more you can
come by the atlast name booth afterwards
and we can talk about it in depth does
anybody else have any questions
sure
the question was do we and Atlassian try
to keep our commit history cleaned so
that get bisect works better and the
answer is it's team by team I know
and in bitbucket we don't we don't
really put a lot of effort into it and
we don't have we don't have that many
problems really like that and what we
usually do is use the pull request
commits just sort of bounce around and
figure out what's what's been merged in
and what's been changed that may have
affected something that went out to
production I can't speak for other teams
though any other questions so the
question is do we use crucible some of
our teams still do definitely some of
our server product teams still use it
they still prefer it or and they'll
sometimes go back and do some like after
commit or after release code review with
crucible and of course we still have the
fisheye crucible and clover people that
that tend to use and dogfood their own
products over over pull requests any
other questions sure
you're asking our do we use automated
automated testing tools and do we use
those at Atlassian not a bunch we do use
some coverage tools so for instance we
have clover but we on the bitbucket team
we also use I believe it's I believe
it's just called cover that just
validates code covers but we don't use a
lot of defect detection we do use some
security detection software that I'm not
really sure I don't actually know what
how to talk my head what we which
particular product we use but we do use
some some automated detection but not a
lot of not a lot of specific defect and
bug detection like that any other
questions cool wait did you set it all
right well thank you very much for
coming everyone</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>