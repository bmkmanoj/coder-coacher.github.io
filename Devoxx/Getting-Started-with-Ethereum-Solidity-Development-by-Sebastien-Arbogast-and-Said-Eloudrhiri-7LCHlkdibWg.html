<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Getting Started with Ethereum Solidity Development by Sebastien Arbogast and Said Eloudrhiri | Coder Coacher - Coaching Coders</title><meta content="Getting Started with Ethereum Solidity Development by Sebastien Arbogast and Said Eloudrhiri - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Getting Started with Ethereum Solidity Development by Sebastien Arbogast and Said Eloudrhiri</b></h2><h5 class="post__date">2017-11-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7LCHlkdibWg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone and thanks for coming so
early I mean come on it's 9:30 and it's
minus 1 degrees outside so I understand
how difficult it was today we are gonna
talk about getting started with a
theorem sorry TT development so I hope
that's what you're here for because well
otherwise just previously on the box so
we're here last year to talk about guess
what blockchain development any failure
but mostly to talk about why you should
get interested in the blockchain so we
won't go over that again if you want to
watch the detail three-hour presentation
you can go to youtube and see the
presentation for yourself but we still
want to give a brief introduction for
those who were not here last year and
just as a way that everybody starts with
the same points and understands what
we're talking about
one of the main feedbacks that we got
last year is that we our presentation
was very broad and lacked some code and
after all we are in a developer
conference so fear not this year there
will be plenty of code to draw on but we
dive right into it who was here last
year at our presentation ok but 10 I'd
say who is here because they want to get
into this world and get ripped fast with
icos and stuff still a few ok ok just a
word of warning we're not going to talk
about cryptocurrencies here I mean not
for the sake of it but really focus on
development who's already written some
solidity code and can understand what
this does couple three four ok and who
is one of our udemy students nobody
that's good because if you were you
would be able to enjoy this amazing
course that we have ok whatever so who
we are very briefly we are all time
freelance developers we've
on all sorts of projects from back-end
to mobile to front-end web smartwatches
Smart TVs fridges whatnot went to
together we own a fortune of about five
yrs so we're pretty rich I mean come on
I mean not now
maybe next year and yeah two months ago
we released a course on udemy we have
more than a thousand students about film
development I don't know what I
mentioned anyway so what are we going to
talk about today first of all I'm gonna
give you a short introduction to
blockchain architecture how it works
what it includes and so on and then we
are going to create adapt a
decentralized application from scratch
with truffle you will see what truffle
is later on will work right a smart
contract we'll see how to test small
contracts and to interact with them once
they are deployed how to create a
front-end very briefly and then did I
mention we have an online course on
udemy sorry so very brief introduction
to the blockchain
there are a few things that block chains
are awesome at the first thing it's not
just for FinTech so I'm sure you've
heard of the blockchain in the world of
banks and insurance companies and so on
it's clearly not the only vertical I
would say where they're useful and I
would even argue that it's not the best
one because those industries are highly
centralized and we're talking about a
technology that was designed to be
decentralized so be aware of this
limitation what they're awesome at is
robustness they were designed to work
decentralized and distributed because
well the same as the way the web was
designed first if you remove a node it
still works if you remove half of the
node it still works
so it's really made for those kinds of
applications where you need to be sure
that the system will run no matter what
another thing is great at is censorship
resistance
I'm sure you've heard since the
invention of Bitcoin well one day will
disappear a nation-state will take it
and shut it down not possible
it would have liked to after all it is
an alternate currency and by most
nation-states laws you're not allowed to
create it an alternate currency but
still they can't take it down because
it's censorship resistant by design
another thing it's great at is being
completely borderless there is no notion
of a national border on the blockchain
none whatsoever
so it's really powerful for those kinds
of applications where you need to
transfer value when do stuff on a global
scale another thing it's great at is
being secure but that's why I chose this
image secure in a very slow way ok
you trade off security for speed
basically at least that's the case for
now but don't believe those who would
say that's this that's the the way
things are in the blockchain world I
mean we are talking about a technology
just very early very young and it's
evolving very fast so most of these
problems will be solved at some point so
basically it's great for
disintermediating mat markets that's the
main thing so whenever you have an
industry that's run by a category of
actors of yeah type of companies whose
main job is to serve as a trust 40 or an
intermediary that's the thing where you
can rethink the business model based on
the blockchain and that's what scares
the out of thanks basically because
well again they are intermediaries and
their main business is to take a cut of
everything but that's not the only one
notaries insurance companies I said it's
not just for FinTech it's also for in
the energy market and plenty of
industries really and basically what it
allows you to do is to create a network
of value so you might already understand
that the internet is designed as a
network of information which means that
when I send something I keep a copy of
it so everything works by replication
but on the blockchain it works by copy
so when I send you something I don't
have it anymore and that's absolutely
key that's something that we couldn't do
before and that we can do now thanks to
the way the blockchain is designed and
yes it's also very good at looking hype
so this is just the progression of the
price of a share of a company and the
last part of the graph is the day they
decided to add blockchain to the name so
yeah of course there's that also but
what I would like to you to remember
after this talk is that it's also very
important in terms of opportunities for
you guys developers ok I know we're all
excited by the last JavaScript framework
and and the latest evolutions in spring
and so on but here we are talking about
the technology and I'm mark my words I'm
talking about the technology that's
going to be the foundation of businesses
for the 20 years to come it's not ready
for completely ready for prime time yet
but this is it
this is going to decentralize so many
industries and it's going to go beyond
businesses so I hope you all realize the
importance of that moment the role that
you may have to play in this transition
and yeah the incredible world that's
before us so how do blockchain achieve
what we just talked about first by
building a distributed ledger so
Ledger's are a very efficient way to to
manage value whether in a real world
with paper Ledger's or in the existing
world that's the way banks manage their
backends basically and the difference
with the block change that this ledger
instead of being stored in one central
database is distributed across the
network so every single node in the
network has a full copy of the entire
database ok so that's the main key and
what when you hear a blockchain that's
what it is
it's a chain of locks where each block
contains a list of transactions so when
you change locks together you indeed
have a global ledger of all the
transactions
the way it does it is through
decentralized consensus now this is
something that we talked about last year
but it's really really important to
understand this is a problem that's been
bugging the that had been bugging the
computer science community for y'all
since the 90s basically and it's called
the Byzantine generals problem okay
so again imagine a city that's
surrounded by armies each armies led by
general and they all have to decide
independently whether they want to
attack or if they want to go home if
they all attack at the same time the
city will be taken and the armies will
be victorious if they all go home then
nobody is harmed the cities remains
intact and everybody is happy now if
some of them decide to attack and the
others go home then we have a problem
it's gonna be a massacre not just for
those who attack and get butchered but
also for those who get home and will
have to pay the price and this happens
in context where the communication
between generals is very unreliable okay
let's say they are talking via horse
messengers for example and messengers
can get corrupted they can lie they can
get intercepted replaced whatever so you
can see the analogy here this is exactly
a situation where we were in we have to
agree on a common version of that
distributed ledger okay - all work on
the same version of the truth but we
have to do it on a network that's highly
unreliable it's called the Internet and
and we all have to come to an agreement
okay so that's decentralized consensus
thing and again there is no super
general that arbitrates the decision in
the end another thing is that it does
that over a peer-to-peer network which
means that at any point knowing notes
can join or leave the network without
any words of warning okay and this is
absolutely key because this kind of
problems the Byzantine general problems
we already had solved it in the 2000s
before Bitcoin but in a very specific
context where the network size was
always the same and the nodes were
unknown and so on
and all of that happens in a trustless
community of anonymous notes so you
don't need to authenticate notes before
they join the network there are
mechanisms in place to make sure that
all those notes behave in a consistent
way and you don't need to trust the
notes themselves Trust is built into the
network that's a key difference and all
those nodes are here to contribute time
stamped tamper proof and immutable
transactions and again and in the case
of Bitcoin those transactions are money
transfers but we'll see that on a more
generic blockchain so those transactions
can be much more powerful and include
any kind of value and for any kind of
network of value you need your
transactions to be immutable you don't
want people to be able to change history
you need them to be tamper proof so
whenever they're sent across the network
we have a way to verify that nobody
fiddled with them and there are time
steps so everything keeps I mean remains
in order and thanks to all that we can
transfer any kind of value as I said not
just crypto currency but really any kind
of value that we can represent and again
remember that the blockchain the Bitcoin
blockchain was designed as a way to
create a monetary system and to transfer
currency that's already a pretty nice
achievement but what we have now with
the theorem is the ability to do much
more than that so concretely how do you
use a blockchain well first of all you
need to install Network client okay
there is no server to connect to or
whatever you just install this
application on your computer and you
start it when you start it it connects
to the network so it finds a few peers
around you and it starts to download a
copy of the distributed ledger and
that's something that it needs in order
to start secure transactions so this can
take a little bit of time okay right now
when you when you start a new node from
scratch it takes about two to three
hours to download the entire theorem
blockchain the goal for the developers
is to bring it down to under ten minutes
but still that's
that's something that you need I mean at
least if you want to start a full note
the next thing you have to do is to
create an account which on blockchain is
pretty simply a key pair so private key
and a public key your public key helps
you identify your accounts your private
key you keep it to yourself because
that's the way you sign transactions and
if you lose your private key if you
somebody gets a hold of it you're
screwed so keep that very very securely
of course creating such an account a key
pair is completely free so you can do it
as many times as you want
and nobody will require you to send you
a copy of your identity card then to use
the network you will need some
cryptocurrency in the case of a film
that's ether and the case of Bitcoin
that's Bitcoin of course and every open
blockchain has its own intrinsic
cryptocurrency and you can do that very
simply by going to something like going
BAE's any marketplace where you can buy
some cryptocurrency with your credit
card or sending a wire transfer it's
very easy now of course you can also
instead of buying some cryptocurrency
you can also mine it but that requires a
kind of a bigger investment and then
again if you buy some cryptocurrency on
those marketplaces don't forget to
transfer it somewhere safe because those
those marketplaces are not what we
couldn't call safe they are a
centralized database where they store
your private key for your account so if
somebody gets to hack these well it
happened in the past and that's where
all the thefts happen there was never a
known bug in the blockchain itself it
was all the in the market places that
 happens that's the weak link in the
network really and once you have some
cryptocurrency then you can start using
it to deploy a smart contract and will
actually show you how to do that and
then you can call functions on smart
contracts so you can see small contracts
like I'm gonna get user buzzword like
micro services okay that you deploy
somewhere and then it
there's an API and you can call
functions on it when you deploy your
contract to the blockchain doesn't do
anything it's just sitting there as is
as a service with a state so with a
persistence database of sorts and then
you can call functions on it to modify
that data and to get data so what
happens behind the scenes this is a
typical example of a transaction so you
send a transaction from an account you
send it to another account which can be
either another human account I would say
if I want to transfer money in this case
it's a contract account so the nonce is
just a way to avoid replay attacks so
it's a kind of a counter if you want the
gas price and the gas limits this is
very important because that's a way for
that's a way to pay for the execution of
the functions that you're calling so yes
nothing is free on the blockchain now of
course as we said before this price is
very very little for a simple transfer
thing now it's under 1 cents of a dollar
and then of course it depends on the
complexity of your of your network sorry
of your functions and that's the way
that network that the blockchain network
prevents people from abusing and
overusing the capacity of the network if
you want then you can with every
transaction you can associate value
again not just for money transfers but
also if you call a function on on a
contract you can also associate value to
that to that call and in that case it's
important to understand that every
contract has its own balance so you are
effectively sending money to a contract
and then inside the contract you can
send when your way and the data field is
to include for example the name of the
function you want to call the parameters
and so on and of course everything is is
encoded there so once you've created
your transaction you sign it with your
private key and it spreads over the
entire network starts with the appears
and then your peer send it there appears
and so on and very fast it spreads over
the entire network using a what we call
a gossip protocol
it's called the deaf p2p protocol and I
won't go into details here but you can
find this information on the ethion wiki
then miners who are just other users of
them on the network with a little option
enabled in that client they can pick up
your transaction and try to mine it into
a block again we won't go over the
consensus algorithm the mining stuff in
here but I strongly advise you to have a
look at this address where they really
show you how mining works and you can
really see those transactions work and
it's all very simple there is a video on
YouTube and there's also the prototype
that you can try online so - pick up
your transaction and mine it into a
block and then blocks get built and
append into the chain actually at which
point they can spread across the network
again and this s stats tool is just a
way for you to see the actual live
blockchain work and see the blocks being
headed by by I mean who are the miners
who appended the block and so on when a
node receives a new block you can easily
check it and that's what the note
software does it does behind-the-scenes
without you even noticing and we can
check a few cryptographic primitives and
then we're sure that the block is
authentic and it was really processed
via mining and again you can use as a
chain that organized or anything to
actually inspect the blocks see what's
inside
when it was produced by whom and so on
and you rinse and repeat every few
minutes so on the blockchain on the
Bitcoin blockchain is every ten minutes
on the thing emits about every 15
seconds now I think and this process
goes on and on before we dive into the
real blockchain again we just want to
emphasize a few things that block chains
are not very good at so if you want to
run a blockchain
on a small device think again because
the of course as I said every
transaction is appended into the the
distributed ledger that everybody has a
copy of so it grow
and grows and grows okay these are
approximate figures but for Bitcoin for
example right now the blockchain is
about 140 gigs and grows by 4 gigs a
month for a film it's about 70 gigs I
say about because actually and the
etherium case it's a little bit more
complicated to calculate it all depends
on the mode that you choose to
synchronize and so on so I won't go into
details with that but it's about that
order of magnitude
another thing that block chains are not
very good at is throughput we said it
before if you compare for example the
Bitcoin and the a theorem block chains
compared to traditional centralized
networks Bitcoin is about 11
transactions per second now a theorem is
about 20 but and that's a max that's a
cap it cannot be go beyond for PayPal
that's about 115 but that's an average
it's not a cap these are about 2000
transactions per second but again they
can go up to 40 50 60 thousand
transactions per second especially when
it's holidays and everybody is buying
like crazy so that's also something to
remember again we paid the
decentralization aspect with a little
bit of speed
another thing real-time so when you send
a transaction to a network it has to
spread across it be mine into a block
the block has to be spread again across
the network so all of that takes time
and when you send a typical TransAm call
to a REST API for example it can take a
few hundred milliseconds but when you
send a transaction on Bitcoin you have
to wait for at least six blocks to be
sure that the transaction is an
absolutely immutable and that's about an
hour for a theorem it's much shorter as
I said blocks are produced every 15
seconds or so and you have to wait well
it's with 17 seconds last year and you
have to wait 12 blocks to have absolute
confirmation of your transaction so
that's also something to remember
another thing is that block chains were
designed to work in big networks with
a lot of noobs so when he tried to apply
it in small networks well you get
centralization again and you get plenty
of issues okay so it works great in big
networks a few thousand nodes or
something but as soon as you try to
apply it to smaller context well it's
clearly not efficient enough and it has
a problem with privacy that's something
again that's gonna change in the near
future but for now clearly storing your
medical records on the theorem
blockchain might not be the best idea
ever
okay so keep that in mind everybody has
a copy of all the data it's not like
it's I mean everybody can see it right
away they still need to decode it and so
on
but I mean if the information is
precious enough it will happen and as we
said before it's not good at free usage
so every single transaction that
modifies the state of the blockchain
that changes something in the database
has to pay a price and this price in the
case of a theorem is called gasps okay
it's not directly paid in ether but
basically it's it's a unit of complexity
the more your code is complex the more
gas units it will require to run and
then each gas unit has a price in ether
okay so when you send a transaction to
the network especially when you call a
function a an ether transversal just
sending in crypto currency across to
another account
it's about 21,000 gasps but when you
want to run more complex code then it's
that it has a price and of course the
heavier the the operation you're trying
to run the more it costs and you can
find plenty of information about that on
this website and it's not very good as
at fast protocol upgrades you've
certainly heard of Forks soft Forks hard
Forks whatever those are the ways that
we change the way the consensus works
and the way the network works when you
did when you deploy a centralized
application on the server somewhere you
just change the application you upload a
new version and nobody saw it with
anything on this kind of networks where
the software runs literally on every
single node then you have to upgrade
that software
on the whole network and that takes time
and sometimes it doesn't happen very
very well sometimes some of the nodes
decide to upgrade and others say no I'm
staying with the old version and then
problems start to appear
so if you want to understand more about
what a fork is there was one on a theme
- yeah - three weeks ago and it went
well everybody agreed with it so
everything went smoothly but we
explained everything in this video and
the next thing that block chains are not
very good at is pleasing centralized
institutions and regulators so you might
have seen this news of this guy at
JPMorgan that says yeah but the Bitcoin
is a scam and it's gonna disappear yeah
it's a scam for you because it doesn't
fit into your world but we're in a
different world now you don't know it
yet but it's different so that's
something also to keep in mind you will
have some resistance from either big
companies even nation-states governments
and so on because this is a completely
new paradigm for them the last thing I
want to insist on before we dive into
some code is what you should not call a
blockchain and again if you've seen my
talk last year our talk last year so
that I'm kind of obsessive with that but
I think it's very important to balance
the message and inform everyone on what
a blockchain really is because you might
sometimes hear of this thing called
permission blockchains
and notice the number of quotes around
blockchains
for us and for a lot of people actually
in the blockchain community permission
block chains are like planes on highways
imagines if the Wright brothers came
with the airplane and this yeah it's it
flies and defeats flies possibly flies
and then people said hey this is cool at
being fast let's drive it on the highway
no no it was designed to fly don't care
don't need to fly invested in roads come
on let's okay and that's what most
companies are doing when they're using
this permission block chains they're
taking an amazing technology that was
designed for a very complex and
yeah very new landscape basically and
they remove the part that don't agree
with and they try to do something with
it but then what the end up with is
actually over overly complex solutions
to existing problems yes banks have a
problem to be efficient and to make our
wire transfers more fast for example
yeah sure but is the blockchain really
the best solution if you start with the
same assumptions and so on
don't you find an easier solution then
this okay there's no buzzword and so on
and your share doesn't go through the
roof just because you added blockchain
to your name
but still from an architectural
standpoint doesn't make a sense so for
us those permission block scenes are a
huge diversion of money and energy when
we would need definitely to have more
brains and more people thinking about
open block chains and how to solve the
last problems that we have so yeah
that's the problem and don't forget
there's a side effect to that it's not
like okay let them call it blockchain
and they'll come back afterwards there's
a risk for open block chains as well
no this Gartner innovation cycle there's
a true of disillusionment at some point
well that's when those big companies
will say yeah it doesn't work that's
because of the blockchain remember they
did exactly the same for agile they did
exactly the same thing for the cloud
okay when it doesn't work it's because
of technology it's not because of their
decisions
so mark my words so as you guess today
we'll be talking about open block chains
and more specifically about a theme and
we're going to show you what is adapt so
adapt is a decentralized application and
very basically it's a set of smart
contracts and again we'll show you what
it is with a user interface so you have
smart contracts that are deployed to the
blockchain and when they are deployed to
the blockchain to get an address okay
that's a fixed address that you can use
to to access them those contracts can
collaborate together okay and they all
expose some API that you can use to call
them and usually you call them from a UI
because yeah calling smart contracts
directly is like calling a rest a REST
API directly it's not the most user
friendly
way I mean for normal people I guess you
all use pull all day and so maybe that's
not for real people anyway and you do
all that use all that in a special kind
of browser why is it special because it
needs some keys to work it needs to send
to sign some transactions for the
network and it does that with a bunch of
key pairs are stored in the browser and
of course this browser needs to be
connected somehow to the network on
earth in order to spread new
transactions to get new blocks and so on
ok so that's what we're going to show
you now let's get our hands dirty let's
say we want to organize a new conference
ok and it will be a conference where
attendees can register using
cryptocurrencies instead of paying with
euros and dollars and stuff that's so
boring and they can also vote for talks
that they attend nothing fancy here but
the difference is that in this
conference speakers will be paid
according to their reviews according to
the good ratings that they get from
attendees for portion aliy if you want
now let's call it let's say
decentralized Vogler let's call it D Vox
do you think we'll have a problem anyway
so that's going to be the name of the
app we're going to show you today a few
disclaimers this is completely original
code so we of course we demonstrate
another application in our online course
but this is a completely new one
and it's the first time we show it so
there might be some quirks here and
there but bear with us usual warning
this is by no means usable introduction
so if you want to organize your own
conference you might have to work a
little bit more than what we did this is
really to show you how it works
generally we are going to live code some
of it review most of it the goal is not
to for you to watch us to look at us
type for three hours but
still we're gonna show you some real
code and show you how it integrates in
the application progressively and of
course we'll everything is already on a
github repo that will give you the
address at the end so you can check out
the the entire project afterwards to see
how it works and we'll focus on small
contracts first and then at the end
we'll show you a bit of web user
interface to show you how to finish I
would say the architecture of this step
so well we'll the development
environment look like first of all we're
going to use test RPC it's a common line
tool that is actually an idiom node
emulator okay so when you're developing
you don't want to develop with the real
network where you have to pay real money
to run your contracts and so on and also
you don't have to - you don't want to
wait real time for it to happen so on
test RPC everything is instantaneous
it's completely fake everything happens
in memory mining is instantaneous and
transactions are basically free so
that's very good for development just a
world of running this tool test RPC has
been used for I think a year and a half
and so on
by a lot of people we are going to show
you the truffle build a framework also
and in the new version that was just
released last week test RPC is actually
integrated into truffle so you don't
need to start it on the site anymore but
okay we adapted our content and we wait
for the documentation of truffle to be
complete with truffle we'll use it to
create the project to compile contracts
to deploy contracts to the network and
to test also our contracts and we will
use I mean we are using a IntelliJ
because we are all time Java developers
and we love it but you can use any text
editor with some sort of a solidity
plugin for syntax colouring and stuff it
works really most of those tools I mean
work with a simple text editor
another terminal anyway and I think it's
coding time
and this yeah it's coding time so I'm
gonna hand over to Sayid
it's going to show you how to create the
project and get started okay let's go
let's - to the to the code enough with
slides so as we saw we need to set up an
environment before creating our our tap
our doesn't allows application and the
first thing that we have to to install
is a serial node so as Sebastian told
you we'll use test RPC because it's fast
and you know when we develop an
application we hate to wait so to
install test RPC it's quite easy it's
the start be seen that it's no GS
implementation and you can find it on
our github this address github calm
guitar MGS just RPC the installation is
quite easy
NPM node package manager install my
energy to install it to globally ETA mgs
- test RPC well we are not going to show
you how to install no GS I think that
guy that you are developers and I'm sure
that you are able to to do it on your
own so to install test RPC and PM not in
uppercase air and p.m. install managing
aetherium yes - this RPC hello so I will
install it and the installation is quite
fast it has been optimized since a few
months now you know it uses only
JavaScript libraries and dependencies so
that's pretty fast
okay sorry the installed if I want to
start it test RPC and here we
a lot of things first the version of the
Star PC version 6.0.1
it's really important with the etherium
or with any earlier technology to check
the version because sometimes you have
some you know some upgrades some minor
fixes or some margin fixes and when you
are working with the the ethereum
blockchain some major changes can can
break some some things in your just for
comfort so you have to be really careful
and to to be sure that the new version
will not break anything on your on your
code something in nothing new first for
people working in a JavaScript
environment anyway breaking changes in
minor versions duh so test RPC is
powered by a library called ganache core
so ganache core now is bundled with
within truffle dot 4.0 so with truffled
4.0 that that has been released the last
week you will not have to start to start
PC I try now well just just just just
use this version just for PC so it's a
test aetherium note it's creating for
you 10 accounts and test accounts you
can see here their public address and
their private keys the private keys will
be really useful if you have to import
the account in a third party application
for example metal mask that will be
illustrated at the end of this of this
session and test RPC is also creating
100f error for each of these accounts
but don't try to sell these accounts on
the main Network it will not work if
anyone is monkey money
exactly so test RPC check now we have to
we need to have a framework to create to
compile our smart comforts but also to
deploy to this to this this
in theory I'm not so we see that we will
use a truffle as a development framework
as you can imagine there are many
frameworks but we think that the truffle
is really a great solution this solution
has been created by consensus the
company beyond truffle and beyond a lot
of tools that are used in in the interim
ecosystem and we think that truffle is
really great and if it's a solution that
is I will say improving very fast very
very fast
the version truffle 4.0 is really
promising but here from now we will use
the previous version because we know
that this version is really stable the
documentation is up-to-date and well
it's a demo we don't want to take risks
yeah yeah offer for is has been released
with documentation not yet
good practice right anyway so we'll have
to wait a few more weeks together
up-to-date documentation on that side
and it's really important because they
added quite a few things so yeah so to
install truffle same thing you have page
here describing the framework as you can
see you can you can compare smart
contract deploy deploy it's basically
the Gradle or maven before adapts
install it npm not packet manager
install you install it globally truffle
but here then use this command because
it will you it will install for you the
last version so we will use will install
the previous version the command is npm
install - j trust and we'll use the
version 3.4 dot 11 don't do it
and here also the installations fast
okay so truffle is installed if you want
to check what you are using here truffle
version and here we have two information
that is really important first the
version of the framework but also here
in the version solidity version all 415
and solidity is the programming language
that we will use to create the the smart
contract so we have several programming
languages I think that is Viper well
there was there were already a couple of
programming languages at the beginning
that completely were thrown away like
serpent if you might have seen something
like that now the main languages being
used is solidity the new one is called
Viper it's not really ready for
primetime yet but it's going to be soon
and there's another one called bamboo so
basically you're in known territory here
because it's it's the same logic as with
the JVM the the if your network work
works with the EVM the etherium virtual
machine so it's just by code and then
you can use any kind of programming
language that compiles down into this
bytecode to work so solidity solidity is
probably the most popular one with it
exactly and you can find the
documentation of solidity in this URL
solidity dot read the docs at i/o and
develop but again here the version of
solidity that is provided in this page
is the last version you can read the
documentation that is related to your
environment by you know switching here
the version 0.4 dot 15 and you will have
all the documentation related to your
version and unlike some of an
environment you might know new versions
of the language don't have don't happen
only every three years or four years
it's more like every two months so yeah
you have to keep track of that as well
okay so now we have the framework we can
create compile and deploy the smart
contract we can also test it we have a
a theory of node implementation with
test RPC that will create a blockchain
in in-memory watching this is why the
star PC is quite fast but we have to
edit the code of course so you can use
the eye editors that you love for
example not but or fin or whatever but
effectiveness also has an interesting
year yeah we can see in the ecosystem a
lot of people using a toe as as an IDE
text editor from github and if you want
to to beautify your code your solidity
code you will have to install a package
in atom and this package is called I
don't remember the name yeah it's a
language - Assyria you can install for
you a plug-in that produce if I your
solidity code and if you use IntelliJ as
as an IDE as your IDE you can install a
plug-in that is maintained by the
community that is cold
including plug-in here solidity
it's called individual region IntelliJ
solidity this plug-in is quite
interesting because of course you have
all the other things
beautify you can also you have the the
auto completion that is quite
interesting but of course you can use
the power of IntelliJ to navigate
between your spoiler alert or showing
the full contract sorry
spoiler alert you try any full contract
okay anything okay so now we have the
environment you are ready to create our
project our effects project I don't know
if you
we are we allowed to use this name so
ask for forgiveness
alligator permission so first I have to
create a folder of course call it a box
and then I have to create a structural
form for my contract
hopefully truffle is providing a kind of
boilerplate for you kind of start a
project that that you are that you can
use to create your DEP if you create if
you want if you just want to create a
smart contract work without any kind of
front-end application you can use the
command truffle in it shuffling it will
create a project structure but just to
just for your smart contract but here of
course the plan is to create a real
death with the backend part and a
front-end part the backend part we will
be your smart contract the frontal part
will be your the the web application
that will be used by your your users and
there you can use any I mean any no you
can use some of the front-end frameworks
you're used to it react or angular or
view Jas or whatever well some of them
are clearly more used than others but
yeah there are boxes because that's the
feature that's going to be used for all
those different frameworks so here I'm
going to use a simple box and this box
is called pet shop so it's uh I'm sure
you've read that or use that somewhere
the pet shop application ketchup
application it's a it's a jQuery based
application so to create the starter
program I type travel unbox pet shop so
here is creating the structure it's also
setting up the NPM environment so it's
downloading all the dependencies and you
know how empty it gets downloads the
internet so yeah it's just to show you
the process but
so I'm going to truffle framework boxes
and as we see there are plenty of boxes
available for you about for react a box
integrating of the authentication
mechanism but a box with the reactant
new port such as it's kind of an SSO for
the blockchain if you want yeah the
patch of the ones that you are going to
use a bot that will allow you to create
a RC 20 token in order if you want to
launch an ICO so this is the thing that
you can use the web pack and you have
some contribution here for status for
angular 4 and for view for who I don't
know what was a lot a lot of stuff but
if you are brave you can create your own
box by using this blueprint and to meet
you - truffle ok so here the project is
created ok we can open it and that's why
we like also to work with IntelliJ
because the support for those front-end
frameworks is really good so you can
work with your smart contracts and your
front end at the same environment of
course you can do that also with a Dom
and so on but when you are used to to
IntelliJ well so it's better so before
starting coding we have to analyze the
folders that have been creating for for
us so far as creating these folders the
contract folders migration node modules
SRC tests and some some files so
contracts will be the folder that will
hold your smart contracts and you can
see here that truffle has created the
first contract called migrations so
migration will be used part by the
deployment mechanism of truffle to know
exactly which contract still needs to be
Royden watching so it's something that
is really related to the truffle and
migration will hold the configuration
file that will be used to deploy your
smart contract when when this my
contract will be compiled this file will
be used to deploy the the contract the
bytecode to to the to the SE ryeong load
deployment scripts basically so that's
where you specify which contracts should
be deployed in what order and some you
can configure how you deploy them and so
on non module so it's a no GS Thames
starts all the dependencies that are
required by your enrollment SRC will
contain all the files that that will be
required by your front-end application
so the CSS the font images JavaScript
this is where you will you will store
your business logic the html5 saw the
pet star J's and it's something that was
provided with the pet shops and simple
application and here enters folder test
this is where you will create installed
your test suite to to test your
application it will be illustrated by
Sebastian in the few nets and we have
here a file called vs configured our
JSON this is because a pet shop is using
a light server and light server comes
also with the processing so it's a
library that will optimize the realm of
your web application we have the package
that JSON where you will put your
dependencies and also to have some
comments for example and p.m. run dev
will start here the light server and and
this file is also interesting it's
really important for travel it's the
truffle de geus so truffle DOJ's will be
used for travel to to locate the target
our environment where to deploy your
smart contract
so here the Folies empty but we will
have to to fill it in a few moments so
that's it for the explanation of these
folders but now we have to create the
smart contract and we'll call it
conference so we create a new file on
the contract folders call it conference
the sol sol is the file extension for
solidity and then that's it let's start
the writing we have here to define a
keyword pragma so DDT we have here a
version 0.4 dot 15 ok and instead of
typing here class will type contract and
the name of the contract the conference
so here the the pragma directive it just
used to ensure that the smart contract
will be compiled with a computer we will
will with them to not break any rules on
on your contract for example here the
compiler that is below the version of
0.4 dot 15 of the solidity will not be
accepted and all version of the solidity
compiler starting from the version
ordered 5 will not be accepted to this
this is done to ensure that yozma
contract well will still work and we
still be able to be compiled so here I
have a contract called conference now I
have to create the state variables that
will hold my my data
so the state variable will be the
contract state and here I have yeah this
one so the conference will have to store
some information to identify at all
and this is what we are going to do here
so we will create that there what's up
in an interactive approach so the first
step will have to store at all and to
read the details of the talk the talk
will be identified by a name a title
sorry a location a title for example
just talk one a location room for a
start time and an end time that will be
a coded in a unit size it will be
compatible with UNIX timestamps the
number of seconds since January 1st 1970
and we will have one speaker per told
and the speaker will be identified by
its address and a name a full name here
you can see that in solidity we have the
the data table address that that is a
pretty wide value 20 mile value used to
identify the the public address of of
the accounts and here you can see that
it's quite similar to any any other
programming language just precision you
might hear us talk about addresses and
public keys interchangeably that's
because they are basically based on the
same information the address is a hash
of the public key so it's a shorter
version I would say of the public key so
we have strengths you you int and signed
int and of course solid it is providing
other kind of data types so we need here
to add at all and for that we have to do
to create a function that will be called
I'm told but I think that I already know
you have to that's the constructor yeah
start with this so the app dog we're
going to analyze this function so as we
can see it's a function and it's public
that means that this function can be can
be a cold mouth of the contract exactly
outside of the contract it will receive
a set of parameters a title a location
start time and time speaker address and
speaker name forgot this for for now and
here we are just assigning these input
parameters to my state variables this
means that this function it is changing
the state of my contract and it's really
important because you will see that if
you call this function you will have to
pay some gas
Agito and storing data in the state of
the contract is one of the most
expensive operations so that's also
something to keep in mind and of course
you don't want that anyone will be about
to add at all so this function will be
allowed only for the contract owner and
the contract owner will be identified by
this state variable variable address
owner so how to retrieve this contract
owner we will reach with this
information from the the constructor so
when you create a contract when you
deploy it to the shin the constructor
will will be called the constructor is
an optional function you can declare it
or not but here we are going to use it
in order to to keep to retrieve the
address of the contract owner and this
address is provided by this global
properties global variable school called
MSG dot sender you have a set of
variables but this one is really useful
because you will have the address of the
contract order so and this can be used
in any function that is non constants
will see the difference afterwards but
that's a from within any transaction you
can know which account triggered that
transaction and this is in the MSD
descender so here we know who has
deployed the contract who is a contract
owner and each time someone is calling
the adult we will retrieve the address
of the function color to see hey guys
are you the contract owner yes or not if
not so you are not allowed to to alter
the counter the state of the contract if
yes we will get all the parameters and
we'll change the contract it's instant
state okay so I told it's done so J of
course you as you see here we have only
one talk and one speaker so it's
basically meet up we'll add more talks
and speakers afterwards a new lock also
to retrieve the details of the talk so
here we have again a function it's
called yet talk it's public and we have
something new here constant constant
means that this function is not allowed
to change the state of the contract and
it's also mean that this function is
free you can use it without paying any
any gas and this function will return a
set of properties the title the location
start time and time speech address
speaker name the solidity supports
multiple returns yeah so that's it we
have a smart contract called conference
that has function that will after the
contract state a getter that we return
the detail of the contract and when we
deploy the contractual web we will
be able to identify the contractor owner
so I will say that from now that's okay
so we are ready to deploy it but to
deploy it we need here to create a
deployment file to inform truffle that
this file confirms that Seoul will have
to be deployed to to the to the to the
blockchain so here we have to create a
new file under migrations and this file
will be called to the naming is
important especially the prefix because
the way that truffle works is kind of
unusual for us Java guys but the
migration scripts are ordered so they
are run in sequence based on this prefix
and and then that's what is used in the
migrations contract to keep track of
where the last script was run so here I
have created another my Grosh falter a
file called to underscore g pro contract
that contract so again the naming is
important especially the prefix part so
yeah done and here we will inform
truffle that the smart controls that is
located in this file conference that's
all will have to be deployed that's it
and everything will be managed by
truffle so how so it's time to to deploy
so it will it will compile so dtc file
into a binary file create the
transaction with the network sign it
send it to the network everything is
handled by by truffle for us well well
but before deploying the smart contract
we have to inform the target environment
truffle here is providing a file called
truffle de Geus this is where you are
going to to store all the the target
enrollment for example here we have a
project that was able to deploy contract
in different environment for example a
development environment located in
localhost for 8545 or to the ring be
test public test network or also to the
live network to the main network an
interesting thing to note here is that
you can see that the the host doesn't
change it's always localhost and that's
a key difference with the the
environments you might be used to
because actually even if you're
deploying to the main chain so to the
production network if you want the host
you're deploying to is basically the
local node you're running on your own
machine and then it spreads across the
network automatically so our here I will
inform travel that the contract that has
been compiled needs to be deployed on
localhost for 8545 and it's a different
development platform so before to do
that I need to start test RPC a lot of
it's already started maybe somewhere so
just RPC if it's already started will
complain anyway so tests are PCs running
I go to here until eg and I will types
up some comment here truffle migrate
and we can see that truffle is compiling
the contract located under the contracts
folders and here it has deployed all the
other contracts the migration that is
used by truffle to better mind if
another contract needs to be deployed
but what is really important for us it's
this information here deep loyal
conference blah blah blah with here and
address here it's the edge code of the
transaction because we have sent a
transaction to the to the to the to the
ethereum notes saying hey guys I want to
deploy the contract and I will pass as
value the bytecode of of the of the
smart contract and this is something
that we have also to mention when we
build a smart contract
well we'll we'll create a byte code that
will be executed by the Italian virtual
machine and this bytecode is sent within
the transaction can you show the console
for test RPC yeah if you want to adjust
to the test RPC terminal we're not sorry
just switch yeah so here you can see all
the transactions has been been created
and how much gas they cost you know gas
usage and so on so that's also some
information you get from test agassi and
he treated for transactions one to
deploy the migrations contract when to
update the migrations contract saying
the migrations contract was deployed
another one to deploy the conference
contract and the last one is to inform
migrations that the conference contract
is deployed so this is the migrations is
like the the deployment state if you
want so now if we want to interact with
our smart contract we have to use a
console so we'll use the truffle console
here okay
maybe you can reduce show move up the
console no the I mean just reduce the
window or something yeah
before interacting with the contract we
need to getting instance of this
contract and here to get instance I have
to name my contract conference deployed
so just well is typing the the truffle
provide in addition to all those build
and test tools provides us with an
abstraction on top of the notion of
contract called truffle contract and
this is this abstraction that side is
using now to the deployed function and
all that is provided by the truffle
contract dependency there on hit ensure
I have a lob Jack that I can use to
introduce s-type just like that to show
that it's just a JSON object containing
the structure of the of the contract and
all the functions that you can call on
it and I think your screen is to begin
II to reduce

okay yeah so let's start by reading our
instance of the contract by calling the
get dog if I type up get dog we can see
here that we receive some information
but all the information are empty
because by default the the instance of
the contract are set to empty values for
example here it's normally it's the
total title description the start time
the end time the speaker address and
speaker name so this value are are empty
its default initialized if I want to see
the address of my contract
I can type conference that address and
have the contract of the contract this
is the address where the contract can be
found inside the blockchain and if I
want to add at all so I just have to
type the adult function so the first
permanent will be the tour title bulk
one for example before that I have to
create the start time and end time yeah
so L is doing that just to explain the
difference before you called yet talk
and as we defined it yet talk is a
constant function so it is just reading
States from the blockchain and it
doesn't need to send a transaction for
that it has a full copy of the of the
ledger locally so you can just see what
the data is in in the local instance
whereas here what we are going to be
doing is calling the add talk function
and the add talk function actually
modifies the state so we need to put in
a transaction to spread it across the
network needs to be mined and so on and
so forth so that's there's a big
difference it's kind of CQRS styles of
things there is a big difference between
reading data and modifying it
oh my god it's better time so here I'm
creating my start time just get here
number of seconds so I have here two
variable start time and time and just
another word of running also as you can
see here those two values string stuff
it's the start time and end time but an
unsigned integer in the context of the
the virtual blockchain sorry if your
virtual machine is actually a 256 bit
integer that's quite a huge and clearly
JavaScript doesn't have that kind of
data type so it's using a an alternate
data type called a big number and that's
his way of representing it's that's
basically like your your big decimal and
in Java or something so I'm ready to
call the at all so I need a tour title
location start time and time a speaker
address so I will use one that has been
generated by a desktop PC for example
this one okay and a name
John do I know that everyone is knowing
this guy so I'm ready to a call no
you're not ready to go no I'm not ready
it's called because if I do that the
problem is that we don't know who has to
pay for that you know the adult function
is a function that will alter the state
of the contract so someone has to pay
for that so we need to identify who is
calling this function and for that I
will add an additional parameter or call
from and I will say you remember that
the adult has is only allowed by the
contract owner right now I can
tell you that the contract owner is the
account zero so when you run truffle
migrate it will actually automatically
deploy it if you don't specify you can
specify the sender address in the
truffle dot JS file if you don't specify
it it will take the first account of the
note it's connecting to so here and test
RPC generated the ten accounts and we
can access them with web 3.8 eh that
accounts and we take the first one
because we know that's the one it was
that was used to deploy the contract and
we add that with kind of a JSON object
that is the last parameter so there are
many different metadata elements that
you can put in there here we just need
the from yeah so suspense I type ooh I
have a transaction so that means that we
have called the I told function and a
transaction has been created this
translate transaction needs to be mined
by the node and we have here the ash of
the transaction and we know that the
transaction has been mined it's located
in the block number five in the chain
data
it caused this case this number of gasps
sorry and that's it right now and for
that issue again you can specify that
but here it's using the default gas
price which is a 20 or 40 gigabytes I
don't remember anyway so the theorem one
ether is divided into 10 to the power of
18 ways that's the minimum unit of value
and there is a price in way for each gas
unit so that's how you determine the the
actual cost in ether sorry I'm going to
see if my contract state has been
changed or not I call up kettle and
voila so here inside the smart contract
somewhere in the blockchain the
State has been changed I have bulk won
the room fourth so the location has been
changed I have my start time end time I
have the address of the speaker and the
name of the speaker and remember this
this address you know wet 3et Ashe
account zero as you can see here test
RPC is creating for us 10/10 public key
and there are available here on the
console by typing web 380 H that counts
we have an array of this accounts you
can see that they are the same okay
hopefully and to identify the owner of
the contract you can type web 380 H dot
conveys and conveys is the default
account that owns the contract and here
the conveys or ether base in ethereum
it's their dress or 8 or 17 blah blah
blah and by default we always use the
first cancel unless you override it
intro for the GS turns ok so and of
course here you can retrieve information
from the get old can hear you received
here an array of information and I think
that can you can type get talk the
function beta so the truffle contract
obstruction uses promises all over the
place
yeah but when you return multiple values
from from a function then you can access
them in an array for example here I have
achieved the the position 2 of my array
and it's the start time okay so in
summary we have what we have done here
first we have created a contract called
conference we said hey guys the
recommendation is to use a compiler that
is compliant with the version of my
smart contract we have created a set of
variables this is this is the state of
my contract the first iteration of this
dub is to say we are just creating one
tool and to get the detail of this talk
so we have here a function called adult
that is public and this function is
altering the state of the contract so
we'll have to pay some gas for that but
this function is only a load for the
contract owner as the contract owner has
been stored when the contract has been
deployed we have retrieved the the
address of the contract owner and store
it into the owner address variable and
then we are able to retrieve information
from the smart contract thanks to the
function get dog if the function is
public and it's a constant that means
that I can call this function 1,000 or 1
million times I will not pay for that
it's free because it's a read-only
function since this function is not too
low to alter the the contract and we
have of course here created a file to
see when we will deploy the contract I
need to retrieve the contract located in
this file and then
by default when I typed truffle migrate
please deploy the contract that I have
just built into the ethereum node
located under local host port 80 45 and
the pool this this node is the test RPC
that we have started doing before
that's so now we wrote our first smart
contract we deployed it everything but
it's very important to remember that
block chains are immutable so when we
when you deploy something when you
deploy a contract which is as I said
before like a web service of sorts to
the blockchain it's immutable so it
cannot be modified after it's been
deployed sorry I forgot to mirror on my
screen so it cannot be modified after
it's been deployed so it's very it's
even more critical in a blockchain
environment to actually test everything
that you do before you go live and
that's what we're going to see now how
do you unit test such a contract so
that's exactly the contract that say it
showed you and I'm gonna show you how to
test it so there are mostly three
strategies for testing small contracts
of course you can run unit tests and
usually you do that on test RPC you
don't want to be running unit tests in a
main chain because then you will pay for
running your tests and then you will not
do it which is bad so let's do that on
test RPC
once you have unit tested your contracts
you can also integration test them and
you can do that either on your own
private blockchain so you can create
kind of the your own development Network
if you want or you can do it on one of
the public test chains so the theorem in
addition to the main chain there are a
certain number of test nets that you can
use that our public that you can share
with everybody so when you deploy
something in there the ether is not real
again it's fake money but but still you
can deploy your contracts there and
share them with your friends
for for user testing for example and now
what we're going to show you is how to
do it on test on PC again when you do it
in test RPC there are when you unit test
your contract you can do it in two ways
either using Java scripts and that's
what we're going to do you can also use
solidity so you can have a contract
that's used as a test that calls your
contract but that technique is kind of
new and not very well documented so far
so I'm gonna focus on on the JavaScript
part what else would I want to say yeah
so the first thing we're gonna do is
just start to star PC again so I'm going
to front machine so I'm doing it
directly in there okay
again 10 new accounts the the accounts
are random by the way you can start the
stuff we see with some common line
arguments so that it always creates the
same accounts which can be practical in
some in some ways but yeah so test
obviously is running in the background
we don't need to care about it for now
now I'm going to create a new test in
that test folder and that's gonna be a
JavaScript file so just call it
conference conference test dot J s okay
and there we are going to copy some code
so show you what it does same thing as
in the deployment script we need to
import the conference smart contracts
the source just to let know to let refer
know that it needs to compile that and
it needs to deploy that before we can
run the test and then truffle integrates
with mocha and chai so I think it's
mocha for the test framework and chai
for the assertions or something like
that yeah and and you can use just that
for testing your small contracts so
instead of having a test here we have a
contract directive that takes the just
the name of the contract that we want to
run this can be anything but
the name of the contract and the
function that will be used to test takes
a list of accounts and parameter and
that's the accounts that are available
on the node that we are using and this
is very useful because when we will test
some actual calls with transactions
we'll need those accounts to send I mean
to pay for for the execution of those
functions then we use actually it's for
Casey here conference that deployed same
thing as we did in the traffic console
it's really the same instruction then
function we get an instance and then
once we have an instance of a deployed
contract we can call the get talk
function on it okay and then in the
return and by the way this when you when
you call a function that triggers the
transaction this then is only executed
after the block has been mined here
there is no block that needs to be mined
because it's a it's a constant function
and then we can use asserts just to
check that theoretical values match the
real values that we get okay and that's
really all there is to it now that we
have that we can go back to the terminal
open a new window and here use truffle
test and what truffle test will do is
compile the contracts that have not been
compiled in a while
deploy them to the to the I mean to test
our PC in our case and and run the tests
and it will redeploy the contract for
every test suite and it's a suite is
just one of the JavaScript files so you
can have several test cases in stage
suite and each test suite gets a a blank
slate in terms of state so here I'm
running truffle tests it compiles the
contracts and deploys them and here we
have conference is not defined yet
because I was actually using the wrong
case in both so now I can run the tests
again redeploy the contracts and we
could we have a passing test yay
first one so and here of course if I
check for example for a non-existing
value and I run the test it will fail
and sometimes the error messages are
very useful sometimes they're a little
less than that but still so the test
passes now I want to show you how to
test the add a talk so for that we'll
add a couple of variables to our tests
so inside of the contract structure I
will add a couple of variables okay so
we'll use a variable to store the
contract instance want to store the
owner of the contract just all over the
the fields that will pass to the get to
the at talk function and that's
basically it
okay so now we can add a new test case
to the test suite right after here okay
so let's go over it this one will test
what happens when we add a talk so again
we'll need to call a conference that
deployed okay and then we get an
instance that's always the same
mechanism this time we're saving it and
then on it we're calling contract
instance that at talk okay with all the
values that we've defined above and the
special parameter at the end that we use
to specify who we want to deploy the
contract and in that case that's the
owner which corresponds to the first
address of the first account okay when
we call the add talk function we wait
for the block to be mine so again this
abstraction make sure that we only get
notified when important information is
available
so once the this transaction has been
triggered and mind then we can query the
state of the contract by using contract
incidents that get talked and then we
should have all the same
you as we had stored okay so pretty
straightforward by the way you can see
that I can use the two number function
on the big number to transform it into a
JavaScript number so that I can test it
of course I take the risk that if my
number is really big then I'm going to
lose some information but here is just
the start time and end time should
be good okay I'm run truffle tests again
and here we have two passing tests my
god I'm on a roll this was not prepared
at all of course and that's it that's
how you unit test your code so the end
smart contracts is really important to
test them once you release them into the
wild then your if something happens
you're screwed by the way something like
that happened in June 2016 some
contracts were poorly tested and they
were released in production and it
resulted in fifty million dollars being
lost or something
so yeah unit tests are your friends now
the other thing I want to show you in
addition to test is how to get notified
when something happens in your contract
so with events your contracts can
communicate with your application with
your especially with your front-end so
let's say for example I'm running the
front-end I'm going to show you later
and somebody adds a talk I would like to
be notified so that I can reload the
screen and show the ad talk there is a
way to do that in solidity it's called
events and what's important to
understand that events are actually like
logs so they are added to the blockchain
but not they are not part of the
blockchain state they are in a different
data structure in the blockchain that
you can watch for events and interact
with but only external account sorry
only external applications can view
those events contracts themselves have
no access to them they can send events
but then they don't know who is pressing
is processing them and so on and more
importantly they cannot watch events
okay so here we are going back to our
conference contracts
and we are going to define an event that
will be used to notify Watchers when a
new talk is added so to do that I'm just
going to go right here and add this
event so that's the way you declare an
event with the event keyword that's the
name of the events and then I can
associate a couple of fields to my
events and that will be useful for the
Watchers to know what what happened
exactly
and that's it for the declaration now of
course I need to use that event and I
will do that directly in the ad talk
function so once the ad talk function is
successfully saved everything I can go
there and call the ad talk event and
pass it the title the start time and the
end time and that's it when I do that
there later I can watch this event and
and react on it okay I will save this
and I will redeploy this contract now
they start fishing still running in the
backend it's in memory but it's still
running in the backend so it still has
the old versions of the contracts
deployed and we actually already run
both migration scripts one and two okay
so if I run just truffle migrate now
which I will do okay if I just want
truffle my great actually sweet do we
need way because I changed the contract
and it detected yeah okay so if I just
run after the contracts have already
been deployed it will say okay network
is up-to-date
I already run both migrant migration
scripts as confirmed by the migration
state so it should be good if you want
to force the latest version to be
deployed you have to use - - - reset and
then will force everything to be
deployed again
okay now contracts are deployed and
everything so I can run traffic console
again
okay just push that up a bit and with
that I will be able to interact with my
contract again so the same thing as
before we started a new console here so
we need to get a new instance of our
contract conference deployed then
function instance of equals instance
oops yeah I made a steak I thought there
was one too much disease yeah that's it
okay
nope that's better okay so now we have
app that contains the interface to our
contract and we can actually watch our
events so for example I will add app
Talk event okay so I want to watch this
event and then so this is the way I get
the access to it event and then I call
the watch function on it and this will
have unfortunately that's not very
consistent here it's a good old error
data callback it's not a promise and
here I will just console.log it that's
one of the main difficulties when you're
working with this set of tools right now
it's still very inconsistent sometimes
you have promises sometimes you have
callbacks sometimes you have nothing and
yeah it's kind of frustrating but you
get used to it and the things that we
can add to the document is a way to
filter which events we want to watch so
you can use a first object that can be
used to filter on the values of the
field that
we have added to the events here we'll
just take all events and you can also
say the which range of block you want to
of luxury that you want to observe so
here we want to observe only the latest
block and not the whole chain okay I
don't think this is right is it
yeah should be okay we'll see so now
that we have that let's recreate our
start time equals new dates okay stay
here whatever just keep it that way
yeah that's a start time and we'll do
the same for end time let's say we have
a talk that lasts a full day come on and
then we can call the at talk again
okay so let's call it talk one it will
be in room one start at start time and
at any time I can use one of the
accounts you can change your own
terminal just or just by using what
three th accounts oh yeah all right
Group three third ETH accounts six for
example over here so that's my speaker
address and then my speaker name John
Doe again of course I need to specify
from which account I want to send that
and that would be web 3.8 eh dot conveys
accounts one of course I can do that
right wink wink so it sent a transaction
but we see that the logs are empty so no
event was triggered and we didn't get
the call back either okay so that's the
kind of thing that can happen you have
something that gets an error but you
don't get any obvious sign that
something wrong happened but here
something wrong obviously happened
because we didn't use the right account
to send a transaction from and when you
do that oh we get a transaction and an
event so this time I'm just going to
show you again the okay
so here what you can see is that after
we called the function here okay so this
one will send with the account 0 we get
the transaction receipt with the
transaction hash all the data we have
some logs and logs contain actually the
events that were triggered inside this
transaction and here we have the ad talk
event type and since we registered a
watcher on the on that event we also
have a console log afterwards that
contains exactly the same thing as the
logs here and gives us information about
a talk event and we have the arcs that
contain the values that were sense with
the events okay so that's how you can
watch an event and later on you can do
that also in JavaScript
in your front-end to be notified when
something happens by the way this
mechanism of events is very important
because you've seen that we used returns
for constant functions but there is no
way to return anything from a
non-constant function so when your
function is actually modifying the state
of the of the blockchain it does it in
an asynchronous way so you need to send
a transaction transaction needs to be
mined and so on so you don't have direct
access to the return values yet they are
incremental e adding this kind of
feature to the to the language and to
the EVM but for now there is no way so
events are the only way by which you can
make sure that you get some some real
value okay now that we have added this
event as I said before we need to test
everything so let's go back to our
conference test and we'll add a new test
case that will test that an event is
currently trigger when we call our talk
okay so this will be
okay so same thing as before here we'll
just we just call in conference that
deployed definitely need to change that
later on we just need to call conference
that deploy to get a deployed instance
of our contract we call the ad hoc
function again from the owner same as
before but this time we get a function
receipt so earlier we didn't we didn't
use that yeah here we didn't use it okay
but now we can access the transaction
receipt and this transaction receipt
among other things contains a logs field
so we can check that we indeed received
just one event and we can check the data
will the name of the events and the arcs
of the seventh okay when I do that go
back here actually we'll open a new
terminal and run truffle test and we
have three passing tests so that's it we
show you how to unit test your smart
contracts and how to use events to get
notified this will be very important in
the front-end later on and I think the
next step will be to show you how to
register to register an attendee but
would probably do that after the break
right now
15 minutes break so 15 minutes break
let's come back at 11:25 or something
and and then we'll show you the rest
before we start again I just wanted to
answer for everybody one of the
questions that we had at the break
because I realize now that can be
disturbing when we when we run a
transaction when we call the add Talk
function we specify the account we send
the transactions from okay and we just
indicate the public key the address of
that account you might think okay but
then that means that anybody can call
this function without any other form of
it but I'm taking the authentication
well actually not what happens behind
the scenes that we are using test our PC
and test our pcs development environment
it's an emulator so by default all the
accounts that are created for us the 10
accounts are created for us at the
beginning are unlocked all the time ok
so you don't need to specify any sort of
authentication it can use the accounts
directly on a real chain all these
accounts would be locked with a private
key so you need to have access to the
private key in order to be able to
assign the transaction and then to call
the function and of course we you cannot
pass the private key directly as a
parameter that would be a security issue
a security risk but what you can do is
unlock the account before sending the
transaction and you can do that with
some commands in a trifle console for
example and and then after that you can
call the function and it will use the
the private key to sign the contract the
local so that's also something I wanted
to clarify so now we are going to show
you how to register attendees for our
talks which will be useful because if
you remember people will be able to
register using cryptocurrency ok so in
this step we are bigger we're going to
register an attendee why because here we
are creating a voting system so you guys
you will be able to vote for a for talk
but the the requirement is that an
attendee has to pay a fee to attend the
cont
turns so to be an attendee you have to
pay fee for the conference this is what
we are going to to implement soar here
we will see an interesting notion called
the value the value that will be sent
with the transaction so here we'll start
from this version of the project we have
the death toll and I get all can the
events and the testing that's great and
now we are going to create a payable
function called register will see what
is a PayPal function so here I'm going
to create some variables - for the first
one will be used to hold the address of
the attendee so your address your
ethereum address the public address your
name and here we have a constant
variable that will hold the price and
you can see here that the price is not
expressed in in ether but in way so
ether is is the the value that is used
in ethereum but inside the VM we have a
kind of metric system used to to codify
these these values and the base unit in
etherium is called
way you can use some website to convert
a an ether for example in way for
example one ether is I would say one
exponent 1810 1818 away so the
registration fee will cost the check one
point 1.8 ether and now we are going to
create the register function so here
it's just as a point of information as
of right now a theorem is three hundred
dollars when he forgives three hundred
dollars
so here the requirement is to say if you
want to restart to a conference you will
have to pay fee the registrants the
registration price and the value that
we'll send to the smart contract will be
must be equal to this registration price
and also you you you are not allowed to
register twice so will check if you are
not already register to the conference
and then if everything is okay we'll be
able to alter the state of the contract
as you see okay you are allowed to
register to the conference and here we
have a new function called register and
if we check this function it will
receive only one parameter the full name
and here we can see that it's a function
called register with parameter the
function is public and we have something
new here payable payable means that this
function is allowed to receive value is
allowed to receive money from the
function color for example at all here
it's a function public function but it's
not allowed to receive any value from
from the function color and it's
important to understand that this value
that you can send to a function call is
separate from the gas ok the gas is the
operational cost of your call but here
is really a payment that you can
associate with your call so here we are
using the equal function that will
ensure that the value that you have sent
is equal to the registration price that
is the constant that we have defined on
top of the code so here we have another
global value that is provided in the in
our code you remember the message that
sender that contains the address of the
function color and here message that
value contained the value sent by the
function color color to the to the to
the
so here if it's okay great we can we can
render that the next line and here we
will ensure that the message sender is
not already registered so again this is
a small conference one talk one speaker
when you call attendee so it's really
sad
it's my star turtle is an MVP okay later
on we'll add more registers and if the
rules are okay so you can store the
message sender to the attendee address
the foo name in the attendee name and
then - to trigger an event a register
event so I have here to create this
event okay so I have an event called a
register event that will that will
provide the address of the the attendee
and his name okay that's it I'm just
yeah one thing that he didn't show you
is when you when you specify the
arguments of an event you can mark them
an indexed and when they are indexed it
makes it faster and easier to filter
events just by this value so for example
if you want to filter events that are
reduced where a specific attendee
registered then you can use this indexed
argument and here we are also to create
an additional function constant function
so a function that is free free of
charge
and this for chun is called is
registered is register will be used to
know if you are already registered to
the to the conference or not and here we
received an address and that is the the
account your account for example and to
check if this account is already
registered or not for example this this
this function can be used by the the
organ organizer of the conference just
to to check if you are if you are
already registered or not
and that's it if you are not registered
it's return false otherwise it returns
true when also another thing that is
important you consider this require a
call that's also something new it's
basically like an assert it's provided
by by solidity and what it means is that
if the condition is not verified then it
throws an exception and that will be
somewhat better than what we had before
when you remember in the ad talk if the
owner of the contract was not the
message sender then we simply returned
and we didn't have any exception as you
saw we just had a successful transaction
with the exception the transaction will
actually fail and we'll get an exception
so this require thing is is important ok
that's it we can build and deploy this
version of our contract in this terminal
I have start test RPC and here I'm going
to migrate my contract migrate
and check here okay the contract has
been deployed and then I can open the
console refer console I will get an
instance of my contract
okay and now I will I would like to
listen for my my event just to be sure
that the register has has been done
properly so how will create register
event variable I'd like to hear for my
event this one so what is doing here by
recording the reference that's registers
return from the watch function it's just
a way to keep a handle on the event so
that you can unwatched later it's also a
good practice especially when you're
running this from the front end to not
watch event all the times because
otherwise you can you don't know what
happens if you're not there to listen so
yeah then later on we can use register
event reference to and watch the event
and here I will filter my event for the
account 3 because it will be the account
that I will use as as the the attendee
of the conference watch and you don't
you arrange sorry no range of blocks
okay you are not obliged to specify a
range by default it will be from letters
to to latest so here is using the filter
parameter that we left empty before now
I will display my event here event okay
first time so now I'm ready to register
the account 3 but before doing that
we'll check the balance of this of this
account so I will call this function web
3 ETH get balance for the account with 3
that ETH that accounts 3 and we can see
here that
the account 3 has a lot of weight a lot
of way that's the problem and so all the
unit's manipulated by the the contracts
are also always in a way and fortunately
for us there are a few functions that
are available on the web 3 library that
allow us to convert way to ether and
ether to weigh its own so I'll always
remember that because sometimes you're
you don't understand what I I send one
ether to my contract and it's not
working no because you send one way it's
not enough and here I have used web 3
from way for the balance so I can see
that here this function is converting a
way to ether so I can see that the
balance of the accounts 3 contains 100
ether so can you check also the the
balance of the contract yeah so the
that's also an important thing to
understand is that every accounts that
you create has a balance an ether but
every contract also has a balance so you
can actually send money to a contract
and that's what we're going to do with
the valuable function so here we can
just call the get balance function on
the contract address in the same way as
we did it for for a real account I mean
for an external account as it's called
and right right now the contract has no
ether in its balance
now I'm going to register this guy so
register I have to give a name so Rick
the cart plan to attend the conference
and the attendee will be easy again 3
yeah and here we have to pass another
parameter called value this is the value
that you are willing to pay that you are
willing to send to the to the
transaction and here remember the
conference cost one put on eight ether
so I will use here web three two way
because I don't want to write this value
in way I will type 1.8 and to see this
value is given in ether yeah okay
register read the card from a country
I sent 1.8 ether from my wallet and I'm
ready to go and you can see here we have
received an event this event is called
has been triggered by register event and
the address of the attendee is oh it's 8
5 blah blah blah and the name is read
the card if I check here my you can just
call it back now you can just going back
with the upper rows you want to show the
balance yeah you can just of course so
if I change the balance of the account 3
you can see here that we have paid
something so 1.8 ether for the
conference and some additional ethers
for for the guests in order to to to
validate the transaction and if I want
to check the balance of the contract
here we can see that the contract has
received 1.8 ether ok so now if we want
to be sure that everything is done
properly we have to add some testing we
have to
prove the test in order to be sure that
everything is okay so I will take this
file confirm test and I will add some
additional parameter for judging to make
it bigger so here I will add some
variable the registration price the
attendee here I will use the account one
while it does not matter you can put
three if you want a full name and we
will check the balance before and after
the call and at the end I will add my
new test case so here we will check if
we can registered to a conference so we
will get first we'll get here the
balance before the call we'll get the
balance for the attendee and for the
conference and we'll keep it in these
variables so balance certainly before
can't write before and then we will try
to register this this attendee this this
account or providing the the full name
and then here the second part is to is
to first we call their register and we
want to be sure that an event has been
triggered by the function because as you
can see here if the event is triggered
that means that everything has has been
executed properly because it's the last
instruction of your function and if if a
required condition is not met and it
throws an exception and of course it
interrupts
the kitchen of the of the of the
function and even better than that sits
transactions are supposed to be atomic
it reverts all the change all the
changes that you already did to the
contract State so it really goes back to
how it was before the only price you
have to pay if you want is the gas up to
that point so if there is some gas
consumes before you throw an exception
then this gas is lost is it go it's lost
it's not lost for everyone it's actually
paid to the miner who mined the block
containing that transaction but that's a
price to pay for throwing exception if
you want so here I have received my
register event I checked the address of
the attendee and the full name just to
be sure that everything is has been done
correctly and then I will call here I
will check if the attendee is properly
registered so I will call the constant
function is registered and normally of
course the value should be true and here
we will check the balance after the call
so we will retrieve the balance from the
attendee from the conference and we will
make a check just to be sure that the
assertion is is correct and here you see
that the test is using so for the
contract balance it would be exactly 1.8
ether because that's what what was sent
by the the attendee but the the balance
of the attendee itself is less than the
amount he paid I mean it's a hundred
minus 1.8 to pay for the fee minus a
small amount for the gas and this amount
is kind of hard to predict because it
depends on the complexity of the code
that was effectively executed so this is
kind of a loose test to make sure that
it's yeah the comparison is okay so
let's try let's test our project
trifle test suspense great we are able
to register an attendee cool magical and
the the last step regarding the
registration is that you Europe you can
also test the exception for example here
you can add another test suite called
Conference exceptions that GS and this
guy is this one okay what we're going to
do here is to a simulate an error and
here we're going to try to register an
attendee but with the wrong price as you
can see here we should receive an
exception if we receive an exception and
in our case because we are using require
so if we receive a revert from the
contract that's okay this means that the
smart contract is processing the
exception properly but if the function
has managed the call I will say and it
was about to register the attendee it
means that will be in the then section
and that's not okay so we have to to
fail the test case by the way and
something that might be disturbing also
for you Java developers in the room when
you throw an exception in Java you can
associate a message with it not in
solidity not yet not yet it's gonna come
but it has a cost in terms of
development and stuff so actually the
last hard fork that happens two weeks
ago is going to enable that but for now
the only thing you know
that something happened and then you
have to figure it out by yourself by
using console logs and stuff or by using
some debugger that's also been released
recently so as you can see your
something that our myth missing but at
least we can test that an exception
occurred now I can run truffle tests a
tougher test will run all the tests
sheets that are available under the the
test folders as you can see here of
course we can add at all register an
attendee and we can also where we have
verified that if we try to resist an
attendee with the wrong price the smart
contract is working as expected and well
you can if you want you can execute you
can test a specific test suite for the
truffle test from this folder Conference
exceptions by providing the name as an
input parameter it will run only a
specific test read so that's it guys you
are ready to attend the conference and
to to vote we have a question here why
don't we need to oh yeah
good question well just to show you that
you can yeah mostly you can define a gas
or you can use the default value well
what's important to understand here is
when you specify the gas it's not the
real gas it's the maximum gas you're
ready to spend yeah so by default when
you send when you call a contract like
that truffle will insert a default gas
value and again that's a max that's not
the exact amount because the exact
amount is unpredictable thanks to them
some algorithmic T theorem I won't go
into it's impossible to predict the
complexity of some of running some code
in the dance so here is just a way to
say okay for this
call I'm willing to spend use 500,000
gas units right now if we go over that
if the execs equation of the code
reaches that limit it's like it will
throw an exception indeed so all the
state will be reverted and if I added if
I send some value along I will get it
back but I will pay the gas anyway so
that's a way again the the the gas
mechanism is a way to avoid spy spamming
the network if I didn't have to pay for
exception throwing then I would just I
could just send invalid transactions to
the network all the time and I will I
would spam the network with invalid
transactions so it's a way to
disincentivize wrong transactions it's
really interesting question for example
here I have simulated an error I've
provided the gas that is really really
low 1000 and when I try to run my might
this case it tell me well something
wrong happened but here I want to know
exactly what happens so I have used
console.log and to display the error and
the error message is this view exams
game gives me base fee it says yes limit
and it can be it can be a way to
identify how many gas gas will be
required by by your real function for
example okay so that's it so when you
specify by the way again this is a
maximum so if you specify 500 thousand
and only a hundred thousand is used you
get the 400 thousand back it's really
just a way to to protect yourself
against infinite loops and stuff like
that okay so now we have one attendee
one speaker one talk it's time to boost
our contract and make it more useful by
adding the possibility to create and
retrieve several talks because usually
in a conference you have several talks
okay so first of all we'll add the
possibility to keep track of several
talks in the contract stay
and we'll modify of course the our TOC
function to update that list we'll
retrieve the list of ID's for each stock
and for that we'll demonstrate the use
of structure types and mappings so
structure types are a way for contracts
to is a screen so structure types are a
way to keep the fields that are related
to a single entity together okay so as
we said before a contract can be seen
like a class but it's really not it's
just the same level of abstraction I
would say and structure types are just
like structs in other languages it's
just for storing data
I mean data objects if you want and
mappings are kind of like hash maps in
Java so they're associative arrays where
you can associate a key to a value but
you will see that they have some
specificities in solidity but first of
all we will clean up the contract a
little bit because there is kind of
mixed responsibilities in there if you
remember early on we used in the add
talk function here we use this this test
that checks if the message sender is the
owner of the contract and if not returns
what we should do here is actually
require use the require function so that
it throws an exception that's one thing
and another thing is that this has
nothing to do with the business with the
business of our function it's mostly
authorization code so we'll put that
somewhere else where it's more adapted
and where it can be reused and for that
we'll use a new feature well it's not
new in the sense that it's been there
for a long time but you will show it to
you
it's called modifiers ok so here inside
the the contract at the beginning I will
add a new modifier that it's called only
owner
okay so modifiers and solidity are kind
of like very very
aspects okay there a way to surround
your function code with some other code
and do it in a reusable way so here the
only owner will check that the message
sender is the owner of the contract if
not it will throw an exception if this
passes then we use the underscore
character here to represent the code of
our function okay so I could also do
something after so it's really like
again a very simple aspect okay and this
is a reusable authorization modifier
that I can then apply to every function
that needs it so for example in the ad
Talk function we will remove this test
now and here after the public will add
the only owner modifier okay so that
will apply our modifier to our function
quite literally the that is that the the
compiler will add the code of the
modifier injected into the byte code of
our function okay so it's very very a
roll like that and thanks to that if we
try to call add talk from another
account than the contract owner then it
will fail we'll get an exception okay
now another thing that is important but
I mean it's an occasion to show you is
that this authorization pattern is
actually quite common and yeah there are
a lot of situations occasions where you
want to check that the color of a
function is really the one that deployed
the contract so to do that to make it
more reusable even we can use
inheritance so yes solidity supports
inheritance and it supports multiple
inheritance so one contract can inherit
from several other contracts here who
will create a new contract called
ownable
no don't want it okay and I will
actually replace the code so again same
thing we specify the the pragma for the
solidity compiler version and then we
keep track of the owner address in here
okay in the in what we will use soon as
the support at the superclass we declare
the on the owner modifier right here and
we also declare the constructor of our
ownable contract that will register I
mean keep track of the owner of the
contract okay and then inside conference
we can modify the conference contract to
inherit from ownable but of course here
it doesn't know what ownable is because
we need to import that contract so here
at the beginning we can just add the
import honorable that's all it's in the
same directory so it's just a way to let
him know and then we can say conference
is honorable thanks to that we can
remove this state variable we don't need
to keep it track of it here and that's
pretty much it I think yeah we can we
don't have any constructor here but
since it's it's the same as Java to some
extent there is a default constructor
that's going to be generated for us by
the compiler and it will call the super
construct a constructor automatically so
it will keep track of this owner state
variable okay and I think that's it so
now we didn't change anything to our
functionality so truffle test should
work just the same and it does okay so
would actually add a test case now that
checks that an exception is thrown when
you try to call the at talk function
from the wrong account but we'll leave
it to you as an exercise now that you
know how to catch exception in you
t-test and so on so now that we've done
this little bit of cleanup let's
actually make it possible to store
several talks in our contract to do that
we will define a new structure type so
we'll do that at the beginning of the
contract okay actually two different
types one for talks and one for speakers
okay so talks will contain the title
location start time and tank I added
this cancelled field that's going to be
used later and a list of speakers an
array of addresses okay and the ID is
new it's just a way now that we will
have several talks to uniquely identify
each talk will have also a structure
type for speakers with again the address
of the account and the full name and
this time the full name will store it as
a bytes 32 yeah before that it was
stored as a string and by 32 is a
special datatype in in solidity that
contains a fixed size array of
characters okay so it's always going to
be maximum 32 characters whereas a
string can be a variable size array
again one thing to understand is that we
are running in an environment where
every byte counts every data that you
store in the contract States has a cost
in terms of real money so it's very
important to choose your data types very
carefully and here we're using buy
stores too because we know that the full
name of a speaker is never going to be
that long and also because there are
some limitations in solidity that
prevent us from doing some things with
some data types and especially returning
a viable array of viable size types is
not allowed yet so that's going to be an
issue for later
okay so we have both our structured
types and now we will be able to store a
collection of talks we'll do it for four
talks speakers it's the same logic
afterwards so to do that we'll add so
first of all we can get rid of those
variables for speakers and talks will
keep the attendee stuff for now okay and
here we'll add some variables to keep
track of things this was before so now
we added three state variables okay
talks speakers and total talks for that
we're using the mapping type now as I
said the mapping type is an associative
array kind of like a hash map where you
can associate a value to a key the value
can be any data type including a
structure type which is what we used
here and the key can be anything that is
unique of course and here we are using
integer IDs for talks and we're using
the address of the speaker four speakers
one thing that is important to
understand and again it's a little weird
is that mappings are associative arrays
but there is no way to check if a key
exists if it's been assigned a value and
there is no way to iterate over it as a
consequence of that okay so the only way
to know which talks exists for us will
be to keep track of the number of talks
and then we know that every ID from one
to the number of talks has been assigned
and the others when if we try to for
example if there are two talks and we
want the title of the third one we'll
just get an empty value not know not an
exception just an empty value okay so
again that's a weird thing in in the in
the in the e/m but that's something
that's necessary because of how it works
okay now that we've
that we can modify the the ad talk to
take that into account actually I will
completely replace this function here
some room for it so we have the ad Talk
function it takes the same parameters as
before at the beginning the title the
location the start time in the end time
but this time it's all can have several
speakers
unfortunately there's one thing that we
cannot do with solidity yet is to send a
parameter that is a list or mapping of
structure types so here we can only send
a list of primitive types and in that
case that will be addresses and bytes 32
okay so we have to space it as different
arrays and then we'll have to check that
those arrays have the right size and so
on it's again using the only owner
modifier that we declared in the ownable
superclass then we check the input
values using require so we check that we
actually have a title that the start
time is over is above zero that the end
time is after the start time and that we
actually have some address with some
addresses for the speakers again
normally you would also have to check
that the array of speakers dresses is
the same size as the array of speaker
names and so on and so forth but you get
the gist then once all the input
parameters are okay we first increment
the total talks counter because we would
use it to assign some real values to our
mapping and again a mapping is just an
associative array so we can just do this
okay so talks I pass the key and I can
assign each field of my structure type
by the way structure types are syntactic
sugar added by solidity but the EVM as
no
knowledge of it which is why there are
some limitations with it and that's it
and then we iterate over the speaker
addresses array and for each one we make
sure that there is an address and that
it's not new and and then we again
create a new speaker with this data and
we add it to the talks okay so we
establish this many-to-many relationship
between talks and speakers and when
everything works then we can trigger the
add talk event but this time we pass
another parameter total talks that will
correspond to the ID of the new talk
that was added so that means that we
need to update the the event as well so
if we go up a talk event here we will
need to add you int indexed I ID okay
and this way we can passed the ID and we
can even again filter events on a
specific value of ID okay last thing we
want to do is to add actually a couple
of more things is to add a function to
return the number of talks okay so get
number of talks is a public constant
function that returns an unsigned
integer simply returns the value of
total talks by the way this could have
been replaced by simply declaring the
state variable itself here as public if
you do that then the compiler will
generate a getter for this viable just
together
no setter there is no way to modify a
contract state variable in a generated
function of any kind and only in your
functions that you define yourself okay
in this case I will just use my my
function here because I want to change
its name of the waste has the same name
as the so it will be called total tox
and that's it now of course I have to
change the implementation of get top
okay because it those variables that
returns the don't exist anymore
and here again we are limited by what we
can do or not do with solidity we cannot
return an array of structured types
because again that's because the EVM
doesn't have any knowledge of structure
types this is something that will change
soon normally in the next version of
solidity there should be some some
changes to that but yeah for now it's
not possible and so yeah again this
function just talked it just takes the
talk ID as an input parameter and it
returns all the values so we cannot
return a structural type itself so we
cannot return talk here we have to
return the unpackaged version of it okay
so we check that the stock ID
corresponds to a talk we could have done
the same with just checking that talk ID
is less or equal than total talks for
example we check that the talk has not
been cancelled and then we can load this
talk so within solidity we can use I
mean inside a function we can use
structure types however we want so we
just load it and this memory thing is
again very important so by default when
you load something from the contract
state you actually load a reference to
the contract state ok and it's different
than if you want to modify it in memory
and here we just want to return it from
memory okay we don't want to take any
chance that will modify the state so we
just load this viable from the contract
state into memory and then all the
subsequent operations on talk will be
a little cheaper because we were
manipulating memory instead of contracts
instead of blockchain persistence if you
want so here we're loading this in
memory we're doing the same for the
speaker's address and speaker's name and
here we are actually assigning I mean
creating new arrays with the right size
and we are iterating over the top
speakers and assigning them to copying
them into our arrays that then we can
return okay so we turn take took title
location start time end time and those
two arrays that we've just built okay so
now that we have that again it's a
constant function doesn't modify the
state and we're good
the last thing that we want to do I
think yeah so here we have a function to
return the details of a talk now we need
also a function to return a list of
talks actually what we will do again we
cannot return I mean big array of
anything of unknown size so to avoid
that what we will do is return on our
list of IDs and then the front end can
iterate over those IDs and retrieve the
details for each for each talk you might
think okay that's clearly suboptimal we
are dealing with an N plus one situation
here and that's the kind of thing that
you want to avoid on database and you
would be right but here again this is a
constant function it's just querying
state directly from a local node okay so
the cost is not that big and yeah and in
that case we we don't have a choice we
have to do that so let's add this gift
aux function so here we added a little
bit of funky stuff to it to filter if we
only want Stephen the talks that have
been cancelled or not
so if you pass it false you will get all
the talks that have not been canceled
sorry and and it returns an array of
anti need teachers that corresponds to
talk IDs okay
of course this function call will only
be valid if we have some talks and then
we'll build an array of all talk IDs
that will be initialized as an array
containing total talks elements
unfortunately from within a so dtt
function especially when you're dealing
with an in-memory array you have to
specify the size again kind of
cumbersome at at the beginning but
that's the thing if you have to do so
that means that we will store some talk
IDs because we have to filter them
according to their concert state and if
we have some canceled talks and we only
wanted the non canceled talks then the
resulting array will be smaller than the
total number of of talks so we'll need
to do a little bit of algorithmic magic
to shrink the table after that so again
we check the status of the talks
depending on the value we get passed we
add we copy the talk IDs in our array if
number of talks is equal to total talks
it means that no talks was cancelled and
the array size is the same so we can
just return it directly otherwise we
create a new array a smaller one
containing just a number of talks that
have not been cancelled and then we copy
over very low level stuff very weird
stuff to do when you're used to more
expressive languages but still okay and
that's it so we could also add some
functions to for example returns the the
only the talks of a given speaker and so
on but again that's basically the same
logic over again so it doesn't bring
anything new to the table now that we
have that let's run for my great
for him nothing has changed of course
because the migration state said that we
already run all the migration scripts so
we have to run truffle my grades - -
reset to force the latest version of our
contracts to be deployed and it's
working and now we can run truffle
console actually you know what like that
so that you can see there okay so here
the same as before deployed we get an
instance of our deployed contract and we
save it in a local variable tick so app
contains our contract and then we will
add a new we'll watch the ad talk event
to make sure that the the event is
triggered correctly so far ad talk event
equals F dot our talk event dot watch I
feel that it now so here I'm not gonna
filter on values and I'm just gonna go
from block latest to block latest okay
and then in watch I get a function and
this function is an error and an event
simply console.log the events
unexpected string of course I made a
mistake
oh yeah to block to block I forgot the
Cullen there we go okay now let's do a
start time again
you did get time oops
okay and we'll do the same for end time
I will just be easier to use later on
okay and now we can add a top well
actually before I add a talk that is
just our speakers
it talks oh yeah I get to define a
parameter oh no that's not what I want
you to do get get number of talks so if
I call this constant function to get the
total number of talks I get zero okay
and now I can add a talk so I can call
the add talk function just remember that
I need to specify some metadata after it
so this talk will be called talk 1 it
will happen in room 4 start at start
time and at any time and here we have to
pass an array of speak your dresses and
an array of speaker names into it
directly here okay so for the speaker
addresses let's say that it will be 3
dot e th dot accounts 1
and with three the eth that accounts to
for example okay and the name will be no
Sayid that's the last one for example
okay and now in the metadata of course
we need to specify who is adding the
talk and here I will use web three that
ET h dot accounts one and you human
compilers will already know that there
is a problem if I do that I get a VM
exception and the VM exception in my
case just returns invalid of code
because I'm using an old version of it
of test RPC it should would say revert
trigger the whatever but just to show
you that here we have an exception and
that's it we don't know why we don't
know no math no error message nor
whatever just something wrong happened
with your code and of course if I run
now from account zero which is really
the account the contract owner then I
get a transaction receipt with some logs
and the log the event is log to the
console so I can see that I have ad talk
event it has an ID a name and start time
and end time okay so now if I run up yet
number of talks again everything works
and if you get talk one we give the
details for top one
and yeah I think we wanted to show you
more like how to register
I mean how to reward speakers and also
the front end but we won't have time
it's already ten minutes left so one
thing that is important right now you
saw that with the register function we
added some con we added some value some
ether to the contract balance and then
of course the contract balance will be
able to transfer that value to other
accounts whether other contracts or
other users and in our case it will be
speakers so you can use that logic to
actually pay the speakers with actual
ether and that's where the power of
smart contracts is they have they have
they contain value they can send value
they can receive that okay so that's
something that you will be able to see
in the github repository and also for
the front-end we just wanted to show you
it's very simple but you can develop any
kind of JavaScript framework that
connects using the same web three
functional functions that we use as we
are using in the truffle test so the
logic remains the same you just have to
take into account that a lot of the
actions are asynchronous so never take
something into account directly and you
always have to yeah show the user that
something is happening in the background
I will just show that that transfer mode
so here quickly if a speaker wants to be
we were we roared it so you will call
the withdrawal reward and here he will
have some logics that will count your
rewards and what is really important
here is this line because this line will
transfer a number of money of ethers to
the speaker so here the logic is the
speaker that is the message sender will
receive the number of rewards regarding
the
the toll that that is given during the
conference and if the transfer failed
everything that has been changed here
will be reverted so your contract
instances will not be changed if the
transfer filter and that we trigger an
event with a reward event that's it
okay so just that was just to show you
that you can transfer value out of a
contract and then just show you quickly
three so that is the the code of the
front end so again when you unbox the
petshop example you get a full jQuery
application at first and and you can
customize it and here for example in
Abdo GS which is the javascript of our
application for example the function
that we load the talks and displays them
can access the contract in the same way
as we did in traffic console and in the
tests so using the deployed function we
get an instance we call the get talks
function with false saying we want only
the talks that have not been cancelled
we get a list of talk IDs and then we
can simply well using jQuery we re
reinitialize our state and we can
iterate over those IDs and for each one
called the get talk function again and
in the return we call display talk which
is in this case is simply a JavaScript
function that will update individual
elements of our list of talks okay all
of that will run in a traditional
browser provided that you use something
called meta mask so meta mask is a
Chrome and Firefox I think extension
yeah the plug-in that you can install on
your browser and that will actually act
as a proxy to the real blockchain okay
so it will hold all your accounts and
actually I can show you here the
terminal is here test RPC is here let me
force an upgrade
my great - - reset so I'm really playing
my contracts and once it is done I can
run the light serve HTTP server provided
by the contract so I'm peein run dev and
pay install oh okay so I have to install
dependencies first of course and this is
just to illustrate that you can store
your HTML Javascript CSS files anywhere
you want of course the easiest way it is
to store them on a central server
but then again centralization and stuff
and unfortunately there is no easy
option to do it in a decentralized way
for now there is something called ipfs
allows you to store your files in a
decentralized way but yeah it's kind of
cumbersome to use and soon there will be
swarm that's an official project from a
theorem that will make that very easy
but it's not ready yet for now let's run
npm run dev we serve our files from our
local server and here you see it loads
in the browser quite normally and I will
use meta mask so this is the extension
where I can connect to any number of
network and there is a notion of a vault
that is a safe where it keeps all my
accounts and all my keys and here I can
switch to my local network and I can
well I can use this extension to view my
accounts to send transactions and when I
try to send a transaction from from a
page meta mask will intercept that call
and will say ok this account is locked
are you sure you want to confirm the
transaction and if so I will sign it if
not we stopped it there ok so this is an
extension that's very powerful there's
also the mist browser where you can do
the same sort of things but it's not
very practical for development purposes
so that's meta mask and the front-end
again everything is available in the
chain skills slash devoxx
repository on github so you will be able
to check that code run it yourself
there's readme explaining everything
just a few last things to conclude so
overall what's important to remember is
that none of that code that we showed
you was production ready I said
especially with all the jQuery stuff
it's not really readable and
maintainable in the end and again you
can use reacts that's the most used
option right now to do that sort of
things angular as well to UJS as well so
we created a project with a scratch from
scratch with using truffle acuity the
smart contracts with a few advanced data
types like mappings and structure types
our contract can receive and send
cryptocurrency and it can also authorize
access to certain methods depending on
who is connected and we almost showed
you a basic way to connect a front-end
to our contract was almost a small very
small report there was the DEFCON 3
developer conference just last week in
Cancun actually I landed yesterday and
we were there to kind of follow the last
news so a few last news from the network
the community is growing really fast I
think this year was like five times last
year in terms of number of attendees so
it's growing really really fast
Vitalik bittering is kind of the
inventor of a theorem if you want is the
creator of the initial project and it
proposed a very interesting role map
strategy that I really encourage you to
to have a look at there was a very few
interesting tools very yeah some some
very interesting tools that we
discovered and we're gonna cover them on
the blog and the general impression from
the whole community is that we are still
playing with toys that are really early
pre-production stuff so it's gonna come
production ready soon but we are still
dealing with some scalability in a
and productivity issues another
important message from the conference
everybody all the developers from the
core team said ok stop this ICO madness
you're spending
you're wasting way too much time on that
we need more brain time on the tools and
on the the infrastructure itself
regarding the remark above and yeah
Mexico so that's it the last thing I
wanted to say again we have this online
course I think I might have mentioned it
a couple of times or hatred it's on
udemy and if you used devoxx 2017 code
you get the whole course for 15 euros
and that's that it also for the people
who are watching us on YouTube live
right now and we demonstrate how to
create a front-end application yeah
there we have time we have 10 hours we
have time thanks a lot thank you very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>