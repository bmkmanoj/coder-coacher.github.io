<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Managing State with RxJava by Jake Wharton | Coder Coacher - Coaching Coders</title><meta content="Managing State with RxJava by Jake Wharton - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Managing State with RxJava by Jake Wharton</b></h2><h5 class="post__date">2017-04-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0IKHxjkgop4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">how many people have used arks job
before I most people how especially how
people haven't used our Java okay um
this may be a little bit of a challenge
for you I do start with sort of an
introduction so you can try to pick up
on stuff in that but it is going to be a
little bit more technical and I kind of
assume some things about our table going
into this so okay so my name is Jake
Wharton and I'm here to talk about some
of the more complexities of Arc's Java
which is managing state so once you've
initially invested in our java kind of
how you take it to the next level and
how you can use it in a much more
idiomatic way I have a lot of content so
I'm probably going to be going quite
quick
so this beginning is part of a talk that
I gave before but I'm going to try and
frame it in a different way but it will
also be useful if you kind of don't have
a strong idea of Arc's Java so I'm going
to postulate that unless you your entire
system can be modeled in a synchronous
fashion that a single asynchronous
source is going to break imperative
programming and by break I don't mean
that it becomes impossible to write your
program with a you know single
asynchronous source or multiple it's
just that the the amount of complexity
becomes so much and compounds such that
it becomes unmaintainable when you get
into this like state soup and that's
exactly what we're going to look at
trying to solve here so just a quick
example if we have you know some
hypothetical class that's managing state
say the current logged in user and then
has mutaters for changing that we would
interact with this in a synchronous way
if it were synchronous using you know
very obvious interactions the problem
then becomes what if these calls become
asynchronous what if they suddenly have
to be written to the file system or
database or because this is the mobile
track likely have to go over an API call
to your back-end server I mean you can
do nothing here right you can just be
optimistic and say well
I'm going to make these changes and I
think they're going to work and I'm just
going to assume that they're going to
work
this of course falls over instantly
because you have network problems or you
may have like concurrent updates from
different devices so you can start doing
things like well I'll provide a callback
so that when the request is successful
I'll know to pull out the new data the
user this is starting to become reactive
except you know in this simple example
we still have no way of communicating
like a network failure so maybe you'll
write a listener a type that allows you
to message both the success case and the
failure case and you'll update your
sample to you know use this well that
was fun this better not be a software
update yeah keynote quit unexpectedly
lovely too much magic news will edit
this in post
alright what'd you do it again
so this listener to allow you to
propagate you know both the success case
where the data is updated and the
failure case where say the network goes
down and you can start creating a more
you know correct interaction where you
have these things that can fail but then
the problem becomes that well what if
you have multiple of these it's not just
that you have two cases to handle now
these things start to compound so you
have four cases you have the to success
both good error or you are only one
could error and it could either be the
name or the age so you know by adding
just one more asynchronous call you've
essentially got this exponential problem
where the number of cases you need to
handle are growing rapidly and then this
becomes even crazier when you start to
do things like compose asynchronous
calls so I want to make one use the
result and then pass that to you the
next one then this is the mobile track
so we have Android to contend with we're
doing this inside of an activity and we
have to realize that there are other
things going on that we need to take
into account in addition to just the
asynchronous Network calls I'm touching
the UI well I need to make sure I don't
touch the UI after the activity has gone
away I have a listener that I'm passing
in to this method well if the user
rotate to the device and the network
call takes ten seconds we've now leaked
this activity for ten seconds
I have callbacks these callbacks aren't
specified what thread they run on
because this is a network call maybe
they come back on the background thread
and we have to do the work to move that
back to the main thread and also this
code doesn't even take into account user
input right we still have to manage the
edit text the buttons we have to disable
them when the network calls inflates we
have to make sure that we re enable them
how do we deal with the fact that this
is just the name what if we also have
the age what if we allow them to those
requests to happen concurrently there's
just so much going on here and this is
where our Java really excels and how
people get into it but oftentimes when
we when we do it we don't actually solve
the problem here of managing this state
so when we look at our code in this
sense we have to deal with talking to
the network the network is an inherently
asynchronous source even if we're
modeling it synchronously that
synchronous call has to be done on the
background thread so it's effectively
asynchronous you have the disc you have
the user interface which is something
you don't think of as asynchronous
user interface is essentially itself an
asynchronous source you push text and
data into it and then it synchronously
returns click you know callbacks the
interactions with the user and so all of
these things are going to be happening
concurrently great we have Network calls
being made we have the database being
updated we have the files being read we
have the user clicking and dragging on
stuff and so you have all these things
happening asynchronously and it's your
code that's sitting in the middle that
has to coordinate all this and it just
becomes a mess and so how can we not
design things reactively when everything
everything in android is essentially
asynchronous we also can't forget the
fact that once this animation completes
that Android itself is inherently
asynchronous so thinking about the
activity life cycle it can come in at
any moment through a rotation or a phone
call coming in the app switching we have
broadcast we have push notifications any
configuration change when the keyboard
pops up you know all that stuff happens
without warning just any point in your
app and so you have to react to those
changes this is where our Java really
excels and this is kind of the pitch
that people that really pitch the pitch
that really convinces people to use it
but as we'll see oftentimes when you
just start using it right away you're
going to wind up not actually solving
this state problem so what our extra is
really about in this example is removing
the responsibility of our code in the
middle and kind of hooking up these
separate pieces to each other directly
so that when the database you know
updates it triggers directly into the UI
we don't have to manually do that
ourselves when the user clicks a button
automatically you know causes a network
request or rights to the database when
the network response comes back it
automatically gets propagated to the
database which then transitively updates
the UI we start removing our ability to
not our ability we start removing our
responsibility to manage these things
directly and instead try and hook them
together and allow them to just react to
each other the ideal goal being that
that that imperative code in the middle
goes away stop that all code goes away
there's still code here it's just the
code that's setting up the arrow is not
the code that's actually managing
everything directly and so to take our
trivial example from the beginning and
turn it reactive we want the user to
become a stream of user so anytime the
user is updated it's just going to
notify us that there's a new value and
then we can do whatever we want with
that similarly with the mutaters that
are going to make Network calls we want
them to become reactive where they
notify us with success or failure which
is what a completable does and then when
we change change our codes actually
interacts with this reactive version we
could do much more declare things like
handle that threading aspects we can
declaratively say well when you're
pushing the users into me do it on the
main thread and then when you're
observing this user bind it directly
into the UI except we still have that
problem of you know is the UI active
well our Java has a kind of a general
solution for that which is these things
called disposables or subscriptions
they're kind of like a handle on an
active stream and by storing that in
some collection we can then use the
lifecycle to automatically disconnect
from all the streams at the appropriate
moment similarly when we're making these
asynchronous requests we can also
declaratively control the threading and
we can also listen to the result and do
whatever we like in the UI and we also
need to track that track that kind of
handle on the connection in our same
disposables
list so that if the activity goes away
we can disconnect from that that stream
and we don't end up leaking anything so
this is kind of what the initial cell
and arcs Java looks like and you get a
lot of cool things so we get the push
based updates whenever your data has
changed it gets pushed into UI you never
have to pull it out we get declarative
threading we can move background
foreground and vice versa with basically
just a single line error handling which
I didn't really talk about it becomes
easy because it's part of the stream and
it propagates through the stream
automatically there's specialized
callbacks so in the case where we're
making the asynchronous request and it
just succeeds or fails that's all the
callback tells us and then we have the
ability to bind into the life cycle in
this case manually but there's also
libraries to do it automatically and so
this is like the pitch and the thing
that sells people on rx Java but none of
this really deals with that state
problem you still have to kind of manage
the fact that these requests are
in-flight yourself and so that's that so
we're going to look at for the rest of
the talk I'm going to use kind of a
simple example a very similar example of
just you know an edit text a button and
then you type in your name press submit
yellow progress spinner as it makes an
asynchronous request and then that will
either succeed or fail so if you were to
write that with our Ixtapa this is
probably what you would write and so
we're going to go through this and take
a look at what each piece is actually
doing the first thing we're doing is
we're taking the clicks from the submit
button and turning them into a stream so
we listen to the stream and it's going
to emit an item every time you click on
the button we're going to use that to
trigger some other effects so
immediately we're going to take that act
of clicking and turn on the progress bar
and disable the submit button so you
can't press it you know more than once
we pull out the name from the textview
we pass it to in this case I'm kind of
modeling this API service we pass it to
a service which
to API call which itself returns an
observable that we can listen to and so
flatmap is the way that you take item
emissions and kind of turn them into
observables that gets folded back into
the stream
because that's an API call the result
comes back on the background thread and
so we move back to the main thread we
disable the progress bar because the
call has succeeded and then if it's a
successful call we just finish the
activity and if it's an if it produces
an error for any reason we re in able
the submit button and we you know show a
really poor version of error handling
but we just show a toast of a flood
failed finally because this is in the
context of an activity we're tracking
the the in progress version of this
stream so that we can unhook from it if
the activity ever goes away so that kind
of went through it in what it's doing I
want to go through it again in the exact
same way except so it's a slightly
different viewpoint so starting with the
rx view stuff so this is from a library
called rx binding and what this does is
take all of the bespoke listeners of
Android and turn them into this very
normalized unified rx system of events
so this is like a big win but then
immediately we do something where we we
tell it like a side effect of the stream
so when you click on the button we start
events flowing through the archetype of
stream except we like jump out of it
back into the UI in order to just to
disable the button and show the progress
view so not the best but this still ok
this is really bad we reach into the UI
very imperative lis and we kind of yank
out data that we need so this is where
in this stream already and we have to
jump out and grab data from the UI
there's all kinds of concerns here so
maybe we already moved to a background
thread you can only access the UI and
the main thread becomes hard to reason
about because you can't really see where
the data is coming from it's hard to
test in isolation because you're
reaching out of the stream
so once we get that data we put it into
you know the network Hall which is fine
we flatten that bit back into the stream
that's fine to claret of we move back to
the main thread for the result also fine
here's another side effect that we run
into you we're in the middle of this
stream after we've done some network
call we again jump back out and touch
the UI and this is actually a bug
because it's a Duan next which means
it's only going to run in the success
case if there's an error it's not going
to call this do i next and the progress
bar is going to remain spinning this is
like something that's subtle that if
you're not really well-versed in the
operators you're going to miss again
threading is a concern if we forgot to
jump back to the main thread what if we
wanted to stop the progress bar spinner
but also like write the response to disk
at the same time we would have to you
know jump to the main thread disable the
progress jump back to the background
thread right at the disk and also if we
have concurrent if we have multiple
requests going on at once these side
effects are reaching into the UI at
random parts and basically are going to
be fighting each other to show and hide
UI information success case we finish
the activity that's fine and then the
error case is interesting this is also
another bug because in rx errors are
what's called terminal events so if you
make a network request and it fails it's
actually going to tear down this entire
stream so you will get you will get the
submit button re enabled and you will
see the error but the stream gets torn
down so you can click on the submit
button all you want after the first
error the streams know all going to be
they're listening so another kind of
subtle bug and then you know tying up
tying the operation to the life cycle
one could argue is a bug so if you
rotate the phone while it requests is in
flight you're going to lose the fact
that this request is being made ok let's
look at this kind of from a diagram
perspective and see if we see if it
indicates how we can potentially clean
this up so we start with the UI
producing events
that go into our code we know this is
good then we immediately jump back into
the UI as a side effect to to show
progress being displayed this is
essential but it's a little kind of
weird and we'll see why and then we do
the very impure operation which we know
is bad of pulling data out of the UI
outside of the stream we do the flat map
which makes the network request we come
back we side-effect again into the UI to
you know hide the progress and then
ultimately we have the SUBSCRIBE call
which gets the result of the data so
this is this is like for a single
request there's a lot going on here and
remember there could be two requests
going on at once what does that look
like well that you basically just
duplicate all of these things and we're
not really solving any problem with our
X here we're just creating new ones so
let's look at it from perspective a
single request this we know the stream
from the UI is good we want to turn
these into things that we can react to
but we immediately side-effect back into
the UI this is necessary but it's not
quite correct we need to find a
different way to do this and this
happens twice in our stream right we get
the initial side effect to show progress
and then we do it again to hide progress
the term side effect itself should be
telling you that these are bad right
side effects are things that should be
happening unrelated to kind of the
primary interaction like logging or
analytics interacting with the UI is not
a side effect it's like it's our primary
effect like we this is the direct thing
we want to be showing the results so we
know that's bad
we know get Texas bad talked about that
earlier the flat map the network all
asynchronously totally fine when we come
back again the side effect which could
stomp on potential concurrent requests
and then we have to subscribe so given
the bad things in this picture where do
we want to end up right look what could
we do here to make this better well be
nice if those red things just didn't
exist and then we get this like really
pretty kind of flow of data
so what can we do to get there so let's
start with things that are flowing in
the same direction so we have data
coming from the UI and going into our
stream currently we have the click which
is flowing normally and then we have
this weird impure thing where we're kind
of yanking data out of the UI what if we
just combine those right everything
coming from everything that we needed to
fulfill this request came from the UI in
a single package that we never have to
reach out and grab things that you know
are outside of the stream everything
would be contained inside that initial
event so we need a pipe for this which
we'll look at soon but this represents
both these to click and having the data
that we need to submit similarly if we
look at the arrows going the other
direction this is from the stream back
into the UI it would be nice if these
were somehow consolidated and you look
and you see well there's two do on next
and then there's a subscribe what if we
just change the last one to a do on next
so the way to think about this would be
the UI is always a side-effect of the
state you know we're managing this state
and then we're side effecting into this
UI that's kind of weird right the UI is
not a side effect of the state the UI is
the way that we're translating the state
into something that we can communicate
to the user if we could beam the state
object directly into the users brain we
wouldn't need the UI at all and then
maybe it's a side effect but we can the
UI is the primary means of communication
with the user so it's that it's like the
direct effect that we want to create
this is that this is not what we want
what if we flip it around and go the
other direction instead of having to do
on next what if everything was pushed
through the SUBSCRIBE right this is a
stream of events so there can be
multiple it's not just the final result
it can be all of the states of the UI
being pushed at different times again
you know before we were just kind of
ignoring the result and just the fact
that it was successful or erroneous did
something and here what like the submit
event will also kind of need a more
complex type to represent all of this
data which we'll look at in a second so
this great no more red
if you look on the the right side which
is like the UI going to our code we have
this that's what's called a
unidirectional data flow you have stuff
coming from the UI into our code in a
single stream one direction and then a
single stream the opposite direction
which is our kind of state being pushed
back into the UI this is not a new
concept in general in programming in
general so let's look at how we can
actually achieve this in code so we'll
start with so with the arrows going from
the UI into our logic so we have the
clicks which is the originator of the
event and we have this impure get text
function at the yanking data out what we
need to do is consolidate those so if we
slide that up and when the click happens
we immediately grab all the data we need
doctor net solves that problem in this
case I was you know you could just omit
like the name but that doesn't allow you
to have more than one kind of stream
coming out so like we talked about
earlier we need some kind of event
object that represents both the action
and the data that's required to fulfill
it and then our you know flatmap down
here is updated and you can see that
it's it's no longer doing things in
purely it's using the data using the
event that's in the stream to create the
asynchronous action ok the arrow is
going the other way so what we're trying
to do here is communicate that the
request is in progress and then that the
request either succeeded or fail it's
you know at the end so let's look at
this and maybe we can fix those bugs
that I talked about earlier so we need
some way of pushing all that data into
the UI at once so we can no longer
side-effect out of the stream so what we
can do is create a type that represents
all the things we care about happening
at once so the fact that the request is
in progress whether it succeeded or
failed and if there's an error message
we're going to start with the first
event so when you click we need to
somehow submit that the UI is in
progress so like this this would return
instance of the model we're in
we're so set to true and where we want
to do that is in that first do on next
immediately when the click happens we
need to tell the UI so we know we want
to somehow use this in progress model
but we need to get it into the UI
obviously we can't do it I do on next
because then it's it's going nowhere we
can't do a map like we did with the
event because then we're actually just
replacing the event in the stream where
we need to put it is a little bit
farther down and so what happens here is
I've taken the asynchronous observable
and I've changed it so that it
immediately starts by emitting the fact
that it's in progress so as soon as you
subscribe as soon as the click causes
that request observable to be created
and then subscribe to it's going to
immediately emit that event saying I am
now in progress there's a slight problem
here in that after that we have this
observe on and observe on the main
thread and what this does is it posts
events to the main thread
unconditionally so when this click
happens you know it's going to fill it's
going to filter down the stream we're
going to create that request observable
that's going to start with emitting in
progress and then we're going to flow
through this observe on which is going
to post to the main thread which means
that it's not going to actually the UI
is not actually going to see the fact
that it's in progress until the next
frame and that's not what we want
because then we won't disable the button
we won't show the progress bar and
you'll just have kind of a little subtle
skip so we need to do is actually just
kind of reorder these where we say that
we're only going to take the background
operation which is the network request
and observe its result on the main
thread but otherwise everything after
that will be on the main thread and will
emit synchronously so our other two side
effects we need to do very similar thing
also you'll notice that like we lost the
fact that we're telling the progress bar
to show we're going to come back to that
the same thing is going to happen here
we're going to lose our view binding but
we're going to come back to it so using
the other two kind of these are just
like factory functions for versions of
this model so
success would you know have in progress
false and success true failure would
have in progress false success false and
then some error message so we're just
going to do a very similar thing but we
need to replace the success case with
turning the turning into the success
model and so because the success case
comes from the network observable what
we're going to do is actually put it
really close to the network observable
so as soon as we get a response and that
response is successful we turn it into
something that means success in terms of
the UI so we take whatever the response
is you know in this case we're just kind
of ignoring it but the fact that it
succeeded then becomes the success model
and if you wanted you would be pulling
things out of the response and putting
it into this model to actually use in
your UI and that's the same thing with
the error and again because it's the
it's because it's the network request
that's airing we want to take its air
and turn that into the error this error
version of the model which propagates
the failure message so if we look at
this new inner observable what's it
actually doing so it it starts with the
network call and if the network call
succeeds it turns it into a
representation of success if it fails it
turns it into a representation of
failure that happens on the background
thread which we then observe on the main
thread so we can bind it in to our UI
and then this observable which is going
to be this inner observable the one
inside the flatmap function is going to
be subscribed to on the main thread so
it's going to click we're going to click
it's going to turn that click into an
event and then that's going to call the
flatmap function which returns this
background observable but it's going to
subscribe to it on the main thread and
that inner observable will immediately
emit an in-progress notification and so
we lost all of our like nice UI binding
so that's what we need to put now down
here instead of just taking success as a
success case we now receive this model
object that we created that has the two
boolean's and the string and we bind
those into our UI in a single place
no more side-effects which is awesome
and then for error handling you know
even though errors aren't from the
network request and aren't being turned
into something in the model we still
actually need to handle error handling
down here in case there's some other
exception in the stream and by doing
this you're basically just crash the app
which is what you want to do so this is
where we've ended up there's a lot of
code on the screen but it's logically
divided into three very easy to
understand sections I guess I shouldn't
say easy but three distinct sections you
have the first part which takes UI
events and turns them into a stream of
things that we want to react on you have
the middle part which takes those events
and does something asynchronous with
them and produces a single like unified
model that we can bind our UI to and
then the third part here takes that
model subscribes to updates from it and
binds it directly into the UI so we'll
get in this case we'll get you know two
notifications every time there's a click
we'll get the one that happens
immediately which says something's in
progress and then we'll either get a
successful or a failure one and we
actually fix all the bugs that were in
the previous one where if you if the
network call fails it doesn't actually
the error never propagates into the main
stream so if you click Submit again it's
still going to work and a really nice
property of this is that that whole
middle section is actually doesn't know
anything about the UI and I can prove
this by turning by slightly changing it
to a transformer which takes an
observable of events and returns an
observable of models and then I can even
rearrange this so that that transformer
can be defined by itself there was
nothing about the UI and then all the UI
code is kind of grouped together and
just uses the transformer not ideally
you would have these in separate files
one not to be unit tested and then the
other that's the actual UI these could
even be in separate modules there's no
reason that the apart at the top which
is actually the kind of back end of the
UI has to be defined anywhere near the
so-called front end
such as the single one what about if we
have multiple requests coming from the
UI while we're going to do the same
process of just converting it into this
and then slamming those together so that
we still only have a single stream I
want to show what that looks like
concretely because it gets a little more
complicated and actually shows a problem
with this so I'm going to flip those
back around so we have the three
distinct sections we have events coming
from the UI we have the asynchronous
kind of logic in the middle and then we
have the UI binding at the end let's
start with the UI so before we were just
using a single event if we're going to
have multiple events let's say the
example I use is as the user is typing
so if you want to check their name with
an API call to the server to see if it's
you know valid so we're gonna need more
events so we now have a submit event and
we have a check name event and for
convenience I've made those kind of part
of the same type hierarchy Kotlin works
great here with sealed sealed class
hierarchies we created another
observable for this this new check name
event so every time user types you know
changes the text in a text box we now
are going to get a check name of that in
a second observable and then because we
want them to be unified all events from
the UI are coming through a single
stream we're just going to merge those
into a single stream we can use the type
to differentiate which one is actually
which event is actually occurring so
that becomes the new kind of top part
now the transformer needs to handle
these this new event type and the way we
do that is this one you know is already
defined for submit event we can create
another one that's just going to deal
with this check name event you don't
really need to like worry about what
it's doing but a key thing to point out
would be obviously that there's I have
these giant red clutch marks because
this this indicates a problem and the
problem is that these transformers are
directly acting on this model and so if
we're going to have more than one
request in flight both of them can't be
returning an improv or a success version
of the model because
maybe they're happening at the same time
maybe the results need to you know be
combined to that multiple in progress
requests don't stomp on each other we're
going to come back to this because
there's actually a larger problem that
we need to fix that will end up solving
this one so for now just pretend like we
put something there and again we need to
combine these so that they produce a
single output stream in this case of the
UI model but first we actually need to
do something different which is we need
to figure out a way to split the event
stream because we need to send only
events from submit to the submit
transformer and only events from check
name to the check name transformer so we
know that you know based we're going to
do this based on the type we know how to
merge observables
but slipping observables is a little
more tricky usually when you do this you
think of the maybe a share operator or
the publish operator that you then
eventually call connect on but a
lesser-known Verte operator or version
of an operator I should say it's the
version of publish that actually takes a
function and so what this is going to do
is take the observable that's coming in
and allow you to subscribe to it as many
times as you want and do as many things
as you want on it as possible as long as
you ultimately return a single
observable from that function which is
exactly what this diagram kind of wants
we want to be able to just split it do
different things with it and then
ultimately merge them back together and
return a single observable so this is
what other things going to look like and
then basically inside that function we
split the observable based on the type
pass it to the appropriate transformer
and then merge them back together so
this is our new middle section and then
nothing has to happen down here at the
bottom right it's still the model that's
coming out of this so we still just bind
it to the UI but you know I left this
kind of I went through this quickly and
I left those question marks in there
there's obviously a problem here with
the
and so the way that we can think about
this is you know there's a bunch of that
is actually a bunch of things on the
Left I just been using the network but
it could be a database could be you know
the file system could be intense and so
what we're doing is we're taking the UI
and turning it into a representation of
events everything every interaction
becomes an event and then we're using
this model object to take you know state
and bind it back into the UI but what
we've been doing wrong
or I should say what I've gone wrong in
this first section and what often is
done wrong is that we're using the UI
events in order to trigger these the
actions that are asynchronous and then
we were using the model of the UI
directly in the result of those
asynchronous actions and that means that
the asynchronous things that we write
are now very tightly coupled to the UI
that you're building so we want to get
to is something to decouple them and so
we need some other thing to trigger the
action and we need some other thing to
be the result of the action and then the
code in the middle the code that's you
know our code that building these
streams just becomes this translation
layer between these two systems the top
one is really easy you know you're
taking your submit event from the UI and
turn it into a submit action to go to
this asynchronous thing this is super
important for reuse right because
otherwise the the actions the things on
the Left are tightly coupled to the UI
and so if we had multiple places in the
app that needed to do a database read or
call this network request we couldn't
actually reuse it directly the bottoms a
little more interesting because you
can't just jump directly from a result
back to this UI model because the result
is just the result of that single action
you need something that's tracking the
ongoing progress of the model so that
when the request is in flight you know
it's setting that boolean to true and
then when it sees the success or failure
result which knows nothing about the UI
can then turn that back into you know in
progress becoming false and then success
becoming either true or false so needs
to be some intermediate thing tracking
the model updates which is what we're
going to look at so the way to do that
the way that we would do that as like a
human if you know keep sort with an
initial state and then for every result
of an action we would just modify it in
some way so let's say I start typing and
I fire off you know the check name API
request is now in flight well I would go
to my little piece of paper and erase
false and I would put true and now this
would be by new state my new state would
be that request is in flight then that
would eventually come back with success
or false and I would you know erase the
the true and it would now be false or
what if there's something happening you
know concurrently I start typing my
check name and then you know do the
erase and turn to true but then I hit
submit and well I know there's a check
name in flight but now there's a submit
in flight so I'm just going to leave it
the same but mentally me is going to say
I don't really care about the check name
request anymore because I know I'm now
in the submit one and that kind of
supersedes so I just leave it as is
there's a way to do this in rx which
we'll look at which I meant to try and
mention try to remember to mention in a
second and then ultimately when success
comes back you know I would use my
eraser and I would change in progress to
false and then propagate the result into
that model how do we do this in rx
though how do we have that intermediate
state and react to these events
basically by taking the previous state
and then slightly updating it we need to
start with some subversion of the state
and so let's say we create another one
called idle and this is just the normal
like default UI nothing nothing
interesting is being down it's just like
the state you're in when you first
navigate to the screen
everything's false everything's not
whatever we have our stream of results
the stream of results is the merge of
all of those transformers back into
you know just stream of data coming out
from those least synchronous actions and
this is from where we're going to derive
the transitions from the state in our X
the operator that allows us to
accomplish this incremental state
updating is called scan and it's
essentially the exact same example that
we just walked through where you start
with a state and then for every event
that comes in you get a callback and you
just give it you return a new state and
that new state becomes the canonical
state until another event comes in in
which case you get another callback and
then you can update the state in some
other way kind of ugly in Java again
Kotlin works really well here with the
when matcher
in sealed sealed class hierarchies but
basically we're taking the results and
we're mapping them back into the UI
model so these results have nothing to
do with the UI they're just actions
happening in the background and we're
turning them into the semantic
representation that we want to bind into
this specific UI if we go back to our
Transformers the things that take the
actions turn them into results we need
to update when l are using UI events
each of these asynchronous actions has
their own type that allows them to
trigger and they're very similar to the
UI events but again they know nothing
about the UI it's just the required data
in order to execute this action and then
instead of returning my slides out or
whatever instead of returning the model
directly we're going to return again
like a semantics result just to that a
synchronous action so you know now at
the top one when we're submitting this
name to the server we're taking in an
action which tells us to submit and then
we're either turning that into success
or failure and as soon as that action
starts we're telling whoever's listening
that this request is in flight same last
check name
as soon as you ask it to check a name it
will tell you that check name is in
progress and then whether that succeeds
or fails you get the check name result
in the code in the last slide then
becomes so we fixed you know we fix
these question marks now we're no longer
dealing with the UI model directly we're
just we just have these actions which
not only know nothing about the UI but
now can be reused in multiple parts of
the app don't even need to be built in
the main part of the app these can be in
different modules and shared and so
where we gotten to this is kind of I
guess this is like a summary of
everything that produces this pattern we
take the UI we take interactions with
the UI where it's very tempting to
create streams directly that you know
cause from a synchronous action it's so
tempting to take those clicks view and
just flat map them into your retrofit
request but in order to do in order to
do like proper state management which
then becomes the responsibility of the
callbacks instead of the stream
you need to coalesce all the UI
interactions into a single stream you
can react to put all the necessary data
for performing whatever action into that
event and never ever side-effects back
into the UI because you as soon as you
do that you're immediately something on
your ability to do things concurrently
to have multiple requests in flight from
the same UI transformations whether
they're synchronous or asynchronous
triggered by an action which is not the
same as the UI event these often map
very very closely to each other and will
contain the same sort of information but
having them decoupled is essential to
allow reusability testability of both of
these both sides of these in isolation
the result of these actions are ways
that we communicate back to the the UI
and by UI which I didn't really define
this is not necessarily like views this
is the presenters
controllers that the things driving the
UI so results are the ways that these
reusable asynchronous operations
communicate back to you that that logic
that powering your UI the result and
that result has nothing to do with the
state of the UI is nothing to do with
what's being shown on screen it just
allows that logic to take that result
and transform the state in some way
inside the stream again without having
to do side-effects and without having to
maintain you know a bunch of fields
outside of the stream important thing
with these results is thread safety and
so I didn't really mention this but an
easy way to just kind of get rid of any
thread management problems is to ensure
that these always admit on the main
thread and then your model update is
going to be blazingly fast because all
you're doing is matching on the result
and then you know changing a boolean or
whatever and so that on the main thread
is very easy and then your UI is just
been listening directly already on the
main thread and can bind bind to the
model and then the code in the middle is
kind of our code that's doing the scan
which is taking the taking this model
that we've created to represent the UI
and taking the result stream coming from
the actions and just like incrementally
updating the model just small changes to
indicate that a request is in flight or
that an error message happened or that
you know the server returned this piece
of data and now that needs shown in the
UI put all of the necessary data of
state into that UI model because it
affords all kinds of cool things the
first being rotation which I haven't
really talked about I mentioned at the
beginning about how we are tracking
things in disposables and then we kind
of dispose them all when you rotate the
phone or hit home or whatever the cool
thing about this is that cool little
phone emoji can totally disappear and
everything to the left can still stay
running and basically your models are
still running and you always have kind
of the latest state so that whenever the
UI comes back it just binds to the model
and so if you get a phone call
you press you know your submit you get a
phone call your your activity flops out
the network call comes back when your
activity is totally gone and say it's
successful our logic our scan in that
center part can update the model to
reflect that success and it emits it but
no one's listening
but that emission is cached so that any
when the UI eventually comes back when
your mom finally stops talking and hangs
up your activity comes back it binds to
the latest model and then immediately
reflects you know whatever that state is
in this case it would finish the
activity and go back to the previous one
but you no longer have to expand it's
the same is true of rotation if you get
a callback in the middle of rotation you
no longer have to really explicitly
worry about tracking that tracking that
in-flight state because it's now been
totally decoupled from the UI and what's
cool about this is now side effects can
be used for side effect these things
interactions with the UI maybe you want
to record those now you want to log
those that sounds like a side effect
that you can just shove on the stream
coming from the UI what about logging
the model going into the UI seeing the
object that represents the state of UI
and being able to log that and record
that have that available in say your
crash reporting tool so you can see them
you can see the events and the models
that led up to a crash another cool
thing about this pattern is that you
don't actually need an activity or a
real UI on the right side of this you
can test the entire business logic of
your app by just using rx Java of test
primitives to swap out how you create
the events and how you read the model so
now you can unit test this similarly we
don't actually need the backend of the
app you can swap out that entire
back-end for the same kind of test setup
and you can now shove models into the UI
at will and see how the view is being
rendered or you can interact with the
view in espresso and ensure that the
correct events with the correct data is
coming out of them so this would be good
for a for unit testing the UI not
you know you'd still want like full
integration tests with espresso but this
will allow you to test kind of all the
variance of your UI all the interactions
with it and all the different setups of
the model being pushed into it inside a
instrumentation unit test and so this is
it it's not a library it's nothing
insanely novel here it's really just
kind of a pattern and there are
libraries that will assist with this
pattern if you're familiar with things
from the web
we're basically stealing Redux and cycle
and turning them into an Android version
those libraries tend to want to put the
entirety of your app state into a single
stream a single model that represents
your entire app not quite sure that
makes sense for Android and you don't
have to do it this whole system could be
a single view it could be a single view
in your view hierarchy that's just
dealing with you know some complex piece
of state management and then that
component can be reused it could be a
fragment that could be reused it could
be an entire activity or it could be
your entire application and the
advantage is that you don't need it to
be everything and in fact I probably
wouldn't recommend doing everything but
if you have if each one of your you know
components of your app be it activities
fragments or something else are built in
this way they all become very easy to
test it's very easy o matic and rx
everything is contained inside the
stream instead of these side effects
pulling things in and out of these
complex state management problems
there's no subjects there's no relays
there's none of these things that are
hard to say uh Nydia Matic but are just
not the ideal way not the most idiomatic
rx way of representing state you want
everything to be put inside of the
stream and when everything is inside the
stream you get this nice uniform model
it's certainly more complex it's not the
easy thing to do it's harder but I would
also argue that it's really no different
than you
doing an MVP or an MVC or this is very
similar to mvvm it's essentially an
architecture and architecture inherently
comes with a slight bit of overhead
there's a little bit of abstraction
there's a little bit of duplication but
that's required in order to get clean
separation to get the testability to get
the reusability and so again it's a
pattern there are a few Android specific
libraries which are trying to help out
with this I have a few opinions on them
which I won't include here because we're
basically out of time but it's if you're
using rx and that that beginning example
really resonates with the kind of code
you're writing and then ultimately the
problems you're having this is something
you can look into in order to take that
state from being your responsibility to
being put inside the stream and
ultimately and hopefully cleaning up a
lot of that state management and for
that thank you guys for listening and
hope that was insightful Thanks
it's 1122 and this talk ended 11:20 so
if you have any questions I'll be around
all day all conference actually yeah
that's it come see my talk on Colin at
lunch
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>