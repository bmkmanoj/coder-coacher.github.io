<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Puzzlers by Peter Lawrey | Coder Coacher - Coaching Coders</title><meta content="Lambda Puzzlers by Peter Lawrey - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lambda Puzzlers by Peter Lawrey</b></h2><h5 class="post__date">2016-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tSbK3A9QMmI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon my name is Peter Lorre
and I'll be talking about lambda
puzzlers I'm a job developer and
consultant for worked with investment
banks and hedge funds for last 10 years
and also a Java champion and I've got
the most answers for Java and the JVM on
Stack Overflow also interesting to me is
that I've the only gold medal holder for
memory and file i/o so it gives you an
idea of my sort of low-level bent and
that's in any language so I thought it
would give a bit of a rundown of lambdas
and streams but more focusing on lambdas
what are they really how do they operate
what are some of the gotchas and how
should they really be used so I'm going
to look at things like what are they
good for when's a good time to use them
how can you how and why would you
serialize them
how can they be interchange with other
kinds of objects and last but not least
some of the performance considerations
so there's two ways of writing a lambda
one of them is a method reference and
the other as a lambda expression so one
of the differences with the method
references that you're naming a method
and that's significant when you come to
things like serialization but when you
use a just a normal lambda expression
then actually a method gets generated
for you in that class so there's a
static method that actually holds the
implementation and that may or may not
change particularly if you change the
order of your code for example so what
are lambdas well they they're actually
classes that are generated at runtime so
they're not generated by the compiler
there's no dot class file for you to see
but at runtime you can do get class on
at lambda and we'll give you back
somewhat not very meaningful string but
you do get an actual class back and so
what they can do in fact the class name
is deliberately obscure so that you
don't find interesting uses for it and
then complain when it breaks you can't
over the ride the two string of a lambda
which has all the equals or hash code
which has the downside that you can't
compare to lambdas and you can't get
very useful debugging information off
them but apart from this they're very
useful for snippets of code now in terms
of streams streams as an API that uses
lambdas but lambdas are not limited to
streams you can use lambdas in other API
as well and we have our own API for
example at their open source we use
lambdas a lot but we don't use streams
very much so they are actually separate
in that sense also with streams you
don't have to use lambdas you can you
say anonymous inner classes or other
implementations
it's just that using lambdas and streams
together is a fairly natural thing to do
so you've got imperative style coding
which has been around for quite some
time after Java 7 is your only option
so you have a loop quite often to
iterate through some data set now with a
functional style you can construct a
stream and for the most part it will do
the same thing it will do it will have
very simpler performance properties but
often when you look at some trivial
examples and certainly my initial
reaction to a lot of the easy examples
to do with streams is that often when
it's simple to understand it's often
difficult to see why you would even use
streams in the first place however as
you get into more complex examples you
will see that streams actually become
and lambdas become much more powerful
and they allow you to do things that in
a loop would be quite painful one of my
earliest observations and revelations
was
like group by Sol collection stuck group
by is very easy to do with the strength
but actually quite difficult to do with
a loop because you have to maintain or
what what was the previous value what
sort of collection am I using and so on
so pure functions well it's this lot
written there unfortunately I could I've
probably got too much material but
anyway so we've got what is a pure
function a pure function is one it has
no side effects and this is an important
concept for for functional programming
is that you want to minimize the amount
of side-effects involved that way you
can reason about what those functions do
and in particular as we can see later
you can paralyze it so you can run that
code across many threads there's no
interaction between those threads
because there's no side effects so you
want to you want to use pure functions
as much as possible even before lambdas
I would have advocated even in Java
seven you want to make your functions
pure where you can you want to minimize
side-effects or perhaps as a rule if
it's going to have a side effect you
just have one side effect if there's
more than one side effect it's when you
get situations where it really gets
confusing so here's a little puzzle for
you and this puzzle is which ones are
these methods are pure methods that is
that they don't have side effects now
one of the things one of the hints big
hints is that a pure function should
return the same result for a given input
and as you can see actually these the
first example is a pure function the
second one is definitely not a pure
function it changes state and it gives
you a different result every time
concurrent time Milly's might give you a
different value each time so it's not
really pure either get user count might
keep changing and lastly you getting an
empty tree map and you might claim that
that's pure but from an object point of
view you're getting a different
reference each time so in fact that's
not potentially
not really pure either so one of the
things that you find in reality is that
well people say all functional
programmers come to Java the way you
will probably end up using it isn't
really pure functional programming you
will have side effects and you will use
it in ways that you know in a more pure
functional language would be avoided so
some classic examples of these are the
consumers and runnable these only exist
to have side effects they don't return
any result so so that so as a result
they're clearly going to be they either
do nothing or there are going to be an
impure function so they're the ones to
watch out for so if you can reflect the
code and you'll see some examples later
where you can avoid using consumers or
runnable then that's likely to be an
improvement so this is a little puzzle
for you so in this case I've got an
executor service I've got two pieces of
code that do service ami executor
service and in the first case I get an
exception being thrown but in the second
case no no exception is thrown and the
only difference between the first and
second cases and then is that I'm
returning null so in the second case I
return null the first case I don't
anyone see why that might happen why it
might be that one in one case it's
allowed to throw an exception the other
one is not yes
yes callable so the first one is a
runnable because it doesn't return
anything so this is part of the title in
France magic it says that it's not
return anything it must be a runnable
because that's the only type that's
overloaded that doesn't return anything
in the second case there's only one
method that can return something that's
a callable one of the difference between
runnable and callable is a callable can
throw a checked exception runnable
cannot so you get this strange
side-effect that by returning null I now
no longer have to catch my arrow
exception so a mixing imperative and
functional code isn't isn't ideal and
Java doesn't have any way of preventing
this or even flagging it but it's
something that you should try and be
aware of because you will you will find
things get a little bit more difficult
if you start to mix these two forms so
it's a couple of examples here this is
based on some some real examples in the
first case validate was a method that
threw through an illegal state exception
if if that that item was invalid but
obviously for each it's taking a
consumer only exists for a side effect
and that side effect is that will throw
an exception if any one of the elements
is invalid so this is not really
functional programming but it's - even
though it's using the functional
libraries it works maybe writing it
another way would just be not
necessarily an improvement it's
something you should be aware of that
this is this is exists for a side effect
so in the second example you can decide
to remove based on the filter all that
all of a particular element so this can
have some strange effects particularly
in parallel because you're altering a
list
iterate over so it's generally not a
good idea so one way that you can
refactor this so in the first example I
have a mixed style because I'm using the
functional interfaces but then I'm
calling put I'm using a consumer instead
of doing that I can collect all the
results for the map into it into a new
map and I'm only returning a result
there's no consumption going on and
there's and you you're producing a
particular result you're not altering
anything so that's one of the key
aspects so you shouldn't really be
altering anything in any of the lambdas
in a stream so there's an example of
where this goes particularly badly is if
you call compute evapo a inside a
computer absent right actually
accidentally did this although it wasn't
as obvious as that it was more
complicated but and in this case I've
picked a key which is Nina just so that
I can show you what enum map does now
the behavior here is undefined because
this is not intended you've got a
side-effect inside lambda which will be
executed when the the value is absent so
what happens with different maps well it
depends on the map in many cases you
don't get the first value you get the
second you get hello equals to some
cases like hash table you get both keys
so you get a duplicate key which is not
particularly good linked hash map you
get a duplicate key again except in the
opposite order when you when you to
string it can concurrent skip this map
is the only one which does what I think
it should do and in fact as a short-term
workaround for that code I started using
concurrent skip list later decided to
just refactor the code so it didn't do
that in the first place
probably the worst one is concurrent
hash map and that's because the
locking that concurrent hash map uses
internally is non reentrant so he dead
locks itself or live locks itself so
that's not not ideal so in in lenders
you have what's called capturing a non
capturing a capturing Landor is one that
takes values from its context and a non
capturing one is one that doesn't it it
has it retrieves any values it needs
when it runs or it is passed every value
that it needs so this has some side
effects so in the first method the value
that's returned it's not is non
capturing the lambda that's returned as
a non capturing which means that you
always get back the same object every
time so the JVM will treat non capturing
lambdas as something that only
constructs once so it constructs it once
when that line is run and then that gets
cached for the rest of the life of the
program or until perhaps that class is
unloaded now in the second one I'm using
a method reference but this method
reference is capturing it takes a copy
of what system dot out is which also
means that every time I run this I get a
new object so it captures it again and
again and in fact you can change system
dot out so it is meaningful to do this
so if I create this consumer and then
alter system dot out to be some other
output this will continue to write to
the old system dot out because it's
taking a copy and in the last case we've
got something similar we're taking an
argument and returning a value it's
acting as a consumer instead of a
runnable and again this is non capturing
the all the values that it needs are
being passed in rather than retained so
this has some side effects as I
mentioned so in the first case it's non
capturing so if I call this method twice
I get the same object we call it twice
for the second case which is capturing I
get different objects so if I put these
into a set in the first case I
the mentor said I have a set of 1 and in
the second case I have a set of 2 if I
try and remove the element from the
first one it will even may well work I
can add it to a set and then remove it
later however in the second case I have
to be a lot more careful because if I
try and remove it it will remove a new
object which doesn't exist so nothing
actually happens so it compiles it runs
it just doesn't actually alter the set
so it's a I've run into that situation
with subscribers so another puzzle for
you do we need to close this so most
dreams don't need to be closed it
happens a closeable a base stream is a
closeable and you can call closed on it
but in most cases the only thing it does
is it prevents that stream being used
again so if you try and use after it's
been closed till throw an exception but
in this case you actually do need to
close it because it creates a file
resource and for whatever reason when
you reach the end when you get to the
end for each or an exception is thrown
it doesn't close off that resource you
have to manually do try with resource on
a stream to ensure that that resource
gets cleaned up again this is a subtle
bug because most of the time this is
fine it will eventually get cleaned up
when it gets a G seed and that will
close off the file but if you create
these faster than the GC cleans them up
then you can run out of file handles so
there's a fairly subtle bug that doesn't
show up in some simple unit tests for
example so you have to know that some
streams that use particularly file
resources are likely to have to be
explicitly closed off serialization so
one of the benefits of land is compared
to anonymous in the classes is they
capture less scope this makes
serialization easier because you're
capturing less data which might not
itself be serializable so you have to be
careful what gets captured as to whether
that's appropriate for serialization or
not
now there was some discussion when this
was added this feature was added to
Landers that you could serialize them
and in particular some people brand gets
included it was thinking well this is
probably something a feature we don't
really want to be supporting but there
was enough people who convinced him
otherwise so it does mean that but you
can't do serializable it's something
that's not there by default so you have
to jump through a few hoops so one of
the hoops that you have to jump through
is quite scary it's it's having you have
to cast but it's a cast that has it's
not if this is a compile type cast not a
runtime cast at compile time
this cast says this is the type of
Lander I need to produce and it changes
the bytecode appropriately it's also odd
you've got a cast here with an and in it
so you've got multiple types in fact you
can add as many marker interfaces as you
like we're using this style of casting
however whole point of Landers is to
avoid boilerplate and as you can see the
cast is longer than the method or the
piece of code that I'm trying to to try
to wrap so this style isn't particularly
friendly so how can you get around this
well one way of getting around this is
to have an API that uses an interface
that is serializable so when you when
you define your your lambda function you
you say that it extends realizable at
the time you write the API and then
people using the API don't need to know
this detail that hides that detail away
from them so again we've got three
methods in the first case as I mentioned
before this is capturing so when we come
to serialize it it blows up because it
says that system dot out to print stream
and it's not serializable
we can't serialize it second case will
actually serialize and you can send that
across the wire and execute it on the
server for example what will happen
though is it will just print out a line
on server won't print out the line on
the client
and the last case is where this is where
lambdas have something above our benefit
over anonymous inner classes there's
apart from it being more of our boats
the anonymous inner class will capture
that this of the context so if it's not
static it captures that this even if you
don't use it and that that creates not
only an overhead but it actually makes
it non serializable which is probably a
good thing because it is serializable
it'll be sent across the wire even
though you're not gonna use it for
anything which is something of a waste
why would you serialize Atlanta well
there is a number of distributed api's
out there we've got one hazel caste is
another one I know that use this
technique where you can write snippets
of code on a client and then they are
executed remotely on a server so it can
take that piece of code pass it to the
server and the server then execute that
code it can do it atomically and then
send the results back to the client
again it's not like it has to take some
sort of global lock send the data to the
client apply the result and then send it
back again and release a lock
fortunately it can be all done where the
data actually resides so this can lead
to some more complex examples where this
is based on radius you want to say
you've got a collection a map and you
want to get all the keys that match a
particular pattern well if you were
doing this executing this on the client
it would have to download every key then
it would match them against the pattern
and then you would get your result but
in this case we can write a snippet of
code but because it's serialized it gets
sent to the server the server executes
this and it only sends back the keys
that actually matched the nice benefit
of this is that you have all in one
place both the code on the client and
the code on the server all nicely
self-contained so it makes it much
easier to read and understand what it's
doing
also if the client for whatever reason
say this is actually being executed on
the server then the server can just say
well I'm not going to serialize it I'll
just run it myself so this can all be
handled in the library
without the the developer writing this
interface needing to know those details
so say we want to turn a list into a map
so this is actually quite a common use
case of streams and one of the functions
that can be used is a thing called
function identity and it has a very
simple implementation I actually favor
just listing T arrow T because in fact
each shorter than the method writing
them Ethical itself a function dot
identity and then you can also see what
it does a little bit clearer but so that
that's converting from one data type to
another as a fairly common a use case
where it streams to a very good job
so another puzzle for you I create a
stream of six integers I print out the
even or the even integers and then I
want to print out all the odd integers
does anyone know what happens when I do
that it'll fail and in fact what happens
is that it gets an illegal state
exception that on the second attempt
telling you that it's already been
operated or closed so this is one of the
gotchas of streams compared to some
other languages where this is not the
case
you cannot reuse a stream so if you have
a data set that you want to reuse you
might have to use a different library
that does support this or you have to
take it into a collection which you can
then reuse as many times as you like
so I gave an example earlier of being
able to sum up decimals either
imperative style or functional style but
what about big decimal because one of
the things about big decimal for me at
least is that there's unlike say c-sharp
there's no language support for decimals
it's just the library and in fact again
it doesn't have great support in streams
either so what you have to do is you
have to do a reducing function so you
start with the value 0 it's a big
decimal then you write a function that
will take each value of input
in this case it was a series of trades
and then adds those values together and
then eventually you've got an
accumulator now I've written it this way
because it's the slightly more elegant
way isn't as quite as obvious but in the
middle stage you're grouping together
everything that that thread will have so
if you you parallel stream so imagine
you've got 16 threads then every one of
those 16 threads will start with 0 and
keep accumulating those results but
finally you're going to end up with one
result for each of those 16 threads how
do I combine the results of those 16
threads well that's what the last
expression does which is called add and
that just adds big decimals together now
a clearer way of rewriting this is
actually to use map to extract out the
big decimals we're interested in and
then you can see that we all we have to
do is well it's big decimal to add all
the values within a thread and then big
decimal to add to values between threads
it's not quite as obvious because now
those two terms are actually the same so
this is a something of an anti pass all
that comes up on stack overflow there's
often the question how many objects does
this create and often it's a little bit
misguided it'll it'll have say a section
of code that's got some strings and
really they're only thinking about well
how many strings did I create and do you
understand how string literals work but
in fact the reality is that most strings
wrap a string char array in Java 9
they'll probably wrap a byte array and
so that's actually another object for
every stream there's actually two
objects but it's worse than that because
in some examples they don't just give
you a snippet of code they actually show
you the main and the class that's in the
reality is to start up main and to start
up that class takes more objects
probably a lot more than you might have
imagined so this is particularly the
case of streams because as I mentioned
lambdas are generated at runtime and
there's a long time library that goes
and generates bytecode and compiles it
so that on the startup that could be
quite expensive
once the jaebeum's warmed up it can be
very fast but to start with on the very
first invocation certainly for the very
first invocation of streams you can be
surprisingly expensive so anyone has it
a guess as to how many objects this
piece of code will create note I put in
system in dot read so the program just
stops so that I can do a J map and get a
histogram of how many objects get
created so I'm willing to guess how many
objects he created well actually the
closest estimate is 20,000 so from this
one line of code which has one lambda R
in it and one array of four objects we
actually end up with 20,000 even though
I use the in stream which is primitive
so this is what the dump looks like yet
integer arrays which are really big
they're often used for character
encoding char arrays which are sitting
underneath a whole lot of strings byte
arrays which are used for decoding
classes then the next biggest one is
actually to do with the code generation
it uses a its own internal use of object
web which uses to generate code on the
fly finally we get in string and string
has got four and a half thousand so if
you're wondering about that string
example I mentioned earlier even without
streams just a simple hello world
program you're going to be looking at
about 10,000 objects so and then it goes
further down the class the one at the
bottom that's my pet hate which is
string buffer string buffer has been
practically deprecated for ten years now
it's Java doc says don't use it use
string builder and yet the launcher uses
it almost as much as it uses string
builder and the irony is that classes
such as simple date format used string
buffer and yet simple date format is not
thread safe so how could this be well
there's a kind of design flaws
if you've got something like hash-table
you can do a get ordinal put and they're
useful operations in and of themselves
their atomic you can do a get and then a
put and that's all you need to do it's a
single operation or a string buffer each
individual method is thread safe but not
a combination of them so if you do a
pend that's it you can't do a two string
or another append because that
combination that will release the lock
in the meantime so unless you've used
external locking string buffer is almost
useless for multi-threading in which
case you may as well have used string
builder and make it really clear that
you're doing external locking so yeah
there's a parade of mine it never made
any sense in my opinion so okay so how
do lambdas perform well we actually use
lambdas in some of our low-level
performance based api's in this case
we're using lambdas in a couple of
different ways one is as a setter and
you'll notice that in the bottom part of
the code we're actually passing in an
extra value as an argument to avoid
creating a capturing lambda so we create
a non capturing lambda on the right and
then we pass in that extra argument
which is in this case this so that we
can set that field on this the in the
first case it's message field gets set
when the message field comes in its read
so with a bit of rearranging the API you
can make it that your lambdas can be non
capturing by making that the additional
data they probably need is an extra
argument so there's a little bit of
refactoring but it has the benefit that
this can produce no garbage so one of
the interesting things about enums and
Lam does is they can actually be used in
some cases interchangeably
and in fact we do in this API so an ena
a lambda is an interface which has one
abstract method however enums can also
implement interfaces so instead of
having snippets of unnamed anonymous
code you can actually pass
an enum to where you would normally pass
in a lambda and now you've named it this
has some upsides as I'll mention in a
moment but in this case we week and this
is somewhat of a contrived to use case
because why I key it's only anonymous
method is name and it returns a string
but enum actually implements name for
free so in this case we've got an
interface which is a functional into
functional interface but we didn't
actually have to write any methods for
it because enum gives it to us for us so
then we can you as you can see in this
case on the on the left-hand side of the
code here we've used lambdas which
allows us to create some arbitrary
string names or here we've used in amps
and that way we can keep them similar
now why bother doing that at all well
actually we can extend those enums and
use them in other ways so say I want
numbered fields instead of named fields
in the enum I can define those as an
additional parameter of the of the wire
key so I can actually use other
extensions and still use the same
interface so when when you use enums
well enums are a lot easier to debug
because they're named you can see them
in the debugger by name you can see the
class name you can then work out what
they do fairly easily they're much more
efficient to serialize because although
serialize is the class name and the name
of the the enum they can't be easier to
manage in a distributive environment
because you can build a preset list of
functions so you can have one e nun-like
operations or in this case we've got map
function and then we can list as a whole
series of enums all the different
operations you can perform on a map so
we can decide in advance what operations
you want to allow however lambdas are
much simpler to write as less
preparation involved they integrate with
generics much better because they can
take into account the context of when
they're used
so the same snippet of code can refer to
different types and different situations
whereas an enum that's not the case and
they can capture values which is another
thing that enums can't do so I've kind
of given away the answer to this
question but what does the line at the
bottom do well the line at the bottom is
a lambda that returns something that
produces another lambda and so this is
kind of confusing so and this does
happen particularly to around type
inference where you've got type
inference involved you the the way
you've made your mistake and where the
compiler gets confused and produces an
error message can be quite different
because you can have many lines of code
that are all working together so how do
you resolve this well one of the
techniques that I use to resolve this so
I use the IDE to revert it or convert it
to an anonymous in a class and by using
an anonymous in a class in this case one
inside another I can see precisely what
it's doing and if the types aren't
working out I can make the types what
they should be and then use the IDE to
switch back again switch it back into a
lambda and that'll all compile so it's a
useful trick when you are dealing with
really confusing error messages to do
with lambdas escape analysis escape
analysis is actually one of the key
optimizations in Java eight for me
anyway because it can reduce the amount
of objects be created it can put objects
onto the stack unpack them basically and
it also can reduce synchronized they can
take away synchronized locking so
essentially what it does is that it
works out whether an object ever escapes
a method and if it doesn't escape a
method you can ply optimizations that it
couldn't do otherwise such as not
actually using the heap so one of the
key things that escape analysis needs to
function is inlining because if you
if it never escapes the current method
that would be quite useless you couldn't
really do anything with it but after
inlining you the in all the code maybe
in that method now so within lining you
now get this big long open method then
it can work out well does it escape
after I've in mind everything so how
your inlining works is key to whether
escape analysis is likely to a function
however they can actually get in each
other's way so this is just a note that
you don't always even with scape
analysis when it is working you don't
get as optimal code but you get pretty
close and it's kind of a free in a way
because you don't necessarily even need
to know it's there this is why using a
profiler it could be very helpful
because you might read the code and say
oh this is producing lots of objects but
if they're very short-lived objects and
they only exist in one method might not
be producing any objects at all because
the escape analysis can kick in put it
onto the stack and now no objects at all
are being created so one of the catches
within lining and escape analysis is
that the thresholds are not in my
opinion compatible so the threshold the
limit of how big the method can be after
inlining when escape analysis stops
functioning it by default there's a
hundred and fifty bytes but the limit in
which it will stop in lining is 325
bytes so if actually had examples where
you write to a very simple piece of code
and it's running and it's creating
garbage but then escape analysis kicks
in and then it no longer creates any
garbage for a short period of time but
then it does a bit more in linings
because it can it can now that it goes
over the escape analysis threshold and
suddenly it's producing garbage again
because it's turned off escape analysis
so for this reason I always suggest if
you're going to use escape analysis set
it to a higher level than your frequent
in line size and then you won't run into
that situation in this case I'm I'm
using three times the default and for me
it's never caused a problem but your
mileage may vary
it's time for another puzzle so anyone
know what this will print out yes
it's a bit of a mystery really yes well
there is a hint for you there is no char
string or character string
so in fact chars actually returns an
interest string so when you print it out
it looks like this which isn't very
useful okay so I know how to fix this
I will cast all the integers to chars
let's let me give this a go how did that
go well unfortunately I said it the same
thing and the reason is that what map
does is it always returns the same type
as what you started with so in this case
I'm casting it to a char and then it
will take that result cast it back into
an integer again for you it doesn't
still doesn't quite work so what we need
to do is to turn them into objects so
again I'm casting it but this time it'll
become a character object which is not
very efficient but at least it will work
and do what I expected so I mentioned
this example before I won't again
okay so group by this is again from some
real code first we're filtering and then
we're using group by two group all the
possessions for a particular symbol so
this is this is a reasonably common
pattern for certain kinds of code in our
case it was quite common and like I said
trying to do this imperative style is
quite hairy and messy so this is where
the first time I saw that lambdas and
streams could be a real win in terms of
reducing the complexity of code again
this is real example with to do it using
to map to create a new map but applying
a filter first so you can use contains
in a list or string but in this case
it's useful because you can not only say
contains but you contain something that
matches and a predicate or
or for which an expression is true so
that becomes a lot more powerful in
terms of being able to match this will
inherently stop and if you've used
parallel stream it will actually stop
the whole lot as soon as there's one
result that's successful so it it can
cut down the amount of work even in
parallel stream it'll try and stop early
it can be used for something like a deep
copy where you go through and clone
every I entry so you can do a copy of a
list of positions in this case okay so
this one is coming into something of an
anti-pattern
again this was from some real code we're
working at project a couple of years ago
and it's sort of well let's click the
results and then do a for each on the
results well actually didn't need to do
most of those things and you can
actually just map them and then collect
the results to a list so there's an
example of sort of sorted so one of the
things about grouping by is that it uses
hash map by default so yes you can sort
their values but the problem is that it
then puts them into a hash map and you
may not very unlikely to actually get a
saucer result so how do we deal with
that
well grouping by allows you to specify a
supplier for a map in this case a tree
map and that way I can construct the map
in a sorted manner all in one step and
then the the map I return will be
assorted that now in the previous case I
could have used a constructor for a
linked hash map but that wouldn't have
been sorted it would still that would
only continue to do insertion order
another way of sorting is to actually
chain them like this we have sorted by
one thing sorted by another and sort by
something else we found that that's
actually pretty inefficient because it's
going over the data and log in three
times and we get much better
if we create one comparator that
compares all of the fields now
interestingly if you switch from this
form to this form you actually have to
invert the order of the fields that
you're comparing because in this case
the last one is the most important in
this case the first one is the most
important so this is a rather ugly
somewhat contrived piece of code you
would probably wouldn't want to write
this all as one-liner
but what it is doing is it's actually
taking the top 20 most popular words in
a file the most most frequent so it
starts off by listing all the lines then
it's doing them all in parallel then it
goes through each of those lines and
breaks it up into a stream of words so
/b is separates on any white space then
it collects them all by key so the key
is retained so for every word I now know
I'll have a key of those words but then
the the accumulator is not a list of the
words but it's actually just the counted
result so I end up with a map which is a
frequency count but it's not sorted so I
can then take that entry set as a stream
and then I can sort them now
interestingly enough type inference will
only go down one level they don't won't
go into a nested method call like this
one this line has so even though two
lines down I didn't need to specify the
types in this example on this line I had
to where it's doing sorted comparing so
sort of comparing I've had to specify
and this is how you do specify it when
it can't work out what type in this case
the map entry is so I'm now sorting it
by value reversed so I've now got all
the ones with the highest frequency
counts first I limit 20 so I just take
the top 20 if there's any duplicates I
will just arbitrarily chop off some of
the duplicates and then I get all the
key so now I have the top 20 words
and I can turn them all into a list now
trying to do that in imperative code
would be tricky but it also certainly
couldn't do it as a sort of notionally
one-liner now streams aren't all good
I've seen examples such as these where
people had decided they're going to use
streams and it would have just been a
lot simpler if they hadn't so in this
case I I'm not too sure why they took a
copy of the balances before adding them
to combined list they could have just
used a doll in the second case again it
could have just used a couple of a dolls
or perhaps a flat map so it could do a
flat map of the two lots of trades and
then combine them into a list another
thing we see particularly people that
aren't used to using optional is that
there's a sort of an attempt to avoid
using optional and I call that optional
denial so in this case the easiest way
to avoid using optional is you just do
or else null and then of course you have
to go and check whether you got null or
not so you go back to your old
programming style and would pretend you
not using option this is again a real
case where we not only check that the
optional is not null we also check
whether the optional itself is null and
so this becomes a lot simpler I probably
should have included the example but
this becomes a lot simpler when you
actually just use a series of streams
because you can stream off optional as
well okay so it's getting late so I'm
glad I finished a little bit early so
there's a little puzzler at the end just
at the bottom there on my machine when I
run that I get cyst I get an exit code
of 84 no of 80 because it divides up the
work and if the fork/join pool hasn't
started what will happen is the the work
assigned to the current thread comes in
first
and that just happens to be on my
machine for the number of CPUs I have
starts at 80 and then I go to system
exit of 80 and all the others get thrown
away because there they get killed off
anyway thank you you have some questions
okay you can ask me questions later if
you like</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>