<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JAX-RS 2.1 Reloaded by Santiago Pericas-geertsen | Coder Coacher - Coaching Coders</title><meta content="JAX-RS 2.1 Reloaded by Santiago Pericas-geertsen - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>JAX-RS 2.1 Reloaded by Santiago Pericas-geertsen</b></h2><h5 class="post__date">2017-04-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/x68STOyYgTo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so I'm Santiago Rica's Carson
I'm the co SPECT lead for jax-rs 2.1
right now I've been in jax-rs for a few
years now and today I'm gonna give you a
quick update on this latest minor
revision of jax-rs and talk a little bit
about the things that we're working on
at the moment many of the things I'm
gonna be talking about today are very
much under work so our really some of
the discussions are just even starting
in the expert group so it's all really
bleeding edge stuff that we're gonna be
talking about today so the three main
big-ticket items that we had for this
minor release are rather important I
would say and I'm just gonna focus on
those there's a lot of little other
things that we need to do for this
release but I'm just going to focus on
the on the big topics so the first one
I'm going to talk about is is some
reactive extensions that we are building
for the client API I'm sure people have
learned a lot about reactive at this and
some other conferences recently and it
actually fits really well with jax-rs
client API and I think people are going
to find that very useful the other topic
I'm gonna talk about is server-sent
events this is something that we try to
add into jax-rs
in version two as well but we sort of
run out of time and I think it also fits
rather nicely with the last topic I'm
going to talk about which is
non-blocking i/o all right so let's
start with some of the reactive
extensions before I show you the new
stuff I like to talk a little bit about
the old stuff the things that we've
added in jax-rs 2 and in a sense they're
already old and we think that there's a
better way of doing things so in Jax
restitute ro we added support for
asynchronous processing and this
affected both the client side as well as
the server side so on the server side
what we did is we added a new annotation
call that suspended and a new type
called asyncresponse and
this is the way you basically indicated
to the jax-rs runtime that you wanted a
your resource method to be asynchronous
in that perhaps the response to that
request was going to come on a different
thread and essentially the request
thread could be freed and used rather
other things a lot of people have asked
why we've added those two things
wasn't it sufficient to just at one of
them we'll see some examples and and the
answer to that is that whenever you have
a parameter in a resource method that
doesn't have any annotation then jax-rs
is gonna think that's the entity so we
had a problem there that's what we
needed to add the ad suspended
annotation the other thing we did is we
extended the the client API to support a
synchronous processing in at the time we
worked with whatever was available on
the JDK which was the the future type
many of you may have used that and we've
also added a new type that we felt was
necessary at the time which is called
invocation callback so let's take a
quick look at a couple of examples to
show how to how to use this so the first
one is future and again we're talking
about the the client API here so the
first part of the example is the normal
bootstrapping code we have with Jack
Sora's client the interesting part is
what happens when you construct your
request so we added this notion of a and
invoke to the client API and you could
actually switch invoker's along the way
so normally you would get the
synchronous invoker but if you want you
can switch to the async and poker and
then things will you know work a little
bit differently and you can see here in
the async all highlighted in red this
essentially changes the overall type of
the expression and goes from something
that was supposed to be a light string
to something that is going to be a
future of string so with that you were
able to quickly switch between different
types of invoker and in fact we're going
to see that we're going to continue
exploring that extension when we go to
reactive but the problem with the future
is that it's not as powerful as we want
to the the basic model with future is
that it's a polling model so when you
have a future it denotes and I think
company computation and you need to
check overtime to see if the value that
we're waiting for is available and of
course we all know that polling is not
the most efficient way of doing things
so it often happens that you just get
tired of it and then eventually you do a
get and you just request the value of
that asynchronous computation and of
course two things could happen the value
is available and you get it right away
or you block right and so the whole
thing that you were trying to avoid at
the beginning it's it's back in in in
play here so because of that shortcoming
we said well you know this may be
sufficient for some applications but
other applications may prefer the
alternative to polling which is
callbacks and this is why we introduced
the invocation callback mechanism so
with invocation callback this is a Jax
or a specific type what you do is is
when you specify the entity first of all
you continue to use the async invoker
but when you specify the entity you say
here's my invocation callbacks just let
me know when the value is available and
of course this you know this may happen
on a different thread and whatnot but
the the idea is that you don't need a
poll you don't need to wait and you
don't need to block and so the
invocation callback has two methods
completed and failed which are standard
you know things we've seen in other
api's at the time this was not available
on the JDK so our only option was to to
add this so this is obviously a step in
the right direction so now we don't have
to poll and we don't have to block but
there's still a problem
the moment you start using more than one
asynchronous computation and maybe start
composing them or using anything that
requires the value of one to be using
the other or wait for more than one then
the code becomes really messy and let me
show you the example so here's an
example of composition you have two
asynchronous requests synchronous
computations if you will more generally
speaking where the value of the first
one is used as the input to the value to
talk to execute the second one so we
have an initial target one where we do a
request we set an invocation callback
and when we get the value in this case a
user we take that we put it in a header
header and then we execute another
request and as you can see
this becomes less and less readable for
those of you that have experience with
JavaScript this is often referred to as
the pyramid of doom because we start
programming and nesting these things to
the point that it becomes impossible to
read so obviously we need something a
little bit better than this and the
aggregation use case is becoming more
and more popular so we really need to be
able to execute multiple of these things
and combine them in easy easy ways so
here's some of the use cases for
asynchronous computations the one I just
showed you is composing two of them you
can combine two of them where you wait
for the value of two or more of them and
then execute a certain task you can
consume the value if you have a
collection of these things you may want
to wait for one of them or for all of
them to complete and and so on and so
forth well the good news is that the JDK
has improved and we now have better
types to integrate into jax-rs and the
way we can do that today is using
completion stage so this is in JDK 8 and
which we depend on now and anything that
you see here you're going to be able to
run on jacks let's do that one so again
we use the same extension point we had
before except we have a different
modifier for that expansion point point
instead of being async it's our X and
then once again just like before the
type of the entire expression changes
from just being a string to in this case
being a completion stage string now the
good thing here is that we didn't have
to reinvent the wheel we didn't have to
create new types once you get a
completion stage then you can use the
API from the JDK to combine them and do
whatever additional computations you
want so this is in essence the same
example I had in the previous slide but
hopefully much easier to read so once we
get the the first completion stage then
we can compose that and you see the dot
then compose invocation there even
though composition is really a binary
operator you know the way it's expressed
in the API is using methods so we say
see s1 dot then compose and we create
the other invocation in the same way we
did before and then we get again get a
a completion stage as a result so in the
sense completion stage is a much more
first-order thing than what it used to
be and at the end well if you really
want to bring out the final value then
you wait on the cs2 to complete and then
you print the quote so again the API
that the JDK provides is is quite
powerful and all we have done is just
give you at the ability to obtain one of
these types and then you can just go and
use that API but it turns out that there
are many other api's that support this
one of the most popular one is Eric's
Java some of you may have used it so in
addition to supporting completion stage
from the JDK we thought it was useful to
provide an extension point so that you
can plug other reactive api's and so
this is the way you can do that or
you're gonna be able to do that using
Jack's or a pseudo one it's basically a
two-step process we really struggled to
to get this to be done in one step we
run into problems with generics so we
ended up doing this essentially the
first thing you need to do is you need
to register a provider this is the same
registration mechanism we had in Jack's
arrest tube and in this case this is
gonna be a provider a provider for an
observable rx invoker and the whole
purpose of that provider is to be able
to create instances of this new invoker
that we want to use and again this is a
this is going to be an extension not all
jax-rs implementations may support this
they're all are required to support the
completion stage mechanism but this one
is an extension that only some of them
may support and then the other thing you
need to do is when you use the rx method
then you need to specify what is the
invoker that we do you want to use
essentially the one that needs to be
instantiated through that provider and
then once again the type of the
expression turns into whatever type that
library supports in the case of rx Java
it's called an observable and then once
you get an observable then you're on
their API and you can use in this case
subscribe to to print the final value so
we don't know which api's are gonna be
supported which libraries are gonna be
supported but clearly RS Java is one of
the main ones so it's very likely that
your attacks
implementation will support this
extension all right so this is a summary
so let me skip that so the next topic I
want to talk about is server-sent events
so as I said this is something we wanted
to add to Jack's arrest too and we
basically run out of time so let me give
a quick introduction to server-sent
events I'm assuming most of you is
anyone not familiar with server-sent
events okay all right
so services events it's a it's a very
rather simple specification originally
that was originally part of the html5
umbrella of specifications from the w3c
and the nice thing about server-sent
events is that a completely is a
completely HTTP based protocol and the
sort of less desirable feature of it is
is only a one way server to client
messaging protocol so if you use
WebSockets before this is sort of one
way or single duplex WebSockets and
there are some other limitations there's
only text-based and things like that
but it's actually very useful if you
look at a lot of the new applications
out there a lot of them are exposing
remote events through SSE so it's
actually very convenient to use and the
way this all works is there's a special
media type defined by that specification
called text event stream and because we
already have a mechanism in jax-rs to do
content negotiation and and all that
then we we can use that media type and
and essentially provide support for it
so let's start with the the client API
again there's a client and a server
component what I'm going to talk about
today is actually in the jax-rs EDR
jax-ur I still don't want ETR that you
can that you can go and get from the JCP
we've actually already made some changes
to this I'm just showing the version
that it's out in public because the
other changes are still sort of internal
but I'll talk towards the end of the
presentation why we made some changes to
this and it relates to the ideas behind
non-blocking i/o okay so for the client
API there's a new type called an SSE
event source
this you can think of this as something
that you used to create an SSE
connection so you specify a target to it
and you build it there's a builder
pattern there and once you get there
then you can subscribe to that source so
you should think of this source as being
a publisher and this is where the
connection comes later on and so anytime
you get an event then your handler for
that subscriber is gonna be called in
this case it's the print line method and
and you can react to events that are
coming from a service or remember this
is just the server to client
communication so the server and this the
client in this case cannot send messages
to the server you can only receive so in
this example we're just sleeping for a
little while so that we can get some
messages it's not really important the
other thing to notice is that the SSE
vent source is an auto closeable type
and that's why we use the try with
resources statement all right so I think
this is pretty straightforward and you
can you can do SSE without having to go
to the low-level HTTP API alright so
what about the server-side API thinks we
are a little bit more interesting here
so obviously we have an app producers
for the new media type that that we're
handling and we have a couple of new
things that we can inject in our
resource methods the first one is called
an SSC event sync which is the dual of
the source that we saw on the client and
the other one is just called SSE so the
SSE SS even sync represents the
connection the HTTP connection and the
SSE is sort of a context object that we
used to create the event in this
particular example what we're doing is
we are starting we're using an executor
to start another thread and in that
thread we do we send a couple of
messages and then we just close the
connection the sse injection here is
it's necessary to create the events and
this were shown a very simple example
where we're just adding some data to the
event but there are other things you can
do in an SS event you can look at the
protocol and there's three or four
different kinds of messages that you can
even send all right so I think this is
also pretty story for
but there's another use case that is
also very important for SOC and the fact
the one that you're gonna be finding in
practice most of the time which is
broadcasting so what if you have
multiple clients that want to connect to
the same resource and you want some
message when you send the message you
want to send the message to all of them
okay right so the first problem you're
gonna encounter
doing that being jax-rs is the fact that
the default life cycle for a jax-rs
resource class is request scope which
means that every time you get a new
request you get a new instance of that
resource class that may not be what you
want in the case of broadcasting so
let's take a look at an example of how
you could do that and we're also going
to introduce a couple of new things and
particularly the SSC broadcaster so the
first thing you do is you annotate your
class with singlet in' so that you don't
get multiple instances of this thing and
that way you can have a way of grouping
all these client connections into what
we call an SSD broadcaster so just like
before we inject in this case in the
constructor we inject the SSC type so
that we can create messages but also
create a broadcast or one interesting
thing to notice here is that even though
the life cycle of SOC and SSE broadcast
it are managed by the jax-rs runtime I'm
sorry the SSE and SSE sync are managed
by the broadcaster the broght let me say
that again by the jacksters Wrentham the
broadcaster is not managed by the
runtime so it's up to the application to
create it and use it and that's
important you'll see when you look at
some of the examples alright so this is
just a setup for our resource class so
let's see how we can actually use one of
these broadcasters so we have two
resource methods here one to subscribe
and the other one to a broadcast they
want to subscribe the only thing we do
is when we get a connection over that
resource then we essentially just push
it to the broadcaster and we say hey
here's a connection that you need to
talk to and we just send that welcome I
guess
and so the broadcast is the one that
when we send a message here then that
message is going to be forwarded to all
the clients or all the sinks that are
associated with that broadcaster so it
doesn't really matter that we're using a
multi-part form data media type here it
all
all that matters is that we're getting a
string event and we can use the
broadcaster that we created to broadcast
that message to all the to all the
clients mm-hmm why is the first one as
good good question yeah it's a it's a
diaper all right I'm sorry no no did you
say the second one or the first one no
the first one it produces that because
it's producing it's an SSE connection
that you're getting there right all
right so this is the summary for SSE
event I had I think I had a duplicate a
slide here you can see this was the
summary for the other part anyways we're
gonna skip the summaries all right we'll
just go to the next topic all right so
let me talk about the third any other
questions since we we had a question
already any other questions about the
SSE part yet to the broadcaster you need
to have a reference to yeah yeah yeah it
can be this is just an example of
somebody coming from the outside and
pushing something that wants to be
broadcasted but normally this will
happen from the server itself right all
right so skipping the summary again I
had a mix up there let's let's move on
to the next topic which is a
non-blocking i/o all right so let me
start with some motivation behind
non-blocking i/o well the main
motivation is that there are certain
apps that need a little bit more control
over the input/output and we sort of had
this this idea was here from the
beginning we have a thing Paul here from
Joxer as one who who knows about this
we've added since Jack's ours one we had
this idea of streaming output was a way
of providing applications a little bit
more control sort of a lightweight
message for a writer but it turns out
that that's not sufficient for what
these new breed of applications require
where you have a high throughput
requirement on i/o so we struggle with
this idea of how to do non-blocking i/o
with jax-rs
and i'll show you a little bit where the
discussion started and where we are at
the moment so first before we move
forward as I said let's let's have a
look at what we had since jacks or s1 I
don't know how many people have used
this particular type called as streaming
output but the basic idea is that you
could actually have an entity of type
streaming output either the way it's
shown here in the example or you can
return it as part of your resource
method and all you had there is the
ability to get access to the runtime if
you will at the time the entity was
gonna be written so at that time you
could rather than using a message or a
writer in this case you can just have
full access to the underlying stream and
write to it of course as you can see in
the example this is an old-fashioned
output stream and in particular it's
gonna be a blocking output stream so
you're gonna get called just exactly
once here and you're gonna be given the
ability that's right but there's no
guarantee that that right is gonna be
non-blocking
so even though this was something that
people thought could be done it really
doesn't work for the non blocking i/o so
based on this idea the first proposal
was to go something in this direction so
what if we had another type of streaming
output if you will obviously at this
time we already have lambdas so there
was not a need to create another type
and the basic idea here is that this
write handler is something that will be
called multiple times if you're familiar
with the way servlet does an i/o this is
somewhat similar to that by the jax-rs
runtime and so every time you get call
you have a chance to write some data to
the output stream and then you also have
the chance to indicate whether there's
more data that you need a right or not
and so this was the initial thought
about how we can do an i/o in the
context of jax-rs but there are a number
of shortcomings with this proposal in
this
why we're moving away from it in fact
some people have actually implemented
this extender jax-rs to do this type of
thing but they quickly realize that
there are some shortcomings as well so
these are some of the limitations first
of all this operates at the level of
byte streams and we all know that if all
we need to do is byte streams we
probably can use some other library
you know jax-rs is is is great for doing
slightly higher level things like
operating at the level of poachers for
example and that's why we have all this
technology around message for readers
and writers and whatnot the other thing
is that it was very difficult to see how
this extension could integrate with the
rest of the jax-rs pipeline especially
with the additions to the jax-rs to the
tow pipeline so naturally the readers
the writers but also the interceptors
and the filters and finally as more
libraries are coming out and we started
looking at what people were doing we
realized that this doesn't really
integrate with anything so unlike the
the reactive example that I showed
before which was easily integrate able
with existing libraries just doing this
byte oriented and i/o thing did not did
not fly so the current proposal and
again this is something that has started
very recently just a few weeks ago is to
go with the flows approach so some of
you may know that there is a type called
flow unfortunately is in Java 9 and it's
it's essentially a copy I think it's an
exact copy of what originally was part
of reactive streams the problem here
obviously is that jax-rs to the one
cannot depend on Java 9 so we need to
depend on Java 8 so we're gonna have to
jump through a few hoops in order to do
this and we're gonna have to create some
additional types but I'm not gonna bore
you with the details so I'm just going
to talk as if we could run all this out
of the box and the advantage of using
flows as we're gonna see in the next few
slides is that it's not just for bytes I
mean you can certainly use bytes you can
use a byte array of load byte arrays for
example but it fits much nicer with the
rest of the jax-rs pipeline and and how
we do things in jax-rs and the other
thing that is nice about it is
that it provides the possibility to
integrate with third-party libraries
just like we did in the reactive case
and I guess another great thing about it
is that it's a very simple model to
understand for the most part so there's
basically just three concepts and these
are patterns that we use all the time in
computer science so it's just a an idea
of putting them together more than
anything else so the first one is the
context that I'm sorry the concept of a
publisher and the publisher is something
that can produce something and will see
that something can be different things
we also have a subscriber which is sort
of the consumer for whatever the
publisher produces and finally we have a
processor and the processor is going to
basically act both as a publisher and a
subscriber and of course this is a
really nice model because it's very
composable if I take the processor and I
put it right after the publisher then
what I get is basically a new publisher
right and if I take the processor and I
put it right in front of a subscriber
then I get essentially no subscriber so
it's easy to build this pipelines and
these flows in terms of entity
relationships as I said a processor is
both a publisher and subscriber and
naturally a publisher can have zero or
more subscribers all right so this is
all great how does it relate to two
jax-rs
if it does it all so let's try to see if
we can connect the dots here obviously
an i/o is usually something that takes a
little bit more work to get right and so
it may not be for all the use cases that
you have today but it's certainly for
some use cases and this is what we're
trying to identify as part of this
process in particular we believe it's
beneficial for large payloads and the
rationale for that is that the
likelihood of blocking when you're
reading or writing is much higher when
you're writing a large payload right if
you're paler is very small then you have
maybe you're lucky and you can read it
right away so the idea behind this is
that most of the large payloads in that
jax-rs has been used for involve
collections right so you have a
collection of some
thing and that collection can grow and
if you need to read all that from from
the network then may that may be
time-consuming and you may want to do it
non-blocking Li and so in terms of or in
flow terms basically a collection
approaches you can you can think of that
as being a publisher for poses right so
whenever data is available on the on the
network then you you read as much as you
can once you get a poacher then you push
it through the pipeline and you keep
doing that for all the poachers that
that you read so essentially you're
creating a more of a push model but
still within the the jax-rs model as we
shall see alright so how is this gonna
look from the from the API perspective
alright so here's an example one of
those examples we put together for
processing a collection of pojos so we
have a post we consume application Jason
the entity here it's called publish it's
call pojos sorry of ty publisher poggio
so this is a new thing that directors
will need support and we're using the
async mechanism that I mentioned at the
beginning of the presentation where we
say I will win a process this on a
separate thread and so we inject the
response that we can then pass to
whoever is gonna be responsible
producing that and then since in this
very example in this simple example all
we're going to do is we're just gonna
subscribe a new subscriber for those
poachers which is part of the
application code and anytime we get a
new pojo then we can process that pojo
and do whatever we need to do with it
and finally when we get informed that
there are no more poachers coming from
the from the publisher then we can use
the response object to return the
response and say yeah no no no because
that's that's the the entity in this
case yeah
you have multiple well this is really at
this point is really designed for one
collection one large collection but that
doesn't mean that you cannot do an i/o
in other ways and I'll come back to that
later
all right so even this what appears to
be a simple example there are a lot of
hidden details here and you may be
asking you know why is this all gonna
work and how does it work so as many of
you are familiar those that are familiar
with jax-rs are familiar with the notion
of a message for a reader message what a
reader is a way to turn a serialized
pojo into the poacher into an object
that your application can operate on but
in this case we're talking about a
collection of those things so how do we
divide a collection well we need
something new in order to be able to
process these collections so one of the
things that we've been discussing is the
idea of introducing a new type of reader
this could be done in two different ways
it could either either be a new type of
reader or it could be new functionality
on the existing readers that you would
need to implement if you want to do niño
I'm leaning more towards the latter so
we'll see how this goes but obviously
processing a collection it's not the
same as processing a single object so
you need some additional help from the
application to do that and in the case
of Jason and things like that obviously
they're going to be provided out of the
box so we need to know how to process a
collection approaches and everything I
just said obviously applies to the
message what a writers as well because
you can do an i/o writing not just
reading so let's have a look at an
example of that so remember before that
I said that a processor was something
that was both a publisher and a
subscriber so you could have a resource
method that takes publisher think of it
as taking a stream of poses and returns
a transform stream of those projects
just to make it really really simple so
here we have a jax-rs method that not
only takes an entity of type publisher
poggio but it also returns one and that
may be confusing at first because what
does it mean to return a publisher
well in this case what we're doing is
the application it's creating its own
process or you know I'm not going to
show you the code of my processor
because I don't even know what it does
and but all we need to do is we we can
subscribe to the entity which is called
pojos using our processor and because
our processor is also a publisher then
we can just return it as a value of the
resource method so basically what you're
doing is you're sending a stream a
poacher's doing some transformation on
them and getting them back but you're
doing this all using an i/o because the
system is gonna guarantee that it's all
done through n io
any questions on this I I know it takes
a little bit now this this may seem
related to sse we looked at the sink in
si si and I want to come back to this
example when when we talk about SSE
alright and so the other thing that this
was going to promise us as I said at the
beginning is the idea of integrating
with other libraries and I honestly
didn't find a good library so I just
made up one here so don't look it up
because it doesn't exist but let's
assume that you have a library a
database library that knows how to do
how to return a publisher for objects
that you're querying from that library
which is you know perfectly reasonable
to think about so the integration it's
provided at the level of that flow API
so let's say you do a get in this case
and you specify your predicate so you
run one of these database queries and
that returns a publisher a POJO right so
those poses are going to be pushed from
the database to the network in an n io
fashion of course there's a lot of magic
that happens behind the scenes here the
jax-rs runtime needs to subscribe to the
publisher that you return and the
initiation of that pushing needs to be
synchronized there's a lot of little
details that we're still working on but
at least you can get the the basic idea
there's as long as you have a library
that does flows you're going to be able
to integrate with with Jack's arrest
alright so another thing I mentioned at
the beginning was what about the rest of
the jax-rs pipeline
jax-rs is not just about resource
methods we have filters we have
interceptors readers and writers and
whatnot so the answer to that is we're
still working on what's the best way to
do this but think of a filter in jax-rs
a filter is looks a lot like a process
or right it's something that sis sits in
between the flow of data and that's some
transformation on it the intercept
intercept there is somewhat similar but
it's more of a typed filter it's really
related to the entity and notes of notes
about the type of the entity that you're
dealing with so just like in the case of
the readers and the writers we have a
couple of options the first one is to
add some new methods to these things for
the niño case and the others to create a
whole new type and a whole new pipeline
for an i/o which seems like a lot of
work and a lot of new types which is
probably not the direction in which were
going to be going so the discussion is
still ongoing around how to do this but
there will be support for niño at the
level of filters and interceptors and
whatever support we come up with here
it's gonna probably have an impact on
this idea of the niño body reader and in
our body writer it's likely going to
have an impact on the way those are
defined all right so so far I talked
about the server API but naturally we
can also do this at the client API level
we also want to do niño there so it's
it's basically what you would imagine
we're gonna do essentially the same
things we've done for other things in
jax-rs
one of the nice things about the jax-rs
client api api is that you can reuse
certain things that you build for the
server so you may want to reuse a
message reread or a writer and intercept
and things like that because the client
library also supports many of those
concepts so the idea here is exactly the
same we're gonna try to use the niño
body readers and writers on the client
API if you so desire and of course we're
gonna need a new invoker that's what we
seem to be doing all the time in these
days so the way to do niño on the client
API at least the way we're thinking now
is as shown in this example so just like
before you can ignore all the noise and
look at the niño modifier there and that
returns that's once again going to
change the type of the expression to an
n io type which
our case is going to be a publisher and
I'll talk a little bit about about
naming later on and then once you get
one of those objects then you can just
use the normal flow API you can
subscribe to them and you're gonna be
able to read pojos out of that
connection and of course jax-rs is going
to guarantee that everything is gonna be
done non-blocking Lee
alright so talking about vocabulary and
this is sort of a sore topic we I have
been using publisher and subscribers
simply because I think most of you are
familiar with those concepts but we may
have to use different names you may have
noticed that we use different that I
already use different names in in the
context of SSE and and the reason for
that is for this is because since we
cannot depend on Java 9 we have to have
some support inside jax-rs for the Java
8 users maybe in the future there's
gonna be a new version of jax-rs that is
going to say forget about all this just
run on Java 9 but at this moment we
can't do that but the other interesting
thing about this is that once we look
closely at the way we could do an i/o we
we realize that well but this rings a
bell here what we're doing here it looks
very similar to SSE in the sse case if
you remember we're actually injecting a
sink into the method but an alternative
to that is to return a publisher you
don't have to inject this thing you can
also return a publisher so in fact you
can think of the sse case as being a
special case of the n io flow api
doesn't necessarily gonna guarantee the
n io part we haven't really talked about
that but from the api perspective it
certainly looks very similar so this is
not this is what i said at the beginning
that even though the EDR is out and we
have an API for SSE we think it's going
to change because we think and flow is
nothing more or NSSC connection is
nothing more of a flow of sse messages
so we're going to go back to that we're
going to look at how we're gonna name
these things obviously we can take a
copy of the flow type from java 9 and
put it in jax-rs but that's that's
probably going to be very confusing so
that this is why we're thinking
about some minor rename at least for
this particular version all right
finally a summary that I think it's
correct so for the IO part the direction
that we're going is based on flows I
mean there are some limitations you
brought one up about you know what if I
have more than one collection but flows
allows you to do not just publisher
oppose you you can do publisher of byte
array of course that's not the biggest
solution but the point is that you're
not you're not going to be limited to to
produce if you want to do byte
processing you're gonna be able to do as
well we need the ability to do readers
and writers for these collections we're
still trying to figure out how that fits
and the rest of the system one of the
biggest problem we have is because we
talked about integration with
third-party libraries and all that and
of course all that realize that on using
the same types if I you know if I use a
different flower than than the other
library then integration is a problem so
unfortunately the solution for Jax is to
the one maybe just some adapters that
are provided out of the box that you can
use to convert types that are
essentially the same type and as I said
before maybe there's there's gonna be a
jax-rs 2.2 or something like that which
will say you know forget about Java 8
will go into Java 9 and just use
whatever is there alright now I already
mentioned that okay so just to conclude
the presentation we're working on the
public release we're looking for
feedback so you can subscribe to the
jax-rs user alias all the communication
among the experts it's going to the user
alias as well so you can certainly
comment on them and as I said even
though the EDR is out and there's an API
they are for SSC it's very likely to
change based on the latest find that's
that way I want the flow API alright and
I think I finished early for a change
yeah yeah I think if we're going into
this idea of sse being a special case of
flows you're gonna get better okay have
you consider using an interceptor or it
didn't okay do you know what an
interceptor is vaguely well you people
you know what an interceptor is in CDI
yeah so you have a method you say I want
to intercept the call to this method and
anytime somebody calls that method you
get called right and you have a chance
to do something either before the the
method is called or even after the
method has returned so you're basically
a wrapper on that method okay so an
interceptor in jax-rs is essentially the
same thing for a message for a reader or
a message for a writer so it's an around
read to interceptor and around or read
from rather and around right to
intercept so perhaps what you're saying
composition can be could be done with an
interceptor and then all you need to do
is just register that interceptor
right right yeah I think I believe
that's true I believe there are other
things that are not in IE am I mistaken
yeah I I don't I don't really have a
good answer you need to talk to Mike
reserve a guess as to why they decided
to leave it out we have seen a lot of
examples where you actually want to do
SSE from your own Java applications so
as to give you a concrete example cats
CAD systems containers as a service
systems like kubernetes and marathon and
all those they often expose an SSC event
stream so if you're doing anything with
those things you're gonna be able you're
gonna be able to open connections and
listening which before you could do but
you had to open like an HTTP connection
and then parse each event inside you
know look for the colon and whatnot and
it's going to be much easier to do it
with us as far as the browser support
yeah you know don't use IE
any other questions
okay so you have a synchronous response
know you want to return and you cannot
do that before returning from the right
I don't know I can't think of anything
that you can use from Jax or si I
suppose you can use things from Java
right you can create another thread and
with the async case one of the things
you can do if you define you know if you
use the async response pattern then the
jax-rs runtime immediately knows that
you're going to be processing the
response in a different thread so it's
going to essentially once it's good once
your returned it's gonna free the thread
the request thread right and then you
can do whatever work you want on that
and if there is a response that happens
later not I don't think this is your use
case but if there was then you can
respond from the other thread this is
why I think it was introduced that may
help I mean one of the issues that we
you have in certain containers Java
containers is that you have a limited
pool for server requests so you don't
want to start blocking all of them
because you're gonna run out of them and
then your server is going to start
tonight oh is that why you're asking so
the show you should so you should
definitely look at the async then
because I think you're gonna be able to
do it that way all right yep
yeah yeah yeah it's it's it's it's there
well there are a lot of little areas
where the integration with CDI was not
great I don't remember all of them but
there was one around constructors for
example that wasn't great
and and the biggest problem has always
been the fact that jax-rs is sort of
multifaceted it can run with jibt sorry
with CDI or without and you can run in
in EE or outside and it's very difficult
to make it work in all the environments
even though we have a lot of conditional
statements in the specification that
basically say if you're running here
then you do this there are a couple of
things that we want to do in in CDI but
frankly since we restarted you know
people know that we've been off a little
bit on our schedule we will focus on
these three items we haven't had any
discussions whatsoever on Cydia it is it
is plan yes we have Cydia and we have a
lot of other little things that we want
to tackle but once we finish these three
the the current plan is to try to
complete jax-rs by July yeah so it's a
rather aggressive yeah yeah I don't
think it's gonna be a huge task the
things we want to do because I don't
know that we can fix all the problems
really the Cydia well I don't want to
come into it in somewhere in July Linda
is here she can talk about EE
I think the schedule that is published
on the JCP side says September or
October something like that but it
hasn't been updated we really were
really targeting July yes
can you no no the interceptors already
exists from jax-rs to now we just know
we just need to make sure that they work
with the niño flow because all the
interceptors and filters and everything
we've introduced is they they all have
to do things with output streams and
input streams and they're all blocking
right so if we want to do flows and we
want to do know things non-blocking ly I
don't even know that's a word but I keep
using it then we need to we need to
extend those those things well there is
there is an integration with CDI already
in jax-rs - yeah right no it's not
yeah and and again the reason for that
is the fact that what I said before that
is very difficult because jax-rs needs
to run with without CDI and in fact if
CDI had appeared before jax-rs you know
or at around the same time we wouldn't
have the add context thing and some of
the other things we've introduced and
jax-ur is simply because that was not on
the platform so Jackson add context is
it's basically a way of injecting things
in jars and that you know and then the
problem is that CDI appear and then we
needed to align with CDI but we needed
to maintain backward compatibility and
things get messy
yeah do you have a specific example is
it the Constructors that you trip down
that's right yeah yeah and unfortunately
it's a very difficult problem I wish I
hadn't nobody seems to have a good
answer to to do those two things fully
integrate with CDI and maintain backward
compatibility that's the very problem we
have all right I guess that's it thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>