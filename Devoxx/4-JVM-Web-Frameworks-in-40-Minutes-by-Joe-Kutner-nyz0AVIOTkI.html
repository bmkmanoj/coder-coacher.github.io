<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>4 JVM Web Frameworks in 40 Minutes by Joe Kutner | Coder Coacher - Coaching Coders</title><meta content="4 JVM Web Frameworks in 40 Minutes by Joe Kutner - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>4 JVM Web Frameworks in 40 Minutes by Joe Kutner</b></h2><h5 class="post__date">2015-11-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nyz0AVIOTkI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">ready welcome to for jvm web frameworks
in 40 minutes I know the question you're
all dying to know the answer to is how
are we going to cover four frameworks in
40 minutes and also isn't this a 60
minute session and the truth is that you
know this just didn't have the same ring
to it plus or minus five minutes you're
also probably wondering what this
motorized skateboard is and if you
signed up down at our booth took the
roku survey we're gonna give this away
to one of you at the at the end of the
talk so that's where I work Heroku my
name is Joe Kutner I'm the JVM platform
owner after oku so I'm responsible well
first of all Heroku is a platform as a
service for running your applications in
the cloud without having to manage any
kind of infrastructure even virtual
infrastructure and my responsibilities
there is overseeing the operations of
all the JVM applications that are
running so we host over five million
applications and handle eight billion
requests a day so we see a lot of
different types of applications in
different languages and different JVM
frameworks so that actually actually
makes me I think pretty well qualified
to give a talk like this because I've
had a experience dealing with many
different types of frameworks and I'm
not necessarily deeply vested in any of
them so if you go to a talk on a
particular framework whether it's a Java
framework Scala framework you're going
to hear it from someone who is either
the founder of it committed to it or
someone who's using it in production and
whatever it is they're they're deeply
vested in this in this technology which
makes them great at going deep on that
but it makes it a little biased right so
they're not necessarily going to point
out the warts and the problems for me
I'm allowed to hate on all of them so
you'll get the truth here no actually
what I've picked are a few that I think
show interesting characteristics and can
be compared together nicely
the one we're not going to talk about is
spring which is I mean I've got nothing
against spring but it's pretty widely
understood it's also somewhat deeply
rooted in the past what I want to look
for is
the wrong direction the the frameworks
that are going to bring us into the
future
the alternative jvm languages and the
frameworks that are associated with them
because these are languages and
frameworks that have been designed with
a web native cloud native era in mind so
the four frameworks and languages that
we can talk about our Scala and play
groovy and Rat Pack JRuby and rails and
then closure and luminous I know I think
in the notes it says a mutant but I've
actually brought it up a layer luminous
uses a mutant so we'll talk about both
them so before we can talk about any of
these individually we need to talk about
what is even a web framework because 10
or 15 years ago that was a pretty easy
question to answer whatever we were
doing we were building web applications
that had a model of you of controller
they were probably backed by a database
and we're doing some kind of crud
operation but over the last decade or so
we've introduced a great deal of
complexity into our web apps we're now
probably have multiple data stores some
are no sequel some are sequel some are
caching key value stores we have
different front-end concerns like
JavaScript and CSS and Ajax and
WebSockets our controllers have to
handle multiple protocols so press JSON
they have to do a venting and
asynchronous non-blocking i/o we have to
send email and not do authentication and
logging all these concerns that at some
point you're gonna have to confront and
modern web frameworks have taken
different approaches to solving this
complexity problem the first approach is
what we call the full stack framework or
I like to call it the big circle
approach so these frameworks have drawn
a big circle around all the different
problems you might encounter when
building a web application they try to
provide a solution for each of them so
it's a very cohesive big circle
framework the the second type of
framework is the micro framework and it
does the opposite
it draws a small circle around just the
essential components needed to get
started with a web application and then
usually provides some kind of
first-class binding or plugin mechanism
that allows you to pull in the different
capabilities of different components
that you need based on the type of
application you want to build
tailoring the framework to you the last
type of framework I just made up if you
google for nano framework you're not
gonna find anything but it is a class of
framework that I think exists and it's
it's somewhere between a template
generator and the micro framework these
are frameworks that aren't really a
framework at all but they help you do
your job and you'll see what I mean
later on so each of the the frameworks
we talk about today fall somewhere in
this spectrum and it is a spectrum it's
not a discrete classification system
rails is the most full stack of these
and then luminous from a pack or more on
the micro side so as we talk about each
of these I'm going to come back to this
matrix we're going to talk about the
different characteristics associated
with persistence and documentation
templating all of these kind of standard
web features but at the end of the talk
don't be surprised if you're not able to
build an application in any of these
frameworks this is a survey and the goal
of this talk is not to empower you to
use one immediately but to educate you
so that you know which one might be
right for you which one will solve the
problems you face best and which one you
want to explore further so you can go
listen to the the deeper dive talk on
them all right the first one we'll talk
about is the play framework this is a
full-stack framework developed by the
folks at typesafe it is reactive which
is a somewhat loaded word I'm not gonna
get too much into what that means but
we'll talk about a little bit and then
it is opinionated so opinionated means
that there is a way of doing things and
in the play framework or in a play
framework application and that way of
doing things if you abide by it you'll
have a pleasant experience but if you
need to go outside of that way it gets a
little rocky so when I say it's reactive
there's a reactive manifesto and there's
a lot of characteristics to go into
reactive but for what I want to talk
about today it essentially means
asynchronous or non blocking i/o which
are not the same thing but I'm not going
to differentiate at this point and both
these are different from what we
traditionally would see in a web
application framework which is this
walking request handling a client makes
a request to the
server and there is a thread that
handles that request and that thread
will do some data processing go hit a
database maybe hit a caching system do
all these different things and while
it's waiting on those various IO
processes it will block so it can't go
do anything else even though it's sort
of in a waiting mode with asynchronous
IO or non blocking i/o that thread will
free itself up while the database is
doing its work so that it can go do
other things and then when the database
is complete it'll come back get another
thread then respond to the client and
this allows you to chain these
operations together pipeline them and
ultimately get greater throughput in
your system not only for a single
request but for lots of requests this
diagram is a bit of a mess but I think
it fairly accurately represents what
happens in a asynchronous IO system it
becomes very difficult to trace some of
these processes through the system a
little bit more difficult to debug but
it's a trade-off right you get more
power a little bit more complexity a
little bit more concurrency issues all
right so let's take a second to do a
demo of how the play framework works
I don't live code because I make too
many mistakes so for your safety
I have pre-recorded my demo alright I'm
going to create a new play framework
application and the first thing I do if
I want to do this is go to play
framework comm but I won't download play
itself I'm going to download activator
activator is a tool for creating
managing running and essentially working
with play framework applications when i
download it I'll get a couple of
platform-specific binaries that I can
put onto my path and then I can use them
from the command line so I'll hop over
the command line and run activator new
and in the name of my application and
this will prompt me to choose a
different of a certain template for my
application I can create a akka template
or just a minimal Java or Scala
application and I'm going to create a
play Scala application so I select six
and it's going to generate the basic
scaffolding of an empty play framework
application written in Scala and because
it's a standard
SBG bass Scala project I can open it in
IntelliJ IDEA my preferred IDE and it'll
know exactly what to do with it you can
see here's the application directory
structure we have an app directory which
is where all of my application source
code will go and inside of this
directory I have packages for
controllers views the different
components in my application so if I
have models there will be a models
package this is part of that sort of
opinionated approach it defines where
you put your your components inside the
controllers I have a default application
controller and some default views we'll
take a look at these here in a second or
right now the application controller has
a single index action that will map to
the default route in my on my server so
I'm gonna start the the application up
with activator I'll execute activator
run that's going to resolve some of my
dependencies it'll start up a server and
it'll bind to a port but what it's not
going to do is compile my code it's
actually going to do this lazily so it's
once it hits the binds to the port I'll
hit it in the browser and only when it
receives that request will it then
compile the code so if I do that hop
back to the terminal see air compiling
seven Scala sources one Java source and
then I'll see your new application is
ready right so what this allows me to do
is make changes to my code and then very
quickly see them realized in the browser
so if I hop back here and I change new
to root and then save the file I go back
to the browser and refresh it as soon as
it gets that request it'll then compile
just that single Scala source so it
detects that that file has changed and
uses a Scala incremental compiler to
compile only what it needs to to make
the application work not the entire
thing so that allows for a very rapid
development workflow and there you can
see it in the browser so it also a very
rapid development workflow very easy for
you to understand how your changes are
going to affect the application this is
something that I think is expected or
people are used to in languages like
Ruby and
Python and nodejs where they're
interpreted and they get this rapid
feedback but for a statically compiled
language this is rather unique and
something that's sort of unusual all
right so I'll kill off that server the
next thing I'm going to run is activator
tilde test this is going to do two
things it's going to run my tests well
it's going to compile my test code and
then run my tests and the tilde is going
to instruct it not to terminate after it
runs my tests so it's going to keep that
process running and it'll watch my code
and look for changes just as the the
server did so we see here it's compiling
the test classes and then in a moment it
will run the tests and I'm actually
expecting it to fail because I've made
this change to the string there yeah so
it says it's expecting your new
application is ready but I've changed
that so let's leave this process running
you can see down below it's still going
and I'll change this back to new and
then as soon as I save the file it'll
immediately recompile just that class
and run the test again and hopefully
they'll past this time so just as the
getting that rapid feedback and the
browser allows me to make changes and
understand them the tests give me the
assurance that the changes I'm making
are not causing damages to the rest of
the system other parts of the
application that I might have not
expected to to be affected all right so
let's look at a few more of the files in
this application we have these template
files that use the Scala template
language which is characterized by this
@ notation each of these files is
actually treated like a function so the
the top line is actually the sort of the
definition of its parameters so it'll
accept a title and a content and then
within the the rest of the body of the
the template we can put the dynamic tags
for for where we'll use those and then
in my my code I just invoke this as if
it were a function to render it we also
have a conferee with application comps
similar to what you might see in a
spring properties file and a routes file
and some other things all right I'm
gonna kill that test process and I'm
going to now run activator UI this is
gonna spawn off a separate server
process
not my application server and this
server is essentially an IDE in the
browser for activator based applications
it'll launch this this browser for me
and immediately start building the code
just as it built it in IntelliJ IDEA
it'll allow me to view the code and I
can actually edit the code in here it's
almost a fully featured IDE in some
sense so here we see the same
controllers in views directory there's
my application dot scala my comp
directory so let's go ahead and edit
this routes file this routes file is
where we map the URLs to the the actions
in our controller I'm going to create a
hello route and then application hello
action and then in my application Scala
I'll def a new hello action so these
actions represent a unit of work that
the server is going to do when it
receives a request but you notice
they're not like a method these are
actually more like a promise or like a
Java future they're just a unit of work
that it promises it will do in the
future
a synchronously and then return some
response from so that's sort of the the
key mechanism for how it does this
asynchronous i/o all right so I'll save
that and then it'll start building my
code again and I can actually run it
right here in the in the browser once
it's done building alright so once it
finishes up I'll just click this Run
button it'll fork off a new JVM process
which is my application server at this
point the same thing that I saw running
in IntelliJ and then I get a little link
I can click and view the application
just as I did before yeah so there's the
landing page and then that will have the
hello route go so that is how a Play
application works alright so let's
review what we saw Play Framework has
excellent tooling quite fully featured
tooling for running your apps testing
your apps and even having this built in
IDE you may not think that an IDE in the
browser is something you'd like to use
and I certainly wouldn't use it on a
daily basis but it does prove to be very
useful
a common baseline if you have developers
on your team that are using different
development tools different IDs it
provides a place where they can sort of
come together share code it's also
excellent for getting new employees or
new programmers on-boarded with an
application we also saw this built in
Scala templating framework as I said
each of these templates is treated as a
function and that function name is
actually determined by the name of the
file so this is more of that opinionated
convention over configuration approach
so I can just invoke this in Scala code
as hello dot index and pass it some
arguments I didn't show it in the demo
but Play Framework has built-in database
support that uses a car ECP by default
her car CP is a connection pooling
library that's very quickly becoming a
de-facto standard I'm seeing a lot of
different frameworks adopted and it
definitely has great performance
characteristics it also has support for
slick first-class support for slick
which is a functional relational mapping
library so an object relational mapping
library Maps objects to relational
tables but there's always this impedance
mismatch and you can never quite get
them right but with a functional
relational mapping we're just mapping a
functional style of programming to our
queries to how we introspect our data
and manipulate our data so as you can
see we can have a some data set of
coffees and we can filter it based on
some predicate just like we would do in
sequel and in fact that's what happens
here these Scala
bits of Scala code get compiled to
sequel code so here's an example of
joining some tables together you can do
just about anything you can do in sequel
in Scala code so here's a full outer
join and again you get to take advantage
of all the all the features of the Scala
language as you're doing this Play
Framework also has built-in database
evolutions also sometimes called
migrations it's a very simple framework
you have a number of sequel scripts that
follow certain convention for having
up-and-down migrations to manipulate
your database upon deployment but
certainly works it also has a streaming
HTTP library built in support for
sending back chunk response and using
that underlying asynchronous
non-blocking
capability to
throughput high and has built-in support
for WebSockets and specifically using
WebSocket actors which again fits very
well into the Scala ecosystem and as we
saw built-in support for Scala tests
that was what was being executed when I
ran activator test all right so the Play
Framework is great for traditional web
apps that also do a lot of i/o so
traditional web apps being something
that's a customer facing web app with a
lot of JavaScript people are interacting
with it making orders something like
that but it's also great for getting up
and running very fast when you generate
a new Play Framework you're very much
well on the way to getting to the
application code you don't have to worry
too much about architecting it and and
figuring out which components go where
so that gives it sort of a unique
combination of attributes it's both high
powered and great to get started with
quick these two are usually mutually
exclusive in in my mind now it's not so
great if you dislike heavy-handed tools
all you saw the tooling system it's very
opinionated you know if you like more
flexibility this won't won't fit with
your your style it's also not so great
if you like backwards compatibility the
Play Framework has kind of developed a
reputation for breaking backwards
compatibility even on minor releases
there was an infamous shift from play
one auto to play 2.0 and that was in my
opinion they should have renamed the
framework it was completely different
but even through some of the minor
versions we on our on Heroku we see a
lot of people stuck on earlier versions
because the cost of upgrading is just
too much for them all right so again to
recap play framework is great with Scala
but it also works with Java so it and
can also be used in a hybrid fashion has
this built-in templates play Scala based
the underlying server for play is Metis
which is a high power library for doing
TCP clients and servers and that's what
gives it this asynchronous capability
the documentation is excellent there's a
lot of people using the play framework
so if you encounter a problem there's a
very good chance someone else has
already run into that and you'll be able
to find a solution on Stack Overflow or
on the Play mailing list which is also
very active
it's a full-stack framework as I
mentioned tooling with activator and SBT
is very strong persistence with slick
and Akari CP and then Scot latests great
alright let's move on to rat pack rat
pack is an interesting framework to put
next to play because in many ways they
have things a lot of things are in
common but they also have a lot of
things that are completely different
all right so rat pack is a micro
framework is by no means a full stack
framework but it's a synchronous to its
core and it son opinionated so it's
micro framework meaning that on what it
provides is only just a core that's
essentially routing and controller type
stuff and then it provides a first-class
binding mechanism to bring in all sorts
of different modules that do different
jobs will show some of those in a moment
as I said it's asynchronous so it's
gonna use this same model of
non-blocking i/o let's do a demo ok so
I'm going to create a new rat pack
application using lazybones which is a
template generator and this is gonna
generate just the basic framework of a
rat pack application which is actually
not that much there's just a couple
things needed for Gradle and then a
couple of rat pack files here but
because it is a standard Gradle
application I'll open it in an
intelligent to do with it so you can see
I have a source directory kind of what
you'd expect my Gradle stuff my
build.gradle you can see it pulls in
just a couple dependencies a couple rat
pack dependencies and then some plugins
for IntelliJ and an eclipse support but
really not too much right so by default
there there isn't much provided for me
I have a groovy source directory but
it's empty because I don't get it in
code I have this rat pack directory and
a rat pack groovy script which is really
sort of the heart and soul of a rat pack
application in this rat pack groovy
script I have a section for bindings and
this is where I'll pull in those
different modules that add different
capabilities you can see here we have a
for markup template this application is
going to have some HTML with markup so
we'll need it if your application is
just an API or something you may not
need it and you can remove it and then
below that I have handlers these
handlers are sort of a combination of
the routes and actions that we saw on
the play framework so I have a get
handler which just because it has no
arguments applies to the default route
and it's going to render some groovy
markup template that index GT PL so
let's take a look at that template this
is a templating language and which you
get to write HTML that looks like groovy
I'm not sure the advantage of that is
but a lot of people like it
so back to the groovy script let's we
can run this application just by running
this script and IntelliJ we could also
debug it if we needed to and that's
going to start up a server very quickly
because this is a very lightweight
framework and it will bind to a port and
then we can see it in the browser and
there just the basic application that's
all there is to it so let's add some
let's add some more to this we can add a
new handler for the hello path again and
we'll just render some text and I've
actually left the server running so I
don't need to restart or anything like
that and now I can browse to hello and
there it is so get that same rapid
workflow that we saw with the the Play
Framework
I can also add multiple handlers for the
same routes and chain them together so
as long as I call next it'll go to the
next handler sequentially in this in
this file I can also add handlers that
capture larger groups so maybe an all
handler to do authorization around all
of my all of my requests and then as
long as I call next it'll go on in
pattern match with the other ones it's
all clear those out I don't need them
let's do something useful let's interact
with a session so we're gonna pull in a
new module and the first thing we have
to do is add a new dependency so we're
gonna add a dependency on the rat-pack
session library and then when I do this
I will have to restart the server
because I've added a new dependency so
it's got to go through that that process
and then once that's up and running I
can head back to my groovy script and
now for my handlers I can add a session
argument so all oh well first I'll have
to add the module so up in this binding
session I'll add a session module and
then in my get hello handler I'll add an
argument for the session so it'll go
pass it in and I can do things with it I
can get values out of it but I can't get
anything out of it if I don't put
anything into it so let's create another
route for a we'll call it login give it
the session as well and we can just
render something in set of value will
set the greeting to two hyah
and then just render okay so now after I
hit the login route I'll have something
available in my hello route so when I
call session get but I'm not actually
going to get a string back even though I
put a string into this this session
value I'm going to get a promise and a
promise if you're familiar with nodejs
and things like that is a promise that
the server is going to do some work to
go get that value and then return it to
me eventually and the reason it needs to
do this for the session is that most
likely the session is backed by some
kind of external storage like memcache
to read it so it's going to be an i/o
operation and we don't want to do that
synchronously so instead of just using
that value I will pass the promised a
eventual execute upon retrieving that
value so I passed G in here and then I
can use it or just default to hello and
then I can actually tidy this up I don't
need to create that variable just did
that for demonstration okay so my server
is still running I'm gonna head back to
the browser go to the hello route and
I'll see hello DevOps because I haven't
put anything into the session I'll go to
the login route okay we're logged in and
I go back and now I'll see that it
retrieved that value from the session
then this this ability to do IO with the
session asynchronously is sort of a
standard feature of a rat-pack I can I
can do
about any kind of i/o asynchronously in
fact there's a first class blocking
mechanism in which I can call get and
then wrap any kind of database or
external service thing that I need to do
a synchronous Li and then get a promise
back and and pass it a then function
well it's particularly unique though is
even though I'm going to have multiple
asynchronous things happening I can
actually guarantee the order of
execution those I get a guarantee from
rat-pack that they're going to execute
an order and now that helps ease the
burden of doing this asynchronous non
blocking programming model so let's head
back to the slides all right so what do
we see Rat Pack is a very lightweight
framework but with some great great
tooling was it provide for database
nothing that's up to you what does
provide for testing well it did pull in
a testing library but that's very easy
to swap out very uh opinionated about
that what it does provide our
integrations with all sorts of things
integrations with spring integrations
with Netflix OSS pack for J drop wizard
all these are first-class so drop wizard
for example drop wizard metrics is a
library for capturing detailed metrics
about your servers performance house how
people are using your application has
specific bindings for jetty and logging
frameworks and things like that so you
can very easily pull this into a Rat
Pack application with the drop Wizard
metrics module and just here's an
example of incrementing a croc counter
it also has a hysterics module hysterics
as part of the Netflix open source
software suite it is a latency and fault
tolerance library designed to isolate
points of potential failure and a remote
system wrap them so that you can force
timeouts and add resilience and things
like that so with Rat Pack you simply
wrap those troublesome calls or
potentially troublesome calls and a
hysterics observable command and and you
get the ability to essentially build a
circuit breaker pattern it has a built
in non-blocking HTTP client so just as
we're receiving requests and processing
them asynchronously or in non-blocking
fashion we can make outgoing requests
asynchronously as well
all right so to review rat-pack is great
framework to use with groovy but it
works equally well with Java so again it
can you can take this hybrid approach
the default templating library was the
groovy templating library but that can
also be easily swapped out the
underlying server is again nettie this
is what gives us this a powerful
asynchronous model the documentation is
it's okay
but Rat Pack is very new so it's got
some time to grow into you're gonna have
a little bit more trouble if you run
into problems finding people that have
encountered the same thing it's a micro
framework it's tooling is with Gradle
and then all the other components
they're really up to you so let's do a
direct comparison of Rat Pack and play
they're both using nettie that's that's
one of their strengths they both have
this asynchronous i/o model play I think
is better suited to traditional web apps
as I said the customer facing websites
with standard kind of stuff
whereas Rat Pack is more ideally suited
to building api's implementing circuit
breaker patterns and pointing micro
services the drawbacks I think I think
the play framework developers would
disagree with me but I think it leads
more to monolithic Apple applications
certainly this is what I've seen in in
the real world because it is opinionated
because it provides these things for you
you tend to end up with more yeah more
model it's like I don't really mean that
in a derogatory way but they do you end
up putting more things into the
application and as I mentioned backwards
compatibility rat-pack doesn't have a
problem of backwards compatibility
because it just recently reached one
so we'll see how it does in the future
all right intermission didn't know that
was coming so the first two frameworks
that we looked at are very heavily
steeped in the Java ecosystem right they
both work with the Java language they're
using Gradle in these these Java tools
but why do that right if we're using
alternative jvm languages why not
branch further out and that's what the
next two languages and frameworks we
look at have done they have their own
communities they have their own
ecosystems
the first one is rails which runs on the
JVM by virtue of JRuby
rales has been around for quite some
time there's a good chance you've heard
of it it very much redefined the way
that we approach web application
development it it introduced new ideas
new ways of doing things that were sort
of revolutionary and many of the
frameworks that we play framework in
particular but many of the other
frameworks that we use today have all
drawn something from from rails so it is
very much a full-stack framework
provides many different features for
many different problems it favors
convention over configuration and it's
opinionated so full stack meaning it has
components that will do just about every
kind of thing you can imagine for for
WebSockets and all that stuff it
unfortunately though does not have an
asynchronous i/o model it uses this
standard synchronous blocking to handle
requests it is possible to do
asynchronous i/o in rails but it's very
much not on the happy path all right
take a look at the rails demo now all
right so I have a ruby interpreter
running on line on my system but if you
see when I run Ruby - V it's actually
JRuby and it's running on the JVM and
into this Ruby runtime I have a gem
install the rails gem a gem is sort of
similar to what we what we think of as a
jar file and in the Java world but it
also adds some if it's installed
globally it'll add some commands to my
path and one of those commands is the
rails command and I can use this to run
rails new and I'll create a blog app so
the blog app is the sort of
quintessential rails example because
it's a standard
crud application with restful routes and
things like that this is gonna generate
quite a bit of code for me
application code test code again it's
very opinionated so it's it kind of has
a way of in which it wants us to do
things and I'm going to open this up in
Ruby mine which is the jetbrains
equivalent IDE for Ruby applications it
works great with JRuby and you can see I
have my application directory structure
here that actually looks a little bit
like the the Play Framework directory
structure we have an app directory with
component directories under that four
different components in our application
views models controllers
let's do before do anything else let's
just go ahead and run this rails server
that's going to start the application up
and we will almost never restart it
because of its dynamic nature you can
leave that server process running just
about indefinitely and the landing pages
just tell us a little bit about our
application we're running on this
version of Ruby and Java and some of our
dependencies things like that and then
it tells us to go and run rails generate
to get started so rails generate is a
tool provided by the rails framework
that automatically generates code for
you and it's a pretty handy thing so I
can I'll just run rails generate here to
list all the available generators I have
generators for JavaScript stuff CSS
stuff tests controllers models what else
I've generators for generators so if I
have a common type of component that I
need to implement I can write my own
generator great number of tools there so
I'm going to use rails generate to
generate a new controller a Welcome
controller with an index action so kind
of similar to what we did in the Play
Framework just a base controller with a
single index action that's going to
generate my controller my tests my
helpers my CSS CoffeeScript which is a
compiled to JavaScript and so you can
see I have a simple controller extending
from a base controller and an empty
index method now this index method is
empty but that doesn't mean it doesn't
do anything in fact rails is so so
heavily favored favors convention that
just because of the name of this method
it's going to render a particular
template so in my views I have a welcome
folder with an index template and
because they are both named the same
it's going to render this this file so
that's that's how heavily it is steeped
in convention it also generated routes
for us so we have this routes file and
it generated a get route for the Welcome
index action and I'm going to make that
the the route as well so I go back I've
still got my server running even though
I generated all that code and refresh
the page and now I see that that welcome
index action
I can view the these routes are written
in rubies so there's someone dynamic but
I can execute rake routes to to have
them all spelled out for me I I'm gonna
use the generate command again to
generate scaffolding this time so
scaffolding is a more complete set of
code it's going to generate a model it's
going to generate controllers database
migrations just about everything that's
needed to have a restful service and an
backing object in my application so I'll
give this a title it's a string and a
body that is text so this is a component
in my application generates all the
tests all the styling code we have this
controller if the actual model class
which doesn't have any code in it but as
with the controller having no code
doesn't mean a whole lot the active
record which is the ORM for rails
provides quite a bit of functionality
just based on what is in the database
and and some of its opinionated defaults
we have a whole bunch of HTML templates
as well as well templates for listing
widgets for viewing a single widget and
for editing a widget so this is a little
form that all it needs is some styling
but the dynamic ER be tags which is
embedded Ruby the default templating
language they can just be pulled in as a
snippet into another web page alright
and then I have my controller and in the
controller I have a number of actions
for creating a new widget editing a
widget updating a widget all the basic
restful operations and then those routes
are defined by by use of this resources
directive and here's my migration so
let's head back to the the console while
run rake routes again and you'll see now
I have all these get put post patch
delete routes everything that's needed
for the widget and those will just
execute the the controller actions I
showed and we can run rake DB migrate to
execute the database migration that's
just above there that's going to create
a table in my database with the
appropriate columns that I defined in
that generate command servers still
running so I head back
the the browser go to the widgets page
this is my list of widgets and I'm
having a yet so I have a new widget link
that's part of my template that was
generated for me this is a link to the
two that create route there's that form
so this is the form you showed a moment
ago there it is rendered in the browser
no style but all the basic components
there so I'll fill this out click create
a new widget now I've created a new
widget in my database I can go back to
that index view it's there with the
appropriate links for showing editing so
we'll just list a single widget and if I
go back I can actually destroy it to
which even has the appropriate prompt to
to make sure I really want to do that
okay so that is how the rails framework
works all right so we saw it has a very
extensive tooling even more extensive
than the play framework there are tools
for generating new code tools for pre
compiling assets if you have a bunch of
JavaScript or CSS it's going to package
that up and do a minified file that you
can deploy with your application rails
server routes a whole bunch of other
tools that are available to you
rails is very mature so all this stuff
has has been well developed the
templating framework by default is ER be
very straightforward has this percent
tag notation for dynamic content and
within that you just write Ruby code
active record is the default ORM it's a
very flexible o RM so as I said or even
with no code that implies quite a bit of
behavior for this for this object and
then also the migrations to back it up
so these these operate hand-in-hand now
one of the advantages of running rails
on JRuby and on the JVM is that we can
use things like torque box torque box is
a ruby server that's based on JBoss so
we get all the advantages of running on
a JBoss platform without actually
running any Java code
so using torque box you can run just a
standard rails application no different
than any other rails application and
pull in the ability to do scheduling
jobs background jobs clustering load
balancing high availability all those
sort of enterprise-e features
all right so to review rails is based on
JRuby that uses ER B for templating by
default the underlying server can be
torque box that's pretty easily the most
powerful Ruby and rails server available
the documentation for rails is
absolutely excellent again this is a
mature framework that's been around for
a long time when you encounter problems
you almost certainly will find someone
who's hit that already it is full stack
tooling is provided with both the rails
command and this rake command which is
the build tool persistence with active
record and then mini tests but that can
be swapped out rubyists are totally
crazy about testing they test everything
they have lots of different test
frameworks
I think that's partially due to the how
dynamic the language is because you can
I mean you can change what string does
at runtime so you need tests to make
sure you're not shooting yourself in the
foot all right so let's take a look at
rails directly against play because
these have a lot in common and then also
you know a lot of differences we saw in
Eddy in this asynchronous model with
play but rails is still a bit more
traditional that that blocking i/o and
it's built on a fairly older and mature
JBoss server for torque box they're both
excellent for building traditional web
apps are both excellent for getting up
and running very quickly they're both
full stack the biggest difference though
is the language that they're implemented
in the Ruby language is very simple sort
of not not a good word but it's very
approachable I would argue that it's the
easiest of these languages to learn
whereas Scala is probably the most
difficult of these alternative languages
to learn so it's very complex and I
think you may challenge some developers
if you're going to introduce a new
language and that's the one the the
downside to rails can be its flexibility
for some people they would rather have
the more rigid constraints the more
strong typing and things like that of a
scala type language alright so let's
move on to the last framework luminous
which is I'm lying it's not even really
a framework they call themselves a micro
framework but I call it a nano framework
it's modular it's unup enya nated so I
put this in parenthesis because I think
luminous would probably describe her the
a person probably described it as an
opinionated but I very much believe that
it is opinionated but it's in sort of a
weird way you'll see what I mean
so when I say it's a nano framework and
that there's not really a framework if
you go on khlo jars calm organ sorry
which is a repository for all of the the
closure libraries and you search for
luminous you're gonna find two things
you're gonna find a deprecated luminous
library that isn't in development
anymore and you're going to find a
luminous template generator there is no
luminous library framework thing that
gets pulled in at runtime instead the
luminous pulls in a bunch of other
libraries and then has sort of a an
opinionated way about how you should use
those libraries so it generates a bunch
of boiler code boilerplate code for
getting you set up with those and that's
why I find it to be opinionated in a
sense the reason it does it this way is
that foreclosure developers if you've
ever met a closure developer they're
purists right they're just bad II about
everything being purely functional and
an immutable state and all this and so
for them the word framework is a dirty
word
they don't want frameworks they want
libraries and this ability to pull in
libraries actually works really well
because of their insistence on immutable
state and function functional paradigms
and all that so let's let's see what
that means in real life all right so I
use to create a new Luminous application
you use line which is the default build
tool the sort of de facto build tool for
closure applications when I run line new
and then give it a template name it'll
go out to closures org which I just
mentioned and look for a template that
matches this and it will find Luminess
I'll give it a name and then I can use
these arguments to give it different
functionality so I'll go to Postgres
database and then I'll open it an idea
actually I'm opening it an idea with the
cursive plug-in which is a great closure
IDE and because it's a standard line
project I have my project clj test
directory it already knows how to how to
deal with it so my project clj is where
i define my dependencies it already sets
up some profiles for me for running
in in development running in production
packaging up an uber jar which is a fat
jar file and of course it you know
defines all these dependencies but you
look closely here you'll see that there
is no luminous dependency so I just have
my closure dependency even closure
itself as a dependency I have database
dependencies ring composure all these
other components but no luminous what it
does do for me though is generate a
whole bunch of code for executing or
getting started with these libraries so
my server library if I use that I'm
certainly going to need to start a
server and bind to a port so all that is
implemented here for me also setting up
an end repple server which I'll explain
what that is in just a moment and then
within this routes and these DB packages
or namespaces I have sort of my custom
code and by default it generates a
little bit this for me just so I so it
can sort of guide me as I build my
application again it's sort of
opinionated about how I should do things
even though it's very much gets out of
the way so in this home dot clj I've got
two routes to find one for the route
path and one for the this about path and
they're just going to render some some
templates so execute line run to start
up the server and I'm actually going to
get it's going to bind the two ports
it's gonna bind for 3,000 for my web
server and then port 7000 for my repple
and I'll I'll show how that works in a
moment so first I'm gonna go look at
3000 in the browser and you can see
there's just a base application even
includes Twitter bootstrap for me I'll
leave that running the repple is a
interactive console where I can execute
code invoke functions and things like
that and for closure using the repple is
very much a part of everyday development
so I'm going to create a process that
connects to that and repple Network
repple essentially and then I get this
little window over here where I can run
some code I can do some math I can
invoke some functions I can actually
take this file on the left and load it
into the repple you can map this with
keystrokes I'm gonna do it the long way
so that you can see it
load up on the repple switch the
namespace to that context so I can use
shorter paths and I can invoke these
functions directly so my about page
which I
just saw in the browser I'll see the
HTML spit out as a string in the console
or in the in the repple so a lot I was
that allows me to test sort of test my
code test in the sense that I'm
executing it and then throwing away the
test but sort of vet it out as I'm
working with it and that encourages
closure developers to build smaller more
cohesive functions that they can execute
in isolation so I'm gonna find a new
function the hello function and then
I'll load this back into the repple and
I can execute it to make sure it's
working good so I got that string back
now I can go add a new route to my to my
list of routes
hello route and just invoke that
function so that it can render that in
the browser if I head back again my
server is still running
hello path there it is okay so I get
this sort of fluid development workflow
that we've seen with some of the other
frameworks but I also have this this
repple that that assists me as I go we
also have a bunch of other resources
generated for us we have a migrations
framework migrations library sorry I
pulled in for us basically just standard
sequel statements here that are run
based on some conventions so I'm going
to start up a database here and then I
can use line again to run my migrations
so it'll execute those we see above
create some tables and now I can start
using some of the database code that was
generated for me by the by the line
template yeah so I've restarted my
server so I have to reconnect my repple
and let's pull in this DB core which is
part of the the generated code that the
template engine provided for us and
let's add a function that will create a
new user in our database so we're going
to invoke this create user function but
this function is actually a function
that's defined at run time based on some
sequel statements and I'll show those in
just a moment so effectively what I'm
doing is invoking a sequel statement and
passing it some parameters alright now I
can load this into the repple and then
execute it good so I've turned one it
means it worked
but let's vet that out let's create a
get foo and call get user give it that
IDE loaded into the repple and there's
our our full cycle of the of that data
all right so the the create user in the
get user as I said they're really just
sequel statements and that's using this
Y SQL library that was pulled in by
luminous what this does is use a
convention within the comments for
naming the function but then essentially
I'm just using sequel statements so we
saw with slick that we had a functional
relational mapping tool but if you don't
really care about using the language so
much and if you're content with writing
sequel code this is in many ways doing
the same thing without a layer that is
the DES program the the primary language
you're working in all right so let's
let's create a template so we can view
these database changes in the browser so
the templating language that the uses by
default is called Selmer and it's
characterized by these bracket notation
and within somewhere I can have data
such as this Docs here below and then
apply filters to it so you'll see this
pipe notation kind of looks like
invoking a method on an object but
remember this is purely functional right
so we're we're not actually doing that
we're applying filters to data so if you
apply a markdown filter to some string
it'll render it appropriately alright so
I'm gonna create a new DB HTML and I'll
put I'll have some user data that's the
user that I created and I'm gonna apply
the join filter so the user data are the
properties that I got from the database
I'll just join them into a single string
back in my home clj I can add a I'll use
this hello route and then just render
that DB HTML and pass it the value of
the get foo function so I've already
vetted all this stuff in my repple so
I'm just piecing it together now I can
test the whole thing there's the HTML it
did an error out and when i refresh the
page there i see my my code in the
browser so while it's left is to find
somebody that's good at making things
look good and they can style it all
right
so what I was doing with the repple is a
very rudimentary but this replica VIN
development is key to working in closure
if you're interested in this more and
you have some familiarity with closure I
strongly recommend going and watching
Friends of the Dead it's a set of videos
made by a guy in Norway who has a lot of
free time and he's he's building up a
samba game from scratch using closure
ins closure script and he's you know
pulling in libraries and doing this
repla driven development ins actually
pretty enjoyable to watch and gives you
a good feel for for how productive you
can be with that kind of work
alright so within Luminess we saw the
Selmer templating language which you see
on the right but it also includes
another templating language by default
which is hiccup and this allows you to
use closure code to generate HTML and I
see a lot of people mixing these
together seems to be that there are
situations where each is is right it
also provides great support for closure
script which allows you to not write
JavaScript I think this main advantage
but it allows you to write JavaScript
essentially in closure which means you
don't get weird things like 0 being
false there's closure scripts a whole
other discussion the database stuff that
we saw me working with is y SQL as you
saw it maps things directly to sequel
code so you don't have to like learn
anything new if is if you know sequel
you'll be able to use it then Luminess
by default pulls in a mutant as its web
server so a mutant is actually the
closure equivalent of torque box which I
talked about earlier for Ruby it is a
closure server built on JBoss but
because frameworks are so nasty in the
closure world a mutant is like JBoss
broken down into libraries so the web
library is what was pulled in to
luminous but you can also pull in
scheduling libraries WebSocket libraries
caching libraries all those capabilities
that you'd expect from the enterprise-e
server so here's an example of using
WebSockets taking these functions and
applying them to different channel
routes as callbacks fits very well with
the closure way of doing things
alright so to recap Luminess is based on
closure time
with hiccup and Selmer the underlying
server can be a mutant it is a mutant by
default documentation is pretty good but
you do have to depend on the
documentation because as I said it is
sort of opinionated about how it wants
you to do things and you need to
reference those Doc's to check in see if
you're going the right way
it's a nano framework so it really is
not a framework at all use this line
again and yes ql4 persistence and then
closure test which is actually built
into the closure language that's what
everything uses in closure all right so
what do we see here we saw a whole bunch
of different frameworks all have some
similarities and differences Oh
first let's look at the Luminess and Rat
Pack directly right so Rat Pack again
asynchronous by Nature
luminous that it's possible to do that
that same model but it's not really what
what it does by default they're both
very modular
but Rat Pack is better again for
building api's and things like that
whereas luminous especially with its
support for closure script is great for
traditional web apps especially if
they're heavy on the client side and
then the weaknesses again asynchronous
can be a weakness depending on your
organization and then closure is a
completely new paradigm so if if the
developers and your team are are not
familiar with it it may be a struggle to
learn
now all these frameworks have their
differences have their similarities but
they do have one thing that there they
all have in common
none of them are deployed as war files
these are all modern JVM web frameworks
they embrace the 12 factors which I
actually talked about earlier today and
they're they're sort of the avant-garde
of the of JVM web frameworks so while
many other frameworks work they're still
steeped in the past and these are
designed with the cloud and with the web
and mine and of course they're using
modern JVM alternative languages which I
believe are the future of JVM web
development so you're at a crossroads
right which which one of these are going
to choose which one of these are you
going to explore further I think to
answer that question you have to look at
three things who are the people in your
organization what are the processes you
use in your organization
and what technologies do you already use
and what technology problems do you have
so who are the people that the people in
organization what are their skills what
languages do they already know what are
they interesting and learning
what processes do you have what what
does it take to get a change in a line
of code and development into production
does that take a month two weeks do you
do it every day
are you agile are you are you working
with product owners who are very rigid
those those all come into play and then
finally what technology problems do you
have are you doing a lot of i/o do you
need this asynchronous non-blocking
pattern do you have a traditional web
app are you your customers you know
using lots of JavaScript that kind of
thing so here's my challenge to you when
you leave here today just pick one of
these which one do you think is best for
you and then run that command so you saw
me for each of these run a command to
create a new application I say right now
pick one right down this this command
and it may take a couple of steps for
using activator you have to download
activator you may have to install a line
again but run that command and then get
started run the application and and
start digging deeper hopefully hopefully
you will end up using one of them
production but uh thank you for coming
today and I'll be happy to stick around
for questions oh and we have to do the
skateboard let's do the skateboard now I
have a little magical fairy who's
actually a very tall German that's going
to help me now all right I'm so excited
so there's definitely not we had many
hundreds of people sign up and there are
not many hundreds of people here so if
you're still here your chances have
increased significantly congratulations
so it's actually fair all right okay so
we're removing this girl from the list
yeah take a moment because I'm sure the
first hit is not in the room
I can't say that
what's xxx German Michael Shane arts
alright let's try again Nikolas tanguay
so if you win you need to get say we say
loudly Peter strand
Baldomir succour Matthias makovski story
Yenko Sergei told you it's gonna take a
while
and a meet the grocer no last name Kim
London Madsen yeah so come on down now
you have to write it in front of
everyone</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>