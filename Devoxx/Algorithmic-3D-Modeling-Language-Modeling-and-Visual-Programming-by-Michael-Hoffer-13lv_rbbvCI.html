<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Algorithmic 3-D Modeling, Language Modeling and Visual Programming by Michael Hoffer | Coder Coacher - Coaching Coders</title><meta content="Algorithmic 3-D Modeling, Language Modeling and Visual Programming by Michael Hoffer - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Algorithmic 3-D Modeling, Language Modeling and Visual Programming by Michael Hoffer</b></h2><h5 class="post__date">2015-11-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/13lv_rbbvCI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome everybody as you can see i
brought my 3d printer it's actually
working already so you can watch it if
you like and also after the talk you can
come down and watch it more closely so
this talk will be about algorithmic 3d
modeling language modeling and visual
programming using VR else to do so the
idea is that we create our 3d geometries
visually and but still that we have the
option to do it by programming really
because most of us are programmers right
are you all programmers yeah so most of
you perfect so my name is Michelle Hoffa
I work at the goethe university of
frankfurt at the goethe center for
scientific computing and my research
topics are creating visual programming
concepts for complex simulation
workflows then my twitter handle is mia
soft so if you like to stay in touch and
yeah talk about visual programming or
IOT related 3d printing stuff then yeah
please do communicate yeah so how do we
create geometries programmatically there
are some some options out there where
you use a professional cad/cam
application or a 3d graphics software
like blender or maya where you can just
draw the application the geometry in the
application and sometimes they even give
you the option to do some programming in
it but it's not a real programming
language in most cases at least not for
the 3d modeling as we explain it later
there is one good application called
open SCAP that allows you to program
that but it has a limited api in a
limited programming language so i
thought it would be cool to just create
your own application and library so
that's why i wrote the chasee is qi
library and jf x cat which is a chav
effects based application for doing that
and the basic algorithm works like that
you can Union two objects like you see
in this two circles that become unified
object and you can create the difference
like removing a small part from one
circle you can compute the intersection
and also the hull around two objects so
that are the basic building blocks that
let you create complex geometries like
for example this one here I I know it's
hard to see because we don't have a
camera here but later on you can come
down and watch it more closely and the
JCC library itself is also open source
you can download it from github you
don't have to use your old studio for it
it's just a regular Gradle based java
project and it can also export all the
geometries to a job of x note so it's
actually quite easy to simulate what you
what you code and also visualize it so
this is another example also created
with the library it's for a drone arm so
I build my own drone with it and it's
very neat to have it a rama dries
geometry defined in code because all the
inner structures can be changed easily
and you can change the like the the
infill and other parameters like the
holes for engines and so on and also you
can use j CSG envy or else to do that we
will show later in the visual
programming part and yeah it's just a
plug-in and you can use groovy and java
to to access the whole api and of course
you can download examples on the web
page if you're interested here are some
images how you do that there you see the
the algorithm again you can Union
difference and intersect it so yeah and
you can also create quite complex
objects so now I'd like to give just a
brief introduction to 3d printing
because I apply all the visual
programming to 3d printing here at the
conference because it's a visual thing
and it's really nice that you can
actually
touch the result of your programming so
who of you has done 3d printing already
okay quite a few yes and all the others
are just interested in it and like to
buy one or yeah cool so additive
manufacturing is actually a really
exciting technology and I just want to
briefly explain how it differs from
subtractive manufacturing so in
subtractive manufacturing that we do for
quite some time actually you you have a
raw material and then you want to
extract an object from that so like in
this case it's just a cylinder and you
get a lot of ways because you're just
removing material and after that you get
your finished object so this has
advantages and disadvantages of course
but it's just it's also limiting because
you cannot remove something from inside
of the cylinder if you want to keep it
closed it's it's just not possible with
additive manufacturing it actually there
is a lot more possible with it so you in
this case with this printer you just use
a filament and then you heat it up and
you put small layers one layer on top of
another and then you build up the object
you don't have waste and you can even
print holes inside the cylinder if you
like or any other object so like you saw
with the drone arm for example so
because we don't have a camera here here
is a 3d printer in action it just prints
a very basic part for a Raspberry Pi
based robot that's also a very cool
thing to do with 3d printing like
combining it with IOT related stuff and
also use it for teaching actually here
are some nice microscope images where
you really see how the structure looks
likes and that was actually fun it's a
friend of mine who has access to an
electron microscope and when you go too
far like you see in
the lower right image actually the
plastic starts melting again it's really
weird so it looks like volcanoes or
something and still interesting that you
can see the layers also on this very
small level so the printer works really
accurate yeah of course there is thing
worse where you can share 3d geometries
and almost anything has done already so
when I started with the 3d printing
actually I was kind of frustrated
because everything was there already but
then I discovered of course you can do
new stuff and it's a really nice
platform so now let's go into visual
programming because that's what we want
to combine we want to do visual
programming for creating 3d geometries
and first I'd like to give some
historical motivations why I designed
the visual programming environments the
way I do the thing is when we did
application development for the last
decades it started as a really hard and
manual process so people use punch cards
to edit source code and it wasn't
interactive at all so you didn't get a
response from an idea or even a very
simple text editor like VI or something
it just wasn't possible and computers
were not able to run an editor and a
compiler or even the program at the same
time so that's why we have these
distinct phases because people thought
okay we have to first edit the program
then go load the compiler create binary
representation of the program and then
finally we could run it but actually
that's not the only only way to do it so
nowadays we can do a lot more with it
and for historical reasons people threw
away all the useful information that is
inside the compiler so you would just
create an application use the compiler
information all the internal
representation like the ast and and
everything else like the optimizations
and so on you used that for creating
compact and efficient binaries but after
that you just threw that away when the
program runs you don't know anything
about that anymore
of course there are exceptions nowadays
languages have access to ast and we also
use that in a IDEs while developing to
just enhance the experiment experience
and also with programming languages like
Ruby they give you access to the
compiler so you can even do meta
programming in the language itself but
still it's not that much used for the
end user application and that's what I
really would like to do and this is also
part of my research so there are two
approaches you can do a visual
programming at runtime or at compile
time so doing it at runtime is a nice
thing it's basically something like
visual shell maybe so with VR else to do
which is a really nice experimental
innovative ide for prototyping and also
learning you can do visual reflection so
you give it source code and it will
instantly create a user interface for
you and you can define workflows and of
course you have an integrated editor
with syntax highlighting and plugins
system and so on what it actually does
the VR elf framework below view else to
do gives you a framework for automatic
user interface generation so you just
give it source code it creates a UI and
then you can do workflow management so
we have an object inspector that uses
the reflection API to generate user
interface and then it delegates that to
the actual scene graph or j-frame
depending on which UI framework you use
so yeah I'm not going to talk that much
about plugins but we have of course a
plugin system and we didn't know about
project chick saw when we started that
it was a few years ago so actually we
also have strong neck encapsulation
there and you can access the platform on
different levels and we also have native
plugins so you can bind your C++
frameworks as well
so now I'd like to give a short demo
this is a workflow the actually the JC
sg-1 so here you see we have a solar
creator and a sphere creator and that
are just library objects that are
automatically visualized and they can
have data flow dependencies to other
objects and here we create the Union the
difference and intersection and the very
cool thing is you directly get feedback
from that and then we can save that to
an STL file and feed it to the printer
software and just print it and the basic
concepts behind vrl studio are actually
that you get an instance visualization
so you don't have to stop the program
that that is what I mean when I say we
have to combine compile time editing and
run time to get more out of our
applications so when I compile this and
create an instance here is my user
interface I can directly use it there is
no build script or anything involved you
just type your source code and you
directly get get a response and we can
also do that with with more complicated
objects let's do something like this
still very simple but it has an output
so we just add two numbers we get this
representation and the the very cool
thing about it is that we can now do
data flow based programming so like here
we can combine both define a data flow
and we can instantly try our source code
and see whether it works and all these
input fields they have also validation
so if I type something that is not an
integer I run it I get an error message
down below it's as I can't invoke the
method because the data input type
doesn't match so that's the basic
concept of it and all the object states
so this is an object that really is on
the heap you can serialize it and
whenever you save a project it will be
civilized and all the object side is
either
saved as XML or base64 binary
representation depending on the object
type so now let's look at some more
complicated examples and I look what we
have in the slides yeah that's correct
so here we have another example where we
actually did everything by coding so I
can just use the chase CSG library as
any Java library and use it in this
groovy code editor and as it returns a
CSG object here it gives us this nice
visualization so then we have a double
which is like the radius and then we
have the number of arms so I could
change that to five maybe so like this
because otherwise it looks like a moose
eaters star and yeah you can annotate
everything and then you yeah basically
enhance the the information from the
reflection API so in all you saw here is
open source it's a project you can
contribute to or you can just use it for
teaching Java or doing experiments
yourself and it's not limited to two 3d
printing it's just a neat application so
here is the web page we are else to do
museu you can download pre compiled
binaries and you can also check out all
the examples like you can even do sound
generation and opencl programming and a
lot more so that was run time based
programming do we have any questions
about that because actually that the
talk is split in two parts so I would
just prefer that we use the time between
the talks as a QA for the first part if
you want or should we yeah go ahead
okay go ahead so now we come to visual
programming with a compile-time so we
are not doing it at runtime but at a
compile-time of the program and edit I'm
actually and therefore we need language
models so the idea here was to capture
not only the interface of objects but
rather than that the whole program
actually because that is something that
most visual programming environments
struggle with they give you a nice
interface you can edit many things but
then they save it as XML file or
whatever and it diverts from the actual
source code you won't find a really good
visual programming language for Java for
example there are editors that that you
do some modeling but it's not like
editing compiling and running the
program so therefore I introduced a
language model that takes the ast from
the groovy compiler and it's actually
observable and ya can do communications
with the user interface and also you can
declare and modify the model actually
you can declare new classes and methods
and invocations to change the model and
it can render back to source code and
also you have the program's as data
structure so you can actually add your
own optimizations or transformations
also in this model except that it's also
visual and that is something that you
see here so here you see just some
groovy code and on the right hand side
is really the representation of the
complete program even with all the
intermediate values because everything
you see here will be instrumented here's
a closer look and now it's time also for
demo of that
at the moment this is still a prototype
but you can also download it from github
it's in an experimental branch and then
you can just run it it's also a greater
project so I do it with netbeans but you
can also do it with other IDEs what you
see here it's just a very small program
it executes a for loops a few loops
actually three and here you see the
complete program on the right hand side
so if I select things in the editor they
will be also selected in the UI so they
are really tightly coupled and if I run
that you will get instantly the
profiling feedback and also code
coverage because every window that
really gets highlighted will be executed
and now to something even better like
this one here in this example we really
use the JCC library again so first we
create a sphere then we create a cube
and then we do the difference operation
between the cube and the sphere so let
me just highlight that so you see it
here it selects all the windows that
represent this executions and then in
the main method we just execute the
create difference once and test just to
show you that the link between the UI
and the source code is really deep so
what we see here is a just a print line
that you can see here and I can change
it to hello java and groovy and also the
source code will change it's cool right
so you can really do visual programming
and it translates back to the source
code so now if i delete this it will
also delete the source code and
I can add it again if I save it here it
is again and now for the instrumentation
part what it does it takes the whole
language model and introduces event
generators before we execute things like
methods or operators and after that and
when we do that we can run the program
again and we see all the intermediate
results so that's what we see here so
here is the creative method it's red
because it it takes all the CPU time
everything we execute is actually
executed in this method so naturally it
takes most time and everything is
visualized with job of X and Shop of X
3d we can even zoom in that's the result
we get and when you see that here this
could actually be used as a even end
user interface you could just combine
those and give it a front panel and then
ship it as application and users could
either work with the UI or go back to
the source code and change it so it
wouldn't really matter and when we want
to know what the create difference
method does you just go here like that
here we create the cube then this fear
and then the difference so when we do I
would make a 3d modeling this is really
important because otherwise the debugger
for example in a regular ID would never
tell us that actually the this field was
too big or too small or something so we
really need the visual feedback and also
humans are actually visual we always
work visual and when we do programming
of course we trained to think in
different ways and we kind of guess the
actual control and data flow and I des
tend to help us by by visualizing
different
references of the same variable and so
on but still we are visual and it takes
a lot of time to really get to the text
based representation but of course there
are also situations where text based
programming has its advantages and that
is why I think we should combine that so
it doesn't really make a difference so
we should create user interfaces in a
way that they are really the source code
and we use the language the programming
language actually is as our dsl in a way
to define the user interface because
everything I did was writing some groovy
code and I got this user interface so
this is a DSL for describing a user
interface that can do 3d modeling in
this case so and you could do a lot of
other things like image filtering or all
sorts of applications actually so this
is a research project that I do just to
explore this these possibilities and
yeah as you can see it's highly
interactive already so we could also
introduce like a second creative here
something like that and of course it has
to recompile and now we get a second
creative window and if we run it it
looks like that because I didn't change
the numbers very much but you can see if
you look closely this here wouldn't be
printable because it's not connected
anymore and no debugger would ever tell
us but we can see it instantly so we can
just change the number back to maybe
eight or something so we get a connected
object again
so here you see the difference okay so
that was the demo I already mentioned
that everything I did was actually also
profiled on a language level maybe it's
a good idea to just show you the
instrumented version of the program
shortly briefly it's it's here so it it
is actually a mess but it still executes
what we want it so it introduces a lot
of intermediate variables and takes
apart all operators and everything and
the very cool thing about this doing it
on a source code or model level even is
that we can just apply to places we want
so we don't run the JVM in profiling
mode or debugging mode or whatever we
can even just change the level of
profiling and when we add different
language supports we can even render
that language model to a different
language and all the instrumentations
would still be there in a different
language and we could even apply to like
html5 rendering or something like that
so but at the moment we use job of X and
the really cool thing about it is that
it's quite easy to implement these
scaling capabilities so what you see
here is that some of the user interfaces
just vanish when the objects get too
small so if I make this smaller and
resize this year the content is gone so
you can really visualize vast amount of
data so that is also important when you
visualize real programs and large code
bases and what I'm thinking about is
even extending that so that you can
actually zoom out and not just visualize
one file by the whole project or even
relations between different projects so
that you can really scale from something
like a group of github repositories to
down to individual source code lines and
yeah that's kind of the idea and we are
also working on integrating that into
different editors and so on but this is
the
an experiment I would still be glad if
you if you want to contribute or have
yeah ideas how to improve that even
further because it's still an experiment
it goes way beyond the paradigms we
usually use when we do visual
programming like in LabVIEW or other
languages so yeah that was basically the
introduction to this environment and
here you find some resources so we also
you can be downloaded here is also my
twitter handle and get up name so yeah
there you will also find all the the
repositories and experimental programs
and now i like to open Q&amp;amp;A so you can
even even you can come down and have a
look at the 3d printed stuff also at the
robot that we built with that
environment and the printer and we can
just have an interactive a Q&amp;amp;A session
you can also ask via twitter yeah just
as you like because this was also about
3d printing and many people said it was
interesting to watch the printer and
sometimes it was crowded at the booth so
we thought we bring it here and you can
just have a look at it and either yeah
ask questions or just watch it it's
really fun it's unfortunate that we
don't have a camera so if you're
interested please come down have a look
and also i will show you the robot parts
that we did yeah thanks
yeah so in the viral studio thing it was
a swing an enhanced version of swing and
then with the zoomable experimental
thing it was job of X because it has a
very nice scene graph API and we use
javafx 3d for the 3d models and the JCC
library can just export any intermediate
object into a java x 3d nodes so you can
directly visualize it and that's what we
do with the instrumented source code
where it just it puts in the 3d notes
there and we just add some mouse
listener so that you can rotate and yeah
so you can also just use the the JCC
library and add it to some Java X
application actually we also have an
example for that just let me show it to
you online it's on github and here you
will see the pie on wheels project and
here you see you can do the coding here
and also you see the 3d visualization
which is just the travel of X 3d note
does it answer the question yeah
actually Gaki on from the from that
means he already started an experimental
plugin for the NetBeans platform so that
is actually also the goal also with the
new approach it would be preferable
because then you had a really powerful
text-based editor and you still have the
visualization for free you could just do
it with any NetBeans or project or also
for other ID so I am I want to start
with with Gradle actually so that you
use the Gradle tooling API to do that
but we're also looking into integrating
that into NetBeans that's a good good
idea yeah
yeah you can come down as I said it's
don't be shy it's rather difficult to to
see you so maybe I missed somebody and
if that's the case go to the microphones
upstairs or just calm down the
difference is that this runs on Java and
as I do the visual programming with so
the question was what's the difference
between openscad and JC istry so the
difference is that this one runs on on
Java we can use reflection to do all the
visualizations automatically in openscad
only gives you one result it's a very
good library and much enhanced but it
doesn't give you all the intermediate
results you only see one object you
cannot visually program you know so
that's just a limitation because they
have a limited language and also you
cannot do any kind of program what I can
do here is we also have simulation
frameworks and they give you an output
from simulation and a contrast feed it
to the chase you see library and the
other way around and I can do it in with
reflection so i don't have to create all
the user interfaces everything is
completely automatic and you know you
don't have a specific user interface for
open skate but what you could do is also
you could actually come add a Java layer
to open scan then you could do basically
the same but for my experiments it was
better to write my own lightweight
library because it doesn't depend on c++
and QT and whatever its and also I had
some licensing issues with autumn Scott
because it's pure GPL and I tend to
release stuff under PSD or Apache stuff
so it's yeah but I really like the
program so yeah
yeah offended on funded also a great
application for teaching purposes</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>