<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Testing made sweet with a Mockito by Jeroen Mols | Coder Coacher - Coaching Coders</title><meta content="Testing made sweet with a Mockito by Jeroen Mols - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Testing made sweet with a Mockito by Jeroen Mols</b></h2><h5 class="post__date">2016-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/DJDBl0vURD4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello good morning everyone and welcome
to my talk on testing made sweet with a
mojito let's start with a small little
world about myself I'm a hero moles and
Belgian and I work for a small company
called Philips
on the connected you lighting system I'm
also quite active on Twitter so feel
free to hit me up with any questions
should you have any after the talk or to
follow me obviously so this is a talk
about testing so then the first question
we should ask is why should you write
tests maybe a small question for the
audience who here writes unit tests for
the coat alright that looks really good
well it's important to write this
because yeah if you don't like des in
your coat why would anyone like testing
your product right should you not be
writing tests then the best way to get
started is to stop fixing bugs put in
stats first write a unit test that
produces a bug and then just go and fix
that unit test because if you do so
you're not only sure that you fix a bug
but you're also sure that that bug never
reappeared again now today we actually
want to do something fairly simple
imagine the very basic application we
have some UI which has a button and if
you press the button the UI will do a
login request and that will then
actually create a user object called a
login method on the user object the user
in its turn will talk to a web service
the web service will do the login
request somewhere in the future that web
service will yeah
respond with success or failure notify
the user of that and as a result the
user should update UI this hopefully
looks fairly familiar to all of you now
what you want to accomplish today is
some way or the other we want to
completely isolate the user object and
fully test that okay simple enough so
let's try and do that but before we
actually can do that
need to have our tools we need to have
our tool set an order first things first
- writing unit tests so what makes a
unit test good first unit does need to
be fast and I'm not talking about your
unit that should run in a second no I'm
talking insanely fast ludicrously fast
even you should be able to run hundreds
if not thousands of tests in under a
second and why is that so important
because the faster your unit tests are
the more likely you're going to be
running them and the more you run your
unit tests the more valuable you will
get from them so having fast tests is
really really important secondly your
test should be small and focused by
small I mean physically small they
should only be a couple of lines of code
right that's no different from your
normal code you should be able to look
at a test and immediately understand
what's going on but they should also be
focused by focused I mean that every
single unit test should only test one
specific part of your goat or if you
turn it around should you have a bug in
your goat then only exactly one unit
test should fail so you don't want to do
multiple assertions in one unit test and
then the last requirement is your test
should be reliable as a non flaky this
is also really important and why is that
because if your tests fill that should
be your top number one priority you're
going to fix at that point and dime you
should drop everything go about and fix
that unit test but now imagine that the
tests just filled randomly so what
you're going to do is you're going to
drop everything you're going to go and
analyze the why it went wrong you're
going to look for a bug but you can't
find a bug and then in the end you're
just going to decide like okay let's
rerun things and magically everything
works again now that might not seem like
such a big deal but over time you're
just gonna stop caring about those
failing tests you're not going to have
the urge anymore to really go about and
fix everything when a test fails so they
should be reliable if something's wrong
then you can go and fix it
and that should be something which
happens only rarely obviously now if we
map that onto our project the main yeah
difficulties in testing this is the UI
because testing UI is for instance on
Android device you need to instantiate
the UIs
well that's going to take time so
they're going to be slow so we don't
want to test your eye and the same with
the web service yeah web service is
always going to be slow and also yeah
doing yeah talking to the Internet is
inherently unreliable so also there we
don't want to test the web service cool
so how can we actually do that well
we're going to isolate the user objects
first look at our architecture so we
have a clean architecture or user
depends on the know our UI depends on
the user the user depends on the web
service but there are no dependencies
the other way around so the user is not
dependent on UI nor is the web service
dependent on the user because of that we
don't have to include UI in our test we
can just immediately start invoking
methods on the user so Kay that's solved
second problem the web service
well that's slightly trickier because
obviously we want to have reliable tests
so we don't want to do the network
requests in our unit test so what we
need to do there is we need to replace
web service by something that looks the
same but behaves differently and then
instead of actually verifying results to
state verification we're going to verify
the interactions to behavior
verification okay so this brings us to a
definition called testable a testable is
exactly the same as a double ganger it's
somebody who looks a lot like you but
just isn't here so we replace the green
web service by an orange web service
which looks exactly the same but has a
different behavior and that actual
behavior of that dummy or of that
testable can differ so instead of doing
the normal implementation it could
simply do nothing or it could always
pretend like the network request was
successful or it
throw an exception and do something
completely different well in reality you
actually have more than two deaths
doubles so you have quite a lot of death
doubles but the two main ones are mocks
and stubs I'm not going to cover those
other ones because I just find them to
add more confusion and then they
actually should so what is amok amok is
typically an automatically generated
class you ask some kind of framework a
framework create a mock for me and that
framework will then create a new class
which looks exactly the same like the
other class but just doesn't do anything
so every void method won't do anything
every method with a return value will
return the default value for that type
so method that returns a boolean will
return false that return the string no
an integer 0 and so on but the one thing
a mock does do is it has counters
internally so it can remember which
methods we actually call on it so later
on you can actually verify that a
certain method was called on that mark
let's behavior verification now on the
other hand we have a stop a stub is
typically something you write yourself a
handwritten class and what you're going
to do is you're going to heart goat
program some behavior so you're
basically going to return yeah
predefined responses given a certain
input and that then because a stub
actually returns values also allows you
to do state verification so we have two
main things MUX and stops and that's
also something we're going to use a lot
today now we have a tool certain order
but it's time to look at our framework
and our framework is called mojito
who here knows mojito all right great
well then this won't be any surprise for
you I guess it's an open source
framework that allows you to write
beautiful tests with a clean and simple
API it's yeah on get up to source code
and the documentation and it has a very
friendly MIT license now why would you
drink it there's two main reasons one is
it's ease-of-use so it's it almost has
no learning curve it has a very clean
simple syntax and it also offers
annotation support to make your tests
even more readable on the other end it's
a very mature framework mature mojito is
and has already been for yeah a couple
of years now in the top 10 of most
popular Java libraries so there's a huge
community on Stack Overflow and should
you have any question you can always go
there and find the answer to it so how
do you drink it well mojito is deploying
to J Center or maven central I don't
really know but anyways J Center the
supersets maven central so if you
include chase Center in your builder
Gradle file you could just pull it in by
specifying and test compile dependency
as of today the latest version of
mojitos to 2.11 which means mojito has
reached its to dot x stable stage and I
will talk a bit more about that later in
this presentation
ok so that's that let's now look at the
ingredients of mojito well there's
multiple things you can do with mojito
and what we're going to do is we're
going to just start at the basics and
then we're gonna build them
incrementally to more advanced use cases
so first things first what do you want
to do with the mocking framework it's
creating marks I told you Makita was
easy to use and you can see I didn't
apply because creating a mock is only a
few lines of code basically what you do
is you just ask mojito
hey mojito create me a mock of this
class for instance here it creates a
mock of the web service class and the
mock web service is something which has
exactly the same interface of the web
service but if you call a method on it
it won't do anything if you call a
method that returns a value it will
return the default value for that type
now there's actually a second way of
creating a mock I know first a small
site note so mojito relies on static
imports so the mock method of before is
statically important now there's a
second way of a yeah creating mocks and
that is by using annotations
what you basically do is you just create
a public field no up a field can be
public or private doesn't matter you
annotate it with at mark and then
mockito will initialize the mock for you
there's one thing else that you need to
do because if you have used any
annotation processing framework before
then you know that dosia annotations
don't initialize themselves so you have
a couple of options either you just ask
mojito or dot and you tell it to like
mojito annotations dot initialize and
then it will initialize all of those
annotations for you or you can use a
test rule and I actually recommend using
the test rule because that's yeah
cleaner to use and also what the test
rule rule will do is it won't only
initialize all of the annotations but
it's also going to verify that you're
correctly using mojito so we'll see
later on mojito yeah makes use a lot of
fluent syntaxes so that means that you
could forget to append the last part of
the syntax and mojito is smart enough to
be able to detect that and that's also
something this tester will do for you to
add a test rule that's really simple you
just create a public field now it does
have to be public you annotate it with
at rule and you initialize a Makita rule
in it so you say Maki teach a unit dot
rule okay so let's verify some
interactions have a look at this very
very simple test it has a very basic
clean structure Triple A structure so
first we do some arrangement very yeah
create a new user then we do an action
we call logout on the user and then we
do an assertion to actually verify that
a logout method was called now this is
where we actually do the verification so
to verify the certain method is called
on a mark all you have to do is ask
mojito a mojito verify it on this mark
this method is called it's nothing more
than that you actually have a couple of
options if you want you could specify
the amount of times that you want that
method to be called you could say like I
want this method to be called
once or at least so many times or I want
to sweat method to be the only method to
be called or I want this method never to
be called and so on so you have quite a
bit of power to specify how many times
you want this method to be called by
default maketo will actually use the
times one so in the previous example if
you don't specify anything it's just
going to take x one now be a bit careful
with this because if you're going to be
yeah overly restrictive you're gonna
make your tests brittle imagine this use
case we're testing the login methods
well you could say like when somebody
logs in you don't want them to log out
immediately after because that will make
any sense right so with in your login
test you could next to doing the verify
that the login method is called you
could also explicitly verify that a
logout method has never got well that's
actually a really poor idea and why is
that because in reality you're not gonna
have one login test you may have 10 or
20 login tests login with user ID no
login with invalid user ID login with
correct user ID login with password null
and so on and so on so you're gonna have
a test for all of those cases and should
you also explicitly add the case never
call log out to all of those tests well
what's going to happen then is if you
later do decide to allow this
for instance you're adding a wearable
support to your app like Android wear
where it may make sense to immediately
log out after login to conserve battery
well if you want to make that change
then you would have to go about and
change all of the tests you wrote for
the login so you really don't want to do
that don't be overly restrictive if
that's a use case you find important
just write a single test for it
login no logout should never be called
immediately after login put the code in
one test and then if you later change
yeah your use case you just have to go
and fix one test all right now what if
the method takes parameters for instance
the login method takes parameters you
can just add those
meters you can't just do that you can
also be a bit more vague about how you
want the parameters to look like so you
can say like hey mojito I want this
method to be called but the parameter
can be I don't really care it can be any
integer any string or any object of this
class this is what mojito calls a
matcher and why is it important to know
what the matter is because if you use a
matcher for one argument you need to use
a matcher for all of the arguments so
here if you use the login method if you
say like mojito verify that log and
method is called and the user ID can be
any integer then you need to wrap the
exact password with an equals matcher it
sounds a bit artificial and that is
because it is artificial but don't worry
too much about it because if you don't
do this mojito will throw a friendly
warning reminding you that you should do
this now there's even more advanced
measures like greater than less than
less than equal or string matches that
you can say like all strings should
start with this value or yeah Accord to
this reg X and even crazier stuff like
it can be any object of this class but
it should not be no or it needs to be
between those two values out-of-the-box
mockito has two classes where it defines
all kinds of matches you can use mojito
matters a mojito dot additional matters
so you should find a match for every one
of your use case and if there's not you
can also extend the matcher interface
yourself implemented and then you can
write your own measures we will actually
do that later in this presentation the
last thing you could do with verifying
interactions is verify the order in what
methods are called so here we go first
login and then we call logout well then
we actually want to verify that the user
also calls these methods in that order
on the web service so we just ask mojito
in order for this mark verify that first
this method is called and then that
method is called this works for
different methods called on the same
mark or for different methods called on
different modes
all right stopping methods well remember
when I said if you create a mark then
every method that returns a value will
return its default value so if you look
at the mock web service salt is offline
method if you don't do anything that
method will return false because that's
the default type for a boolean should we
want to change that for our test so
should we want to stop the behavior of
that method we can we just ask mojito
hey mojito then on this mock this method
is called then return that value so when
on the mock web service is a flying
method is called then return true and
when that returns true we can then
verify that yeah the user never calls
the login method on the web service so
this is quite powerful actually you can
just stop one invocation of the method
but you can also stop multiple
invocations so you could say like the
first time this method this call to turn
true second time false and then all of
the subsequent times through again or
you could even say like hey throw an
exception so have completely different
behavior or you can even go wilder and
specify a complete answer to be returned
when the method is called well I'm not
going to cover this in depth because I
don't really recommend you using this
this is really nice because in your
answer you can also look at like yeah
the parameter that were passed along to
the method and then yeah according to
the state you're currently in and the
input parameters then you can decide to
return a particular value now I'm not
covering this in depth because what this
basically means is if you think about it
your hard coding knowledge of the rest
of your architecture into that one test
so I don't really want you to do that
because if you do that and you change
the architecture later on then the tests
is going to break because of that so you
know that this exists you can look it up
on the internet and see and use it if
you need it for use case I personally
also admit I sometimes use it especially
if I'm testing against
third party library of which I have no
control of the interface and if the
interface is inconvenient for testing
then sometimes you need to jump to a
couple of hoops to make it work but this
should not be your default go-to
stuffing methods okay so stopping
methods has multiple syntaxes and the
default is a mojito when on this mock
this method is called then we learn this
value but you also have an alternative
syntax hey mojito do return this value
when on this mock this method is called
and then you might ask what's the
difference well this syntax is actually
slightly inferior because first you have
return type and then you have the met
identification so this syntax is not
typesafe mojito cannot in verb infer the
return type of the method when you're
using this syntax why would you use this
int exam well if you're working with
spice or if you want to hear overwrite a
previous stopped method then you can use
this syntax so again this should be
something that you rarely use mojito
does have another interesting syntax and
that is the BDD syntax it's exactly the
same as a when syntax but it's just to
rename to make it a bit more BDD like so
here you say like given that on this
mark this method this method will return
that value then on this mark this method
it should be called exactly so many
times so if you're into VDD then this
might be an interesting thing to look at
okay capturing arguments this is with
more difficult to explain so bear with
me let's go back to our problem
statement so what we basically do is we
call login on the user the user is going
to talk to the web service but yeah a
web service cannot respond immediately
so it's going to return an asynchronous
result it's going to return a success or
failure fire response object to the user
and then the user is going to update UI
as a result what if we want to test this
exactly so we want to test that given a
bonds of the web service that the user
updates the UI properly okay
let's zoom a bit deeper and see how the
login method on the user looks well
inside of the user so inside of the
login method this is a method online
user class the user will create a new
response which is yeah an object it
passes along to the web service and the
web server is going to use that response
to provide the feedback about the
success or failure now if you see how to
response glass looks in the unrest
completed methods we have a very simple
logic with just if it's successful then
calls the on login success or otherwise
call the on logging field now it's
exactly this logic that we want to test
so given that the request is completed
successfully or failed the user should
call the write method on the login
interface now how can we test this first
we're going to invoke login on the user
so the user does the login call on the
web service
well when the user does that because
some way or the other we need to get a
hold of the response object that user
creates internally right so when the
user calls a login command then we're
just gonna intercept the object it's
created internally and passed along to
the web service and once we have that we
can simulate success or failure and then
do the verification that the user
updates UI accordingly well this is how
it looks like I'll talk you through it
step by step
it's not as difficult as you might think
when you see this so step 0 is to
initialize a new object called an
argument captor this is also one of the
native types of mojito and what you
basically do is you annotate a member
with add captor and then you specify
what type it's going to capture so this
is a response capture so it's an
argument capture which can capture an
argument pass to a method of the type
response once we have that we're going
to do step 1 so just invoke the write
method on the user object so the user
now is going to internal
create response objects and call login
on the web service and then we're going
to verify that the user actually called
that login method on the web service and
now you might think whoa whoa you said
before like 50 minutes ago that you
should never do more than one assertion
in a unit test and now you're doing it
yourself well yeah that's true but this
is just a way how it works in this case
we're not doing the verification for the
sake of actually checking that the user
calls the login method on the web
service no we're doing this verification
just to get a hold of the parameters
passed to the web service so to do
response capture dot get value then we
actually capture the response objects
passed by the user to the web service so
once we have two response we can invoke
its method on it so now we pretend like
a network request is successful and then
we can just check that the user of the
hcy accordingly all right so this is an
extremely powerful mechanism especially
to test asynchronous logic I use it
quite often for that but please don't
overuse this because many of the use
cases where you might use this for you
could also solve it with for instance a
matcher so then yeah it's not because
you have this power in your control that
you actually need to use it
okay so maketo do comes with a few
limitations
it cannot mock final classes and methods
but fortunately moki toe-to-toe does
bring that power it's still an
incubating feature so it's not turned on
by default yet so you need to opt in but
I'll show you later how you can actually
opt into that so basically the only
limitation that still remains is mocking
static methods that's something mockito
cannot do then the other things it
cannot do with private methods but yeah
why would you want to test a private
method and also hashcode and equals I
don't really see a use case for that
either
so let's do some advanced work Ito now
the raspberry mojito again up
matera of topics you want to cover I
think the most notable ones are going to
be testing the UI how you can go about
testing final and statics and then also
maybe a custom matcher so testing you I
remember what I told you before you
don't really want to test UI or at least
we didn't want to do it in this example
and the reason I gave you for that is
because you're why tests are slow and
that's always going to be the case
because initializing UI always is going
to make take more time than initializing
just normal code especially if you use
Android because then you have to run
your tests on a physical device or an
emulator so you have like the deployment
step the install step and so on now so
given that we don't really want to test
UI how can we then still make sure that
our app is properly tested without
really having to inflate the UI
well the way I do that is I separate all
of my view and view logic from each
other so not make one class with you and
view logic so you can completely test
view logic and you don't have to worry
about the view a really nice paradigm
that I find for this is MVP Model View
presenter it works very very simple you
just have a view interface you create a
few interface and there you specify like
these are the methods that the presenter
can call on the view then you have an
implementation of that interface which
is typically your activity or fragment
on Android and the first thing that
implementation is going to do when it's
created is create a presenter and it's
going to pass itself as if you interface
to the presenter and also pass the model
to the presenter so then whenever your
UI gets initialized the first thing
that's going to happen is you're going
to create a presenter and it's going to
get all of its dependencies inject it to
it which is great for testing right and
then so that's the first reason it works
dependency injection the second reason
why it works is again because this is a
clean architecture all of dependencies
only point in one direction so the few
implementation depends on the presenter
but the presenter does not depend on if
you
plantation directly now should you adopt
this what you basically do is you DOMA
Phi your UI and just reduce it to a yeah
merely a pass-through layer for instance
the view interface would define a method
set progress and then implementation in
the view class so in the view
implementation would be progress bar dot
set progress with the same parameter so
I personally don't test that logic
anymore because what you would basically
be testing is just if the android
framework or whatever UI framework
you're using if that works so I accept
that I don't really test that what I
would do instead is just write a couple
of integration tests for the common
flows in your app I think there's more
value in doing that then actually yeah
writing test for that dummy UI that we
have here a second remark I want to make
here is please please don't be dogmatic
about this and the Android community
there's a lot of talk like yeah you need
to do model-view-presenter you need to
do it like that no no no it's really it
doesn't matter what you do as long as
you're consistent about it
for instance here this is MVP but it's
not textbook MVP ideally I should have
also made an interface for my presenter
and interface for my model but I
typically only have one presenter or one
model so why would I bother doing that
but it's my opinion if you have a
different opinion
by all means create your interfaces the
only thing you should take care of is
that you and the rest of your team are
doing the same thing so be pragmatic
choose as a team what do you want to
test how do you want to test it and then
try to be consistent about that okay
what if you want to run mojito on an
Android device that's possible so if you
take a step back and see what we've done
so far is we were always running mojito
and a JVM now we're going to run it on
the Android device first thing you need
to do is configure the Android testing
support library so you have j-unit for
support and then you just add a
dependency on mojito and that's it now
maybe you've noticed that these are a
couple of more dependency
than we had we were using mojito on a
JVM and the reason for that is that the
way Makita works is it's going to
generate classes at runtime for you so
if you're running your test and you ask
Makita to create a mark on the fly it's
going to create an instance of that mark
so it needs to be able to create a class
and the way you create classes is
different than a JVM then it is on an
Android device and because Android has
their own virtual machine so mojito
cannot do that out-of-the-box how mojito
solves that is by using a tool called
text maker and that's basically that
offers the ability to mojito to also
generate classes on Android device it's
a great tool it's stable you can use it
the only disadvantage of it is that it's
not really actively maintained so I
think the last commit was about a year
ago and that means that it's not yet
compatible with mojito - at all so that
means we're stuck with mojito 1x on
Android it's not a major deal because
all of the things that we already
discussed up to this point those are
also possible in mojito one dot X so
mockito 2 dot X didn't bring many
interface changes basically yeah the
good thing about this by the way for the
Android developers in the room is that
because mojito is only a runtime thing
it doesn't have a compile time step and
if we then very soon move over to the
new check engine compiler well mojito
isn't going to be bothered by that so
Makita will still continue to work on
the new checking shell compiler all
right so let's write a custom matcher
maketo OtterBox provides a lot of
different matters I remember a matcher
that was a thing that you could use to
verify that a certain method is called
within certain parameters there we were
during using matchers to be a bit more
vague about what the parameter could be
mojito offers a lot of matches
out-of-the-box but for instance a make
sure that it doesn't provide is to check
if a list contains a certain value so
let's write out ourselves
so this is the list contains mature the
way you create your own matter
you first implement the argument matcher
interface and the argument matcher you
can see and the generic type ID finders
list so there you need to specify like
okay this is going to be a matcher for a
method that takes a list as an input
parameter okay
then also mind generic that we added to
list contains so that our matcher isn't
tied to a particular object now the
first thing we're going to do is add a
new constructor and inject the object
that we want to test for in the lists we
need to keep track some way of the other
four of that object so that when mockito
actually does the verification we have
the object to test or so we keep track
of the object in the constructor and
then this is where all of the magic
happens when mojito evaluates the
matcher it's going to call the matches
method and then it's going to pass you
the parameter of done methods and so
you're going to get the list and then
you can simply check that the list
contains the object which is quite
straightforward then a final thing you
need to do is add the two string methods
this will count will be called is if the
matter evaluates to false so should your
test fill mockito is going to call the
two string method in order to print a
proper error message so here you just
have to return yeah an error message for
instance list doesn't contain object now
in order to use this matcher that's
slightly counterintuitive or yeah let's
say not really intuitive so what I
recommend you to do is to create a new
glass we're going to define all of your
matches so here I create a new class
list matchers and then you add a static
methods for every matter that you have
so for instance you regulate a static
method which will return our list
contains matcher and then that static
method will wrap around yeah the NAM not
really intuitive syntax for you so this
will return a new arc that new list
contains for that object so this is like
the non-intuitive part you can also use
this directly but by creating a static
method around it you can just have code
where you
like okay list contains so let's have a
look how this would affect our tests
this is like a traditional test you
would write where we're going to test
that like yeah a list in an argument
contains a certain value so the way that
would work is if we send a message to
the user the user is going to send yeah
a list of messages to the web service so
here you would then verify that the sent
messages is called on the web service so
we can capture the argument using yeah
the technique we did before then you
have access to the list and then you can
get the value from the list and assert
that yeah the expected value equals the
actual value so this is the cube or some
way of actually checking that yeah an
object is in the list parameter if we
now use our custom matcher you can see
everything becomes really clean all you
have to do is say like a mojito verify
that on this mock this method is called
and that the list contains this object
this makes your this a hell of a lot
more cleaner right I also have a blog
post about that so if you want to learn
more you can check that blog post and
I'm also building my own library which
adds collection matches to mojito so you
can also check that out on get up an amp
yeah I'm basically building a hell of a
lot more matches similar to list
contains to basically deal with
collections in mojito okay so testing
final and Static well let's have a look
at the end row at another Android
related class who here is actually an
Android developer okay not that many but
thanks for coming anyway and so this is
basically it's a typical Android class
it's a Android auto vessel handler what
this allows you to do is it's typically
used to yeah move work from one thread
to the other because this basically adds
a message queue to a given thread now
you don't really have to worry about
those details the the main point I want
to make is this is a framework class on
land right so it could also be a library
class and it's methods
our final so this means mockito cannot
mock dogs final methods so how do we
work around this well on Android the
best thing you can do is run these tests
novel on Android device but on the JVM
and why is that because the Android
tools will then instead of using the
actual Android jar they're going to use
a modified version of the Android char
which is all of these modifiers stripped
away so if you run this on like yeah and
in a JVM on Android then the finals
won't be there while running your tests
and then you can simply mock it now if
you cannot do that you still have two
options first option is to create a
wrapper class so basically we create a
handler wrapper and in its constructor
the first thing you're going to do is
you're going to initialize the method
you want to wrap so you initialize a new
handler there you keep track to it and
then you implement exactly the same
methods but you just remove the final
modifiers so this one also has a post
and a sent message method but there's no
final modifier there so this would be an
approach I had to be able to still work
around that issue now as of mockito to
dodo eggs 2.1 actually we now have a way
of having mojito mock the finals for us
this is still incubating like I said
before so it's an opt-in process it's
quite cube resume but it does work so
you need to create a file with a very
specific file name in a very specific
part with very specific contents but if
you manage to get this right then mojito
will mark final notice for you I also
have an example on github where you can
check that out it's currently an
incubating feature so mojito the mojito
team is talking about also providing a
programmatic way of enabling that and
who knows maybe even mocking finals can
become the yeah the default behavior for
Mac equal in the future so how do you
test static methods this is still
something that mojito cannot do and
basically here you would use the exact
same technique as we did with the
handler class so you're basically going
to wrapper
around the native class define similar
methods without aesthetic value and then
always call true now I just leave this
as an exercise do you guys this is a
part of my open source library landscape
video camera I have many other yeah
interesting techniques to make things
testable and you write tests against a
native Android camera which has yeah a
lot of static methods okay now often in
your unit tests yeah you're gonna need
some kind of pojo which is initialized
with valid data you just needed to feed
through the rest of your app so you can
actually test something so how can you
provide testing data well simple right
we have a mocking framework which can
create a mark of that POJO and then we
just double a every method well that's
actually a poor idea because if you do
this besides being incredibly verbose
this is also fragile imagine if I would
now remove the get first-name method
from the user class then everywhere you
did this in your test all of those tests
are going to break and you're going to
need to fix them one by one
so you don't really want that a better
way is just creating yeah a new class a
test user data class and then just
override all of the methods in that
class and have them return a value
appropriate for your testing this is
going to make your tests a lot cleaner
and this also yeah because it's just a
Java class if you start refactoring an
IntelliJ it will be smart enough also to
remove the methods here alright new
creation so what makes things hard to
test is basically when you create
something new internally in an object so
have a look here you have the
constructor of user class what if the
user would create the web servers
internally well that would be a problem
right because how can we then mock away
the web service for our unit testing so
this actually makes the goat almost
impossible to test so in general you
should avoid creating new objects
internally in another
object if they have the same lifespan as
that object because the webservice
is going to be there as long as the user
is there right so that's not really a
good candidate to create internally so
avoid this for long lift objects a
better solution would be to instead of
yeah creating it internally just to
inject it as a dependency dependency
injection at least on Android is been or
has been a bit of a loaded term where
there's many people saying yeah you need
to use an expensive framework like
dagger or dagger 2 to do dependency
injection well that's actually not true
you can use the framework there's
nothing wrong with those frameworks but
dependency injection is nothing more
than just injecting a dependency in a
constructor so you can already do a very
simple thing yourself and optionally you
could check that the dependency is
actually injected I never do that
actually but should you be building a
library then it might make sense to do
that a second interesting pattern is
what if the user doesn't need one web
service but it needs multiple of them so
imagine that you want to create a new
web service for every method call you do
on the user well in that case it's
better not to yeah you cannot inject one
single web service so what you can do is
we can inject the web service factory
and then every time that the user create
needs a new web service it can just call
factory that create web service and this
method we can then mock away in our
tests or stop it so it always returns a
mock web service ok then finally some
power tips if you're not writing tests
you're writing instant legacy gold maybe
it's different or probably it's
different in the Java world but at least
on Android you can see that apps used to
be fairly simple they're getting more
and more complex everyday and more
complex a project becomes the more
expensive it was to create it so the
less likely you're going to be to throw
it away
so you won't start over as often anymore
so that means that you're gonna need
those tests and blame
because otherwise over time you're just
going to be fixing box of all of the
features you already have and you won't
have any capacity anymore to add new
features especially in a system like
Philips you we need to deliver something
new to our customers every month so
testing automation is really really
important for us now power tips don't
use Singleton's singleton store global
state in your application and that can
gaff stuff like that the success of one
test depends on whether or not which
tests that run before it so then you can
gather yeah
connections between tests avoid Android
instrumentation tests or that those are
tests that you run on an Android device
they're always going to be slower and
they're also likely to be flaky if you
have code that's not tested like what I
showed you before in my yeah few
implementation that goat isn't tested
also in the handler wrapper that goat
isn't tested in the native camera that
goat isn't tested it's not such a big
problem to have code that isn't tested
as long as that was a deliberate choice
i isolated all of those code parts to
one single class so it's nicely isolated
in a single class I know that's not
tested and if I would go to that class
to see what the class does every method
is just a pass through so I can
immediately understand what's going on
there so it's in a manageable risk not
to have that tested don't use mojito
spice I haven't covered mojito spies
here in the stock and there's a reason
for that because again yeah a spy is
basically a mark but it still goes
through to the actual object and you
really don't want to be doing that
because if you do not imagine if you
would have done that from the web
service if you would then go login on
the web service it would actually do a
login and if the login then fills or
your web service crashes then that crash
could pop up potentially in the next
test or for tests later so then again
your tests are not properly isolated and
you can have side effects from one test
in the other test and that's going to be
a mess over time don't nest marks so if
you have a mug that you turns a mug that
returns mark the
once returned mark you don't want to
have that because again what you're
doing there is your heart goading very
detailed knowledge about the rest of
your architecture in your tests so if
you were to change your architecture
later on then those tests are going to
break so you don't want that and avoid
using dedicated methods just for the
sake of making things testable okay
let's wrap things up so this is from the
Mojito documentation and this is really
really my sentiment about this talk it's
better to have something simple that
works then to have something complicated
that seems to work mockito has a lot of
powerful features but you should rarely
be using them the only use cases in
which I use them is if I'm testing
against a library of which I cannot
really control the interface so then I
need to yeah I want my go to be tested
but the library is inconvenient to test
so then you need a couple of those power
features to make it test of all but
wrapping things up you can say like yeah
mojito is really easy to use makes
mocking and stubbing really easy
don't create objects internally because
that makes things hard to test as a team
choose a testing strategy it doesn't
really matter too much what strategy you
choose as long as you are consistent
about it and don't overuse a bar
features you know that should be small
and focused consider refactoring unique
testing code is exactly the same as
production code so you need to treat it
with the same care otherwise is going to
bite you later on and prefer your tests
on the Java JVM which won't really be a
problem for most of the audience I guess
so that is it
I have some references to mojito and two
decks maker and also have quite a few
projects on github in the mojito example
project you can find any line of code
that I showed you here you can find it
back there and then you can just test it
around so if you want to see how to
actually enable testing fine also mojito
to doto just check out that example and
you can run it I have an open source
library called landscape video camera
which is completely test driven in fact
so there's many interesting testing
strategies there and also I'm creating a
new library called mojito collection
matchers where I'm also open sourcing
all of those yeah matchers to deal with
lists so the image credits I wasn't
responsible for making all of those
mojitos
unfortunately so credit where credit is
due
and yeah I'm atmosphere on twitter feel
free to hit me up or ask me any
questions and also tend to block quite
actively on the room topmost slash blog
it's not only Android related as you can
see also many just maven or Java related
topics so thank you very much for coming
to my talk we still have quite some time
for questions so if there's any
questions feel free to ask
no questions all right thank you very
much and ever a greater meaning of
DevOps</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>