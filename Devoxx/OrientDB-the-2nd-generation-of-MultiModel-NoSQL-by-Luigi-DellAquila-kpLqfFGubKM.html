<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>OrientDB - the 2nd generation of (MultiModel) NoSQL by Luigi Dell'Aquila | Coder Coacher - Coaching Coders</title><meta content="OrientDB - the 2nd generation of (MultiModel) NoSQL by Luigi Dell'Aquila - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>OrientDB - the 2nd generation of (MultiModel) NoSQL by Luigi Dell'Aquila</b></h2><h5 class="post__date">2015-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kpLqfFGubKM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi welcome and thank you for being here
I see a lot of people really happy about
this
my name is Luigi del Aguila I am
director of consulting at Orion
technologies and I'm also core developer
on orient DB so you'll find my commits
in github on Orion TB project today I'm
gonna talk I'm gonna talk about Orion DB
and multimodal databases in general and
in particular I'll focus on gruff
aspects on multimodal I have bunch of
slides but this is a tools in action
session so I'll try to go fast on that
and concentrate on code and practical
stuff okay let's start from facts 90% of
data in the world has been created in
the last two years so they are growing
exponentially we have a lot of data to
manage many different types of data
structured and structured some of them
are clean data some other data are more
less clean dirty and so on but what
really matters is not data alone but
relationships between data
I mean connections how every single
element in your data set is related to
other elements this is the real value in
data now to manage this growth of data
and match this particular shape I mean
instructor data and so on no SQL
solutions were born and were developed
we have key belief stores document
database is calm databases and graph
databases and other small subsets I mean
object data business and so on I made
two partitions graph databases is alone
on the right why just because everything
that is in the left was particularly
focused on performance on instructor
data on scalability and so on but
nothing there can manage relationships
the only no SQL model that can manage
relationships is graph databases
now why most know SQL products avoid to
manage relationships because it's an
hard task let's start from the beginning
from the old relational world
I think it's familiar to you it's a
joint table customer address and the
join table in the middle to represent
the relationship itself now we have to
execute the join every time we have to
calculate the relationship what's going
wrong with that one thing is that join
to be efficient relies on an index index
one primary key index on information in
the query itself anyway on the primary
key mainly but the lookup in an index is
like a lookup in an address book you
just have to go down logarithmically
that means that the cost of the lookup
grows up when the index grows up in a
dimension and this is very critical when
you have hundreds or thousands of
billions of records in your database
because that logarithm can be expensive
now the second problem with joint is
that join is calculated every time you
execute a query so if you don't quit
once the database has to calculate the
joint if you've the same query twice and
three times and so on every time the
database has to recalculate that join
and the joint is logarithmic for a
single key I mean so it gets worse when
your database size grows up so this is
what happens in your old relational
database the database size goes up the
performance goes down the solution to
all this is the graph database a graph
database is a storage system that
provides index free adjacency that means
that adjacencies relationships do not
realize do not rely on indexes but rely
on other types of structures let's see
what a graph is to understand a graph
database it's something very very simple
graph is a set of vertices in this
vertex is just a piece of information
here in database as an edge is a
connection between two verts
and exactly two versus a starting point
and an end point actually a graph
database is a property graph that means
a directed project property graph that
means that every edge and every vertex
can have properties and factor
properties I mean key value pairs and
edges are directed and you can have many
edges connecting vertices together
that's it this is your diploma in graph
theory this is all you need to manage
your graph database this is very very
simple this is the real power of graph
database is that it's simple well let's
see how graph true graph database can
manage relationship I say through graph
database because there are some tools on
the market that claim to be grafted a
basis but using the XS to represent
relationships so it's not very very good
in performance when you prop the first
point in oriented DB in particular but
in also in our systems is that every
element so every vertex every Edge has a
record ID the record ID is managed by
the graph database cheese the record ID
is managed by the graph database its
internal primary key and it represents a
physical position of the vertex or of
the edge into the storage that means
that if I know
13:55 I know which file I have to look
up in the in the file system and I know
which position of that file contains
physical position that file contains
that particular records relationships so
connections are managed as physical
pointers that means that the Luigi
vertex contains a reference to the edge
document to the edge record you see
22:11 the same record ID and the edge
contains pointers to both sides so both
connected vertices and the same is on
the other side
so you can't reverse this relationship
with a constant time I mean I'm not
talking about indexes I'm not talking
about the size of these database if you
have a handle to that vertex you already
have a position of that edge and in the
edge you have to put the physical
position of that vertex so traversing
this relationship is a constant time
operation it does not depend on the size
of your database think about this you
when you think about big data and you
can see that we have relationships on
Bob I mean we have links on both sides
that means that you can traverse edges
in both directions with the same
performance so which is the difference
of this one from a relational approach
in a relational database join is
calculated every time you do the query
in a graph database the relationships
are calculated when you insert data so
when you create the edge then the
calculation the query of the database
just follows physical paths
there's no calculation that's only
lookup constant time access so it it
means passing from logarithmic time for
a single traversal to constant time it
does not depend on the database size and
I told you this is really important when
you manage Big Data and this is very
handy when you have to manage
applications that have to manage
relationships like recommendation
engines social application Geographic
special applications or master data
management you know access control
information clustering and so on if you
think about this every database is a
graph even a relational database
represents a set of entities as a set of
nodes or vertices and a set of
relationships that can be thought as
edges now this is my very own Magic
Quadrant this is the first generation no
SQL we have here in the two dimensions
are data complexity and relationship
complexity so do
ability of the data model to represent
complex data and to represent
relationships at the bottom left this
key value stores equivalents or you only
know the key of every record so you
don't know the complexity inside the
records and you cannot manage
relationships moving on the right you
have document databases where you can
represent nested objects embedded
objects and so on schema less
information but no relationships on the
top you have graph databases where you
can manage very well relationships but
you don't have the schema let's approach
the embedded approach and so on so you
have less complex information relational
world is there more or less I mean you
have relationships you have quite
complex data but not at the top let's
say the real the reality is that your
information is sometimes like this it's
instructor disconnected it's you know
resources links information that you
cannot categorize and so on so you end
up with something like this you have an
application you have a master data like
a primary data store Oracle for example
to manage transactions MongoDB to manage
instructor data JSON data unstructured
information a graph database to manage
relationships because when you have to
do analysis on a graph you need in next
we're just in C you need a fast graph
engine and you have a cache maybe radius
and so on for direct access so too high
perform to have high performance what's
the problem with this the problem is
that you have to manage all this there's
no standard in all these four different
query languages for different
infrastructures for different policy
platforms and stocks I mean one is C++ C
another one is Java another one is know
what and so on you have to keep them
synchronized you need ETL in the middle
they have to be aligned and consistent
one with each other so
you need a team with a lot of
competencies and a lot of work to keep
them to gear the answer to all this is
no SQL as a multi-modal database so a
single data storage that can manage
graph data document data and also with
some capabilities of key value stores
and something more
maybe object-oriented concepts we will
see in a few moments so something like
this the intersection the multi model
represents the intersection of multiple
models so a single vendor to work with
that is a big advantage a single
language of query a single component in
the infrastructure and a single point to
manage but with all the features of all
the models in the new SQL now this is
what oriented DB is proposing every
vertex in every edge in or 80 DB is also
a document that means that you can have
edges connect vertices connected
together by edges and every vertex can
have a structure like this with embedded
documents and you can the database
understands that one
if you pass JSON to orient DB or entity
B will understand JSON if you query
oriented DB or entity will return JSON
so it speaks a language you already know
it can work in schema-less mode so you
can put instructor information inside
with new keys at runtime or you can work
schema for schema hybrid that means like
you can define a subset of information
let's say that the name and surname are
strings and are mandatory and are at
least five characters long things like
that things that allow you to have
consistency in the database you can have
a nested documents you see the details
there rich indexing and query capability
and developer friendly I'll explain so
the multi model is right there all the
advantages of document database the
ability to manage relationships as a
graph pure graph database and something
more
this is oriented EB here is a set of
features I will go very quickly on this
let's say that this is a mix
of all the models plus some very
important things that come from
relational databases like acid
transactions SQL support but also with
something more replication multi master
replication charting embeddable you can
use it as a standalone server or you can
embed it into your java application and
run it into the same virtual machine
with native API without network
communication I mean it's a big
advantage in terms of performance and it
has a lot of interfaces the main
interface is Java tinker pop all the
standard tinker pop isn't standard for
graph databases SQL plus extensions to
manage graph relationship JDBC
connection HTTP just JSON rest interface
and drivers for Java no js' Python
php.net C++ and more more it also has a
multi master replica though that means
you can start multiple instances of
warranty be out of the box and they will
just replicate databases it can manage
charting that means I can partition data
it has how to discovery that means that
you can start new nodes in the
networking day we just connect to each
other and this way you can implement
high availability fault tolerance and so
on but I mean I could go on for hours
I'd like to show you something first of
all that's let's install oriented DB
just go to the website let's see if
you're lucky there are some problems
with connection it seems Orion tv.com
that's beer download take your database
from here you will see this is here it
is 25 min okay and one downloaded it's a
it's a tar.gz it's a zip file nothing
more unzip open a console move to the
bin directory and do server dot sh three
two one go it's Ronny
now open a browser and move to localhost
2480 slash studio slash index HT
TP here we are this is a web console for
NDB or it has a an embedded smoke
embedded web server that intended to
manage this kind of things
let's connect with a demo database admin
that mean here it is thank you we are
here we can do some queries things like
have a small data set some people
connected together with some topics Java
JavaScript and so on with relationship
between people and topics Luigi knows
Java and so on
let's query this select start from
person it can sound strange you could
say what's that I mean it's a new SQL
solution yeah it's no SQL solution but
it supports SQL as a native query
language and the result is what you
expect here it is a table more or less
you see all the names of people and some
strange information here in and out
friend knows and so on these are edges
these are physical pointers to edge
documents the this is a let's say a
pretty print of the result if you click
here you will see a JSON representation
this is the native representation in
orient DB you see this is this must be
frank here it is a person whose name is
Frank and so on this is a JSON object
you can query it directly from the
browser you can enter a URL in the
browser and get a JSON result if you
want no and are important things another
thing I said select AF people and topics
so let's do select from topic here it is
auto completion have some topics now I
define a small data hierarchy let's say
I have a schema here Oh what's this ok a
schema I define the person class here
this let's let me enlarge it a little ok
I have a person class I have a friend
class
Frank lass is an edge look at this I
don't know have tables I have classes
like in programming languages and I also
have super classes with multiple
inheritance so friend is a subclass of e
is a edge and V is vertex and person is
a subclass of vertex also topic is a
subclass of vertex so I can do this C
select from V get all the vertices to be
I mean accurate I'd say I'm doing a
polymorphic query give me all the
results that are instances of V but
person and topic are subclasses of V so
also persons and topics are vertices I'm
doing the polymorphic query I can define
deep class hierarchies if I want another
nice thing is this one a lot your canvas
and select from V here these it's a
graph database so why don't you display
it as a graph this is a small subset of
my team there's me there
I know Java there are some people from a
team G America and as JavaScript SQL PHP
Python and so on
we all know Java or in DB is written in
job it's just for the sake of
description topic this is interactive I
mean you can click here do the details
for every vertex you can connect
vertices together I can say that I know
Frank is a friend of okay he's a friend
of Andre I select an edge class friend
and next I can also add properties here
if I want that feels easy and create
edge now here it is we have a new edge
connecting Frank with Andrew now ok nice
I did a couple of SQL statements but
let's see the power of all this I can do
simple queries but I can do something
more let me open a couple of bookmarks
let's create something more complex
that's good a person but I want
something more complex I want a person
with a name I did not define the schema
for these classes even though I could so
I can insert as many attributes as I
want in this case I'm inserting a name
and an address where the address is a
complex object object with a street name
plus the CD and inside the city there's
a country and so on let's create vertex
ah I could do insert into into person
that's almost SQL but I'll do create
vertex run here it is and it created Bob
it's showing me that the the record
content now I can query this using the
document functionalities so for example
I have bookmark query otherwise go crazy
with that side from person where address
Street like foo and address dot city dot
country dot name equals UK you see the
structure here I have an address with CD
inside there's a country inside there's
a name that is UK so that should return
Bob that's right here it is and this is
Bob
you can put constraints on your data
objects with schema you can put indexes
you can many things now let's do
something better let's leverage all the
power of graph databases think about
doing a query in a relational database
where you have to query a hierarchical
structure let's say you're not an
organization instructor for company you
have a manager you have to find his
departments of the parts of instance of
departments and so on and go down until
you reach the end but you don't know how
deep that is how can you write it in SQL
you just can't you need something more
and here the graph API comes handy
oriented DB defines some new keywords
inside the SQL to manage deep traversal
let's do this let's select a person
select from
we're name equals not the star is
optional I can put it here that's not
from person our name equals Luigi this
will return myself let's see let's find
my friends
select out friend it's saying follow
outgoing edges was that their outgoing
edges out I can get incoming within or
both directions with both let's do this
so what friend it will get some record
IDs in this case let's expand them
expand oops here it is and see the
results now I want my friends of friends
both friend dot both friend okay here it
is there's also me because both I'm
going out and in but that's a detail I
can exclude that now the performance of
this query does not depend on how deep I
want it only depends on how many records
and edges I Traverse mmm I can do more
in this case I know that I wanted to go
at a particular depth to in this case
but I can do this select from person
here this this is me and then traverse
traverse out or both friend and from my
record while depth is less than uh nope
for go to depth for I can remove this I
can go deep as much as I want okay here
it is it does it avoids loops so it
stops at the point I can do more I can
write a while with anything here while
name name is different from something I
know
oops different from food in a while
condition I can put everything that can
be put in a word condition that's just a
filter it will keep traversing until
black the condition is not met anymore
so all these together with replication
time is running fast so I believe some
time for questions and answers all this
with replication and sharding I launched
the server with let's stop this with
server dot s H I could launch it with
this server dot s H and it will start in
distributed mode if you launch two
servers with this server on the same
machine or two machines with own in the
same network
they will just join each other and share
databases that's automatic then you can
partition data if you have a big
database you can define single slices of
your data set and deploy every single
slice on a particular machine all this
with transactions you can do begin
commit and rollback on this one and this
is a real advantage we strongly believe
that data consistency is not optional
data consistency is something you need
every day so even in no SQL world even
when you have to go fast you have to
choose if you have to go with
transactions or without of course doing
something with transactions in some
cases with low down some kinds of
operations a bit in some cases it won't
anyway you have to choose an oriental
bit supports transaction or NDB has a
pure Java API so you can get vertices as
Java objects traverse them using Java
API get edges as Java objects put
properties on and get properties from
into vertices and edges using a Java API
you can run or entity B as a single
server like this from the common common
line or as a system service or you can
embed or it DB jars into your java
application and run it together with
your application without network
communication and this speeds
performance a lot all this with apache
license that means you can use it for
any purpose
even in production I mean you can have
Orion to be embedded in your application
run it and we will never know about you
and that's fine you can have Enterprise
Edition that's free for developer and
you can have enterprise level services
because behind oriented DB there is a
company that provides enterprise
services so production support
consultancy and so on all the important
services this link is points to free
training check it out it's not I mean
it's simple but it will get you started
very quickly couple of numbers is a bit
old we have 80,000 downloads per month
we are we have almost 100 or more than
100 committers and contributors on the
projects some fortune 10 companies work
with Orion DB in production and we have
a lot of resources we are in USA in
Europe and so on we are also in India
right now so that's not updated and this
is the trend of the growth of database
technologies in last year's the green
one is graph databases search as figure
out some customers that are using orange
TB in production right now just for a
reference thank you very much any
questions we just have three minutes
left
so if you have any questions and here
Thanks
that's my Twitter handle these lights
are on SlideShare SlideShare / Luigi the
lock we like you will find</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>