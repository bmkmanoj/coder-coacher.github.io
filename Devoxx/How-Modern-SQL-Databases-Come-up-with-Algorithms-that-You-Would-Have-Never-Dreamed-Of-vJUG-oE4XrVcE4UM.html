<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How Modern SQL Databases Come up with Algorithms that You Would Have Never Dreamed Of (vJUG) | Coder Coacher - Coaching Coders</title><meta content="How Modern SQL Databases Come up with Algorithms that You Would Have Never Dreamed Of (vJUG) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>How Modern SQL Databases Come up with Algorithms that You Would Have Never Dreamed Of (vJUG)</b></h2><h5 class="post__date">2017-05-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/oE4XrVcE4UM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">work it make it do it make sure okay
this is live now from the virtual jug
and from de box London DevOps UK so in
London and this is a virtual jug session
which we are actually presenting to a
full room hey everyone's live on the V
jug now wave there we go wave be happy
okay and joining us this is I call it a
virtual jug everyone is here but you
Lucas welcome to Lucas EDA where are you
calling from Lucas into its little use
level Jeff from Swiss and whereabouts in
Switzerland zero beyond take it st.
Gallen you don't know it it's in the
East so we just let us say Zurich yeah
and until Lucas who are you you're the
CEO of data geekery yeah that's correct
and now I didn't create the company
behind Juke which so many of you may
know as the new Java way to interact
with sequel awesome and what are going
to be talking about today
so today's talk will be about sequel of
course and the title is how modern
Stickle databases come up with
algorithms that we would have never
dreamed of okay be interested to hear
what you think of modern s what did you
say a modern SQL database right yes
excellent I'm looking forward to the
definition of that so joining us as well
is Roberto Cortez oh look at that that
is me I believe I was doing either a
great time finding so Roberto is also
one of the leaders of the virtual jug
helps with the book club and also with
that leads the book club and also helps
with video 24 which is very much
appreciated a little sneak so we
announce it yeah let's announce it save
the date for October 25th when we're
going to be also doing our second
edition of V jug 24 which is 24 hours of
live Java conference 24 back-to-back
sessions so that's going to be kind of
fun if anyone wants to ask questions
they can ask it in the room or online
will we'll get
see up online you can also ask here with
in IRC if you really want to but I'm
kind of a bit meta and without further
ado let's pass over to you Lucas and we
can we can start well you read the
questions to me okay yeah we can read
the questions okay
or have you not read Lucas kind of no I
stopped reading no really okay so you
can see my presentation we can perfect
it's all animated now yeah it is
perfect okay so we haven't to say I have
a hard stop at when 6 6 a 5 6 6 6 0 8 no
exactly 6 because because Roberto has
cut a line I not blind not divided by an
acknowledged Okinawa 1 straight after so
apologies if we leave is over 5 or 6 6 6
or 5 all right
6:05 yeah so I've a little spike so
let's go how modern sequel database has
come up with algorithms that you would
have never dreamed of or the short
version of this title is some why are
you all here so I understand this is the
Java user group the virtual Java user
group or the devoxx UK a conference
everything is about Java so you're here
because you think this cannot be true
right this must not be true and you will
run out of this room
is it true though or oh my god I'm going
to rewrite all my codes to go excellent
so me I'm Lucas difference here with
data geek we at Simon already told you I
work with Oracle and Java mostly and I'm
at a charge the group for Ben were in
Switzerland so if ever you want to come
to Switzerland do some location and talk
at our user group please join me or also
the Vox days direct conference which is
also a part of the Hawks franchise and I
believe that sequel is a device whose
mysteries only exceeded by the power why
do I talk about equal to Java
conferences sequel is the only ever
successful mainstream and general
purpose force generation programming
language and it is awesome so why don't
anyone else talk about sequel is that
awesome I don't know I have absolutely
no idea no one talks about sequel
Abdallah conferences everything is micro
services and stuff like that no one
talks about Seco except maybe a blast
very nice guys hibernate developer
advocate and he started talking about
sequel as well at conferences so this is
an example from flat blog it's a very
interesting example because it shows the
only important and only useful a JPA
feature and that's that feature over
there
so when you can write actual sequel with
JPA then actually you win with JP as
well so who I see my other talk usually
I see hands in the room not on any hands
let's see my other talk I mean this talk
hear this talk to convince you that
sequel is awesome right if you have not
seen my other talk you should google it
just google tentacle tricks and you will
find my talk all over the place and my
other talk is about these lies little
tickle tricks like this one here so here
we have a recursive query for Postgres
and when we run this query you've
already mentally executed this query in
your head then you see immediately that
is the result right the sequel is really
a computation engine or your database is
a computation engine your application is
sitting on a Ferrari style computation
engine and you can run really awesome
sequel statements with it and that's the
other talk but today we will talk about
more basic sequel and it's still going
to be awesome right so you're saying
this is sequel who in here things this
is sequel anyone things here this is
sequel so if you think this is sequel
then this talk is going to be so I've
already talked about how sequel is
awesome this is the outline of my to
talk sequel is awesome I've already
shown this so let's focus on how Seco
makes you productive and finally we get
to how sequel is fast there are two ways
of proving how sequel is productive I
could show you some examples and I try
to when I prepare this talk I try to
find some examples which are really
really convincing a really really nice
examples of how really really awesome
sequel is but then I thought about a
second way of showing this is by showing
the alternative if you don't do it on I
try to do it in Java then you see the
alternative right so this is going to be
a high level conceptual story about Seco
we're not going into deeper levels of
sequel today for that please watch the
other talk so business is asking right
we're always doing stuff for business
this is the main purpose while we do
stuff in programming we do something for
business and this is our database for
instance I'm just using this sample
database which is called the Tila
database you can download it for free
from market stuff and it has a DVD
rental store
so what we have here is the film table
you see the film table in the middle
nice little example database film table
and we have actress here and we have
inventory rental and payment so
everything that we need when we rent
yuji's the business is asking how much
money we earn with each film on each day
right so that's a typical question that
business would be asking us programmers
and we programmers will think all right
I know how to solve this let's sit at
the problem and we're going to identify
this is the film table and this is the
money this is where the money is right
so between film and money we have to
somehow join these two things and we
also have today information so we have
all the information between these two
tables how much money we make for each
film on each day right so you see the
path between these two tables excellent
so this is the path between these two
tables and now what we're doing is a
joint right so you see we join these two
tables between these on this path and we
don't have any problem at all so right
we start we write the query and it's
really really easy it's really easy you
see immediately that this is the film
table so we need money per film right so
you see the table right there
and that's the relationship between the
film and the money and now we aggregate
for film and days and then we have the
result okay
business is happy this took us about two
minutes to solve and business is happy
and they can make a lot of money because
they have many questions that we can
answer and now let's try doing this in
classic Java and by classic Java I mean
this right ok yeah so I can't hear
laughs so this is why is a introduce the
laughing a sound right here so I kind of
have the impression that you laugh my
joke this is a Java and we're starting
with the Java class everything starts
with a class you still with me okay
perfect so now when we add a class
obviously film is a tuple so we can
create a tuple in Java as well we add
some attributes this is the only
important information that we're ever at
in Java it's this column now because
it's Java we have to do it like this
right this is John we have to write
getters and setters everywhere because
the Java no one asks questions about why
we do this we don't care we just do it
all the time right so someone someone
Rio from the 90s told us to do so we're
just not questioning it we're let's do
it
and then we can't forget these of course
as well so we have to write hash code
equal to string and all these things all
the time for film film factor from
inventory for payment for all of these
entities we have to write this code and
then ladies and gentlemen this is really
dangerous code so because it's Java we
add a factory right so we have to be
sure that no one can actually
instantiate a film without our consent
so we have to be sure that the film is
instantiated with the factory and the
factory is also a dangerous place to
work with because the factory cannot be
instantiated by the user either so we
create a film factory builder exactly
and now this is still too dangerous in
Java because we can't work with classes
we have to abstract these things and we
have to create interfaces instead of
classes and then we have private
packaged private implementations that no
one could see for these interfaces right
and we're not done yet because this is
all too tedious now we've written so
much boilerplate we need to add some
spring to configure all of that right so
we add some beans or some component I
actually got this wrong so it's a real
annotation of the component and we need
to catch some of these things and then
we add a little bit of Lombok because
obviously Lombok helps us be more
productive and then actually while we're
at it we're at some new libraries we
just found this new library and then let
actually some more libraries as you can
see here the more libraries and in the
meantime the average enterprise Java
being that you've written art there is
actually visible from space right if you
speed right there that's the average
enterprise double-v that you can see per
space I've written it in a gallon so
that's where it's good and if you want
to have more information about this
topic here at the website for you to
annotation maniac because everything
that we write today's more a little
refactoring right again it's annotations
I think Roberta and actually show you
more information about this he has
written some really nice annotation from
this blog so Roberta be sure to show
that the audience about your annotation
skill of testing we're not done yet
right we've only implemented the
enterprise javabean what do we have to
do we have to actually get from the film
to the inventory storage rental to the
payments right to remember all these
joints we have to do that as well in
Java just because we're doing it in Java
doesn't mean we have to do we don't have
to do the work so let's just start with
the inventory so we get a guest
inventories method here so we get a list
of invents
and then we use this nice annotation one
more annotation can't hurt right so we
write this nice little annotation one
too many we're mapping at the
inventories by the film so I'm sure
you've seen these other things right now
the question is you want to discuss this
or that right
make sure which one is the better again
as what the only other guy that ever
talk about sequel conferences yes the
answer is but we're not going to focus
on these APRs we're going to focus on
the Java code so this is the optimal
result type that we want to have right
we want to have how much money how much
money that's right there the money the
big decimal how much money did we make
per film and per day so we're using a
map of map of big decimal right perfect
and actually if you really want to go
into the domain-specific girl or recall
is that domain driven design and
everything you want to model your domain
not with the value but with an actual
money type and we have the money type
for this
there's the Java money API right so the
domani APR is idiomatic Java and you can
see the immediate like there right yes
idiomatic to our money API very simple
way to interact with money in Java
perfect okay right so but we're going to
skip this part today we're just going to
think that big decimal is good enough
for money so this is the result up now
now let's think about this is really a
good result type or maybe this yes this
is a difference or maybe we should use
this but instead is better maybe we want
to actually show the result in a sorted
order right so we have to use a tree map
and actually the junior on our team he
said okay I know everything's better I'm
going to write my own life I write my
multi key map right so because this is
the map with two keys and one value we
actually need a new type for this that
optimizes everything and why we're still
deciding for the correct collection type
are everyone feels like this right so
who in here in the room has felt like
this before you can add you can actually
move our phone okay
so we've had the answer right now okay
it's me yes the answer is yes okay
perfect now anyway let's calculate for
real we've not calculated anything yet
we've just discussed data types okay so
this is the result imagine the result is
this and now we're going to we have to
load all the
oh my god and there's n plus-1 problems
we see it it's really really slow but
all optimizes later right and okay uh
well optimize this later and urgent this
is really slow in production someone
please optimize this so typical Java
development cycle right so now we loop
over the film and then we have to do
something with the with each individual
film right so what is this something the
something is we have to get another map
from the map so we have a map of local
date and bigdecimal right so this is the
same part you immediately see this very
very easy and oh my god probably enjoy
our lazy initialization this is no at
first this is not we have to initialize
this first right everyone agrees this
has to be initialized first because
otherwise you get a nullpointerexception
oh my god this is Java right everyday
telework you would know this feeling now
remember this discussion oh my god
nested map this is a link task same
discussion again but let's get this
discussion let's just assume you have
lazy in Oster eyes the nested map and
now from this daily results we go to the
inventory so from the films we go to
inventory and from the inventory we go
to rentals and from the rentals we go to
payment and now you really think about
eager and lazy again so eager was
forbidden but lazy is not much better
either so do this lazily you get about a
million queries I guess right so
everyone knows okay perfect now because
we don't want to have anything like
eager or lazy in our code we actually
use the entity graph right the entity
graph is what JP a came up with to
actually run queries this is the entity
graph ladies and gentlemen so this is
how JP folks say for this particular
case when we go through the graph from
15 metrics rental payments we are
actually using only this main sub graph
and I'm feeling all like oh my god what
is this going to do remember this slide
here I showed you the average enterprise
javabean it's visible from space now by
the time you add all these patients the
average dollar enterprise javabean is
visible from Andromeda galaxy right it's
right there you see from outer space our
aliens will see our Java being perfect
okay anyway yeah very funny okay
the looping is done right we're in the
middle of loop so we put a value in this
nested map so the payment date and the
Imam
is going to be put in the nested map and
oh my god that's still not correct
because we still have to lazy initialize
the zero value so we have to write this
code here right so if the map contains
the date and we added otherwise we just
put it and all this code is getting so
hairy and someone says okay maybe Java
eight and use compute compute is a much
better methods of computing absence we
can lazily initialize the hash map and
lazily compute the value that's much
much better right and everyone in the
room is already feeling about themselves
like this now you see everyone knows
what's going to happen next right now we
figured out the algorithm completely
it's correct and then this guy shows up
business is acting again oh my god did I
say how much money per film I meant how
much money per film and store oh my god
all this work okay so these are the
programmer reactions the sequel
developer and the Java developer have
different reactions right so this is the
sequel rear up developer then ever he
has a change request is just all right I
gotcha Covered all right perfect
and this ladies and gentlemen this is
the Java developer this is the Java
developer yeah that's how we feel about
change requests by us everything changed
again all back to the start okay what is
the secret developer do the sequel
developer checks out this original
sequel query and then he just asked a
little bit of white space right there
you see it a little bit of white space
and then we add the store ID column
right there and we're done
right so business is asking business got
their answer again and we got a paycheck
and the raise and more vacations because
we're so good now the Java developer all
right oh my god this was my code was the
compute it's absent everything I act on
it I'm going to do the cool trick as
well as the sequel to I'm just going to
reserve some space right in there and
then I'm going to add all of these
things or my god who can see it and now
now you see maps of map of integer of
map of local date big decimal this
inevitably triggers attention of the
Software Architect Software Architect
we'll save that this guy by the way he
sees everything this is every one of
your commits we will
zip we cannot have such type we have to
factor out the type in a new class right
you cannot have map of map of map we
have to have a class as a factory and by
the time you have this argument you're
just going to say oops oh my I'm going
to quit this job while you and your
architect engaged in a nominal where the
structural typing philosophies you
prefer a functional programming and he
prefers maybe object-oriented
programming there's this guy again you
know who that's coming that you know
this guy right yes exactly
the inevitable did I say write daily
revenue I meant cumulative daily revenue
oh that's what I meant okay
the Java developers really oh my god I
want what is cumulative daily revenue
what is it cumulative sum so you check
out the internet right so you go to the
internet and you type in cumulative sum
revenue what does it mean okay so you
touch the internet here and you get this
result and oh my god oh my god what is
this thanks God it's Friday
I'm not going to implement it meanwhile
the sequel developer he's just going to
add a little bit more white space at
this nice little window function here
the window function which calculates
conveniently the cumulative sum of the
dailies revenues over our payment tables
as you can see here in our database the
cumulative sum is just adding up the
previous sum for each transaction
wonderful that is all we have to do in
sequel so I think you get the message
right now the difference that I've shown
you is Java is a third-generation
programming language sequel is a
fourth-generation programming language
this means in sequel we only declare the
result we don't actually say anything to
the database about how it should
implement this algorithm we just say
this is the result we want to have now
figure the algorithm out for us
wonderful right this is really wonderful
this is why the companies called Oracle
because we asked the Oracle question
again so we'll give this an expensive
answer though algorithms are boring
we really think algorithms are boring
mostly we don't care about these things
you don't care about writing algorithms
using them is a different story of
course we want to know exactly how to
use the algorithm but we don't
to write algorithms we don't want to
write the sort algorithm we don't want
to our data structures we don't want to
perform premature optimization we don't
want to think about is linked as Maps
performing better than hash map is a
linked list better than ArrayList we
don't want to think about these things
we don't want to think about data type
details when we have high-level business
logic that we have to implement if
business is asking us some interesting
question we don't want to really think
about is it better to have a hash map of
a B or a list of entries of a B right so
in concept and theory these are more or
less the same types but from an
algorithmic perspective these data
structures are completely different and
we have to decide all of these things
all the time we don't want to write
local variables what was the last time
you actually enjoyed writing a local
variable never right and caches you
thought of our caches you don't want to
care about caches caches should be
completely transparent we don't want to
actually store something somewhere which
is want this to work we don't want to
write loops and loops and message nested
loops we don't want to lazy initialize
anything or care about
nullpointerexception or you could
discuss about optional so optional might
save you from the null pointer exception
but not from the lazy initialization
problem we do care about these things we
do care about business logic because
that's our job we have to implement
business logic and with sequel we're
just doing a bit of indexing and then in
most of the time it's going to perform
super well so someone will tell you
okay we'll generate everything changes
okay at least we can write functional
logic right now so this is a quote from
Mario fiscal where he shows how we can
do something incorrectly or functionally
with the stream API so the stream API
would see something very similar we have
something like from here and then we
have something like where right there
then we have something like fetch next
or over limit in sequel and something
like group buy and this reads really
nicely so it's much easier to read when
you put it like this course the example
is really simple and really made for for
this example but in the inner ear
principle sequel and scheme APRs they're
very similar they're very similar so you
can see the table in sequel is something
like the stream of tuple in Java so a
tuple in Java it's just a class the
class has attributes tuple in sequence
also triggers and a stream and the
tables exactly the same thing more or
less a select operation is like map map
the tuple is an input and gets a tuple
as an output supply select when you have
a select expression you have select
first name last name you get a tuple you
produce a new tuple it works in a very
similar way at least a mindset of doing
these things is very very similar the
things is the same thing is of course
join and flatmap are kind of similar
we're having and filters the same thing
group buying collects is more or less
the same thing order buying sources it's
just different name Union all and concat
just different names now let's look at
our java algorithm this was java
algorithm in an imperative way now let's
try something really really nice with
stream so we're just streaming and flat
mapping right so this is essentially
what we have to do we stream all the
films first we stream all the film then
we stream the inventory's from the film
then we stream the rental from the
inventories and then we stream the
payments from the rental that's it
but now we have to access s and i in the
collector when we want to aggregate how
much money did we earn on each day we
have to actually remember all of these
parts we don't remember them with flat
map so we have to nest them somehow so
here I'm using something entry like a
map entry where I keep remembering the
inventory the film the rentals and the
payments ok so you can use some rapper
and pray for stack allocation to happen
right so performance in this case is not
very validated yet but ok let's assume
that this worked and now we just have to
collect into some grouping right easy
everyone agrees is easy perfect oh my
god all of these so we have to remember
this was the film inventor rental
payment nested type and we have to get
the key QT to get to the film back back
to film and you don't see the types
anymore right here so but it still looks
declarative right so this is more or
less the Java solution to doing the same
thing like in sequel with Java 8 it
looks declarative and if you want to go
one step further I can do some little
advertising here for the open source you
lambda library that we're a publishing
jolanda's
goal is to bring a little bit more
sequel to java language so we can do
something like this you can do multiple
aggravation and stuff like that I'm
going to show how we can improve the
stream API usage with Jolanda so instead
of streaming we will just use the
Jolanda sequence but everything is a
sequential not parallel that's the
difference
one down stream so what we can do now
here instead of having this nested
nested types you can actually just cross
supply across the price feature from the
sequel language it's available in super
server oracle and Postgres so you can
cross supply it's bit easier so we can
remember this cross supplies means if we
get the film and inventory in one tuple
and this automatically nest film
inventory and rental tuple etc so I
leave it up to you to read what cross
supply really does but it makes it a
little bit easier right here that we can
now have a film inventory rental payment
object right there so we have to
dereference everything and again and
again so this is really a bit tedious so
we can maybe refactor because we didn't
really need to rental we haven't needed
for rentals except for joining so we can
factor them out so right now we have a
little bit better just one entity has
gone and maybe we can actually use this
group by operation so this actually
looks quite neat and the result type is
now off a little bit nicer and okay the
point I'm trying to make here is how
much time do we spend on this problem
now I already have two almost a quick to
show right now because the Roberto's up
next so I have to stop right here the
point I'm trying to say here is you're
already falling asleep with the Java
solution right we can discuss this
endlessly but the sequel solution was so
easy this was such an easy solution and
we could change it so easily as well
Pico is a fourth-generation programming
language this means it's a great
improvement of developer productivity we
can write sequel so much faster because
we don't have to worry about all these
algorithmics and data structure details
and we don't really care about how much
I'm just standing about talking about
Siegel so far almost nothing how much
time did I spend talking about Java so
much time so sequel is easier this also
means sequels more productive so I think
I've proven this second point sequel is
more productive
we're ready for change requests so we're
now reaching the final chapter which is
the best chapter the one about
performance it's not only about making
you more performance but also the
database itself so how does equal work
we have to understand first how to go up
now let's hear this guy again how many
films each actor whose last name starts
with a play in this is a typical
weary typical maybe a bit academic but
let's run it so the career will give
this result in our database so all these
people have a last name that starts with
a and these are the number of films it
played in right so this is the query
going to run and that was the query
actually in sequel so we will select
first name at them from actor film actor
joint and then we check the last name
starts with a group our first name last
name and then we count that is the
single queries and now let's see what
really happened this is the syntax we
have to understand this syntax is not
exactly the big thing as what happens
logically so people often criticize
sequel because they don't like the
syntax and that correct the sequel
syntax is a bit weird it's really an old
type of language so you have to get used
to it but once you get a hang of the
following slides I'm showing to you it's
going to be much easier because the
logical operations order is not the same
as the sequel syntax operation order the
Select Clause is not the first thing
that happens logically in your single
statement and observe I'm saying
logically am not actual order the actual
order we get to that is going to be
displayed by the execution plan so the
optimizer will figure out the actual
operations order but now let's focus on
the logical operations order so the
first operation is we're selecting the
actor table and the film actor table
we're loading all the data from these
two tables and join these two so the
join keyword is actually not a keyword
from the Select statement it's an
operator between two tables right so the
keyword is from from is the keyword that
we execute first in the Select statement
and now the second operation is the
predicate we acquire the predicate in
the where clause the from produces
tuples or records and where reduces that
resulted again because we only want to
have actors whose last name starts
letter a now we collect groups group
wise the third operation in this example
so we're grouping everything by a first
name and last name but it's the third
step and the first step logically is
aggregation after grouping we aggregate
now again this is the logical operations
order it might well be that database
will prove both steps in one go or maybe
even to something with a pre calculated
count value from an index or from a
materialized view but we don't care
about that
logically it's the fourth step after
grouping and you see two terms we're
using the current expression count star
is in the Select clause and in the order
by clause but the database may well
choose to optimize these two expressions
it should actually and execute them both
in one step so you can reference counts
are many many times and because we don't
have any performance impact
now count star is already calculated in
step four before we project so before we
actually run the Select statement count
is already there and it's calculated so
now we project and we create this new
tuple and then we order by the pre
calculated count expression this is the
logical operations order here's a slide
with the pretty much the full logical
operations order with all the closet
that you use every day
so from happens first and we're and then
some obscure connect by an Oracle if you
using Oracle group by and then all the
aggregations and once you have
calculated the aggregations if you using
having that happens now and then window
functions will be using those let's skip
model in Oracle and then finally now
you're doing select number nine I use
the laser pointer so you can follow my
train of thought I have to select we
apply these things and then will you
apply Union intersecting except then
order by only after this has been done
then offsets and limits and finally for
update if you want to do pessimistic
locking so this is the logical operation
order and this explains a couple of
things for instance aggregations happen
here right aggregate functions happen
asked a group by and after where this
means this is the reason why I can't use
aggregate functions in the where clause
because the where Clause has already
been executed you cannot use an
aggregate function in the where Clause
because they are calculated after the
where clause or if using window function
30 firing here you cannot use window
functions where Clause either
right because they're happen afterwards
but you can use window functions in the
Select Clause because the Select Clause
happens after the window step now column
aliases if you use column aliases right
if you want to read need a column in
your select clock you can only use that
in subsequent operations like ordered by
you cannot use an alias in where this is
quite tedious because we have to often
repeat ourselves in the sequel language
it's no language Ramar so it's
sometimes are a bit tedious to use this
explains why you cannot use a column
alias in this in the where clause or in
the group by clause even if that would
be really useful that explains a singer
too right
okay but I told you that's not really
what happens any algorithm that produces
the exact same result as this logical
operations order is acceptable and we
can see the algorithm from the database
for instance this is the algorithm in
Oracle I'm going to show other examples
afterwards this is called an execution
plan so who in here has seen an
execution plan in the past you can use
your mobile phones again to vote okay so
there is a oh okay okay
it's great so great I'm here I'm showing
you something you I'm just assuming
right I'm just making this up but I'm
assuming 15 this so just try clicking on
these buttons here in Oracle city to
deter or Postgres PDF main or sequel
workbench for my sequel or sequel server
management studio you have these buttons
to display estimated execution plans and
sometimes even actual execution plan so
there's an estimate and there's a real
execution plan that's a nice difference
to know about but in any case the
interesting thing here is for instance
in the Oracle execution plan we have how
many rows are produced by each operation
right so you can see right here this
joint operation produce 154 rolls
estimated 154 rows and this where Clause
the where clause or it selects the last
name starting with the letter A it
produces six rows and altogether more or
less thirteen rows and here we have
quite a big number we're going to look
at this afterwards what this means so
you see the number of rows the database
things it will produce with each
operation and here's the cost the cost
in Oracle is a bit weird but in other
databases it corresponds to more or less
the time it will take probably database
estimates how much time and how much
resources will I need to calculate this
result so the actual execution order is
always in execution plans it starts from
the bottom and goes up so the first
operation in the database is to get the
row at ease from an indicated predicate
so I think pretty much everyone in the
room would have thought that it is
probably better to run the predicate
first until index and only then execute
the draw
right so to join even if it's logically
first operation it's not the first
operation that gets really executed the
first operation is accessing the index
and then we access the remaining rows
from the same table all right so that's
the first thing that we do the active
table is loaded first but only those
rows that we actually need with an index
access and the third step is we're
loading the entire foreign key
relationship index into memory what was
that surprising if you look at this the
chip index is being loaded into memory
because the database things that's the
fastest way to actually run this query
all right we're not going to actually
look up each individual actor and select
their films and then only when we've
done these two steps when it's loaded
both tables then we put them in a hash
map and join them and then we put
another hash map to group the rows and
finally we sort the result because
that's what we're required now the
question is we've chosen the same
algorithm apparently it's faster in this
case to load 5460 two rows into memory
than seeking six counts individually so
the database thought this was going to
be the faster algorithm and I think
pretty much everyone in the room would
not have chosen this algorithm you would
have chosen to select the six actors and
then loop over these six actors and
select all their films individually and
count them the difference is a hashed
shown in algorithmic complexity in
Oviatt notation integer notation is o of
n so it's linear you can execute a hash
drawn in linear time with n being the
number of film actors so the bigger
table is the one that influences this
algorithm
what's the nested loop drawn with
indexes it might have a worse complexity
right here so maybe it's log M times log
n or maybe it's even worse M log n so we
have a worse complexity for small
amounts of data this might be better but
for large amount is better data another
one is better so which one is better all
the time it depends so the database it
always considers these are going through
complexity so this might be our the data
that you have what do you think you have
so maybe we have here a couple of
algorithmic complexities around stirring
up my power point so here a linear time
logarithmic is too green curve
linear is this one and this one is
sorting n log n etc but maybe what you
really have your data set is the small
size here right maybe you have this data
set where all the complexities are kind
of inversed where the worst complexities
might perform better than do it the
better complexities the linear is not
always better maybe a quadratic is
better for small amounts of data and the
problem is also quadratic is also better
for your machine when you work as a
developer with developer data set then
you are always in this area where
everything seems to be super fast and in
production you have a lot more data so
you really should think about
algorithmic complexity and understand
these here's a nice link to learn about
these things if you've never seen it or
if you want to refresh your knowledge
about algorithmic complexities and time
space complexity it's not a thing let's
talk about histograms databases do this
this is the histogram we have here the
bank account transaction table and this
is the distribution of our amounts so
pretty much in all bank accounts we have
probably something in the middle a bell
curve where we have all the time we have
something like we paid for the
restaurant or we are the restaurant and
we get the money or here and at the NBC
we buy a new car or we are the car
seller and we sell a car so we have a
lot of transactions here in the middle
and only few transactions at the end at
the other edge now imagine we have these
queries these two predicates someone
wants to check if the amount is between
one and two thousand and two thousand
someone else wants to check it demand is
between five thousand nine thousand both
of these ranges are the same size right
but you both predicate prop from
indexing this predicate here is not
selective at all we're selecting almost
all the data so when you have an index
on the amount column
we're not profiting from using the index
whereas here we can certainly use the
index see these two predicates are two
very distinct predicates depending on
what data were selecting we're accessing
doing this is only worth the pain if it
helps reduce the result set otherwise
just read from the table or read from
the table which is loaded into memory
completely or we scan it it completely
and the database knows all these things
nice stuff we don't ever have to think
about these things
until they go wrong and they don't go
wrong very often right so the database
can always choose the right execution
plan depending on what you're doing with
your queries and your queries
change in production maybe you have a
lot more data tomorrow than today and
your database can adapt their fusion
plan so how many rows are returned from
the table database notice how how many
rows are returned from a query notice
how much does it cost to the access to
this the cast how often this is three
run how often is the table active how
much memory do we have I'm deliberately
skipping these things because we don't
care about these things right how many
our processes are running parallel right
now how does the creeper form with the
find variable are we running on HDD SSD
flash your RAM oh my god right so in
memory no sequel TV vendors it's hard to
tell you we have to do everything in RAM
now but maybe you want to offload
something to this um our demands can
optimize all of these things and
everything is a car so how does equal
work everything is a cost so a
particular spring produces an expression
tree and I'm going to go through this
really fast I only have four with five
minutes right
nine minutes okay so the parse single
string let's imagine this is a car so
you bring this an expression crease the
week's a a plus a minus B is an
expression tree and we can say multiple
expression trees are equivalent so they
can be transformed into each other so we
can say a plus a minus B is exactly the
same thing by the laws of associativity
of addition we can also say a plus a
minus B and we'll get the same result
it's a different expression tree but we
can easily see it's exactly the same
thing now that we have shown this you
can also another transformation we can
actually say this is also the same thing
all right two times a minus B is also
the same thing and this is a much better
execution plan if accessing a is super
expensive
imagine a is on the disk and B's in
memory do you want to run the first
execution plan or a second one so this
one is obviously much better the
database does all these things it
transforms your query into other queries
each expression some tree has a
corresponding execution plan and an
Associated estimated cost and then the
best plan that the database can come up
with the one with the lowest cost is
chosen and then these commercial
databases do this the actual execution
cost is compared with the estimate so
the database can only estimate it then
it runs it and get actual cost and it
can use this information to improve
future estimate the future executions
the one is the last
Oh Jericho the business with last time
you wrote Java code that can adapt its
own execution in run time depending on
the data set that you're transforming
your estimates aren't even done in
production you're estimating stuff with
your developer data set okay so the
production is here your estimate is
being done here and you see immediately
why sequel is fast you can be super fast
because it can adapt its execution plans
that it algorithms in production and now
that you know all of this which one do
you prefer you prefer this which was
already much much more tedious to write
or this which is going to be much faster
anyway right and I'm telling you a trick
so I lied to you it's not always easy
and simple to tune sequel but imagine is
tuning something that was written in
Java which has the equivalent complexity
it's going to be even much harder there
is a nice quote from Rafael winterhalder
which recently published he's the
developer of byte buddy ah hello Java
champion and he says knowing Java
performance fairly well is a nice trade
but not knowing my database well enough
still punches me in the face once a week
right so most of the time when yes
performance problems it's in the
database even if the database does the
stuff already so good so you have to
imagine if you have to do all this work
that is already hard to do instead of in
the database in Java
that would be horrible ok so why do I
talk about sequel sequel is the only
ever successful mainstream and
general-purpose for generation
programming language so everything I did
here is declarative you can do
everything in sequel declaratively and
it works extremely nicely no one else
seems to talk about cichlid our
conference I have absolutely no idea why
because it's such a great tool it's 40
years old or even older and it still
works very nicely it works much better
than ever before because optimizers are
really really good today they do all of
these things and tons of other things
now everyone in the room asked kind of
write sequel in Java that's the big
question because writing Java most of
the time so yes there's an answer from
me you can write sequin gel using joke
for instance right so joke allows you
finally to write types it's equal in
Java little advertisement here so every
object in Luke is a table or a column in
sequel and then you have the types of
sequel a v8 if you are
type checks your security and if that
type save resulted back and the way you
feel about you will feel about writing
Seco in Java as well this is how you
feel or this okay so you're perfect so
what's the key takeaway and the from
this talk can you do it in the database
right yes you can because equals Turing
completes that's a part of the other
talk that you should definitely look up
look up on Google sequel tricks
ten Seco trick you will see sequel
turing completeness this means you can
write anything in sequel perfect can you
do it in the database yes after you
watch the other talk you will see all
the tricks you know everything about
cycle and if you don't feel comfortable
enough with the with the other talk it
can visit by a 2-day sequel training
where I split everything very slowly
from both talks so you get a really nice
deep dive into the sequel language can
you do it in your database yes most of
these features that are displaying these
talks is Kiko standard so you can do all
sorts of calculations like the recursive
query that we seem to calculate the
Mandelbrot set it's a single standard
query you can easily calculate that in
any database unless you're using my
sequel my sequel is quite behind all the
others although my sequel AIDS will
catch up and deployment window functions
to calculate running total recursive
Seco as well so my sequel eight is quite
promising looking forward to that
should use it should you do it in the
database that of course you should do it
in the database yes absolutely the
database is the perfect place to put
this logic because we've seen sequel is
a logic programming language it's a
declarative programming language and
it's what are the best languages to
implement such business logic right so
we've seen with super productive to long
titles or from a talk attract attention
this title is super long it's incredibly
long and still you have all the
attention you had high expectations they
were fulfilled so yes this also works
will this talk ever end also yes
if you remark google team secret trick
and finding a target ask it will love it
as well thank you very much
so we have created this one yeah
can you any questions to the room any
questions from see only Joe well I think
we have a comment here
so these coming for from cartons
wage something well so if you assume
that we all agree with you yeah are you
suggest
are you suggesting that we just query be
directly or how it is integrated into
the standard we have crew that so the
question is arm to be right to the DVD
directly with sequel is that a question
instead of the APA yeah let me just
should you just square it divde and how
do you integrate these with the standard
web crude app so basically people are
talking about those dashboards that
business loved so much instead of crud
yeah okay I told you only half of the
story right I told you to also listen to
laugh the other cycle guide and talk to
Java conferences so there are two topics
on Seco one is writing and the other one
is reading I only talk to you about
reading today right the reading is
really the domain of the sequel language
when it comes to writing when you write
the database there are two types of
writing there's ETL jobs and data load
jobs and these kind of thing batch jobs
or you still use eco and if you write
current applications you're probably
better off using some ORM or active
record or something else that helps you
write that sequel because they don't
want to write insert select updates the
delete all the time right so there's a
two parts of the story that's the best
parts of both world today I talked to
you about sequel and I definitely think
you should write equal directly writing
is a different story okay yeah and no
one was pretty much sign it
yeah any any other questions room anyone
for any questions no ok so Lucas thank
you very much for your session awesome
sessions normal and I think I do believe
V or
your other session may the 10 tips and
tricks' is as you in the video as well
as your website so so feel free to go to
either and and thank you very much on
Twitter you are just Lucas error right
lÃº kÃ¨ oh there it is Lee KS Elysee
feel free to type in Lucas with any
other questions online and you very much
cheers Lucas thank you guys and thanks
everyone here</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>