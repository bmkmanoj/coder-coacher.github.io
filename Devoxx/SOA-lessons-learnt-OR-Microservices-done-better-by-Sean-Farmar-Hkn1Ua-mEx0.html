<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>SOA lessons learnt OR Microservices done better by Sean Farmar | Coder Coacher - Coaching Coders</title><meta content="SOA lessons learnt OR Microservices done better by Sean Farmar - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>SOA lessons learnt OR Microservices done better by Sean Farmar</b></h2><h5 class="post__date">2017-08-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Hkn1Ua-mEx0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi there my name's Shawn farmer and I'm
a solution architect in particular
software um I've been doing
service-oriented architecture and what's
now called micro services disability
systems an answer is best for the last
kind of ten years roughly two thousand
seven eight I started doing that today I
in the last four years I've worked for a
particular software and I'm doing
working with customers around training
consulting and supporting them building
disparate systems um I see that there's
a st. Patrick's celebrations even here
in Vienna I'm from Ireland I am
originally from Israel moved to Ireland
thirteen years ago and my wife's Irish
my parents are Irish so when I feel very
proud to have have seen you know this
kind of celebration even here the other
side of the world um any Irish here no
I'm just just checking my own yeah so
today's talk is is more about trying to
teach or kind of show what what we
learned with service oriented active
architecture all our failures and how
hard it was to get to a point where we
were able to successfully build disputed
systems and get a really good design in
place and now we have this kind of new
fad which is the micro services and it's
catching out like fire isn't it anybody
here do micro services yeah good portion
with you guys doing micro services so
everybody's on the bandwagon and the
only troubling thing I see with
micro-services is that we've done the
whole saw our deserted systems for many
years now and the whole micro-services
movement seems to forget everything we
learned it's very common in in in
software development in our in our
business that we just seem to forget
what other people have already learned
and forgot to forget and so I'm hoping
that the little view to get out of this
talk is just not just to avoid those
those horrible pitfalls and those
struggles that that I I went through
until I was able to build a good system
and don't get me wrong I love the micro
services idea I have not nothing against
not preaching against microservices or
anything like that but I think that they
could be done better if we learn from
the from past mistakes so I I've started
doing this sort of thing quite quite
some time about 10 years ago but I've
been developing for 20 odd years now 23
or something like that and before I came
to so I started as probably most of you
have you know building this those
business systems whether it's e-commerce
or internal business systems and you
come into a new project or a failing
project one of the two it's always one
of the those kind of things and if
you're really lucky you get the
opportunity to build a greenfield
project and I you know I kind of learned
the business and then go about you know
pick up my Tiger team or be part of the
targeting and build this say you know
all new shiny clean well-designed
well-thought-out architecture that's
gonna last forever right and I build you
know using all the best practices that
Microsoft and other
have provided and we put it into
production everything's really great
yeah
targeting moves on three months later
six months later the business succeeds
or the application is successful the
business grows there is something you
know some feature requests some some
changes and either the target team or
the next team after that the maintenance
team poor little buggers are there you
know to pick up the slack and start
modifying your beautiful design and a
year and a half later you find a huge
big ball of mud that you know totally
doesn't resemble your beautiful design
it just gone out the window and although
all the best practices will adhere to we
we come into this point where we get
loads of performance issues we get
bottlenecks the nightly jobs run over
the 24 hour segment you know like we
can't find a plan a time to run the the
bad jobs because there's just not no
more scale to do everything is really
really hard to change anything you know
any pull request that comes in from a
from the business all of a sudden all
developers disappear right they're
really busy doing this other thing I
just have this bug to fix over there I'm
really I'm sick I don't know I'm not
going to touch this code you just look
at the code and start vomiting right you
just go like now I and the business also
gets into this very edgy nervous thing
yeah they go if we do another change
request now we're gonna suffer it's
gonna cost us you know all the
development team is going to go into
crisis mode we're going to deploy it
into production and fix it and stabilize
it and fix it and stabilize it and then
six months later it's gonna be alright
yeah we done affixes and then we go
through that cycle again and again and
again anybody been there is it far away
yeah yeah we all been there this is a
this is what I've been experiencing and
I've been doing this for many times it's
not one time you know you say oh I did
this couple of stupid mistakes in this
project
won't make it again in the next project
right I have done it a couple of times
and in big you know small and big
projects and I felt you know I'm going
mad right and I'm doing everything right
I'm trying to do my best and I'm failing
constantly now of course it's it runs
it's in production but it's a failure
yeah at the end of the day and you know
Einstein said you know somebody who
tries to do something again again and
expect different results what is he he's
an idiot toys crazy right one of the two
and I felt exactly
I actually I felt both yeah so the last
my last attempt actually reminds me very
much of of what Mike servers are doing
today and that is like I I took a whole
architecture and split it to multiple
webs you know multiple applications
communicating with each other multiple
monoliths communicating with each other
over web services anybody tried that you
successful yeah okay it's very
interesting because that's very close to
the kind of micro services paradigm I
did that and I failed miserably even
like things were even worse than what I
thought it would they were way with the
monolith because in Amana days it was
like oh yeah I have a bug I I go fix
that bug you know that that's done right
it's like I can kind of cope with that
when the application fails again or the
system fails again I can look at it and
say oh yeah that's this component on
this server in this module it's I just
need to fix that thing I do a quick
patch everything's fine all right but
with with five applications talking to
each other with web services when things
started going south it was you know you
you never knew where it started who is
the cause and it was a self denial
attack yeah like I was my own
application was denying its own service
because once one one component failed it
started you know being slow or just
failing then the calling service was
also failing then the
the thing that's called the calling
services also well also failing and you
know slowly slowly we saw everything
just collapse and now you had to figure
out in the distributed system what's
going on right where is the problem
right so it was really really frustrated
and really I was actually thinking or
just you know maybe put the you know
call it today let's let's let's go back
I was an engineer for twenty twelve
years let's let's do sound engineering
it's much nicer so I went to my master
and I said master master what is going
on I'm doing everything right I'm trying
to do everything I we were using all the
new frameworks and all the new features
and all the new ideas and paradigms and
best practices and horrible work best
practice and and I'm failing so in his
in Yoda voice he said you know solve the
problem you want coupling your problem
is now that makes a lot of sense right
coupling is what kind of every time we
try to touch something and every
everything else breaks that is because
everything's coupled to each other right
is this dependencies there's things
going calling each other you know
components calling each other and if
something changes over there the other
thing will be affected and when we try
and separate stuff then we get to this
point where we go off if I if I'm taking
this little component or module and
trying to put it over there I'm gonna
pull all this other site with me right
it's all going to come with me so where
do I where do I start cutting and if I
start cutting and watching I find that I
have huge dependencies between these
different components and I end up with
this big ball of mud in small bit small
bits and that that really doesn't help
ma'am so I said you know that's great
it's just the couple of things right so
just go right just throw everything away
and and start cutting in and and it
really didn't work every time I try to
pull something out and make it loosely
coupled or
you know autonomous in any way I felt
that I'm pulling a lot of stuff together
you know I'm pulling loads of things
that were already well you know kind of
encapsulated and all that now when I try
to pull them out they break other things
it was really really hard to kind of
find a way around it so let's look at
coupling and just to try and understand
what coupling actually is so they're
about five or six dimensions of of
coupling that that we can look at and
afferent and efferent I never get it
right so afferent is the stuff that
depends on you anything that kind of
coup is using you as a resource or
calling you to get something or calling
you to do something they depend on you
because without a if you go down if
there's a bug in your code in your
component then you break them and
afferent is what depends on you stuff
that if if that you need in order to
complete your your functions and could
be third parties could be and just
another component you calling to
complete some work and the other
dimensions that we need to look at by
the way over here there's no magic
number yeah there's no there's no zero
coupling ever you're never gonna get to
a point where you know if there's zero
coupling you're building an application
you know like Word Excel you know you're
not building a system right if if you're
looking in you know to a magic number
you know 2 &amp;amp; 5 5 of 5 3 &amp;amp; 2 there is no
magic number the the point is to get you
know to a loose is loose coupled as
possible
right then the if we're looking at other
dimensions that are very clear to us we
look at temporal time based stuff
spatial which is like space where things
are located you know which servers are
in which zones on the network and so on
and
platform so in temporal and if you take
anything from this talk take the
temporal coupling okay temporal coupling
is classic yeah this is a anybody
doesn't use Facebook here doesn't all of
you don't you don't do Facebook don't do
Facebook somebody we all do Facebook
right and and when we want to you know
when we become friends with somebody
then we are time bound to their their
actions right every time they do
something we get a notification that
they've done something right
em so time-based coupling is something
that is related to how long does it take
for the other party to acknowledge or
reply to your request so every time you
call a web service the time that it
takes to - for that component to reply
that would be or your your coupling time
okay even if it's a logical one yeah so
even if you you make that call
synchronously and you're now bound
you're now sitting there you are unable
to do other work while you're waiting
for the reply of the response from that
a component that is your time bound
you're bound to that to that other
component synchronous communication is
like I need to get some data from
database I need to get the data from a
web service form a third party anything
that's IO bound and not CPU bound a
memory bound is you know is something
that will take time something that is
gonna is gonna make a coupling a greater
and in addition to that every time we
start a synchronous communication we are
that thread is going to sit there and
wait for the response okay so if the
other component is down we either
explode or we just sit there and wait
for this thing to reply
okay the logical temporal coupling is
all about what I said earlier you know
if you're just sitting there and waiting
and not able to respond to your initial
requests because you're waiting for this
other thing to come back so even if it's
structurally or technically sound you're
not getting a reply and you're okay with
it you not explode you know you don't
throw an exception or or your your
thread goes down you still sitting there
waiting to complete your job I will talk
about that a little bit later especially
is more about physical where do we put
stuff where's the end point you know the
endpoint address or sequel you know
where a sequel server anybody still
doing or done before this you know put
my sequel string connection string
inside the code we do that today
anybody now we're all angels aren't we
Saints so I did it when when I started
coding that was you know very common and
was smaller things and we did it and
then I learned that it's really really
bad so special is all about you know
where you put your very deploy or your
thing on the network how close it is to
the network that kind of would change
your your performance it will change you
know if if the admin decides to move
your sequel server for one IP address to
another and Eve used an IP address then
you're basically lost your database
right now and a protocol a platform is
all about protocols and platform
specific features anybody did not doubt
that remoting here for example know your
java people aren't you yeah so Java Java
specific stuff is like what you call DTC
in Java this visit transaction
management in Java okay
so that's the kind of stuff yeah stuff
that is that is a that you can't use
Java and.net together to do the same
kind of operation you're you're gonna be
calling a using a specific protocol it
has to be you know windows - windows
Java Java but they can't mix so all
these things that have to do with
coupling when you go to do to distribute
stuff even if you have a monolith and
you're communicating with third party
this is already like kind of distributed
systems right the beginning of that how
many of you do this nobody calls service
you not reusing third parties to do your
payments - yep sorry you don't do this
anymore you do dependency injection
right let's say that's even yeah so when
we do this thing our expectation here is
that the result is going to give us some
data right the best case scenario is we
do we we couple that we put that around
we put a try-catch around that yeah
agreed
fine to do try-catch here what happens
when the the catch happens when the
exception is thrown and we what do we do
it when we do the catch thing yeah it
depends yeah
we log it yeah okay so usually we log
that there was an exception or we bubble
up the exception to an exception manager
or something but the data the stuff that
we just passed to invoke the service
with is all gone right anybody tried
here to save the data before they call
the web service yeah one or two it's
very good
but most for most cases we assume that
the service is there when you write the
code the service is there we don't think
that the service is going to fail right
and that's why we're going to talk about
the fallacies of this video computing
the that those fallacies are very very
old yeah they're like I think they come
back from 94 or something like that and
it's written by Gosling James Gosling
and a couple of guys from Sun
Microsystems back back in the day when
Sun Microsystems were not doing Java so
much they were doing networks they were
building Network stuff and he came up
with those a couple of fallacies of this
that he kind of identified that we as
developers and architects look at at
approach out of design and ignore all
those fallacies yeah we act as if those
fallacies are true Network is reliable
and can ask Amazon Google about that one
latency zero the bandwidth is infinity
yet there's no problem just more and
more data of the network the network is
secure of course
topology doesn't change this there's
only one administrator so you know when
the administrator is gone then nothing's
gonna work and of course the
administrators will be always there we
never think about the risk of the
administrator and winning the lottery
was something else a transport code is
cost is zero and the network is
homogeneous and all these if you look at
all these these these fallacies you and
and go back to your code or your
architecture and look at it you see that
that those are those assumptions are
valid we never look you know we never
look at how much data we pick up or what
what happens when the network's down we
don't mitigate for network outages we
just go try catch and if it's not there
the client will try again I don't care
you know I'm you know if it's a million
dollars and just went that's fine that's
cool there's no problem with that right
and I'm not diving deep into this those
topics because I'll give you this link
here and you can download an e-book that
has you know the whole story really nice
well-written and it has the whole
stories the mitigations and and a lot in
a lot more details and depth they also
look at the ted nerds blog about the
fallacies which is really really nice a
really good blog and I'll I'll let you
take another picture at the end so why
did we start off building macro services
and Microsoft's is started kind of five
years ago roughly and it started because
people were tired of having the the
monolith break on them the scale thing
you know the you remember the MongoDB
scale thing that ran in the internet for
ages ya know anyway the scale thing came
in and everybody was trying to be
skillful to get scale to be able to
operate at scale to build big big
systems with loads of data and loads of
customers and be highly available and
all that and that was really really hard
the big the big the Giants were were
running that okay you know Google and
Amazon they had different approaches all
around but nobody on a small scale was
able to actually to access it was too
much overhead to build to emulate this
kind of architecture so Microsoft is
came along and said oh you know it's not
a problem just build those little you
know break down the monolith and build
little islands of functionality and
expose them and deploy them and then run
your business on top of that and
everything is going to be cool in the
regular monolith design or architecture
of course this is a very lightweight
representation of an interior design of
a monolith this is the kind of thing
that we we have we have like a UI a
business layer
they were a success layer and then a
database beyond that that everybody
talks to everything is singular yeah we
have one one database one layer for that
one layer for that one line for the
other of course on the side here you'd
see all kind of you know common services
common frameworks and between those
layers you might have layers and of all
kind of service layers that make it look
really cool right and and but at the end
of the day all this is like tightly
tightly coupled on the horizontal yeah
so the you I would be very coupled along
it's dead you know along the layers and
so so on and so forth but and very
loosely coupled on the vertical
excellent it's you know it's gonna be
little they're going to be little
communication between those layers at
least by design right when we start
building the system and then maintaining
it which is more important then people
start you know how do i how can we say
you know bypass the design yeah they
bypass the layers because it's all of a
sudden really really hard to talk from
the UI to the business layer to the doll
and to the database why not just put
some business logic in the UI that's so
simple right we have all these magic
frameworks that build all these things
on the UI so all some leakage go from
the business logic up to the UI or the
other way around
hey why do we need the UI at all let's
just do all the business logic in the
database stop seizures yeah bad jobs all
the lovely things that sequel you know
can do and absolutely it can do it could
do it very well but still you put in
database it's hidden away from everyone
and once you try to change that behavior
god help you
and so basically as we as we go from v1
to v2 to v3 or 1.11
point four point five we end up with
this this thing this big ball of Mad
everything talks to everything there is
no clear understanding of what what is
there and usually the the maintenance
developers that come along after the the
first nice versions will actually bypass
the whole thing right have you done this
before he looked at the thousands of
lines of code and gonna I'm not gonna do
that I'm gonna take this a new new bit
of functionality I need to do just write
a little class over there that's gonna
bypass this whole mess and I'm gonna do
it my way and I'm gonna jump from you
know directly from the UI to database
which is I've seen nothing wrong with
that but just the side effects from
doing those kind of patches are
interesting so instead and this is very
much part of what the kind of the the
micro services and so that's where they
share the the paradigm is that when we
go to to build scale stuff instead of a
you know instead of having tight
coupling here we have tight coupling on
the vertical and we reduce the the width
or reduce the amount of stuff that's
being done on the vertical slice in
order to make it really easy or much
more much easier to to create to achieve
loose coupling
and of course when you look at the
different kind of components and and
they each component is isolated it goes
and provides all the functionality top
to bottom and mind the gap yeah make
sure when you look at those kind of
systems never forget the database any
resource whatsoever
it should not be shared yeah but the
database around reads is okay to share
maybe maybe depending on where your data
is and how you did you
your architecture but the rights should
not be shared at all right and if if you
take the second point to take from this
presentation is do not share your data
yeah
and doesn't mean you know Reid is all
right Reid is it's a totally different
thing rights are what's important there
should be only one owner of this piece
of data in the whole app I'm sorry in
the whole system and the reason for that
is that if we start sharing the data
what are we doing where we're creating
we're introduced reintroducing coupling
right we're saying like oh yeah
actually you know when I need the CRM
needs to do an invoice I'm actually
gonna update the the customer record to
say that I sent him an invoice right so
why should I send you know send a
message over to to the customer customer
service to let it know that no no I'll
just update the data directly right
that's where the fun starts yeah so when
you do vertical slicing remember to
never ever share your data when you want
to do reads you can do publish reads you
can do caching all kind of funky stuff
you know have a nai whatever to build
you know business logic to build some
you know reporting model some something
that allows other people to share the
data in order for them to read it but
don't ever share your write data so when
we look at the definition of
service-oriented architecture and I
don't think it's that far away from a
microservices is that we're trying to
address the coupling in a software
design by building loosely coupled
highly encapsulated components and woody
de hann is I'm quoting with the de Haan
here it's not my anybody know woody done
her
a couple of you look him up he's
interesting um the the point is here is
about loosely coupled and highly
encapsulated components and highly
encapsulated components is very much
like the coming from the object-oriented
kind of methodology or paradigm yeah so
in object orientation we say that we
want to encapsulate our business logic
and we want to hide our behaviors and
not be and only enable the outside world
to use it without knowing what we are
actually doing inside yeah we keep it
encapsulated we do whatever we want to
do inside our component and not allow
anyone else to change our behavior or in
or forcibly cause us to do something we
don't want to do okay does that make
sense and we create autonomy here okay
and so encapsulation is all about
autonomy is about I ran in my own
context I can do all my stuff by myself
I don't need anyone around me I'm not
dependent on anyone else to do my
business you know what the function of
my business okay as we go around to
achieve autonomy we need to decompose
our business entities into into kind of
components that are they they are a
definition of what we do those
components are as day as we decompose
them they can provide business value
they can do something that we can
explicitly say this is what this
component is doing it's not doing
anything else it's doing this very well
defined the business ability or business
capability and the important thing here
is that we when we come to decompose
this thing
we walk away from the monolith
well-designed database
you know the database a concept where
everything is linked to everything yeah
where we go and build like this huge
sequel tables with a referential
integrity that you know everything is
linked to everything so we have a user
and the user as a you know a link or a
reference to orders and orders have a
reference to items and items have
reference to products and so on and so
forth and although all this kind of
beautiful schema that looks really well
to you know to try and it and explain
something to a business person that's
great in in the real life if we
introduced those huge entities and try
to get them to work together then we
come back to problem number one coupling
because if one field in my database in
my table changes then that means that I
need to update some other table right
and that means that everything is kind
of coupled everything depends on
something else and if it's a big table a
big user table for example or a big
product table or big any any any table
that has a multiple fields and in
different fields interact with different
components with different business
concerns that means that we are back in
square one we're back to having it a
table that like a coupling between our
data in our data resource which means
that we can't do an operation without
affecting other components okay so
instead of looking at it in the
beautiful schema of having loads of
dependencies between different tables we
take we carve out the tables the
properties that interact with each other
put them into a single bounded context
you know carving out the single bounded
context and putting them into a single
table right and that single table then
would belong to a single component does
that make sense and then when we
interact you know no no other component
is trying to access that data that data
is mine
I am the the owner of that data as that
component so I can encapsulate my my my
data and my logic from other components
and do my own thing without having any
effects from other components is that
make sense and bounded context inside
the bounded context you can have high
coupling there is nothing you know
stopping you from having you know inside
the the thing that you're doing all this
business activity that you're doing if
there is hi you're expecting it to have
high coupling because you're expecting
all these these these things to happen
in one logical transaction okay it
doesn't have to be physical doesn't have
to be acid in that way but it has to be
this you know this component does
everything in in kind of one go if you
wish yeah so if I want to create an
order I need to do three things maybe
those three things might be a bounded
context because I if I don't do those
three things together that doesn't
really work right I can't say that I
successfully created an order or created
the user or created an account okay what
that leads to is having a very very very
fragmented database right
very very fragmented components a very
fragmented design you you you're gonna
end up with loads of little things all
around you from a design perspective
it's another thing that that we all do
probably very well but we generalize we
generalize stuff all the time that's how
we taught to build right if we have a
method that you know the crude operation
kind of thing yeah crud do you do crud
yeah crud is the most general generic
thing you can do right what
what does it do it says create me
something this entity
update me something delete me something
and read me something right it is
totally generic there's nothing there's
no business activity there there's
nothing that describes what you are
actually trying to do the day the
example I could take is like okay update
user does anybody know what an update
user does do anybody here has an update
user it knows what it's doing it is
physically can update some fields in an
entity right what do you do when you
want to try and figure out what happened
what do you need to do you look at the
source code you do use try and
investigate the data right what's coming
what came in what field changed in this
update right yeah and then you go oh
actually this phone did this guy this
app they just changed the phone number
all right now I have to do if else cases
factories whatever to kind of go oh this
is the event that I want to raise I want
to raise a phone number changed event
right when I say oh this is this is what
actually happened can you imagine how
when you have a rich business entity
like a user and you're going like oh I'm
gonna have like this method that's gonna
do of course it's gonna be injected and
it's gonna have factories and all that
not going to look that dirty but
effectively every time an update comes
in I'm gonna figure out what I need to
do right because otherwise it's just an
updating it means nothing it has no
merit and it could be any of the twenty
fields that you have in this table so
instead of generalizing take the pain
and go create a method and a and eto or
DT whatever dial or however you're going
to get this into the database that does
only one thing if I want to change a
mobile phone I'm gonna say you know
change user mobile phone and be explicit
about it name the method correctly pass
very little arguments and
in the data that you need to again as a
small amount of data to make that a debt
operation explicit when they you're your
coder you know another coder looks at
the code there's no arguments here
you're updating the users mobile number
if you want to raise an event than to
say oh I've some you know other bits of
the system we want to know that I've
changed the users bank account or the
users mobile number you raise an event
and the other the other components will
know what to do because it's very simple
for them to know that the event is not
update user it is I've just changed
mobile phone for that user or I'll
change the bank account coming out of
that again is SRP so anybody does single
responsibility here can you vouch for
that should I look at your code it's say
it's really really important to stick to
that thing where you go I'm doing one
thing in this method and then I'm
passing the responsibility not calling
another method to do another thing and
calling another method to do another
thing and calling but just go I'm doing
this I'm done when I'm done I can erase
and send a message over there but when
I'm done I'm done I don't I'm not doing
other things also when you come to
maintain those simple small explicit
single responsibility items it is easy
to to get this across to fix it or to
make an it to create a new behavior
another one is that when you have
smaller items smaller things it's much
easier to fix them it's much easier to
know how much side effects you're going
to get from those small things okay
and keep your verticals thin top to
bottom is all about don't start at the
top with very small thing and as you go
down the chain start expanding your you
know the first thing is just update
mobile phone then you're gonna call
another message it's gonna create mobile
phone and add some logic to what have
when debt and then another one that
there's that that does another bit of
logic but it's much more stuff and at
the bottom you're gonna update a huge
table that's gonna do all kind of funky
stuff yeah so keep your your slices
vertical all the way don't let them grow
arms and legs and don't pull the kitchen
sink with you so lessons learned from
what we did is first it's hard it's a
lot harder the the you know the the
productive side of it when you start
doing these fitted systems or Microsoft
so it is much harder yeah it's much
harder to to get started and to get like
the infrastructure right the design
right to get this is the the much bigger
learning curve however is as opposed to
what what happens in a monolith you
plateau at some stage yeah you get to
this point where you have a good design
and then you can plateau the maintenance
the the extensions all that is the
effort is relatively stays the same one
of the biggest things that that I want
you to the third thing that I want you
to remember here is that you should use
a synchronous non non non synchronous
communication between your different
components okay so I see a lot people a
lot of people doing are you know micro
services with restful interfaces yeah
and we have like this micro service is
calling this our this micro service in
order for it to do its job it needs it's
the the other micro service data
it sounds really logical it sounds okay
but that comes back to them to that
distributed web service thing that that
I failed with once you introduced
synchronous communication it means that
this other component you're depending on
it right that means is leakage in your
and how you split your your
your your domain or your business
components so that dependency that
synchronous communication is gonna kill
you someday maybe not today it's gonna
kill you it means that you're depending
on another thing and that kind of goes
against the whole idea of micro services
right it's the whole idea of breaking
them apart making them small units of
autonomous work so we can build a
reliable system that that is not you
know and change those little components
without having effect side effects on
the rest system that you know if you use
synchronous communication you just
killed everything it doesn't matter how
it's nice and cool and has all the fancy
frameworks and all that and if it's in
containers and not containers and you
know just don't so use queueing systems
whatever they are if you're you know if
you have a JMS or a rabbit or whatever
using use durable queueing mechanisms
they will you know that kind of
communication allows you to very nicely
maintain durability and continue to
function when the others the other
component whatever it is is dead right
and it will die and when you have 150
200 microservices or 300 or 800 they
will fail one of them will fail some
some could you know the network is going
to go down a segment of not a quiz go
down something's going to happen and
you're not gonna have the communication
to do the synchronous communication when
you want to communicate between bounded
contexts or between components that are
between autonomous components use events
use pop-ups that publish/subscribe heard
about the pop pops up publish subscribe
yeah very easy nice it enables you to go
around not worrying about what you're
gonna do you raise an event the other
systems will do their job based on the
event that you propagated and another
point coming back to say
a point I raised before is use CQ s
command query separation anybody heard
about CQ s not secure as CQ s yeah it's
very old it's not a new concept at all
the idea is that you separate the change
stating operations from the read
operations and change stating operations
do not return data okay they just go 200
this is where I got it you're not
waiting to get data you send the command
the command does its thing again a
synchronous that's great you could just
send a command over there make sure you
know all you need to make sure is that
the communication that part's saving
that message on to the queue was
successful you're done the read
operations could be anywhere right you
could do caching you could do a lot of
technical solutions to get reads from
anywhere yes there's the whole thing of
an eventual consistency and all that I'm
not gonna get into that but it is doable
there is way ways around it it's very
important to kind of get we usually you
know we get data hammer and everything
is a nail around us right once we have
this new shiny framework or this new
shiny system we just go around saying oh
yeah that that you know we can hit that
with that we can hit that nail with that
we can finish that we can do that and we
try to do everything you know no sequel
so everything is no sequel you know
messaging so everything is messaging if
you do messaging for request/response
you're screwed right so if you need to
call a web service and get immediate
response and it's all our PC it's all
like synchronous communication don't put
messaging in the middle that doesn't
make sense right but it makes sense
where it makes sense use messaging which
doesn't make sense
use your app receipt but know the risks
understand you know remember the
fallacies decomposing your business
entities is the hardest thing ever every
time you think you got it right somebody
comes from businesses but I want to do
this like that and you go oh man
where do I find the boundaries of my
data where is the bounded context how do
I keep this bounded context it is hard
and you know as I said before no
frameworks or tools will automatically
you know fix your problem it's not about
technology it's not about you know
technical solutions it's about
understanding your business and and
putting the business first and making
sure that the business functions and
that you dare you look at the business
as what it is and kind of decompose the
domain affect accordingly so I said that
data right and ownerships referential
integrity in goods again if you're using
referential integrity and you're putting
Microsoft's on top of it you're just
killing yourself
yeah and data reads an eventual
consistency is a whole new whole topic
monitoring remember if you're
distributing monitoring is your friend
without monitoring you're driving in the
dark without the lights on yeah you're
just driving 100 100 miles an hour with
the with the lights off and you're
thinking that you're not gonna hit the
wall right very optimistic testing is
extremely hard and when it comes to
deployment and you probably know all
about that automate everything
everything should be automated from day
one the more you automate the less
issues you have in in building stuff
later the easier it is to scale the
easiest is to scale out and the there's
a less human factor in there
don't forget your organization you know
I know you're a great developer or
architect if you can't sell it to the
organization if you can't work with with
the teams to sell the fire time you're
gonna you're gonna you know you're gonna
fail badly and be pragmatic don't always
go and do a whole thing system
architecture thing when you only need to
solve a little problem over there but
keep the paradigm make sure that you
remember why you're doing this
it's first place and build the assist
your business and not systems a lot of
us really love to build this you know
beautiful architecture system thing and
we forget all about business and then
you know at the end of day the
businesses are paying our our bills
they're there why we exist that's why we
do one of the nicest jobs in in the
world that I know anyway so I'm hoping
that I'm kind of running out of time I
think roughly and so this is my kind of
summary if you're on the dotnet platform
check out and service bus and we don't
have time for Q&amp;amp;A but please come come
I'll be outside if you have any
questions any any arguments be very
happy to to chat thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>