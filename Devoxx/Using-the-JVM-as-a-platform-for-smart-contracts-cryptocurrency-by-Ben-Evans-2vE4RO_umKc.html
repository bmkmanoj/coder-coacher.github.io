<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Using the JVM as a platform for smart contracts &amp; cryptocurrency by Ben Evans | Coder Coacher - Coaching Coders</title><meta content="Using the JVM as a platform for smart contracts &amp; cryptocurrency by Ben Evans - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Using the JVM as a platform for smart contracts &amp; cryptocurrency by Ben Evans</b></h2><h5 class="post__date">2017-05-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2vE4RO_umKc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">where again you play kid do it make sure
okay
is everybody having a good Friday
afternoon at devoxx
excellent um hands up if you already
know a fair amount about cryptocurrency
or describe yourself as an expert one
person okay that's good
don't kill me for anything I'm about to
say beat me up in the bar afterwards
okay so this talk is called building
smart contracts on the JVM and its
really the result of some research that
I did last summer for a company called
r3 so there's a bunch of links at the
end which explain where to get more
material there's a lot in here and I've
only got 15 minutes so I'm probably
going to talk quite quickly so I'm Ben
Evans and I'm I've done a bunch of stuff
in the community Java champion I serve
on the Java community process Executive
Committee just the body which determines
new Java standards you might have seen
some stuff in the tech press about Java
9 modules yeah that's been occupying a
lot of my time lately
so if you want to know about that at the
end come and see me career-wise I've
spent most of my time in banks I founded
a startup called Jay clarity I was chief
architects listed derivatives at
Deutsche Bank and before that Morgan
Stanley so I've seen quite a few
financial systems and I'm interested in
cryptocurrency really from both the
technical and from the financial point
of view I don't think necessarily that
they're going to be the thing which
which changes the finance system as we
know it but there is certainly some
fascinating computer science aspects in
there and that's kind of how I got
involved in this project so what are we
going to talk about today well we will
talk about cryptocurrencies briefly
because some background and the primer
is needed but it's the computer science
aspects that I I really want to focus on
then I'll talk about the JVM and how
that fits into the picture and why is it
the JVM might be a good platform for
building cryptocurrencies on and why it
might be a bad platform as well as you
probably won't be surprised to discover
I eventually concluded that it actually
was a good place for a quick
season smart contracts so after that I
shall go deeper into the technical work
we are going to see some byte code we
are going to look at class loading and
the kind of the bottom two bullet points
here really what the whole talk is
building towards I'm actually going to
talk about provably deterministic
execution programs that will not run if
they are not deterministic that's
ultimately where we're going to end up
and probably some of you are thinking
hold on a minute
I do the computer science degree what
about the halting problem well hold
those questions at the end please
because we are at right on time okay so
let's go first of all let's talk about
cryptocurrencies and let's also talk
about some computer science along the
way so the best known of all
cryptocurrencies of course the fantastic
Bitcoin which everyone knows all about
partially because of its a high profile
role in in ransomware scams drug
giggling and other forms of illicit
activity and if you're a student of
human folly as I very much am Bitcoin is
is very attractive because you can see
the absolute best of worse of humanity
often side by side if you if you spend
any time lurking in there in a Bitcoin
community ultimately what it's what it's
supposed to be is is a digital form of
cash and that's quite interesting
because if we think about what
properties cash has and what properties
therefore that we would want online cash
or digital cash to have we might end up
with a list which looks something like
this because physical cash has all of
these attributes you can't duplicate it
but if I spend a ten-pound no I can't
you know create another one which of
course for digital patterns of bits is
trivial to do so that the lack of
big-big of not being able to duplicate
it immediately indicates that whatever
form digital cash takes it's not a
pattern of bits it has to be something
else what else would we want cash to
have well cash is anonymous if I go to a
barn buy beer I don't need to know who
the barman is and he doesn't leak
knowing who I am
guys pay with cash and there's really no
record of the transaction a Bitcoin
doesn't really do that it's really you
animus rather than anonymous but that
that distinction would probably take us
to far afield for for 50 minutes but we
would kind of want a level of anonymity
to be associated with our cash it should
be fundable and liquid by which I mean
it should be exchangeable for any form
of goods and services and it should be
readily accepted if it's network base
then the network has to be full tolerant
this stuff has to work it's been going
to be used for transactions where
essentially all of human behavior so the
network had better work and transactions
potentially even at a distance between
parties that don't know each other and
who may not trust each other that's
that's also an interesting problem to
solve the the trust lessness if you if
you like if the network is would also be
important and finally the network should
be unable to prevent anyone from using
it and that's that's kind of an
interesting point as well because having
read this list
there's something which might not ever
have occurred to you cache has these
properties but your debit card doesn't
your debit card has precisely
none of these properties and what's
actually happened is that we already
have a dual financial system we have the
financial system which is represented by
cash as these properties and we have the
banking system which is actually a
private network and all that happens is
that the units of currency which are
used in the private banking Network
happen to be the same as those of cash
and at the end of each day all banks
essentially Tahlia who owes what to whom
and perform a you know a large
settlement between each other as to
where the the actual real money the cash
should be should be move around - so
we're already using a system which is
like digital money and and so much so in
fact that most of us have who haven't
stopped think about this might have
confused it for being the same as the
actual actual cash that we have in our
our pockets but they are in fact very
different things so let's move on let's
let's look at term up
what crypto might be able to do to help
us and Bitcoin basically manages to
solve you know a surprising number of
these of these problems the Bitcoin
approach is is that it's resistance
double spending it does have a measure
of anonymity although you know as the
saying goes if your threat model
includes the NSA or the Mossad you have
bigger problems I am perfectly sure that
the NSA either knows or could find out
if they chose to
who owns every single Bitcoin on the
planet but the the network itself is at
least pseudonymous there's an
interesting paper released a few months
ago where someone that did an analysis
of the Bitcoin ledger and was able to
map about a sixth of all bitcoins in
existence to either an email address or
to a user name on a social media network
which is kind of scary because for
something that's supposed to be
anonymous and largely used for illicit
stuff you know a simple network analysis
leading to to one-sixth of the ownership
being revealed is fairly bad fairly bad
floor anyhow
so so that's one of the reasons why I
use the word pseudonym us rather than
anonymous and Bitcoin is is of course
trustless as well and this quote by by
rich Kendall Brown I think is some is
quite telling it's it's about
transferring value at a distance without
a central third party I mean it's it's a
slightly flawed a quote I can see a
couple of things that are wrong with it
or I could nitpick about but it broadly
gives us the sense of what bitcoin has
managed to to achieve okay so that's
that's the background of our of our
crypto currencies
there could be science aspects of crypto
and of a Bitcoin of really what
interests me and there are really four
pieces of separate and interesting
computer science that are buried just
beneath the surface of cryptocurrencies
there's hashing and it's used in
producing the the chain of transaction
blocks the dreaded blockchain that we've
heard so much about in the in height
phase of the tech press
there's also the what's called the
Byzantine generals problem this
basically is how do you reconcile the
fact that your network may have bad
actors in it
another classic computer science problem
the names of so many greats of computer
science Leslie Lamport
Barbara Liskov and so many others are
attached to the Byzantine generals
problem and for those of you who are
students or aficionados a computing
history studying that the history of
just that single problem will show you a
great deal about thee about the history
of the field all of which would be
absolutely fascinating to talk about
this afternoon unfortunately I only have
fifty minutes so I'm going to focus on
just one of these and that's the turing
completeness of smart contracts now
hands up if you know what a Turing
machine is excellent
so you recall back in the dim and
distant hungover days the first year
computer science that you have a machine
which has a tape and it basically is
equivalent to two programs and basically
what we will probably remember the
halting problem is is that it's not
possible to construct a general
algorithm which given any possible
unknown program that the algorithm will
tell you correctly whether or not the
the program will terminate okay
so great halting problem what does that
have to do with crypto what does that
have to do with smart contracts well a
smart contract is a program which runs
on top of a digital distributed ledger
like Bitcoin okay because that's really
what we're talking about rather than a
pattern of bits which of course could be
duplicated we want to model something
which looks like the private banking
system which we have been so so so
unconsciously using all this time and
what that means is that we are going to
have the equivalent of bank accounts or
Bitcoin addresses which have amounts
attached to them and we're going to be
able to write a program which indicates
how to manage the assets which are
recorded in the ledger so do we want
this language to be turing-complete or
not
now obviously the the class of what you
can do in done showing complete
languages is
rather restricted and rather rather
boring so we probably do want full
complexity of pure and completeness but
then of course the problem is is we're
running this on top of a ledger which
contains people we potentially don't
trust we're really going to start
running code from an unknown untrusted
origin in a network which almost
certainly has has adversaries in it well
that's a thought sounding good either so
what are we going to do well let's pause
and let's have a think about the JVM and
see see if there's an angle here which
we can we can use to to address the
problem well Java is is 2121 now is
finally old enough to drink in the US so
people who've been telling me for years
this picture actually shows Duke with
some kind of frothy coffee or something
it's clearly wrong it's clearly now old
enough to to have beer so Java is 20
years it's been enormously successful
you know I'm not going to tell you that
that Java is the mythical perfect
programming language of course it's not
but languages which make it to 20
generally have something of a story to
tell about them and I think there were
two quotes about Java which I which are
particularly stick with me both from
James Gosling the originator firstly
Java is a blue coil language this is the
single biggest and most important thing
which explains the design decisions in
Java the language it is designed for
working programmers it is designed for
people who get their job done and
deliver fairly mainstream business
applications it's designed to be stable
and robust small C conservative in its
design choices and James has also said
that the other quote which I talked
about putting on on the slide that if he
didn't know the right way to implement a
feature in the language he would rather
leave it out and wait until it what
until he was sure so you can complain
about backwards compatibility you can
complain about the right rate of change
of Java but but this is not an accident
it's not because the people who are who
maintained and Shepherd the language are
incompetent quite the reverse it's that
they take their responsibilities for the
language extremely seriously
and Big O you can see that that much as
we as developers might want to know
lambdas 10 years ago or whatever for
many business applications backwards
compatibility and the stability is a
huge strength now the second quote is
really about the language itself Java is
a very simple language in fact here it
all is 53 keywords no more when I had
this together to talk to a bunch of C++
developers an argument broke out in the
room amongst C++ developers about how
many keywords in C++ there actually are
we got up to about 200 I think and then
they started arguing amongst themselves
so that was that was quite disruptive
that that talk did not fit in 50 minutes
but we finally might have got it calmed
down but in Java we only only have 53
notice that there are two keywords that
none of you not a single person in this
room has ever used go to and Const both
are reserved words in Java and both are
illegal and the compiler will reject any
file which tries to use them they are
reserved for future use good luck with
that
there are of course other keywords here
which which you may never have used or
or shouldn't use assert for example but
we'll come back to some of those
stranger keywords in a bit so the
language is extremely simple and the
operating environment is also quite well
engineered and also quite simple we have
we have a clear separation of the
concern of compilation generation of
class file we have the class loader
which we're going to talk a lot about
which actually is where a lot of Java
security model is implemented and that's
going to be a very important thing to us
and then we have the method cache and
interpreter which is defined by very
clear standard the VM spec and then also
subject compilation the only real major
subsystem of the JVM is missing from
this diagram is of course garbage
collection but that's an operational
concern rather than specifically a
design one-foot for our our purposes and
I like to think that this represents a
very very clean and clear separation of
concerns
and I was trying to think about a way to
explain the concept of separation of
concerns to some junior grads who had
never come across the term before and
then I found this if next time you have
to explain what the separation of
concerns is show them this picture okay
so this is starting to sound like we
might actually have some good traction
with with Golikov might be a good
language with earning smart contracts
what are our key positives
well Java is extremely well understood
and it's extremely tractable it has been
around for 20 years it has been studied
by literally millions of people
worldwide the the semantics of byte code
are fully understood the security model
has been attacked over and over again
and although there have been
implementation bugs there are always
implementation bugs the model itself has
withstood twenty years of serious
efforts to break it and it's held up so
we have a very mature environment
there's also a lovely tooling space for
JVM bytecode
with a lot of libraries and a lot of
good tools out there and we also have
the class loading pinch point now this
isn't this is integral to the security
model but it provides us with not only
the existing security that the the
platform comes with but because class
loading is a hook that developers can
access we can use it to apply additional
security concerns and remember we're
driving towards rejecting
non-deterministic programs we can do
that at class loading time and that's
that's actually going to be one of the
keys to getting this to work okay sounds
great what's the catch
well Java is highly dynamic and it is
essentially multi-threaded all Java
programs more or less the multi-threaded
even if your code isn't the JVM is and
that's it was the first mainstream
language to provide threading and almost
multi-threaded programs are
unfortunately non-deterministic so that
sounds almost like it should be a
showstopper but it turns out that the
the interpreter spec allows if you are a
single threaded application to produce
deterministic answers okay now it won't
work for things like which depend upon
the actual running time of the program
because garbage collection could happen
for example and you could get non
determinism that way but aside from that
as long as you don't depend on on
external clock time which you can't
anyway because if you want to be
deterministic the last thing you should
be doing is calling something like
system current time Milly's because it
will give you a different answer each
time you call it so that so maybe the
fact that we can't depend upon external
wall clock time isn't a problem so in a
single credit program maybe it will be
okay okay well what about JIT
compilation
well here's the thing about JIT if you
have a JIT compiler you must to be
compliant have the same semantics as
interpreted code so even the fact that
the JIT compiler is non-deterministic
and by the way is very non-deterministic
you will get a different set of compiled
methods tip apart methods for every run
that you do of every java program you
execute the set of methods is not stable
from run to run even in highly
controlled performance environment so
again that looks like it could be a
showstopper but in fact we're saved by
the by the fact that the JIT compiler
code has to have the same semantics and
once again we're not depending on
external time so it looks like we might
actually have a shot at making this work
so let's see how we're going to do it
well let's uh let's Bluff our way
through some bytecode here's a class
file if you like editing hex directly
which I do this is this is hex ed 0 XE D
which I think I secretly liked because
it's a terrible UNIX joke in at least
two different ways at once so so that
that's going to make it appeal to me
what can we see here well we can we can
see the pure hex view of the class we
can see on the right hand side some
stuff which has got strings in it that's
the error of the class for called the
constant pull and most of it is going to
taken up with the bytecode of the
methods so bytecode
call is called white coat because each
operation or each opcode is represented
by one byte potentially with some
parameters following it in the byte
stream its big-endian those of you have
read Gulliver's Travels you know you
know where that comes from there are 256
possible byte codes because one byte and
about 200 in use that sounds like a lot
it's not because there are 200 different
fundamental operations that the byte
code can do it's because bytecode is
typed so the same general operation will
have one byte code used for objects on
one byte code for floats perhaps 1/2
inch and so on so each of the primitive
types potentially can be represented on
a particular byte code family by code is
an abstract representation it is not
machine code for an imaginary CPU hands
up if you were told that a university
good I'm glad that myths has finally
died when I first learnt it in 1998 I
think I think that that myth was still
very much alive byte code is stack based
so what I mean by that is that the the
execution has no registers so everything
which you do when you when you call a
guard method a new stack is generated
which you you load things onto and then
operate on the top of the stack
consuming entries from the from stack
and replacing them with any results of
the operations so that's different from
a call stack so I'll sometimes use the
expressions evaluation stack and call
stack bytecode is not really a compiled
form Javik to me is not really a
compiler for those of you who remember
your compilers courses it's um it's
really the front half of a compiler the
thing which actually produces the
machine code the real meat to the
compiler is the JIT compiler so when I
say compiled by always mean the JIT I
don't mean I don't mean javac ok let's
see some some some byte codes let's look
at a few forms
so as promised we've got D load to load
doubles onto the stack a store means
store the object in an appropriate local
variable I'm just going to do enough of
the byte codes to it to for the rest of
the talk there are others which
occasionally crop up byte code is
actually pretty easy to read there's a
talk of java P which will dump out byte
code and let you let you read what's
inside files and once you get the hang
of it well for Java the bytecode that's
produced is extremely similar to the
Java language code once you've taken
into account the fact that you're you're
actually working on a stack machine
other language is a not that's not the
case so the sky lack the Scala compiler
produces reams and reams and reams more
byte codes and javac does and it does
some really quite amazingly clever
possibly too clever things under the
hood ok so here are our load install op
codes these basically are going to put
things to and from the stack the way to
read these steady Z the family name is
here it may need a prefix like load for
example the arguments basically say how
many other bytes of argument it takes
round brackets means they're potentially
optional for some forms of the bytecode
the fat layout column basically tells
you what the effect of the op code on
the stack is so for example if you start
with an empty stack and did an a load
you will get one thing on the top of the
stack after the the opcode is finished
you have load in store you have get
filled and put filled these obviously
going to store things not in local
variables but in the fields of this
object or potentially another object if
you if for some crazy reason you have
public fields which none of you do write
arithmetic so none of these are code to
take any kind of argument they all
operate on the two things which are on
the stack and here is where a piece of
the security model comes into play
suppose I load a an object onto top the
stack with a payload and then I load an
integer an entry onto the stack and then
I issue an I add what am I trying to do
so loading an object unloading an INT
and then I issue an eye add instruction
and then return that as an object
absolutely it's point to arithmetic and
it's completely disallowed so when the
class loader sees that sequence of byte
codes it's immediately going to reject
loading that class now of course the
Java compiler javac will never emit such
such a stream of instructions but I
might be able to handcraft it if I was
sufficiently devious but it doesn't
matter because the security model and
the class later will protect us
flow control Java a Java bytecode only
has two legal float control arguments
these days it's if and goto
that's it there were at one stage others
jsr and ret produced a kind of a local
subroutine effect but they they were
disallowed in I think Java six I think
any class files which are which a Java
six or later will be rejected if they
contain GSR on ret table switch to
lookup switch there something seen for
for the output for what switch statement
has been boiled down to but mostly it's
just different go to notice that go-to
can only jump within the local method so
that it's so again the class loader will
check and says the target of your go
tease is it in this method or you trying
to branch outside of the method oh you
are well guess who's not getting loaded
today the application instructions again
this is the starting point for so much
that we could talk about here but the
key thing to note is that they are the
only way that you can call another
method if there's no go-to instruction
which will take you outside of the
current method if you want to genuinely
call another method you have to use an
invoke so what this means is that the
JVM is also immune to a whole class of
attacks that would be possible in sort
of late 90s early 2000 see the kind of
attacks where you you use an array to
write out some some actual machine
instructions overwrite the return
address of the stack and jump into the
code that you just wrote out that
doesn't work in Java because
fundamentally go-to is local to a method
and the only way to call a method is by
an invoke so what I'm saying is that the
Java platform always knows the
difference between bytecode and data
that's kind of a useful property for a
security system or the basis for for a
secure system to have write a couple of
other ones we need to know about nu
which allocates memory so basically as
we'll see a Java object construction
boils down into two separate operations
a new opcode for allocating memory and
an execution of the constructor body we
also have monitor enter and monitor exit
which jar the keyword do you think those
have come from yeah synchronize that's
right so so we'll have something to say
about those as well okay very quick
example here is the world's most
interesting class it has one field on it
and it's int and the gastrin Isetta
disassembled the bytecode we end up with
something like this and basically there
are three methods here we only talked
about two here so sure enough just as
you were always taught the compiler has
inserted a constructor for you and
notice what it does it calls object in
it which is which is necessary objects
which don't which are constructed in
which don't end up calling object in it
are actually illegal on the platform bad
things would happen if you if you if
each object doesn't at some point go
through the object init constructor okay
so let's look at the methods one at a
time let's start with a getter so a
little tiny bit of code a load zero what
do we think that does it's going to load
something onto top of the stack
what is it an object the a prefix by the
way stands for address so we can always
tell it will be loading as an object
reference point into the heap would yes
absolutely it's loading this because it
has to because the only way that you can
you can operate is to have this already
on the stack because the next line down
the get field needs to have an object to
operate on which object it to operating
on twelve runs on top of the stack which
is this this is one of the shortcut
forms that I mentioned earlier notice
that a load zero has no arguments after
it
load typically does so this is a
shortcut form and the reason we do that
is because it saves two bytes in the
file size every time you want to load
this or to top the stack and you do that
a lot now that might not sound like much
of a big deal
but give us the first Java class files
that I ever downloaded we're over a
fourteen point four kilobits per second
modem I am very glad that I'm not paying
an extra two bytes every time I want to
load this so we get the field and then
we return so let's see that in action
load this on the stack you execute the
get field instruction to get that value
and back it comes the setter method we
load 0 so put this on the stack we we
load 1 which of course will be the first
argument basically the order for local
variables is this is 0 if this isn't the
static method the first local variable
will be the first argument if there are
any etc and then basically your your
actual locals for the for the method
gets shuffled up after that we run the
put field and then we return so let's
see that in action load that up put
field and now of course we have an empty
stack which means of course that we now
really know what void means void as we
know is not a type what it actually is
it's a statement about the state of the
call stack when the method returns ok
and here's our constructor again we do
load this call the superclass
constructor and it's effectively become
a void method for the constructor body
for object creation we do something like
this so the way that we would call that
constructor is with a piece of code like
this we call new to get some TSO memory
we duplicate on the top of the stack two
copies of the uninitialized object are
now on the top of the stack and invoke
special is called to run the constructor
and then we finally we store in the
local variable the dupe is there because
if you don't do it the invoke special
consumes what's on the top of the stack
and you end up with no reference to the
object you dis created which means that
you've just run
constructor body allocated memory run
the constructor body and immediately
made the object available for garbage
collection unless of course you you had
side effects in your constructor but you
wouldn't do that right okay so we've
talked about the stack we talked about
some byte code another note just about
the interpreter really it's unison
environment and if you want to make your
own implementation interpreters the best
thought of as just switches inside while
loops hotspot actually is quite a lot
smarter than that but that would take us
down quite a rabbit hole so let's talk
about file floating so the class file is
basically a binary metadata file which
is not really human readable but it is
possible and it's not that bad to work
with the sort of the overall anatomy
looks a bit like this you have what's
called the magic number which is the
identifying bytes at the start of any
UNIX binary file in Java skates that's
rather embarrassingly cafe babe it was
embarrassing 20 years ago and it's
scarcely got better with age immediately
after that you'll find the minor and
major version numbers of the class file
there are different versions of the
format and it does change over time the
rules for example in for Java seven
bytecode is quite substantially
different for those in in six but it's
always backwards compatible because
that's the driver way I found myself
having trouble remembering all of this
so I came up with this acronym or
mnemonic to help me remember instead and
every time I see this I always think of
the movie gremlins because it I don't
know it's a kind of my name is that
there's kind of like the gremlin count
on the on the right hand side okay so
now we know what's in our class file and
it's basically the metadata we'd expect
what fields have we got what interfaces
what are our methods we need to get it
into the platform somehow so let's do
some class loading we add in a new live
type notice that as it's being loaded
potentially it's going to be transformed
lots and lots of frameworks do this and
we're going to do it too
so the first thing which which happens
when you when your class load is
confusingly called loading I don't know
why the phase was called specifically
loading rather than something a little
more sensible but there we are
essentially reads in a byte array that's
normally on a disk somewhere it might be
over the network and it does some very
basic checks on the class it basically
make sure that the constant pool which
is where a lot of the references to
things that this class requires are kept
but that collection of constants is
self-consistent but it but is no way
does it produce a class object and if
you think about it that's the process
that we're undergoing when we when we do
class loading as we start with a bunch
of bytes and we end with a live running
Java class object that we can use so we
need to to have that as our goal our end
point and that of course may contain
code there may be static initializers
for that class at some point that code
has to run but the way that the security
model is designed very much we want to
leave the running of code until we're
absolutely sure that it doesn't try to
do anything evil so the the the pointer
arithmetic attack for example or any
other of the huge number of things that
could be wrong with the class file we
want to ensure that those checks have
all happened before we before we start
running any code and the place we do
that is the verification step so
essentially what this breaks down to is
that the the class file that is a
candidate to be loaded is not going to
do anything illegal at runtime so things
like do you respect access control
keywords are you trying to call somebody
else's private methods again yeah like
going to MIT code which does that but I
can write it do you have the correct
static types for calling are you
properly going to initialize your
variables all that kind of things and
for this verification the stack nature
of the JVM is actually really important
it's not impossible to do this on
register machines but it's a lot harder
the stack machine is actually fairly
easy to reason about types for and it's
a
the the checking of that at class
loading time is is one of the things
that makes class loading interesting to
us there's a bunch of other things which
which happen stack under flow mismatch
all kinds of things any sort of clever
attack which tries to subvert the run
time although the rules of the platform
will be checked you may need to load new
classes and so you may end up with a
picture like this I collect load one
class object and I've ended up with all
these other classes which are suddenly
in scope would also need to be loaded
this doesn't actually happen for object
because it's part the core of the
platform and so it's actually loaded and
far I think we'll the bootstrap class
loader which doesn't actually do any
verification just loads it because
essentially you have to trust something
finally after we've verified the class
it's we're ready to go we can allocate
memory for it we can actually start to
get ready and then finally produce the
class object run the static initializers
and you're now ready to go
at this point some aspects of the class
are still not fully initialized in
particular reflective aspects will be
initialized lazily so you won't be there
unless you actually go and poke them but
the class object is is fully usable at
this point so let's talk about some
implementation details of how this is
going to work in particular the class
class loader it's an abstract class it
works but it has no abstract methods so
that probably sounds a little odd but
what it means is if you want to use it
you have to subclass it it can't be
directly associated itself it provides a
public load class method for loading
classes you passing the binary name and
whether or not it should resolve it and
it will it will then load that class for
you which sounds great but the other
method on which we pretentious you want
to focus on a little more is to find
class now this is a protected method
this is called from the subclass and
it's going to be the basis of custom
class loading and this is going to be
our our point that we're going to am
we're going to step in at you probably
know that class sliders loaders form a
hierarchy where you
class loader that loaded you is normally
the one sectors your what's called your
parent and there's a delegation
hierarchy where you collect to let a
class loader that loaded you deal with
the class before you do it's very very
easy to write a class labor I mean I
missing a a code comment here but apart
from that that is a perfectly valid and
usable class loader doesn't do much but
it's it's valid okay so what are we
going to do now we've got the the
concept that we could use a custom class
loader to somehow verify determinism we
also probably therefore need a library
to help us analyze bytecode I said the
tooling space was very mature and my
library of choice is thing called Adam
hands up if anyone's used Adam before
few people yes it is not the world's
friendliest of lot of libraries it's not
got great documentation but it's
actually really pretty solid
you know once you've got to know it a
bit it it's it's fine it provides a
fairly close correspondence to the
actual Java bytecode format and it's
kept up to date over over many years
there's even a version of it hidden away
inside the JDK if you want to know how
lambdas and so forth are actually
implemented inside Java right go and
have a look at the source code and you
will find a modified version of Adam
lurking there don't use that one use an
external library instead the platform
likes to keep its internals private and
you should you should respect that
so ok so how we're going to use a Adam
well there's a simple pattern which we
you know we can start from you spin up a
class visitor you write out the header
of the class you generate any methods of
constructors you want and then there's a
method to turn it into a byte array and
write it out if you want to know to dip
your toes into the waters of Adam I
wrote an article which outlines the
basics of it which is available on info
cube oh my god right so this it kind of
is the picture that we're actually going
to have we're not going to quite do is a
simply use case at Adam as we we saw in
the last slide instead what we're going
to do is we're going to do a
transformation we're going to load in
the class file as a byte stream using
defined class pull it off the disk run
it through an Adam process to determine
whether or not it
is actually deterministic and then we're
going to output some potentially
modified code okay so now we get to the
real meat of the talk let's talk about
provably deterministic execution how am
i going to get around the halting
problem well here's how you do it first
of all a class loading time anything
which is non-deterministic which means
anything which tries to create another
thread anything which calls a method
like current time Milly's or nano time
or anything else which which I know is a
non deterministic method I'm just going
to reject straight away okay and after
I've done that I'm left with a set of
methods that may and the class which may
possibly be deterministic now the only
problem is that it might run out of
resources it might be in an infinite
loop somewhere so we can't have that so
what I'm also going to do is I'm going
to rewrite the bytecode and I'm going to
insert resource tracking code into the
candidate program okay and then at that
point I'm going to allow it onto the
platform
then at runtime if anything happens
which is going to breach resource limits
that contract is killed R and now all we
need is a transaction monitor because
then at that point I can roll back the
effect of whatever the contract did to
the previous state and I should have a
system which is actually robust enough
for deterministic execution should we
see how it works so okay the
whitelisting class loader there are a
few driver keywords that I've
highlighted here of being of potential
interest okay they are catch because we
might try to for example catch the kill
signal I'm going to send two contracts I
could use thread got stop to kill off a
contract that's breached its resource
con limits but we know that thread
doorstop is bad
so we don't do that instead I simply
have a method which will throw a thread
death error now someone enterprising
person might try to catch that thread
death error so that can't be allowed so
I have to go through the code and look
at any catch block and see if anyone
when loading if anyone tries to throw
thread death or catch through a death or
throw a ball or anything we've got on
the path between the two that contract
is disallowed so I have to check for
that native yeah no native code that's
probably not a surprise so anything
which declares a native method that's
out as well
synchronized I think I have an edge case
I haven't been able to find a test case
for it
that I could actually get block with
would sue to be nasty synchronized
either way I'm just you know there's no
point because the contract should be
single-threaded so we'll just get rid of
synchronized so what that will mean is
that the money to enter and money to
exit are bytecodes so how does the
monitor enter work well you put the
object whose monitor you want to lock on
top of the stack and then you execute
monitor enter which consumes that and
similarly when you want to exit the
monitor so I'm just going to rewrite
monitor enter and monitor exit to pop
you put the object on top of the stack
great I'm just going to pop it off I
don't care what it was and I'm certainly
not going to try to do any locking
transient is is ruled out for
complicated reasons to do with
serialization I shall go into strict FP
hands up if you've ever written strict
FP in your entire life nobody that's
normally the answer I have used it once
the thing about strict FP is it says
follow precisely strictly the
floating-point semantics of the the OEE
triple I Triple E 754 standard which is
the floating point standard if you don't
have strict FP on your method the
hardware will use better precision if
available that obviously is a potential
source of non-determinism so we enforce
strict FP on every single method we ever
touch and now the demo this of course
will not work because demos never ever
do
okay so here is the whitelisting
classloader
is that too small should I increase the
size of the font yeah okay how's that
cool okay so this is the white listing
calculator sure enough as promised it's
a class loader and inside it I'm going
to keep a couple of things I'm going to
keep a map of classes that I've loaded
and I'm also going to cache the bytecode
which in its transform state
I've got additional search paths because
the classes that I'm going to want to
load probably aren't on my class path so
I've got to maintain a separate internal
class path for that I've got a thing
called a candidacy status this is a
domain object which determines whether
or not the object actually is a it's
deterministic and that's used for a
modified version of what I subsequently
realize is actually a modified version
of Dijkstra's tricolor marking algorithm
it's not quite the same but it's it's
very very close
ah I didn't tell you about this this
class loader actually has two modes the
first mode rejects anything which is
non-deterministic the second mode strips
out any non deterministic methods and
keeps only the deterministic part of the
class okay why did I build that well
because I actually want to have some
useful classes Java util Java IO not
Java IO Java util and Java text
certainly so I have actually built a
deterministic version of a subset of the
Java collections library by running the
class loader repeatedly over the same
packages I can build up a larger and
larger map of things which are known to
be deterministic because the way that
the algorithm is going to work is if I
have written you on a list especially
whitelist to say that method is
deterministic then any method which
obeys all we are the rules and cause
only deterministic methods is itself
deterministic so on a recursive
set of calls through the same packages I
will eventually reach the point where
I've iterated so many times at the input
set and the output set are the same and
I know what my search deterministic
methods is at that point I can save that
as a list and the next time I fire up I
don't have to do that that repeated walk
so that's what removed non-deterministic
methods means okay five minutes so we've
got a bunch of constructors here where
this actually that the real meat of this
is find class and find class basically
is is what you actually override when
you write a class loader load classes is
the entry point but that will delegate
back to find class and if you look at
the source code for class loader let's
find a class you can see that if you
don't when your subclass in class loader
if you don't override find class and
actually provide an implementation you
get a class not found exception so
that's basically the fallback and that's
that's actually where you you put the
hooks for for your own class loading
okay so how do we do this well the first
thing we do is we check to see if we've
already loaded it if we haven't we
change its name because of course the if
I'm going to use Java util or Java text
then I can't use those package names so
I have to change them so that what I do
is I rewrite the package names on the
fly as well to bring them into what we
call the sandbox so if they're already
in the sandbox great we'll use that that
loaded class if not will try and let the
superclass find it so that if it's
something that's already present on the
platform which is some it's being used
then it then it can be we found if not
well then it's it's our go and what we
do is we pick up
the method we set up our Azzam class
reader from that we also set up a
whitelist checking class visitor which
basically is is where some of the work
starts to happen so here for example
this is the the visit method Adam is
based on a visitor baton which means
that that you get call backs into
individual matters that you've you've
overridden here so here for example is
me forcibly switching on strict FP for
every method here is me immediately
saying if you're Native then out you go
this is the finalize check no finalizes
either of course and then at the end
when we visited all the methods we
finally call visit end and we basically
run this algorithm to determine whether
or not we're deterministic based on what
we call ok there are method visitors
somewhere else as well I'll just I'll
just show you
I think I've just done something wrong
there we go in the in the method visitor
I've got a bunch of stuff to do with the
try CAPTCHAs so if I try to catch thread
death the way it goes if I try to do
anything which involves invoke dynamic
again you're kicked out and here's where
I set up the other piece for the the
determinism spec to this method okay two
minutes left what I did in order to test
all of this out is I wrote myself a
basic contract container
it's called Graymalkin I don't know
where I was going with that with
Graymalkin as a witch's cat concat
something like that I have no idea what
I was thinking and basically what this
does is it starts up a thread which
watches the directory for incoming
classes and then it tries to load them
into into a contract so where's the
other one yeah here we are so we pull
pull things off the out the directory
and load them if we can the way that
this is handled is we have what's called
a contract class which basically is a
representation of a running thread with
a contract on it so it's one thread per
contract it's some and there's an
executor which basically which runs the
actual contract I didn't have my
increment a full distributed ledger so
what I did was I produce something to be
mocked up to look like it it's called a
vetted log appender it just depends to a
log and it won't allow you to do that if
you're non-deterministic so the
appropriate interface is string returner
so my contracts have to implement string
returner so let's run this
okay so here's one I made earlier on
Anita
okay so it in here I'm just going to
tail the log we're waiting for stuff to
turn up
actually let's move that into a separate
window so we've got some classes in here
let's send one of them across simple one
drop class into the test directory and
as you can see a bunch of stuff has
happened it's gone and it's checked
through this to ensure that it's
deterministic and I didn't have time to
tell you about the the runtime cost
accounting but all of that code was
inserted into the the code and now this
time if I pass in is it's free which is
non-deterministic sure enough it's gone
through class simple free cannot be
loaded because it's calling a
non-deterministic method and so it is
not allowed into the into the sandbox
okay I think my times up
does anyone have any questions yeah ah
okay so the the resource son yeah okay
so we can do that so it's basically in
the costing package there's a thing
called a runtime cost a counter and the
way that this works is it has four
thresholds so an allocation threshold
because I've rewritten new two to put in
code which will show up if you if you'd
like to see which memory a jumped
threshold where if you I should Luke too
many times it will kill ah and and an
invocation for a shoulders well if you
want to come and talk to me afterwards
very happy to to tell you more about the
research the work was originally
commissioned by r3 it's part of the
Corder project there's another article
about it on info Q there are bunch of
books that I wrote and thank you very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>