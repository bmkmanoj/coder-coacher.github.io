<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Elm in production by Richard Feldman | Coder Coacher - Coaching Coders</title><meta content="Elm in production by Richard Feldman - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Elm in production by Richard Feldman</b></h2><h5 class="post__date">2017-04-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XsNk5aOpqUc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right this is zero runtime exception
since 2015
Elmen production I'm Richard bellman
excited for a company called no red ink
we make software for English teachers
and back in 2013 when I joined the
company we had this sort of smorgasbord
of front-end technologies we had like a
little bit angular louver the backbone
jQuery
it's a whole bunch of stuff and then
react came out and we started using it
we just like introduced this a little
bit of react to our stack and said like
okay there's going to use this on one
part of one page and just see how it
goes so for a little experiment and the
experiment was successful we liked it
we're happy with it kind of grew and
grew and grew and then 2014 react sort
of took over it became the dominant
paradigm of our front-end we're pretty
happy with it until we got to a project
that sort of took a long time it took a
lot of iterations so one of the things
that we really value is giving our
students a really good authentic
experience so we had this interface that
where the goal is to teach them active
voice and passive voice and we took our
react app out to a classroom and tries
out and unfortunately it didn't succeed
like the students weren't getting it
wasn't effective at teaching them and so
it's everything will go back to the
drawing board and we'll revise this we
need to make a lot of revisions a lot of
heavy revisions and what we were finding
was that it was just taking a long time
like we would break all of our tests
would have to go back and rewrite a
bunch of stuff things would crash and
before we could get it out for the next
iteration it was just a very lengthy
process so then we took it back and got
some more feedback had to go back to the
drawing board iterate again and all this
time I've been working on Elm on the
side for a side project I've been doing
and I've had a very different experience
with this type of revision where I had
the Elms compiler helping me out and I
was finding that when Elm when I made
big changes like this it would take a
lot less time and by the end of this
whole experience I thought man if I just
said let's do this in Elm instead of an
react this planning process would have
taken less time and the resulting code
would have been more maintainable he
wasn't after accounting for how long it
would have taken the ramp everybody else
on the team up on Elm but it's a lot of
the mistakes so in 2015 as a little Rufe
introduced a little bit of element
Dakotah bass just see how code same
thing we did with react just try a
little experiment so we did and we liked
it once again worked it was nicer it
solved some of our pain points and so it
kept growing and growing until by the
end of 2016
Elmen became the dominant paradigm of
our front-end so the title of this talk
comes down to a little technology that
we use called roll bar so roll bar is a
library that catches JavaScript runtime
exceptions so we just have it running
we've had it running for a long time now
and there's me every time something
crashes something throws a runtime
exception in the browser for one of our
end users roll bar catches it and
reports it to us so we find out about it
so we can go in and find out what went
wrong and some of these triage or every
week somebody goes through roll bar and
just checks out where all the bugs came
from we file issues and you know figure
out what to do about them
so we notice something interesting when
we started introducing elm which was
that we weren't getting any runtime
exceptions for our elm code only from
our legacy JavaScript code and that's
kept being true longer and longer until
the point where I was asked to speak
here in October 2016 we still have not
seen any so the title of the talk is no
runtime exception since 2015 which is
actually to say yet like ever it had
never happened but if you think about it
an interesting timeline situation here
and you can kind of backtrack and think
about what happened leading up to today
so October 2016 I get asked to speak at
that point we have zero runtime
exceptions in production but like that's
true then today is March 2017 so I had
to decide on the title to talk between
then and now and not your visit was
going to happen in the interim like very
possible I've been a reputed today add
what I'm about to say is well that was
true back then but you know things
happen so I'm sitting there debating
like what should I talk about like I
think of a really cool title for the
talk but but like what if it doesn't
work out that way what if we finally get
our first one-time exception between
then and what I have to go on stage
having now committed to this title so by
now I guess if I doubt those really kind
of came down to confidence right I was
asking myself those questions like I
just really want to use the title of my
talk and I was thinking like how much
confidence do I have that this is not a
fluke like this is just like actually
just
normal and like yeah probably this is
just going to keep happening and I
thought well I'm not too confident
that's true so that's sort of it as you
know because that was the title to talk
so what happened so these are our
current production numbers so this is no
red ink in production so we have over
two billion questions answered so
students are answering millions of
questions per day that'll probably be at
three billion the next time I put this
flight up that at 100,000 lines of elam
code running in production since 2015 oh
we didn't have that much back then but
and today the total number of runtime
exceptions we've gotten since we
introduced it for all time
still zero we're not they're probably
thinking okay okay so like what does
that mean
zero runtime exceptions okay we know
that it literally means that there were
no runtime exceptions but like why is
that because LM just swallows one-time
assessments got giant try-catch around
everything like they're they're not
suppose you could achieve this right
especially the answer's no it's much
better than that it's actually that we
got no runtime exceptions because Elm
has an awesome compiler that just
catches all the problems that could lead
to runtime exceptions up front so to
give you an example of how this works
let me introduce you to Ellie so Ellie
is program that it sort of nominally
like jsfiddle for Elm
but it does some cool stuff than that
this right here is from home code on the
left and what it's causing to render on
the right is this chart so this is the
elm code on the left and it le was
compiling it and then using it to render
this code on the right so LM compiles to
JavaScript it's a functional programming
language so what's happening here is
when I make a change over here and I hit
compile it's going to rerun the compiler
check for errors generate some
JavaScript code and then run that
JavaScript code over here on the right
there's a tiny little bit of HTML down
here that's sort of setting up the back
of the like what's backing the actual
JavaScript so companies know about this
so the sort of nominal purpose of le is
this share button but so you can share
the little code snippets with one
another but the cooler stuff is that you
can kind of see a little room go into
what it's like using L
for like normal development so this
format button is pretty cool so there's
a I don't know if you've used go format
or in or in JavaScript prettier but
basically in elm there's this one common
formatting library and when I make a
bunch of changes like this and then I
hit the format button Wi-Fi permitting
let's see maybe I need to and I
connected one of those things where you
do a live demo and then you check things
right before you start and then maybe it
works and maybe it doesn't compile okay
that worked and now I'm going to mess
stuff up for that there we go okay sorry
about that little Wi-Fi blip so yeah so
so it has the sort of consistent
formatting scheme that yogya here is to
prevent you from having to spend time
thinking about style so one of the
coolest parts about Elm format is that
there are no configuration options zero
and that's a very intentional design
feature and what it does that prevents
teams from having arguments about style
configurations so you can't argue about
like how to configure your tabs or how
to configure your like line blank so if
you anything like that it's just all
baked right in and this is sort of like
the consistent community standard so
everybody on our team has own format set
to run on save so soon as you're done
you just hit save them and everything
just lines up pretty nice there's also
the fourth button which is if you want
to again if you want to share things but
the real exciting part about what LM
with you is really comes down to the
compiler and that's what this compile
button does so let's say I want to
change the size of this I wanted to
change 400 to 200 ok that worked fine we
expect that to work what if I change 200
to something that doesn't make sense
like cats okay let me compile this and
it's gonna say take this match
you only need to function size is
causing this match so I was expecting it
to be 2 inch but it is in a string
alright so the compiler says ok I
understand that those are you know two
different things and you can't do that
ok but it's a pretty common source of
runtime exceptions is null pointer
exceptions in Java or undefined is not a
function in JavaScript being a lot lots
of different cases where you think
you've actually got something to work
but it turns out you don't but I try to
compile this cannot find variable no and
the suggestion to you are kind of
revealing this movie you want one of the
following area dot fill HTML dot ul
label dot fill list dot all like whether
that's suggesting no lifted that Elm
doesn't have no or undefined or nil or
anything like any of those so there's
this great quote from Sir Tony Hoare
where he talks about how he popularized
know that can all gold W and he called
his billion dollar mistake because he
thinks that over the years
Noah has caused over a billion dollars
in economic damage and he considers it a
mistake to have introduced it in the
first place so it turns out that there
are other ways to represent the absence
of a value and those alternative ways
but the compiler help you out more and
let you make sure that you're handling
all the cases where you need them to be
handled so M doesn't have null doesn't
have undefined so that entire category
of runtime crashes just goes away so
remember things to note on the left here
we have some packages we have l9 flash
core online flash HTML ln / DG + 3 squid
flash elmify
so elm has its own package manager you
can add packages right here through le
and we'll talk about that a little bit
later but one thing to note is that
element doesn't reuse the existing
JavaScript ecosystem it actually has its
own separate ecosystem but a completely
different set of guarantees that's based
around this compiler okay so how are we
actually getting from this compiled code
this own code to this plot like how does
Elm deal with rendering things if it
doesn't use the built in you know
baseline things that JavaScript does
let's talk about that so there's the
fundamental thing to understand about
how Elm makes interactive you is is the
difunctional a function that takes some
arguments and returns a virtual Dom so
the virtual Dom is this idea that was
popularized by react and it's basically
the idea of describing how you want the
page to look so the Dom being the
document object model D the the
browser's representation of the page and
so when you look at something like this
this is a function called view it takes
one argument called state
any argument you want could be multiple
arguments doesn't matter the important
part though is that it's returning this
virtual bond description of how we want
the page to work and these right here
these are just plain old elf functions
so div is a function H 1 is a function P
is a function so this div is sort of the
container around all this this h1 has
the text color devoxx that's this
there's a player gap here with the more
text this is a chart pillowtown plot and
you notice that even something much more
complicated like this entire interactive
plot is also just a function call right
so I don't have to do any kind of like
special like this is a special
templating thing or like JSX or anything
like that it's all just built into the
languages functions so how do you get
something interact about it obviously
this there's more going on here this is
this is not just built into you know
JavaScript this is this is custom logic
here so how do you get interactivity out
of just a view function so the answer in
DL R architecture so the view the view
function is actually only part of this
architecture it's the part that does the
rendering but it's not the part that
does the interaction so personally
wouldn't compile Elam to JavaScript it
sets up this runtime the l runtime and
the runtime is in charge of doing all
sorts of different things like dealing
with event listeners performing side
effects there's just like the whole
category of things that are sort of
relegated to the runtime such that you
can write your own programs in terms
that don't need to deal with any of
those things so the own runtime deals
with the Elm architecture and translates
it into a running interactive program so
at the top you have your model so the
model represents your entire application
State as we will see shortly I really do
mean your entire application state it's
one single immutable value one source of
truth to the entire applications state
that you have a view function so the
runtime will actually pass your current
model to the view and say look I need
here's the current state of the world or
our entire application state when do
this you can break the view down because
it's a function into other functions
right so you can have one view function
at the top they can call out for lots
and lots of smaller view functions as
your program gets bigger and bigger that
sort of tree of functions sort of
evolved naturally view returns some
virtual Dom that describes how we want
the page to look and the runtime says
great
I now have got that description of how
you want the page to look I'm going to
take care of making the actual Dom look
that way now part of that could be
event listeners right we could say I
want you to react when something when
the user clicks or when the user moves
the mouse or when the user does this or
that importantly though the way that
those are specified or not in terms of
callbacks the way that specifies in
terms of messages so a message is just a
value a piece of data and the runtime is
actually going to send that data to a
different function called update so when
the user clicks it's not firing a
callback all it's doing is saying hey
runtime here's the description of what I
want you to do in response to that click
just go ahead and send that to the
update function so the runtime says cool
update here is the message that
describes what the user did and then
also here's the current model the
current state of the world now what I
want you to do the update functions job
is to return a new model says like
here's the new state of the world and
also as a separate value potentially any
effect that it wants the L runtime to
perform so this gives us a new model
based on user input and then finally
closing the loop the runtime says okay
cool now I've got my new model my new
state of the world I'm going to run that
through view again to get some new
virtual Tom which describes the new page
as I want it to look and then finally
the runtime says I'm going to glyph the
current virtual Dom that you just gave
me was the previous one that I had from
the last time we ran through this loop
and it can do that really efficiently
really quickly same thing that react
does and Seco I'm going to prove just a
minimal set of updates necessary to the
Dom to effect that change to make the
Dom actually reflect what's going on
there so all of this happens really
quickly as it turns out their benchmarks
you can read about on the Elm websites
blog if you benchmark this approach
versus like react and ember and angular
on like to two MVC application elements
benchmarks are actually faster so even
though it's doing all of this with just
immutable data and just pure functions
like you just returns the value to take
some arguments in terms of value update
also just take some dot some arguments
and returns value even though this
entire system is just based on immutable
data and pure functions it still
actually really fast in practice at
least fast enough for to make nice web
applications clear said of course you
can always fine tune like and tune
JavaScript to be a to be faster because
at the end of the day Allen compiles
down to JavaScript but the point being
you know even for very large
applications like ours this
really really well okay but this is
unusual a to handle application state
right like back in the day when we were
just using javascript and possibly
jQuery it was kind of normal to just
store a lot of your application stay
like right in the Dom itself just like
putting attributes on elements and then
read them back out use global variables
eventually we kind of figured out you
know this is like okay in the small but
when you start to get more and more
complicated after javascript started
getting fast enough to move a lot of
your logic to the clients where you can
get a better user experience this didn't
scale very well so it kind of moved on
and today I think most systems do what
react does which is to say you have
stateful components which can hold on to
their own State and manage it's sort of
object-oriented notion of things that
manage their own state and enforce which
are also separate sources of truth for
the application state redux which is
actually based on the yellow
architecture it's a story I guess not a
lot of people though but it's a little
bit up since I've been out of Rob's
interviews about Redux and the origins
but basically that says we'll just have
one store but you can still have
components with their own individual
state but I removed the only one that
I'm aware of that really takes a hard
line on saying up our application state
is really just one immutable value like
that is the single source of truth and
there was no alternative
so Elam doesn't have mutable Global's in
the language you can't you can't use
them that's not a feature it doesn't
have components it doesn't have stores
it's just this one mutable value for the
model that's it so what does this do for
debugging let me give you example this
right here is our create assignment form
so this is what teachers use when they
want to assign something to students so
this is written in L and so there's a
lot of stuff going on here right so you
can expand and collapse list of students
you can select all these different
possible types of things which reveals
more and more things you select content
it brings out this whole other thing we
can look at all these different things I
can search for like now and then say
okay identifying parts of speech cool
I'll check that off maybe check out
uncheck some of these we can see us
thinking in the background there this is
just a lot a lot of logic here and we
can imagine when you have this much
logic even when you have a compiler
that's preventing things from crashing
you still just sometimes make logic
mistakes right you write something that
compiles and it's valid but the end of
the day when you have
much business logic it's pretty easy to
make mistakes so here's how Elm handles
debugging so this right here I hit that
little Explorer history button in the in
the corner this is only available when
you compile your program in debug mode
so all those messages that are coming
through normally those are just part of
the process and they get garbage
collected
but in debug mode they don't and debug
where they get saved they get remembered
in memory I'd be pretty inefficient for
production but for debugging it's really
great because what I can do now is I can
just go back in time and say okay here's
what happened when this message came
through here's that having this message
came through and I can just replay all
the stuff that I just did
and because Elm has everything in this
application state that's one immutable
value this just works right there's no
other sources of truth here there's no
like missing information it's just
what's in the DOM and then what's in
your application state and I can just
like you expand and collapse all of this
right I can just look at any part of my
model at any point in time and just see
exactly what the values were so instead
of having to Doug go through and set up
watches and things like that it's just
it's all right here there's nothing else
to it there's nothing else to watch
another cool thing about this is what it
means for QA so if I hit resume here I
can now in addition to hitting explore
history I can also hit export so this
actually downloads everything we just
saw in a to realised format and now I
can actually I can switch browsers you
over to Firefox so if I go for history
here we have nothing because I haven't
done anything in Firefox yet but I can
now input this and just import that
history and now everything's
everything's back right this moves if
I'm trying to communicate or even say to
a co-worker where that's somebody who's
you know saying hey I can reproduce this
problem locally can you see what I'm
seeing I say I don't know what are the
steps to reproduce they don't have to
tell me the steps to reproduce they can
just send me this and say here this is
exactly how you reproduce it then or
that but because all this is doing is
its replaying these messages I can
actually make code changes as long as
they don't change how the messages are
structured and then I can still me play
these on top of that code and actually
the debugger is smart enough to say if
you try to import something and the code
has diverged too far and it's no longer
replayable it'll tell you but if it is
replayable and I'll say cool there you
go I can make it so you can replay
everything actually confirm that the bug
is
it's confirmed that it's no longer
reproducible and again this is possible
because of the way the Elm architecture
is oriented but there are some downsides
here in terms of learning right so when
you're switching from this
object-oriented mindset where you have
like components and state that's
managing local different sources of
truth versus this purely functional
style it takes some getting used to
so the fact that Elm has no components
means you have sort of a new way to
learn about how to do how to accomplish
reuse and for one people that takes time
to learn right it's a mindset shift and
whenever you have a different paradigm
to learn there's a cost right so this is
not something that we took on for free
there are a lot of things that you know
it really got better but the paradigm
shift definitely requires an investment
another thing that takes some getting
used to is if you're used to JavaScript
where everything is dynamically typed
I'm just switching to a type checked
world like Elm can also be an adjustment
right the benefit is that you get the
sort of different compiles it usually
just works now that's not true of all
type systems but it generally tends to
be the sentiment that people feel in
l-like once you get your program
compiling it tends to be that it just
works of course you can make business
logic errors but in practice it seems to
be a pretty representative of the
experience that people have and instead
of mean that you get cheaper refactoring
which in turn means that you get less
technical debt right so technical that
tends to accumulate less when
refactoring is cheaper like this so we
found a there's a significant chunk of
our old JavaScript code base was kind of
like nobody wants to touch it it's sort
of like we know that needs to be
factored but I really don't want to
touch that code I don't know what evil
spirits it will release better didn't
happen in elm code people have the
confidence to refactor so if you've got
some elm code you're like you know what
this has kind of gotten big and bloated
I want to just like split this up and
simplify it you can do that in fact
we're the compunction about saying even
like the most junior member of our team
who just joined and just say yeah just
go ahead like if it compiles it usually
just works so we have this confidence
that like unless they're you know doing
something really wild and out there like
yeah it's fine to just make refactor and
so the code base ends up being cleaner
because it's easier to clean now having
said this
this dynamic type system moves quickly
to get something up on the screen in
JavaScript right so if I'm trying to
make a prototype and just trying to
knock something out there's no doubt
that if I have two scenarios and all
else being equal in one scenario I don't
have to go through these checks I don't
have to deal with these errors that's
just going to be faster to get something
up and running but over the course of in
our case we found it to be a lot of bug
if you have a project that's a tall
longer lives in that even even just a
month long project you're going to have
overall higher velocity an L that's what
we found so the same project doing it
like the same team that granted once
they've been ramped up on Elm they
understand it they will actually get the
project done in less time and the result
will be more maintainable that's what
it's definitely a worthwhile trade-off
from our perspective now all this is not
to say that we have a hundred percent
Elm code right Elm is the majority of
our code they expect vast majority a
stacked our front-end engineers spend
about nine percent of their time writing
home code but there is some need at
least in our case and in fact in most
companies that I talk to to do some
amount of interrupts with JavaScript
right almost a much newer language the
library ecosystem is not as big so
interoperating with javascript is some
extent inevitable that's even on this
thing if I scroll down here almost
everything on this page is Elm except
for this little date/time picker right
here and even by we we ended up with all
sorts of really nice libraries that were
sort of off the shelf and elm we
couldn't quite find a date/time paper
that we like so this is jQuery right
here so it's this page is basically 95%
elven then just a little bit of Jake
okay probably more than 95% but actually
there is now some nice Elm Bay time
pickers that have come out since we did
this and we haven't gotten around to
switching but this little thing caused
this so probably a surprisingly high
percentage of the bugs on this page just
because it's jQuery rather than Elm
but interoperating javascript is not
only possible but it's important at
least in practice it's important to note
how Elm does this so elem code talks to
javascript the same way that it talks to
servers which is to say just by sending
data to and from it so if you think
about it let's say I have a server
written in Ruby which in fact that
our back-end is in Ruby if I'm talking
for my own code to my Ruby code I don't
really have to worry about Ruby breaking
any of Elms guarantee sorry there's no
code sharing that's not really possible
so what that means is that if I'm
talking to JavaScript the same way then
I have that same invariance right so I'm
just sending data to JavaScript and then
receiving data back from JavaScript
there's no possibility for the
JavaScript to impact the guarantees in
my own code these are sort of section
dot so this is a little bit more work
right it's definitely easier to just
call a function in the middle of any
other function than it is to talk back
and forth with data and so there's not
most languages that compile to
JavaScript interoperate with JavaScript
is if there if I'm in the middle of one
of their function calls and I decide
that I want to run some JavaScript they
will permit me to do that they'll say
you can just call it to the JavaScript
function anywhere you want now this is
convenient but the downside is that you
can no longer rely on your guarantees to
the same level you can with elm
I think of this interupt approach is a
big contributor to how we've been able
to avoid runtime exceptions is just that
when something goes wrong it's isolated
right the Java scripts kept completely
separate from the elm code so we can
really quickly tell where problems are
when they happen the clear area of
JavaScript as a service and so far at
least for us it's been a big benefit in
terms of reliability now let's talk
about the huge JavaScript ecosystem
deadness unlocks because on the woman we
do want to maintain our guarantees it's
really important that our elm code stays
easy to refactor and stays easy to debug
like this but it also is important that
we have access to that huge ecosystem
that ecosystem elite Russ pretty much
lives on NPM and I think that's true of
most JavaScript developers these days
like there was a while like Douw are
kind of how to run and so it's
unfortunately necessary for web
components and a few other things but
but pretty much this means NPM so NPM
obviously much much bigger than the
Ilham package ecosystem no doubt I mean
it's it's enormous right it's probably
the biggest packaged ecosystem in the
world at this point I'd be surprised to
learn that it wasn't and know does it
let you publish JavaScript you can also
publish binaries other things you can
always pretty much anything you want to
NPM there's also another thing about NPM
that I don't hear it talked about very
often which is that
I install an NPM package I fail NPM
install and then the name of this
package I want to get that package that
I'm installing is not just going to give
me some code that I can add to my
project it can also run a post install
script and that post install scripts
just arbitrary node.js code hmm any time
you install package from NPM certainly
mean you hit NPM install and download a
bunch of packages they're all
potentially running these things who
knows how many key loggers you're
getting we're just assume the horrible
of this that's the perfect and this
hasn't blown up in our faces yet but it
seems wild to me the notion that that
will never blow up in our faces
I think it's pretty much just a matter
of time I don't know why we're not
talking about this that we thought we
should be how many times a day do you
hit NPM install and just watch it
download all the packages have you
checked all that goes to make sure
they're not malicious I don't
fortunately elm package does not have
that feature so when you install a
package of my own package really all you
get is some Ellyn code that you can add
to your project and that's it it's not
actually capable of running strips like
that but I perspectives this is
wonderful for peace of mind
I remember think about own packages that
it supports encode but not arbitrary
JavaScript so what this means is let's
say I want to make a new element and I'm
like okay cool I'm going to build this
thing and I'm going to publish it and I
write some code and I hit publish it's
like cool Thanks here you go
congratulations you publish your first
package and then I start to do some
JavaScript Interop with that package and
I had to try to hit publish again it
does nope sorry
this is just throughout code that's
that's what this this repository is for
we can do JavaScript Interop through
your application but you can't just sort
of like wrap an existing JavaScript
library and publish it and again this is
on purpose right this is this is the
goal is to create an ecosystem where
these guarantees are maintained and you
can't possibly maintain those guarantees
if it's possible for you to publish
JavaScript the goal is to make an
ecosystem of elsif where all of these
guarantees are respected one concrete
benefit of this is what it means for
versioning so in JavaScript you have no
notion of semantic versioning other than
a social contract right you can say
please follow this semantic versioning
scheme if you make a breaking change
please bump the major version number but
unpackage actually takes this a step
further eventually
enforces it automatically so if I
publish that package and then I make a
breaking change where I glued some
arguments for a function or have it
returned something else or delete a
function and I try to hit publish again
after only bumping the minor version
number it says no sorry this is a
breaking change like if somebody else
tries to compile against your code it's
going to break because you you change
the public facing API you move to bump
the major version number
so it's enforced across the entire
ecosystem like every package in Elm
package has this enforce so there's this
really consistent versioning scheme
which makes the difference in the
upgrade experience like when you go to
update your own packages very different
from the experience in NPM talk to a lot
of people recently who's in complaining
about how they update something in NPM
and a bunch of stuff breaks it just
takes a lot of hair-pulling and time to
just sort of work through all that and
debug their way through all that whereas
an LTAC egde it's very different right
you upgrade and typically if there's no
major version bumps you just okay
everything just works again but even if
something does change then you can just
kind of work through the compiler errors
and once everything compiled again it's
it's all good this is a very different
experience one of the the quotes that I
throw that sort of most directly adjust
this was well sorry ah skip skip aside
we didn't switch to Elm because we were
unhappy with react we switched to Elm
because we were unhappy with NPM and
this definitely resonates with me
so the Detroit offered this moves those
that move that there is less available
off-the-shelf like there there are fewer
packages in the Elm ecosystem because
it's a bulwark for we're really trying
to build something new here we're trying
to build something that's got a
completely different set of
characteristics that the room is going
to be more do it yourself right like
more something where you just don't find
an off-the-shelf solution and you're
either going to light it yourself or
you're going to interoperate with the
existing JavaScript one so for example
if I if I wanted to write a wrapper
around moment.js which is a date
manipulation library
I couldn't publish that I couldn't do it
I would instead have to write a date
library in Purell actually if you think
about it there's some nice consequences
to this so own plot is basically exists
because there's no wrapper around v3
people wouldn't bother building a night
scrapping library if they could just
write bindings for d3
because the preimage it doesn't winter
stuff the idea of real implementing d3
in the new language sounds very daunting
but fortunately Teresa didn't do that
what she didn't said what she said okay
I want to do some graphing in Elm
there isn't an off-the-shelf graphing
solution I'm going to start from scratch
and just think about how nice of a
graphing solution can I make and so this
API is not d3 the API this is an API is
tailored to be nice and L it's using
elements immutable data structures under
the hood instead of the JavaScript ones
which would have to convert back and
forth all of this is optimized to give
you the best experience possible in L
and the results are really great like
this is this is a wonderful library you
did use some nice API and it looks great
and all of this exists because of that
decision to say yeah we're not going to
just wrap the existing stuff we're
actually going to try and do things in
an elm way so this is optimizing for
long term ecosystem quality over short
term ecosystem size so read maps would
have made it to full scale Elm but
that's that's not the normal situation
right most people are either not using
element production or if they are it's
sort of like very early days and so a
question that I get asked a lot of sort
of how do you get to this scale how do
you get to the point where everybody on
the front end team is spending 95% of
the time writing elm and that's what I
give it the full scale Elm begins with
small scale so what I mean by that is
just ship something small and get it all
the way into production just one small
part of once one page and get it into
production and the sauce part is really
key because it forces you to answer all
these questions that otherwise we'll
standards is sort of vague for the
intermediate indefinite barrier between
you and actually using elm all the time
questions like how are we integrated
into our code how will we teach it to
our teammates right realistically the
story that we hear about team
successfully integrating elements you
have like one or two champions we're
really excited about it everybody from
the team is kind of like sounds cool but
we're not really excited about we don't
really know it so there's gonna be some
teaching that's inevitable there's
always some story where people need to
figure out how to teach their teammates
how to get ramped up in this new system
how we build it how will we deploy it
this is something that we sort of took
for granted early on right we were like
oh well it works locally in our local
dev environment
that's it right case closed that we
should have known better that of course
those systems are complicated right
there's a lot of moving parts there and
it's always going to be a little bit
different how you build and deploy it
from how you do it locally but once you
go through the actual work of deploying
even something really small into
production it forces you to answer all
these questions right you no longer
worry about integrating with your
codebase because you did you don't want
to worry about teaching it to your
teammate you can just pair with one of
them as you're going through and setting
up this one small thing and not to
mention you now have the context of
being able to show them look this is
this one part of our code base you know
how this works it's not some abstract
concept that they won't have anything
concrete to latch on to and building and
deploying it once it's in production
you've already had to go through that
whole process so this removes this
barrier and makes it so that you can
instead of worrying about these things
and having these question marks standing
between you and where you want to get
you can instead say okay we'll just
expand from there we've already got it
in production we'll just do a little bit
more a little bit more a little bit more
that's what we did that's how we got
200,000 lines another important thing
about this is that it lets you get away
with introducing in the way that
involves minimal risk so a common thing
that I hear is that people say well
we're going to use them on our next big
project we got this greenfield project
coming up and like that's what we're
going to try out Elm the problem with
this is that that's actually really
risky all right if you're betting your
whole project on a technology that
you've never used in production yet like
that's actually a really big risk like
what if it doesn't go well right now all
of a sudden that entire project is sort
of like tied to the thing that you don't
really fully understand yet you're
actually less risky approach the more
responsible thing in my opinion is to do
it on something small where the cost of
going back is low so if you're just
working on this one small thing so we're
going to get into production the other
day if it doesn't work out you can only
throw back you can always just say well
we tried it and we decided not to use it
all right it's very low cost but
although it is minimal risk there is a
major potential reward but if it
succeeds if you'd if this little project
doesn't make it into production then it
takes and people liked it and they're
happy with it you can then just expand
and expand and expand and then over time
this pays off way way way more than the
initial risk in the initial cost
how we build it I can answer that for us
so initially we built it with sprockets
which is sort of the rails asset
pipeline so our back-end is Ruby on
Rails so we initially did a sprockets
integration but then we had all sorts of
problems with that that we were not
happy with it's not just rail but for
things in general and so we ended up
switching to a web pack loader and
that's so what we're using today at the
end of the day quite a few different
build tool integrations a web pack grunt
gulp sort of like all the big names but
the end of the day if you have something
custom you can always fall back on Elm 8
which is the compiler so all of these
things are just basically interfaces to
Elm make which is just like give me some
vellum files I will spit out some
JavaScript for you so you can always
fall back on that another question I get
asked a lot is sort of like why not use
fill in the blank here instead this is a
good question right there are a lot of
different front-end technologies out
there a lot of great ones and they have
a lot of different codons and so we just
explain why why we're using L instead of
some of the alternatives what reason is
delight this is just like an extremely
warm and fuzzy and impossible to
quantify word but I think it's the only
fair way to describe how happy it's made
our team I'll just give you one example
this and this is from a tweet that
somebody made saying this is the best
error message she'd ever seen this is
this is an error message from the LM
compiler so there is problem this typing
race is recursive forming an infinite
type so you containing a type alias no
two equals so this is basically saying
whenever I write the word note here's
what I mean
and saying okay we have an X which is an
int and a Y which is also an int and
children which is a list of nodes and
it's like okay wait a minute list of
nodes what's the note Oh a node is an X
and a Y and the children which is a list
of nodes wait what's a note okay no it
isn't right so that's the problem this
is this is a compiler error this is when
I expand a recursive type alias it just
keeps getting bigger and bigger
so de listing results in an infinitely
large type try this instead and then it
gives a little workaround it says this
is kind of a subtle distinction I
suggested the naive fix but you can
often do something a bit nicer so I
recommend reading more at and then a
link so the person commented like this
is the basis their message I've ever
seen and be perfectly honest I mean this
is kind of like where the bar is for LM
error messages like the compiler really
I'm putting comfortable things that's
the gold standard like I have been
reading more and more blog posts about
different languages saying we're trying
to make our messages more like Elms and
this is why like it's it's really nice
working in this all day there was a
quote somebody reply to the tweet that
should be an inspiration for every error
message and this is someone who you may
have heard that who kind of had some
experiences with type-check languages
this is John Carmack commenting on this
so definitely agree with mr. Carmack on
that one it's it's really nice so dart
is one remote ability is the other and
so I want to talk about a couple of
different classes of languages that have
various different alternatives to
reliability and what sort of set sets
Elm apart from them so type scripts flow
and dart are all languages or I guess
close with the type checker that sort of
introduced without changing JavaScript
semantics a ton a type system so a
common thing to people ask is like well
why would I use them both I could just
have typescript
plus immutable J's plus babel Burnap
Evelynn type scripts case but why can't
I just like do I build my own Elm why is
that
you know what's the difference so we'll
talk about typescript for a second so
here's some typescript code this is like
the try typescript website so that
little bit of typescript on the left as
far as reading equals hello devoxx stay
alert greeting duck trim I can hit run
see how the Wi-Fi is doing great how do
I walk so that's that's all this code
does now what I can also do is I can
also add a type annotation to this right
I can say this is a string and that will
compile great Howard's a box cool now I
don't have to do another thing which is
I can save for original colon string and
then I can set this to be equal to
original so all I've done here is I've
just introduced a new variable and I'm
just passing if your original the string
it's called hello today box
greeting is also a string which is just
set equal to original so hopefully this
will still run of course great now let's
say I want to change this I change this
to from hello there walks to five okay
and this should not compile which it
doesn't
which is great because there's a
mismatch right so type 5 is not
assignable to type string for an
original string right so that's correct
right that's fine is not a string and in
fact if I were to try and run
Kota would crash like it would call trim
on 5/5 does not have a method called
trim so listen crash so it's a good
thing to compiler contest excellent now
I'm going to change this string to any
now compile everything time nothing is
broken and when I run it straight off
run time exception glue to lab trim is
not a function I'm sure it doesn't have
that function so what happened here why
would this work why did write in
typescript except my code and then crash
the literature is there any keyword
right so the ending type is this magical
escape hatch that says okay just
thinking about everything except me I
know what I'm doing but I did not know
what I was doing I told her it I knew
what I was doing and I was wrong
and so the result was a crash so I'm
going to keyword is sort of this big
escape hatch that makes things sort of
more convenient short term but less
reliable long-term right so like any any
code that I write that uses any is
susceptible to crashing in this way also
any library code that I import that uses
any is susceptible crashing in this way
also I have no way of telling which if
any of my library code is using anything
so you consider like just don't use it
like just have a rule on your team never
used any and then you can also say just
have a linter rule that says absolutely
nobody on your team can use any but it's
pretty wide to say also don't use any
library to use it because that basically
closes you off from the whole ecosystem
consider definitely type so this is the
repository for high-quality typescript
type definitions
it's called definitely types which we
really I read that as everything in here
is definitely typed but amy was actually
considered part of its best practices
like it actually has a whole section on
there on their webpage about how to use
any properly in in this ecosystem and
the problem with that is that any is not
definitely typed actually that's this
whole point is to say this is not
definitely type trust me I know what I'm
doing but I mean the only thing you get
from definitely typed or from any type
script code potentially it just has
these like working runtime exceptions
again LM doesn't have it l doesn't have
any elm doesn't have that escape hatch
it says no no seriously we're going to
take reliability really really seriously
so these will give you
Fuli grant less crashing than playing
JavaScript like that there ways that you
can do checks ahead of time to prevent
certain types of crashes but if you
really really want this zero runtime
exceptions that we've got for almost two
years at this point running you know
running home I think there's really kind
of like only one place you can go now
another reasonable question is okay what
about a different functional programming
language right there the opportunity is
that the diverged from JavaScript
semantics like Elm does that will also
compile to jazz so why not then I should
preface this by saying that like I think
FP languages they compile to jazz on the
whole are pretty sweet and I'm not
saying this to discourage anyone from
using them but I really like to compare
you know like why not use them instead
of L so if you read capsule we should
probably check out pure scripts or gh
DGF so a pure script is sort of designed
from the ground up to be compiled to
JavaScript it has very Haskell like
semantics geo tjs is literally a subset
of Haskell ported to JavaScript so it's
even closer to Haskell if you had camel
you should probably check out either
reason or buccal script so reason is
just a syntax on top of a camel that
makes it more sort of JavaScript
flavored and does some other things
Kepler script compiles a camel code to
JavaScript so putting the two together
you can get a camel code that compiles
to JavaScript Scala if you have Scala
you will be surprised to learn you
should check out Scala j/s and if you
like closure again big surprise
close your script might be of interest
to you so how do these compare to Elm
like so from your script does the same
kind of optional typing like there's a
core typed module but again if this sort
of off by default all the api's are
defined in terms of dynamic typing so
kind of the same boat as like type
scripts dart etc so if you really want
like the no runtime exceptions
experience this is probably not the
right place to look
scholar Jes has a type system but it
does have the the billion dollar mistake
right No
so again you can make a rule thing don't
use it but you know libraries that use
are still probably going to have it and
that's a potential source of crashes you
can peer script no reason both have land
base in the language but all four of
these it's true that anything can run
arbitrary JavaScript code so I talked
earlier about how Elms Interop system is
designed to isolate JavaScript code so
you're guarantees are really really
solid inside your elm code but all four
of these don't have that they have the
typical FFI story where the idea is that
in the middle of any function in any of
these languages you can just call
arbitrary JavaScript code at which point
kind of all bets are off when it comes
to reliability and enforcing those
guarantees so really if you want this
experience there really is only one
place that you can go at least at this
point in time maybe that will change in
the future but for now it's really just
Elam that takes reliability that that
degree of seriously another question I
get a lot is how do we hire anyone like
this is the new language right this is a
relatively like this small hiring
pipeline right like how many people out
there really know Ellen really are using
L so hundred eleven developers in 2016
and nine of them actually cited elements
of reason for applying so it might
surprise you to learn that actually
hiring was much harder before we used
elm we're actually not sure how we ever
did it before so it turns out that
although there is a relatively small
number of people who already know Elm is
actually a pretty large number of people
who want to learn Elmer who want to be
using it in production and as long as
you're okay with having them ramped up
and we found it easy enough to ramp up
that we actually have our you know
people who hire people straight out of
boot camps who write Elm in the first
week this to be absolutely fine and as
for why we get such a volume of job
applicants think about this which which
of these job posts stand out hiring for
Reax redux mules jfl
higher angular 2 types de panda or want
to write a lobby
it's a bit of garbage right there's
always some people in this room who just
thought yeah it does actually sound
pretty good by the way we're hiring if
you're interested in that and that's
pretty much all we have to do in order
to get way more job applicants than we
ever did before on our front end
positions another question is how are we
teaching right so obviously more new
hires are going to know react in elm but
we haven't actually found since we do
know react from back in the days when it
was do it and basically were hiring
people who did not know react who had to
get ramped up the pretty similar time to
becoming a production contributor
comparing someone who doesn't know react
and has to learn that because remember
the whole ecosystem that goes with react
versus someone who doesn't know element
is getting
the speed on that and to be honest I
think a big part of the reason that it's
the same or at least similar is that the
compiler aids beginner learning a lot
like obviously you're learning a whole
new language new semantics there's a lot
more to learn that you also get a lot
more help with those really friendly
error messages those help beginners a
lot okay finally I just want to do with
some resources too if you're interested
learning more about Elm
guide on Elm languorous or the official
guide that's always a great place to get
started there's a blog post called how
to use element work on the Elm website
that specifically talks about like how
to go from having an all j/s code base
to introducing el cura plug I'm reading
a book element action for Manning
publications it's about not not overly
done yet but you can read several
chapters already there's training
available I can recommend three people
Luke Wesley and humble Sparky is
actually the creator of le which is
written in El muddling Brian Hicks an
asterisk II created Elm benchmark which
is like the awesome benchmarking library
Chris Jenkins from London he created a
road data which is a popular library for
dealing with from Road data there's a
podcast called Allentown run by Murphy
Randall he's awesome he's great host got
the dozen or so episodes at this point
probably lots more coming out there's a
very beginner family community out there
so the reddit subreddit has a weekly
beginner question so it's a sort of like
hey just come ask easy questions and you
know people will answer them there's no
like with like a lot of members a really
helpful beginners channel and finally a
lots of meetups so we had they like to
customize the Elm logo to fit their
their local meetup style so these are
pretty creative and and also what
mmunity events in the form of
conferences so we just said LM concert
in st. Louis
back in September there's going to be
another one next year also attached to
strings loop LM Europe and Paris is
coming up in June there are still
tickets available for that I believe but
I know it's capped so they got to be
careful about that so finally the open
house in our team do this like how can
we get this going
remember folks PLL gives with small
scale so ship something
well done in the production watch a girl
thanks very much questions yeah yeah
what's the mobile story huh so I guess
interested in that question is like
what's the how do you make stuff really
small and like lazy load and only load
the resources necessary because every
time that it's like this is JavaScript
that is compiling too so that's actually
the focus of the current releases asset
management so the goal is to make like
code splitting with lazy loading like
really really easy server-side rendering
up that's necessary that's like so
probably going to be coming out this
summer and because a lot of people are
asked that question so yeah that's uh
that's very much the focus of the
current release yeah so so the
server-side rendering which is an easy
problem and then there's on the server
side which is a wonderful project if you
want to do a good job at it
so basically Evan ship linking is the
creator of Elm he sort of said that if
we're going to do Elm on the server side
he wants to be really ambitious about it
and not just say this is Elm except
literally on the server he wants to say
like how do we make a really great
server-side experience like from the
ground up and so there's like a lot of
design work a lot of questions about
like what's the right target platform so
Elm is really serious about concurrency
which is kind of wasted in the browser
because a single-threaded but it's
designed at least to have really
powerful concurrency abstractions on the
server
someday so then the question becomes
what do you want to compile it to if you
compile it to JavaScript you're still
only getting one thread and so you're
wasting a lot of that so it seems like
some alternative makes sense which
alternative so there's a lot of
questions out there so to make a long
story short I think that's a couple
years off but I think when it does land
it's going to be much more than just you
know letting you write the same language
on client and server which is awesome
but it's also going to be hopefully an
awesome language in its own right place
that's the goal
yeah
well yeah we've gone through many
upgrades so we're on Elm 0.18 when we
started it with 0.15 so I guess we've
gone through for like major breaking
changes so basically uh number one the
compiler helps out a lot number two
they're like community tools that help
out so the most recent when it was
called one called Elm upgrade and it
basically like there was some syntax
changes and I just like went through all
our code and just like upgraded the
syntax has changed it so long story
short yes there have been breaking
changes to the language and though they
haven't been a huge problem yes well I
didn't but yes someone else did
I would say it depends on what you're
doing right so implicit in the like
client-server like metaphor of
relationship is that some things are
easier to do than others alright so in
the same way that talking to servers
some things are just really easy to set
an end point and then it like gives you
back what you want if you need to do a
lot of coordination like back and forth
back and forth back and forth that gets
more complicated so it really depends on
what you're doing so for visualizations
it usually tends to be fine because you
can just say like okay here's the data
that I want to visualize go and then I
care about these four events so just
tell me when when the user does these
interactions and then I'll handle them
but like I said it really so is if
you're doing something like newly heavy
like numeric computing where you need
the like some I don't know like some
cryptographic I don't know if I should
be doing photography in the browser but
something where you need to like call
out to just like one function like over
and over that gets this more trouble but
yeah I mean different for everyone
behind like there was just that like you
can do that you know for your
application like if you're just like we
have some code or we want to use this
existing library control we interoperate
with that locally but you can't publish
it right so that's the idea like let's
let's make an ecosystem that that has
respect to the set of guarantees other
questions all right and we're only
slightly over on time thanks very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>