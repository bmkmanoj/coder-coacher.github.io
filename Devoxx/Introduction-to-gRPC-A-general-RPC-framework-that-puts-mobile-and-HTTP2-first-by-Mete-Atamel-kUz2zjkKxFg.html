<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Introduction to gRPC: A general RPC framework that puts mobile and HTTP/2 first by Mete Atamel | Coder Coacher - Coaching Coders</title><meta content="Introduction to gRPC: A general RPC framework that puts mobile and HTTP/2 first by Mete Atamel - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Introduction to gRPC: A general RPC framework that puts mobile and HTTP/2 first by Mete Atamel</b></h2><h5 class="post__date">2016-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kUz2zjkKxFg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone so this is the last
session of the day thanks for sticking
around and I'm going to talk about G RPC
but before I start my talk a little bit
information about myself my name is
Matata Mel I'm a developer advocate for
Google cloud platform I'm based in
London what a developer advocate means
is that basically I come to conferences
and give talks about Google cloud
related technologies I also try to talk
to developers get their feedback about
Google cloud and bring that back to
engineering so if you if you are using
Google cloud or or if you have any
questions feel free to let me know this
is my Twitter and my email so even after
today again if you have any any
questions about the top today or about
Google cloud in general feel free to let
me know so the agenda we have today is
first I'm going to do a little intro to
RPC I mean most people probably know
about RPC here but will will make sure
that one is on the same page and then
after that I want to talk about a story
or building an RPC system because it
might be one of my previous jobs I
actually built an RPC system and I think
it's important to talk about it because
it's hard to appreciate a framework like
GRDC if you don't know what goes behind
the scenes in an RPC system so by going
through that story or building that
system hopefully you'll get to
appreciate what G RPC provides to you so
once we cover that we're going to talk
about what is G RPC what does it
actually provide to you and then I'm
going to show you some code and then
after the code we're going to talk about
the benefits of G RPC so what it
actually get gives you on top of the
features like what's the what's the
underlying themes like HTTP to
multi-language support stuff like that
and then finally if you have some time
we'll look at some more code so this is
the agenda so what is remote procedure
call I just want to cover this so that
people are all on the same page so
normally this is a regular procedure
call so imagine you have a greeter
service that has a say hello method and
it's very simple it takes in a text as
string and returns a string as well
if you want to use this from a client
let's call it greater client you can
create the service and then you can just
call the method on it with the with the
parameter and that's it you know this is
what we do then everything is in the
same machine that's the box it's the
same machine and you know this is simple
life is simple now our PC Wikipedia
definition is this so our PC is a
protocol that one program can use to
request a service from a program located
in another computer in a network without
having to understand the network details
there are two keys heat key things here
one is you know you have two computers
now you don't have everything on the
same single machine and you want to make
a call from one machine to another
machine but the key thing is that you
you want to make that call in a way so
that all the details of the connection
are abstracted away from you so you
don't care as the client
you know how the connection is being
made what the state or the connection is
you just want to make that call as if
it's local so that that is what RPC is
it's like it's a procedure call as if
it's local as if it's on the same
machine but it's not local it's on
another machine but the RPC framework
takes care of abstracting all of that
complexity from you all right now so our
simple example now it kind of looks like
this now so you have you can call it
machine running machine to or you can
call it client and server whatever you
prefer but you have the server's running
on a different machine with the method
and then you have the client and client
needs to call that service right now
conceptually this is simple but if you
think about it there are many things
that you need to answer now for example
how do you expose that service how do
you tell to the world that I have this
service and it has this method and
people can call this method how do you
make the client be aware of that service
once the client knows that service
exists how do you make the connection
how does that look like you need to also
send some text to the service right so
how do you realize that because at the
end of the day what you need to send
over the wire is just bytes so how do
you take your tag
converted to bytes what what does that
encoding look like so even though
conceptually it looks really simple
there's all these questions that you
know that comes up that you need to
answer now at this point I want to
switch to my RPC story so the new
motivation of the story is to tell you a
system that I worked on that where we
built an RPC system and then through
that we'll see all the complexity that
comes with RPC systems so this was back
in 2006 I had a I had my first job out
of college I was working for one year
but then the the job was a software
engineering role but it turned into more
like a support engineering role where I
was kind of on call all the time and I
was responsible for services that I
didn't write and people would call me in
the middle of the night and say this
service doesn't work and you fix it so
it's I had enough of that job and then
at the same time someone from Adobe
calls me and says you know we have this
new thing called Adobe flex I don't know
do you guys know whether we flex yeah
you remember yes yes yeah ellaby flex
was great so the goal of whether we flex
was you know flash at the time was
virtually on every single device but it
was mainly used for games and Adobe
wanted to turn that into a platform so
that people can write applications in
flash so not just Gainsborough
applications and they created this
notion called rich internet applications
because back in 2006 HTML and JavaScript
was really basic and flat flash is
really rich you can you can have great
UI with flash and using other B flex
they created all these components and
all these things to actually build rich
Internet applications so that's the team
that I started working and of course
with every with every client you need to
connect to some server right so j2ee
at the time was really popular it was
like kind of the main thing that people
did so there was this other product
called flex data services I don't know
if people know about that or use that
but basically it was a j2ee application
that you could drop in your app server
and it would it would make the
connection from flash your Flex client
to Java backends now to make the
connection we had to build an RPC
framework so I just want to go through
that process and tell you the design
decisions and all the new constructs
that we had to go ahead to create to
make that RPC system now the first thing
is so we have the j2ee server with the
service that we want to expose to our
clients but we also you know in a
typical use case you also have some
private services you don't want to
expose everything that you have on your
server by default right so when you have
these services and you have your flash
client to talk to that service how do
you actually define what's public and
accessible to clients and and what's
private and it should stay private
so the first thing that we had to create
was this notion of destinations
so if destinations was an XML
configuration that you could define on
the server and in this XML configuration
you'll basically say these are my
services these are the public methods
that you can call and you will by
listing it in these destinations you're
basically making them public to the
world and then this destinations XML
would also be baked into the flash
client and then the flash client will
use users destination and contact the
server so this was the first notion
destinations that we created now you
know the destinations but you need to
make a call to the server so I don't
know if you guys know about ActionScript
has anyone use ActionScript before yeah
great I still love ActionScript even
though I don't use it I think compared
to JavaScript it's much better it's
strongly type it's unfortunate that it's
not used that much anymore but
ActionScript was the main language for
flex so in ActionScript we created this
thing called remote object so what what
you would do is you would create a
remote object and specify the
destination that you want to talk to and
then you would just call a method on it
as if it's local so you just say you're
not object on say hello and pass in your
hello and actually this reward object it
was a proxy object it didn't really have
this say hello method what we what we
would do is that we would we would
intercept a call and create a remoting
message with with the meditate
so then the remoting message will have
you know destination ID it will have the
name of the method and it will have the
parameters and we will see realize that
remoting message send it to the server
the server will get this message this
relies it and then it will check the
destination ID if it exists it will
forward it if it doesn't it will send an
error back if the destination exists
then it will check for the method that
you want to call
so if say Allah exists which exists in
this case it will let it through if it
doesn't exist it will return error and
then it will also look at the parameter
so if you test in a text then it will
pass it through but if you passed in
let's say an integer it would complain
about it so in so we created remote
object we created remoting message we
had to sterilize these remoting messages
and then we have to deserialize them we
had to add all this error checking on
the server side so as you can see there
there was a lot of things that we had to
implement but life was good we made the
connection from flash to Java world and
it was simple enough to use it and we
were happy about it until the product
manager came up with a new requirement
so our product manager at the time told
us that you know this is great now we
can talk from flash to Java and we can
pass in objects we can expose methods on
the server side that's great but we have
financial services customers and
financial services customers they want
to stream a lot of data from server to
client client to server because they had
to do like stock stock applications
where there's like topics and and and
subtopics and people subscribe to those
topics and get stock update stuff like
that so he said we need something new
not just remote observer we need
streaming and we need pub/sub messaging
that's what we need so we had to go back
to the board and design that so what we
design is this so we created topics and
subtopics so if you guys know about JMS
so it's similar to that and we also
created the this new two constructs
consumers and producers so the producer
will talk to a destination this
time is a messaging destination and then
it will send a message and then the
consumer will will subscribe to a
destination and get updates so the new
constructs here is that the consumer
producer the messaging messages and and
these topics and subtopics and we also
we were also using AMF so for the
encoding we could have used XML that was
like the main thing at the time but we
use AMF which is which stands for
ActionScript messaging format I think
it's a binary protocol it's much more
efficient than plain text so that's what
we decided to use and we were using HTTP
as well
now the problem in this case was that
you know how the consumers get messages
because in remote object case you make a
request and you get a reply and it's
simple in consumer you subscribe to the
destination but you need to somehow get
those messages when the producer sends
the messages right so in that case you
have two choices you can either as a
consumer ask for messages in a periodic
time or the messages can be pushed to
you somehow but for that to happen you
need a TCP connection just HTTP
connection wouldn't work in that case
the other thing we had was okay we are
using HTTP but can we use something else
because in streaming cases you really
need a TCP connection and at the time
flash had a protocol called rtmp I think
which it stands for real-time messaging
protocol that is mainly used to send
videos but we also thought we could use
that for the data as well so you know
maybe instead of HTTP we could use rtmp
so all of these choices they led us to
another construct called channel so we
said maybe we need channels to define
all these different choices that we
could make for the connection between
the client and the server and then we
created lots of channels so we create an
HTTP channel for the regular request and
reply we created HD the poling channel
where the client asks for messages every
X seconds we created long polling
because polling is not efficient you you
pull every three
if you don't have any messages you're
just wasting requests whereas in long
polling you Paul and then if there's no
message you keep the connection open
until you have messages so we created
that we created HTTP streaming which we
which is a server to client connection
so you decline makes a connection and
the return is kept open for the server
to push messages it works in some cases
but in some cases like load balancers
they don't like it but we for customers
who could use it we implemented that we
used rtmp I am sorry 10 P was basically
a TCP connection between flash and the
server and then later after like a year
or so WebSocket came along so the web
WebSocket is the real-time HTTP protocol
which is also a TCP connection so when
that came along we also implemented that
so in the end this is what we had so we
had for messaging we had consumers and
producers for remoting we had remote
object on the server we had topics and
subtopics then we have our services that
we would expose through destinations
then we have different channels rtmp
channel HTTP Channel long polling
streaming all the kind of stuff for
encoding we use AMF and then we have
this all these different kinds of
messages remoting messages and messaging
messages going over the wire as you can
see it's getting complicated
but life was good again you know like we
could do a lot of things here like it
was we could and we had lots of
customers doing different things using
this framework and it felt good until
this guy came along and I don't know if
you guys remember but in 2010 Steve Jobs
came up with a public letter and it's
still public it's on still on the web in
you can read it and it said the title
was thoughts on flash so basically he
wrote a letter explaining why flash
wouldn't be on iPhones ever he had some
good reasons because the performance of
flash on mobile wasn't great some of his
points were kind of exaggerated but
either way the big point was that flash
would never be on iPhones and that and
for the world I mean the world is was
moving from desktop to mobile at that
point so that was a big
blow for for adobe and flex and stuff
like that so what happened afterwards is
that flex basically slowly started
disappearing from mobile the Flex
framework and the flex data services
that I was working on it was open-source
but then they really didn't go anywhere
at acting they lost momentum Adobe even
Adobe they shifted focus from flash to
HTML and JavaScript and as for me I
moved to another company and working on
different problems not flashy related
but the thing is I still had problems to
solve with RPC you know so when I start
working in this new company I was back
to square one you know I had to answer
these questions like how does a client
call a service on a remote machine how
do you expose the service so that the
client knows about it how the data is
serialize and deserialize what's the
nature of the call is it HTTP is a tcp
is it web stock what is it
authentication how do I do the
authentication so all these questions
that I asked and implemented in flash
they were gone like I couldn't use flash
anymore but I had to do I had to answer
them again I had to implement them again
so I felt like I went back in time
basically so at this point you have you
really have two choices we likely see
you can build your own custom RPC
framework you know if you have the time
and if you want to you know invest time
and effort into it you can build it and
the good thing about that is that it's
it is exactly how you want it to be so
when we were building the flex data
services and the RPC framework there we
really liked it because we we started
from scratch and built this thing and it
felt beautiful because it is exactly how
we want to want it to be but the
disadvantage here is that as you've seen
like when technologies change things
that like you need to answer all these
all these questions that I talked about
and when technologies change then then
you need to really answer those
questions and build code again and
that's not so great
thankfully there is another choice which
is G RPC so G RPC said it's a
high-performance open-source Universal
RPC framework that's out there that you
can use the good thing about that is
that it's all the questions that that
we asked here they are already answered
and implemented in multiple languages
for you so you don't have to you don't
have to answer them you don't have to
think about them they're already there
the disadvantage is that our PCG RPC has
a certain style that you need to get
used to so you need to you need to like
that style and I'll show you some code
how that looks like so you need to add
up to that style but that's that's okay
because in every software reuse case you
need to like or you need to at least
adapt yourself to work what you're using
all right so so this is your PC but at
this point you might ask to yourself
why don't we just use rest you know like
we know HTTP rest it's it's well
understood
you know the HTTP works like get post
put delete they're usually rich enough
for for the things that you want to
implement so why don't we just go with
that and my answer to that is you know
if rest is good enough for you go ahead
and use it you know it's simple there's
many benefits of rest like you know it
caches really well things like that so
if you can use rest use rest but when
you think of complex scenarios imagine
you want to do like a bank bank transfer
for you want to transfer money from one
bank account to another bank account if
you want to do that with rest you can
probably do it but you'll probably need
like multiple rest edge TP requests and
and the client has to worry about you
know making this require HTTP request
making sure that they succeed there's
lots of details there that the client
shouldn't care about instead if you use
RPC you can create a bank service and
you can create a you can have a method
on it that says transfer from this
account to this account that amount and
you can abstract away all this
complexity using RPC so that's what
that's what I like about it is that in
complex scenarios it helps you to
abstract and and make it look like it's
a local call for the client even though
it's not local and the second thing I
like about RPC is that it's strongly
type so the client using stubs talks to
talk
to directly service using a stronger
type object so the client doesn't have
to worry about creating HTTP requests it
only cares about talking through the
stub and I'm going to show you some code
shortly to let you know what I mean all
right so this wraps up the first part of
the talk where I kind of give you the
motivation of why G RPC so as you seen
like there's a lot of details that you
have to implement yourself if you have
to do it yourself or you can rely on
GRDC and let Jerry PC do the heavy
lifting for you so in this part of the
talk I just want to go through the
details of GRDC so G RPC as I mentioned
it's an open-source project but it
actually came from something called
stubby stubby it's an internal IPC
system used at Google and it's used to
do I guess 10 billion whatever that
number is RPC calls per second so it's
used a lot at Google so what we did is
that we basically looked at stubby and
stubby is really tightly coupled to our
internal systems so we can just take it
and make it open source but we basically
looked at it and said ok what did we
learn from stubby and how can we take
stubby and bring it to open source so
that other people can use it as well so
G RPC basically came from stubby so the
team who worked on stubby they created G
RPC using the learnings from stubby so
in that sense it's the best of both
worlds
so G RPC is open source but it didn't
start from scratch
it came from this a stubby
project that we use a lot internally and
the goal of gr PC is basically we want
it to be we want a RPC to be really
efficient because if you are making 10
mil 10 billion calls per second every
millisecond counts so we make sure the
connection is really efficient we make
sure that the encoding or the wire is
really efficient if you want it to be we
want you to be able to use G IPC no
matter what language you use so it
multiple languages are supported its
performant and scalable and also micro
services I mean you probably heard a lot
about my resources here and in every
Java conference that we go to nowadays
you know you we are breaking down on all
of us into smaller micro services but
then the problem that you have with
those micro-services is that they need
to still communicate so you want to make
sure that communication is really
efficient so G RPC is actually designed
for that so and I'm going to show you
what I mean with examples but basically
when you have my services like and if
you use a RPC the connection and the
serialization over the wire and
everything about is really really
designed for that so this is one slide
that basically it tries to summarize G
RPC like in just one slide first what
you have in G RPC is is a service
definition so in in this service
definition it's a protocol buffer
definition you define what your services
and you define what your methods are on
that service and what these methods take
like what are the inputs and outputs I
really like this because by just looking
at the service definition you can you
can get an idea what your system is so
you don't have to look at the classes
you know you don't have to look at the
generated code you just look at the
service definitions and from there you
get an idea of what your system looks
like and I'm going to show you some of
these later so from the service
definition you generate code so you
generate client-side code and
server-side code and this code is can be
generated in like 10 plus languages this
is also great because you don't start
from scratch
you get like a starter code that's given
to you by G RPC and then you can just
extend from that code and get started
with it that way in terms of
civilization it uses protobuf so
protobuf is the efficient binary
serialization format so that gives you a
fishin see in what goes over the wire
but also the connection uses HTTP too so
HTTP 2 is designed for making user feel
like latency is good and actually there
was a talk I think it was like last
hours that talked about HTTP 2 but it
basically tries to use HTTP 2 for the
connection so you get the efficiency in
connection as well
and then for the Kinect for the actual
connection itself you have multiple
options so you can have unary connection
which means request and reply but you
can have server-side streaming you can
have client-side streaming and you can
have bi-directional streaming so for
imagine a chat application for example
where the client and the server they
have to send messages to each other you
can you can have that as well and then
for authentication you can have multiple
options I get a cell and token-based
authentication so as you can see like
all the questions that I asked earlier
they have answers to them which is nice
and then if you look at it in a
graphical way so you as I said like
there's multi multiple languages support
so you might have a C++ service and a
ruby client and Android based Java
client you generate code stubs client
stubs that the client uses and then you
also get some boilerplate code for it
for the server so once you have these
codes then you can just extend from them
and then this stub talks to the server
using proto it makes a request gets a
response stuff like that all right so
let's let's look at some code now so
imagine the hello world case that I
talked earlier where you have a service
called hello hello world that takes in a
text and returns the text if you want to
implement that in GRE PC how do you do
that so I'll show you that here in four
steps first you need to create the
service definition file as I mentioned
so the first thing you do is you create
an example service dog proto here
usually we are saying that we have a
service called greeting service and then
it is a RPC method called say hello and
it takes in a Hello request and returns
the Hello response so it's very simple
just one method and it has it has one
parameter and returns one parameter now
of course we need to define what the
requests and responses would look like
in this case our request is a message
and it has a string name so it's
basically just a string and then it has
a response which is also a string but
these requests and responses they can be
complex objects and I'm going to show
you an example of that but for this
example they're basically you're
basically taking a string and
during a string so once you have this
photo you're you define your service
from here you you generate code so if
you are a maven user there is a
prototype of maven plug-in and if you
are a great little user it is perturb of
created plugin so using these you just
point to the service definition file and
this creates the client stubs and some
server code for you to extend from the
third step is to actually create this
this server so the server implementation
it's really easy you just extend from
the generator base class that the proto
protobuf generates for you and then you
specify the port and then you also
specify a service implementation so you
need to actually define what the service
does so that's the service
implementation and you start the server
and that's it so the three things here
is that you extend from the base class
you specify the port and then you define
the actual service itself and then start
server and then the last part sorry the
last by this creating the actual client
so the client is a little bit more
complicated because you need to actually
define how you're going to connect to
the server so for that they also have a
notional channel so you create something
called ml channel for the connection
from the client to the server then from
the from the channel you need to create
a stub so the step can be blocking or
non blocking in blocking stops when you
make a request to the server the the
call basically will block until you get
a response but you can also create an
onboarding stop where you know you
install a blocking call you actually get
a callback so so you create your stub
with the connector with the meta channel
then you create a request and then you
send the request using the stub and then
you get a response from the server
either in sync mode or async one
depending on your step and that's it
that's it really so let me just show you
this quickly in Eclipse so here I have a
project called simple G RPC server
and simple jar PC client and then first
thing let's look at the proton object so
this is this is the service definition
one thing to note is that first the
syntax I'm using is proto 3 so proto has
different versions but g RPC uses the
latest one which is per 2 3 and then you
can define packages so this package will
basically be used for the generated code
so the generated code will have this
package name i also specified this java
multiple files when g RPC generates code
by default it puts everything into a
single class I don't like that because I
like things to be separate so by setting
this flag I'm getting classes in in
multiple files now let's look at the
service so the service like I showed in
the slides
it's called greeting service and then we
have the greeting method takes in a
Hello request in terms a hello response
now the Hello request in this case is
it's a little bit more complicated so
instead of just being a string name we
also have H that's an integer we also
have something called repeated so this
is a list in G RPC so we have a list of
string for hobbies and you can also have
a map so in this case we have a map of
key n values and you can even have an
enum so in this case we have an enum
called sentiment so the the request is
basically about a person with name age
hobbies and sentiment and then the
sentiment has to be defined so we
defined the sentiment here as enum
sentiment happy sleepy angry so this
this is our request and then the
response is just a string so we'll we'll
get the request and the response will
just be a string from that so this
defines our service and then from here
if you look at our pump file
you can see there is a prote above maven
plugin I'm using maven here so this
plug-in will look at the service
definition and it will generate the code
for us and if you take a look under
target generator sources you see that
there's a lot of code here that's
generated for you this is a great news
because this means that this is a code
that you don't have to write yourself so
all the connection details all the
things about making connections sending
the requests serializing this noise and
all the kind of stuff is done for you
and if we look at the code itself
it's not it's not great I mean I don't
like generate the code and I don't look
at it usually but if you want to look at
it is here but usually you don't care
because you're in Eclipse you have
strong types so you can just you can
just use like code hinting and find what
you need to find you don't have to
actually look at these classes yourself
the important thing is that so let's
look at how we create the server server
so this is my mighty RPC server so this
is the class that you have to create
yourself and if if you look at here what
we do is first of all we need to build a
server so here I'm using server builder
this is something given by G RPC to me
and I'm saying I'm going to use this
port so I'm using port 8080 and then I'm
adding a service and then passing a new
greating service implementation so this
is the guy this is this service
implementation is going to define how my
service works and then we're gonna look
at that shortly and then from there I
just do build so everything in G RPC is
through builders so you build builders
and then and then you call build on them
to get the actual object so this is
something that you need to get used to
if you don't like builders but that's
how it is so once you have a server then
all you all you need to do is just call
start and service starts now the
important part is this creating service
implementation because this is the guy
that actually defines what our service
is going to do so let's take a look at
that it's right here so one thing to
note here is that the the service
implementation extends from this base
class so this is the base class that was
generated by G RPC for us so by
extending from this you get this
greeting method that you need to
override
so so this came from the service
definition the service definition
basically defined what this greeting
should look like for us and all we have
to do is just implement this method and
we're done so in this case the great
thing takes a request and returns there
what's called a stream observer so this
is basically the the response to the
client and what we're doing here is that
we we take the request and then we
create a strict greeting from the
request so we say hello there
and then this request object it's
generated by G RPC for us and it
strongly type so if I do this like
because dot I can see that it's it's get
age get back all trips tricks get name
so you don't have to actually look at
the request object from from here you
can figure out what you have access to
so here what we are getting is basically
just the name from the request and then
we need to generate a response to the
client so what we do is hello response
dot new builder everything happens to
rebuilding G our PC and then once you
have the builder you call set greeting
and then pass in the degree that we just
created and then to build so now you
have a response that you can send to the
client and then you just use response
observer so response observer on next
will basically send the response to the
client but it's not committed yet so
then I call uncompleted to make sure
that the actual response calls to the
client so this is this is it for the
server as you've seen all we had to do
was build a server with a service
implementation and then we defined the
service implementation in the other
method and then call start on the server
and that's it and then the service
implementation it extends from the base
class that was generated for us and from
that we know that we need to limit this
method and then here we basically just
define what we want to do and then
create a response and send it back now
to look at the client side
so this is the client site so what you
need to do is first you need to create a
channel so you need to define how the
client is going to talk to the server in
this case we are saying we are using
this channel builder and then we are
saying talk to this host and the port
and the host on the port our local
ozonated here I don't want to worry
about HTTP and certificates and stuff
like that here so that's why I'm using
use plain text true so this basically
tells Jerry PC that you know this
channel is for HTTP but in real world
applications you would use HTTP but for
this time I'm just using HTTP and I just
called built so I have a channel that I
can use now from the channel I need to
create a stub that the client needs to
use so in this case I am creating a
blocking stub because I want to make a
request and make sure that I get a
response
I want that to block so I just again
using the generated code I just say okay
give me a blocking stub and use this
channel when you make that connection so
this stub will use this channel
basically to talk to the server so now
now that I have stub basically that's
all I need to worry about as the client
like the client talks to the server
through the stub now what I want to do
is I want to send a request to the
server so again I get I go to my hello
request that was generated for me get a
new builder and then from the Builder I
have all the things that I can set on it
right like all if you do the top set you
can see all the stuff that I can I can
set on it in this case I'm setting my
name my age my sentiment is happy and I
do build so I have my requests and I
just basically do stop dot and then it's
strongly type right because because
everything everything is strongly typing
in jpcc so from there I know that I have
this greeting method that I can pass in
a request so I just called greeting and
passing my request and since this is
blocking it will basically block here
until I have a response and once I have
a response from the response again it's
strongly typed so from the response I
know what to get I'm getting the
greeting so basically I'm making a
request and then I'm getting the
greeting from the response and then once
you're done you just shut down the
channel so that's it let's just run this
quickly so that you see that it works so
go here so server restart it on port
8080 and the client now when I run it it
will create the request send it and get
a response sending requests receive
response hello there and my name so it's
very simple and let me just stop the
server I'll go back to my presentation
so this is like hello world in G RPC now
I want to talk about the benefits like
so what benefits do you get by using G
RPC other than just the generated code
for you and the benefits is number one
HTTP 2 so the whole point of HTTP 2 is
low latency transport or content so
there are many features in HTTP 2 that
tries to make the you end user perceived
latency much better than HTTP 1 1 or 1 0
and actually there was a talk before now
that talk much more about this than here
so if you're interested make sure you
watch that video it was a good talk one
of the things that's important in HTTP 2
is that it tries to use a single
connection because normally if you want
to make a little request to the server
you make multiple connections but here
in HTTP - there's a single connection
and there's true multiplexing what that
means is that if you send so let's say
you send three requests requests one
request to request three if requests one
takes a long time then your request two
and three will will block basically
before HTTP - but in HTTP - it's it's it
basically doesn't block so you so if
your request one is taken a long time
requests two and three if they take
shorter then you will get responses for
those in a much quicker way without
having to wait for
every because one so so that's it and
then what this means for you is that
when you download a picture this is how
it looks in HTTP 1 1 1 and in HTTP 2
that's how it looks like and actually
there is a cool page if you go to this
page you can run like live demo so this
is being downloaded in HTTP 1 it took 2
point 4 8 seconds if you run the same
one and it should be - it takes X 0 zero
point three nine so that's really nice
so so this is basically the connection
efficiency that comes with GRP see the
other efficiency that comes with GRP see
is what goes over the wire sorry so G
RPC uses a protocol it's a binary
product protocol and it's much more
efficient than your regular XML or JSON
this is a graph from one of the Google
cloud services they used to have an HTTP
1 1 JSON based endpoint and that this
was their throughput and then they also
created a gr PC based a product buff
endpoint and then their throughput
basically jumped - you know from 30
something to almost 120 because what
what goes over the wire is much smaller
what you need to sterilize is smaller
what you need to digitalize is smaller
so you use less CPU so by just using a
binary efficient protocol you're just
getting like benefits like this way
throughput increases so that's
efficiency over the wire and the last
one and I think it's a really important
one is the multi-language support so all
this language is C++ Java C sharp PHP
there they all have implementation is
Shinji RPC so you don't have to pick a
language basically as long as it's one
of these you're pretty much covered and
I think that's important because in my
case I was using ActionScript and flash
when flash went away then I have to do
all the work again but now here like
with G RPC you have all these generators
that's done for you and that's great and
the last one is the connection options
so you don't have to do just request and
reply you can do server-side streaming
you can do client-side streaming you can
do bi-directional streaming which is
nice and let me just show you how that
works so imagine you want to write a
chat application
where people are chatting to each other
in that case you need a bi-directional
streaming because your clients can send
messages to the server anytime and then
your server when it gets the message it
needs to send that to connect the
clients anytime so it needs to be
bi-directional so to do that in gr PC
remember in flash I had to create all
these news channels and and do all that
work at the channel level to do it but
injera PC it's much simpler what you
need to do is I have this sample here
chat server and chat client so let's
look at the server first so first we
need to define the actual service let me
close the other ones so we have this
chat service it has a metal called chat
and it takes in a chat message so this
is the message from the client and then
it returns a message from the server so
that's the message from the server but
one thing that you're going to realize
is that we have this stream keywords so
by marketing this message as stream we
are basically saying that the message
the connection between the client and
the server
it's a streaming connection and also by
marking this this one as stream we are
saying that the connection from server
to client is also streaming connection
so it's a bi-directional streaming
connection so all you have to do is just
basically mark your messages with stream
and that's it you have bi-directional
streaming now if you look at what these
guys are the chat message is basically
it has a from so who is sending the chat
message string and it Anita also has a
message which is a string and then the
chat message from server it is a
timestamp so when the server gets a
message it will timestamp that and then
the actual message that was sent from
the client so this is our definition for
our service and let's just look at the
code real quickly so if you look at chat
server it's very similar to before we
again build a service with the port
which is 880 again we add a service
which is chat service implementation
that I'm going to show and we've built
and let me start the server it's
identical to hello world but this is
much more complicated it's
hello world it's a chat application
that's bi-directional streaming but when
you look at the code it's pretty much
the same if you look at this service
implementation again it extends from
this generative code and by extending we
get this method this time so this method
it's a little bit different than before
and it's called chat but for it takes in
a chat message and returns it takes in a
stream observer and we and it returns a
stream observers so stream observer is
the abstraction that we use to define
the streaming connection basically so
what we do is when we get a request a
response an observer from from the
client we add it to our observers so
these are basically our connected
clients so we keep that in a set and
then this stream observable basically
defines what we're going to do on the
server what we're going to do when we
receive a client message from the client
so on next is when we get a message from
them from the client what we are doing
is we are printing the message for
debugging and then we're gonna we're
going to take the client message and we
can we're going to create a server
message out of it so we create a new
server message we set the message to
what we received from the client and we
also timestamp that and then that's it
so we built that and then once we have
the message from server to client
we'll just call observable on next and
passing the message so will basically
take create the message on the server
and pass it to all connected clients and
that's it and on error I'm not doing
anything right now but normally you
would log it and send some kind of error
message and then uncompleted is when the
client disconnects then you will just
remove the client from our list of
observers so this is the server side and
then if we look at the client side so we
have this chat client and I am we are
using Java effects here so there's lots
of UI code here but we don't care about
that let's just look at the actual G RPC
code so as before we are creating a
manage channel for the host on the port
and
we are using HTTP HTTP now from the
generated code we get a new stub but the
defense in this case is that it's not a
blocking stuff anymore it's non blocking
because in a chat application you don't
want to block you you want to get
callbacks so from there we get a chat
service and then we can recall the
method it's strongly typed so from here
I can say I can see what I can call so
there's a chat method that we created on
the server side so we call that and we
pass in a stream observer so this is
basically the handler for the messages
from service client so what is the
client going to do when it receives a
message from from the server so what it
will do is again it's strongly type so I
know that I need to implement this on on
next on error and alone completed so on
next is when I receive a message from
the server I'm basically just displaying
that in my Java FX application and then
on error I just print the error and just
say disconnected and the known completed
I say disconnected as well and then the
last thing is that when the user we're
going to have a button for the text so
when the user types of message and sense
since you know send it sends what
happens we create a chat message so
again from chat message that was
generated for us we get a builder and I
say from message and build and then we
have this chat object that that we got
from from this chat service earlier so
we just pass it on next so we're
basically just creating a chat message
and sending to the server and when we
close the actual chat application we
call uncompleted so we are basically
letting the server know that you know we
had done you can close the connection so
that's it then let's just run this again
quickly so let's start the server so
service running and then let's start the
client and let's start two clients
because it's not nice to chat by
yourself
so this is client one
this is client - let me move them a
little bit
so this is let's say it's me and then
it's you and if I say hi then right away
the other guy gets it and then hi back
you got it so you have the stream
connection so every time you send a
message that the guy who gets it right
away all right so let me just go back to
my presentation quickly so this shows
you that you have different connection
options basically and that's it that's
all I had to say there's a page ER
pieces of i/o where you can go and what
depending on what language you use
there's lots of samples and cooks quick
stars and if you want to contribute as I
said it's open-source so feel free to
contribute yourself and by Twitter and
my email if you have any questions let
me know I think we have time for some
questions so if you have any questions
let me know yes
what happens when you have a connection
and server crashes the the client will
get like an on disconnect so the client
will be disconnected basically so there
will be an error message yes how does it
manage optional values and there are no
optional values so the message has the
values so you have to pass them in I
don't think there's any optional values
yes
yeah yes so the question is is GRP City
compatible with mitosis that can
independently update right that's a
question yes I mean it is designed for
that because you have the service
definition file that everything the
client and the server gets cervical gets
generated from right so if you need to
change your service you just try and
change one file and you regenerate what
you need to regenerate and that's it
yeah yes I mean of course that you need
to do versioning and things like that
but all that kind of stuff with UNIX you
need to still do it but at least like
updating the service itself it's easier
because you don't have to you just have
to worry about changing the service
definition file and from there all the
connection stuff is auto-generated for
you so you don't have to change a lot of
code yes there is nothing in gr PC
special for versioning so you still need
to do that yourself yes
so yes so the question is how does
reactive stuff relate to gr PC makes it
right it doesn't really play well with
reactive stuff chair PC maybe someone
will come along and they will write
something that will make it easier but
for now I don't think there is anything
in gr PC that plays well with reactive
yes
is it possible to customize
authentication between services I think
it is possible I haven't done it myself
I know that the usual TLS stuff works
and that is token-based authentication
as well but you can plug in whatever you
want you just need to implement that
yourself yeah I mean the whole thing is
open-source and and it also tries to be
pluggable so whatever it doesn't work
for you can pretty much plug in and
write your own implementation more
questions all right I think that's it
thanks for your time and yeah</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>