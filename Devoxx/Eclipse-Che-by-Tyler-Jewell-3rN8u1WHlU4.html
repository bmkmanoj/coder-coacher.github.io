<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Eclipse Che by Tyler Jewell | Coder Coacher - Coaching Coders</title><meta content="Eclipse Che by Tyler Jewell - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Eclipse Che by Tyler Jewell</b></h2><h5 class="post__date">2017-04-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/3rN8u1WHlU4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right good morning welcome to devoxx
the first North American devoxx event
here in San Jose the San Jose Convention
Center this is my first event at the San
Jose Convention Center usually in the
Bay Area it's the Santa Clara Convention
Center
where these things take place and
they're much smaller venue so these days
this place is massive it's like that
projector I suppose I'm Tyler Jewell I
am a project lead for Eclipse CheY which
is an open source project that's about
18 months old
I'm also founder and CEO of code Envy
the the originators of Eclipse J and we
also make a cloud IDE as well a hosted
version of that and I'm a I'm also a
venture capitalist I'm a general partner
with a company called Toba capital and
we have about 500 million dollars that
we've invested and and I'm an investor
and board member on various developer
related businesses some that you may
have heard of including sauce labs wso
to shift mobility Cloudant which got
bought by IBM a couple years ago so it's
all I've ever done I just focus on the
developer market and I have a various
high investment hypotheses about the
segments and those have largely played
out to be true
but my day job is running codenvy and
being leader for this project called the
club's che there's some background on
how we came up with che and its
motivation I tell this story some people
laugh because I felt pretty often but
it's it's relevant and true
I started off my career as a Java
programmer I worked at B EA for six
years and I was in evangelism marketing
product management roles and they were
all technical and I had a really good
hands-on skills to the point where I'd
written books about Java and EJB and was
you know heavily involved in the
advancement of the language and the
WebLogic platform
and and I very much enjoyed that but
then I pursued a career in management I
spent seven years at Quest Software
rising up various levels of product
management responsibilities and at one
point in time I had responsibility for
about 200 million dollars of revenue and
about 30 products 30 different SKUs and
organization in a very sizeable
organization and then I got sick in 2010
really ill nine-month illness that took
me offline and it really messed with my
cognitive ability and I was really
worried about my future and my outcome
and when I recovered from that illness I
just had this awakening that I wasn't
necessarily enjoying this career
ambitions that I had and I wanted to
reacquire some of my programming skills
and so I sat down and on the go I miss
programming in Java so let me just get
the pet store app working in Eclipse IDE
we'll get some Tomcat going well do you
know maven build system and three days
later nothing worked you know I couldn't
get Eclipse to work right you know maven
was foreign to me you know the
technology had had leapfrogged me at
this point in time and so it was
impossible to get these things to be
configured so that all I wanted to do
was compile encode messing around with
some of the Java code see what was the
advancements that were there and it was
incredibly frustrating humiliating
angering sort of experience for me and
and I was just like oh my god why can't
this just work and and it would
have been easy for anybody to just give
up at that point in time and I'm sure
there's lots of people who start to
experiment or explore or learn about our
technology and they get to that point
it's overwhelming to them maybe they
don't have access to a mentor or someone
who's willing to coach them and walk
them through it maybe they're not the
sort of people who can sit and look at a
30-page wiki to try to figure out follow
the steps as a way to learn about a new
discipline and and I was just like what
you know cloud technology had come all
this way why can't there be a link I
clicked that link and inside that link
was all the information necessary to
generate the worst space that had
the code inside of it the the build
utilities the runtime utilities and a
browser-based IDE that let me execute
these commands so that I could get
exactly into what I wanted to do and
that was the basic idea why can't anyone
anywhere contribute to a project without
having to install software first and and
that was the basic idea and we started
code Envy as a company in 2012 prior to
that there had been this initiative
called cloud IDE comm where we had made
a very simple browser-based IDE for Java
it was very limited in what it could do
but it showed the promise and the
potential of hosted runtimes and
browser-based tooling sets but we came
up with this vision and we were like
okay how do we pursue this vision well
first let's break it down and talk about
what's a contribution right and and in
order to make a contribution you need
three things you need obviously your
source code you know generally an IDE or
any sort of tool called the tool or the
editor experience whatever you want
something that you can edit with those
files but then you also need a runtime
and and we we historically think of the
runtime as you know the what goes into
production but the runtime here is the
anything necessary to run the tools that
are going to lend to your code compile
it you actually run it or debug it as
well so there's a whole series of things
associated with that and and if you
don't have that runtime you you
certainly aren't going to be able to
work with the code and so that has to be
available to make a contribution now now
when we install our IDE onto our desktop
we do have a runtime it's just localhost
right we're just installing software and
and so if you're using IntelliJ or the
Eclipse IDE and you say build they're
sending a Java C command and and it's
going to localhost and there's a process
there that's running there and so it's
consuming the resources of your laptop
and and we just you know take for
granted that this runtime is there
there's an operating system we install
software onto it but it's an unmanaged
runtime and what I mean by unmanaged is
that you know
the tools can install software into
there you as an individual can install
software into there you can override the
customizations and so there's no
repeatability of that and so so
something that works on one desktop or
laptop doesn't necessarily migrate to
another on that so we need these items
for a contribution a workspace is a
higher order construct that historically
has been seen as a wrapper around the
code itself but then provides
integrations to the IDE and then also to
the runtime so that a user who's using
an IDE can say load workspace one or
load workspace two and there's some sort
of reasonable isolation so that these
workspaces can have slightly different
configurations but continue to work with
the same runtime and the same IDE
alright this is this is traditionally
how we work but that's ok but if you
want to click on a link and magically
have a workspace where you can do
development that means that the
workspace has to be one that is
dynamically generated or it is portable
it's moveable from one location to
another so how do we go about sharing
our workspaces today
well one you know you can do it on the
IDE level where you have some sort of
synchronization of your workspace config
and so if you go from compute one
computer to another you can take your
workspace and and share it and there's a
config server this is what the JetBrains
approach so they'll have a IDE
configuration and you can share that
down but it's just the IDE right it
doesn't share the necessarily
configuration and it certainly doesn't
share the runtime and if you look at M
which is a project open source project
as part of the eclipse foundation it
synchronizes the the not only the
configuration of the workspace but also
the installation of the assets as well
so it'll install the binaries all their
dependencies and the configuration but
again no runtime it assumes that it's
using your localhost runtime and fluxes
another
that uses a service bus to connect two
completely different IDs that have their
own independent install and then
synchronizes various assets like the
files or the project tree between them
but again just the configuration and the
project code nothing about the runtime
itself right so how do you sync the
runtime and the runtime has all sorts of
weird you know capabilities associated
with it there's an operating system
there's a whole series of processes the
configuration of those processes their
own dependencies on that and something
like this is not available and and this
is not available because localhost has
constraints right you can't necessarily
take localhost off your desktop and just
share it you can't necessarily clone it
it's not secure and you certainly can't
scale it right so it's got limited Ram
it's got limited CPU it's fixed
so the workspace that you set up using
your desktop IDE is constrained by all
these limits that are there what we said
with Eclipse J was if we wanted to click
a link and magically have a completely
functional programming workspace we
needed to redefine the workspace and J
takes the work space and says not only
should it have the code and the IDE but
let's take all the dependencies if you
will that that code would require
including the runt and treat the runtime
as a dependency and include all of that
inside of a single workspace there and
and will redefine the definition of the
workspace so that it's inclusive of all
those dependencies almost to the point
where you could call it a unit workspace
like a unit kernel right so in J when we
talk about a workspace and workspaces of
first-class object the first thing they
do is they bring their own runtimes so
every workspace has its own runtimes
these runtimes by default are docker
containers but they don't have to be
they could be a VM it could be a remote
server over SSH but it needs to be a
runtime and and in the case of che it
could be a
Engel docker container like I'm just
gonna grab an Ubuntu or a Debian image
or it could be a docker compose syntax
which is a multi container orchestration
across a common shared network so we
first start and take this run time and
this one time could be a production run
time or something that you author
yourself so we're gonna take some
off-the-shelf production run time and
then we treat the source projects as a
different abstraction so in our case a
project is a first-class object that
maps to a repository it could be a git
or a subversion repository maybe a zip
file but you can have one or more
projects and we are going to mount them
into the workspace after the runtimes
have been brought online so we say bring
up the runtime move your projects in and
then we're going to give the projects
type it's gonna be a maven type a C++
type the sort of typing that you see
previously and that that imbues
behaviors and then each workspace serves
its own IDE now these workspaces provide
services right and we provide these
services through things called agents
that are running inside the workspace
itself so a standard agent could be an
SSH agent right so a client could be a
remote client an SSH into the workspace
but another agent would be an IDE agent
a workspace agent and and it's a server
that's running inside the runtime in the
scope so it's got an endpoint it's got a
port and it's a process that's running
in there and and then a browser can
connect to this workspace and say give
me the IDE which is JavaScript code that
it downloads and boom without having to
install anything if as long as you know
where the workspace is located you can
get the browser IDE that gives you an
experience but because there's an SSH
agent you know you can connect overt
Ellijay or eclipse as well and and just
treat it as a desktop client against a
remote workspace environment and then
you know the chase server is simply a
server designed to host these workspaces
which have their own runtimes
on that so you can launch multiple
workspaces these workspaces can be
shared among different users because
their servers now on that and so each
workspace is its own independently
running self-contained entity right and
we then you know takes up for some other
Eclipse technologies particularly the
JDT and Orion and and we've wrapped this
up into a slightly different developer
experience one that's focused on
simplifying a lot of the development
experience and removing a lot of the
unnecessary capabilities that exist in
other IDE s so let me just go here and
bring up a demo so is that readable okay
no it's not it
there we go
I didn't do it a little bit better so
what I just wanted to show here is what
this maximize this che itself as a
docker container right and so you can
actually say docker run Eclipse J and
it's gonna it'll go and download the
docker image and you know it gives you
syntax there on how to run it and so so
docker run Eclipse /j gives you syntax
and it's a server right and and the
syntax kind of looks complicated there
but it's simple commands you start you
stop you can restart the server and and
there's one volume mount that's required
you've got to mount some local folder
into the docker image and this is where
your workspaces will be saved in your
projects in case you bring the Chase
server down but beyond that so I'll
bring up here I've got J running and
this is the chase server not a workspace
here and I go to my dashboard we'll just
create a new workspace and I'm gonna
create a workspace from a stack and a
stack is a way for us to describe a
runtime so the first thing I need to do
is pick the runtime that's going to
power my workspace and these things this
these descriptions here ultimately just
boil down to one of three things either
a docker file that we will compile on
the fly a docker compose file
that again we will execute on the fly or
a docker image that is hosted on a
registry a private registry a public
registry but you can pick any of those
things we have obviously a stack library
we could author our own if we wanted to
but I'm just going to take a default one
here which is Java MySQL and this is a
docker compose syntax that will launch
two separate containers one for a Java
Tomcat server and another for a MySQL
database and so I've selected that
stack I can then give him Ram because
these are runtimes so you need to size
them I'm just gonna take the defaults on
this one of them is going to be labeled
the Deveny sheen which is where the ide
will connect to the other one is more of
a slave machine that's the database
machine there and sorry my alarm keeps
going off like stop all right and then
then it says okay what are you projects
do you want now I could just create it
without a project and then clone
something from get but we've got some
templates here and so this is a web Java
project and and then project me I'm just
gonna say create and when I say create
it's going to both create the workspace
and then activate it and the bootstrap
sequence of the workspace itself is to
first create the workspace as an object
the second is to activate the runtime so
in this case it's taking the docker
compose it executing the docker compose
service that's creating a network that's
creating than two docker containers the
read even that that's that's all normal
that's all natural after the two docker
containers are created at least one of
the containers needs what we call the
workspace agent and the workspace agent
manages the health of the workspace
itself so it's how the Chase server
manages its relationship to the
workspace and it's how the browser
ultimately gets connected to it as well
and so after the workspace runtime is
completely booted then you're gonna see
this next thing calling the starting the
workspace agent and that's going to be a
tomcat server that boots up inside of
the the workspace and that then means
that the workspace is completely active
and after the workspace is completely
active then the last thing is that
inside the workspace the get utilities
will then clone the source code from the
repo the sample template we chose and
it'll clone it and set it up as a
project and we'll define it as a maven
project and then it will imbue the maven
capabilities and after all that stuff is
done and we verified the health checks
of the workspace the workspace agent and
the projects
the IDE will be automatically loaded
into the browser and available on a
unique URL so the URL at the top right
now is a chase server URL the chase
server is managing this workspace in the
the bootstrap sequence there it goes to
create the project and and Mike by the
way this is Windows laptop low ram so
unlike if this wasn't a bun 2 server at
digitalocean this thing would be
screaming right now so in its windows so
you got to forgive Microsoft a little
bit but there it goes the project has
been cloned and you can now see on the
left the little green dot means the
workspace is running everything's been
verified the the IDE the browser IDE is
being loaded and boom it's done now this
graphic is the dark the dark experience
is not all that good thank you
let's try the light theme
refresh it see if the light themes any
better is that easier to read better
yeah okay cool
all right we'll just collapse the left
nav bar there and you know lo and behold
we've got a running workspace and up
here in the left here's that project
we've got a project tree you know and we
can in here open files if we wanted to
all right so we got an editor I can
because this is a maven project it's
actually smart enough to recognize that
this is a Java project
so it's consolidated the folders all
right if this was a C++ it wouldn't do
that and so I can see the package model
I can open up Java one of the agents
that was deployed in here we recognized
that it was a maven project with Java so
one of the additional agents that were
added was a Java language server and the
language server is a standard protocol
that is about a year old now that we had
done with Red Hat and Microsoft and it
standardizes the interface between an
editor and intellisense like
autocomplete document registration and
lookup so I can come in here hit just
hit control space and wallah
I've got intellisense for Java on that I
didn't have to install anything that was
just registered as part of that and
there's all kinds of great you know Java
intellisense and and there are now
almost two dozen of these different
language servers that are out there
Python PHP c-sharp is one that we
support a clang d1 is coming a little
bit later this year so these language
servers are making it great and easy to
just add intellisense without having to
do any sort of special installation you
can see down here that we have two
machines so there's the database machine
in the dev machine those are two and
they represent two containers so these
two containers are both running they
both have status let me just probably
zoom in a little bit
my brother there we go
it's not how I would work but it gets
the point across and you know and this
is a terminal and you know it's a full
terminal so I can run midnight commander
if that's your thing inside of this
let's see we're gonna go to the maven
project there's the project we just
create we can just touch hello and you
know refresh this real quick
and there's the hello and I can say
hello DevOps and it's all in the cloud
so I don't have to hit save or anything
like that and more hello and you know
you can see that it's there so this
editor or this terminal is working
against a file system inside the
workspace that that file system is the
same file system that the project tree
is managing against and the files that
are there right so I could you know echo
hi has an append to hello and you know
you can see that it it added it to my
editor automatically on that okay
alright so see it got a zoom out here
there's a bug there red
there's the we lost the my commands yeah
so where is usually a towbar here but it
looks like the light theme has lost the
toolbar on the commands so so commands
are a concept in it some point in time
you need to compile your code to run
your code and a command is our
abstraction for how you do that and so
commands can have type like they could
be a maven command they could be a bash
command and even though you define them
and work on them inside the browser the
commands have to be sent to a runtime
and now you're dealing with the world of
multiple runtimes here we've got the
database we've got the Devesh eeen
there's separate containers so in
addition to choosing the command that
you want to run you have to target it to
one of the
runtimes of where it should run because
they have different software installed
here and so you know here's a build
command and and that looks really tiny
but it basically just says maven clean
install and skip tests and and that's a
command that's there and and if we want
to you know I can even edit commands
remember how to do it or is it on the
menu Brad yeah at the Edit window I
don't know you can't can't run it here
let's just go back to the dark preview
there's our theme
no I'm running the nightly it's wild
anyways well this just gives me a good
excuse to go bring up a staging server
where we're rewriting the commands
anyways so we will bring up another
workspace
all right here we go
so and in this version this is a staging
server what we've done is we've got
actually a command editor over here and
so here's a build command I can open it
up it opens it up in the editor
experience and so you can see that it's
maven - F I can actually run it believe
it or not and when I run the command it
sends it to the dev machine and there it
goes it's off its off building that
command and we've got a new toolbar up
here where you can see the progress of
the commands and you can choose from
different commands and whatnot on it
including the debugger on that so and so
now it's built that project was built
and I haven't had to install anything
this concept that works based concept
the workspace is shareable among
multiple people the workspace itself has
API endpoints so it's programmable you
can program the workspace agent you can
program the chase server itself and it
is customizable as well so the
architecture of the way this works is it
I call it a tripod and you've got the
browser
you've got the server and you've got the
workspace and you can see that the
browser is simultaneously maintaining
channels of communication between the
chase server and each workspace and it's
connected in so that we call the chase
server a master and the master is really
responsible for orchestrating the
various workspaces managing resources
because you have to limit limit resource
consumption across all the shared
workspaces and then once the workspace
is up and running the browser and the
workspace maintain a direct
communication the the master itself is
no longer directly engaged in the the
the developer workflow it's it's largely
just there to make sure that the
workspace maintains its running and then
report back to the browser if anything
is broken on that this entire
architecture is
completely customizable so at the core
of che is an SDK and with that SDK you
can create custom extents that go into
the workspaces you can create custom
extensions that are packaged into the
master or you can completely change the
browser IDE and the the browser IDE is
actually written as a java google web
toolkit GWT plug-ins on the server-side
and then those plugins are compiled into
cross browser JavaScript that is then
downloaded into the browser but the
architecture of this SDK for the
client-side is very similar to what like
the Eclipse RCP platform has so there's
extensions for the editor the panels the
menu the buttons all the sorts of things
that you would expect I mean what can
happen is that you when you create a
custom cloud IDE you create extensions
for the workspace extensions for the
master extensions for the browser you
package them all together and then they
all get compiled together into a new che
docker image and then that docker image
you can deploy and it will manage and
set up this distributed architecture for
you on that so the whole system is
completely customizable that way and as
a result we've been able to build a bit
of an ecosystem with this we're close to
4,000 github stars in about 600 Forks so
it's a it's a good project that people
are forking and then trying to add
either new programming languages new
types of language servers extensions to
the usability on the ide side you know
you pick your poison people are
customizing it there the activation is
largely what we talked about the the the
work the first step is the start with
the production runtime it always starts
off with a docker image this image could
be cached or not these images could be
hosts hosted docker hub it could be
hosted locally
it could be hosted on a server that you
set up or it could be just straight up
docker file syntax and if it's
right up dr. Felson tax the the chase
server will use the local docker daemon
to build it to actually take the docker
file build it into a docker image and
then use that docker image from the
local cache on that agents are packaged
as zip zip files and and these zip files
contain processes that run on the native
OS and you can adapt these for Debian
Ubuntu CentOS all the different flavor
distributions that are out there that
they can be packaged for and a couple of
agents the workspace agent and the
terminal agent are defaults that are
there because every workspace needs a
terminal every workspace needs a
workspace agent and then the once the
runtime is up all the cloning all the
get activities actually take place
inside the workspace itself so the
workspace when it does a get clone it
comes from the workspace as if it was
localhost
so once the workspace is running it is
identical to localhost it's just running
somewhere else and so it doesn't get
clone and that's how the the files can
come in once it's all set up your IDE
clients can SSH in or we have a
live-work space sink so you can on your
local client do a workspace sink which
will take the project files from the
remote workspace and keep a two-way sync
between them and a local folder and if
you do that then you could have a local
IDE using those local files and then
they're automatically pushed back up to
the shared server I'm gonna skip those
here the infrastructure itself is done
with docker of course right everything
you know the the workspaces are dr. eyes
containers the actual administrative
install is a docker container and it's
actually pretty clever so that docker
run Eclipse CheY that I did at the very
beginning that is a stateless docker
container so it will it's only job is to
configure install start stop rerun other
chase servers and so and we call it's a
CLI bootstrap it's a real simple syntax
it's got version management
into it you can do an offline install if
you want so it has a way of downloading
all the necessary doctor in ajiz and
running che offline and it bootstraps
things so it verifies access to the
docker it verifies that you have access
to docker hub if appropriate checks the
networking and then it uses puppet to
generate a configuration and so the CLI
will actually generate docker compose to
meeeee docker compose syntax for your OS
or however you've configured it and then
it tells docker composed to run that
docker compose file which actually runs
the chase server which is then
responsible for running the workspace
runtimes so you get this a container
chaining and each level of this
container chaining is there to verify
that you get mutability and portability
of not just the workspaces but also the
chase servers so that you can just spin
them up with the single command on any
different server or system we then sorry
that that image is almost impossible to
read but we at code Envy take che and do
a couple of things to it so so che is a
single server a single user or a shared
server concept so you can have multiple
users but they're all on a shared server
and codenvy is a multi server concept so
you can have as many physical servers as
you want you install code envy with the
same exact syntax is Che but then you
just register these additional physical
nodes and code envy is responsible for
distributing the workspaces on different
physical nodes so that you can get a big
workspace cluster the second thing that
we do is that we add authentication so
your users can have security they have
identity and they have control over
their workspaces
so that's permissions control and then
we have a bunch of DevOps tools for
backup Recovery administration
monitoring this because when you're
talking about thousands of developers
all sharing the same system you're
getting to run a pretty big cloud
because the average developer wants 8 8
to 16 gigabytes of RAM per workspace
there might be running a couple of
workspaces at the same time and so a
thousand developers turns into a pretty
architecture and so the codenvy
architecture is that the master is there
the machines are distributed and then we
you know connect it with an LDAP
registry and Enterprise docker registry
and an artifact repo and and we manage
it as a single system the the last thing
here and this has got a code Envy logo
on it
but we're just a couple of days away
this feature is now being ported into
che and it's going to show up we're now
in final testing the last thing is is
that original story that I started with
which is okay how do I get to all this
into a link I just click the link and
get what I want the process that we went
through was a pretty manual process you
know choose your stack choose the source
code that you want to go into it
verify that the commands work execute
the command
get the browser IDE loaded up it's not
it's not a lot of work but it's still a
couple of clicks we have this concept
called the factory URL which allows you
to take a workspace and an entire
configuration and it's projects of that
and then save all that configuration
into a automation URL we call it a
factory and and what that Factory does
is that you can publish it and when
people click on that we will execute the
automation to either create or load a
workspace exactly with the configuration
that's there and the user doesn't need
to have any previous experience whoops
so can I appear this should have a
hyperlink in it no of course the
hyperlinks not working so let's go to
clips or J will go to the sass variation
of this and and these are all flavors of
this and I can come down here and I can
choose a spring and when I click that
even though I'm not logged in to code
Indy it has the encoding on that I can
just choose a Google+ account
Giusti jewel and and you know so I can
either create a new account or login
with it but without having to go through
that step of what do I want that URL
that was encoded with the factory has
all the encoding necessary so just by
clicking on that URL it's going to get
the the workspace get the runtime get
the projects get the commands and then
he can actually execute some macros
after it loads as well so that the end
user is just plopped in and picks up
exactly from where they want and this
particular example was exactly the issue
that I ran into in 2010 which is the
same sample app that I wanted to get
working in Eclipse
that I couldn't after three days and
roughly about you know 30 to 45 seconds
after just clicking one like link
logging in you get everything that you
wanted without having to know anything
about the details of how it was set up
so you'll have to take it on me that
this is get loading the workspace agent
and that it'll finish for us see here
there's me
so our community is pretty rich we're
really fortunate to have a community
that's there we our last major release
the five-o release we had 70 different
contributors to it and it's been growing
so a year ago it was like 35
contributors to that major release we
had been four and we just did five and
so it's definitely getting bigger we're
really fortunate with that we release
every two weeks
our meetings are completely open on this
we so we work in very tight Sprint's the
the big features that we're focused on
this year are getting che to run
natively on kubernetes and OpenShift
because right now it runs natively on
docker and so you'll be able to deploy
che as a pod and then the workspaces
will be also there sone separate
services inside of kubernetes and
OpenShift
we're going to do the same thing with
code Envy itself we're doing a lot of
work on performance we actually think
there's a lot of file system operation
and management performance
there's the intelligent commands so you
saw the nice a nice tool bar up top and
command editor that's coming online and
we're doing a lot of work to simplify
the customization process we now have a
new archetype generator so there's a
single command line that you run it'll
generate custom extensions and plugins
and so those are the the the major
focuses for us this year and then
optimizing the workflow there's lots of
places where we can simplify the
selection of stacks and how you get into
a workspace faster so this world is for
people who want to supercharge the agile
ethos it's about if you're moving to the
cloud
it's about simplifying things for
various dev teams who don't need to
worry about the infrastructure or the
work setup process and that's what we
designed it for and so with that I'll
say thank you and open it up to any sort
of questions that you guys may have on
this
no we yeah what language is the sport
there's so the language support question
is always a tricky one and let me break
it into two flavors of that three
flavors really the first the first
flavor is editor support for syntax
highlighting there are dozens if not
hundreds so we inherit from on Orion
editor which has fantastic globalization
support and syntax for capabilities for
lots the second tier of language support
is what I call you know the bare minimum
of can I edit compile run into bug on
that and in that case you actually have
access to this a lot because the stacks
are completely customizable and so
because you can completely write your
own docker file for the stacks you can
set up a swift stack that has all the
Swift tools inside of it
so as long as you're comfortable doing
everything on the command line you can
enable potentially any programming
language within this the third tier
which is what people really care about
is what do I get when do I get Intel
'since in the browser the way I showed
it here and a live GUI debugger on that
now on the GUI debugger part we have
support for jdb Java debugger gdb and a
PHP Zenda bugger on that much like I
talked about the language server
protocol being a generic protocol to
connect editors with language servers
there's actually a matching one called
the debugger server protocol that has
just come online and so over the next
couple years we should be able to see a
large matching of debugger servers and a
single debugger interface on that on the
language server protocol it's it's
fairly new but there's already a couple
dozen actual separate language servers
right now we have to package them one at
a time so we have to take the language
server package it as an agent package it
into this we have instructions on how
you can take an off-the-shelf language
server and package it into an agent so
if you go to lang server org you'll see
all the language servers that are
available there and they're all
built they're all built by the community
we do Java but all the others have been
built by others hopefully by the end of
this year knock on wood
the the work is starting on what would
be like a language server registry which
would allow tools like ourselves to
dynamically connect get a list of all
the beta various language servers
available for that file type and then
dynamically install it without the user
having to package it as an agent or a
stack on that so depending upon the
degree of you're willing to customize
the system you could have a very wide
range of capabilities there
yes sir yeah which one yeah we use a we
use our own proprietary JDT not the same
protocol no it's a different one for JDT
yeah because the the Java language
server is not the actual open source
java language server is not as rich as
what we what we do today yeah yeah well
we'll swap it out once it once it
crosses that threshold here and we'd
like to anyways the JDT version that we
do it's a it's a memory hog like if you
have if you want to if you build Chang
Cheh the Java language server consumes
that gig and a half a memory so so like
if you do che and Shay you need like a 4
gigabyte workspace runtime just because
the the Java intellisense is just eats
up half of it
all right well thank you we have a we
have a booth obviously in the exhibit
hall we can you know we have experts
there that can get you more hands-on or
more detailed questions if you like but
otherwise thank you for the session</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>