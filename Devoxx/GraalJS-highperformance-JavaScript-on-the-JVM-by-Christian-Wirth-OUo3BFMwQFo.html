<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Graal.JS - high-performance JavaScript on the JVM by Christian Wirth | Coder Coacher - Coaching Coders</title><meta content="Graal.JS - high-performance JavaScript on the JVM by Christian Wirth - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Graal.JS - high-performance JavaScript on the JVM by Christian Wirth</b></h2><h5 class="post__date">2015-11-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/OUo3BFMwQFo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay good morning thank you for joining
this session for your first session of
today my name is Kristen Viet I'm from
Oracle labs I'm based in Austria and I'm
present to you today our engine our
grouchiest
engine which is a JavaScript engine for
the java virtual machine where you can
execute Java Script programs with very
high performance we are fully standard
compliant and I will show you how we do
that and what else you can do on that
engine so I'm not only gonna talk about
JavaScript today I'm also talking about
Java I'm talking about language
interoperability how can you integrate
other language engines like Ruby Python
Erlang C closure or whatever language
you want to add to that list
I'm from Oracle labs which requires that
I'll show you that slide which basically
means all we do is research none of what
we are doing will ever be a product of
course we hope that it will be a product
but I cannot promise you so what am I
gonna talk about the first thing I want
to show you is what is growl and what is
the growl VM what can you use that for
then I will tell you how did we
implement this grouchiest engine how can
we make JavaScript really really fast as
fast as all the other engines on the JVM
whenever you talk about JavaScript you
need to talk about note chairs so I'm
gonna show you how can we execute notes
chairs on our engine and how do we test
that we really fulfill all the
specifications and all the tests and all
the compatibility is to existing engines
and finally that's probably the most
interesting talk for you unless you're a
JavaScript developer is language
interoperability how does our engine
hopefully solve the problem of language
integration of language interoperability
how can you write programs in multiple
programming languages now to start with
growl VM what is growl what is this
growl virtual machine
the project I'm in started off as a Java
on Java compiler so what we are talking
about is a just-in-time compiler for
Java written in Java as you know the
current Oracle Virtual Machine the
hotspot VM has two compilers the client
compiler and the server compiler both
are written in C++ and we think in the
future we want those compilers to be
written in Java they might be easier
maintainable they might be easier to do
research on it might be easier to extend
them to write new optimizations to write
new features to extend Java in the
future that's what we have written growl
for so growl is a just-in-time compiler
I guess most of you know what that is
just to get the picture clear I'm not
talking about the compiler that
translates Java to byte codes but the
software artifact on your machine that
at runtime translates Java byte codes
into machine code so you get really high
performance basically native performance
once it's compiled growl VM now is
basically the existing hotspot virtual
machine with growl used as a compiler we
are still using the existing compilers
server compiler and client compiler to
compile chorale itself as growl is a
Java program but the application that
you execute on top of this chromium is
then executed by growl what we've done
is in the first instance a Java compiler
but we thought how can we extend that
how can we add more to this environment
and everything that growl does is
optimized for more than just growl we
try to compile other languages with high
performance as well I've added some here
on the list that are done internally in
Oracle labs JavaScript C Ruby and our
statistical language but more languages
are done by cooperation partners by
universities worldwide or by open source
projects
all the java compiler is open source so
you can download it from open JDK you
can build it yourself we also have a
binary available I will show you but
everything we do there is open-source
you can download it you can change it
you can do your research and you can
write your language on it
many of the language implementations
besides Java so for instance Ruby or are
are open source as well
they are also researched in-house in
Oracle but they are open source you can
download them you can compile them
javascript what i'm talking about this
currently still closed source but we
have a binary release available we just
uploaded it two weeks ago for Java 1 and
it has the Java compiler it has the
JavaScript engine so grouches it has
Ruby and R and all those languages can
interact on that engine that's a very
high-level overview of what we are doing
to execute more than just Java on the
base layer you have the operating system
and on top of that operating system you
have your virtual machine which is the
hotspot virtual machine or a growl vm in
our case this contains a very small
layer which we call truffle the truffle
api which helps you implementing your
language engine with very little effort
actually on top of that is your language
engine so grouches is just one example
of those engines and finally on the very
top layer you have your application
program any JavaScript application and
node.js application or an application
written in many languages as you see
most of this stack is implemented in
Java so the growl vm has a very tiny
layer of c++ that you need to start
hotspot that you need to do some memory
memory management but the core of corral
itself all the compilation q all the
compilation itself all the optimizations
they are written in Java
what's the status of this project how
how far are we as we are doing research
we are pretty far already we support
everything that's in the Java spec so
just about any Java program that is out
there you should be able to run with
scroll if you find any bugs tell us but
we think that we are there and we can
execute all the programs as I said this
is open source you can download it you
can compile it yourself now the question
is we are in hotspot and we need to
modify hotspot so what does that mean
for you how can you how can your
customers use growl and the good answer
is the good news is there is the GEP
2:43 Java enhancement process and that's
how is it called Java level JVM compiler
interface we call it JVM ci Java Virtual
Machine compiler interface that will be
in JDK 9 at least that's the current
plans it's almost done it's ready to be
included in KDK 9 so that will mean
growl itself won't be Angelica 9 most
likely but this interface will be in
there which basically means you can drop
in growl or any other compiler adhering
to that interface to any existing
hotspot virtual machine then starting
with jdk 9 so in the future you're more
free to select what compiler you want to
use in your hotspot virtual machine so
much to Java now let's go to growl let's
go to garage yes let's go to JavaScript
this is our engine and it's basically
Oracle labs showcase to our main example
for this truffle API and for more than
just Java on the JVM it's developed
in-house at Oracle labs it's closed
source as I said we're working on open
sourcing it might take some time because
we need corporate approval for that but
we hope we can do that in the future we
support 100% of the old the previous
Eggman script 5 standards
now this summer a conscript six came out
or a conscript 2015 as it's now called
we implemented all the features already
so everything is there
we're not fully compliant to the
standard yet so the official test suite
says like 99.5% I hope we kind of finish
that this year so then we are really
standard compliant that score should
actually be higher than many of the
other engines so v8 for instance Google
Chrome's compiler has less than that
score whenever you talk about JavaScript
today you're gonna talk about no chairs
as well because we think that JavaScript
when you execute it on the server
most people gonna use no chairs and I
want to make that clear we're not
talking about the javascript in the
browser that's not what this project is
about there are many good engines out
there that can do that already
we really concentrate on everything
that's on the server for longer running
programs for data heavy programs for
programs interacting with other
languages with Java with a database
whatever to parts and just to drop the
names here which we use in in grouches
is the truffula API I will show you in a
minute what that means that helps you to
implement your an absolute syntax tree
interpreter for your language and the
second thing is the polyglot engine
which we use for language interaction
now the amazing thing is we wrote a
whole new JavaScript engine a lot of
people did that before but if you take
for instance Google's v8 engine they had
to write everything from scratch they
wrote their memory management from
scratch they wrote their garbage
collector from scratch all the library
support whatever they do they have to
rewrite that's not true in our case we
already have a working VM there we
already have growl VM based on hotspot
VM so we can reuse all those components
and our job was not to implement
everything from scratch but to take what
is there and try to see what's the
minimal thing that you need to do
to have a fully compliant language
implementation so our approach is to
write an ast into a beretta abstract
syntax tree interpreter that's one of
the easiest ways how you can implement a
language engine to interpret that
language that's very easy to code every
student in our university learns that in
grad school so there shouldn't be any
major issue with that of course the
problem is and I see you thinking that
in your brain interpreters or slow I
will show you how we solve that issue
now as interpreters are easy to code our
effort was really really small so to get
to get the fully standard compliant
Akmal script 2015 engine it's about 80
thousand lines of code eighty thousand
lines of Java code a few lines of
JavaScript code because we added some of
the advanced features of a comma script
2015 in JavaScript so I think that's a
reasonable amount of effort to implement
a language engine that's something that
a small team can do in two years maybe
of course we have some external
dependencies we depend on Nelson which
is another JavaScript compiler by Oracle
for parsing we depend on the Jony
library for regular expressions and we
depend on avatar J's for 4-node
compliance we're writing a new engine
for something that already exists
javascript engines are out there and
people are using javascript people have
already written JavaScript applications
so what do we need to be compatible to
when we want to enter that market of
course there is the ACMA script standard
which is a very nice written standard
defines almost all aspects of the
language and as I have shown you before
we are very compatible to it few edges
to cut off but we're almost there on the
other side there are existing engines
and that's a bigger problem because
those engines don't always adhere to the
standard Google v8
and spider monkey and take all the other
languages that out there from Apple from
Microsoft whatever they add their own
features and that makes it very complex
for a language implementer to figure out
what do we really need to support to get
your program running the third here on
the picture is no chairs no chess adds
another layer of complexity no chess has
its own base system implemented in C++
it adds JavaScript code it adds new
api's new layers that you need to be
comparable to and talking about no
chairs you can implement modules in no
chairs not only in JavaScript but also
in C++ and here's where the real trouble
starts implementing a module in C++
means you implemented against the v8 API
and that one is changing with every
release of v8 with every release of node
now people are gonna work on that there
is the native abstractions module in no
chairs currently they try to tackle this
problem to abstract it and to make it
easier to keep compatible with new
versions of JavaScript with new versions
of v8 and node but currently we have to
support the the internal API of that
node version that we want to support
taking v8 now as an example what are the
difficulties there we have to stand out
but why are those engines different the
v8 engine has most engines at their own
extensions and at least it's just a few
here you have a stack trace API you have
more global symbols that you can use
they have fields on the regular
expression function they have the strong
mode which is very nice thing in the
future but all that stuff adds to
complexity and it's not really well
defined how to implement that on the
other hand all those features are used
by a code out there and we think it's
reasonable to do that so this is stuff
that we to some extent do not support
currently but we will in the future we
think it's very important that that is
in there
that's the one side the other side which
we don't like so much is off spec
behavior and that's where we ate or
where other engines clearly violate the
specification of a common script I
listed just a few here for us now in a
kiosk of 2015 the most important one are
proxies the b8 implementation is totally
off spec on proxies it has different
traps it has a different way to create a
proxy understand that you would need to
call the constructor b8 calls a factory
method now we can support that in the
future but we still hope that v8 comes
to senses and supports that as its
defined under standard in the future
they have some open issues in the air
pocket tracker and on that but they seem
to be a bit resilient currently but
let's see what the future brings but
also other behavior where we see our
engine is failing the tests of v8 why
are we failing them because the test
itself is wrong from our point of view
so that leads to us not passing all pH
test and we try to figure out what tests
do we really want to pass what is
relevant for us and what is relevant for
use of our engine that we pass so from
the 2500 tests that are currently in the
test suite we consider only
2,170 about to be relevant those are the
tests that we want to pass at one point
in the future and currently we only pass
87% of that because we're missing some
of the of the extensions that v8 brings
but that doesn't mean that a program
that you download from the internet
doesn't work usually most programs will
work because all those features are not
used widely they are used but not by
each and every program now performance
I'm talking about a JavaScript
interpreter written on Java which itself
is an interpreted language isn't that
horribly slow when you execute your
application on that
I'm gonna show you some numbers how fast
we are on peak performance I want to put
a big disclaimer there
whoever few has ever done benchmarking
knows how hard it is to really benchmark
and figure out what do you really want
to know what do you want to benchmark
which heap do you want to use which
application do you want to benchmark we
have selected the v8 octane suite so the
suite from from Google's v8 project and
we executed it on our benchmark server
we do that regularly basically for every
push that we do to the server and those
are the numbers I can pair grudges
against v8 and spider monkey here and
the takeaway message here is that for
the benchmarks I show you here we are
basically the same performance as v8
sometimes we are a bit faster sometimes
or on many benchmarks v8 is a bit faster
but it shows you that we are in the same
ballpark as v8 it's not that we affect a
to effective five effective ten slower
we are maybe effect to 10 we are 10%
slower on some benchmarks we're 20%
slower on some benchmarks with 20%
faster on others so you see with with
reasonably small engineering effort I'm
talking about 80,000 lines of code here
we can write a JavaScript engine that's
fully standard compliant and that can
execute code with very good peak
performance how do we do that I told you
before that we are talking about a
abstract syntax tree interpreter what
what is the abstraction 16 to a Beretta
it basically means when you start with
some code like a plus B multiplied by C
you create a tree of nodes here you have
a multiplication node that has a child C
which can be a variable read node it can
also be a constant node depending on
what C actually is on my other side you
have an ADD node which adds a and B same
story here now what does the add node do
it has an execute method every node in
our tree has an execute method and this
node reads the value
from its a child from its left child and
from its right child both those nodes
return a value which is an object in
this case and then it calls the add
method which what I'll show you here is
not JavaScript semantics it's an
abbreviated version but just to get the
picture
if both values that we read are integers
then add them with integer and semantics
on Jama if both values are strings then
concatenate those strings and in all
other cases well go to some generic
method that does the magic of course
that will be horribly slow when you
execute it in your code because every
time you execute that you have to figure
out what are my values what types do I
have you have to box them if they are
numbers because you you're using objects
here how can we get that fast the
interesting observation here is
javascript is a dynamic language you can
use different types you can mix types
you don't have to use find them at
compile time but at runtime statistics
have shown research have shown even in
in 1970s that at specific places in your
program there is a very high chance that
types do not change if you observe an
integer at one position in your program
it will stay an integer maybe it will
deviate to a double but it will never be
a string most likely and we can use that
in the sense that when we execute the
program for the first time in our
profiler in the interpreter we figure
out to be using integer do we use a
string to be used something else and
then we rewrite our note we replace the
node in the tree so we can make an
integer node out of that that does just
the thing we wanted to do adding two
integers or we replace it with a string
node that does just concatenate two
strings or we go to another third case
which is more generic so starting with
the tree here on this side we specialize
all the nodes in this tree depending on
what
what values we see at run-time I've
shown you here how we specialize how we
could specialize in an easy case on data
types so we only get more generic from
integer we can go to double but we can
never go from integer to string or vice
versa
in that case if that happened we go to
the generic case that way we specialize
our jury this is not only done for data
types you can do that for any
optimization you can think of for
instance we do it for object accesses
whether we have to create that field on
the object as JavaScript is a
prototypical language you don't have
classes you need to change the classes
that you see or whether we write to an
object that already has that field where
the writing is much simpler we do the
same for arrays which we specialize on
how we store values in a race javascript
basically defines that there is a hash
table a dictionary but of course when we
see that this dictionary only has two
indices 0 1 2 3
written with integers then we will use a
flat Java integer array to store the
values and we use this specialization
strategy to optimize the writing and to
reading access to that arrays so that
the performance will be as if you had
written in Java in the first place with
types after some time this tree will
have all the values specialized all the
nodes will be specialized in this
example here you see we have 3 nodes
that specialize in integers 2 nodes that
specialize on generic now here comes the
real magic we take this tree and we
compile it and before we compile it we
perform what's called partial evaluation
the simplest description for partial
evaluation is we take the whole tree and
we inline all the execute methods into
one huge function to do that we need to
assume that all the call sides are
stable so that all the child nodes are
stable but if that assumption holds we
can really create one method one
compared
one compilation block that we compiled
and where we generate machine code for
and this in the end results in the
hopefully smallest possible Java program
that executes your JavaScript
application so if you had written the
same thing just for that input
JavaScript program you wouldn't have
been able to write a better Java
compiler this gives us machine code and
machine code should be pretty pretty
fast of course during execution it can
happen that data types change arrays can
grow objects can have their values
deleted we can overflow an integer value
or the user can suddenly input a string
where only integers are expected here
the java virtual machine helps us a lot
in that case we can be optimized so we
can throw away the compiled code we go
back to interpreter the interpreter can
execute all programs because it's not
specialized we can rewrite our notes so
in that case we rewrite from an integer
node to a double node and then again
after some time the program can be
recompiled and it can again execute the
program as fast as it would be possible
with that data that you have as input so
much to our core engine now let's look
into nodes chairs and here the good news
for us is we didn't have to implement
much because there is an avatar project
or the walls and avatar project at
Oracle where in the Avatar dot jeaious
code in the Avatar J's project they try
to execute JavaScript programs on top of
the earth stack and to make them execute
node.js code as well we could just take
their recast which basically is taking
all the nodes core the node core
implemented in C++ and rewriting it in
Java we took that code and that was
almost everything that we had to do
to execute note applications now the
question is is that enough can we
execute all known applications because
we have no clue whether that means we
can execute 35% or 99% or all notes
chess applications how do we know how
would we test that the MPM project the
node package manager has more than
200,000 modules 200,000 modules that we
can use to test our implementation and
that's what we did we took many of those
modules now here many of those modules
are implemented in JavaScript some are
implemented in C++ we're working on the
C++ support but currently we cannot
really support that it's a very tiny
fraction of modules that use the C++
implementation because when you're using
no chess you want to use as much
JavaScript as possible but the tiny
fraction has some very important modules
for us we are oracle we want to support
the node oracle DB driver couldn't tell
my manager that i cannot execute that so
in the future we will have to support
that we're working on that but for what
I'm gonna tell you now we're just taking
a look at JavaScript modules and modules
that are implemented in JavaScript how
do we do automated testing on them how
do we test those 200,000 modules whether
we can execute them there is the good
news that most of those modules have a
test commands so we can execute tests on
the module and the module will tell us
whether it's fine or not on our engine
the bad news on the other side is that
this is totally unstructured there is no
well-defined way how a test reports
whether it's passed or not it can just
write any message it can have a return
code it can crash it can print fail it
can print pass it can do whatever it
wants so our approach here was for now
to to get a first feeling we took the 30
most popular modules and by most popular
we mean those modules that were
referenced by other modules the most
time and we made them work
so we figured out what do we really need
to know to see whether this module has
passed the tests or not and that's what
we are currently testing we are passing
you see this value is around the
month-old we are not passing all the
tests there are many many reasons for
that
our recast is not perfect we need to
change in the recast some of those fails
come from what I told you before we're
not fully a coma script 2015 compatible
yet we're not fully know v8 compatible
yet we have some crashes in in the
compiler even but it's very nice to have
that huge set of tests if any of you
knows of a better strategy to test no
chess modules so if any of you wants to
work on fixing a problem in NPM I would
be very happy to hear from you but right
now we try to automate as much as
possible but unfortunately NPM does give
us so much here now let's come to the
last part of my presentation which is
about language interoperability I told
you about JavaScript that can be
executed on a Java Virtual Machine of
course there is a way to interact with
Java but there can be more the promise
given by the Java Virtual Machine
initially and also by other similar
things like Microsoft's common language
runtime was yeah you can execute all
languages on our engine is that true
well it is to some extent you can
execute all programs all programming
languages on the java virtual machine
but we would like to add to that
sentence as long as it looks like java
or as long as it looks like the c-sharp
because when you execute something on
the java virtual machine you have to
translate the program into java
bytecodes and java bytecodes are not a
great tool for instance to implement a
functional programming language it's
getting better but it's not perfect for
that of course that might be a
controversial statement but in the end
many languages cannot be fit well to
java bytecodes
so we think there should be a better way
and we think the programmers want to
write programs in more than just one
language so when a programmer tries to
do that he has a ruby program and he
wants to call javascript typically there
is no interface for that he can simply
not do that sometimes he has the
possibility to do but if that then he
has to write lots of rapper code
typically so when you use J and I for
instance you have to write more than you
just want to write it's not as easy as
it should be and besides not being as
easy it's very very slow so every time
you cross the boundary between two
languages you're in a whole new world
everything has to be reset all
assumptions have to be taken new just a
small example what we want to do assume
you have a C program where you use a
complex data type and you have a
JavaScript function JavaScript method
that does the ad for this complex for
two complex values there is no way
currently you could execute the
JavaScript function from your C code
that's a very small example but consider
you have large applications where you do
want to do something like that it's
simply not possible or not easily
possible or it will be slow but we think
programmers want to do that programmers
want to reuse code programmers want to
use the most suitable language they know
to solve a problem and not just that one
language that the project started in and
on the ground vmb allow you to do that
we allow you to use more than just one
language you can gradually migrate
projects you can take to existing code
bases of different languages and let
them interact without writing much
boilerplate code I hope I have time and
it looks good
I can show you a demo what we really
need to do to let that interaction
happen and very importantly for us
when you reuse existing code we don't
want to have a language boundary we
don't want that to be horribly slow we
want to be that as fast as if you had
written it in just one language in the
first place now is that possible what do
we need to do that you can have
languages interact assume the growl VM
again with a JavaScript program you see
the code here we read the value field of
an object and that's JavaScript code so
all the the three currently is
JavaScript but as we're in a multi
language environment assume that the
value that flows in so the object itself
the value stored in object is not
JavaScript it is in fact a C structure
and we want to read the value field from
that structure cannot do that currently
but we can do it because when we figure
out that this is a C structure we
replace the JavaScript specific object
access that reads object and value and
returns the value field from object with
a read message the read message is
totally language independent and it just
knows readme value from object of course
this read message doesn't know how to
solve the problem in the end but as
there is a C value in our system there
needs to be a C interpreter somewhere
a truffle based C interpreter must be in
our engine otherwise we wouldn't read a
C value so the read message can just go
to that C interpreter and ask hey see
how do you read value from object and C
of course needs to know the answer to
that it cannot only read the value it
can do in our case something even better
it can tell us how we can do that so it
can provide an ast snippet it can
provide a few notes that know how to
read value from object if it's a C
structure and we add that code into our
JavaScript
now in the end all this is a Java
program so it's not a problem that we
mix languages here it's not a semantical
problem not in our engine and not for
JavaScript not for C because in the end
this subtree here will return a value of
type object so the JavaScript node here
the assignment operator can use that
object no problem we can do that and it
will work very nicely what we also add
here is a check whether it really still
is a C value again we can partially
evaluate that we can compile it to
machine code which will result in a
machine code that is comprised of
different languages in our machine code
we have now mostly a JavaScript engine
but some parts are from C and this also
works when you have more than just one
more than just two languages when we add
Ruby to the game we just create a
polymorphic inline cache where we ask oh
is this C then do this or that if not
it's Ruby then do this or that and again
you get the best performance even if
types of different engines are flowing
through your program how fast is that
same question as before what we did here
is we took benchmarks from the language
shoot out game benchmarks and we
implement or they are implemented in
different languages they are implemented
in JavaScript in C and in Ruby for all
three we have an engine so we benchmark
the execution and that's the result we
have one outlier here for the tower's
where the c engine is not as fast as it
should be the values are normalized to
the c engine and not unexpectedly the c
engine is usually the fastest because
object accesses are simplest in C
JavaScript engine on the very left you
see the composite score it has about a
performance of 60% of C and the Ruby
engine again is a bit slower but
percent of see performance now what did
we do to really test our multi-language
runtime on the next slide what I will
show you is we still take only the
JavaScript implementation so you will
see three bars for each benchmark and
each one of them shows JavaScript engine
the codes that we run is JavaScript but
we replace the locations so that you not
only see JavaScript engine executing
JavaScript objects but also the
JavaScript engine executing C objects
and Ruby objects and that should be
slower than the JavaScript engine but
it's not the black bar here is the
JavaScript engine operating on
JavaScript objects that's what you
usually do but amazingly the JavaScript
engine executing on C objects or than C
structures which is the red bar here is
actually faster your program is executed
faster when you change your objects from
JavaScript objects to see objects and
for us that is proof that this is a very
useful technology you can mix languages
you can execute applications in combined
style you can exchange data between
languages in your application and you
won't lose performance in some cases you
will even gain performance of course if
you let Ruby objects flow through your
engine performance gets slower but it's
still working and that's the very good
news here now before I come to the
conclusion I want to prove that this is
working and I'm trying to make a demo
let's see if
if everything is working as expected
this is our shell it's a multi-language
shall I hope move not as sharp let's
make it
I hope you can read it it yeah should
work this is our multi-language shell
and you can switch between languages
here now it's set to R but I can go to
Ruby 2 simple language our example
language to JavaScript or no chairs I
mean R and let's set a value to a vector
this now set hundred million elements to
this vector a hundred million random
elements so length of V should be
hundred million and the sum of V is
about 50 million of course so how long
does it take to calculate the sum we
have a time function of some V it's
pretty fast it's less than a second
significantly less than a second of
course we can also implement the same
thing so the Sun in R itself and that
will be slower if we execute it it will
take about four seconds I'm doing the
whole thing here in in VirtualBox which
is not a good thing to do when you do
benchmarks but just for the demo it
should be fine now if I execute that
several times it will take about six or
seven times here now our compiler will
kick in because currently all this is
executed in the interpreter so it's slow
it's like a Java interpreter in the
beginning but at once this is compiled
it should be fast it won't be as fast as
the built in some function but it should
be really really close yes you see it's
this try its twice's
so it takes twice the time of the built
in function but that's okay now
I'm gonna have a JavaScript function so
I switch to JavaScript here this is a
JavaScript ad it takes two parameters
and just adds them and return them so I
can call J a set of seven and eight and
it should be fifteen right what we also
have here is export now this is some
kind of boilerplate code but it's not
actually required we do that because we
think we don't want to bloat the global
environment we could do totally without
that we could export all values from
JavaScript to all other languages we
think it's more reasonable to not do
that to only export really what the user
wants to export and to import what you
want to import but probably if this ever
is a product we're gonna have that
behind the flag so you can really export
everything if you really want to that's
not a technical limitation it's just for
us to keep the overview now we are back
in our and in our I have a new function
are some two and this one implements
imports our JavaScript add it then
iterates over all the elements recall
these are 100 million elements and for
each and every one for 100 million times
it calls the JavaScript ad and sums up
the value in the end so let's benchmark
that again it will be slow first it will
probably also take here three and a half
seconds and again if I compile it so if
I execute it several times the system is
not prepared for demo it should compile
really really fast if I execute it again
several times it will be as fast as
before sometimes it's even faster
because in JavaScript the arithmetic
sorry v'n a bit faster yeah you see zero
two seconds it takes 0.2 seconds to
iterate over a hundred million elements
in the our language transfer the values
to javascript sum them up their return
to our and calculate the value I hope
this is kind of proof for you that this
language interaction really is working
and is working as fast as as we expect
it to be now I told you lots about our
engine about language interoperability
especially language interoperability is
a field where I could have a whole talk
of its own and maybe for each language a
full talk and this is very new research
we had a PhD student currently working
on that at Jake huling Tatyana's Kappa
University in Linz and we're currently
taking over that that approach into our
engine so the demo I've given you has
been shown for the first time two weeks
ago at JavaOne we really try to
integrate that and make that work for
each and every scenario but there is
much more we could talk about if you're
interested keep listening to our Twitter
feeds and to our releases what we are
also working on is parallelization
javascript is a single threaded language
but there are many ideas out there how
you can paralyze it we are also trying
to paralyze our executions we have an
software transactional memory approach
there how we automatically parallelize
loops but we have also other ideas how
we could give an API to a user to
execute code in parallel on the truffle
levels on the language interaction level
we are working on instrumentation we
think you should be able to instrument
each and any program that you have
regardless of what language it's
implemented in as we can share data
between languages that shouldn't be a
problem and based on that we provide a
debugger solution and also analytics
tools for you
our program so for instance we're
currently working on a debugger that you
can debug our applications applications
that are implemented in more than just
one language for instance in the
NetBeans debugger being Oracle database
has to be everywhere so we are also
working on database optimizations with
some ideas how you could optimize the
database access from no chance from
JavaScript applications also from Java
we can use the same system of
specialization also there may be nicely
if you want to learn more on what we are
doing I told you before Grall is open
source you can download it you can
compile it yourself and that's
everything you need to implement your
own language if you have one language
you want to add to our list you can do
that make an open-source project on it
and please tell us about it
also if you just want to use the
JavaScript implementation we have a
technology preview released on the
oracle TechNet work you can download it
there play with it a bit this language
interoperability as I've shown you the
demo I've given you should be working
there if it's not please tell us we know
that this is really research we still
put it out there for you to try out tell
us what you're interested in
tell us your scenarios and we will try
to make them work and integrate them in
future releases that's all from my side
thank you for your attention and if you
have any questions we have 10 minutes
left to answer them
I have a hard time seeing you but are
there any questions yes yes okay the
question is in my example I've written
the JavaScript a function and exported
it and used it in R is it possible the
other way around and can I do the same
with Java
honestly I try to rewrite the demo so I
start with JavaScript and that didn't
work I just got a crash but that's what
I said we just integrated that three
weeks ago the idea is yes
you should be able to do that from each
language to each other language we can
even better than I've shown you
integrate with Java but that's not big
news now so one can do that or has been
able to do that for two years now Rhyno
has been able to do that but between our
truffle based languages we should be
able to export functions export values
from each language to each other
language we're not there yet or it's not
100% working at least I wasn't able to
make it work but that's what we want to
do any more questions yes
thus the growling does the growl VM
target dynamically typed languages the
answer is yes but you have seen that C
is on our list of supported languages so
initially we thought that dynamic
languages are the main target here
because we can gain most benefit
JavaScript Ruby peyten
that are ideal showcases for
specialization as we've shown it but as
you as you have probably seen in the in
the language interaction benchmark C is
fast C is way faster than our JavaScript
examples and that the C implementation
that we have is almost as fast as GCC
not in all cases GCC is a great product
and we have a hard time beating its
performance but we can also work on
statically typed languages like C and we
also have an language engine for closure
and for airline student is currently
working on that so we try to target more
than just an MHC typed languages but the
man a meekly typed languages are really
the main idea why we did it and where we
are best at
so a Java interpreter that interprets
Java code yes you can do that we even
think that that would be quite
reasonable to do if you re implement
Java as a truffle based language because
it would make some things especially in
interaction way simpler right now Java
is always a special case for us because
Java is different than all the other
languages for us if we reimplemented
Java on top of truffle as a as a
language interpreter we have thought
about that before yes but it's not it's
not totally necessary but if we find a
student that is interested in doing that
might be a great topic any more
questions if not then thank you I will
be around all day so if you see me and
have more questions feel free to ask me
thank you bye</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>