<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Serenity-JS: next generation acceptance testing for Angular-JS in TypeScript by John Smart/Jan Molak | Coder Coacher - Coaching Coders</title><meta content="Serenity-JS: next generation acceptance testing for Angular-JS in TypeScript by John Smart/Jan Molak - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Serenity-JS: next generation acceptance testing for Angular-JS in TypeScript by John Smart/Jan Molak</b></h2><h5 class="post__date">2016-11-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YYgkFgBxEwc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome today we're going to be talking
about a game-changing way of writing
automated acceptance tests in JavaScript
cool hello guys so my name is Yann maroc
and you probably already know John smart
we're working together mostly in the BDD
and test automation space so what we'd
like to talk to you about today is what
we believe is to be the next generation
of acceptance testing in JavaScript and
typescript as well and what we think
should work really well with all the
modern applications especially angular
ones and any other stuff that you can
test with protractor so what we're
really trying to achieve here is to
bring to the table some of the advances
we've seen in other areas of automated
acceptance criteria to the JavaScript
world because we've found that in the
JavaScript world seem to be lagging a
little bit behind in a lot of these
areas and we've been wanting to bring
basically the power of what we can do
with techniques like behavior driven
development with requirements discovery
with sustainable test automation
practices and bring that to the world of
JavaScript so that you can have the
advantage of basically have your cake
and eat it have the advantages of these
really sustainable efficient automated
testing practices not only in the world
of Java but also with your front-end
applications precisely now before we go
into the details let me just ask you a
question do you know what's the root
cause of most issues with software any
guesses users all right
be much easier with at least 10 users
when the so it turns out that one of the
major issues is well it is people yeah
that's right but one of the major issues
are the requirements so how big of an
issue that is you think a show of hands
how many of you think that let's say 10%
of all software defects are caused by
requirements let's say 10% make more
okay 20 50 75 100 okay
so according to research that's been
done over the last 30 years or so
between 44 and 80% of all software
defects due to ambiguous unclear or
simply incorrect requirements and
funnily enough those problems have been
around since known 1985 that's when I
found the first study through 90 95 2005
and intellivision days as well so
despite the changes in technology the
main issue is still the same
so it might make sense that as part of
our test automation effort we should
perhaps address the root cause of all
the problems and so that's why behavior
driven development comes into play
behavior driven development is basically
approach that brings together
requirements discovery and a tight
feedback cycle that you get from test
automation if it's done well behavior
driven development is really about a
conversations about conversations you
have with your business with your
product owners and with your developers
any testers to try and build software
that actually matters who builds
features that make a difference and
that's what we're trying to achieve in a
nutshell when we do techniques like
behavior
driven development have any of you used
BDD in in practice on your projects okay
excellent
and how about the main driven design all
right excellent yeah cool and what about
the user centered design okay
some of us well not as many so what
we'll look into today is how we can
bring together the techniques of
behavior driven development of domain
driven design and user centered design
to give us this next generation of
acceptance tests what we fired was the
biggest problems with acceptance tests
with automated tests in general when we
go to client sites and we see how they
do them it's a flaky as hell they're
very it's very hard to get them to scale
reliably and this creates a whole chain
of problems because we end up with
tested a and that basically people don't
believe you don't trust some the
business doesn't trust them if the
business doesn't trust them then we
can't use them as part of the build
cycle they don't give the feedback we
need there's extra time that people need
to spend debugging them or triaging them
and so this leads to a whole chain of
problems basically defeats the purpose
of any approach any movement going
towards lean or DevOps so what we really
need to do is try to make our tests what
we identified here are three main
attributes so we want our tests to be
reliable so if it passes it passes it
fails it fails it sounds obvious but
it's a lot of tests become flaky very
quickly when we get into the acceptance
test level we want them to be scalable
and I don't mean scalable just that you
can run a thousand tests in a reasonable
amount of time
we want them scalable in the sense that
if you bring on 10 new developers or ten
new test automation specialists you want
them to be able to come on board and be
productive very quickly you don't want
to have a Byzantine monolithic test
framework that nobody could understand
and when you change something over here
breaks something over here which is
often what we see and we also need them
to be actionable
them to be presented in a way that you
can actually do something about so that
you can see the results and figure out
basically what's the purpose of your
test Wells to see whether your
application is release ready so a list
of test results doesn't really give you
that it might have a hundred tests of
the green but if they don't test the
right features not a lot of use so we
want tests that actually show
demonstrate the features that you're
trying to deliver and how those features
are tested if we can get to that point
then then it starts get interesting
mm-hmm and because BDD is all about
having conversations around concrete
examples we would like to give you a
concrete example right now so okay how
many of you have heard of cucumber or
maybe used it on a project lovely and
how many of you think that it's a very
good test automation tool okay not too
many very good interesting
so it's cucumbers one of those tools
that's greatly misunderstood so even as
phlox said and I'll quote him here
cucumber is first and foremost a
collaboration tool rather than the test
automation tool and please keep this in
mind while we go through the example so
here's our feature that lets say we
discovered us all as part of our BDD
process of part of our three amigos
so I'm sure you're probably all familiar
with to-do lists reminders all this sort
of stuff so that's an example of such
application so we have a feature that we
would like to filter the list to find
only items of interest and as part of
our UX process we've identified a
persona of of James so we would like to
enable this particular feature for James
so so far so good
now let's say we've got a number of
scenarios of how this specific feature
could be used so in here we've got James
starting with a list of two things
he completes one of them then he selects
a specific filter and he only sees the
item that he hasn't completed yet so at
this level is all very high-level very
business specific we've got no reference
to level of implementation nothing about
clicking buttons entering values into
fields nothing like that
so so far so good so we've got scenarios
now the next step that we would need to
take is to automate them and that's
where some things might start to fall
apart so from communication to
automation so let's see how we can
automate this scenario we just looked at
so first of all if we are using cucumber
tears we need to create so-called stably
Phoenicians I'm guessing probably some
of you have seen those before it's hands
up if you dub this sort of card with
cucumber JavaScript anyone Oh Java or
Ruby I mean it's all similar concepts
yeah cool it is a teleconference cool so
the first idea that we might have about
automation is that we could try to
implement our tests like that so what we
do is to be jump straight from cucumber
from this high level definition of
business goals business objective
personas and all the business lingo
straight to protocol API or in Java
world that a webdriver API so very low
level driver that interacts with the
browser and here's who were so many
problems actually start to crop up so
first of all how easy can you tell what
this code is doing it's quite a lot of
things happening here right so we
navigate in a specific page we're doing
some data transformation or maybe we
need to split a list when to transform
it and do some stuff and at some point
we actually interact with one specific
element of the website now the problem
here is that cucumber step definitions
are
not really designed to be assured or
reused right Cumbres basically a parser
of scenario files that then execute the
code of your test framework so if we
just try to directly invoke protractor
we might end up with code like this so
code that's not really readable or
reliable or easy to maintain easy to
change and so on another problem is that
now if we make this jump straight for
cucumber to protractor we lose all the
business context we jump straight from
the business domain to our
implementation domain so try to give
this sort of code to any of the business
stakeholders on a project to read and
verify it's pretty much impossible
also if a test on this fails will only
have the granularity of our report
pointing class at a specific step in a
cucumber
scenario not a specific task that the
user was performing so that's probably
not what we wanna do so there is another
popular approach in the JavaScript and
protractor world is to structure those
tests a little bit better so instead of
just writing the script we could try to
come up with some page objects and have
any of you use page objects on your
projects quite a few yeah all right
let's step in the right direction mm-hmm
definitely and quick question actually
how long do you think a page object
class should be how many lines should it
have let's say 50 is 50 okay just raise
your hands if you figure 50 is fine okay
100 miss hundred three okay okay 500
we've seen some that were actually 1,000
lines or longer so we'll get to that in
a moment so what you see here is now
instead of just calling the API is
directly we created some page objects
and we're calling those instead however
this didn't really help us that much
because now we still have a lot of noise
a still of data transformation here and
we really still have the same problem
and if we look at our page object
definition
well we've introduced some concepts of
the domain of vocabulary here so we've
got things like adding items to a list
or maybe completing an item or removing
an item and so on and those will work
fine the trouble is that the richer your
domain is and the more complex your
application the longer those page
objects get and this of course affects
the reusability of code and
maintainability and how easy is to share
because now at the point in time where
the speed of the original 500 or 1,000
lines of code they're just no big blobs
of stuff and it's quite difficult to
figure out what is their responsibility
and obviously it's no longer single it's
a problem with this one is that in
JavaScript you also have to synchronize
any operation within cucumber steps with
the cucumber driver so protractor same
as the webdriver J's library they use
their own implementation of promises so
that's what's called the control flow so
they're not standard nodejs promises
there will be just scheduled put on a
queue and executed at some later point
what this means is that cucumber is not
aware of this promise train so if you
say say have no 10 test steps in
cucumber and you've got your failure in
the third one it will just help you go
through all the steps and tell you that
all the steps have passed and we've got
a failure in the last one so that's
problematic especially when you try to
figure out where the issue is
okay so can we do better and that's
actually the core of what we wanted to
talk to you about today absolutely
button have you guys heard about it at
all
okay flow table nice good any good
things okay so let's take a step back so
if we try to think about our acceptance
tests not from a perspective of a
browser that interacts with web page but
from a perspective of a user that is
trying to accomplish some tasks or some
goals we've in our systems then we could
use a technique that's called
hierarchical task analysis in user
centered design so what is all about so
with this approach we start with an
actor so either a person or an external
system that interacts with our
application those actors have some goals
they try to accomplish it could be to
make a purchase of a product or to
register an account or whatever our
business goal is in order to accomplish
those goals
the actor needs to perform a number of
tasks those tasks are then composed of
interactions with your system so if we
have a look at the future definition as
we had it before we could try to go
through this process of task analysis
and try to slice our scenario definition
in a slightly different way so it's
still the same feature file sealed to
the same scenario but now let's try to
identify the actor so it turns out that
if we have a UX process in place we
might actually already have some
personas so that's cool so we could use
those in our test as well if we use
cucumber well we already have the goals
where the goal is the title of a
scenario so that's what the actor is
trying to accomplish in as specific
case now where do we get a task strong
if we keep our given went and dance at a
reasonably high level and focus on
business objectives then those tasks
though those steps from the cucumber
file could be actually mapped pretty
much 1 2 1 2 tasks of the user so in
this case we've got James who wants to
see active items only and here seems to
start with a specific state of a system
perform some tasks so complete an item
filter released and then he expects to
see something now if we take this idea
further we could actually see that some
of those tasks can be composed of other
local level ones so for example to start
with a list containing some items it
means to open the browser resizes added
to the item and so on and we could
continue with this process until we have
a fairly rich vocabulary of all the
activities that a user or an external
system can perform within our
application and then at some point those
tasks we need to interact with the
system so there will be a layer of low
level interactions so at this stage we
only say that we enter a value into a
field or click a button and so on now it
would be pretty cool to be able to
express that in code as well right so
that's what 73's allows you to do it
allows you to build this rich vocabulary
based on some interfaces called
templates and so on and design your
tests in a similar way as you would
design a workflow from a user experience
perspective so the impact of these tasks
these actions is interaction objects
using objects instead of functions using
the way we've structured at there and
what we'll see shortly in the code it
is really a game changer when it comes
to making your test Suites maintained
while making them easy to scale in the
sense of bringing people on board it's
much easier to get people up and running
very quickly much easier to come back
and maintain the tests and there are a
lot of nice characteristics and the
reusability of these tasks these objects
where once you do what it's good you
don't need to touch it anymore so the
maintenance goes down drastically you
don't ever need to change a task once
it's completed unless the application
underneath it changes makes it much much
easier to maintain the codebase and
we've seen this in practice you can come
and ask us after the talk where we see
these in practice many times it is
really very spectacular so let's have a
quick look at the parts that make up the
screen play button so first we need to
define what the actor is so it's very
straightforward
we just use a new variable and say let's
call our actor James as an actor named
James now the next part of the screen
play pattern is the abilities so in this
case James is a persona who's capable of
using a web browser and he could be
using other means of communicating with
our application as well he could be
using a rest client or an FTP client or
pretty much any interface to the system
that we have one minor detail here we
are actually using typescript rather
than JavaScript people familiar anyone
familiar with typescript if you're not
familiar with typescript there's a talk
on it by someone who we mentioned
earlier yes yes there is a talk tomorrow
afternoon on typescript if you want to
learn more about that so an actor can
perform tasks so in the case of the so
in today's implementation what we do is
we basically invoke the attempts to
method on the actor and we give it a
number of tasks objects they're just
busy
the commands that you can chain together
and if you wanted to plug them into the
cucumber steps well the only thing that
we need to invoke there is this code
james attempts to start or perform some
other actions so it's pretty much a
one-liner so we don't really have any
additional code in our cucumber step
definitions that's where we're using
this one-to-one mapping characteristic
of this code and because the tasks and
interactions are just classes those can
be reused much easier than cucumber step
definitions now another property of
those tasks is that they can be composed
of some lower-level ones so as you've
seen before to start means to open a
browser resize the browser window and
add some items now what does it mean to
add an item it means to enter a value it
means to hit the enter key
so it's all pretty straightforward right
I mean we're able to explain how the
pattern works to you in about 10 minutes
or so so what we've noticed is that this
is a very powerful concept and it's very
easy to grasp no matter how experienced
the developers are because if their
developers experience they can grasp it
in a couple of minutes if less well
maybe like half an hour or so but it's
still very easy very easy to understand
now another property of a task is that
it can be annotated so that's a feature
that comes with typescript is that some
methods can have annotations and the way
we use them is we use them to map a task
class to a piece of text that will be
then used to generate a report of our
test execution and those reports are
what you can very easily present back to
business stakeholders so what they can
do is they can go through through HTML
click on every single one of the tasks
figure out what it means to perform a
specific action find an attached
screenshot that shows the state of the
application at which it
when the task was performed so it's
quite a powerful media to explain to all
parties in your organization how your
tests work what is the value of those
tests and we'll show you those in a demo
in just a second visually just a second
thinking listen magic
so all the code that I'll be showing to
you now is available on github 73's is a
free and open source library that you
can clone right now and tell you the
example yourself ok so let's start at
the feature file level so as you can see
here I've got an example project usually
have some feature definitions some
source code for a project and so on
at the feature level I have grouped the
feature files into directories and those
directories correspond to high-level
capabilities of the system and those
will become important when we analyze
failures of tests in order to find out
what the severity of the failure is so
let's start with a feature file as you
can see we can just go through each of
the steps see the invocation of a task
see it has definition the annotations
and so on the same thing as in our
presentation but let's try to run the
tests now so I'm executing them using
just the regular and p.m.
so that probably looks familiar I think
Sofia
so as you can see under the hood it's
still executing the regular protractor
interactions with the application
with this minor difference but after a
test run we can have a much more
in-depth report and I hand over to John
so essentially what these reports were
about or not they're not just test
report series a list of test outcomes
you have your the tests that we execute
and whether they pass or fail but that's
boring what's really interesting is the
fact that what we are really reasoning
about is not test out not just test
outcomes but capabilities and features
that we're trying to demonstrate so the
point of a test is to demonstrate that a
feature is ready to go into production
you have a number of tests which
collectively can build confidence in
whether your features are ready to go to
production and that's what we're doing
here so we've got the fine things to do
capability and that is made up of one
feature filter the listenor in a beer
application you probably have more and
then inside that particular feature we
have what we saw in the cucumber file in
order to limit cognitive load and so
forth and we have a number of acceptance
criteria for that feature which map to
your acceptance tests and then if we
want to drill down into those we could
drill down into any one of these and we
see these are the tests that we saw
being executed earlier we can see the
description of what the feature is and
then underneath we get a high-level
overview of how the feature was
demonstrated and if you're not satisfied
if you're not satisfied of what that
means and he completes write some code
then you can open it up and see what
that actually means so James marks
writes and code is completed and how did
that work well he clicked on the check
box you know down as far as you need to
to illustrate exactly what you're trying
to do or keep it at the top level if you
just want to some summarized version
then naturally you have screenshots to
illustrate each step so what we have
here is what we call living
documentation at a top level
viewing from what capabilities and
features
are ready to go into production and from
a detailed level how does each feature
work so it's all nice and well when the
tests pass right so let me just break
them for you quickly so we see how this
is reported as well okay now you're here
write some code and I think I probably
need to get a coffee as well and p.m.
run clean so I'm just removing the test
results from the previous run and p.m.
test so what it does is I introduce a
change in one of the feature files which
will cause the test to fail and I should
be able to show you how the failure
reporting looks because what you might
have noticed on the previous screen or
the report was shown is that we didn't
show any no expose selectors or CSS
selectors or any of this noise because
now if all the tests are working fine
then there's really no reason to pollute
the report with this sort of low-level
implementation detail however if the
tests fail will actually give you all
the details so that you are able to find
where the problem is so now we can see
we've got a big slab of red but it gets
more interesting because if we go into
the actual failure we can see it was
viewing completed items only which
failed let's see what went wrong we were
expecting write some code and we that's
been cut off so we want to see a more
detailed version expected write some
code to Rico write some code get a
coffee so we get a business level
description of what went wrong which is
if you're trying to figure out as a
tester what has actually broken this
gives you a very fast way of identifying
what's going on then if you really need
to see the details you can have a look
inside the test but at this level we're
talking in business terms not in terms
of XPath or so forth and what this
translates to in business terms is that
if you have your business person looking
at a test report they can immediately
see that well check out is broken or
people can no longer pay for our
products
and that's important right it's much
more powerful than telling them well
we've got five tests out of 500 failing
and there is some problem with a
selector and people get bored when they
see the sort of sort of stuff so all of
this code is available on this
repository on github so if you please do
check it out
clone it and play around with it and let
us know what you think and we will hang
around a little bit for people who want
to have questions I think we are we have
been out of time for some time now so
thank you for staying a few more minutes
and listening to a full presentation
thanks so much for the time if you'd
like we've got some selling today
stickers here as well so yeah come over
say hi Ekans laptop stickers they're
very cool</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>