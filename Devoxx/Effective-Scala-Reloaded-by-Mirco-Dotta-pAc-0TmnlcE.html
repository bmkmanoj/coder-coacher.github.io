<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Effective Scala: Reloaded! by Mirco Dotta | Coder Coacher - Coaching Coders</title><meta content="Effective Scala: Reloaded! by Mirco Dotta - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Effective Scala: Reloaded! by Mirco Dotta</b></h2><h5 class="post__date">2018-03-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/pAc-0TmnlcE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right welcome everyone so we all
want to get to be more effective Scala
developers I guess but who's new to
Scala who hasn't done any Scala or very
little Scala okay and who's been doing
that for maybe a couple of years two or
three years okay good then I guess this
is gonna be interesting for most of you
so just a few words about me I'm the
co-founder of triple quad maybe you've
been at the growl talk before that's the
company that Thomas couldn't remember is
triple quad and we're doing the aedra
compiler so I drew is a commercial
compiler for Scala and what it does it
allows you to compile Scala faster and
how does it do that well they compile in
parallel so he uses all the course that
you have available in modern out there
that's about the plug about triple quad
added doings about me I've been doing
Scala for quite a long time now and I
contributed to several open source
projects among which like all the Play
Framework and the Scala compiler itself
so the golden rule I would say for Scala
and throughout this whole talk is that
we want to try to keep things simple and
and I think you should do this even more
in Scala considering the full
opportunities that the language gives
you to actually make things more complex
than they need to be so doing scale I I
often feel like that guy like I'm a
super here you know I create this
beautiful code at least it's beautiful
to me it does tons of things in you know
maybe one or two lines of code because
there are lots of other things happening
behind the hood but the thing is that
despite you feel like that guy there are
always guys feeling like the other one
in you know in the back blurt that
really doesn't get what you're doing it
was forced to be wearing this you know
superhero costume but he actually
doesn't have a clue or what you're doing
and it doesn't have a clue about what
the code does
so it's not because it's color you can
do a lot of things it's not because
Karla offers you all these tiny while
all these shiny tools that you should
use all of them together at the same
time in every project otherwise you end
up like this guy which is definitely
being me several times in my life I just
give you a few seconds to retreat
hopefully you can all relate to this to
this comic you've write code it looks
beautiful
then you do just don't touch you for a
for a while you go back to it it's like
well you know I don't really have a clue
what this code is doing so this talk is
going to be opinionated it's a lot of
pinyon opinions it's going to be my
opinions I'm sure that not everyone will
agree with my opinions which is great
because it means where I have a lot to
talk at the end or after the talk so
you're very I would you know I would
encourage you to ask us many question at
the end or after as you as you can and
one I'm very apt to discuss all of these
things and I'll also see whether you you
find that some of the things I say they
actually make sense to you as well so
the agenda we're gonna start with some
stylistic decisions that you can make
about how you write your code that
sometimes they actually tend to be not
just style but but also have a huge
influence in in impacts that you may or
may not catch a compilation so we'll see
what those are and I'll give a few of my
mantras what I think's are well things
that in scholars should really be part
of you you shouldn't even think about
these things you should you you should
everything you they're really part of
the philosophy of Scala now you should
be writing Scala code and I will have a
short plaque on collections and implicit
on things that are you know you should
maybe do one way instead of another way
so do's and don'ts on on collections and
implicit so style let's start by saying
maybe for the people that are just
approach is calendar new to skull I
would say you should really try to learn
the scholar way of doing things so try
not to bring too much from other
languages which may or may not make
sense
for Scala depending on your background
so I actually spend the time to look
into the Scala guide available online
and and try to stick to those
conventions because well probably the
people you'll be interacting with either
at work or on the community they will
probably follow the same convention so
it's about trying to have a similar
style and avoiding you know confusion
and unexpected comments maybe on your
pool requests and and the other aspect
about style is also about having a
common style and forcing it so use some
automatic tool for enforcing that
whether it's Scala style or Scala fmt
you know whatever tool you prefer but
the point is try to avoid spending hours
or countless time over discussing style
which really doesn't matter at the end
just agree on something
have it autumn I have some automatic way
for checking the style and then move on
you don't have to discuss that for every
pull request absent members so what do
you think about this definition would
you you know we we define a field edge
it's an abstract and we made it a ball
is the fact that is a vowel or a death
making any difference
okay so this is just an abstract
definition but basically what you're
enforcing by doing this is that the
implementers of this abstract method as
a Val they cannot override this
definition and make it a death so you're
basically saying that that field is a
state is not computation you're making a
very strong case about it and you're
basically disallowing anyone else from
overriding with computation so if you
don't have a really good reason for
doing that then you shouldn't do it then
always use a def as I said it's going to
be opinionated so when in doubt of where
you don't know use a def so that you're
actually giving the Liberty to
implementers to decide whether there
should be a death or a Val yes so when
is a good idea to use file instead of
death it depends on what the valley is
supposed to old let's say that is
suppose to old some costly
implementation that maybe there are some
other methods in the same try provide
some implementation calling on this
abstract field in that case if you
expect that that after our field is
going to be costly to exit to compute
like accessing the database maybe you
don't want to do that for every call
that make it a field so that you're
actually forcing that into the
implementers through through your taking
a decision as the API designer you take
a decision you have that Liberty you can
take a decision a strong decision for
everyone but if you never good reason
for doing that don't do it make it a
death that's really the point of this
light if you don't do it if you don't
know just make it a death and move on
you don't have to think about it it's an
easy decision so another one it's over
right which is Scala
it's mandatory if you override on a
concrete member
but it's actually
optional if your overriding an abstract
member and I'm going to tell you always
use overwrite unless you have a good
reason not to and there are possibly
some reasons where you don't want to use
it it goes back to our linearization
works and now when you mix several
traits out things may work and now you
may want to allow some mixing instead of
others but more often I would say 99% of
the case you're not thinking about that
okay so let's take that away so why
wouldn't you put overwrite I don't know
I would always put it because this way
if someone goes and change the
superclass you changed the methods that
I'm overriding the compiler will tell me
hey this this method is not overriding
anything so I I have a compile time
error about you know Santa that has
changed
that's one reason second one is when I'm
reviewing the code it actually adds me
understanding ifs and if a method it's
being overriding something or not
another very easy one is don't leak
types especially try to have explicit
types for all your public members so in
this case if we look at the apply method
what is the type that is being fed by
the compiler it's going to be the
standard logger type so you're actually
leaking this type the standard logger
type that you may be meant to be sort of
an internal and implementation detail so
be explicit in this case and just say
this is a logger right and even you
could go even a step further and
actually make the standard logger a
private class so that actually there is
no way for that to leak right because
the compiler would tell you you're
actually leaking a type that is private
and that's not okay and that's basically
the point I was making about making it
private it's here use the access
qualifier that you are yes the access
qualifiers that you have in Scala to
clarify your code when I'm reviewing up
a request no mean if something is
accessed by everyone or if some is meant
to be accessed from everyone
outside or not yeah it actually makes a
difference I want to know what is the
API and what is actually implementation
detail so because in Scala the default
is that everything is public where you
don't specify it
they used the access modifiers to
actually specify whether Santa is
private protected and so on and in fact
you should you know you should be aware
that Scala has much richer access
modifiers than say Java or C sharp or
other languages you may be used to in
fact in Scala access modifiers can be
augmented with qualifiers so if you look
at the example at the table Java in
Scala
you could basically express the same
semantics if you look at packaged
private in Java and now we express it in
Scala that's using a qualifier so it's
private and then E qualifies basing by
its private to this package so it means
that the only classes within that
package can have access to let's say the
member that has that visibility and and
in fact there are a number of
interesting things that access modifiers
with qualifiers gives in Scala for
instance did you know that private
members of companions can access each
other's so if you let's say you have a
class where you have a constant you can
actually put it in the companion object
make it private and the class can still
access that member you don't have to
make it public and by doing that you're
actually getting some performance
benefits because it's a constant is
going to be inlined so you know whatever
the field contains it doesn't it will
not be a look at it several times for
the many instances of the classes that
you'll be creating so is Carla being
more functional language we tend to
write recursive code right at least I do
tend to do that quite often and one
thing you should make sure is that when
you write recursive code you're now
going to blow up the stack so in order
to do that you need to make sure that
your implementation is stay recursive
so meaning that the last call in your
implementation it's always either the
recursive call to the method or a value
that's the only place where our
recursion is allowed this as the last
expression in in the method
implementation and you know sometimes it
may be hard to understand whether sunday
is a recursive or maybe you
understanding and someone else comes
along and then it changes the
implementation and silently is no longer
tape recurs so in Scala what you can do
is actually using any annotation you use
kalinihta Shantay track and then the it
will be the compiler job to tell you if
the implementation is not recursive
there will be a compiler error so a
compile time you will know if the
implementation was changed in a way that
is not recursive anymore and lasting
about style
I'd really like string interpolation and
I really don't see any reason for
writing a two string like in the first
way I would rather use string
interpolation because it makes it easier
to read
on the one side but it also makes it
easier to avoid errors because this reel
and I am variables they actually checked
a compile time if I'm going to refactor
the name of the field reel to something
else I will get a compilation error
again so the only reason why you may not
use string interpolation is for
performance reasons because
behind-the-scene is going to create a
string buffer basically it's going to
concatenate these different elements so
if you have those kind of reasons fine
but again I would I would expect that
most of the most times you don't have
that kind of needs maybe especially for
a two string and so using a string
interpolation makes a lot of sense
because it makes your code more readable
and and just nicer good let's go with
mantras first use the rep you have this
fantastic tool where you can just you
know try things out very quickly if
you're using SBT just type console you
get into the base color wrap and for you
all all all the
that you defining in the class part of
the project that you're working on
they're gonna be available in you know
in the rep so you can actually
experiment and explore the API of those
dependencies that you have in the
project it's really useful you want fast
calico elation other than using our
compiler then what you should do is
really try art to stay in a JVM that is
warm because that's going to deliver up
to 2x speed-up just by having a warm JVM
and I'm telling this because I've seen
people like experienced Scala developers
like they use SBT and every time they
wanted to compile they will go with SBT
compile so what happens there is that
basically you will never be you will
never have a warm JVM to compile because
if you type as PT a you enter the
interactive shell so and then you
compile only when you're inside the
interactive shell the compiler it's
going to be well you know you'll you
profit from hotspot and so you you'll
get the JVM that does the compilation to
warm up and that we reflect in in your
computation time so you will actually
have up to 2x compile boosting compile
time just by staying inside SBT instead
of compiling from outside and and for
maven is the same or Gradle or or the
other build tools there is this zinc
server so you can just basically there
is documentation for spawning a sync
server so that when you compile you're
actually sending sort of a computation
event to the server and the server is
going to be kept on the background so
that as you compile it will warm up and
you will benefit from having a world JVM
this is a really simple things to make
you way more productive Scala is an
expression oriented language so
expression so what's the difference
between expression and statements so
statements basically returns the unit
they returns null value while
expressions they always return the value
so what is this the fundamental change
when you
an expression oriented language well you
can compose things together you can
chain them because you always ever read
a value on which you can do something
right so you can compose these things
together which is something you cannot
do with a statement oriented language
like you know like Java or an imperative
language just in general so yes my
reason is really that it makes your code
an expression oriented language makes
your code shorter simpler and composable
and that's really that has huge
implications so let's just have an
implementation what I'm doing is I'm
just trying to prepare some HTTP page
and I can get some exception and based
on that I will have to return a
different kind of page and I'm writing
these in a very imperative way assuming
that I'm not using Scala but let's say
this is sort of a Java like
implementation how I would do it is
Carla but let's say I'm using Java so
I'm doing it this way so I need to
create a bar because try-catch is a
statement it doesn't return a value
right so I need some way to sort of old
the state that is going to be side
affected by the try and the catch well
but since Scala is an express expression
oriented language and considering what I
told you so we can make things shorter
and simpler let's refactor that and this
is how it would look action in Scala we
don't need this extra variable try/catch
is an expression so it returns a value
so we don't need to old any state
outside of it we just return the value
right but I just told you that try-catch
is an ex is an expression so what's
interesting is that if you look at the
catch that's actually a partial function
on the right hand side of the cache
right so we can actually break that down
so we can break it down let's say that
we have some complex logic that we want
to reuse across different methods so we
extract this this logic and we create
two methods this time out catch and no
page catch and now we want to reuse
those in the initial implementation how
do we do it well we compose right it's
really the beauty we get expressions
so we can compose them together and we
can reuse we don't have to repeat
ourselves return I should really not use
return Escala there is really not a good
reason to you to use a return and
actually it's so bad that in my may even
have a performance implication that you
don't expect the fact that you use a
return so let's have a look at this code
you know we're just process advice and
then we're basically giving the
opportunity from the outside from a
different thread to sort of stop this
computation this is what the is this is
interrupted variable is useful okay and
then if basically someone tells me I
should stop I will just return is this
compiled who knows so this is how it's
compiled so the return it's actually
translated into an exception so it will
throw an exception and it will catch
that exception so that you know
basically you terminated the computation
it does what you expected to some extent
actually but it does so we throwing an
exception you don't have to do it this
way right you can just you know have a
filter instead of having a return and
just stopping the computation in I would
say a very normal way so really just
avoid using return because it's not just
not idiomatic in Scala
but in my translate to code that you
really don't expect to see and the other
thing is that if you look at
implementation actually at the initial
one
well would you expect that the logger
dog is so considering now okay well now
I wanted to make another point but let's
let's let's go on another simple thing
in Scala don't use now
honestly the only time when I wonder
about Natalie Scala nowadays is when I
interact with Java libraries and then
it's always a hell I never know what I
have to do I always have to go and check
the implementation does you know is this
returning null or not this method call
and then if it does then I have to wrap
it inside an option even though I'm not
telling you this right away so Natalie's
really a disease like null checks will
spread because you always have to check
whether something is null or not and all
the caller's have to do that so it's
really a domino effect
nullpointerexception will still happen
besides the fact that you know you you
try to avoid them with these null checks
but they always end up happening because
you always forget some place where you
should be checking if something is null
or not and the assertions won't really
help because if you know if you get a
null pointer in production the assertion
didn't really help I just get a
different kind of exception maybe but
it's it's just still as bad as as having
a null pointer so it's Teddy Scala if
Santi is now just use option instead and
and basically make that information part
of the signature Express the fact that
something may or may not have a value
and and it's really about being type
safe and about documenting what you're
doing if I again if I'm looking at a
pull request I see a method with a
signature that takes an option it's
really clear there that in my arm I know
I have a value that I'm passing to that
method if the evaluation could be passed
as an al I have no clue about it so here
is an example of how using option so on
the one side it's documentation so it's
part of the signature and on the other
side the code actually it's pretty neat
I don't have any null track I don't have
you know it just flows like I can just
read it it's clear if I have a username
and I have a password if I can
authenticate the user with a given
password then you know I just give the
privileges for the user and I move on so
but but on the other side I would also
say don't overuse option
well because when when you use an option
you're also forcing the color to handle
that option right you will always have
to say well if I have the value I will
execute this logic if I don't have this
the value I will execute semadar logic
and so on and and there are cases where
actually having a null object is a much
better fit so a null object makes it
transparent for the color you know what
you're gonna return whether whether
something that is supposed to render you
know a proper page with an authenticated
user or maybe scientist that is supposed
to produce and he like a 404 for the
color is completely transparent because
he knows only has to call maybe it's the
render method so as long as you can call
the render method it doesn't matter to
him what kind of instance he got so
again I would say option are good but
abusing them tends to actually create
code that is not so easy to maintain or
so easy to read and so there are
situations where you should actually be
thinking about using an awl object
exceptions and control flow again I
think this is something that at least
I've seen a lot when I was too in Java
and and I don't see as much when I when
I do Scala but it still happens from
time to time you know when you have an
error that is an application error you
should really not be throwing an
exception but you should really make
that information part of the types so
you can use either you can use
validation maybe from you know these
functional libraries like Scala see your
cats and make that part of the contract
of the meta so the method is suspected
to either return a value or maybe a set
of errors and those are only expected
and valid by return values then there
are exceptions are for exceptional cases
are for things that are not expected
application errors but things that we
cannot recover from so in that case it's
absolutely fine to try an exception but
I do not expect the color to react on
that and of course there are frameworks
maybe like caca that expects you to draw
exception because that's how they were
science so of course in that case it's
fine to throw exception but I would say
in your application code if you're now
forced into doing things because of a
different framework don't do it make
sure that you express the error as part
of your signature immutable let's always
stay immutable three reason why it
matters I don't know what are yours but
those are mines definitely simplified
reasoning why because I can just use the
substitute principle so if I have you
know some code that does something but
it returns an immutable value I can just
replace the competition from the
immutable value and keep reasoning about
my code there is no side effect that I
need to track in my head because that's
not what an immutable object is right so
it definitely simplifies reasoning
another thing is that it allows going
contravariance so variance it's
complicated but if we think about Java
well arrays in Java okay so I have a
string of array and then I have an array
of objects and I assigned to this array
of object the array of strings that's
okay because in Java arrays are
covariant so it means that if a is a
subtype of well in this case if string
is a subtype of object then an array of
string is a subtype of an array of
object and that's okay so I can do that
but then if I can do this since an array
is mutable then I can actually put
something into the array of object let's
say I can put an integer right well if I
put an integer in an array of object
which is actually pointed to an array of
string that's definitely gonna create
some problem at runtime and so this is
the kind of problems that you can get in
Java this is bad if type-check language
allows you something like that it's bad
because it's basically not protecting
you from something that should actually
be an error at compile time the reason
why it was done this way I'm not gonna
get into it but the point here is really
that mutability and variance means
trouble if you have immutability you can
have cohen contravariance so if you look
at the skyline mutable
actions that's why you can have
covariant collection you can have
covering mutable collections while if
you look at the mutable scalar
collection they're all environment and
other nice things that immutability
gives you is actually a way to define a
correct equals and hashcode in fact if
you try to define equals and hashcode on
scientist that is not immutable then
that's definitely a bad implementation
you cannot you cannot respect the
contract of the equals and hashcode if
something is mutable and of course
getting back to my initial point it also
simplifies reasoning about concurrency
because immutable objects are thread
safe by design
so with that I don't want to say that
you should never use mutability but you
should make an effort to contain
mutation to really small scopes that
means usually like maybe inside a metal
implementation and and really do all you
can to return immutable values as part
of you know your API or your method so
mutation it's perfectly fine inside an
implementation but try to avoid passing
mutable objects to you know to the outer
world good let's go to the collection
side so if you ever look at the
collection hierarchy it's pretty complex
and I mean this is only sort of the
generic hierarchy but then if you look
at the immutable immutable one it gets
very complex there are lots of class and
traits but at the eye level you should
sort of know why why is it like this so
how is a traversable different from any
terrible who knows so a traversable
gives you a for each method so that
means that the iterate you're not in
control of the iteration the iteration
is made by the collection while if you
have any terrible you can get an
iterator so you can be in control
of the iteration and that you have six
set the map and behind those you have
different some other different
implementation but like what's the
difference between an index seek and a
linear seek and that's the moment where
you need to start thinking about
complexity so if I want to access any
element in my in my sequence in constant
time I better use an index week so if
I'm thinking about maybe concrete
collection in Scala would I use an array
or would I use a list for having
constant time access to any element in
my in my collection I would definitely
use the array the list on the other end
is good if you're writing elements at
the beginning so if you're yeah if
you're prepending elements to the list
in that case you get constant time it's
a constant time operation while with an
array that's actually a really bad
operation because you need to cop right
so the point here is that you should
know the complexity of well the
complexity characteristics of the
collection classes so that you can make
a correct decision when picking one over
the other and if you really don't know
our collection is going to be used
whether you know it's going to be
writing let's say you need to use a an
immutable collection but should that be
a list should that be a vector should
that be something else and you don't
really know how the collection will be
used will the element be picked at the
beginning at the end in the middle so in
case you don't know just use a vector
because it has basically good overall
performances with all you know kind of
operations is not the best for a
specific operation but overall is the
best across all operation so that would
be the kind of the collection that I
would use if I don't want to think too
much about it and the other thing is
learn the API of the collection
libraries there are autonomous and you
know I cannot remember a time when I had
to implement my own method for doing
something with the collection you
it either already exists or I can just
compose to method calls to do the job
while if I think about my times in Java
I would always have a util class where I
could do things with collections because
they were not part of it at the time and
now one question for you if I'm writing
this code is the seek mutable or
immutable of course there is a trick
just like this because like let's take a
step back when we have a map or us or a
set and we don't we don't have any
import what is the type there is it an
immutable or mutable collection it is an
immutable collection in the case of map
and set but in the case of seek in the
case of seek like this we don't know
it's it's the generic seek ok so if you
want to make sure that that's going to
be so if you want to sort of have a
contract on your color and say I want to
receive all the immutable an immutable
value then what you should do is making
the implicit expel having an explicit
import so saying I want to use the
immutable seek and then you're
guaranteed that your seek will be
immutable and this could make a
difference
in the case that you know you're in
maybe you're using that you are like
doing things in parallel inside that
seek so potentially you're reading
elements from different threads inside
the seek whether it's mutable or not it
actually makes a difference in
correctness so it could make a
difference the good news about this is
that actually this is going away in
Scala 2:13 so the next release they're
finally gonna make this as the default
so you will no longer need an import to
immutable seek but today if until Scala
213 you do need the explicit import good
and now let's have a quick touch on
implicit
my the best recommendation I can give
you with implicit is try are to limit
the scope of implicit that's really the
best tip I can give you make them so
that they are now going to interact with
all the code maybe you know all the code
in your source file or maybe all the
code in your project but have a very
specific place where you expect them to
kick in okay so the follow-up question
would be okay but how do I do that it's
like that sounds simple enough but how
can I do that well you need to
understand our implicit resolution works
you need to understand how the compiler
is going to look for implicit because by
understanding that that you can
understand where you should be placing
your implicit so that you you sort of
reduce the scope of that so the implicit
resolution are great works in two ways
well in two steps first it looks for
implicit in the current scope in the
local scope so that means it looks for
implicit that are available without a
prefix so maybe things that you define
yourself in the current scope or maybe
implicit that you imported maybe because
you have a dollar underscore on you know
something that defines implicit so those
are all going to be part of your local
scope if the compiler doesn't find an
implicit for healing the expression that
is looking at in this scope then is
actually going to move on and look into
the implicit scope and this is really
where you should be placing your
implicit so the implicit scope it's you
know it might be not so simple when you
look at it but at the end it's actually
really simple you just look at the
companion object of the types that
you're trying to heal okay so compare
the compiler is gonna say okay you have
an expression from type you you you have
a you have an expression of type a but I
actually expect a type B so I'm going to
look into the implicit into the
companion object of a and the companion
object of B and see if there is an
implicit that can help
he'll this expression the compiler will
do that for you without you having to
import anything it will just do that
it's part of his algorithm
okay so if you start off I be implicit
in the local scope you-you-you managed
to move them into the implicit scope
you are definitely narrowing down where
you know the applicability of your
implicit you're making it really
specific these implicit is only going to
be used if I'm going to trying to heal a
type something that is of type A to type
B and you know based on that you can
actually reason about when implicit SAR
being are being used by the compiler so
and another reason for putting the
implicit sin the implicit scope is that
it allows the user to override whatever
default you define so this is
particularly useful for libraries if I'm
adding an implicit in the current scope
it means no one can override that right
because I if I am deciding for every one
that does the implicit that should be
used if I put it in the implicit scope
then I'm actually allowing you know my
users to override that implicit by
adding their own implicit either
explicitly or maybe as an import so in
this case as you can see we have the
standard logger is an implicit and where
is it placed it's in the companion
object of logger and as you can see I
don't have any imports so when I when I
call logger dialogue hello the compiler
is saying well I need to look for an
implicit of type logger
there is no implicit in the current
scope so where am I going to look for
that kind of implicit I go into the
implicit scope and where is that
implicit scope where I have logger so I
need to look into the companion object
of logger and one turns out that there
is a standard loggers while I find it
I'll use it and inject it and so the
logger dialogue the first logger
dialogue call is going to use the
standard logger now say that yes I want
to override that and actually use a
remote logger I can do that if I add
something defining the scope
the current scope it would be a lot
harder for the user to do that and using
this is a this is an example of using an
implicit parameter this is actually
really good thing this is how implicit
should be used this color I would say
the one thing that you shouldn't do is
using implicit views so what is an
implicit view is just scented that
translates a type to something else so
let's say here I have an implicit that
translates any name into a station right
so that I don't have to write this glue
code myself well actually this is really
bad it's really bad because it makes it
really hard for people to understand
that you know something example
happening underneath there is no
evidence that that's happening of course
the idea is telling you something but
this is what makes calico I think really
are to understand when too many of these
sort of magic happens underneath and so
what should you do instead well I'd say
you should keep it simple
you should really not do that if after
five times you know if if you're doing
this because you have three five ten
calls that are banished you know you
don't want a type news station of name I
think that's that's really bad to write
an implicit just because we want to save
a few keystrokes I think you'd really
need to feel the pain before you go into
you know sort of finding a more
elaborate solution I know for instance
like Martin or their SCADA creator at
the language so he was saying that he
had to sort of pass some implicit
context 5,000 times before he decided
that was too much and so he actually
went and created a feature in the
language in dot e that is called these
implicit functions types but it took him
five thousand you know repetition of the
same thing before saying enough and and
I think we should really get to that
point to say okay it's enough I see that
I'm doing too much of the same so maybe
I should really tech things in a way
that actually don't make me write this
boilerplate and my expectation is that
by then when you realize that the
solution will probably not be an
implicit view because that's usually
really better listen your application
code but it will be something else and
implicit views they have their you know
they can be okay they can be used I'm
not saying that you should never never
never use it for instance in test
I somehow field those can be useful but
I'd really try to stay away from them in
my application could exactly because
they make my code are there two to
reason about thank you all for the
attention and well it was an opinionated
talk so I hope you guys have a lot of
questions yes oh yes return this one
okay is it about the code yes so I so so
you're asking about having multiple
returned in an implementation so in in
in Java so I you know I'm let's say that
if you come from from a background that
is like Java you you need to use return
why because you need to strike the
compiler that you actually want to
return a value from this method because
the language is not built around the
fact that is an expression or expression
oriented language right Java is not
expression oriented if statements
oriented if anything while in Scala
every everything is an expression so
that return is completely irrelevant
like you know you'd really don't need it
it's it's just sort of noise you know II
do marry Scala the last expression of
course is the return value of an
implementation but that's just
because you know any expression that is
at the end is a return value any
expression is a value and and yeah and
that was you know one side of it it was
about its nari dramatical it's really
not needed and the other one it was
really about the fact that he generally
he can produce code that somehow you
don't expect to see and and that's why
I'm saying that you you know don't use
return but actually do it as you would
do in Scala so I would just use a filter
condition on that for expression that
would get me out of the loop the other
benefit of doing that is actually that
the logger dottyback
would actually be executed while you
know in the case of the return that is
not executed so you know I actually
think it would be a much better way of
expressing the intention of the code
instead of using a return so do you guys
all like do you agree with everything I
said I come on there is no question so
you must be agreeing good now so you see
this this is the IR key for so in Scala
there are actually you know three IR
keys there is like for collection there
is the generic one and there are two
implementation the mutable and immutable
one right even in the this is also
reflected in the import you say Scala
dot collection that immutable or scale
at our collection of mutable so yeah you
have these two different implementation
but when you in your code up to now when
you write us seek you are actually
referring to this seek in the Scala dog
collection so that means that as a user
I could pass your an immutable seek or a
mutable seek right and and so that means
that that may be fine but it really
depends on you on what you doing that
implementation let's say that you're
actually doing something that is
multi-threaded so you may have different
threads reading on that on that sequence
well if the sequence is mutable and
maybe gets changed
behind you know behind your face that
you can you can actually get an
explosion so that's why I'm saying that
since it's a good price since I think
you appreciate the fact that map and set
are immutable by default if you
appreciate that then you probably want
to have the the explicity import as well
for seek it's just about you know
knowing what you're gonna get instead of
kind of leaving that to the user
yes good note that so I wanted to prove
a point so what you should do when you
have question like this just do this so
by default you get a list so you don't
get a vector the reason I can only
speculate the reason why it's a list
it's not a vector it's because vector
was introduced in Scala 2.9 and I think
it would it could be surprising like you
know let's say that you have legacy code
you know you have code running that has
been updated to Scala 2.10 then suddenly
instead of returning a list you get a
vector I think they didn't want to get
into sort of that kind of trouble or
they didn't want to sort of put
potential problems into application that
we're upgrading from Scala 2.92 you know
later Scala's but if it was me I think
it would be better to have a vector
because if you don't know what you want
to get then I I think a factory is
actually a better a better collection
but if you do know that like you know I
tend to use least quite a lot because
more often than not what I implement is
to prepare elements and so I actually
appreciate that at least this constant
time it doesn't go it duplicates all all
the elements that I'm you know I pay
prepending to so to me it's really about
understanding and knowing the
collections and and knowing which one
you should pick for the job that you
have to do and I think with that we're
running out of time okay two minutes so
there is time for one more question
maybe about about triple quote otherwise
thank you right yeah it's a really good
question and point so the thing is that
it's Carla you tend to have different
containers you know you you and that so
the question is that you end up having
things like futures an option and and
either and you know and so on try and so
how do you sort of treat all these
different things in uniformly so that
your code doesn't doesn't become really
bad to to read so in scala at the moment
like in in in the Scala library itself
or in the language itself there is
nothing that allows you to you know that
helps you with that so what you could do
is actually converting these things so
like if you're using a future then you
know you need to wrap the option into a
future that's successful and so on but
there are other libraries like there
let's say libraries exist in like cats
or or Scala see that have abstractions
that actually allows you to easily map
one type to another without you having
to write this glue code that you just
sort of call a method and sort of makes
it simpler to to kind of work with these
iterations collections or types but but
this is also something that you know I
have I guess I'm lucky enough to be
talking to Martin you know their skip
from time to time and and this is
actually Sunday would like to improve at
least in dotty so I would like to have
some sort of constructing dolly so that
he has some language support
for making it simpler to work with this
you know different kind of types let's
say in a for-expression
so today I would say you need to look at
these designer libraries but hopefully
tomorrow this is something that will be
easier in the language itself because
there will be you know first-class
support for these kind of things but I
don't think this is happening in Scala
2:13 so it's really probably going to be
something for scarlet reader oh alright
thank you all
I think we're our time is over and I'll
be out if anyone has more questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>