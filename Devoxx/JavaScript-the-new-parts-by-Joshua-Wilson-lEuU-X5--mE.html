<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JavaScript:  the new parts by Joshua Wilson | Coder Coacher - Coaching Coders</title><meta content="JavaScript:  the new parts by Joshua Wilson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JavaScript:  the new parts by Joshua Wilson</b></h2><h5 class="post__date">2017-04-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lEuU-X5--mE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright so this is josh with the new
parts i'll get into some stuff of
JavaScript before I get into this how
many of you are javascript developers
what Celia how about Java developers all
right how many of you are actual
developers okay all right a good mix
knowing that the audience here is
predominantly Java bring out a few
points in this I've been a Java
developer for a long time and over the
years transitioned into JavaScript
because I didn't mind it and I liked
working on the front end and so I ended
up doing that that type of work and over
the past couple of years I've gone
exclusively into the front end you I
work you know that's me that's the pic
that i use wherever I'm at online so if
you find that you can thank me Twitter
handles at the bottom yeah I am an
engineer at Red Hat and I'm currently
the lead UI developer for the developer
tools and experienced group that's until
today ok before i get into the content
in this guy's got questions raise your
hand to ask let me know and keep an open
discussion hope you guys not fall asleep
after lunch right so we need some
context for javascript to really grasp
where we are and how we got there so
back in 95 brendan eich created java
script he wrote it in 10 days and some
people are really harsh on him for that
but they had to get it out and hit some
certain timelines and he'd written
languages before so it wasn't his
first rodeo so he did it in 10 days and
then went through several iterations as
time went on they went through several
names like mocha was the first name and
eventually they settled on JavaScript
because they wanted it to be aligned
with sun java they're trying to
piggyback off off of that so went
through several iterations and around
2004 they were trying to get out yes for
so the es is for ECMO script and the
echo is the standards body that adopted
it and has owned it since then but they
weren't able to get the agreement
amongst all the parties in the board
trying to figure out what was going to
go into this and there was a lot of
advanced features so they killed it and
did SAT so from 99 to 2009 you got 10
years until you get the next release of
JavaScript and the changes in es5 were
minimal and you access those by using
you stripped as we've seen that in the
JavaScript before so then it's Saturday
is 5 for a very long time until a couple
years ago when they finally got es6 out
so the formal name for it is ECMO script
26 2 2015 that's we short cut at the es6
and then they're just finalized in
january the equus script 2016 or es7
cookie es7 has only two features in the
rest are just bug fixes questions good
so to do we got to learn some ps6 what
sort of focused on here my goal here is
that you guys would pick up some of the
reasons why moving the es6 is better and
the advantages of it so try to make that
as simple as i can tell so from here on
out we're just going to stick with code
well this is a bunch of examples all
right in pre es6 if you want to write a
string single quote double quote doesn't
really matter so you hello world example
for you start this off with can
everybody see this even by I so to
concatenate strings whether it's in
JavaScript or even in Java it's the same
way you just use the plus sign and
concatenate them it's fine if you're
only doing one or two things but it gets
annoying when it gets bigger so one of
the things that they did is they
improved that with a different format
now this is not a single quote it's a
back tick that's the key that's the
tility right above the tab key and that
also allows you to use template strings
so now you can embed it in the dollars
and braces so you can put them right in
there like that so it makes it a lot
cleaner and look at so when things get
bigger when you start to fill in more
strings than you want to have so this is
old-school JavaScript got to use the
concatenation and you can see how we're
referencing the properties in the object
in an array and we can make that a lot
easier by using the template literals
and the strings like this all right
sometimes we need to build out a whole
set of HTML and when you're doing that
you got to do a lot of concatenation a
lot of quotes and we want to keep it
structured like this so when you're
going to debug it you can actually see
what's going on with it and we have the
/ end in there so that its new line when
it does print out you can actually sit
and work with that you can clean this up
a little bit by putting a splash on the
end of it but you still going to have
that / new line / in there and so
obviously you can just put the back
ticks in there and it wraps up the whole
thing and makes it really nice and neat
easier to work with easier to read all
right one of the newest features one of
the biggest known well-known features
for es6 is the use or introduction of
let and const okay so let's look at this
code for a second you guys tell me what
you think this is going to do I've got
the variable x3 and we're creating a
function we're going to pass in a
boolean so make random do we want to
make this thing randoms we're going to
get a number and let me check if it's
random if it if that's true then we're
going to go through and run math.random
on it and then we can return X if not we
just return X so I'm going to take that
method get number and I'm a passing a
false what's it gonna send me why why is
it false
yes
well it's the variable is false that's
fine but the problem is it's not going
to be three it's going to be undefined
and here's why in JavaScript there's
something called hoisting and so it
takes that variable that we have here
which VAR x equals mass that one and it
takes it and puts it at the top of the
function it's not going to look outside
of the function because it was declared
inside the function variables or VAR is
function scoped so it's inside of that
function and this gets to be really
annoying especially when you're just
starting out working with javascript and
you don't realize what happens here so
when the compiler looks at javascript
it's going to take every variable to
every variable declaration and move it
to the top of the function and it's only
the function there's no other scoping in
javascript up through es5 but with es6
we have the introduction of let which is
block scoped and block scoped is just
something in the curly braces so just
inside of those braces so now we've got
let being described there and it's
within the scope of the if statement so
when we run this because the let is
within the if statement block it doesn't
doesn't affect the one that's in the
return so the return has to look higher
and then he goes well I don't have
anything here there's no let in here no
bar in here so they can go higher and it
can see the one above it so that's how
that works const works exactly the same
way except you can't change it it's not
entirely immutable though so if you have
a simple thing like pie here you can't
modify it once it's created however if
you make an object the reference is not
changeable but the content inside the
reference the content inside the
variable is mutable so that can be kind
of dangerous
if you do want to really lock something
down then you can pass an object into
object freeze and then it's not
changeable at all if any of you are
familiar with Java and this works
similar to final in Java it works the
same way one of the big differences in
Java and JavaScript the use of final
verses const here final can set the
value of that item anywhere in the class
whereas this has to be declared when you
say const whatever the thing is you have
to declare what it is at that point you
can't do it later on so everybody said
their developer I'm hoping everybody
interests into the for loop is standard
for loop in Java and JavaScript same way
both ways can we have an array we're
passing in there we took the array
length and we cycle through that array
and we pull out for each of the indexes
would pull it out and we do console.log
which is printed to the console in es5
they added a for each which simplifies
looping through an array so you can run
this on a raise but only arrays and it
runs through it and you can pass in the
element and index and get those out you
can until the same thing one of the key
differences with the for each is that
it's only it's going to run through the
entire thing and you can't put a break
in it so if you run from a for loop 3
part 4 loopy you can put brakes at
whatever point you jump out of it but
not let it for weeks so it's going to
run through the whole thing the addition
in es6 is the four of and this allows
you to have a cleaner syntax than the
standard for but with the ability to
break in it and it can work on anything
that's iterable so maps and sets not
just a raise so that's the big
difference there
if I go up you can see this one has
access to the index here I don't have
the index in here but I can add it by
doing this if I go in and set an array
for the index any element of whatever it
is then I can pull that out as well all
right functions now for java developers
the wave functions work is probably one
of the harder things to grok and some of
this some of the changes that have been
made have been made so that it fits more
like what people expect it to work like
but what we're doing here is more
functional based so this function is you
pass in a function to a map and then it
iterates over that array and it does the
function in here it's going to take X
from the array and the x times X return
that in es6 we clean it up a bit we take
out the word function and parenthesis
and the braces and you just put that fat
arrow in there and so it's just like
that you can add each of the other
pieces in there as needed well not each
but you you can put the braces in there
so if you have as it gets more complex
but you don't want to use the word
function you want to use the word error
not the words arrow instead to keep that
difference so this has a really
important difference for us and that
gets into lexical scoping and for this
we use the word this okay java
developers what ones this reference in
an object
yeah the object right in JavaScript it
references the calling object the
calling context is what this is a
reference to so here we have this
uicomponent is a button and this is for
the UI component when I want to
reference it in the inner function so
this function that you see up here
inside of the event listener I have to
use the self so this is a trick and this
is common across all of JavaScript
actually yourself or that or underscore
their swords some variation on on this
so that you can have a reference to that
outer this this is how we do that in
standard however when you go to a fat
arrow or the arrow style functions the
lexical scoping is so you can actually
reference the calling ones this instead
of the one you're in so it cleans it up
it makes it a lot simpler and you don't
have to worry about to this you can see
we added the template literal but this
is this for the UI component button not
the one that's the function that we're
in this is the key difference in a
narrow function the syntax is just
easier to read but how it's using the
keywords this and how it accesses it is
the key java tens javascript tends to
think of everything some type of boolean
and it uses the terms truth II and
faulty to designate that something is
one or the other and depending on how
you use it or where you where you're
accessing things you can leverage that
this is a common pattern if you are
trying to have default variables so you
have this move function and if you don't
pass in the x and the y a little default
20 and how it does that is it has
and it takes to X and it says okay if
there's an X great that's a truth II
thing so i'll just leave it to whatever
you set it to and if not well then
there's an or so truth or false or 00 is
true so i'll just put a 0 in there sort
of a hack but it's the way we do things
in javascript and and you can see how we
can print that out but in es6 you can
actually name them and then reference
those directly and you put the value in
the parameters sexually right there all
right now we're getting into
destructuring and if i want to have a
method that returns more than one thing
these methods only ever return one thing
you get a return an object or an array
of said things so in this case them
returning an array of two numbers one
and two and if I want to get those out
of the get X Y and then I gotta do get X
Y it creates the XY array and then I can
access those with the index 0 and index
one kind of verbose these structuring
allows us to take that and put it
directly into an array so I can do what
you see here the x and y inside the
array brackets that there's in that
Coast we can do the same thing with an
object note the curly braces versus the
square brackets same setup except this
time we have to denote the variable
names x and y and give them a value so
just returning the value because we're
going to reference those in the the line
where we're calling it in es6 you can
see that I've got an ex and I've got a y
colon my why both ways work to access
what's your pulling out of there so if
you want to have
the variable and you name it to whatever
you want then you put colon and then you
put your own name in there so it's I'm
saying X is or X add something else so
you get through that named parameters
the options object paradigm allows us to
pass in set of named things into a
JavaScript object function and so you
pass in these or its expecting the
options dot start to be set to start and
then you can have it set to that or just
like we did before so the defaults each
of those and they're named and then so
if I want to just when i run the Select
entries and I only want to set the step
but I want to leave the others and I can
use this that works we can clean that up
quite a bit though by putting it inside
the braces which is an object then we
can specify the names in there directly
and the default values like we did
before and then we can access it here so
I don't have to do with the whole
options reassignment thing bit clearer
all right in in Java we had arguments
like args and Maine is a similar idea
here but it's a lot less obvious in
JavaScript ok so there's another point
to this I'm guessing everybody
understand this but I just want to be
clear there is no concept of a signature
in JavaScript it's very key and
important in Java to have the signature
you know it's got a type in it's got the
number of arguments and what those
arguments are and so you can overload
and you can override and you can get it
all that stuff you can't do any of that
in JavaScript and then they've got this
hidden variable but if you didn't know
it was there you might not even see it
unless you start digging into some
was using it called the arguments
variable and it's a limited form of
array doesn't have all the array
functions you can get the index out of
it and you can cycle through it like an
array but it's not a full-fledged array
and you can see we're using it here is
I'm getting into length on it and then
cycling through with a for loop we can
pull those out what the arguments does
is allows you to take n number of
variables into a function so you don't
have to specify what they are in the
beginning you just takes how many ever
the person was to put in and so in this
case this function says I'm going to
print out everyone that they send me and
here I send in one two three so it
prints out one two three right the rest
operator and it goes off the idea of
this take the rest of the stuff this is
three dots and then we name it it can be
any name it doesn't have to be ours it
could be foo it could be number it could
be a or Z it doesn't really matter but
then you can cycle through that and here
i'm using the four of since it's a
cleaner and easier there goes for each
our get of args and then i can print
those to the console cleaner now what
happens if you want to take I know
there's one thing that I want in this
case pattern and then I want to leave
the user the ability to put in other
things on yes five and before this is
how we would do it we go through and you
have to do this sort of hack when you're
slicing off the first thing and you take
everything else after that so depending
on the number of defined parameters that
you want and then the argument is still
on the end so every function has
arguments on the end if anybody ever
wants to put it in there so the user
could send in as many things as they
want and it either works or it doesn't
want it runs but it'll compile it just
doesn't work when you use it so we
simplify that with calling up pattern
here and then comma and then we use the
same rest three dots and
whatever name we want to give it then
you can access it the same way on the
inside so spread is just like rest get
into how it works a second but this is
the old way of doing it in JavaScript
and so I've got an array of temperatures
and let's say I had a function called my
max which would return to me the max
value of any set of numbers that I
passed into it but when I wrote it I
didn't write it or maybe you wrote it
and you didn't write it to take an array
and I have an array and what I'm getting
back is an array and I need to do with
it so in order to do that i use the
apply and then the braces the whole
thing just doesn't make sense when you
look at it the first time you like that
what is that doing ok yeah I believe you
let's test it and we'll see yeah I guess
that works ok sure so but this is how we
do it now we just use the spread
operator spread and rest are the same
three dots it just depends on what
you're giving it so if you give the
three dots an array it turns it into a
set of values if you give it a set of
values it turns it into an array it just
converts it from one side to the other
so in this case I'm passing in the array
temperatures and I want to turn those
into just those individual values so
that's called spread so spreading the
array out and just leaving out there now
when we're doing array concatenation and
there's you can use actual cat but here
you can see we're combining two with the
push and apply and then but I can use
the spread operator to convert those
into values and just push them in and
apply it that way
it says everybody's still awake okay
Ricky sure yes I'm all I ever seen it
used in the parameters I don't know I
haven't tried it in any place else no no
to play with that one I've not tried to
convert these at Lincoln okay good in in
JavaScript one of the most difficult
things to grasp when you first start
using javascript is how it works with
inheritance and javascript is
object-oriented for anybody who didn't
know that it is actually object-oriented
but it's not the way java is java is
class-based inheritance javascript is
prototypical or prototype inheritance
and so it works a little bit different
when we look at this there's some things
happening that aren't intuitive obvious
the first time you look at so the event
it's got two variables that get passed
in and they get set to the terms of this
in there well this is a constructor if
you're writing it in most other
languages you would actually have a
constructor that you could fill in and
do it we should passing in variables and
you're setting them automatically when
you create the event now if you want to
add a method to the event you can't put
it any event you actually have to do it
through the prototype syntax so you can
see here an event prototype we're going
to add the get description and you can
put the whole description on there which
is basically a two-string for the value
in there in es6 they added some syntax
sugar to make it a little easier to read
and use it doesn't change that it's
prototypal it's still a prototype
underneath this just kind of wraps it
all up and makes it easier to read make
more sense so you actually have a
constructor and that's a keyword and
then you can have methods as well and
they get added in like this so it's a
lot simpler to work with note that this
is a class we're using that keyword and
there is no parentheses there's no comma
or semicolons to separate the methods
that are in here all right under the
old-school inheritance familiar with
prototypes when you are doing something
in you want to inherit from a parent
class so here we have an employee that
had that's going to have a person that
it's related to so the person has name
and you want to have add a title to that
so then you create an employee and you
can add the title but you got to call
the person and then you got to go
through this meccaniche in here with the
prototypes they're creating the
prototype person object and applying it
and you got to create the constructor
for it and then you can add the
described and work through this this is
how JavaScript works this is if you do
anything in es5 or before and you want
to do any type of inheritance this is
how all of it works but with the advent
of es6 not only the way of class we have
extend so we can extend the person and
then we can access it with the keyword
super and pull it in and simpler easier
one of the things that was always
difficult with this pre es6 way of doing
prototypes and inheritances is that when
you have a javascript made thing like
error not something that I made I made
person and then I made employee but
error is a building well you got to go
through this sort of hack in order to
create your own version of an error
that's inheriting from error and or
extending air it's just you gotta go
through and you got to create one and
then set it and reference it and I got
the method in there and you got to use
the error apply and null it works but
it's hard to follow and hard to track
but now we can do the same thing just
extend error and you've got it so that
cleans that up a lot nicer all right be
a module system that we have now we've
been trying to do something in modules
for a while now I get ahead of myself in
Java the idea of importing is almost
second nature and if you jumped into
anybody else's advanced code that you've
seen JavaScript now you've got a bunch
of JavaScript files are spread all over
the place I don't know how all this
stuff works javascript when it comes
down to it there's only one single file
everything that is written in the
JavaScript that goes into that browser
page is in one file and all gets pushed
into that or you're going to have
separate imports via the script tags
that's about the only way to separate it
out so in order to kind of gain some
modularity in it the revealing pattern
which came out a while ago doesn't add
anything to the code base that
javascript itself and just wraps it in a
module it wraps it in a function and you
can put your functions inside of there
and then you just return them doing
things so liquid have here in order to
kind of clean that up we've got AMD
which defines it and then you can
declare function that way so it's the
same thing on the inside and this has
become more common coming Jess we're
going to see this everywhere using
require this is built into node so if
you do any node programming this is how
you going to do the imports typically
and then you've got the module export to
send the things out that you want
modularized with es6 they actually have
an import from and then you've got the
export at the bottom and so it's a lot
cleaner even than the last ones there's
one downside to this of everything that
I've shown you and and all the other
things that I haven't talked about in
es6 it's all been implemented in the
latest browsers past several versions of
browsers this hasn't the module system
has yet to be implemented in any browser
yet the trans filers can handle it and
if you use any to build systems whether
it's some web pack or require j/s or
whatever you're using they can handle it
you want to use babel or tracer to get
into it they can handle that actually go
reference that just last slide but this
get links to babble and tracer and and
other things so if you want to go
through and add to those things the
module system then you need to use
something that's going to transpile it
and do it for you questions
in the class definition i didn't use
this key definition the function
definition let me go back to that no and
that's one of the key differences in
here so in es5 and before you have to
use function because it's outside of the
scope of anything else and then when
it's inside of a class you're creating a
method and they've distinguished it
calling this a method because it is a
function but it's inside a class and so
you declare it a little bit differently
and so you just use the parentheses and
your declared it yeah oh yeah in the
class you declare variables constant
let's and so forth this bar if you want
yeah fields inside the class it's a
question
let me repeat your question for the
recording so you see a lot of things
that are similar between es6 and
typescript typescript except the missing
types well that's what sets it apart
that typescript has those types and yet
they do all of the es6 functions and
advances they have just about all of
that in there and they put in a few
extra things too so if you want to use
types then by all means use typescript
but there are aspects of JavaScript that
you don't want to have the Taipings in
so people that want to have the strong
typed language and you use and
javascript has the concept of it knows
that something is the type based on what
it is once you declare it but it's not a
type system the way typescript or Java
is I'm using typescript now but it's an
intentional choice to use it because the
team that I'm working with I wanted to
leverage the typing to make the code
more robust for them and they were new
to java script and typescript so i just
picked that instead but when you guys
start getting into things that are
functional I think the variability of
let not being defined had some
advantages so depends on what you're
trying to do and the mentality you have
and what you're comfortable with and I
don't expect them to add types to
JavaScript any time to see
a good question next question yeah Holly
fields for extend gorgeous maybe maybe I
haven't looked for but i would guess
gorgeous his first place I'd look yeah
so in JavaScript so the question is have
they addressed null and undefined in
javascript in some of these newer things
they're dealing with it a little better
but for the most part no it's still as
crazy and weird as it was before so
here's an example in es7 there's only
two things that were added I didn't I
didn't bring it up because there's so
minor from my point of view one is the
includes in an array so now in es7
you'll be able to do includes and the
different the difference between that
and how you would check it normally is
that if you just are looking for X in
the array it would look for it and tell
you if it finds it but if X happens to
be a man it wouldn't find it but if
you're using the new includes they've
actually structured it so that if you're
looking for a man it'll say yep I found
the man it's in there so they're working
at getting better at it but they can't
break the existing stuff because when
they break the internet but if if that's
really important then maybe you should
look at typescript because they do
handle null and undefined as types
I think so
yeah I'm sinner what other question yeah
god I do not know when import is going
to be brought into the browser we're all
waiting for it but to build systems that
we're using right now handle it without
a problem I'm seeing a lot of people go
to web pack and web tech handles it
really nicely and whether you're using
grunt or browser fire gulp or whatever
what have you and the trans pile is as
well so you can you can deal with it
with the transpires anything else
well thanks guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>