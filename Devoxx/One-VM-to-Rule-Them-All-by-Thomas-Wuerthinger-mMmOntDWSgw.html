<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>One VM to Rule Them All by Thomas Wuerthinger | Coder Coacher - Coaching Coders</title><meta content="One VM to Rule Them All by Thomas Wuerthinger - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>One VM to Rule Them All by Thomas Wuerthinger</b></h2><h5 class="post__date">2017-05-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mMmOntDWSgw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so yeah welcome to my talk on
laundry M to rule them all i'm thomas
i'm working for oracle labs which is a
research facility of oracle that we do
language and compiler research as well
as database research of course and yes i
need this little safe harbor statement
here but I think everybody's seen it
yeah so why what do we mean by one VM to
hold them all or why are we doing this
like we believe the world is polyglot
and there is actually more and more
languages involved nowadays and not less
this is like taking from a website
called module counts calm and it shows
the values model repositories of no G as
Java are go Ruby and all of them are
growing and so there's a lot of
multilingual code out there and if you
look at the TOB programming language
index you will also realize that there
is more and more languages that are
relevant more and more languages in the
top 20 have a very relevant relevant
position and we think we should address
this by incorporating a virtual machine
that can execute all of these languages
and not be restricted to a few and
because at the moment the way it goes is
that a lot of different vendors and a
lot of different runtimes are
reinventing the same structures all over
again so there is like one JavaScript
engine and the Ruby interpreter like
those of them need some type of
functionalities like garbage collection
Python might need a JIT compiler and R
has also the need of a JIT compiler so
JIT compiler garbage collector and in
general the runtime system is usually
duplicated across these languages but
those languages are not that different
so we believe that the core components
can be shared between those languages
our system is demonstrating that aspect
and one of the things we believe will
happen moving forward is that a platform
that can execute all those languages has
the ability to affect more investment
and therefore make overall a larger
progress compared to the platforms that
are only focusing on one specific niche
of their own excess we have a project
graph and this is the overall system
architecture of Grall vm it is built on
top of the java hotspot vm in gdk9 there
is a new feature at less controversial
features thankfully called the JVM
compiler interface that enables you to
execute an arbitrary compiler an arbiter
JIT compiler that is written in Java on
top of the JVM and this is very exciting
we can now for the first time in Java
blog in a JIT compiler that is written
in Java itself into the Java Runtime
system and yet does let's press about
that self each entity canine but it's
for me it's more exciting than some of
the other stuff but anyway so one of the
one of the compilers you can plug into
that is the grail compiler and ground is
a usual Java compiler it can execute the
Java's collar
Coughlin's groovy anything that is JVM
bytecode based can be executed as well
because the input to Crawley's TVM
bytecode and it can some of this stuff
it connects get faster but later
demonstrate like some aspects where
Grodd is actually better or more
advanced than the current a JIT
compilers and on top of crawl we built
the framework that we call truffle which
is a framework while you write and
language in an interpreter and the the
compiled code is automatically derived
from that interpreter so this is a
theoretical concept in computer science
where you take an interpreter you take
an input program that is constant and
from this you can automatically derived
code and this interpreter framework is
used to execute other dynamic languages
on the JVM that have not received as
much attention on the JVM some of them
are supported on the JVM like JavaScript
and Ruby is supported on the JVM but if
you compare the performance with some of
the native implementation then the TVM
is still not the ideal target to execute
them and we can without framework
actually achieve the performance that
absolutely comparable and sometimes even
beating for example deviate a JavaScript
engine with which the JavaScript saw so
we build JavaScript on top of this we
build Ruby and we build also our as a
statistical language that's a particular
interest to us but while integrating the
phonetic languages as kind of
challenging and interesting but we
didn't stop there because we also wanted
to get some of the static languages into
the same ecosystem and this is very
developed this project so long a way how
we can actually execute these native
languages as well on top of the JVM and
the voidage works is it sounds a little
crazy but I promise you it works like ah
you take lob embed code you take LLVM to
compile your static language 2-bit code
instead of the machine code of the
platform and then you take that bit code
and you write an interpreter for that
bit code that runs on the JVM and this
interpreter is done kind of by growl
optimized and we have peak performances
that is in the same range as I love um
depends on the benchmark maybe 10 20 %
slower at the moment but it's we can
execute this native languages as well on
the TVM and integrate them fully into
the JVM universe we actually have two
execution modes that we have one
execution modes it's unsafe it's
basically similar to how a native
language would usually executed but you
also have an execution mode that is more
JVM like in the sense that it has
bounced checks and and security around
so that is with with projects along and
this is our set of languages that we
believe we can handle in the growl
virtual machine so it's anything that um
based the dynamic languages like our
JavaScript Ruby and also the static
languages all under one compiler one
virtual machine one execution
environment that's our goal and I will
demonstrate that we are already quite
far along that goal one of the things is
for JavaScript I've been only able to
execute JavaScript we are also able to
execute no chest so we add we took no GS
standard libraries and we replace the v8
compiler with our JavaScript engine so
we are fully compatible and executing
node as is and we are just replacing the
engine the JavaScript execution engine
with our our compiler and that's the
similar thing like for example Microsoft
does with chakracore or or other engines
like mudsill I think is also trying to
do a similar thing in the note yesterday
one short slide on projects along this
nvm based thing I was talking about so
we are in this way not only supporting C
C++ Fortran we can also support go
because all of this code will in the end
like be compiled to the same type of
Allah gambit code at this stage all of
the languages look the same to us or
similar to us and we can then
interpreted it code and execute on the
JVM
this execution of these multiple
languages we are using not only to save
you know resourcing and not have double
layers between languages we also use it
for zero overhead interoperability
between languages so in our system you
can take the object of one language and
pass it to the other one without any
materialization whatsoever it is kind of
for me
personal it's a very sad type of affair
that while we have all
languages around the main communication
mechanism between the languages at the
comm point in time is to serialize them
to ASCII code in a format like XML or
JSON or similar and this relies it on
the other end again this needs to be
this seems to be like a very big waste
of computing resources and we believe we
can do a lot better in integrating
design witches and there is no need for
civilization not even binary
civilization in fact we can just take
one language upon one object of one
language and give it to the other own
while allowing all of this one goal of
our project is to have high performance
for each individual language and I mean
performance charts always you know it
depends on the type of language you're
using at the type of benchmark your
using the set of benchmarks you're using
but this gives a rough estimate of where
we believe we approximately are on this
various languages so for Java we are
roughly the same speed as current JIT
compilers but Java will show you some
examples of you're better for Scala code
we're actually quite a bit better
because Scala is usually more
abstractions for us to improve on this
also is shown by a presentation by
Twitter where Twitter is showing their
improvements with the growl compiler for
Ruby anar we had a little bit of an
easier time because nobody has so far
had the resourcing to invest into a JIT
compiler it's a very good G compiled of
a ruby or very good G compiler for R so
the bar is very low for these languages
and our framework doesn't need this
investment in individual language and
can therefore create quite a significant
speed advantage for native code a little
bit slower are compared to GCC Elohim
but you believe it can catch up there
because there is no fundamental reason
why we should this law and for
JavaScript where this is kind of an odd
number I think you know on par actually
Vietnam vet right believes at least on
the set of octane benchmarks because the
latest updates from Google was
in this course quite a bit by releasing
turbofan instead of crankshaft but yeah
so that was enough on this light
bond to this time now around we no
longer like a research project that can
only show the vision we also research
project it can show them some code and
some artifacts and so I will now switch
to the live demo by the live demos so
actually you can also try this at home
there is like an Oracle lab scroll VM
OTN download that contains the binaries
on the node en license which means
evaluation license it's available for
Linux Mac or the lowest spark as well
and after downloading this and unsetting
this type of artifact what you will get
is actually something that looks a
little bit like a JDK it looks a little
bit like a JDK 8 because it's based on G
decade but it is actually actually cade
with all these enhanced capabilities and
so the first thing I'm doing here is I'm
exporting a path and I'm basically
setting the bin directory 0.22 is our
latest release but you kind of update
once a month so when you look at this
bin directory of chromium 0.22 you see
some like comments that are very similar
like Java Java C Java doc but you
actually see other comments that are
more interesting and other type of
universes like there's a note command an
NPM command that a ruby comment there is
an IRB which is a ruby shell comment and
it's all in our comment so all of these
languages are together here in one
execution environment and I'm setting
the process I think I need it on
mistaken why we can try that bitch is
not starting harlot it's just fat our
looks good yeah so now we started out
here which is our modification of our
and we can do some our whoever
programmed in are not many here computer
scientists usually don't do so much in
the future probably will do more because
it is like the fastest-growing
statistical language there's Python and
are kind of competing but the real
statisticians usually learn are a
particularly at ETH Zurich who claim to
have invented some of it I don't know
but so anyway but R is a fun language
you can do stuff like you know I'm doing
you know I get a vector everything's a
vector actually I can ask lengths of 1
which is tells me one because it's even
that it's a vector like everybody is a
vector anyway let's just a little R here
and I just assure that the path is set
correctly and we are real here it is
running here on on chromium but the
first I wanted to show you a little bit
of Java familis Java stuff I have your
little micro benchmark and I'm using a
JavaScript API which is a very large
abstraction layer
it's just streaming over an array of
values and it's using a reduction in
doing an integer sum here and I can like
go into this stuff here able I can run
this thing and
having time to compile it first
yes six so executing that gives us then
the number of nanoseconds corporation
that's about 11 nanoseconds cooperation
that this runs so into the command is a
flag to enable the TVM CI compiler which
is scroll in our specialty decade growl
is enabled by default so we need to
disable growl and to use to use the
original compiler basically servo
compiler in the hospital so we do - xx -
use chicken thigh compiler then we run
that and well to lower about 3x does PD
438 nanoseconds here when running on
stock hotspot is it 11 nanoseconds not
nice
one can play a little bit on games like
well I have a couple of math expressions
here a map xx + form and then I'm at X x
times 2 let's just make that expression
will be more complicated because you
know it's such a simple example and I
saved it and I can now compile this
again
I'm now running with mr. Spock GDK this
more complex chlamydia expression and I
got a lot slower actually I got now down
to 92 nanoseconds for this stream API
expression I can run this withdrawal and
I think so
actually we can see what happens right
let's sobral has a little I don't have
it open now
okay not that that would be socratis the
visualizer actually for those who are
really you know experts might want to
look at the visualizer so crawl is
effectively able to compile this stream
API stuff down to down to the loop to
the actual loop it should be and and
because one of the things for all those
better on and then current hotspot is
the partial escape analysis and inlining
and in this case the amount of stuff you
need to park the scape analyze and in
line is very big because there's a huge
pile of abstraction associated with 16
epi expression and we can compile it
away so as I said on the slide you're
roughly seen speeders have a compiler
but even for Java for some interesting
complex Java stuff there is a chance
there's a reasonable chance you're
better'n but yeah that's just you know
that's just you know basically making
sure that the java ecosystem is even in
the context of more complex programs is
keeping up to speed so you can write
this complex Trinita expression without
taking the performance and the other
thing is like of course it can run no
chess here as well so I've seen a little
no chess script here
I could servant yes and what is justice
hello from growls yes it's just a simple
Express application it looks like it's
almost no code but you don't won't
believe how many call it throws in but
we got the progress management like it
made me like Ollie
maybe we cannot have so much footprint
on the coat right a medicine that's it's
like well this is ten lines right yeah
yeah there's like 20,000 lines coming on
top line but so it's it's not always
feasible they complexity behind that but
we can you can run that server and well
how can you use somebody using it that
is
I have another got the correct
JavaScript exception that's good okay so
the example app is up and listening on
port 3000 let's see if that works here
so cost 3000 and you tell about from
grudges okay that's just you know but of
course I can do no other things like
actually JavaScript telling the good to
pick integer implementation so I thought
this would be a good example of mixing
Java and JavaScript I can hear now say a
Java that marks the big integer and I
can of course say similar to what not
one is capable of doing I can you see
text I don't know begin to cheer well
you all warned dot power
let's see hundred and then you want to
string 16 that means check with my Chi
Chi this distance okay yes
oh not but you want to otherwise it's
not very useful so good um yeah this we
don't need because we request I want to
say every character here and you can
kill this node and run its over again
we'll see if that works
yes so we just called out from our
JavaScript no J's function into Java
without any problem whatsoever and there
are we running extras here like no
system is at the moment capable of doing
that in reasonable form and this
actually allows you to potentially
combine these tools where usually you
would want to use Java for the more
long-living
business logic type of stuff right and
then you use JavaScript to to prototype
or quickly heck up your microservice
your crank microservices exposing that
logic
we can not only use begins issue here we
can of course also use our own Java
class here so you can hear select hello
from Java and for the sake of time let's
just do the second example also on top
here because when you're in Java here we
can also call out to another language
and we have a little API that we call
the polyglot API in Java and I have
prepared this little statement here but
I will explain what it does it is
creating a new source object from text
in this case you can also create it from
file and we tell the system that this is
an our application either this is our
code this is actually run if is
something in our where you create random
numbers you can do very sophisticated
random number statistics new are and we
then create a new polyglot engine we
call a polyglot engine like one
execution context this is like one
isolate if you want so it's one
execution context of that can run
multiple languages but is inherently
like sharing one state and in that
execution context we can evaluate the
source and we can then cast the result
to a Java list and we can then attempt
that list here to the result
so we now have like a JavaScript
application that is probably used only
to do that right so here in JavaScript
we need to say text Java the type and we
have the class which is called test the
test class and you have a method that's
called get string I believe so here you
have to get string static method so
we're not calling from JavaScript here a
Java method and the cello method is
creating another context to call out to
our and let's see
so we now need to compile with this
truffle API on the classpath because you
need me use the polyglot engine API so
compiling the test method and you found
an unreachable statement
okay let's compile and well let's run it
so the server is hot and Oh last night
sound exceptional that's a problem Texas
money I did the JavaScript exception
state32 the class not not exactly so
we're exporting the best of Java into
the JavaScript okay yeah okay we made a
small mistake we need to put a class
pass because it's Java so we need a
clouds possibly to know where to look up
this function so we need to set the
class pass argument to note which now
works here and it's not the name it is
listening and but yeah here it is
so we now soft request Jason put request
I get requests with some Express calling
out Java using Java big integer and then
using our to create a random list of
hundred random numbers and concatenating
with as a vector whiskey string so
that's three languages in action here
and now now it's so our approach to
execute languages on the TVM is based on
this notion of an interpreter that we
partially evaluate so this is this is a
little bit difficult to explain and you
had actually yeah quite some trouble to
explain to people how this works because
it is like the interpreters are pure
Java programs so this is just an
interpreter written in Java so
technically I can run it fully
functional even without the compilation
I just run a Java program that has you
know execute functions and it's just
calling each other and that's your
interpreter and that's running our or
JavaScript or whatever in the what we
then did is just a small clicking the
compiler where we create a special
compilation from the Java bytecode
where in doing this compilation for
certain load fields that would usually
be a load field to some data or would be
a parameter that's coming into the
function we replace with the constant
because you say well yeah this is the
entry entry function to interpreter
right and it takes a parameter which is
the first statement let's say right but
now it just assumed the first statement
is X right and we then install that code
into hotspot and it's actually awesome
that hotspot allows us to do the hotspot
allows us to we didn't modify anything
in the hospital runtime system so for
hotspot it just looks as if it would be
like a hundred different compilations
for the same method which is teaching an
entry method to that interpreter right
which I actually have a different
JavaScript compilations or our
compilation is all similar but the
metadata is all structured in the form
that for hot apologies looks like a very
stock normal type of method and this
helps us a lot because this allows us to
do this so called the optimization in
hotspot to use the documentation
capabilities in hotspot because from
this form we can always go back to the
normal interpreter
and then it's just executed as a normal
interpreting hot spot right maybe I
should put it into the next time on to
like because you can actually single
step you know in your in your Java IDE
through that interpreter as you go and
you can use your favorite Java tools to
debug that application because it's just
the java application i mean you will
trigger the optimization on the method
because setting a breakpoint triggers
the optimization but but in general you
can you can I could step here through as
well in one of the work we've done with
connecting scene in particular is to
also allow some multilingual stack
tracing so you can then have a stack
trace from our to Java to JavaScript but
it's not byte code generation place
they're not creating any new byte codes
at runtime and this is a big advantage
for us because this means you're not
pressing the hotspot meta space system
in a way that it's not really designed
for and because when you start to create
byte codes you will get there's certain
parts of hotspot that are not very yeah
they do not design for creating this
amounts of fire poison and we don't need
any of that right so well the startup is
a little bit of an issue still for us as
well right so this is why we are we have
developed a system to allow us to ahead
of time compile Java code into binary
not to be confused with the eot function
engine ek9 dat function gdk9 is is to
kind of prepare the code for execution
hot spot me as an ahead of time
compilation that is allowing us then to
fully execute the code natively it's
kind of like it's more similar to there
was this dirty from from kanuda Java
compiler yes
jcj thanks yes exactly
yeah it's that that it's more
conceptually more similar to it but
David and I have your little Java
program which is a factorial tool it's
kind of taking in you know a number in
and it it's it's computing factorial
using big integers on the number that's
my java program here let's collect that
server Java here T and when I'm like
starting this program here la jolla
total tool
and now let's see 100 or something right
yes I'm calculating factorial of 100 and
outputting memory and so the timing here
the user time and it's around 100
milliseconds which is basically the JVM
startup and in this little dravyam
directory which previously were looking
at 0.22 there is a tool it's called LT
image and when running the tool we can
now let's run UT minus e image we need
to specify actually need to specify a
name which is going to be a let's just
remove that file because that's from the
demo so we we have we have to name
jyoti image his name is factorial and we
say age column class he calls and we say
now
toriel tor which is my class that's is
that the class password yes I need to
put the class pass to work so this tool
is not analyzing that application and
determining what is reachable statically
from this application and putting only
from the GDK the data in that is
statically reachable um a little bit
similar as is expressed this looks like
it's more example but it's drawing in a
lot of stuff from localization and
println and so on right but after I did
this I have a binary here which is five
megabytes here which is my precompiled
java application and i can run it and i
can time it again and we are here below
ten milliseconds on startup yes
so what you're currently working on to
enable this type of mode also for our
nodejs implementation because in order
to be competitive in startup which v8 we
need to have a similar ahead of time
compilation for this for this node test
system but at the moment with all the
working is to pre compile Java this way
and to also put come pre compile the
language interpreters this way there are
some restrictions so we cannot do
dynamic last loading which is the main
restriction but they're also restricted
at the moment with respect to reflection
or you know geared usage that would
probably the static analysis but we are
successfully capable of compiling all of
the growl compiler ahead of time
including all of the languages which is
about a million lines of code so it's
it's not a you know you not every Java
code is at the moment capable of being
converted this
but if you want you can also convert the
pretty logical path so yeah this is
basically our answer to the startup
issues and this actually brings Java
competitive with go with respect to
startup and footprint for microservices
so we believe that one reason to use go
for micro-services is these
characteristics and we think that Java
developers should have it too
also we can support go as well because
if there is a go LLVM bridge but so
there has been this trend of new
projects popping up like Scala native
and I think Oakland natives I think a
couple of weeks ago was announced so we
not have made any announcement but we
can execute codling natives and I will
show you how that works
I've here downloaded the Kotlin hello
world example here this is caught in
hello world hello world some cotton and
it's also accessing some Java string and
have here the Java HelloWorld which is
calling out to cotton so actually I'm
using Kotlin in Java at the same time
yeah this gets a little hard to follow
through because there's a get hello
stream from Cortland and one from Java
and but you get idea it's just one
program that's the test Java in it it
says Kotlin code in it and those two
things are calling each other and I've
compiled this into I've compiled this
into a binary here which is called mixed
code HelloWorld 1.0 to always
dependences which because this is the
dependences of cotton in it and I can
run this on the JVM which crawl
Edge's hello from cotton hello from java
yes that's the usual application but
again if I'm doing it at timing on this
I need again this hundred ten
milliseconds or something like that and
now let's see if that works so I can now
yeah let's
I can now run the same thing that pretty
run on the Java stuff now on the cotton
things and I'm using a glass pass to the
cha file which contains this bundled
application I'm using a name hello world
so now I'm using the Java class as the
entry point I can choose the jello
glasses to entry point or the causing
last entry point and I can run this
beauty image it's kind of iterating the
class say is that some type flow
analysis more analysis got us the
universe then it parses in lines and
compiled finally and well now we created
this new file HW which is here which is
also five megabytes in this case I can
run it and just hello from clocking a
local fella and if I time it it's below
ten milliseconds yeah so we're we're
looking forward to what cotton native in
Scala native or produce further but we
actually would like to invite those
projects to work with us on this type of
native solution that's actually polyglot
because in this type of solution also
caught in and and Scala don't need to
actually reimplementation class library
because we can automatically throw all
of that code in which is the biggest
barrier for some of these projects to
succeed because you need to
completeness on the class library and
then again we would end up in a
situation where you add a custom
programmer or a scholar programmer and
you cannot talk to each other and
because you either use color native or
cotton native and we think they should
be polyglot natives and this is our
solution for ah
yeah this is under on the eot things the
garment for civiles architecture
actually forces us into this EOD where
we can bring down the startup of elavil
or from 100 milliseconds down to 5
milliseconds we don't need any dynamic
compilation interpretation for this code
but we scroll BM you can still extended
with dynamic compilation because you can
still load a dynamic hard script for
example in your pre compiled application
and one of the things we are starting to
prototype right now is to also be able
to dynamically load Java code in to edit
our interpreter kind of a Java
interpreter interpreting Java and we can
then ahead of time compile that into the
system which then allows us also to use
Java in the context yet this is done
beyond the embed ability so there's a
couple of resources and graph there is
an authentic
page including a download where you can
get an evaluation download what I used
here is binary is all available for
download there we are usually releasing
every month a new version now we are
kind of slowly starting to get some
feedback from the community and we are
starting to be more confident to invite
more people to try it out well still be
gently and give us feedback
yeah be gentle and but we were confident
that we can pretty soon have a very good
have a very good product out there there
is also the crop objects on github
we are currently here on the chrome
github organization and crowlike the
compiler itself is also an open city key
project that we have to compile on the
GBM CI interface on open JDK
we acquired the handle growl yesterday
so no more followers at the moment but
in the future we'll use the growl handle
on Twitter to to post updates on this
ecosystem and you can also check out my
Twitter account I'm using it only for
updates on that on that growl ecosystems
okay thanks for your attention I hope I
could show you some interesting stuff
and I am ready to answer your question
thank you
yes so yeah we have a little issue with
the genican our integration is that we
needed to update our patches it's very
regularly due to specification update
because Grodd is actually part of to the
case so we cannot opt out of anything we
need to be fully compatible with the
current specification of models and it
turns out that actually the JVM Ti is a
kind of a special case because it's a
it's kind of you can plug in an
arbitrary compiler model into the two
MTI model but so limited to nine is that
we are Gillian CI is part of Trinity on
and you can enable this with I think -
xx unlock experimental feature
- xx use GV MCI or use to be inside
compiler so it's a few command line
flags they can update it but at the
current point in time we would recommend
not yet to use the gq9 versions but to
use the JDK 8 version that we have on ot
and for download because we are always
not sure like usually though it takes a
time when when we have to do a new fix
and it take some time until it drops
into the latest da but it will be
possible to use an unmodified gdk9
binary then plugging growl as a Java but
we are not relying only on a JDK 9
strategy we are committed to provide
binaries that are based on JDK 8 because
we want me think we we want to give this
to people frankly now and and we don't
want to only work starting with silicon
and
that is Jeremy yes so the Ruby
comparison is probably 10 X 15 X so we
are not fast material yes so the truffle
Ruby team is Chris Eaton is leading that
project we have done a very great job I
do have to take a little bit of
different approach compared to JRuby so
cherubi was trying to rewrite most of
the native libraries in Java so they
took the approach to reuse code from the
rubinius project and rewrite the native
libraries in Ruby so which is naturally
I think it's a better approach overall
but the other important aspect of
truffle Ruby is and this is what the
team is currently very hard working
honest to support native modules native
gems so they're currently trying to
support open ssl as one of the core gems
and the way we supported we supported by
a salon so so long our LLVM integration
is executing those native parts and this
allows us to be flexible enough to
support those native gems also they are
compiled against or are written for the
core Ruby runtime so our biggest
advantage to JRuby apart from the
performance advantage is the drivel
support native gems and therefore have a
better compatibility story which i think
is one of the main items that is holding
she would be back compared to Ruby MRI
so do tea compilation other showed is
only working for JVM bytecode based
languages it's working for Java Scala
Kotlin
and with you know working as in like if
there is reflection involved there can
be problems and there might be language
features in Causton HD at the moment not
translating correctly but we could yeah
so the äôt compilation is only for JVM
based languages it's not for JavaScript
not for Ruby R or for their languages
that are executing on top of the Java
framework and we it would be very hard
for us to extend it to these type of
languages in a meaningful way because
these languages like Ruby and JavaScript
is so dynamic that your T compilation is
you know you can you can snapshot we
might be able to do something or a
snapshot after one run to start with the
same configuration again that can work
but but it would be very different to
the year T that we can do for job
because charlie effectively is a static
language
as regressions and editors can you keep
using standard editors if a research
project going on with you know it's Kim
bonbon
King's College London that are trying to
have an editor called
echo that is trying to combine multiple
of these languages within one file I
think that's interesting but it's not a
strict requirement I would say because I
mean for demo purposes you wanted in one
file but maybe if it's a larger project
you rather want it in different files
anyway
added to support one of the aspects
that's important is the multilingual
that debugging aspect we are doing here
prototypes in NetBeans so NetBeans can
support these small people like
multilingual debugging is multiple
stacks and the other prototype we're
doing is the chrome dev tools that we
integrate with chrome dev tools to allow
to exit to debug not yes but also Ruby
and are in the same stack so it's more
on debugging and context I wouldn't say
the editor itself has the support so now
I'm just using any editor that can
display font in large letters and I
think this is very good is because the
record is very good for it for
presentations I wouldn't use it for a
larger project potentially but it's just
my personal opinion okay thanks for your
attention and yeah thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>