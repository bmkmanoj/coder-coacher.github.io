<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Garbage First Garbage Collector by Monica Beckwith | Coder Coacher - Coaching Coders</title><meta content="Garbage First Garbage Collector by Monica Beckwith - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Garbage First Garbage Collector by Monica Beckwith</b></h2><h5 class="post__date">2017-04-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Io8hEdm6haw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well first of all thank you all for
being here today at the same time we
have lots of sessions that are probably
at least in me more interesting than
this so I'm so glad you guys decided to
to be here with me I'm Monica Beckwith
and I'm going to talk about garbage
first garbage collector with examples
this time for people that know garbage
first garbage collector they may also
know that it's going to be the default
collector so for example when you when
you run java up until jdk age you get
parallel GC as your default collector
right you have to set CMS or G 1 GC
explicitly on the command line
so with Java 9 you you get G 1 GC as
your default collector Java 9 also has
unified logging GC logging but most of
the logs that I've shown here are I
don't know if I have any logs here but
most of the work that I've show here is
with JDK 8 so the logs will be different
but the output or the data from those
logs would be similar the logs the the
call to the logs the invocation commands
may be different actually are different
okay so with that information let's get
started so I'm a performance engineer I
used to work for AMD and then I worked
for Sun and then Oracle eventually the
last time job title I had at Oracle was
g1 GC performance lead now I'm a
consultant and I work for myself at code
Karim LLC and I'm also a partner at
extreme performance experts this is like
we offer training courses it's me and
Kirk Pepperdine we offer training
courses for people interested in
performance
performance okay with that let's move on
what I'm going to cover today I'm going
to talk about g1 GC
it's gonna be kind of fast-paced I'm
gonna introduce introduce certain
concepts that are really important in
tuning garbage first garbage collector
so so I'm going to talk about the heap
regions what are humongous regions and
what are regular regions and then our
humongous objects basically and then
I'll talk about some additional
structures and kind of like something
that adds to footprint of G 1 G C and
then GC phases basically it G 1 GC goes
through young collections and then
they're after the threshold is crossed
it starts a concurrent mark cycle and
then eventually after you've identified
the candidate or regions you go and do
mixed collections the identification of
candidate old regions is basically just
how expensive the regions are so
basically it'll be arranged from least
expensive to most expensive and during
every mix collection you select a couple
of candidate old regions until the
exhaust your list or till the cutoff is
reached which are basically tunable Xin
G 1 GC and we'll talk about that as well
and then we'll get into details as a
performance person this is where I want
to concentrate more on and I have a lot
of slides in there so we'll talk about
tuning considerations with garbage
versus garbage collectors the first and
foremost we want to talk about mixed
collections like I said there are lots
of to nobles and I want you to
understand why we need certain to nobles
and in what cases we would want them
next I'll talk about components if a gon
GC pause so when we talk about GC
logging which even GC when you do print
GC details you get a lot of information
so I will kind of quickly try to
get you guys feminized with that
information then we'll talk about two
mungus objects with G 1 G C and then
fragmentation and G 1 G C evacuation
failures and G 1 G C and finally
allocation rate and promotion rate which
has nothing to do just with G 1 G C its
with any garbage collector you have to
especially with hotspot garbage
collectors you have to be aware of your
allocation rates and promotion rates and
how you're sizing your heap so I want to
talk about that as well so let's get
started with G 1 G C background of
course the main thing about G 1 G C's
regional is heap what what is
regionalised heap so everybody knows
this hopefully we this is your
traditional Java heap you have with the
contiguous Java heap and then it's
divided into young generation and old
generation young generation further has
Eden space and survivors space and
survivors are called to and from or s0
and s1 ok
most allocations happen in Eden and then
after as Ethan gets full and you cannot
allocate anymore allocation failure will
lead to a young collection and that
would all the surviving objects which
means the live objects are moved to
either of the survivor spaces after the
objects are aged in the survivor spaces
they are promoted or tenured to the old
generation ok would you follow the same
contiguous Java heap looks something
like this it's the heap in g1 is divided
into similar sized regions the size of
the region could be anywhere from 1 meg
did 32 Meg's it's a power of 2 excuse me
and and they are like I said similar
size they don't there's no variability
in size and I'd like any given time
either you'll have three regions or you
have occupied regions ok so as you can
see here we have the ones that are not
gray are
free and then the gray ones are occupied
out of those occupied regions you could
either of those regions could be either
young or old or our humongous okay
so young regions are basically where
your young objects live okay so they are
basically Eden and survivor spaces
that's what comprises the young regions
the older where you're promoted objects
live and humongous regions are where
your humongous objects live and we'll
talk more about him unga's objects soon
so in the same bland Grapher the the
didn't drawing earlier I put some color
in so this is just for explanation
purposes you've seen enough to Eden's
sorry I'm just keep walking so we have
two Eden's
one survivor there's a contiguous
humongous region right there at the
bottom and then we have three old
regions so like I said at any given time
your reoccupied regions could be any of
the from any generation so to speak so
let's talk about your mungus objects so
in this the notation in the henceforth
is young generations is in blue or
turquoise and old generation is in green
or whatever closes to green and I have
three objects so object number one is
less than 50% of g1 region sighs okay
object number two is greater than or
equal to 50% of g1 region size an object
number three is greater than a total
region it squared is is beyond will fit
beyond a region so how would you one
allocate those regions objects sorry too
into the regions the first one is less
than 50% of the region size so it's
considered a normal object and will
follow the normal allocation path which
is
into the tea labs fast path allocation
that is thread-local allocation buffers
so they'll be allocating the object the
normal objects into the Eden space the
second object is greater than or equal
to 50% off G 1 region size so it'll be
an allocated out of the old generation
into something known as humongous region
so humongous objects are allocated
directly into the old generation and the
third one is greater than G 1 region
size itself so it'll need two contiguous
regions again it is out of the old
generation they are still called
humongous regions but they're contiguous
ok and we'll see examples as we go along
so what we've seen the first one is not
humongous so it follows regular
allocation out of it'll be allocated
into the Eden space
the next two are humongous and in fact
the third one actually needs contiguous
regions to be able to fit so g1 will
have to will need contiguous regions in
the old generation to be able to fit
that object ok so let's talk about the
footprint overhead in g1 the first thing
that g1 needs is something called
collection set collection set is
basically a set of regions so for young
collection it's it incorporates all the
young regions basically generational
hotspot collectors are collect the young
generation in its entirety not just g1 g
c but also the throughput collector C
miss collector and even serial GC your
young generation is collected in its
entirety so when you see a young
collection in g1 GC you have to know
that it it will in this collection set
will incorporate all the young regions
ok and mixed collection set and mixed
collection the concept of mixed
collection is something that's new to G
1 GC so if you compare it to any other
garbage collector so you know the
throughput collector you know the same
is collector
the drupal collector when it has
promotion failures it does parallel
collection but it's a monolithic
collection of the old generation
actually it's the collection of the
entire heap so there's a single stop
stop the world pause the collects entire
heap in through per collector and seeing
as you go do in space the allocation
till you have fragmentation and then
can't grandma failures and eventually
have a fallback single-threaded fallback
GC right
and again that's monolithic in g1 GC in
order to collect the old generation the
concept of incremental compaction is
introduced and incremental compaction is
that you are again you identify
candidate old regions and you only add
so much so many regions based on the
constraints and the tunable that you
have to each collection that includes
the old regions so that such a
collection is called a mixed collection
because it has all the young regions and
a few candidate old regions hence it's
called a mixed collection g1 GC is based
on the principle of most garbage first
hence the name garbage first so the the
idea is to have the collections not be
too expensive if the collection is
deemed expensive than those regions
those old regions will not be included
in the collection set okay so for
example that we use the same picture we
have those eden regions in the survivor
region so as i said young the young
generation is collected in its entirety
so the collection set for young
collection will have all the young
regions and during a mixed collection
it'll again the collection set for a
mixed collection would have all the
young regions and only a few old regions
as shown here so although you see about
for old regions there's only two of them
that have more garbage than the other
two so only those two are included and
it's incremental so that you'll see
multiple mixed collection pauses
so let's there's another so there's a
data structure called remembered sets
okay it's used for maintaining and
tracking incoming references okay it
adds an overhead so when you when you're
comparing footprint between CMS and and
g1 you'll definitely see an additional
overhead in footprint and that's because
of this okay so if I'm a region I have
my own remembered set and similarly
every other region has its own
remembered set my the job of my
remembered set is to know incoming
reference to me okay that's all it does
maintain and track incoming references
to me because we collect so the
advantage of collecting the entire young
generation is that we don't need to
track those references all right so the
only two kind of kinds of references we
want to track are old to young
references and all to old references and
then remembered sets have where like
they become denser depending on how
popular a region is so if I am a region
and I have one popular object which
means it's really really everybody is
trying to access it then for that object
you know so my remembered set will get
denser if I have a region I have
multiple popular objects then again my
remembered set is going to get denser so
based on so based on the popularity of
the region the density of remembered
sets will increase and that's one of the
reasons you may have performance
degradation this is a picture I just
wanted to quickly maybe maybe I won't
cover it but this is from the book Java
performance companion and what you see
here are some young regions and old
regions and what I'm showing here is
that we don't keep a track of incoming
references from the young region so
basically if you see are set for region
y doesn't have anything because the only
incoming reference is from a young
region region Y is an old
aegeon incoming references from a young
region so we don't need to track it so
our central region why is empty that was
just an example trying to explain what I
just said earlier alright so moving on
to g1 GC phases I hope everybody can see
the colors here alright so that we have
five different colors if you need me to
talk to the color about the colors I can
do that
but if you can all see it then it's good
I'll just proceed all right
so G 1 GC starts with young collections
a bunch of young collections as you and
as the heap occupancy increases we start
the marking cycle so at that white line
you see that the occupancy is equal to
initiating heap occupancy % which is
your also known as your marking
threshold or marking anything initiation
all those things I also call it I hop so
after that you start your conference
marking cycle the first phase and I'll
quickly list all the phases but just
here there are a couple of stop the
world phases in the concurrent cycle
the first one is initial mark that
that's what you see in green initial
mark is also piggybacked which means it
happens at the same time as young
collection and then you start root
region scanning which is concurrent and
enduring through region scanning a young
collection cannot interrupt the you the
concurrent process of root region
scanning okay so after you Division
scanning is done you have concurrent
mark the actual marking that happens
could and by concurrent I mean it
happens at the same time as your
application is running so you have your
application threads and you have a few
concurrent threads that are helping
happening at the same time it's not
stopped the world okay so so whatever
you see here are stopped the world
pauses that's why you see these discreet
pauses okay they're not country and they
are stopped the wrong that means only GC
trends are working at that time the
application threads are not working so
after concurrent working so concurrent
marking can be interrupted by a young
collection and that's what you see here
there's a blue line right after the
green line so because that's a stop the
world pause and that's okay you can have
multiple of those eventually you'll get
to remark would you stop the world again
remark is also known as final marking
that's where you want to do all in to
you may have missed some things during
concurrent mark because the application
was also running so you're trying to
catch up and make sure you marked
everything that's what happens during
remark and then there is cleanup pause a
small one
cleanup is also concurrent so there's
partly stopped the world partly
concurrent and then you have a one just
one young collection that determines how
many makes collections you're gonna have
so after concurrent marking we know the
lightness of our old regions we have
sorted the old regions based on the most
efficient collection so based on their
efficiency so the least live ones or the
least expensive ones will be collected
first and the most expensive will be
later so so they're all we have at that
the last young cause that you see when
we know that we need to include so many
old regions based on our targets okay so
then you see the incremental collection
which is also known as mixed collection
or you can also call it incremental
compaction there different ways but it's
the same thing so we see five different
mixed collections here and during that
we we're collecting these candidate
regions so we have different thresholds
sometimes the thresholds because it's
not hard stop so sometimes the
thresholds are just there to to let you
even know what it should do but because
of the prediction logic it may blow your
poss time target and we'll talk about it
in tuning so that's what you would see
you know in g1 GC these are all the
stuff the world passes that you will
notice in g1 GC you could have
more mixed collections because it's
incremental and then so so moving on
from here I'll quickly talk about what
happens during a young collection so
basically describing the what I just
said so all your agent regions and
survivor regions are collected basically
compacted and the live objects are
moving to their survivor or promoted
based on their age then then after you
have a multiple of young collections
like I said you have the marking
initiation known as I have and it's
based on the total heap size it's an
occupancy threshold and that indicates
to g1 that you have to start concurrent
marking there are two useful options and
I've clubbed concrete see threads here
so first of all I hop is adaptive in
Java 9 the prior to then it was the
default is 45% so but it's tunable you
can use the I hop option and you can
specify it based on your observations
and there's something called the kanji
sea trench remember when I said root
region scanning and concurrent marking
they were concurrently with your
application sometimes you may want to
adjust this particular option to two to
get through that concurrent phase faster
so so that's and that's by default 1/4
of your parallel GC threads something to
keep in mind
so content marketing stages I already
covered all of them so one thing I want
to do highlight was that if you're using
something prior to JDK 8 update 40 and
you have issues with class unloading
then with judicata update 40 class
loading with concurrent marking is
enabled by default so that will that
problem will go away okay
and I'm had many people that had that
issue and then update upgraded if that
if that's amazing concern then of course
you should have created another thing
prior to JDK 8 update 40 again
humongous objects the only way humongous
objects could be reclaimed was during a
cleanup phase now during the cleanup
phase remember who I was talking about
the liveness of the old generation in
all regions is do remind if I if at that
time they fell between the phase finds
that one old region or multiple old
regions are empty because they are full
of garbage
it can reclaim it it doesn't have to
wait till a mixed collection pause so
this was the way if you had a dead of
humongous object this was the only way
other than full collection that there
was that humans humongous object would
be reclaimed so if you had any problem
prior to adjudicate update for T with
respect to humongous objects not being
reclaimed that has changed in G decade
update 40 and onwards so with with jdk
and update 40 now humongous objects can
be reclaimed at during a young
collection pause okay it doesn't have to
wait till the folks go GC or till a
clean up okay so it's a reclaimed here
now coming to mix collection again yes
well well it's just treated as a as an
object that is so you you can do those
things because you know where you're
allocating those humongous objects so
you can you have an idea where they are
so you can go and check their liveness
to when you're doing you're doing
marking didn't know just during your
young collection you're already doing
marking and all those things for your
young to write so you can just include
the humungous regions as well at that
time yeah because remember I said normal
allocations are young and then humongous
always going old so we already know that
those are humongous we already know it
okay sorry so so this is what we had
seen earlier our collection set remember
so we have all the young regions and a
few old regions and after a mixed
collection we have achieved compaction
so they moved all the live objects are
moved according to their age and whatnot
and here you are okay so now moving to
tuning considerations with g1g see the
first and foremost is Taming mixed
collection so the reason I said Tammy
mixed collection is basically you try to
achieve where you want to be by by
tuning
various knobs right so so what do we
need to tame mixed collections so say
you have your young collections are
meeting your SFA's so basically your
system level agreements are met based on
just the young collections alone but the
mixed collections are happening too
frequently so they're they're the GC
overhead is increasing and or your mixed
collections are blowing you're SLA is
basically the latency you know so you're
they're more expensive so either too
frequent or more expensive okay that's
the reason why you will tune your mix
collections is there everything is happy
happy and going nicely why would you
bother right so there are two reasons
frequency and latency so for example
here you see all the collections are
less than hundred milliseconds
except for the last one here this one
right so what do we do so if if just
bringing it down is the only concern
then you can divide the expensive
collection you had only one expensive
collection right so you can divide your
extensive collection further into
smaller inexpensive collections okay so
how do you do how do you know first of
all what I need to do next right so
there's an option called print adapter
size policy and you don't have to go
look at the log all right so there and
just what what you can observe I'm gonna
just visualize it over here I'm not
going to show you the log last couple of
times that I showed the logs it was too
much information right so in the amount
of time that I have I will just let you
know a couple of things so you have a
minimum threshold
for each for the old regions for each
mixed collection and then you have a
maximum threshold so a minimum number of
all regions to be included in the mixed
collection set is tunable maximum number
of all regions to be included in a mixed
collection set is also tunable so if you
find them one thing something that's
expensive you can divide it further so
reduce your maximum down right you could
do that so the option for those two so
first one is governed by G 1 mixed GC
count target and the second one is G 1
old C set region threshold percent so
instead of saying mixed C set it's
saying old C said it's the same thing
because basically it's controlling how
many old regions are in your collection
set simple maximum threshold all right
now moving on if that was because
latency one single pause was expensive
what if your GC is too frequent mixed
collections are too frequent right so
your GC overhead is the problem okay and
you have an escape break and I'll show
you an example after and because you
have enough heap and you know you're
humongous regions are I'm gonna blow
your heap
whatever so you have everything here
interesting you can just remove the
expensive regions from your collections
keep them where they are you don't need
to include them in your collections at
all so how do you do that
so you just eliminate and I'm I'm saying
then you know if the 5% of my regions
are expensive I don't care about them I
have enough heat to spare leave them on
on the heap till they become less
expensive simple I don't want to move
objects around if they're if there's so
much of life in data in the air or
whatever so there are two options you
could eliminate based on the lightness
remember after concurrent marking we
know the lightness per region so we are
our own bosses right we can eliminate
you based on the liveness pearl region
the second thing you could do you could
also eliminate expensable regions
altogether right so the two options I'd
let you do that the first one where you
can eliminate okay the first one we can
eliminate based on lightness is called
mix GC g one mix GC live threshold
percent I think by default it's 85
percent you know and you can lower it
you can increase it
the second option just which just says
that keep him in the heat I don't really
want to bother is called g1 heat waste
percent I'm okay wasting my camp it
simple is then so I have enough heap
keep those expensive ones in the heap by
default it's five you could increase it
to ten or whatever you know if you have
enough you to spare so they're two ways
so frequency and latency and they're
four different options that we discussed
right now components of a g1 GC pause
like a single stop the world pause what
is it made of so we saw the phases now
we're going to dive into each pause so
I'll show you the pause how it looks in
the just log but something very pleasant
now is what we see here I'm hope
everybody can see it if not then please
come over and have a look these are so
basically a single GC pause has multiple
has two phases the parallel phase and
the sequential phase
during the parallel phase g1 GC and
actually other GCS - they employ
multiple parallel threads that do work
stealing their work queues and all the
beautiful queueing Theory optimizations
right and then after the parallel phase
is done you have some sequential work
that is done which is like code route
fix help and then clear a card table
then other times okay so what we have
done here is like you'll probably many
you may have seen this earlier I mean
somewhere else as well it's basically
just pop plot all the pauses so here we
see the past time the peril of time and
the object copy times are tracking
pretty well right so what we saw there
is an ideal situation right so what
should be a major contributor to your
pause because we're doing it to stop the
world pause what's the major work that
we're doing during a pause we're trying
to move live objects we're trying to
achieve compaction by copying live
objects so what should be the major
contributor of your pause ideally you
will see that most of your pass time
should be spent in copying live objects
so object copy times should be the major
contributor if it's not object copy
times then you have a problem okay and
let's see how this is the same graph
it's nice everything is tracking nicely
see those are your object copy time
times in turquoise which maybe we can't
see but you can just see it's very close
to each other to your pastimes and your
parallel times so when it's what happens
when it's not the case what would you
see you see something like this okay so
so here what you see is that the object
copy time is kind of about 100 yeah
about hundred milliseconds there's a 100
milliseconds difference in the parallel
time and object copy time and between
the past time and parallel time you have
about 15 milliseconds difference okay
and that is because of that yellow line
which is update remembered says remember
I said
remembered sets can pose issues in your
partnering and pause based on the
density and other things so in this
particular piece of need remembered set
took about little less than hundred and
twenty five milliseconds and the
difference between the past time and
third a long time it's 50 milliseconds
and that's because of the other times so
other times I really a reference
processing and other things happen okay
and and I've seen in my in my
consultancy work that lots of people
have reference processing issues that
they don't know because of the libraries
they're using or whatever they're
calling and you can clearly visualize it
here right similarly over there again
update RS which is update RS time is the
same as your past time it's expected to
be 10% of your possum it's the same here
as the object copy times I mean and then
you have again the other time you see
it's like 125 so we have some issues
here right but this is how your GC log
would look for that particular pause the
first part that I showed right so you
have the parallel time and all the work
that is done during the parallel time
and then you have the sequential times
which are code would fix up code with
migration to your card table and others
and there are various things that
happened during the other than only four
of them I mentioned here so in that
particular case when we saw the other
time is 15 milliseconds thirty six
thirty four point six milliseconds or
because of reference processing there's
something nice to investigate further
another thing that you have to be
careful of what you applauding what's
you observing great and I as a
performance person I always talk about
what are you measuring measure your
worst case right so in this particular
case you can get minimum average maximum
and of course a difference in this but
for this particular pause the difference
was 65 milliseconds all right so so if I
plotted just the maximum which you saw
earlier you would see something like
this but if I plotted the average times
you see the yellow line is pretty normal
when you're plotting the average there's
another thing measurement and measure
and plotting
is important I don't have much time to
talk more about that because we're
talking about G when you see but again
but U and G C make sure you're plotting
the max okay
humongous object requirement okay
so ideally humongous objects are few in
number and are short-lived right
a lot of long lived among these objects
can cause evacuation failures if you're
not sizing your heap properly if your
old generation is not if you don't know
that humongous aren't it's a directly
occupying space out of your generation
and you don't know that you need to
increase that space and you can get it
back problems because of that because
humongous regions add to the whole
generation occupancy right so we saw
this earlier right in that particular
case what did we observe we observed
that there allocated out of the old
generation they are not moved right
unless they are dead and then they
reclaimed but you don't move you don't
they're not including in copying things
if they're live they're expensive to
move you don't want that to happen again
we already I already spoke about that
all right what else did we observe we
observed this kind of space which is
wasted space I'm sorry you cannot see
the text in red
it's it's a it's wasted space because
each humongous region can only have each
or contiguous region can only house one
humongous object you have so much of
wasted space right again so then so
humongous objects can pose the following
issues you have wasted space which can
lead to fragmentation and then you have
the evacuation failures because you
don't have enough to space regions okay
so let's talk about fragmentation in g1
g one has some internal fragmentation
that we've already had covered so i'm
going to go quickly to them remember I
spoke about heat boys percent I say that
I've enough heap to spare I don't want
to collect expensive regions right so so
g1 is designed to absorb some
fragmentation so it does have it it's
internal you don't want to collect those
regions you want you don't want
touch those things so it's default is 5%
and it's because you want to leave those
expensive regions out not included in
your collections there's also we spoke
about the g1 mixed GC liveness threshold
right that is when each region has is if
it's more expensive than the threshold
it's not included in collections right
so again the default here is 85% and
again the trade-off is so that that
expensive region is not included in the
collection
what about humongous objects you have
wasted space right that's internal
fragmentation but there's something
called external fragmentation - I'm not
sure if I have been ok yes I do so it
happens because you're trying to
allocate humongous objects and remember
the requirement to allocate humongous
objects is continued contiguous regions
what if your whole old generation has
free space but it doesn't have
contiguous regions and that's
fragmentation too right so that can
humongous objects can cause
Ragman tation if you're not sizing your
heap accordingly oh my gosh okay so
fragmentation can lead to evacuation
failures let's talk about evacuation
failures and what other things can lead
to packaging failures evacuation
failures are also known as promotion
failures or to space exhausted
you know many multiple terminologies but
they mean the same thing and you have
those in CMS and your promotion failures
and even throughput collector that's how
you get the own collection kicking in
alright again read I'm sorry you cannot
see the red but in what you the text the
first text in red is to space exhausted
and the in the other time you'll also
see how much time that exhaustion
evacuation failure took so in this
particular case it took four hundred and
thirty seven point five milliseconds
that's a GC log it's you can see that in
when you enable print GC details right
so I can see that I had during my young
pause I had an evacuation failure and
then evacuation failure took
hundred and thirty seven point five
milliseconds I'm sorry about that red so
what is it my constrain failure when
there are no more reasons available to
be able to move your survived objects or
you're promoted objects or within like
from old to old on slow simple it's
expensive and the usual pattern is with
with these with the guard the collectors
that have a cache and failures is that
it'll lead to a full collection right
see when I waited a heavenly tuned JVM
command line could be restricting the
guard G 1 G C adaptability g GC
ergonomics is a hot spot J JVM term I'm
using the same thing and adaptability so
G 1 is adaptable if you give it a pass
time go and I guess I say that start
just with your heap sizes and a
reasonable pass time go and see what it
leads you alright you're likely to send
in long-lived transient data may be too
large for the old generation so when
people talk about live data sent they
only think about the London what about
your transients you are promoting after
you aged them you are promoting those
objects in their own generation and
these are your transient live data right
so you have to accommodate them too and
then remember humongous objects too so
check your live data set plus everything
else and increase the heat to come
accommodate that in your old generation
you I hope could be the issue again if
it's if I have if the threshold is too
high then guess what your marking cycle
may not be able to complete in time and
it can delay the incremental compaction
which is mixed collections and then you
can tap evacuation failures right
marking cycle could be taking too long
to complete remember I said we have
marking threads that help with the
marketing cycle right to increase those
threads thread count and reduce the I
hop to start marking cycle a little bit
earlier
to space survivors of the problem which
means that you notice that you have
enough space in the old generation but
your survivor space is the problem so
there's something oops sorry
there's something called g1 Brazil % and
basically it's a false ceiling I think
the default is 10 10 % you can increase
it up to 50% which means that it'll
allow the region to accommodate more
survivors it's simple
evacuation failures oh goodness I'm
sorry what did I do
so let's go critique I did something
crazy okay so so now the air is just
really it's jbb 2005 run on my laptop
and I tried to just push too many
command-line options just to give you an
example of how crazy you can get and
this is what I see I have warehouses
running I have too many threads and my
laptop can handle and I'd love all sorts
of problem and I've tried to restrain my
young generation size like minimum I
gave it to like don't have the young
generation below so new size I specified
new size and my heap is only one one gig
and you have lots of it this is your
this is the occupancy information
alright what that ended up doing was I
had multiple evacuation failures and
full garbage collection and it just went
on and on and it's crazy you see how the
yellow line basically blends in with
your heap the total heap size that's
your old generation occupancy just keeps
increasing and the concurrent cycles are
not able to keep up we don't have enough
threads all craziness alright then I
said ok let's take step one remove the
nursery constraint keep the heap at one
gig remove the nursery constraint let G
1 do its magic yes it's kind of a lot
better right right we see that the old
generation is not reaching the having
the issues and heap occupancy is get
before and after getting up better still
have a lot of evacuation failures so I
wenden plot you know I opened that in GC
histo and at what I see is that I see my
initial mark cycle and I don't see any
other thing so my concurrent cycles are
taking having issues and I see that I
have full collections right after the to
space exhausted because to space
exhausted couldn't do much work to and
then I also see a bunch of messages in
print adaptive size policy output for
the same section what I see here oh gosh
I'm sorry again red I see that did not
expand the heap recent heap already
fully expanded and wreaths in GC
overhead higher than threshold after GC
so it's telling me it was trying and
this is not the first time I see this
message I see this message all over my
love it's trying to expand the heap but
he cannot and my GC overhead basically
if the frequency of my garbage
collection pauses are way above my trash
holder so I had enough sleep to spare
like I said remember and I increased it
to 4 gig a lot more and then it
everything was ok this is simple spec
jbb 2005 it's got very few it's work
each word warehouse has about 32 Meg's
or something so it's not really
intensive workload but since I had
constrained it so much I had constrained
my command line so much that it was not
able to breathe G 1 GC was not able to
breathe and here actually you and you
see managed to avoid mixed collections
all together because you know it can
just manage all young collections and
it's beautiful graph right here I can
tune it further but I just wanted to
show you an example that you know don't
constrain a command line all right
finally allocation and promotion that's
very important to track them this is an
example and I'm if you've seen my other
presentations you may have seen it
before as well this was an application
that was running on CMS and it would
have these allocation spikes and because
they hadn't already tuned CMS so much
but they're sizing was not the the
tuning was not a was not done to
accommodate the allocation of spikes
and what you think is the promotion rate
increases just as the allocation
increases as well but because and this
is a the when I planted that same as he
what you saw that what do you ha the
yellow lines are not visible I'm sorry
can can everybody see the yellow
occupancy line so that not see all
generation African see you see it's
already around 13 gigs right and the
total heap is 16 games so right when the
allocation spike happens which is
where's my pointer well anyway so just
write it right here all the way up there
your heap occupancy before GC and old
generation occupancy are basically
meeting which means that right then you
have a promotion failure then right next
to it you have a concurrent mode failure
and then you have full GC and see how
the occupancy drops so you have enough
room in the old generation but because
of fragmentation issues and all those
things you're their occupancy drops only
after full collection so if you're not
tracking your allocation rates and
promotion rates with garbage collectors
you could have a problem you because of
the way g1 does incremental compaction
this problem was not seen in g1 it
wasn't that bad but we could tune it
further and that's all I have
yay okay if you have any questions we
can take them outside</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>