<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java 9 Is Coming!  by Nicolai Parlog | Coder Coacher - Coaching Coders</title><meta content="Java 9 Is Coming!  by Nicolai Parlog - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java 9 Is Coming!  by Nicolai Parlog</b></h2><h5 class="post__date">2017-03-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vOdFuvIyN0E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">great
hi everybody happy you're here look uh
Sarah's trying was threatening me to
take all my attendees to talk about SQL
but who wants to learn about SQL right
so who is soos using Java eight at the
moment wow that's almost everybody I
guess maybe even everybody great so
you'll be ready to upgrade to Java nine
soon nope doesn't work yeah I heard that
before good friend of mine said he will
update to Java nine he will do
everything to get two video types in
Java ten so maybe that's a good
motivation to go to Java nine but I
would hope to give you more reasons to
switch eventually so the title of the
talk is Java nine is coming and I go
over that and then in the end we can
talk a little bit about me but first my
name is Nicola hi great so Java man is
coming when July really we that that's
the latest and we have and it looks like
it's going to be the actual release date
so settle in that's that's when GA comes
out okay a couple of things before I
start them way too many features in Java
9 to go all of them in detail right so
this is a showcase no tutorial you're
not supposed to get out of this and say
right now I can start using these
features I hope to give you ideas how
they work and how you could might want
to use them and then you can look it up
later and a lot of features I can't even
go into I'll just name them and then you
can see whether it makes sense for you
you can of course ask questions during
the talk after the talk if you're not
the kind of guy who speaks out in public
you can Twitter here and I will maybe
see it and answer and you can follow if
you want the slides already online now
I'm so I can follow there okay as I said
I have lots to talk about so these are a
couple of things these are all the
things actually almost all the things
that that change in Java 9 so first of
all you get the module system of course
we have a quick look into that then a
couple of language changes that we'll go
over quickly
then you and updated api's this is where
we could spend hours and hours we're
just going to look at look at a selected
few and then also the last two which is
something that you might not immediately
come upon what but or just still vast
improvements that we're talking about
so let's start with the module system
unless because we can pick and choose a
little bit who of you knows the module
system basics it's almost half it's
actually the worst result I hope ever
either no one or everybody okay since I
still go over it but I make it quick
so larger system has been around for
almost nine years no it's in it's in
planning for almost nine years now so we
make it this year hopefully so let's
start with with met parts with jaw he'll
the way we see it now jars have very few
properties they're just containers for
classes really so you cannot really
define an API everything that is public
is public there is no such thing as only
within the jar you cannot name
dependencies and there's no version in
concept and this is not only a academic
way to complain about Ross this is extra
consequences build tools alleviate many
of them but you still might get no class
they found error of jars missing you
know you can never find out alter the
problem actual course on running system
you have no encapsulation across jars as
I said earlier and you get nice version
conflicts where you end up with two
versions of guava on your class path and
you don't know which one runs and why
and all that kind of stuff
so income modules modest try to target
this and try to leave your jar hell and
the first thing they do they get a name
and you get in-state explicity which
things you depend on that's awesome then
you can also define your ap is you can
say these you can look at it later how
this exactly works but you can say this
part of my API is public and the rest
will just be within the module we still
don't have a concept not no concept of
versions and so this means we still
aversion conflicts so there's really
nothing changed there which i think is
sad because that was the most pressing
part of John I think but you get another
couple things reliable configuration
strong capsulation we're going to look
at that and a couple of other things
that we briefly talked about so modules
modules means every code is in a module
and also the jdk code was split into
modules into these ones you can probably
even read that that's fine the point is
I'm trying to make us the JDK was split
up and was put into several parts you
have a module for SQL you have a module
for XML you have a module for all
the UI because that was cannot be
separated so the JDK was split up into
modules - one of them is this one the
Java or SQL module all modules are
defined with such a file with a module
info Java file and you can see the basic
structure module and this is the name of
the module then we require some other
modules and this is strange keyword in
here we'll touch later on what it means
it uses something not clear what that
means and then exports things and these
are packages through confusing this is a
module name
these are package names these also
module names this is the basic way to
define a module otherwise the modules
just like a jar but if you compile this
thing and put it into a jar then it's a
module so there's no new format for your
modules for the SQ for the java modules
actually there's a new file format right
so now let's not talk more to features
we live a configuration and strong
capsulation and we look at each of them
in turn reliable on configuration is
very easy you say i require these
dependencies and then the module system
will make sure that they are there when
you launch and they have to be there
otherwise you get an error then and then
not later when the system run for a
while and then there are a couple of
other things that it checks like there
should not be any ambiguity no two
modules should say not to jars should
say there are the same module for
example because one is guava 1800s 114
they both claim to be guava and then you
get you you can launch so this kind of
immediate ease or many of them are
excluded you cannot have dependency
cycles at least not defined at compile
time they can occur at runtime but at
compile time you cannot say a depends on
B and B on C and C depends on a again
and no split packages this little mystic
but what it means is a single package
let's say the java SQL package cannot be
present in several modules and this can
cause quite a trouble actually when
modern migrating to the module system so
that's the first feature reliable
configuration second feature is strong
capsulation second basic property of the
module system here we export a couple of
packages and what that means is that
only public types in those exported
packages are available outside of the
module so when you see public on a type
that doesn't mean now it means it's
visible everywhere
if Java 9 it only means it's
everywhere in the module and maybe
outside the module I'll have to check
the module declaration to see what exact
exactly is going on
so the SQL packet a module sorry exports
these three packages and so result set
for example which is public because it
is public and because it is exported by
the packet by the module you can use it
you can access it but only if your
module reads Java squirrel that means
your module must depend on Java SQL you
cannot accidentally use types from
modules that you just have
coincidentally on the class path like
today you can let's say spring uses okay
HTTP and you start using types from ok
HTTP even though they don't show up in
your maven form or something so this can
happen anymore if you do not depend on a
module you cannot access its types this
is also where the transitive comes in it
just means that you can also see the
types of the module if that model
depends on details are not that
important I just didn't want to take it
out so this is the actual ways in the
module descriptor then we can go into
all kinds of features the different
strengths strong capsulation reliable
configuration of basic properties of the
market system but then there are tons of
features that we could go into one thing
I picked in particular because I think
it's kind of nice our services again
would SQL the SQL module says it uses
this type this actually interface it
says it uses this interface and then
other modules can say look I have an
implementation for that interface I
provide this interface with the class I
have here with my mom I scroll driver
class so you can have one API somewhere
and then love modules implementing the
API and they're all just proclaim I can
implement this API and then the module
system acts as a service registry and
then code can just go to service loader
please load all implementations of the
driver class and then the module system
interacts with that looks at the
provides clauses and it gives you back
an iterable I think is an iterable off
driver and then you do something in this
case are for each over it and put into a
list you can do whatever of course so
there's a nice little feature that you
can use to decouple your your system
there are more features as I said
earlier one of the most important ones
are the first two we just seen requires
and exports and they were very
rudimentary right
require something so it has to be there
but what if I only wanted to be that
compliant I'm not at run time they come
optional dependencies maybe you only
want to export a package to a certain
other module you can use qualified
exports maybe you want to open a package
only for reflection so that hibernate
can use your entities but you don't want
to make your entities public API you can
use open packages and modules for that
so there are couple of things there how
you can tune this requiring and
exporting
then if everything is a module you never
knew would never need these two features
these two things two unnamed an
automatic modules but in the beginning
well nothing is amol you really only the
JDK stuff but everything else everything
that you're right and everything you
depend on in the beginning is in the
module and to make sure that each
library developer and each framework
maintainer and each application
developer can migrate to module systems
at their own pace you can you have these
two features which enable data migration
layers is an interesting thing layers
means you can have or not only one set
of modules running but you can have
different sets of modules in layers
running independently of each other so
you can use containers might want to use
that to make sure that they don't
interact with another one another the
different layers of the system and then
another interesting aspect is jailing
that's really cool actually with jailing
and create runtime images so let's say
you have a server application you don't
want to have swinging your JDK because
then we make it easier to deploy to
docker or something we make the image
smaller with jailing you can create a
JDK in a runtime image which contains
just the modules that you actually need
and you can go further you can actually
include your application modules in that
if you want and then if you run a bin
slash Java your application starts you
can do that for images for docker images
maybe but you could also do that if you
want to if you develop develop desktop
application you can deliver it you can
deploy the desktop application to your
customer in the form of such a random
image and then they just load and it
loads with that Java modules that you
have put in there and they will always
run with them that version and then
there's a final feature of the module
system and that's it brings much
complexity especially in the beginning
and I guess there will be a lot of
people hopefully me including and
including
who can live from that meaning that
trainers and authors and all the kind of
people will tell you a lot about module
system because it does indeed pretty
liberal complexity but in the end it
always comes down to a simple principle
of requiring your dependencies and
exporting your packages and from then on
everything comes kind of naturally and
there's a good way to get to get started
if you go there great so I'm writing a
book with many there's an early access
soon and there's also course here in
April if you want to okay enough with a
shameless plug that was the module
system if questions about that you can
ask now or later it's easier than OSGi
um that depends on who you ask I would
say the basics are easier than OSGi is
also less powerful than I was joy
because there is no dynamic runtime
behavior here there are no you can just
unload the module I want to guess it
easier but it still means you have to
know a lot for similar concepts of
modules and you want to think about the
capsulation anymore maybe you want to
think more about services and I think
that's actually benefit also towards the
I much more Java developers will get to
know this modular concepts and I think
if they then have to going towards G I
will be much easier than it's now so
then Java 9 also comes with a couple of
small language changes none of these are
even close to what lamb doesn't deter
sand in Java 8 so they are just very
small things but I think they're so nice
and it's worth looking at so let's start
with private interface methods before we
had them if you had to to default
methods in interface like here and you
want to share Cody I want to share the
some numbers method I want to share code
and there's no really good way to do
that
and make it a default method which means
it's public and everybody can use it and
maybe I don't want to I could put into
some utility class but you know it's all
kind of clunky it's not nice and so
probably used to when we code with
classes
so in Java 9 we just do this the rest of
the class is the same but here we can
just go private and then we have a
private method in the interface and
private methods and interfaces are
exactly like there are extra classes but
means especially that they cannot be
overridden
so it
have private method interface and then
have the implementation of the interface
change that behavior somehow that would
actually kind of need to have something
like protected methods and interfaces
but we don't so the private method is
really just there for code sharing
within the interface then try with
resources when you're using time with
resources a lot I'm sure you have come
up against this one case where you have
like actually the most regular case you
get something like connection you
already have it lying around but then
you have to do this thing to use it in
the try block yesterday connections seek
like connection why why see if necessary
and the reason why C is necessary is
actually not a technical limitation it's
this block only makes sense if you if
you're sure that you close C should not
be able to in here assigned C to
something else and then what gets closed
down here it's unclear so the idea is C
has to be final and the easiest way to
make that final is to just force you to
declare it here and this is implicitly
final so this is actually only reason
the only reason is to make sure the
developer knows what exactly get is
going on and to force them to make this
final but in Java 8 we got a new feet
and not only feature new concept it's
called effectively final you might
remember effectively final sorry yeah I
also just set down here you see again
the connection the try block and this is
where the final isn't implicitly
effectively final so in Java in lambda
expressions you also can reassign you
cannot you can only access things out of
London also if the lambda expression
that are final but having to declare
them as final was was seen as clunky so
the idea was to mark them by the
compilers effectively final meaning they
could be final it wouldn't make a
difference because they're not not
reassigned anyway so Java eight top is
to the compiler and also taught us to
developers now we have this concept of
something it's not Eclair as final but
still it's never changing really and now
Java 9:00 a.m. makes use this the this
property here and now we can do this
this is our I'm saying so I don't have
to reassign here just a small change but
I think we'll make come up these blocks
a lot nicer
okay diamond operator I think and I
can't even recall I didn't
kochevar not a couple of like five years
ago or something so I can't remember
doing it without the LA without the
diamond operator without this like
putting string in here I can't really
recall doing that or not but I sometimes
see code we're still in there where my
te helpfully complains that this is
unnecessary and that's actually really
nice improve from that you can just
leave the string out here because it's
obvious that must be a list of string
right so if you use diamond operator
just tell Java look you'll figure it out
which type you use here but this never
worked here so here I create in boxes a
class and I create an enormous subclass
here this doesn't make sense really
usually I would be some implementation
in here but if I want to do something
like this I want to create an enormous
class then I have to put in the T here
why again why is not that that obvious
the reason is that the compiler knows
more types than the JVM knows and
sometimes the compiler in first types
that cannot express cannot be expressed
by the JVM and it's called nandi notable
types and this happens in certain cases
will receive one later with anonymous
classes that can happen then so the idea
was if that can happen they were not
sure what what we're supposed to do so
just forbid it that we just don't do
type inference here so now a couple of
years later the decision was made well
why not after all we just we just do the
same thing as before but now we allow it
here we allowed to infer the type here
and if we come up against an on D
notable type then we get a compiler that
means that you can now lose the the type
of the parametric generator sorry
generic parameter here final classes and
still end up with a smaller code and in
90% of the cases within the JDK there
was not a non inaudible type if you are
a construct one you have to do something
will be crazier like this I have to
admit I don't know why it doesn't work I
check that indeed doesn't work but I
can't tell you about the exact details
the point is in this case the type that
is inferred here it's not inaudible
so you're the compiler and you can see
from this construction this is not
something you do regularly so most cases
are like this and then they just work
second-to-last save marks I have a look
at that coat does it doesn't make sense
so if the I have a method first normal I
give it a couple of arguments I used two
VARs argument here and then it's a
stream of the arguments find the first
thing that is not null and return it and
if all of them are not allowed just
return the empty optional so that seems
to make sense but the compiler warns me
here as well as on call sides it warns
me but this possible heat pollution from
parameterize of our arc type what the
hell does it mean it means that when you
box into like maybe you know that
generics and arrays don't cooperate that
world you cannot actually have an airing
of T it must be either area of string or
area of object or something and when the
Java compiler cannot really tell which T
you using it actually creates an object
array if it creates an object array and
you rely on the array being actually of
type T then you can end up in trouble
then you get a heat pollution meaning at
runtime there is something on the heat
that is supposed to be let's say a
string or string array but in fact it's
an object array when you operate on that
the JVM crashes or you don't
JDM doesn't crash particular runtime
error so this is a way to build this the
details are not that important effect is
that I call this method and here I
return there the I turn T array and when
I call this this thing I can put in two
strings and I get back or sort of
between three strings and what I get
back it's not a string area but an
object array so that will be bad so
that's why the compiler wants me so
comfort the compiler tells me that this
is not safe and I should do something
about it so either I can have a look at
the code and decide that it's unsafe and
I fix it or in fact it is safe and the
code that I showed you in the beginning
work was safe because it never relied on
the array itself it just used the types
in there so I can put this on I can say
it's a farts don't bother me without
warning anymore but doesn't work in Java
8 because private is not final power
method is not final because save marks
are only allowed on final methods
that makes sense too because the the
warning also appears at call sight so I
call a method and the method is
potentially unsafe so I get a warning
here where call the method so now I
imply the apply the safe mark sanitation
over there but let's say the method is
overwritten then maybe the other
overriding implementation actually does
something harmful so here think it's all
safe in the entrance out it's not so we
don't want that so save marks can only
be used if the method cannot be
overridden which methods can't be final
methods done only using our final
methods so private methods where as far
as I could find out just maybe not maybe
just forgot so they were just not
including that rule in Java that fixes
that so now you can do oh yeah sorry now
I can do say Forex on private methods
and have one less warning whoever works
with code that has deprecations in it
okay and I like my code to be warning
free if possible and there's one thing
that's actually a bit annoying so see
this class I used the Java type line
number input stream which is deprecated
do you think this class should throw it
application warning I would say yes it
uses deprecated type so I should get a
warning somewhere here okay now I do
this now I'm saying look and now I'm
using deprecated API but I must say from
deprecated as well so you know don't
bother me both of the guy who calls my
code unfortunately I still get
deprecation warning on this import here
which really doesn't make any sense when
you think about it because I'm already
saying like I know I know I shouldn't do
it but still get the warning up here if
you use the fully fully qualified class
name here so you can lose the import you
could just put the Java hyo's blob up
like down here then you're good to go
which is stupid because then the import
itself does of course not changed what
you're really doing so Java and I made a
very sensible change imports don't
generate imports of deprecated types
don't generate warnings anymore so if
you do things like this you can have one
infrequent
okay let's look at the clock we might
make it through everything because
otherwise what's going to make you
choose what you want to look at but I
think we can go to all of these so we
had the module system which does a lot
of things all over the place the JVM has
changed you have this new module in for
fire the compilers changed everything is
changed then we looked at the language
changes which just touched louboutin
syntax code that didn't used to compile
record because it was just not syntactic
Java now does compile or generates less
warnings now we can turn to things that
are more more higher level changes just
regular new API is new things you can
use new stuff you can call first of
those are connection factories you know
if you have the you have static final
fields that are just the list of I don't
know to Google URLs or something and you
want to make a list of just these two
URLs but we want it to be you use Eric's
as list maybe but if you want to do a
map it's much more complicated and some
people said this would be so awesome
like just like Python does for example
just give me some shorthand notation to
say I don't have a list of these
elements and be done with it yeah that's
not gonna happen there's a long talk by
stuart markzware explains this and does
actually make little sense i tried to
summarize it here's here our first
reason this language changes are always
costly there was touched a lot of things
and there's a lot of regression testing
involved so first of all it must be must
be a sufficient benefit to make those
cost worth it
but the second part is actually much
more important because the java language
does not really rely on the collection
framework there is no connection in that
direction of course the JDK API is use
the collection framework extensively but
the language itself doesn't know about
the collection framework but if you
would do this then it would have to
another compiler or something else in
the area make sure to know that oh yeah
if this if I see this then I do have to
create the Java util list or sorry jar
util ArrayList maybe and that's not the
nicest thing to do especially because
then this only works for the Java util
aerialist so if you have a different
implement
which is different list implementation
which is also quite awesome and you want
to use you're still stuck with a now
much more cumbersome regular way of
doing it so now the native API which
might not be the best in your situation
looks so much nicer so you might still
want to stick to it so it gives an
unfair advantage to the JDK collections
so yeah so for these reasons and I think
the second one is the most important one
this is not going to happen
instead we get just simple factory
methods since Java 8 included static
interface methods you can have static
methods on list and on map and on set -
and these are just if you're using
immutable collections from Java you will
recognize the FM's from so guava you'll
recognize this immediately this is very
similar you just do the class in this
case it's interface off and then give
the types for map you can either do this
or if you have too many types I think
there are up to 10 parameters there
exist overloads up to 10 parameters if
you use more than you go with this with
the entries there's also static factory
method on I'm not sure which which map
entry type so this way you can create
areas at hoc
sorry Maps or lists or sets at hoc this
has a couple of interesting properties
it's not just that you create any list
you don't actually know which list you
get but this list that you get to have
certain properties and the most
important one is they are all immutable
the idea was to use this in for example
in final fields which it would have that
we might call constants in those in
those areas was the most primary use
case for these so the idea was not just
to see the list with two three elements
and later put in more elements that
wouldn't work these are immutable but
there's no the mutability is not visible
in the type system you still get a list
you still can call at you just get a
runtime error so if you heard that Java
9 has immutable collections then this is
if there are collections that are
immutable but the type system doesn't
show you that which would be nice but I
think it's hard to retrofit so if you
use these be aware that I mutable they
don't take null values which I hate now
I think that's a good decision and
that's really interesting that has
because for example in a set decoration
roller might change from system to
system from run to run because the
hashcode is used which is not stable but
these implementations use because they
made made for performance if you have
very few elements they actually use
fields to store the elements and if you
store them in the field you always get
the same iteration order any every
system every Java version you always get
the same iteration order that would mean
that code might accidentally depend on
that or it makes it more likely because
there's never a change in this iteration
order so this very interesting decision
was made then from one JVM start to the
next you get a different iteration order
so if you go list of ABC within the same
as all releases always the same
iteration or if you got set of ABC
within the same JVM run you always get
the same as you always get the same
order but from in the next run yet
different orders this is done by pulling
basically a random number and then when
you get when the set off gets the couple
of elements it just reorders them when
it writes them into the fields I think
that's a really cool thing to do record
streams you might have heard about that
that Java 9 goes are reactive it does so
but on a very slow-moving basis as is
not uncommon for Java to go the
defensive front and be sure that things
are well thought through before you
create a public API so the idea was not
to create a JDK create a JDK API they
actually does uses reactive streams but
just to provide a common ground for
other libraries that do that so they can
implement the same interfaces and then
maybe you have more interaction between
different libraries we use a directive
stream so it's done this pops up thing
before very few people okay so the idea
is imagine you're doing something that
takes time like you asking the github
API for a couple of projects you're
waiting to get the JSON back so if you
do this now you maybe want to make a
request and then you get back the whole
answer at once and then you process it
but if you want to use something like
like reactive streams you maybe you want
to make individual calls and then
whenever some call comes back you
process it and do something with it or
say you want to go over the filesystem
list
scan every file for some content
well the scanning most likely takes more
time than the going of the going over
the file system but the point would be
you could maybe tell the file system to
give me all the content in that
directory and will not wait until
everything is decided upon and then give
you back a list but it could give you
back a wreck the stream and whenever it
finds a new item in the directory just
push it through the stream and then you
can do whatever you want so there are
these three things involved a publisher
which in my example of scanning the file
would be the file system scanner it's
the publisher publishes new events or
new new items it can be subscribe to buy
a subscriber a subscriber does something
with those elements it has these three
interesting method it says on next so
the publisher calls on next when
something comes it calls on error when
something broke and calls on compete
when it's done and the link between the
two is managed by a subscription with
which with the subscriber can request
more elements or cancel so if you wanna
start subscribing this is what you
wanted what you would do you create a
publisher or you get a publisher maybe
from from the JDK you would create a
subscriber and then you call publisher
dot subscribe with your subscriber then
the publisher creates a subscription and
past's into the subscriber subscribers
takes at the description and stores it
because a subscription stores it because
it needs it later because from this
point on nothing happens the idea is
that if the subscriber is slow then the
publishers are not allowed to badger the
system with more and more data to make
the system overflow the idea is is that
you've pushed back that the subscriber
can say now I'm done give me the next
elements so from this point on first
nothing happens now the subscriber calls
requests in this case requests 10 items
says ok I'm down like whatever I
whatever I did to initialize I'm done
give me the first 10 items and then the
publisher ad will call our calls on next
a couple of times not more than 10 but
maybe less if no more elements are there
and this goes on and then maybe the
subscriber managed to process the whole
elements and then calls request later
again and then again or at some point it
just decides I'm done it calls cancel a
subscription or alternatively the
publisher may say I'm done there's an
error
I don't find anymore anyone sign on done
so then the subscription is cancelled
and both come on a separate ways some of
this is really nice but the basic point
is when I just said the file system I'd
do this and that it doesn't in Java 9
this API is not provided by any so it's
API not used by any API that you might
know you never get a publisher back from
any JDK API these are just the
interfaces there's one class are there
which implements public publisher and
subscriber but other than that there's
no there's no implementation in the JDK
it is meant for other libraries to build
on and maybe in Java 10 when there's
been it's clear which would be a good
common denominator then maybe the this
interface is getting evolved and then
what you can find them maybe in jdk api
which i think would make sense for a
couple of things for example HP
connections i forgot to ask the first
two times do you have questions
regarding collection factories or the
streams no yes
yes so the question was is the order
random or is it forced always it just
forced different than last have no it's
and that sends random if you call set
off and then a couple of elements then
the first time you do this one random
number is pulled the seed is created and
that could be the same as the last run
but that would of course be unlikely
stack walking let's before we go there
if you want to so there's some
applications that might want to have a
look at the stack they are there your
method gets called and the mathematic
ought from the different scenarios for
this you might want to find leaks for
example resource leaks with that there's
more time my framework smells almost off
medicinal interesting the best way to do
that now is basically to create a
throwable and tell the solver give me
the stack trace
that's an expensive operation because it
means that java is to basically stop the
world and you know evaluate the whole
stack trace and give you that and this
is cumbersome first of all it's not a
nice way to do it and it's also not very
fast so the stack walking api was
created to make that faster and easier
so this is a small chain main calls one
one calls to to cause three and three
does this it gets a stack watts walker
instance and then it just iterates over
it and prints stuff out so if we let
this if I run this I get this three gets
printed first because the stick is top
most element of the stack it's the last
method that got called and then the
method below that was the man at the
stack below that was the sort of the
frame below that was the method that
called three which is two three was to
us code by one so so I go you go this is
the stick you get out it's very simple
way to do this interesting is maybe you
don't want to get the whole stack this
is where you want to if you want to
improve your performance it's likely
that you just want to find maybe the
first element that has some properties
maybe you want to find the first frame
which is a method that does not belong
to your framework so you want to find
the first method that is customer code
they called you did don't call for each
you call walk what you get here is
so this is it's a little bit strange
walk does not return a stream I will
come to that in a moment
walk gives you a stream you have to put
something in that operates on a stream
so you take this stream which I called
frames and then you filter in this case
I look for a method name that contains
one I take the first element and then I
map that to the line number or if this
didn't work out because fine first
returns optional I or else some unknown
line never so yeah and the result of all
this the result of this lambda
expression which took the stream and did
this small pipeline the result of that
is then returned by walk up here so this
this or this depending on whether I find
something will end up here and I get the
line 11 output so this is besides that I
get past the stream and I have to do
something with it beside that's a little
bit strange detail it's just regularly
you get a stream of things and then you
do something to find the first element
so let me talk about why you put in the
you why you really can't just return the
stream the point is basically you have
to this API is to fight different
optimizations at the JVM is allowed to
do because the JVM is allowed to
reorganize the frame under the call
stack whenever it wants to win to
improve performance so if you want to
get a stream back which is evaluated
lazily that's kind of the trick here
that you get that you don't get the
whole stack trace at once but just the
element that you actually want to look
at if you get it back and you want to
evaluate it lazily
then it has to be stable but if the
stream is actually returned then this
method is done this walk method is done
and there's nothing special at the JVM
can do from that moment on you return
the stream it's just any Java code
that's running so the JVM would
reorganize the stream under the stack
and you would get strange results when
operating on the stream so what you what
it does instead is this walk method does
some fancy native stuff which basically
keeps the JVM from organized if you
organizing the stack frames so as long
as you below this walk method as long as
you below there you can do stuff with
frames so if you were to return the
stream for example if you just say haha
I'm clever I just put in the identity
function here I get back the stream
outside and then I do something
with a stream you'll get invalid state
exception so you have to operate on it
in here there are a couple of options
you can take reflective frames are not
in there by default lambda frames are
not in there by default when you call
the get instance method you can just put
in these options and then you get
something if you wanna get the class
reference we'll see that in a moment
then you put in this one so what
information you get out of that for each
and walk both give you stack frames and
sectors have these information the class
and the method name you can get if you
put in this option the class has
actually class instance and PI tech byte
code index if you want to deal with that
so these are these are the things that
are easily available but when you did
create a stack trace the old way you
will also create file name and live
numbers and this are apparently
expensive operations you would force
this expensive operation every time even
though chances are you don't need it so
now you get a stack frame which offers
you the file name as well and as soon as
you call get file name on the stack
frame it internally resolves the stack
trace element and then gets the name
from there so doing that is expensive
how expensive just a small very small
performance comparison this is the old
way just create a throwable and look at
it at the exception stack trace and this
is if you take the for each method and
they go through all the whole stack
basically create all the stack frames
because I saw all the stack trace
elements because we go through it we
call get name get fie name on every
single one of them so all the stack
frames has to be create have to be
created and it makes sense that if it
happens lazily and within a stream then
when you do it essentially the same
thing as before but with more fancy
stuff around it takes a while longer so
if you just do the same thing as before
get the whole stack and look at all the
trace elements you end up worse than
before chances are you don't need to
just trace elements though so if you do
just go through let's say what what have
you available here let's say just go to
the to the method name then you end up
in let's say about half the time and it
doesn't make a difference whether you
actually want to retain that class
instance well if you want to get the
class instance it's just an
accessibility check nothing to do with
performance so what happens if you don't
want to
go through the whole stream because then
it's lazy kind of was also a feature and
that pays off to a little bit a couple
of tricks to end up with this exactly
but the point is if you do those tricks
then you'll see that each new getting
each new stack frame it's a little bit
of over hat so if you know I just you
know if you were in a deep stack because
Java occasionally has these if you're
having a deep stack and just want to go
up like five methods then you would end
up way cheaper than if you would have to
in the old way which evaluates the whole
stack fifteen hundred methods um and
then you you know you just used the
first five you just really used the
first five and the other one never get
evaluated the other ones so the
secretaries elements are indeed
expensive and the lazy evaluation pays
off if you just look at a part of it and
what I just told you I didn't look I
didn't do the research myself I don't
water I was just uh author at sigh point
he's an article coming out soon and he
will look at that India and they're like
just stole the slides from him questions
about stick walking I tend to skip the
OS processes because there are a couple
of things that I want to show that I'm
warm that I think are more interesting I
want to skip this slide which tells you
about a lot of other features that are
in there that I don't have time to touch
on right now so JVM features let's do
their motor release jars this is really
interesting I think so maybe you have
the situation sometimes that you want to
do something on some Java version and
something else on a different Java
version and at the moment this is kind
of cumbersome you maybe use reflection
to find out whether some class is there
that you know how to identify what what
what API is available and then you you
know you have to make sure that these
branches don't accidentally come back
and you call something that's not
supposed to be there Java 8 which is to
call it so that's only generate what you
call in the code that was supposed to
only runs on a seven so if you have this
scenarios the motor restarts are really
going to save you a lot of work because
that makes it really easy so let's say
have a main class which just creates a
version and Colts get on it so it could
be any class here of course I decide to
commit version and then I have two
implementations of version
and this is really troublesome because
getting the IDE to accept this I didn't
I didn't make it actually I just to
compile in the command-line then because
of course if you have two files with the
same class in there you get compilers if
it's in the same package at least so but
if you end up if you do this if IDs
eventually understand this feature so
you have a feature you have one branch
where you put in the version that
supposed to run Java 8 another branch
where you put in the version that's
supposed to run Java 9 so if there's two
versions of the same class then what
then you'll just compile this to you
make one with main and then the eighth
version in two out Java 8 maybe and the
other one in two out Java 9 and
eventually the IDE so built-ins will do
that for you of course and then you use
this new release flag on jar which is
really nice so if you're not used to it
this is the normal way to create a jar
up here I call the jar command I say
create a file by the way this is what I
want to file to be called
everything in the Java 8 folder put that
into all the classes that are in there
put that into the jar but now I can say
and release 9 so for the 9 release also
take these classes that are in here so
the jar command takes both classes from
the java 8 in Java 9 folder and looks
like this in the end if you look into
jar you get this part up here sort of
just the regular jar and then down here
you get this in the meta info on I get
this strange path you have versions
folder you get a 9 folder because you
said release 9 and then it's like
similar similar class path sorry similar
class file folder structure like here we
end up with the classes down here and
the cool thing about this is even though
Java 7 and 8 don't know about my to
release jars they don't have to
so this jar would work perfectly on Java
8 because it just looks here so that
part works and then later on Java 9 if
you run on Java 9 Java 9 knows about
this feature it looks into here and
there you go it runs the other code so
indeed if you run this on Java 8 you get
the Java 8 output in Java 9 you get to
Java line output which is kind of neat
that's not so terribly interesting more
things that changed version strings if
you call Java - I should call the
version with in Java the version system
property you get something back that
starts with a nine actually not a normal
one dot something the command-line
parameters trantric new style not all of
them not numbered none were actually
changed but there were new eternities so
you can use - - class - path for example
which makes more sense and a couple of
other things but the last thing I want
to touch on is performance because there
are two quite interesting improvements
they we have time to touch on that -
sorry to discuss the first one at least
strings use gyrus internally right so if
you have a string internally you have a
char in and these char is make up a huge
chunk of any system that's running it
could be parsed XML JSON responses
whatever depending on system you run of
course they're extremes you have I'm
sure you have systems with like 2% and
other was 98% but by and large you end
up with like 20 to 30% of the whole heap
is occupied just by these charez but the
vast majority of of these strings
actually only ever use a lectin one so
they never use the second part of the
char off of the charts two bytes already
missed that so charge two bytes but you
most of them only use one byte so the
other byte like half of this is by and
large is thrown away it's just wasted
space so if we could just take the whole
char array thingy and just use the part
that we actually need we could reduce we
could have this 20 to 30% so we can end
up with 10 15 % less memory just by this
change and there's a great talk by
alexey shavelev where it goes into
detail about all the the pitfalls of
implementing this and it's actually fun
to vote what the titleist of the talk
what takes us them on subtitles what
takes those damn developers a year to
implement an easy feature let me not go
over it but the point is now we get a
byte array and if your string is letting
one string indeed it goes into the byte
array and it's safe half the space and
if you make a small benchmark like this
which alex is people have presented us
talk you get indeed like almost half the
garbage only that make sense right you
use on lofts
in this and this thing you only have
garbage there is strings and if you can
save almost half the space then end up
at almost half a heap space occupancy
there's another improvement but
performance improvement for string
concatenation which also improves
performance considerably and more things
about performance if you're interested
to learn more about this you can google
for the ultimate guide to Java 9 an
article I wrote a while back and has
links to two other articles so all in
all it's like 10,000 words it's like
this talk right it's just one thing
after another so maybe you wanna read it
in its in steps but they can see
although also the things I left out also
touched upon there and then talk a
little bit about it's already shot you
almost this slide my name is Nicola I
already said that look find me here I'm
blogging here and the editor for side
points Java channel you can look there
for interesting country but Java and you
will find me here on Twitter or if you
absolutely have to you can also find me
on Google+ maybe great that was that
thank you and do you have any further
questions yes I can repeat it it's no
problem okay how does the model system
play with OSGi that's actually I can't
really answer that because it looked in
the beginning like it would not work but
needle Bartlet world of OSGi FM wrote a
couple of posts about that and they seem
like some deep-seated technical
differences that might make this
complicated I would recommend to to
google that okay I think I have the
article here I can if you come up later
I can maybe show it to ya that's that's
all I can say but I think but also
there's also JBoss module system and by
and large these are supposed to be
compatible but I don't know it exactly
which degree
they're also some fundamental difference
between how our CI managers and and and
the motor system particularly when it
comes to requiring because noise GI you
supposed to require packages something
that always the model system does not do
at all more questions no thank you then</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>