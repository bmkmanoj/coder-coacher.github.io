<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Without Resilience, Nothing Else Matters by Jonas Bonér | Coder Coacher - Coaching Coders</title><meta content="Without Resilience, Nothing Else Matters by Jonas Bonér - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Without Resilience, Nothing Else Matters by Jonas Bonér</b></h2><h5 class="post__date">2015-11-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NjPVJ7ZKLnY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to this talk without Brazilians
nothing else matters so they see so how
many of you would like to go to
production with an application that is
like beautiful responsive scalable hila
concurrent scalable human resource
efficient loosely coupled you know yadda
yadda yadda yadda raise your hand I
guess yeah we we all do right but guess
what the problem is a nothing of that
matters not the slightest unless your
app is actually available unless is
actually up and can serve requests and
can fulfill its purpose right so really
without resilience nothing else matters
so I think I think it is really at the
core of everything we do and it's and I
think it's something that we have had
waived way too long as an industry in
this in this talk I'm going to try to
get down to the fundamentals of
resilience oops means look at somehow
like some examples how other in after
the fields like like like nature biology
social systems and so deal with
resilience and see how we can learn from
that and apply that to software systems
okay most of you probably recognize this
picture you know it's about is it's from
this movie Rocky and it's about this if
you don't know about the movie the
shorter plaudits about this andre dog if
they call him the Italian stallion he
gets a shot at the title and and some of
you might might remember this this this
this quote write it but it ain't how
hard you can get hit it's of how hard
you can get hit and keep moving forward
how hard how much you can take and still
keep moving forward that's how winning
is done and this is this is what I call
fault tolerance it's about getting hit
hopefully survive you limp along
hopefully enough that you will win
unfortunately rocky didn't do that
this in this in this movie and later
movies he actually took the title but
the problem is that fault tolerance is
not really a sustainable strategy is
rarely sexual very well illustrated in
this in this in this movies and and
because what I believe that we need is
is resilience and the resilience is
beyond fault tolerance I'm going to I'm
going to dive down and what resilience
really is what it really means why I
think is needed has I said how other
industries in fields of science are
dealing with it and what we can learn
from that so what what is resilience
according to merriam-webster is defined
as the ability of a substance arabic to
spring back into shape the capacity to
recover quickly from difficulties it's
really about to being able to restore
full functionality not just to limp
along like rocky and hope for the best
but actually like fully self feel and
come back to where you were before you
got it and they're so even a lot of sort
of discussions nowadays about anti Fred
Fred fragility that's actually beyond
the resilience being able to like grow
strong or when you when you when you get
hit I'm not going to talk about that
here is I don't think it's asking Crete
and we are not really ready for that as
an industry yet we we're not even are
able to build truly resilient systems
yet so I'm going to focus on that here
today and in the software systems today
are incredibly complex and here here
here this is just a couple of diagrams
them in circulating around the internet
the last the last couple of months and I
really believe that since software
systems are so incredibly complex we
need to study resilience in complex
systems but what is complex and what is
and how is it different from complicated
some people including myself some time
ago actually confuse the two terms okay
so this is a complicated system
I just love this Kiev actually really
happy when I found when I found it
because it's a great illustration you
know of a complicated system because the
complicated system consists of many
small parts usually all different that
like with each one has a precise role in
the machinery and it's and they talked
together work you in some sort of
cohesive all and it's it's usually
possible however very hard but usually
possible to unfold understand a
complicated system if you really put let
me put put put put your mind to it a
complex system however is made out of
very many system like similarly
interacting parts with simple individual
rules that together lead to emergent
properties and in we were their
interactions and how they work together
produces a global coherent behavior it's
actually by definition impossible to
understand a complex system you cannot
only try to understand it by simplifying
it in breaking it down into the
individual components and individual
rules okay so this is an example of game
of life you see I mean in isolation is
very easy predictable even right but
when once you start putting things
together it even though it's extremely
simple it immediately starts to
beauteous starts to producing behavior
that's almost impossible to understand
and and it's very important to
understand that the complicated is not
equal to complex and and one of the most
fundamental wisdom is I allurement I got
when I did some research I sir I found
when I disappointed when I do research
for this this talk was from this paper
and this in this quote by Richard cook
where is that the complex systems they
run in degraded mode complex system
always run as broken systems hey in a
non-trivial complex system something is
always failing somewhere it's it's it is
a fact of life and if that drastically
changes the way we should approach the
problem as I'll try to
to outline throughout this talk and we
assume as we generally just make it
makes it worse a lot worse this quote is
from from this system stinking expert
Donella Meadows she writes about points
for human intervention with with in
complex systems and i quote
counterintuitive that's foresters word
to describe complex systems leverage
points are not intuitive meaning points
where we interact with the complex
system or if they are we usually as
humans and intuitively use them
backwards systematically worsening
whatever problem we are trying to solve
humans just makes it worse and I think
we really need good models to understand
complex systems and how failure happens
in complex systems okay what happens and
what we can do about it and we're all
this operating at the edge of failure
really I got this illustration this or
way of thinking and but this about the
psychological and human part of failure
from rich Felicia cook as well this he
did a great talk in written some papers
on this as well so this model that was
differentially actually defined by its
calling Rasmussen in 97 by the way richa
cook is an MD he's been doing richmond
studies and resilience systems in in in
in medical systems for 20 for 20 years
which is I think it's very interesting
to getting like an hour like in like a
different perspective on what on what
failure and and what resilience really
means so in this in this model we have
three different boundaries first we have
the economic failure boundary okay you
have to stay within this boundary else
you go out of business essentially then
we have the unacceptable workload
boundaries mean if you cross this
boundary then you fall asleep or you I
mean you're burned out or so I mean
people can't perform useful work if they
cross this boundary essentially it
happens you know battlefield situations
when I mean the rutland shipping wanted
0 at startups that people actually
literally fall asleep doing what they
what they're what they are about to do
and then we have the accident boundary
if you cross this boundary then you fail
for some definition of fail or failure
okay can be like that you can define
human different will know outages no one
dies
no business is lost or so and then you
have what is called an operating point
that moves within these boundaries and
is always moving constantly moving
around and if sorry yeah there's some
lag here that's why I'm looking back
sometimes if you cross the the accident
boundary that's where it wouldn't have a
failure that's what you have some sort
of outage okay and then we have three
different pressures the first pressure
is the natural pressure for economic
efficiency like management always wants
you like reduce costs they want to like
try to push the operating point way from
the failure economic failure boundary we
can't go out of business we and so on so
that's an S natural tendency to push it
away and there's also even by as humans
we have a natural tendency to push try
to push the this this point like away
from the unacceptable workload boundary
because we're lazy as nature we want to
go home them in with to our kids to do
something else right so so there's a
natural tendency to just start pushing
the operating point towards the accident
boundary and and then if we have an
outage then I mean then everyone panics
wow I wouldn't didn't expect that be
stark like him perhaps rerouting the
software and bringing in new tools by
turning on the bloody clustering no she
shouldn't do that and and and I mean new
policies training I don't know stuff
like that and that sir pushes the the
operating point away from from the
accident boundary again but then you
know life arrives I'll I've come back
right then it's sort of it and then
after a while we thought we forget about
it and these two like massive forces are
starting to push the operating point
again towards the accident get boundary
and then we have we have an outage and
then we repeat right so the question is
why don't we have failures all the time
you should expect this sort of drifting
to happen all the time it's because we
add usually intuitively what is called
an error margin it's a remor down
they will say we shouldn't we shouldn't
across this because it feels like then
we enter risky territory okay and this
error margin it is usually defined by
rules I keep the speed limits on the
road it can be like we shouldn't use
more resources than extra gentle are
more users and then why or like battling
you know victories are talking about
back pressure infuse and streaming you
know you define your boundaries and say
we shouldn't we should cross this
because that means that we're risking
failure essentially so so the question
is that if we if we then and have this
error margin and try to not cross it why
do we continue to have failure all the
time anyway and here's like the where
the interesting psychological effects up
and I think because we we know a lot
about the marginal boundary right
because we have defined it but we know
very little about the accident boundary
is very fuzzy ok so so it's not really
until we actually cross the accident
boundary that we know where it is and
then we take a note of that and and and
we take a step back right and to the
Mauer and like beyond the marginal
boundary and and and ho and hopeful and
hope for the best ok so so but you know
this constant push towards economic
efficiently like me means that we are
forced to or want to like constantly try
to cross the margin and and and and so
what we do usually do is we try to cross
this and then we come back and then we
try to cross again and then we come back
and after a while we've been crossing so
many times it feels like nothing really
bad really happened I mean it it might
be okay we have been operating this way
like in and out no for six months why
don't we just move the boundary done so
sorry I'm lived behind all the slides
here but so this is what happens so then
we just say okay we since we're
operating this way we should just move
the boundary and we sort of started
moving it closer and closer closer to
the real accident boundary that we don't
really know where it is until we have
failure and and we're and we're back
right and this is this is what it's
called flirting with a margin it's a
Diane von wrote about this when she
analyzed the
you know remember you remember the
Challenger accident to the rocket ship
that blew up this is actually exactly
what happened people people that were
like flirting with the margin and throw
the real sore a proper name for its
normalization of deviance if you wonder
if you want to look it up this is really
psychology I logical effect that happens
to us all the time and it's something I
think we need to be aware of and so
since software systems are so incredibly
complex and and and complex systems
always run it's broken systems yeah and
we are always operating right at the
edge of failure I think we need to learn
to embrace failure fully embrace it and
learn to design from failure from the
start find a better way of managing it
and I think that's the most fundamental
lesson in this dog that i'll try to to
to make a cross rather that is that
resilience is based by design truly
there's nothing that you can just bolt
on afterwards there's nothing you can
hand wave any longer it needs to be part
of the design from day one really I
believe I Ribery I believe that failure
is just it's a silly natural state in
the applications lifecycle I mean
they're calling them exceptions it's
like we do in Java and Scala c++ and
solution is actually wrong there's
nothing exceptional about failures it's
a natural state to the application
lifecycle and if you embrace to look at
it like that there's nothing scary about
it it's justice if you're the state
machine you have I mean you have like
start I mean we're suspend resume reboot
I'm and whatever it is stop and fail so
once you get into the failure scenario
you know exactly how to get out here get
out of there because this is already
expected so to speak this this photo I
think it's extremely powerful it's
actually photo is a photo from from a
former home in Christ Texas it was it
was designed to resist the flood waters
and it was one of the few houses that
survived Hurricane Ike in 2008 is really
the house it was really designed for
resilience from from day one so but in
this talk now which want to look at some
patterns strategies how to manage
failure and to really embrace it at its
core and we're going to start by looking
as how us how some other industries are
dealing with it like
fields of fields of science so a
biological systems I just love meerkats
and III learned this in two very
interesting story from from from a TED
talk actually by nicolas perrot
initially look it up if we're interested
he talked about complexity theory and
this story is about meerkats and and and
resilience in India in the animal
kingdom ok so the meerkats they are
apart from this were being pretty funny
and cute there are extremely social
animals a very rich social behaviors and
one thing is for example is that oh so
it's the only the dominant couple in the
group that is allowed to get babies all
the other ones should be servants like
babysitters look after the kids while
they what the parents have fun I guess
some sprite quite nice and and and and
in this experiment GPS sort of tractors
were put on the only Sony's meerkats and
they were absurd moving from one feeding
place to another and there was the road
in between these between these feeding
places that they had to cross the
interesting thing about that it was the
dominant female that led the group to
the road once you once she reached the
road she stopped and she gave way to the
subordinates and let them try to cross
the road to see if it was safe like if
they got hit by truck or something I
mean apparently wasn't safe but but she
could remain safe and wait until the
right moment and then cross the road and
and and it the interesting thing is that
nature has sort of developed this this
way of dealing with failure and
resilience for thousands of years you
know the dominant female is extremely
important to the group if she dies the
whole group is really at risk and and
and and and this this this way if
they're giving giving way delegating
dangerous work to subordinates is
something that that I think we can learn
a lot from in one building computer
systems as well so i'll get i'll get
back to that later and and and and also
as Nicolas peroni sums up in this in his
TED talk nature actually use complexity
as a strength
right in here he said and I quote in
three words in the animal kingdom
simplicity leads to complexity which
leads to resilience so I think the
embracing complexity in the right way I
think a really can help improving
resilience another example that I have
is from resilience in insolence in
social systems we as any individuals
will live like this all the time right
we don't think about this is how the
horror societies be just built up that
Frasier each individual I mean you can
categorize it that they have like there
are six ways we can die okay we get that
for be too hot to cold from hunger or
from thirst or from illness or injury
and there are like three sets categories
of essential services that protects us
from dying essentially shelter like the
protects us from being too hot and too
cold we have supply for staff resources
that's for hunger and thirst and then we
have safety that's that's against
illness and injury and and these
services are then later laid out in
different layers to protect us from
dying so we have sir you can probably
find more but in this paper they
categorize several layers of
infrastructure layers of protection that
protects us individuals from dying
essentially by providing these these
these services and these are these are
like starting from the top where the
world like then we have like Marquez
energy markets food fuel markets the
country every I just have stuff like the
military I mean readin regional we have
the police the protects us you know we
have in the city web sting like
hospitals water plants neighborhood says
it's getting in lot closer to the
individual where food things are food
shops and stuff and in the home we have
a heating web like a house usually
toilet tap water the frigerators and
stuff and then all the way down into to
the individual with all of this without
all of this we will easily suffer from
death from from one of these injury from
one of these serve ways to die and this
is really how the world works so we are
the sort of these layers layers of
Defense right protecting us as
individuals we don't think
shibari Bisek is actually great model I
think that we should think about when we
design software now get back to that
later as well when I talk about what i
call the onion onion layer resilience or
all in later fair fault tolerance so in
general what can we learn from from
brazilians in biological and social
systems but by the way all these stuff
I'm talking about here are from papers
that are referenced by at the end of the
talk I'm going to publish the talks
online if you want it like dive into
more of the details we want to I mean
just check the facts so the first one is
that we can see across both of these is
that they usually feature diversity and
redundancy I mean generally component
systems with lot of components have have
a lot higher chance of surviving because
it means that that the trail components
can be compensated by healthy components
what way way more way more easily right
to the Gibson insurance effect don't put
all the eggs in the same basket as
people say these these these systems are
also extremely interconnected in the
insulin is earning some nectar network
structure extremely rich where we have a
wide distribution across all scales and
they also have the capacity to self
adapt perhaps hard to write systems like
that emit to some extent we can do a fee
feedback control control systems and so
on and they have an ability to
self-organize 222 like to take hits and
then learn from that and move on
stronger so this brings us to your
resilience in computer in computer
systems unfortunately we often react
like this you know first not at all and
then with complete panic and and I
really think that we need to
fundamentally change the way we think as
I have already said failure is innovated
in readable is natural there's nothing
exceptional let's embrace it and try to
find a way to manage it instead you
might have heard about the let it crash
philosophy you know where like something
that serve it was popularized for Erlang
and also that we use in ARCA
actor model for the job food before the
jvm and so on and it's really it's
really that's our philosophy is based on
essentially two pieces right they're all
defined very well by these papers by can
they are for the first papers call that
they call is called crash only software
is very simple idea is that stop is
crashed safely and start is just recover
fast if you look at the world like this
then you can always fail and get back on
on track right away okay it's it's it
can help you with I mean usually I mean
a lot of a lot of problems lead to like
sort of state being corrupted and stuff
like that and and that can definitely
help with this it's early so it's sort
of a sledgehammer now i'ma kill the
whole thing and reboot but it's a very
useful one but but in in in a follow-up
paper these guys foxing can they are
they they they talk about applying this
idea recursively the papers will recur
Sri storability turning the crashing on
the sledge hammer into a scalpel and and
I that's really what it is it's like
looking at the world like if you built
the system ground up with crash all the
components that can fail recursively up
then then you have a system that has the
ability to really really gracefully
tolerate failure at many different
levels all the way up and another
interesting paper that I that I love is
one called out of the tar pit by mostly
and marks and and here they they define
they have a good way I think a good way
of categorizing state you know most
failures usually are related to state
some sort of state like we have a
consistent state partial partial data
wrong data the law stated application of
data it's usually something related to
date a stateless services are a lot more
pure stateless services I mean not not
not like the the faking say closer is
like we have a stateless component and
then talks to a sequel database that's
not stateless really that's just a
misuse of the word in my opinion anyway
so they classify state s into s in two
categories we have input data that's
really the critical data the data that
just simply cannot lose that's data that
the customers gave to us hard to go and
ask them again can you I please fill in
the form again we lost it alright and
then we have derived data this data is
derived from the input data that that
stuff that's recompute abul and that's
okay to lose I usually have a third
category that is called ethical scratch
data it can be data get data that you're
made up that you make up that you that
if you lose doesn't make much sense but
that you use right during computations
that that's like data that is meant to
be thrown away you know you know when
you when you're a school you redo some
calculations you know you know and in
your like in there like back of the
napkin and then the result matters but
not the actual way you got there really
so now let's look at I'm a traditional
state management how a lot of I mean
most systems today I think unfortunately
are written the legend here is that we
have this or the the the white circle
here is a client and then we have the
blue one is an object in the system and
this this squared red red square is a
it's like a critical state that needs
protection state that we just simply
cannot lose or we will look really bad
in the eyes of the customer okay and and
now we have like a lot of this
interconnected albeit objects you know
in some in some in some in some system
and let's say now that a client comes up
and he makes a request by the way this
dark the line here that's the thread
boundary as well it's also very
important because that I will come back
to why it's important but i can give you
hint isolation in isolation of failure
that's where threads thread the thread
boundaries is ISM is important okay so
usually what's happening here is if the
client then does it so I'm getting ahead
of myself sorry well anyway I spoiled
the whole animation sorry
anyway my what I was going to say that
if you have the dis synchronous dispatch
down and if failure happens at the
bottom if a synchronous dispatch and you
have one thread boundary all the way
down I mean you're going to blow the
whole stack all the right up in the face
of the user then that's not a good place
to be first I mean you take in doubt you
have this like cascading failure taking
down lot more components then then then
then necessary I mean if you have
synchronous RPC you know at a
distributed systems like most systems
are today can actually start taking down
multiple machines seen that happen way
too many times the problem you know is
that so so how should the client react
to this that's hard I really believe
that this whole model is like actually
broken I'm sorry to say but I really
think it is the problem is that you know
this is the family manage management
with that we grown up with in Java C++
and and you know JavaScript and so and
the problem is that we're giving in one
single thread of control that we need to
do all the work in and and and and if
that serve context blows up let me screw
it because that's all we all we gott and
these these so-called exceptions you
know they they they don't they're not
remit through messages that regular
weekly actually can redirect wherever
they can just go one way and that is
across your call chain and and and and
this means that since this context it's
the only thing we have we have we need
to protect that with our life that's why
we need to go around and add try-catch
statements everywhere in the code
because things can go wrong almost
everywhere so they're like red boxes all
over and this means that I mean our nice
business lawyers get completely tangle
with error handling all over the place
and it's hard really hard to make sense
of it and it's also extremely brittle
and I think structure here can give can
give us some sanity back really and as
Sidney Decker said I'm an accident they
come from relationships usually not
broken parts so the relationships need
to be loosely coupled they want me to be
broken up or you will take down the
whole your whole application in my in my
view the requirements for saying failure
model is that failure is the first
gained not leak without you you wanted
to write they need to be reified as
messages might be certain material
wrapped up as messages regular messages
they need to be sitting signaled in an
asynchronous fashion because if if you
if you can signal them in an
asynchronous fashion that means you can
do that safely and and they need to be
able to be observed not not just signal
randomly and I like you need to be
someone there to actually observe the
failure and and and and they need to be
able to be managed outside and if you
have failures as messages in a
synchronous boundary between these that
means that healthy component can just
sit there and just watch what happens
get the failure message and act that
doesn't that's not the case right if you
have like these cascading things like
then this panic panic panic panic death
so sorry about that so first we need to
we need to find a way to contain the
failure and once again right this here
we can like learn from the from other
industries you know the ship
construction in ship construction they
they've used this for a long time they
called about the bulkhead Pat early or
they call bulk heading you know it's
about the key here it's like
compartmentalization like have save
compartments as you can see here you
have this ship and you have set your
like your compartments that means that
if if you're like if you get a failure
if you get a get a hole or you hit the
nice but like rips up three four of
these the ship remains still healthy it
can just continue to sail because the
because you have like boxed it okay and
when I saw bulk edit it right and and
and I people always bring up yet awarded
by board about the Titanic this doesn't
work you know Titanic actually did
everything almost right but they did not
all the way because in that in that in
the Titanic these walls didn't go all
the way up to 2 to the ceiling so when
enough compartments were ripped up is
started to tip and then water starting
to move flood over 21
21 healthy compartment than to the next
to the next to the next to the next to
the whole ship sank it's actually an
excellent example of cascading failures
don't do that isolation need to be rock
solid okay and but I think so this way
of achieving fault tolerance is good but
yet again fault tolerance is not where
we want to be we want to build resilient
application so i think we can do better
than this actually we don't want to
continue sailing with like this three
open compartments right we need to fix
them heal them as well and in order to
do that we need to we need to add add a
way for like some famous to be notified
from a healthy context this is what i
call supervision okay so they against
failures need to be contained as we've
all seen you'll need to be signal
observe and managed by healthy component
and and and this supervisor then should
have sort of them the power to fully
manage the failed component restoring
resuming restarting if needed to restore
full functionality and full service the
true definition of resilience if you're
if you remember so i'll try to explain
what this means through through an
example here of a bit of a vending
machine okay you might have seen this
ever give I've given this example before
so let's say you had this vending
machine the coffee machine in this case
we have a program is really eager for
coffee he walks up to this vending
machine he inserts let's say for example
at this this vending machine accepts two
coins to you and to yours is too much to
sense is too little I don't know true
swedish kronor and the cut and the guy
puts in one okay and he puts yeah given
my coffee I'm dying here and and then
then then really was what should happen
would you feel happens is that did this
did he gets it notifications it please
add more coins you haven't fulfilled
your part of the contract here the cost
to you just gave me one ok and ok then
he one and here one more any hand
he gets his coffee a nice and is happy
ok this is what we expect then the next
day he comes in the insert two coins and
now he gets an out of coffee beans error
thrown in his face like there's no more
beans where should I find the beans
right it's behind the coffee machine
should I go and open up some some I
don't know some story somewhere no I
mean this is not how it works it's not
the program is responsibility to deal
with air with a failure of the machine
right he should just happy it's just a
consumer so what's going to happen I
don't know exactly if it is what is
happening but and in an ideal world what
should happen is that this this failure
should go to some sort of service guy
like runs around the floors and fixes
these machines right to the beeper or
something like that and he can come in
are just enough we need to pour up some
work summer cough you were fixed you
know the the grinder if it's jammed or
something like that so in this case he
has more beans and the programmer gets
his coffee that's that's that's an ideal
world I really think this is why we
should design software and my point here
is that you know when you have the
protocol with it with it with it with
the user if the user is not fulfilling
his part of the protocol that you have
defined then he should expect to get to
get the validation error thrown in his
face right because that he can do first
do something with he can understand he
can fix it and he can continue right but
an application failure that's happening
down some third party services down the
database I don't know it's the disk is
full I don't know what it is right
that's not the clients responsibility
and that should not be thrown in his
face that's madness right what should he
do with that that should go to the
component that sits and watches did the
the other one and so this this this this
this service it's usually the component
that created the service if he created
the better knows why right and and and
he might just split up the service in
multiple components right and here you
join on the only afterwards or something
I don't know but it is the the component
that created this service that's
responsible for dealing with a failure
of it and once again this needs to be
built in from day one it's a natural
state in the applications life here in
this service lifecycle failure is
natural should be part of the protocol
between the creator and the service so
also in this
in this source or of out of the torpid
paper which is they have a lot of great
ideas here they define what they call an
ideal system okay you might if you could
argue about that but they have some
interesting ideas here anyway so they
they talk about essential state
essential state is the foundation of the
system it's completely self-contained it
doesn't depend on anything this is it's
just so the box will be put the critical
state of course has some sort of
protocol to interact with it but and
then we have what they or they then they
describe that the next layer is what
they call the essential logic this is
where the heart of the system and that
depends on essential state not the other
way around so there's an important
dependency graph here this is usually
what we call the business logic right
and and and and then we have what they
call accidental state and control this
is the least important part of the
system right this is this where this is
where data comes in you might imagine
perhaps do some computation using
scratch data and so on passing it into
the central logic but the really
important thing is it is the dependency
graph here and and and sorry well I
think what this describes is what I call
on in layers state management it's also
called the error colonel pattern and is
the idea is that instead of having this
statement of scatter across the whole
application we put it into the inner
most center of this onion and then we
have each layer in the audience levels
like a level of Defense protecting us
from from from bad things happening so
so so and the input so the the key idea
is that it's that the error colonel
never ever performs a dangerous
operation himself he always delegates
that and that he can assume that you can
delegate delegate in multiple levels so
if if one of the outermost layers fails
that's fine right because the critical
state is still preserved and he can
continue didn't try to delegate it again
perhaps delegate it on another machine
or or or or another service to take over
or something like that but as soon as a
request hits the error colonel the
innermost
can accept we can assume it to be to be
healthy we can assume is to be to be
harmless so so to speak okay we can
always assume correctness so in an
audience a state management here what we
do is that we so we have you know we put
the critical state inside what we call
them the error kernel and then we have
sort of levels of defense as I said with
this with these components through
supervision so they are occurring the
creates a bunch of workers for him that
might create to you about your workers
for him for them and so on so we have
sort of delegation like this and now if
if if and also you know then one of the
most important ideas here is that each
one of these components run in his
inside its own thread thread thread
boundary so you can actually die without
anyone noticing which which which which
by itself is a bad thing right but that
means that he can live and die and be
restarted in full isolation and then if
you then add a way of signaling failure
you have you have you have a way of
managing that safely okay so now if your
client comes in and he makes a request
and and it goes all the way up to the
second layer and the signal layer fails
here I mean I mean his supervisor will
be notified that is through this red
error he could deal with that safely no
perhaps through restoring the component
and the component can continue their
request and serve the client in an idea
where the class shouldn't even know I
mean might take a little bit longer I
even if the service is down you might
new timeout and so on but a client
should ideally would not even know that
the failure happened it is not his
responsibility he shouldn't have to care
if he fooled in his if he fulfilled his
part of the contract in the first place
of course and if you remember the
meerkats this is exactly the lesson we
learned from the front america's
delegate dangerous work to subordinates
so you're so you are fine it's fine if
elders like ran out on the street and
gets gets hit by the road
sorry gets hit by a bite by a truck
right as long as you're fine and this is
also the way we learn the social systems
actually the world we live in is
actually already architected naturally
that you have these levels of defense
you know there might be you know I mean
sure I mean if if the I mean there are
situations of course we're not these
matters right if I mean if the whole
world is blown up in a nuclear war or
something like this but but but normally
they I mean these levels of layers of
protection makes sense and allows us to
stay healthy and not having to worry
much right so i have 20 minutes I am see
I i was planning going through a short
example but i probably let's see i was
going to hell just first just going to
show you what and I wasn't what an
actress but that strobe okay i might
have time for this actually actually
i'll ask you would you like me to like
be practical now and dive into some code
or and show you how this can be done in
the mean real code using in this in this
case by my top choices acha or do you
want me to continue to stay a bit more
high level and talk about how you need
how we should extend this mall
throughout an Indian distributed systems
and so on because I don't think we have
really the time to do both the deep deep
diving code and huh okay I can I can
what okay raise hand how many would like
to see me do some live coding for the
first time in years I'm so freaked out
so hopefully it would not snow so many
will raise their hands okay and how many
would like to me to cut to continue then
talking about us about half half okay
okay you decide code ok code crap anyway
i'll post a slice afterwards so i need
to mirror oh oh what's happening here
this is not what i had had planned
that's funny okay so let's say here that
we let's create a new file here then we
call the demo actually i'm going to show
you in scala in a Monsieur I'm gonna see
I'm going to first open it up i'm going
to show you example here you know in in
ARCA and first I can just explain lib it
would i would acha acha serve it the
toolkit runtime for for building actor
based systems distributed systems and
concurrent systems and the interesting
the reason why i'm going to use it now
as an example is that it has a built-in
failure mall that maps very well to what
what I just talked about shamelessly
stolen from her lying i mean we i owe a
lot to Joe Armstrong and his amazing
work there there are actual links at the
end of this of this talk talking about
that I really believe this is this is
this is the best way of dealing with
with with with failure management and an
actress can be like it's extremely
lightweight object it is in Arabic that
has the mailbox you can send a message
to it all messages and asynchronously
they end up on the mailbox and the actor
then takes and works off these cue one
by one so each actor is fully
thread-safe it's like it's island of of
strong consistence you can say in this
in this like sea of you know non
determinism your concurrency
distribution my messages fly around I
said enters the actor you can assume
correctness you can assume that it's a
safe world to live and breathe and and
and and operating and so let's now
sorry no I'm sorry I need to have first
first package right through package demo
and I need to have some imports so so
what I'm going to do now is I'm going to
illustrate this this this coffee machine
okay so let's let's let's start by by by
creating an actor here and a curates you
create an actor by by saying saying
extends actor and then it can have some
state I mean can have some valves
actually this is this is Scala code i
can say first i'm using scholar because
i'm most comfortable with little scholar
but it has a java topmost java api
that's on par with scala if you if you
want to use it from from java and
everything looks almost the same it's
like slight student exchange okay so
that this the state here is that it
keeps track of the number of the above
currently inserting the ins in inserted
coins that's what my session sir speaker
122 should give me coffee because the
price is too then then I also have to
have this like flag that says that do I
am i oughtta beans or not yes sir yes or
no and then I and then I keeping track
with my total number of coins okay so
i'll get i'll get i'll get back to this
but i also want to want to want to
create the my coffee merrier this is
sort of the what i call this sort of the
service guy that's the guy that creates
coffee machines Manish's them anaka
every time you create an actor you are
his supervisor by definition and you
manage his life cycle okay so what is
what this guy does is he a carrabba's
the factor method he creates a coffee
machine by bypassing in this class
giving it a name out here comes comes in
an address to this coffee machine called
in this case machine is called it has
type actor f and and to simplify it
doesn't make sense in the real world
just simplify this coffee manager is the
boys with the user interacts with and
forever request you guess for new coffee
or putting in coins or whatever you just
forwards them to this to this to the
machine essentially in the real world
that doesn't make sure you probably use
the machine directly but but bear bear
with me for some for simplicity here
okay and then we have an appt
that's your driver okay and and what I'm
sure I have some stuff that I'm setting
up here first and actor systems Oldman
call he would said like one actor is no
actor actor comes in systems they always
interact that's where the interesting
things happen so we have an accurate
system here and we create this coffee
machine manager that's our coffee
machine and then we have a customer a
customer in the real active systems is
usually student should be a also an
actor but in this case I'm using a
testing construct from article in box
that makes it easier to to interact
essentially faking that this customer is
an actress Witkin sender is in and
receive messages okay so in the first
test run here what I want to do here is
that I would like to be able to set put
two coins into the coffee machine one
wants them done that i want to say our
this election should be espresso and
then if you wait five seconds then to
get my burb beverage who needs to brew a
little while i guess and and then it's
simply assert that i got my espresso
okay but as you can see why i haven't
defined my my msgs reactor my protocol
because this is this is the protocol
with a customer okay so so what i'm
doing here now is that i define my
different coffee types then i'm in this
just essentially my protocol can i can
send Eckstein coins the nominal coins i
can say i want to have a selection of
you know latte or something like that
like also trigger another coffee beans
failure from the outside also for
simplicity so i can actually emulate to
fail failure and if everything's go well
I i get my beverage or the protocol says
that if i hadn't fulfilled my part of
the contract i'm getting not enough
coins error actually I do distinguish
mean errors that are you sir manage
manage like that the use of
responsibility and what I could fail yer
that's the applications responsibility
ok so now let's implement this protocol
in this in this coffee machine then so
the first thing I'm doing at that I that
I that I said whenever I receive this is
this color code it's like a little bit
more like more drafts which switch
statements essentially cool pattern
matching if you don't know that so in
this method receive i get if i receive a
coins
then I then I coins men message I get
the number of coins and I i increment
the number of a sort of course that's
why i said that my current session the
total number of coins that's in the
machine and I just print price print
that out and I also it's one more thing
as you see I need to do I need to I need
to make sure that I respond to the
selection method message as well right
because that's my protocol sorry my
protocol is to is twofold I first put in
the coins and then I'm pushing the
button for my coffee so in here what
what I'm doing is I simply first check
have I inserted enough coins if not then
I'm then i'm using lampshade this is
actually the way i'm sending a message
i'm i'm taking an actor ref it's an
address in this case it's a sender the
guy that sent me the message i can just
have direct access to his to his address
so i see sender tell I'm telling him
something and I'm telling you that you
didn't provide enough coins so I'm it's
not enough coins error is actually
thrown straight back to decline which
which i think is correct in this case is
because he hasn't fulfilled his part is
part of the contract vray if everything
goes well then I'm then I'm saying that
then I'm done brewing my coffee and I'm
sending my coffee back to the client
okay so now let's try to run this and
see see what see what happens so
everything went well I mean I mean I
mean certain Mike Mike Mike coins and
the number coin is totally in these 2
i'm brewing this press and I mean I'm
getting myself in espresso okay but now
let's let's do something more
interesting then let's let's say that
let's say that I'm inserting just one
coin here and then i say i want i want i
will I want lata okay in this case I
should really get to know coins error is
instead of a beverage as I've already
encoded in the in the in the coffee
machine let's see yeah it seems to work
I get myself an error please insert one
more one more coin so here I'm in a
failure secular throw straight in
decline no sir error so frustrating into
the clients face while failures should
not right so the interesting piece I
think here now is then now this
trigger a failure and see what what see
we'll see we'll see what happens as I've
already said all actors that are created
by other actors which is you have to or
like man like automatically supervised
and the default strategy is on a regular
exception they are restarted and restart
in the actor world means that the old
instance just thrown away a new instance
is created reinstated and handed out to
serve the service to serve the user okay
so what so what I want to do here that I
would like to I mean insert one one coin
I mean since you know I want hear that
i'm inserting my missing in my missing
coin and then I'm triggering it out of
coffee beans failure here so I'm running
out of coffee before I kidding i came
back i can i can brew and then i say i
want i want my latte and then i'm
waiting for my perform a beverage ok so
now let's see what i need to do first is
that i need to need to make sure that
that they respond to this to this
message see what i'm doing here i'm
simply said in the outer coffee beans 22
true and i'm also let's see i'm adding a
check oh sorry i'm adding a check here
that if i'm at a coffee beans i'm gonna
just go through a regular exception ok
so now if i run this you can see that
i'm the exception is thrown and the
client didn't get his coffee naturally
one one one thing that our half though
is I mean we didn't actually see the
things actually got got got restarted
but erica has has it has the way it has
a set of callbacks that that will be
called whenever they come whenever the
component is restarted so we have like
pre restart post restart pre-start
post-op and a lot of these things right
so in this case I'd like to for example
add a add a an implementation of this
post restart so on this new instance i'm
in this case I'm just this will be
invoked in the new instance in this case
I'm just I'm just printing out restart
the Machine and see that it's actually
happening you see here it's actually
it's actually restart is this is a fresh
new instance that it's ready to serve
however the problem is that my context
is lost you know the this new coffee
machine there's no idea who submitted
this order how many coins were there and
so on so what I need I need a way to
actually manage my context throughout
this failure scenario so so in the in
and you know the best way is doing as I
said Legree you should want to really
fight the full the full error that means
that that's the place I'd like
personally like like to put the context
there are many ways you can do it but
but what I would like to do then is
actually define and say I don't know
what happened now I'm debugging I wonder
that I want to actually define a
semantically interesting failure instead
in serious throw throw exception here
i'm saying i'm adding a shilling out of
coffee beans failure there that extends
exception where I'm where I'm putting in
my my current customer I'm also putting
in my pending order here and also the
number of coins he has he has in circus
and nothing should be lost so with the
important thing here now is of course I
need to make sure that I captured this
here instead of throwing an exception so
here is he I'm capturing the current
sender of the message that's a guy that
is currently trying to get his coffee
his selection and the number of it sir
of inserting coins and and what I also
need to do now as I said oltman the all
supervisors are now or by sir without
you having to do anything they supervise
the component but but in order I mean
old old serious actor systems should
actually make sure that they take full
advantage of the of the idea that that
failures are just regular messages they
should be encoded that's rich they have
rich semantics right you didn't just
throw errors exceptions around you're
really no idea what's happening but you
should really encode the failure in the
supervisor tree can act accordingly to
this specific failure so so you do that
by by by overriding the supervisor
strategy and I'm not going to go through
I mean there is some configuration here
extreme acts number retry
within time range and stuff like that
but the important thing here this guy
now response specifically to this out of
coffee beans failure here I'm just I'm
just printing it out and reached and
restarting him but but this is also not
not not sufficient right because because
I need a way to get a hold of that
context in the post restart so I need a
way to like grab the context to
reinstate that on the new instance and
if you remember correctly I had I had
this I had this versus this post restart
method and i'm currently not doing
anything with it but if we if we say
that we do that here now is that you see
because i'm actually getting past the
actual failure here right into that
methods i know what's going on i know
what happened on wisely things failed i
can also get a hold of the actual
context here so if it was an outer
coffee beans failure here i can do here
again pattern matching actually get
actually grab the current customer that
that was trying to get his coffee his
pending order and his coins and and i
can reinstate those here and in here is
also funky thing is pretty nice innaka
you can actually read you can actually
send things to yourself using the the
the the self reference so here i'm i'm
actually it's resubmitting the pending
order to myself and with the customer as
a sender so I can sort of fake that I'm
getting the the even though I'm sending
myself the message i am the sender i can
actually put in the customer address
here as the sender and and therefore he
should be when he when he does reply he
will just replied direct back to the
original customer so if I done
everything correctly here now then and
we remember should see we shouldn't just
get a get and get a failure and began
the client hanging there but you can see
when when I'm actually restarting it
here I make sure to resubmit my pending
order and stop him a lot and the
customer actually guess is larger even
though the whole machine failed and
completely new one was reinstated the
client didn't even notice right and this
is this is where that the power of full
isolation having failures refi this
message is being notified outside in a
safe context right as healthy that can
manage
the failure and and then the very cool
thing I don't have much time time left I
was going to like take this now to the
distributed world in just a few slides
but the back and just say that the
interesting thing at this model just
works exactly the same across machines
with exact same semantics since
everything is messages add messages are
there a synchronous asynchronous listen
the only thing that will change is the
latency or getting messages across
machines instead of across course so
here you really have if you really
embrace this way of thinking this way of
designing your systems if everybody
believed that you have you have a model
that actually works very well across all
deployments I mean starting on a single
core system admins growing it country
moulton machines multiple data centers
the failure model and the way of
thinking about failure yes it is the
same so I'm just going to go back to my
slides I'm stepsister I'm just going to
jump forward a little bit here so in
summary here we've we've covered a lot
of a lot of things but one of the most
important lesson series like complex
systems like I think most of you
probably are writing always run is
broken systems they always running
degraded mode to quote Richard cook and
I really believe that resilience is
truly by design we just can't hand wave
it any longer Trent learn bring in
additional stuff to solve it right we
build our system and then we just add
stuff turn on clustering I don't know in
weblogic server or a tomcat or like you
know add things no we need to start like
truly simplify and be true to what's
really going on and be true have a model
that actually works from small to large
essentially and I really believe that
without resilience nothing else matters
that's where it starts and ends okay so
thank you those everything I had
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>