<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Modular Development with JDK 9 by Alex Buckley | Coder Coacher - Coaching Coders</title><meta content="Modular Development with JDK 9 by Alex Buckley - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Modular Development with JDK 9 by Alex Buckley</b></h2><h5 class="post__date">2017-11-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/HLPPXlhPzHE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay hi everyone I think we should get
started thank you all for coming
my name is Alex Buckley I work in the
Java platform group at Oracle this is
modular development with JDK 9 JDK 9 is
here and there's a lot in it some of the
features are performance improvements
such as compact strings some our tooling
improvements like the search box in Java
doc and the new J shell tool quick show
of hands who's tried J shell a lot of
hands right answer other features are
updates to existing features such as
support for Unicode 8 but the main
feature and the one that's taken many
years to come to fruition is the module
system the module system is a big deal
because it enables modular development
all the way down the java language and
the java virtual machine understand
modules very deeply so that the
applications you write and the libraries
you consume and even the jdk itself can
all be developed and tested and packaged
and deployed as modules with clear api's
and well protected internals making
everyone play by the same modular rules
has great benefits for reliability
maintainability and security as we'll
see in the rest of this talk so with the
theme of modules all the way down in
mind this talk has three parts the first
part explains how modules are a
long-overdue building block in the
structure of application code the second
part is about how applications and the
libraries they depend on can migrate to
modules more broadly it's about how you
can mix modular code and non modular
code and the third part is about the
structure of the modular JDK including
some of the compatibility issues that
arise from it
so programming in the large an
object-oriented programming the basic
unit of reuse is traditionally the class
Java has wonderful mechanisms for
promoting reuse of a class inheritance
for reusing behavior interfaces for
reusing abstractions separate
compilation dynamic linking and access
control all the way down to the level of
individual fields and methods and we've
had nested classes since 1997 so it
should be possible setting up a little
straw man should be possible for a
single top-level class to encapsulate a
vast amount of functionality and so it
seems that an application could be a
single package containing a few very
rich classes all sharing data via fields
and methods accessible within the
package and where a handful of public
classes form the entry points or the API
of the application right not really
how many people work on a code base that
consists of one package no hands right
answer two packages three five how many
people work on a code base just within
your company that's about ten packages
20 now okay finally got the ducky you're
awake good again there are some hands on
the order of 50 packages Wow a hundred
we're going to break the record the
record is 400 order of 200 packages if
you know it's actually quite impressive
if you even know the number Wow
more than 200 packages that's actually
terrifying so the point that has been
extremely well made thank you very much
is that no one no one's application
consists of just a handful of packages
anymore even the smallest micro service
wouldn't be expected to fit into a
single package programs are packages not
classes
unfortunately the Java language kind of
gives up once your program is bigger
than a package just imagine how
difficult it is to control reuse within
a large code base like the 217 official
packages in JDK 8 the only way to share
code between packages is with the public
modifier but then the code is shared
with everyone it's not surprising the
packaged friendship in one form or
another has been requested many times
over the years a package in other words
is a great way to organize classes but
most people wish there was a way to
organize packages to modules let you do
that a module is a set of packages
designed for reuse this is a
long-overdue building block in the java
language in effect modules record the
structure of your program so that the
packages you want to be reused can be
reused
while the packages you don't want to be
reused can't be reused a program built
of modules will be more reliable than a
program built from a loose set of
packages in jar files that can access
each other freely and that exposed to
many api's to the outside world with
public in other words in jetty k9
programs are modules here's a module
that everyone will soon be familiar with
Java base Java base is the foundation of
every Java program like java.lang object
is the root of every class in blue are
the packages of Java base intended for
use by code outside the module these are
its exported packages in red are the
packages internal to Java base they can
be used by code inside the module but
not by code outside the module these are
its concealed packages a module is
declared in a new kind of file called
module info Java that gives the name of
the module and its
sported packages and so by exporting the
java.lang package it means that the
public classes of java.lang are
accessible from outside this Java based
module a package that is not explicitly
exported such as comm some crypto
provider is concealed it's public
classes are not accessible outside Java
base this is the first feature of
modules in JDK 9 strong encapsulation a
module isn't really just a set of
packages it's a set of exported packages
and concealed packages the public
classes of exported packages are
accessible outside the module the public
classes of concealed packages are not
accessible outside the module this means
that access control is more powerful in
JDK 9 than in JDK 8 in jetty k9 you can
arrange for public classes to be
accessible to everyone
or accessible only to other classes in
the same module or accessible to classes
in the same module and a limited set of
friend modules so if you're looking at
PU BL IC on a class declaration it no
longer means that everyone can access
the class access depends on whether the
class's module exports the class's
package
since Java base is a module let's reuse
it with a module of our own here's a
class in the package comm example hello
let's declare a module for it hello dot
world at the bottom there's a module in
photo Java file and for sake of argument
let's export the comic sample hello
package with the exports directive now
you're probably wondering how the
HelloWorld module knows that it has a
package called from example hello after
all nothing in the package seems to
point to the HelloWorld module it's up
to tooling to decide during developments
which module each package belongs to in
practice
the IDE will take care of it you create
a modular java application you're asked
the name of the module and then every
package you creates will be part of that
module
if you run Java C by hand then Java C
figures out which module each package is
in that's why module in photo Java is at
the same level as the comm directory in
SRC the benefit of relying on tooling is
that it's really easy to place an
existing package in a module and
immediately give that package the
benefit of strong encapsulation
we don't want each and every class to
have to opt in to strong encapsulation
by declaring the module it belongs to
that would invite errors such as classes
in the same package attending to join
different modules that's a big no-no for
reasons I'll mention later one more
thing the say hello class imports the
java.lang package where is that package
imported from now you might say the
answer is obviously Java base because
you told me a minute ago that the Java
base module exports the java.lang
package you're right but in general how
does a compiler know that should it
search the file system looking for
modules which export the imported
package what if multiple modules export
the imported package if we intend to
reuse the Java base module we should
document that effect actually since
we're writing a module ourselves we must
document that fact
this is the second feature of modules in
jeddah canine reliable dependencies a
module isn't just a set of packages it's
a set of packages that reuses the
packages exported by other modules so
the HelloWorld module specifies that it
reuses the java base module with a
requires directive in module inferred
Java
this means that code in the HelloWorld
module can import any of the packages
exported by Java base
what happens if code in the hello world
module tries to import any of the
packages concealed by Java base such as
some security provider in red here's an
example of some code that did that
GlassFish 4.1 it at the time of slide
manufacture didn't run on jdk 9 because
the JVM throws an illegal access error
the error message is you can read it
because it's big class comm son
enterprise security provide a policy
wrapper in module a named module don't
worry about that cannot access class son
security provide a policy file in module
Java base now a glance at the open JDK
repository shows that the policy file
class is declared public in the Sun
security provider package but because
that package is not exported by Java
base policy file is only accessible from
code in Java base itself and to be clear
in jeddah k9 the GlassFish code cannot
access the public policy file class at
compile time or runtime it's exactly
like trying to access a package private
class from outside the package Java C
gives an error the VM throws an illegal
access error so sorry GlassFish you'll
need to find a supported API not a Sun
dot star API I'd like to return to the
module in photo Java file that declares
the HelloWorld module it's really
important to understand that a module
exports packages but requires modules
the reason is due to an old software
engineering principle the unit of reuse
is the unit of release this principle is
about separation of concerns you reuse
someone's code not by copy pasting it
into your own source tree but by
depending in some way on the black box
artifacts released by someone else now
in the Java ecosystem there's no
question that the unit of release is the
jar
that doesn't change with modules a jar
file hello Walter jar simply carries the
module info doc class file produced from
module in fertile Java alongside
ordinary class files we call this a
modular jar so when someone releases a
modular jar for the hello world module
its reused by someone else writing
requires hello world in their own module
in photo Java the reuse er benefits from
an explicit coherent API consisting of
precisely the exported packages the
releaser benefits from strong and
capsulation of conceal'd packages inside
the module which supports the API even
if there's high coupling inside a module
there's loose coupling between modules
and other good software engineering
principle okay so you're requiring Java
base from your HelloWorld module and
you've built a modular jar for your
HelloWorld module where do you put it
jdk nine looks for modules in the system
image and on the module path the system
image is in the JDK installation
directory
it contains Java base and a few dozen
core modules Java sequel java xml and so
on the module path is set on the command
line like the class path except that the
module path usually points to
directories
containing modular jars rather than to
the jars themselves so Java minus P mods
specifies that modular jars are to be
found in the mods directory and minus M
HelloWorld specifies the module to run
the key point about modules requiring
each other is that the module system can
check the requirements and validate that
a modular application is sound once the
compiler or runtime has found that
initial module - M hello world in the
system image
or on the module path the module system
performs then a process called
resolution resolution means inspecting
it requires directives and finding those
required modules in the system image or
on the module path then recursively
resolving them we're building a graph
whose nodes are modules and whose edges
are the requires relation and to be
clear in JDK 9 we do this at
compile-time and run-time if resolution
succeeds you get three guarantees first
nothing is missing every module that is
required is available ok pretty obvious
but a big improvement over the class
path where you won't discover missing
jars until later second modules don't
depend on each other in a cycle cyclic
dependencies lead to code that is hard
to maintain and we're taking the
opportunity to prohibit them in modules
from day one of JDK 9 now some of you
are thinking when you may be thinking
many things at this point but some of
you are thinking this is just dependency
management doesn't may even do this bear
in mind that maven only works at compile
time and the resolution process I'm
describing works at runtime as well but
more importantly resolution does
something that no build tool can do
because resolution has the exports
available as well as the requires in
particular resolution checks that if
code in one module imports a package
then the package is exported from
exactly one other module this means
there are no split packages a split
package is what happens when two jars on
the classpath contain the same package
and you load some classes from one jar
and other classes from the other jar
split packages are a huge failing of the
class path mechanism because they lead
to very difficult to debug scenarios
thanks to resolution where every package
is a fake releasing
sourced their impossible in a modular
application which is great for long-term
maintenance in fact this is really what
we mean by reliable dependencies the
dependencies in a graph of modules are
reliable when each module can access
only one version of a package at a time
the guarantee of no split packages is a
big deal for performance as well because
we know precisely which module exports
which package there's no need to scan
every module in the system image and on
the module path when trying to load a
class contrast that with how you load
classes from the class path here's the
class path for Hadoop the compiler or
runtime has to do a linear search
through 110 jar files whenever a new
class is needed now of course the
implementation can speed things up by
caching the classes it found when it
wasn't looking for them but they're
still that nasty half here half their
problem of packages split across
multiple jars in fact if you think about
it the class path is crazy with a
hundred and ten jars there are over
twelve thousand possible interactions
between classes in different jars each
one starting a linear search the class
path is the ultimate in airasia
whatever you know about the structure of
your application the class path throws
it away and connects everything to
everything else with modules you're
telling a resolution what you know about
the structure of your application and it
uses that information to provide both
safety and performance at compile-time
and run-time the prohibition of split
packages in modules has an impact on
application design as well one reason
that a package I should do a survey at
this point who here is aware in their
application of a package being split
across multiple jars a reasonable number
of hands not everyone but a significant
minority
so one reason that you might have done
that was to allow different parts of an
application to share package private
code while allowing those different
parts to evolve independently
now those jars cannot be turned into
modules because they would all be
exporting the same package however the
module system has a better way to
structure the application as a whole
than splitting a package let me set up
this scenario in a bit more detail
assume all of this takes place in a pre
JDK nine world on the left the
application has an API intended to be
globally accessible it's the public API
interface in package P the application
also has at the bottom some helper code
which creates or assists implementations
of the API without being accessible to
users of the application
it's the pedo helper package then on the
right the application has
implementations of the API the gain
intended to be not user accessible those
are classes x and y which live in
different jar files so in order for the
helper code and the implementations to
work together and share code they need
to be in the same package the
implementations are packaged private so
that user code can't access them a
helper class foo helper on the Left API
helper sorry is packaged private as well
it could be public but then it would be
accessible to users and again we don't
really want that
so with this setup while you're sort of
overloading a package there's a bunch of
problems for one thing you've got to
make sure that the implementations don't
tread on each other's toes there can't
be any class name overlaps between the
implementations since they all
contribute to the same package peter
helper despite living in different jar
files a second problem is that you
cannot make effective use of sub
packages
as the implementations grow larger it
would be natural for them to introduce
sub packages but sub packages cannot
access the package private code in the
Peter helper package so you need a
public class in that package to be a
backdoor for sub packages in the
implementations and then of course
anyone in the world could use that
backdoor as well a third problem is that
anyone can make a jar with classes in
this Peter helper package and start
using the helper code in the API jar or
start to rely on the details of the x
and y implementations in their jars so
like I said what's really going on here
when you have a split package is that
the the package being split pea dot
helper gets overloaded it started life
as a simple namespace for code that
helps the API but now it finds itself
being the unnatural home for all kinds
of things but what was the developer
meant to do in JDK 8 the only
structuring mechanisms were classes
interfaces and packages splitting the
package across jar files was seen as
acceptable but you can see that it has a
host of downsides in jeddah canine the
structuring mechanisms or classes
interfaces packages and modules modules
take the strain of encapsulation and
concealment
so that packages can focus solely on
being namespaces that are meaningful to
the developer so here's the same
application developed as modules let's
turn API jar into a modular jar file by
adding a module declaration the module
called API exports the package P with
the API interface to everyone and it
exports the helper package Pido helper
to its friend modules in pull one and
imple - now that ii exports directive is
called a qualified exports any module in
the world can say requires api to depend
on the API module and can access the
package P but only the friend modules
can access the
capito helper now I'm not showing the
module declarations for those friend
modules
imple one jar enable two jar they'll
obviously require the API module in
order to access the API interface that
they implement the friend modules won't
export anything and they can organize
their concealed packages and sub
packages as they wish now the pedo
helper package is not overloaded with
implementation classes from multiple
jars the naming of packages is much
clearer throughout all three jars and
more implementations can be added
smoothly without treading on and other
implementations toes in effect modules
make packages as cheap as classes and
then control the reuse of packages very
precisely so part one a module is a set
of packages designed for reuse modules
offer strong encapsulation and reliable
dependencies module aware tooling is a
big part of modular development let's
talk now about how to take an existing
application and migrate it to modules
since it's impossible to modularize
the java ecosystem all at once we're
going to be living with a combination of
modular code modular jars on the class
part on the module path and non modular
code traditional jars on the class path
for a while that's fine and JDK 9 can
help ease that migration that's what
this section is about so we'll start
with the simple application that we want
to migrate from the class path at heart
a typical Java application has three
layers at the top are your application
jars might be one or more of these at
the bottom is the JDK and in the middle
there's a bunch of library jars
downloaded from the internet and thrown
on the class path now
I've hinted that we've turned the JDK
into modules in this section green boxes
will represent modules you've already
seen the Java based module and you won't
be surprised to learn that there are
also modules for logging database access
an XML processing Java logging Java
sequel Java XML and so on but our
application isn't modularized nor any of
the libraries should we modularize our
application it's up to you you could
just run it on the class path like you
always did the class path that still
exists in JDK 9 the class path still
exists in JDK 9 some people think it's
going away hasn't but we modularized the
JDK for a reason to improve security
through strumming capsulation and
stability through reliable dependencies
applications might want to benefit from
this just like the JDK does so let's
look at how we might turn this
application into modules let's imagine
it's two jars with main code in my app
car and helper code in my lib dodge'
let's also imagine that the soup of
library jars is limited to Jackson the
JSON processing library Jackson comes as
three jars core data bind and
annotations and of course the green
modular JDK at the bottom this is how
we'd run the application today we've got
to set up the Lib directory to include
our application jars and now library
jars and point to class path out of them
then run using the java launcher one of
the things we gain by modularizing is
not having to list dependencies on the
command line or in a script so let's
look at one scenario for migrating this
application top down here we first
modular eyes our application jars
without modularizing the library jars in
general if you depend on third-party
libraries you are depending on them to
modularize a while we can make it easy
for such libraries to modularize
generally you have to wait for them to
do it and no one can force them so it
may well be that some of the libraries
you depend on are not modularized yet
that's okay now for the application jars
the
first thing to do is turn them
one-to-one into modular jars where each
jar file has a module module in photo
class file this is not always possible
especially if your jars have cyclic
dependencies but let's go with it for
now
if we're going to turn each application
jar into a modular jar we'll need to
write a module declaration in module in
photo Java recall that a module
declaration gives a name a list of
required modules and a list of exported
packages the names are easy my up in my
lib we don't yet know what each module
depends on we could make a manual
analysis of the source or the class
files but there's an easier way which is
the Jade EPS tool Jade EPS scans class
files or jar files and tells you what
code from other jar files they depend on
J debts actually came with JDK 8 and
there's an improved version in JDK 9 a
while it's not perfect it's a pretty
good start for figuring out what you
depend on so we'll run Jade EPS on the
application jars with the Jax and
libraries on the class path we see that
my app dot jar depends on two of the
jacks and jars which remember are not
modular eyes yet and of course on my lip
top jaw plus my app dot jar depends on
the JDK modules Java base and Java
sequel Jade EPS can tell that based on
the api's that my app is consuming my
Lib dot jar depends only on Java base so
that's nice and simple and now we have
what we need to write module
declarations so we'll start with my Lib
the smaller library we know it depends
on Java base we can write requires Java
base though we don't actually have to
it's always put in for you by the
compiler since every Java program
ultimately relies on java.lang object
which is in Java base now from the Jade
EPS run we know that my app dot jar
depends on my lip if we'd run Jade EPS
with more options we'd have seen that in
particular my app jar needs the package
comm my app util in my
now we could write exports calm my app
util semicolon in the module declaration
to allow anyone to access the package
but if we're sure that no one except my
app will need access we can use a
qualified export to maximize the
encapsulation and that's what we've done
here let's turn to the module
declaration for my app it requires my
lib and those two JDK modules and we
know it's going to use Jackson but we're
not yet sure how to write the requires
directives for Jackson yet because
Jackson isn't modularized does that mean
that we have to turn by we I mean you
have to turn Jackson into modules before
you can modular eyes my app that would
be unfortunate since no what I assume no
one in this room controls the Jackson
Java files maybe there is a Jackson
committer in this room is there a
Jackson committer in this room no ok if
only there was some way until that
person shows up for the Jax and jar
files to somehow become modules
automatically we don't know what the
dependencies and exports would be of
those modules but we have a pretty good
idea of what the names would be they'd
be the same names basically as the jar
files Jackson core Jackson databinding
jackson dot annotations and if we could
do that we could finish writing the
module declaration for my app happy
faces we'd have a lovely module graph
that a quality IDE will visualize for
you with my app depending on my lib and
Jackson Koren Jackson data bind and on
Java base and Java sequel the good news
is we can do this with automatic modules
an automatic module is a what is a
module whose declaration is inferred by
the module system from a jar on the
module path so if you have library jars
that are not modular jars you can still
put them on the module path and the
module system will turn them into
modules automatically
in effect this means that yesterday's
jars are already today's modules once
automatic modules spring into existence
for Jackson Corday turbines and
annotations the module graph looks quite
different
the automatic modules with the red
border basically say requires for
everything that is they require each
other and all the modules in the image
and all of your modules as well and they
export all of their packages now that
may well not be the set of requires in
exports that the Jackson maintainer x'
would write by hand but the way the
automatic module is inferred is is
really a feature not a bug because it
emulates the behavior of the jars when
they want in the classpath so in other
words we're providing the maximum
possible compatibility surface for code
in jar files when they're placed on the
module path and actually it's better
than when everything was a jar on the
classpath if you look carefully there is
no arrow from my lib to my app so there
is no danger of code in my lib
accidentally reaching into my apps
internals on the classpath code in my
lib dot jar could access code in my
approach are quite easily or in fact in
any of the jackson libraries is not
meant to be using without even knowing
it and that accidental access is what
causes maintenance headaches down the
road so that was a quick section each
application jar is usually a good
candidate to be a module each library
jar will modularize at its own pace that
is to say become a modular jar with a
module in fertile class file but
automatic modules means that you never
have to wait for the weakest link for
that one library that's not been modular
eyes yet you can move it from the class
path to the module path start requiring
it and very often it will work
for the third part I'd like to turn our
attention to the modular JDK twenty
years ago the Java platform was small
just a few hundred classes and the
organization of the JDK wasn't a problem
but every year the platform grew bigger
and now it's tens of thousands of
classes the JDK is huge and worse its
monolithic now in reality the Java
platform is not one thing it's more like
25 separate frameworks including the
swing UI framework the crypto framework
a scripting framework multiple XML
processing frameworks and so on there's
no reason these separate frameworks have
to be tightly coupled in one download in
fact it's an impediment in developing
the JDK the overly tight and sometimes
accidental coupling raises development
and testing costs which turns into slow
a platform evolution plus the larger the
surface of your platform the more
difficult it is to secure and it's an
impediment to a lot of users both those
who want to run applications on smaller
devices and those who want to run more
instances of their applications on large
systems even if you only wanted a part
of the JDK you had to take all of it
that all changes in JDK 9 we've taken
the modular JDK and broken it up into a
few dozen modules some of these are part
of the Java SE specification some are
just part of the JDK implementation this
is a graph of the Java SE modules at the
bottom there's Java base which
everything depends on and which depends
on nothing itself we've broken out the
various frameworks into their own
modules instrumentation logging XML
scripting desktop etc which you can
require or not require as your needs
dictate there's a Java SE module which
has no actual code in it but just has
dependencies so that you can say
requires charter SE and be guaranteed to
have all of these modules available now
it's worth mentioning that merely
finding these module boundaries
which might be obvious in hindsight was
a tremendous engineering efforts you'll
find in your oak her own code that
decoupling a monolith is harder than
building a loosely coupled system from
the beginning
the good news going forward is that the
discipline imposed by modules will
prevent all of us from accidentally
recreating a monolith I'd like to
quickly review the expectations of
compatibility from this module of JDK 9
first there are various technologies
from Java EE that ship in the JDK as
well as in app servers the list of Java
EE modules in JDK 9 I didn't have them
on the prior slide because it makes it
messy but the list of EEE modules in jdk
9 includes jax-ws Jack's B common
annotations and CORBA now these modules
are deprecated in JDK 9 and will be
removed in a future release to prepare
for removal
these modules these six modules are
disabled by default in JDK 9 if you're
running code on the classpath that uses
any of their API s then you can use the
add modules flag on the command line
through to enable them but please
understand this is a stopgap going
forward you need to obtain standalone
versions of the Java EE technologies now
standalone versions are available on
maven central today for pointers you can
see the removal jet that we've just
submitted so there's the URL some
conferences the first row is
photographers who enthusiastically take
photos of every slide with a URL in but
not here
the second thing about a compatibility
in gdk9 is that a lot of tools and
libraries try to access parts of the JDK
that are meant for internal use only
now unfortunately it'll take a while for
tool and library developers to move away
from this practice so JDK 9 temporarily
allows access to JDK internals but
prints a warning when it happens now
there's a command line flag to avoid
these warnings so please check with tool
and library developers about how to
deploy on JDK 9 if you see such a
warning finally there are miscellaneous
changes in JDK 9 that are unrelated to
modules but might affect code that ran
on JDK 8 notably code that assumes the
Java version string begins with one dot
or assumes that the JDK lives in a file
called RT jar will fail on JDK 9 again
please check with tool and library
developers about which versions are
needed to run on JDK 9 you can't always
assume that old versions of tools and
libraries will run on JDK 9 unchanged so
the modular JDK is modules all the way
down dedicate internals are accessible
temporarily in Jellico 9 and you may
need to upgrade tools and versions to
their JDK 9 aware versions so to step
all the way back a module is a set of
packages designed for reuse automatic
modules assist with migration to modules
and again you may need to upgrade your
tools and libraries to their JDK 9 aware
versions now there's a huge amount in
the module system that I haven't had
time to talk about and you're going to
ask me questions about in the remaining
four minutes you can encapsulate
resources in a module not just classes
you can express optional dependencies by
programming with services
you can build custom system images with
the j-link tool so you can drop kaaba
right now if you wish and you can spin
up multiple versions of a module with
the module layer API if you're
interested in this I recommend two books
the first is Java 9 modularity out last
month
it's a pragmatic walkthrough of the
entire module system and the modular JDK
and the other book is java application
architecture from 2012 it's a principle
look at constructing modular
applications and it has very good device
that applies whether or not you use the
module system in jelly k9 so JDK 9 is on
java.net today if you're a library
maintainer please run Jade EPS to see
which JDK internals you rely on and
again you can do this right now with
Jade epsilon JDK 8 everything you ever
wanted to know about the module system
is discussed in jet 261 I cannot
emphasize enough how much valuable
information is in that jet there's also
jet 260 which identifies the JDK
internal classes that are exposed in JDK
9 exposed exported for the time being
jep 223 which defines the new version
strings and jet 220 which describes the
changes to the structure of the JDK
including how RT jar has gone away and
finally jet 200 gives an overview of the
JDK modules themselves but if you've
read jep 261 there won't be any
surprises
in that with that thank you very much
we have two and a half minutes for
questions
front row enthusiastic the question is
about module aware war files and to pull
on that piece of string what is the
situation with modules in EE for Jay
please ask them next question
the question is you can export to a
friend module to a number of friend
modules and how is that not a cyclic
dependency that is an excellent question
I really ought to have a slide about it
the point is if one module requires
another and then that other guy export
back to his friends I mean I've just
drawn and you know so when I say no
cyclic dependencies I mean no cycles of
requires directives so a requiring be
requiring si requiring D ups requires a
that's no good
but the qualified exports they're not
they're not part of that relationship
because you may you may never actually
access any of the exported types it's
much easier to use this and to explain
it to be honest okay mario has a
question
when taking an exist I'm not gonna say a
legacy code base because that'd be rude
I don't mean that at all when you take
an existing code base that was designed
with far too much being public because
things were trying to access each
other's things different packages were
trying to share information between
themselves and so things had to be
public and maybe those public things
were then you know posted to Stack
Overflow you we have the same pain the
end result being that the modules you
declare you have to export more packages
than you would you know ideally have
thought where you're supported API all
modules really do is expose the use
usage scenarios that people want so
modules are not a silver bullets if it
turns out that your module has a hundred
packages and you need to export all of
them because that's just a structure of
the API then to some extent I can't help
you right and any change that I suggest
you might make the next question will be
are but that's binary incompatible and
again
there's not a lot the module system can
do about that it's simply reflecting
your intention as the library owner
there's really the contract between you
as the library owner and consumers of
that library so I'm actually waiting for
someone to say I have a cyclic
dependency what can I do the answer is
work you have to work there's nothing I
suppose you could not you could not make
modules out of these things but there's
there's no keywords there's no command
line flag to make all of the problems go
away if someone in your framework or
someone in jetty is accessing public
types that you regard as unsupported and
of course the JDK has plenty of them
then you have to educate your users
which is why the illegal reflective
access warning message that the JDK
gives when you reflect over internals
has very specific advice please report
this illegal access to the maintainer of
okay I think he doesn't the question the
question is what happens if you depend
on a library that is perhaps perfectly
pure and could be put on the module path
but when it was on the class path it
needed other things on the class path so
the good news is you can leave those old
things on the class path so here's an
interesting thing your module is going
to require this library which I'm going
to assume you're putting on the automat
you're putting on the module path as an
automatic module so you can write in
your module requires you know Jackson
grades your application cannot see
anything on the class path your - in
other words your dependencies are
reliable the only things you can see are
what you require but one thing I
obviously went through very fast is the
automatic modules such as Jackson 4 etc
etc they can see what's on the class
path maximum possible compatibility
surface so you can leave whatever stuff
you had on the class path with all of
its messy split packages you can frankly
leave them there forever
and the automatic modules provide a
buffer or a barrier against that messy
world one more question I think we have
old times up so ask this in negative
time please the question is is the
exports directive powerful enough to say
something like export P dot star or P
dot star star the answer is by design no
it is not because the purpose of the
module declaration and if you browse the
module info Java files of the JDK
modules you'll see what I mean by this a
very clear list of exports with no wild
cards and nothing clever going on just a
flat list is very helpful to immediately
read and understand the supported API of
a module you would also get into things
like if you were to say export P dot
star or export P dot star star but also
exports P Q to a friend now you have a
clash because exports P dot star star is
going to everyone an exports P dot Q is
only going to a friend so you'd have
then that will be a met you'd have to
figure out that out and they'd have to
be errors to deal with that an extra
analysis blah blah blah I think we are
finally out of time again thank you very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>