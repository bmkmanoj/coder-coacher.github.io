<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How Events Are Reshaping Modern Systems by Jonas Bonér | Coder Coacher - Coaching Coders</title><meta content="How Events Are Reshaping Modern Systems by Jonas Bonér - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>How Events Are Reshaping Modern Systems by Jonas Bonér</b></h2><h5 class="post__date">2017-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/3V3pHm2Cpks" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay we are live thanks all for coming
my name is Jonas Panera I'm at a
real-life stir speak I'm CTO and
co-founder of light pen former typesafe
I started the ARCA project a little like
almost was it seven eight years ago now
and I'm going to talk to you about here
try to explains or the essence of what
it means to be event-driven its how to
think in terms of events and what they
can enable us to do as developers in
terms of architecture and the way we
think about the bus software in general
sort of an architectural serve yeah
journey you can say so everyone is
really talking about events we're not
everyone but it's really high
do you know bus worthy now event-driven
its back again it's actually quite old
concept I I have a using events for most
of my life you need you started using
you know events when when I was back in
school about twenty years ago it was
always I was part of a of a other
community around the open source window
manager called KDE
and that was written in you know in the
widget library called Q 2 that is this
concept of signals and slots that was
really event-driven and eventually fall
follow following me around like you know
in different phases I'm in an SOA and
then SBS and no EJB sub special
amendment message driven bean set cetera
cetera and now they're really hyped
again so why should you care you know
we've been doing full circle again it's
an industry as we always do hopefully we
get a little bit better each time around
so I think that I'll hope to try to
conceive you a glimpse if not fully
convinced that events can help us with
things like Drive autonomy both
autonomous teams include the autonomous
components help us to reduce risks
and moving faster when we try to move
move from legacy to more modern
architecture you know he helps increase
things like loose couplings increase
stability in the system and increase
scalability and resilience also
traceability and and even a lot of
things like likes like like travel in
time and and take advantage of that
having a stable notion of time in
distributed systems which is extremely
important and way too often forgotten
and ignored and another question that
it's irrelevant is why now why is events
you know starting to become hype hyped
again well I mean I think it's four
things first its first is this whole
move for us as developers you know to
work loud and and and and multi-core
architectures that's what fundamentally
changed change the game we have to move
away from monolithic architecture from
from from just one single you know
thread per request all the way down to
the database and fully take advantage of
multiple cores multiple nodes multiple
data centers you know virtualization is
really pointing in that direction etc
also this whole move toward micro
service scaling the organization I mean
meeting time to market etc that forces
us to do you know fully embraced
distributed systems and we didn't have
to do that earlier we can we can search
eat and have and chose to choose to
ignore you know the university classes
we took on distributed systems back in
school 10 10 15 20 years ago but guess
what I mean now we need to go back and
relearn those practices they're actually
extremely useful because we're throwing
a thrown in again in this you know
vastly different world called
distributed systems also most systems
today need to be data centric you know
the applications they need to react to
data as it arrives in close to real-time
and are often dominated by data it's not
just something we can look shove down
into database and I think you better
think of it as data at rest we need to
fully embrace it as data in motion and
and and the fourth is our customers you
know
they want more of everything and they
want it now lower latency and better
throughput to like five features faster
more features more data etc etc and they
have learned to be very very picky and
and they can you know very easily not go
over to competitor if we don't you live
up to their expectations and so let's
say that a company now wants to the
Ramada nice for the legacy model is here
and way too often you know customers and
people they settle with this what what I
call micro lifts where you have like
single instance services which is sure
good but they in but they are served
still suffer from this strong coupling
that that synchronous protocols give
them give them in-between this often
means that you need to that you need to
sometimes update update them in lockstep
and and and you can't in any way take
advantage of that you're actually now
building the distributed system and take
advantage of you know cloud computing
and pay-as-you-go and scale you know and
and resilience also really really where
I've saved availability also very much
suffers when when you have strong
coupling between between components as
well as a we can't take advantage of
multi-core architectures to the way we
should be if we block down to the
database every single time etc I think
we can we we can do better than this
sorry skip north light and I think
eventually good architectures can really
help us here the definition according to
Gartner is that event-driven
architectures is a design paradigm in
which software component executes a
response to receiving one or more event
notifications event tree an architecture
can really work as sort of an
intermediary here help us building these
systems with fully decoupled
autonomous components that can you know
act and behave fully autonomous it can
also be you know implemented they rolled
out and and upgraded in by autonomous
teams in full serve isolation of each
other so it's really I think
event-driven architecture could really
be in a blur
can help us or break down you know the
chains of legacy software that's holding
back the organization and can helps us
reduce risk in terms of modernizing our
architecture you know by orders of
magnitude but let's start with the
basics what is an event if you go to
merriam-webster it says that it's
something that happens right it's not
that helpful so oh so my sort of little
longer the definition would try to
distill the essence of events is that
events represent facts of information
you know knowledge can only grow you
can't you should serve retrack knowledge
knowledge just grows from we are born
all the way up until we die I mean
should dementia and other things can can
hit where we forget things but in
concept knowledge is just an additive
process mean facts only accrue ok so so
but but events can however be
disregarded you can't choose to sort of
ignore a fact saying I mean if you think
that there is a risk that the other
service or the the one talking to you is
lying or or or like he causes um through
conflicting you you know I mean one fact
might be in violation with another fact
that we can choose to to ignore certain
facts but it's important that once fact
has been accepted
it can't be retracted okay
at least not conceptually and facts also
cannot be deleted once accepted the this
of course poses a problem in computer
science I mean where sometimes facts
have to be deleted for moral recency or
for actual even legal reasons but I
think conceptually we need to think
about facts as something that can't be
deleted even though we sometimes have to
do that for practical reasons however
new facts arriving arriving can
invalidate you know existing facts
that's how we we as human works over the
time we learn more and we realize that
we were wrong
or that our information is out is
outdated okay and I think this is really
the way I at least think about events
and how they serve arrive into a
component in how I should act upon them
the core machinery in in in events sir
is the event loop it's really what makes
events take okay and the event loop is
really is really a big buildup of two
things first we have the cue awry and
events that arrive and sup in this queue
and then we have to remove a loop that's
or a pick you know picks one at a time
and for each one's or it invokes this
callback so we have this anonymous
callbacks that are invoked for each
event that is that is that is taken off
the queue and processed and this is very
much you know according to The Hollywood
principle I'm sure you've heard about
like don't call off we call you type of
approach it's or easy it see it's
important to understand that event flew
by itself a pure event loop has at most
once deliver guarantees if you want more
delivery guarantee so more guarantees
are all you have to sort of rely on some
surround relying fabric or some other
mechanism to deal to deal with that so
it's also very important to understand
that the event loop is a local thing
only in pure survey a pure event-driven
approach is it's just a local thing you
only emit events to whoever's happen to
listening locally there's no concept of
communication or or addressing that I
will talk more more more about later
events event loop candles can conserve
invoke these steps to pick the cue and
evoke in the callback in an asynchronous
or in the synchronous fashion
asynchronous usually is more flexible
more more powerful and often the norm
but you but it's absolutely possible to
do that in a fully synchronous handover
type of fashion we often not need the
cue you just do immediate and handover
I'd say that it's it's quite limited but
it's also an important building block in
terms of building this this type of
approach or these type of architectures
but it's absolutely not there
what we can syrup we need to build on
top of it I'd say one of the problems
with with the with the vent callbacks is
that there are ephemeral and there are
in our anonymous okay and and that means
that it's really hard to build a same
failure model around just callbacks
because you know that we can't reference
the failed callback we can't reference
the failed context because it's it just
vanishes its execute and and and just
dice it doesn't have a concept of an
address of a reference you know this
means that we can't manage the lifecycle
of events they just they are truly
ephemeral and we can't restart the fail
context etc the only thing we can do is
release sort of rely on and some sort of
error channel like where we sort of like
push fail your downstream just before we
die okay so that's just very limited and
very very very sir yeah very limited
approach to effective to failure
management in general it also doesn't
give us any any any any form of
composition since we can't compose
things and naturally why we can't do
that is that we have you know this the
signature four four four four four four
callbacks issues you know input two side
effect the there's no return type of it
it's just side effecting and since
there's no return type we we can't
change them as we can do with with with
functions so there's really no way of so
composing things in the same in the same
fashion and this all the all this means
that it's hard to debug hard to reason
about and often leads to these things
like we you know people make fun of it
you call back hell and the pyramid of
doom at least and these type of things
and if you still embark on this journey
I mean you might actually find yourself
trapped in this mess well let it burn
what we need I think is higher level
abstractions and see the amount loop and
callbacks it's a great building block to
building more high level abstractions
that we can reason about semantically
that we can compose etc and and and you
know these are no aliens to you to you
guys I mean we have patterns since many
years like like all the observer patran
the pub/sub patrin broadcast and
multicast and these type of things they
build great on top of it in belt loop
things like data flow variables might be
serve a little obscure things
but-but-but-but future and promises is
starting to really hit means now we have
them in most languages stream processing
is really also actually fully
event-driven but it gives us more
higher-level semantics how to work with
these things you know with with
functional combinations like filter
group by map and and you know fold and
these type of things that that remains
the same across different different
products etc we can assume that the
haves are the same type of library of
transformation functions today from
spark to you know akka streams to Oryx
Java or whatever they're all they're all
there and that also helps you know with
cognitive burden of learning these new
things over and over again event-driven
micro services can also be looked seeing
that as a server higher-level pattern on
top of these these ideas including
things like look function function as a
service and so on so but let's dive into
sort of more high-level concept of
event-driven services and because you
know services is what we all ultimately
you want to want to want to build micro
services or whatever
so if event proven services usually
receive or react to facts you know that
is sort of coming his way and it does
its work and when it's ready to to that
should like tell the world about you
know what it came up with it publishes
new facts to the world you know if an
facts are stable values in they are
immutable so that means that others that
listening in on these facts can serve
base their reasoning on stable facts you
know things that won't change
they can't be retracted
and things like that and it and I think
also another important might be subtle
thing is that this way of thinking serve
inverts the control flow and this also
it helps us remain in mice coupling and
also increased the autonomy of each
component I could dive in diving into
into the dive deeper into this now but I
don't think I have enough time but what
is really important here that
mutable state you know even though we
talk about facts and yet ability you
know there's always good I mean I think
mutable states it's absolutely has this
place you know but it needs to be
contained within the service it can't
possibly leak it needs to be fully
non-observable to the rest of the world
so you accept the fact that's immutable
value you can use mutable state to get
your done sorry get your things
done and and and once you're ready to
serve you know tell the world about it
create a fact create an immutable stable
value about it representing that and
then publish that out to the world okay
yeah essentially what I try to say so
and how do you do that yeah I think the
best way of doing that of course they of
course many ways you can communicate
fact but one one of the best ways is to
use an event stream some sort of the
oven of an immense stream because that
can reverse work as the general
integration fabric between all of these
components that are flying around okay
you know so if if oh if I may try to
illustrate than what I mean here by by
some animations here let's say you have
some sort of user that sends a command
to one of these services a command can
you know be coming through through the
event stream but it's not probably more
often used in sort of sentence or you
through using HTTP or drgr PC or some
some sort of RPC type of mechanism
coming from the client okay
and it ends up in the components mail
mailbox and some action is to is perform
okay out of that action I now create an
event that I sort of publish out to the
event bus the event stream this event
stream now skills were just
really this event who ever happened to
be interested in that this that I
performed this action there I actually
did this did this suck this side effect
that can be you know other other
components here that has you know it's
put on them on their on their mailboxes
and some action is performed so all that
is natural but what is also really
really really great that this that this
event stream can also works as an
integration fabric beyond just
communicating between services it can
read you can like be like push things
down into a third party database or even
if we're analysis HDFS are picked up by
spark streaming or summer fling or
something for data processing or Hadoop
and if you're old school or or or doctor
shove it over to some external system
like like through that's beyond of your
of your of your of your control so I
really think that it can be sort of this
thing that tie they you know your whole
story together if used correctly one
important thing to understand though is
that is that it's you know all the
things that regards to events should
really happen in a fully asynchronous
fashion that means that everything here
is eventually consistent which is you
know it's quite a leap to make but I
absolutely think it's worth it I'll talk
more about that later so if you want an
analogy and like Big Lebowski like I do
is really sort of you see the van stream
sort of the rug that sort of ties the
room together it might be a stretch but
it really helped me so no one really
wants the eventual consistency though I
think it's really it's a fact of life
that we have two embraces but it's a
necessary evil it will make your life a
little bit more complicated but you know
it will give you things like better room
Headroom for scalability or resilience
and autonomous components and you know
etc it's really how the world works all
the time if you just if you just think
about it I mean there's no thing no such
thing as as one single global occurs
consistent truth at all times no it's
not
everyone in this room is a fully
consistent doesn't experience exactly
the same experience all the time that's
how we communicate and negotiate and you
know but we remember we're getting along
quite well anyway you know one important
thing to understand if information
travels at the speed at the speed of
life that really puts a limit on the
speed of information and that's really a
reality in the inn system too today a
horrid reality that needs to take into
account it means that information is
always from the past when when we
observe something it has always already
happened sometimes actually quite some
quite some time ago so we're sort of
obviously looking into the eye of the
beholder below is looking into the past
I mean
it's always fixed mortem experience is
always in the eye in the eye of the
beholder so the present and the now is
relative everything is really eventually
consistent and when we serve and so exit
this sort of safe zone of our components
we really serve enter a wild ocean of
non-determinism that's the survey the
world of distributed systems and the
super systems are hard no it's in the
world where systems like failed in the
most spectacular ways where messages or
a drop reorder where fail and detection
is nothing but a guessing game it is
also the world that gives us you know
solutions for things like resilience and
scalability and autonomy and all these
things but I think to stay sane in this
world we need to have way to model
answer uncertainty in a petal and one
said that in the system which cannot
count with distributed transactions the
management of us uncertainty must be
implemented in the business logic so I
really I really we need we need to have
sort of a way of modeling the space
between the services not just you know
think within within the service not try
to hide it but making it explicit sorry
when we talk about active programming in
distributed systems in general I usually
try to teach there which is to embrace
the network making making the
constraints of the network part of the
programming model this don't try to hide
it like we didn't have sort of been
learned to do you know this
shortly through our PC or distributed
objects and you know pretend it's not
there then it then we should be fine no
I know it's the opposite then it will
definitely come back and bite you so we
need a way to explore it reality in our
design and use it at our advantage just
look around and model a world as it
actually is instead of you know to try
to like you know create some sort of of
shielded you know simplified world in in
our in in our computer systems and I
really believe that events can lead to
greater certainty really it can help us
model this uncertainty that I'm talking
about those events can help us with
craft these autonomous islands of all
determinism where we are in control of
now and we are where actually we can
rely on things being fully deterministic
when once we submit this event outside
this context or receive something should
the space in between there might be
totally in deterministic the events
might be reordered or dropped or
whatever but if we have because at least
you know account for and its reach rest
that when the event arrives or when the
command arrives into our components we
can real we can relax which is which is
quite good and and one thing that will
that help me a lot with this now I think
it will help you as well is its what a
start be called advance first
domain-driven design your domain driven
design has been around for quite a long
time so started you know by coin by Eric
Evans in 2003 or something it was a long
time or 15 years ago or something and
its really served us well but he can
actually lead us down the wrong path if
you just applied blindly for you to the
to the to the book because it often folk
its puts focus on domain objects and
structure too early in the in the design
process I mean I usually try to practice
what I call it dance first domain driven
design where we actually put focus on
what's happening in the system first and
then in first Greg young once said that
when you start modeling events it forces
you think about the behavior of the
system as to
opposed to thinking about the structure
of the system yeah so we should we don't
focus on the things initially we should
don't focus on the nuns the domain
objects that we've been taught to think
about first we should instead focus on
what happens okay the verbs search the
verbs in the model and that will be the
events okay we should to remind the
facts coming in but still think think
about yourself like like you know CSI
coming into a crime scene or Sherlock
Holmes or whatever coming to crime scene
and say ask what are the facts you need
to try to mind the facts and understand
causality what will you what have led to
the next thing into the next thing and
one thing that can help us here is is
the constant called events for me
essentially if technique would have put
all the stakeholders programmers domain
experts in one single room to handle
they hand them a bunch of post-it notes
and say and let them through explore and
mine you know what's how I mean what's
really been going on in the system what
are the events what have cost the events
often the command the cetera and try to
like map all that out looking looking at
it from a perspective of what's
happening the verbs okay so we should
try to sort of understand we should try
to when we do that we should try to
understand first intense that is things
like communication conversation
expectation contracts transfer of
control and also facts things like state
history causality notifications transfer
of state and intense are usually mapped
to commands while facts very often are
mapped to events take it with a grain of
salt it's just some try to give you some
guidance how do you think about mining
or model and coming up with something
sensible
okay so commands you know are usually an
object form of the method of them from
action request it usually is so phrased
in the in the imperative like create
order shape product or something like
that that's released to some saw
reaction that is a side effect that is
created that side effects mean
sir after after you done beside we
create an event that represent that that
side-effect have happened okay that's
usually surf raised in the in past tense
like order created is to the create
order you know product ship instead of
ship product so on but let's let's dig a
little bit deeper then commands is
really all about intent while events are
fully intent lists they just seem to
represent something that has happened
commands are directed while dancer are
anonymous okay commands have a single
addressable destination while events
they just happen for me
anyone to observe can be 0 can be 10 can
be hundred it doesn't matter
this means that commands and model
personal one-to-one communication while
events or malls broadcast you know think
speakers corner we all shout out your
use with a megaphone you know hopefully
someone's listening to you and commands
and then have a distributive focus
because they are addressed the the mall
communication in the communication
served you know so you moves across
contexts while events as I've said
before has a local focus it doesn't
cross contexts and so commands are
really all about command and control I
tell you what to do you better do it
while events is fully about autonomy I
react to whatever happens my way and I
choose if I should do something or not I
could choose to ignore so that's why I
think I mean the this tension between
events and commands is extremely
important and I think we should let
events then sort of define the bounded
context define the protocols you know
and the promises we were there with that
without that we can make and what
happens also when we wouldn't decide not
that we can't serve keep them any longer
in more in DDD you know we usually model
this in terms of the aggregate the
aggregate you know is is the component
that manages state usually map to some
sort of database for for durable storage
it is yours your unit of
of consistency that manages the
integrity of your data and the
consistency of the data ideally in a
strongly consistent fashion per
aggregate you know so you can rely on
full determinism within within the
aggregate it's also a unit of failure if
an aggregate fails it needs to fail at
one thing you can't shard an aggregate
that means that you have partial
failures okay and it also is replicated
as a whole it started off as a halt it
was always atomic anyway this means that
it can be fully autonomous okay but I
know what you guys are thinking enough
talk show me the code so I feel we try
to do that I'm freaking out but less
let's try to dive into some code what
I'm going to try to do is it is sort of
show you this essentially this this use
case we have the client that is yeah
probably some I'm going to come from web
browser or something like that
I mean pushing in an order into orders
so for a process manager Orchestrator
that's orchestration the order in the in
behalf of the client talking to the
inventory by certified reserve products
if that's if it's possible to reserve
them submit the payment the payment is
approved ship the products if products
are shaped it sends the confirmation
back to the back to the client so that
is the idea so we have one client and
three different services and the
inventory impairments then then they are
this should probably Model S as and as
entities because they serve represent
this herbal unit of consistency for each
one of these services okay so let's now
try to do that
I have IntelliJ here okay so I just I
just open up the fresh file order
management dot dot Java here so let's
say we're gonna have some scaffolding
here I'm just going to I'm gonna code
this happen in in acha acha is a great
you know distribution fabric it's a sort
of a tool boat toolbox for building
distributed systems for building
micro-services type of applications etc
I won't have time to dive into details
but I'm gonna use it because I think it
will say it's a great practical you're
highlighting some of the ideas I've had
I've given you here so let's say that we
want to circuit some some commands here
first we have some sort interface
command we have create create order with
some properties we have reserved product
submit payment and then ship product if
of course I mean in the real life
scenario I would never use serializable
I probably serialize it to Jason or even
a bro or protobuf or something like that
but just trying to keep dead simple this
is by no means production code all of
all throughout ok it's just trying to
illustrate a point here and then we
create some some events here and we have
some sort of end interface here where
product reserved the sort of mapped you
know reserved product if that was a
successful payment authorized product
shipped in order to complete it okay so
let's now create a few of these services
then starting within with the inventory
I have an inventory actor here okay I
can first just explain I'm how many
people have heard of the actor model by
the way knows what is all about okay
most people here but for you that
doesn't let's give me like a one minute
recap of an actor it's actually served
it distributed fully autonomous syrup
service you say it lives in isolation is
fully thread safe its location
transparent that means that a runtime
can sort of move it around in the in the
cluster as it to optimize you know the
actor is being used etc each actor has
it has a mailbox servic message queue so
so you can send a message to an actor
Arlis where it happens to be in the
cluster at this point it will end up on
his cue and then an actor is multiplexed
on a thread pool so so so you keep
electrics extremely lightweight so you
can millions of actually tens of
millions of actors running on a single
laptop because they only consume memory
they don't consume threads unless they
run on the thread okay so so when it's
when when it's an actor's turns to to
syrup do his work one message is put is
taken from the mailbox you know order of
course from the queue and it's put into
the actor and into what is called the
receive method of the actor okay so yeah
and actors that are fully resilient you
need you supervise the hierarchies to
monitor each other they can be restarted
on failure in all these things but I'll
I'll leave that for as an exercise if
you want to look look it look into it
okay so we have the inventory we have
the payment actor and then we have the
order or salary the orders actor and
let's say now that we want to implement
first one implement some logic for the
inventory so and we so this this
inventory logic is just for further
first we have just some you know some
state just to make it a little bit more
interesting as you know that in servings
in spring or in je app you probably map
this down through JPA to some sort of
database but but but here we're just
keeping it sort of in memory for now and
we we have reserved Mercer products the
service entually do some side effect the
now rep represented just printing it out
but in the real world of course will
actually perform the action of reserving
the product if that is successful then
it's a returns product research okay we
have shipped the ship product method
that essentially just no updates
increments the number of ship products
and then if everything successfully just
returns product shipped command okay
this is just internal logic now what we
want to do is say we want to want to
implement this receive method okay so
what what what what's happening here if
sort of a command of the type Reserve
product is served
enters my queue then is put into the
actor and it any if there is a match
here I will then run this this little
function here or lambda okay
I get the command as as a extension of
this command as I say as if that's an
argument to the lambda and what I do is
I simply call this restore product if
things go well we should they all they
do in this case you know I get the event
and here and here comes interesting
things you know now did this will
represent the fact that I've have
already reserved my product that can't
be taken back you know it's probably
enter some subsystem something that then
I then I use our cos internal event
stream here I'm getting a reference to
that and I was simply publishing my my
product status downstream for whoever
happened to be interested in real-life
scenario I would probably not use our
custom event stream that sort of just
used for simple communication between
actors I would probably use something
like Kafka or kin sec for I know you see
easy to or so but if it serves the
purpose for this for this demo you know
the same thing here with the ship if I
if I get the ship product command coming
in around this lambda I'm try to ship
the product I'm I'm getting the shipping
status event and I'm pushing it
downstream essentially okay for the
payment service I'm it's like similar I
have some state here in this case the
unique transaction ID that I increment
each time I processing a payment if
things go well I return the payment
authorized method no sort of event and I
around I have this received block you
know it's actually you know the receive
is created by you to receive builder
that's actually returned here but if I
if I have a match for the submit payment
command here I process the payment and
if things are well you know then I get
the event back and I publish it
downstream okay but the more interesting
here now is that in the the orders here
because you see the order sexually of
the orchestrator of all of this whole
transaction it has you know references
to the client the inventory and
and that and the payment so what I want
to do here now is I want to have it
subscribed to these events orders and I
do that in an ethical priest or priests
are to serve cold right before the actor
is handed over to do to do work right
before start is invoked on the actor and
what I do here is again I get I get a
reference to the mainstream as they
subscribe I'm subscribing that I myself
should get notifications here I'm
actually sending in myself reference and
I say I'm interested in the product to
serve product shipped and payment
authorized events so whenever these are
alleged flowing down the ax downstream
in the vestry they are sent to me okay
so then I better have a way of managing
them as well and I do that of course
oops
in the in there in the receipt received
lock here we're where you can see that
if I if I get a create or a class create
or command here coming from the client
usually then I essentially tell the
inventory tell is actually the Metheny
on which I sent it fully asynchronous
message to an actor it looks like a
synchronous call but it's it returns
void and it's sense it's asynchronously
to the actor and and and and so actors
or location transparent so regardless
for this actor the inventory actually
resides at this point you mean other
data center even it will eat will get
the message you know put on his cue etc
so I I'm sorry I'm sorry I'm sending the
reserved product sort of command down to
the inventory if everything goes well I
get a product reserved event back then I
can sort of tell you know tell the
payment to submit the payment this is by
the way of course not you know done sort
of synchronously these are these are
just callbacks as as I talked about that
are invoked when one of these events or
commands are coming in this or declare
the description of what to do when I
receive events and commands if the
payment or authorize is to authorize I
get the payment authorized event here
tell their mentor to ship the product if
the product is successful the ship and I
can tell the client then the order has
been completed etc so this is a great
example of what is called the process
manager this also something talked about
in the D in the DDD community but it's a
fully asynchronous type of process
manager okay so now I just want to have
some sort of scaffold and culture around
this I have an order management you know
simulation here the first thing I do is
say there's all these vectors I always
create an actor system okay and then I I
have you know I have some some first let
us have some some plumbing here this
essentially just testing code for for
simulating to have an actor client I
have a client in box that's or events or
if someone replies to - - to this client
in box they will end up being this in
box and I get an actor F so this is sort
of plumbing code there but you notice
for most food forget but here is heresy
and the interesting piece I create a
bunch of services here by our using the
act Rob sort of sort of builder method
it's a factory method here I'm passing
in service and configuration say I want
to create an instance of the inventory
class after a payment actor and the
orders actor I'm going to create the
orders actor I also want to pass in the
other ones you know as arguments to the
constructor so here I have my all three
actors they are already started and
finally you know I I say that I I kick
off the whole you know simulation by
setting a create order to the to the
orders actor and say that everything
that that a rip if someone replies to me
with that address they will end up in my
client inbox here
so I say I say that I am willing to wait
five seconds here for four and the word
a confirmation to come back if that's
okay I just printing it out if not I get
a timeout exception okay so if I now run
this whole thing you can see that it's
the simulation worked as expected they
come they could the client says sends a
command to the orders create order to
the orders then in the order send a you
know reserved product to the inventory
runs the side-effect
event is produced you know representing
the actual side-effects sent back to
orders that is the price or the
orchestrator then the cakes things off
with payment back to orders keeps
himself we mentor shipping things and
then back to the client eventually okay
so here this is urban extra an example
trying to illustrate how you can use the
event stream and and and the concept of
a process Manchester Orchestra multiple
you know fully of it fully asynchronous
event reviews components to doing their
their actual work see just want to go
back to to the slides here so so are we
are we are are we done now then well I
think we will we've come a long way here
but I but but it's also very important
that events can also be used for for for
persistence and for managing time which
is which is quite amazing actually I
mean some people stop here and they just
say I'm just going to persist all these
services use using crowd down to the
database it put the new patrol in
Cassandra or something but I think that
we sometimes some lose some of the power
of of events because the events you know
the end to my system in the order they
arrived well I'm not just for system in
the order they are they they arrive you
know and let that be my my serve my
durability I mean you know also all
single databases they do transaction
logging under the hood then the only
exposed you know that you know a
snapshot of now to us as developers to
work with that's our tables you know
there's no history
exposed to us as developer that's etc
event based persistence can really can
really help that you know if I think
event flowing he really be sir at the
bedrock if we allow ourselves to think
about you know persistence in terms of
traditional bookkeeping and rely on on
event logging in a stories event in the
order STS arrive durable on disk
just like transactions are done one by
one in the ledger and if we do that I
think it can really be the bedrock of
which we built other things more
high-level concerns like consistency you
like availability scalability and and
traceability and so on
an event law if their event sourcing is
really a great pattern that sits on top
of the backlog that gives us a tool for
this it can take advantage of our event
Ness you know in your event sourcing is
really that we log each state change as
an event each each each serve each time
we change the state in in and in an
event-driven object we log that as an
event representing the fact that we did
change the state okay and this gives us
our strong fully strong consistency even
in the in the object itself through
backed up by a by a transaction log you
know you know patalamon said the truth
is in the log the database is a cache of
a subset of the log
you know they either use they used to be
reason why we used in place updates you
know disk space was used to be very very
expensive
now it's immensely cheap there's no
really no reason to keep all not keep
all history around at all that's ever
happened in the system you know and and
and so the question is why work with the
cache of a subset of the real thing when
we can use when he work with the real
thing the log directly and take
advantage of the fact that we are
event-driven so events or services you
know they were they work the way that if
we first first to look at the happy path
you know we first receive and verify the
command for example approve payment then
we create a new event
you know payment approved then we append
that event to the event log and then we
update the internal component state if
the logging was successful and if that's
successful then we around the side
effect like launching nukes or whatever
okay then the interesting comes thinks
that when when that component fails and
it sort of rebooted up again recovering
from failure then we serve can rehydrate
the events from the event log but by
just running that step and update the
internal component State and this is
what Martin taught and Mark and Fowler
often calls for memory machine allows us
to store a persist state in memory
directly you know work with the state in
this
natural representation in your in your
in your object instead of having to go
through you know or mappings and stuff
like that because give us really well
sort of truth all history allow us to
have this in memory durable state or you
know avoid this or this or this classic
or are mapping impedance mismatch where
we had to map you know or object model
or functional model to tables down into
into the sequel database it also allows
others to subscribe on changes that
that's happened because people can sort
of subscribe what's happening in the
amount log you know naturally it also
gives us like full traceability what's
happening the system all the way up to
where we are right now because
everything is there in the event that we
can replay the amount along not just
from failure but also to understand what
went wrong the bug ability for auditing
we have like bulletproof auditing right
into the event log for example it gives
us great but what Martin Thompson called
mechanical sympathy because it's really
you know works the way modern hardware
works with append-only Singh the writer
principal writing you know disk in a
fully append-only fashion you know some
disadvantage is is that you know we're
unfamiliar model for example we're
versioning of events can be can be can
be hard and deletion of events I've
already said is hard sometimes needed
for legal reasons okay so I just gonna
I'm running out of time a little bit I'm
just gonna try to show you in encode how
you can move this move this sort of take
this this demo of ours and making it
event source because the step of doing
so now when we have the events really
they're fully serializable is almost
nothing actually see if I can stop this
so what we want to do here now is that
we want to you know we want to take each
one of these these entities we have the
inventory entity and within the payment
entity and make them event source in our
car we the only thing we need to do
really is we need to say this should
instead be a persist
persistent actor and we also need some
scaffold when you say they should have a
persist sort person versus ID and we
giving it a give it a name your
inventory okay the same thing with this
guy here if you want to make that type
persistent doctor and system ID and call
it payment okay so the interesting thing
is the only thing we need to do here is
actually to invoke persist so you know
product status here represent the fact
that that that that we do want to store
so I just I'm just invoking that for the
persist command here saying I want to
proceed the the product status event and
if that is successful then what I do is
so then I just I don't really want
around this this this this this this
callback in this case you know pushing
it downstream the same thing with this
one here I'm just going to persist the
shipping status command and if
everything goes well I want to I want to
push it down to the to the announce tree
now however if things don't go bad the
this worthy they unhappy path the sad
the sad path what I have to do then is
that I have to in I need to implement
this receive recover method that
essentially says affray for each time I
rebooted all these events that
persistent will be replayed and either
way of managing them okay so I have I
so whenever again then get in the
restart or a reboot or recover scenarios
I get the products reserved method here
I'm running this callback in this case
and just printing it out if I get a
product shipped I'm saying I want to
implement and now want to increment the
state again bring the state back into in
where it was when I serve started you
know from day from day one and and mmm
as printing printing that out and then
the same thing here for
persist payment status bear with me and
it's done here I want to persist the
payment status and I also need to sorry
I still need to round the implement the
recover here saying that whenever women
whenever I get a replay then of the
payment to authorise some from the now
update my internal state the transaction
ID here and I'm going to print it out
okay so this is really all I need to do
if I know you find now around in this
here then you can see that the first
time around I'm not doing anything
really but the second because I'm just
logging things on to disk now and then
in this case I'm just using the level
level DB which is the default
persistence or log but in when I rerun
is here you can see that the events are
actually replayed I'm bringing you know
micro section number two on in the prior
shape to on for rerun it again you know
I should have yeah I'm up to to to to to
to ship products etc so so I'm really
have fully read rehydrated the state in
memory in my in my components all backed
by by the events that just been flowing
into the into my components now but now
made durable to disk as they enter my
components here so I was essentially all
I wanted to show you here the key
takeaways I really think that the
venture even design really helps us
build fully autonomous services you know
have them moves faster to a reactive
architecture to take advantage of the
promise of cloud computing and
distributed systems in general helps us
reduce risk you know moving to multiple
teams and micro services doing so but
helping for a balanced Urton t and
uncertainty and event logging also you
know allows us to take control over over
the of the state you know the history of
the state itself it allows us to do
things like time travel go back and
replay on failure we're auditing for
debugging reasons and even sometimes
you're actually Lyman for the universe
is in into like separate you know States
for it for for different reasons and
allows us to manage in
know this by doing strong consistently
while being fully eventual consistent
between the services you have strongly
consistent services but eventual
consistency in between in making some
sense of all that madness so at least
it's it's helped me a lot I wrote a
little book about this called reactive
micro systems which are actually gonna
gonna hand out some right after this
call this talk for 20 I think I'm will
be at the O'Reilly booth having some of
these out and signing them if you want
healthy also you can just download them
the book at this URL here so certainly
be being limit over time that was all I
had I hope I made some sense and to put
you on the path to worse understanding
and appreciating event-driven systems so
thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>