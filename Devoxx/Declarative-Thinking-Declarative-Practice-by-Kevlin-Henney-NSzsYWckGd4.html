<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Declarative Thinking, Declarative Practice by Kevlin Henney | Coder Coacher - Coaching Coders</title><meta content="Declarative Thinking, Declarative Practice by Kevlin Henney - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Declarative Thinking, Declarative Practice by Kevlin Henney</b></h2><h5 class="post__date">2016-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NSzsYWckGd4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon so I get the difficult
slot the straighter after lunch
slot when actually what you want to do
is go to sleep nice comfy nice comfy
seats and so I'm going to give you that
option you may do that but we're going
to shine lots of bright lights there are
enough bright lights here I'm not going
to turn the volume down if you can sleep
through that well done you deserve you
deserve your rest but for everybody else
this is what we're going to talk about
for the next declarative thinking
declarative practice my name is Kevin
Henny my goal here is to test the
tracking on the camera I was told that
it automatically tracks do you do you
walk around a lot yes I do so we're
going to do some software testing I know
I often talk about software testing but
today I want to talk about something
slightly different
declarative thinking declarative
practice my parents gave me an Internet
unique name before the internet existed
which was a pretty smart move you can do
the same for your kids make sure you
google the combination of their names
I've done this for my kids it works but
a bit about me I have a very strong
interest in things like design patterns
software architecture and the like also
have a lot of interest in the detail of
code I edited 97 things every programmer
should know a few years back for
O'Reilly I was just on the stand signing
copies of this and one of the
interesting recurring themes that popped
up when people were contributing to this
book was sort of an emergence and I want
to point out that this is we gathered
the articles in 2009 pretty much there
was already an appetite for things like
functional programming and it was very
obvious in some of the items but also in
the general guidance that was offered in
other items
weren't specifically about things that
were functional there was very strong
sort of declarative emphasis and in one
sense declarative programming something
we often focus on it's a descriptive
idea we like the idea that our code
should be descriptive but a declarative
approach takes a very different view
than say an imperative approach of which
and we can say that functional
programming this is not strictly a talk
on functional programming although I
will certainly include it is if you're
like declarative programming is a bigger
set of things and functional programming
is part of it or overlapping with a part
of it so it has a natural sympathy so I
want to take us back in time this is a
wonderful coincidence since the Vox
conference has just announced yesterday
if I recall correctly that there was
going to be a Vox LED a Vox day at CERN
and I'd already included this quote from
Tim berners-lee and one of the
observations that he made he kind of see
the dating of this he said computer
science in the 1960s to 80s spent a lot
of effort making languages which was
powerful as possible now he wrote this
in the 1990s at the beginning of the
1990s and he was focusing on things that
were very simple we're talking about
HTTP and HTML here these are effectively
declarative forms in other words we're
stating an intention directly rather
than creating a full computational model
but this idea of powerful languages if
we could easily extend that to the 2000s
we said nowadays we have to appreciate
the reasons for picking not the most
powerful solution but the least powerful
and this kind of goes against our
instincts I find myself on both sides of
the line here sometimes I want something
to be more powerful more expressive and
then sometimes I actually think you know
what we need fewer things more
primitives because as he observes you
can make you can make things if by
making things less powerful the more you
can do with the data stored in that
language
it is the idea and it's a very old idea
of code as data if you write it in a
simple to
to form anyone can write a program to
analyze it in many ways and we see this
example occurs again and again you don't
necessarily have to write a what you can
write a parser but the point is that the
parser can be relatively simple in its
interpretation it doesn't have to have a
computational model a strong
computational model behind it that map's
on to things like state changes so how
far back do we go well the declarative
approach has been around for a very long
time some of them have been more
influential than others this is my
printout of the original make paper the
Feldman invented basically in the late
70s so this is interesting I'm putting
up make here and everybody's here
something oh I don't use make I use ant
or something like that and it's like
well wait a minute let's look at what
all of these have in common because
they're structured in a particular way
what make introduced was the idea of a
less powerful language a very simple
idea of creating as is observed in the
Wikipedia article the make file language
is similar to declarative programming
this class of language in which
necessary end conditions are described
but the order in which actions are taken
to be taking is not important it is
sometimes confusing to programmers used
to imperative programming the idea is
that in imperative programming you
control everything you control all the
state you control everything and how
everything fits together you deal with
all of the mechanics all of the for
loops all of the variables you do the
plus plus because you're the only person
anybody can ever trust I mean how are
you going to make sure that that value
increments unless you do it ok you are
the most important person here you have
complete control of the Machine this
comes to us directly
the imperative model imperative means to
issue a command comes to us very
directly and very obviously from
assembler and there's a and that legacy
has shown through into programming
languages ever since then but make file
approach takes a different approach it
says there will be imperative elements
but the backbone
of a makefile is the declarative
structure it is the relationships so now
it's on a focus on relationships that's
what we're declaring the relationships
between the parts and then we say oh and
detail happens as opposed to here's all
the detail and this is a sort of an
inversion let's go back while we're in
the 1970s nicolas vert the inventor of
pascal modular 2 and a lot of other
things and actually if you're interested
the guy responsible for the title go to
considered harmful the paper was written
by Edsger Dijkstra but he didn't call
him go to considered harmful it was
Nicolas Werth who gave it that name he
wrote a book in the air in the 1970s
algorithms plus data structures equals
programs I'm guessing this probably
frustrated a lot of publishers because
the idea of using symbols in your book
titles is a relatively common modern
concept but perhaps not quite so common
in the 1970s but I'm going to simplify
it for you why don't we take a different
view what about just saying data
structures equals programs again there's
nothing new here if we go back to the
book that everybody needs to refer to
and certainly read at least once in
their career mythical man-month
this is quite a long way back and he's
referred to stuff in the 1960s and he
makes the observation representation is
the essence of programming which I'm
going to point out sometimes you look at
a piece of code if you're looking at a
large java code base there is a very
high probability that the java code base
is what has been referred to as string
lee typed it's all strings and a few
integers we're not making the best of
the possible representations we have
very weak objects very anemic objects
there are controllers and then d tos and
they don't really have a lot of strong
declarative feel the behavior is stacked
away in large methods but there's no
kind of compositional feeling there's no
concept of a clear view of
representation and a model of
representation is the starting point as
as Brooks notes it says look show me a
no charts which is nice and quaint in
1970s and show me your flow charts and
concealed your tables and I shall
continue to be mystified but show me
your tables and I won't usually need
your flow charts they'll be obvious we
can tell from the relationships between
the data structures what is going on and
if we can't tell directly we can Intuit
we can make educated guesses we can
anticipate what is going on and then be
unsurprised by the detail or is if I
just show you the control flow if I just
show you I show you procedural structure
and state change it is very difficult to
discern the intent the declarative
intent of the code of course we have to
be a little bit cautious when we start
talking about tables and say everything
should be tables because you know Excel
is the world's most popular size popular
function language and sound Peyton Jones
who has an awful lot to do with Haskell
a lot of people automatically assume
functional programming means it will
work out perfectly our evidence is that
most spreadsheets do not so clearly
there's a lot more to it than just
saying I have a way of representing data
it needs to be intentional it needs to
have and it needs to have a proper
structure that is properly compositional
and reinforces that view so let's look
at some examples of things that fall
into this category
so in 97 things Burke Hough Naugle has
this lovely makes this lovely article
put the mouse down and step away from
the keyboard there are two things that I
like about this piece one is the general
advice which is encapsulated beautifully
in the title if you are stuck with a
problem then it is very unlikely you can
solve the problem with the same kind of
thinking and at the same level that you
encountered it but we persist in doing
it we spent hours and hours even days
trying to focus on it it turns out that
if that's not working then doing more of
the thing that's not working is probably
not helpful it's a kind of obvious when
you state it like that so there's the
idea that do something else put the
mouse down step away from the keyboard I
generalize this advice sometimes I offer
it to people
they do something that is completely
different to what you're doing at the
moment if you normally drink coffee stop
go and get a herbal tea do the opposite
if you don't drink coffee go and get
yourself a good strong espresso yeah do
the opposite if you normally listen to
music whilst you're working stop if you
don't normally listen to you music it to
music while you're working start yeah in
other words whatever it is that you've
been doing do the opposite of it because
you need somehow to be doing something
differently to inspire different
thinking now the specific example and
therefore motivation in putting this up
here the specific example of Burke uses
is a example that is very very
procedural we can go through and we can
see right so what we doing we're gonna
try something and we're gonna try and
parse a string that is called time so
it's a representation of time I'm
guessing and we can look at substring 0
for 2 we can take the first 2 characters
try and convert it to an integer if that
fails then we're going to return false
so therefore this was not an integer and
therefore it probably wasn't a time
string ok great
and now we're actually going to do the
parsing and then we're going to check
because it's 12-hour time that's been
used here we're going to check that it's
not greater than 12 otherwise we are
going to assume that it is false and the
important thing here is that there is a
dot dot dot after this
this goes on for some distance and then
we get to the end and actually finally
figure out is this a.m. or p.m. even if
I improve this by switching from 12 out
of 24 hour it only knocks off 4 lines
there's a lot of stuff going on here now
some people might be satisfied with this
because there's a surprising amount of
code that looks like this we call it
enterprise code ok and what we're doing
is this exactly what I was describing
before it's the mechanics we're going to
go through we're gonna know let's have a
look at that detail and then there's
that detail and then there's that detail
and then let's drive that detail then we
need to hammer this small thing in and
then worry about that state change to
all of these things it's like what's
really going on it's not obvious so he
did as suggested he put the mouse down
stepped away from the keyboard came back
and there we go that's it a really nice
simple expression of the problem now
sometimes we got to be a little bit
careful with regular expressions there
is always a danger with regular
expressions that you end up with as
sometimes people say I had a problem and
then I solved it with regular
expressions and now I have two problems
although sometimes you can joke about it
and say well actually something and now
I have start problems just to generalize
further but the point here is actually
as a description this is this is
everything it's a declarative
description I'm describing the
relationship between parts it's not a
fully computational model in a Turing
sense but it's a declarative sense there
is a language that allows you there is a
form that allows you to describe exactly
what you want and it is very easy and
this is the key idea it is very easy to
see whether or not this is correct it
takes a little if you're not familiar
with reg X's then it takes a moment of
explanation but then you can see quite
clearly and this is the point is that
sometimes an imperative model may be
completely general-purpose but maybe
obscure whereas a declarative model when
it's well matched will be precise
although it may take an initial moment
to educate the reader what I find
interesting about this is that I could
probably explain the model here quite
easily to somebody who is not a
programmer this on the other hand I very
much expect they would either fall
asleep before the end or walk off okay
so the observation from the Haskell
homepage many programming languages
support programming in both functional
and imperative style ups that they're
just going to say functional role and
declarative declarative is a larger
space but their emphasis here is very
much that but the syntax and facilities
of a language are typically optimized
for only one of these styles and social
factors like coding conventions and
libraries often force the programmer
towards one of the styles this is what
we see existing code bases exert a very
strong pressure so if you you know if
you're managing to migrate your code
base to Java rate or you're managing to
migrate bits and pieces it to some
groovy stuff or you've decided well this
corner of the code we might be able to
do some closure or whatever
the problem is that there is a very
strong force exerted by the mass of
existing code and importantly code does
not exist in isolation it exists with
people people define that and there are
very strong cultural conventions and
sometimes that will move us away
there are obviously language limitations
there are certain limitations for
example within Java that mean it's very
difficult to get certain kinds of
immutability working perfectly
for persistent data structures it's just
built into the language that you can't
do certain things but even allowing for
that there are there's a whole space of
style space where people get involved
and their existing habits and the forces
of an existing code base have a very
strong influence so let's just have to
take a very simple example I'm gonna
pitch this one up in groovy as it's
syntactically lighter of how we have a
very a very imperative example and move
through to a more declarative view of it
you know this is one of those obvious
standard problems that everybody has
when they're programming in a day to day
basis I need the squares of the first
hundred numbers I mean obviously you
have that every single day while you're
working on your applications but it's
small enough but it's precise enough to
be instructive so what we're going to do
well what we're gonna do is we're gonna
set up an array this we can set up a
collection of squares it's going to
begin with empty and we're going to set
up a counter and we're going to call it
I because we don't want to be too
revolutionary with what we're doing and
we're going to set it to one and then
we're going to iterate round for as long
as that counter does not exceed a
hundred what we're going to do is we're
going to add the square of the counter
to the collection and then we're going
to increment the counter because we're
in charge that's the only way you can
guarantee it's going to increment
properly now you'll notice in that
description it's mostly about state
change what I'm about what I'm doing is
I'm doing a remarkable amount of state
management I'm telling people here's a
thing and I'm going to change I want to
set it up like this and here's the work
I'm going to do on it if you look at it
from an indentation point of view and
this is a very instructive way of
viewing your code the indentation shows
you what is import
or rather it should do if I look at this
the idea of indentation is that you say
if it's indented it's a secondary detail
its subordinate to something else that's
not really what's going on here is there
at the top level what I've got I've said
the three most important things in this
program are the fact that there's a list
of something that begins empty the fact
that there's a counter that begins at
one and the fact that there's a loop
those are the top-level things that's
not really what this is about I gave you
what the definition the problem was
before it's the square of the first
hundred numbers that's not visible now I
can improve this so let's go for a for
each loop and here what I've done is
although I still have varying state what
I've done is I've effectively taken away
the state change from I and you might
say well yes I is changing as I go round
well yes it is but I'm not changing it
what I've done is I basically said it's
implicit in the structure it is a
parameter of the loop it is no longer a
control of the loop it's a very subtle
distinction but a very important one it
affects how you think and how you reason
about things I've also got a tidy loop
representation this one's a lot easier
start with an empty list and while run
through from one to a hundred
adding than the square of the number
from 1 to 100 that's quite nice this is
more declarative still ok so effectively
this is the most Ã©clair ative it's a
it's the idea of take the numbers from 1
to 100 and collect the square of each
one in fact to square it
groobie gives us a shortcut I can just
sort of say that once you're familiar
with that you're familiar with that so
basically what I've said is from 1 to
100 collect the squares of 1 to 100
that's very easy it's almost exactly the
same as the problem description oh sure
there's a loop going on in there but how
many loops have you written in your life
do you feel at this point in your life
that you need to write more loops you
know so I don't know I've got a few more
million loops inside me I feel the need
to exercise those before I die no you're
done you know what loops look like and
you know all of the kinds of loops that
there are there's the for each kind of
loop there's the finding loop there's
our
you've got them they're all there
they're there they were taking up wasted
brains but imagine all the useful things
you could do with the brain space
they're taking up all those images of
cats and memes and stuff like that
okay there's bandwidth being wasted here
so the point here is we're going to
commoditize this we understand this we
unhappy that computers know how to loop
I'm good with that I'm really quite
happy to outsource that now what we've
got here although it doesn't look
immediately like it is the notation is
what is known as an intention in logic
the set of characteristics or properties
by which the referent or reference of a
given expression is determined put
another way the perspective of intention
of prime numbers is you've described
them by their property non trivial
integral factors here are the properties
that they have versus enumerate every
single possibility um typically this is
how you describe an intention this is a
set intention this is the first hundred
numbers written using just regular
first-order predicate calculus X is the
natural number such that X is greater
than or equal to 1 and less than or
equal to 100 and what we're after is x
squared this is a familiar very such
familiar form and there's a highly
declara form such as familiar form that
we tend to write it differently select
from where ok in other words this kind
of logic is something that we've seen
before again and again so if you messin
around with with something like C sharp
then link in C sharp is directly in
there if you're messing about with Java
rate streams it's not obvious that the
language is there because select we
replaced by filter and you suddenly see
the languages there if you don't sequel
and this is blindingly obvious this is
logic programming this is this is the
essence of this what we're doing is
we're defining a relationship here and
we're saying here's the constraint and
here's the things I want from that
select from where plain and simple now
that gives rise in code in most
programming languages that are supported
to the idea of a list comprehension so
we don't call it set intention it's a
set comprehend
or a list sorry a list intention or a
list comprehension syntactic construct
available in some programming languages
freaky agent creating a list based on
existing lists or other conditions and
it's that set builder or set
comprehension notation now I'll switch
over to doing something in Haskell and I
guess because this is a Java centric
conference if it makes you feel more
comfortable we can do exactly the same
thing in Frager which is a Haskell JVM
yes more comfortable good so what I'm
going to do here is I've got a nice
direct form of what I just wrote out and
this is sort of a grooviness to it as
well in the sense I'm able to say look
here's a list of the numbers 1 to 100
and I'm gonna take X from this list and
I'm going to square all of them which is
quite cool that's a simple very very
direct I could write a loop but I don't
think anybody needs to see the loop I
think we're good with that but now it
gets a little more interesting if I have
this kind of declarative approach then
it allows me to do some very interesting
things so what I'm going to do here is
I'm going to shift this I'm going to say
I would like a square of all the numbers
all the positive integers so I'm going
to take the natural numbers which some
people can say include zero you can have
a debate over that the debates over
whether our zero is a natural number our
best hand over a drink you will reach
the conclusion as you reach the bottom
of the glass that emptiness and zero
Ness is a natural state of the universe
disappointingly and therefore it is so I
don't want the zero here I just want one
on words so I'm going to say I want all
of them how big is this set Oh like
really big it's infinite so sure
let's try there in Frager that works so
what we've got here is an infinite list
a list an infinite list of squares I've
got 1 4 9 16 25 36 in toast goes on to
infinity
I'm gonna need a few more gigabytes on
my laptop for that but you don't have to
worry about it it turns out that
Infiniti is one of those numbers that a
number of people are afraid of not an
infinite number of people but a finite
number of people are afraid of but
there's no need to be afraid of it
because you can handle infinity it turns
out that as long as you only look at one
thing at a time you're good just don't
look at it all at once because if you
look into the abyss it will look back at
you okay so just look at it one thing at
a time then you can do it this is the
essence of lazy evaluation don't do it
all at once and that's how we deal with
it so at this point we need a point of
commitment so what we've done is we've
described the problem I don't know I
don't have an infinite loop what I've
done is I've just described here is a
thing it's infinite lease it's
infinitely large what would you like to
look at well I'd like to take the first
hundred thank you very much done at that
point there's a commitment in fact
sometimes the way that people find a
good way of thinking about some of these
things is with a description is a
description is kind of in the
subjunctive mood it's kind of like a
wish it's like I would like you to
consider if there were an infinite list
from 1 to infinity of squares so square
all of those ok and at this point I
would like to commit to the first
hundred and now we'd make it real in
other words we describe the
possibilities and then we collapse the
wave function and we say right I'll have
the first hundred thank you very much
now this kind of thinking is very very
tidy I haven't had to do anything clever
with the code if I were doing this in a
loop form I'd have to figure out how to
break out of an infinite loop or rather
I'd have to maintain the loop so we're
gonna apply this to a real problem yeah
we're going to move to fizzbuzz because
we talked about drinking just now ok
fizzbuzz is a drinking game although I
have seen it described as a game for
teaching children arithmetic I have no
idea what the incentive is for a child
if you've only known of this as a
programming interview question or as a
coding Carter then I've got news for you
it's a drinking game and the idea is
very much as I said here fizzbuzz was
invented to avoid the awkwardness of
realizing nobody in the room can binary
search an array especially after a
couple of drinks
what you do is you count round in a
group yeah one two fears for bus every
time you hit a number divisible by three
you place it with fear every time you
hit one divisible by five its bus okay
for fizzbuzz seven eight nine oops
I should have said fits at that point
you have a drink cause you made a
mistake and the rest of the evening is
becomes predictable yeah but - so so
when you hear anything divisible by
three and five therefore divisible by 15
your place it with fizzbuzz now this is
fairly straightforward - you know to
deal with it it's a simple piece of code
and it has a nice interesting quirky
property you can say well I'm gonna
write I'm gonna run it as an accumulator
I'm gonna say I'm gonna start with an
empty result empty string divisible by
three I can catenate Fears divisible by
five i can catenate buzz and you feel
really proud of yourself for having
solved fizzbuzz and fizzbuzz all in one
go genius but notice there's a really
strong sequential dependency there this
is a very strong state full dependency
you cannot reorder these well then you
want to but this relates to larger
pieces of code there's a very strong
imperative dependency because when we
say imperative there's a there's a
suggestion that commands need to be
issued in a particular sequence and that
is a form of coupling we normally when
we talk about coupling we normally think
of relationships between types you know
this class inherits from this other
class therefore there is coupling from
the subclass to the superclass this goes
further there is a temporal coupling the
sequence is it's critical and there's
plenty of state change going on we've
set stuff up and then just to mess it up
a little bit we say well yeah what if
there isn't a result what if we haven't
got fizzbuzz or fizzbuzz oh okay now we
need to do another action and we'll
concatenate the the string form of the
number so we get one two four and so on
and so it's a nice tidy solution and
actually in groovy we can make it a bit
tidy we don't need to put return
statements in
and we can make it feel a little more
functional the idea that the last
expression is the expression of the
whole block so that's quite nice but it
still doesn't change the fact there's an
awful lot of sequential dependency so
another approach would be to
specifically peel off each branch here
there is no sequential dependency okay
well there's a subtle one do the 15
before you do anything else but the idea
is I don't repeat actions or do i well I
do because 15 is when I'm checking
divisibility by 15 when I get
divisibility by 3 in both cases I'm
checking with respect to 3 it's 3 times
5 so I'm checking two things there's a
kind of that's still at little
dependency there ok so we could try
doing something slightly different this
is exactly the same but it makes you
feel clever ok right because sometimes
people say well you know functional
programming its expression oriented
programming you don't have statements
because a statement is an instruction
you are stating a thing that you want to
do you need to just express yourself
elegantly so you say yeah the ternary
operator I have fully embraced this is a
single expression you feel really
pleased with yourself and your colleague
is still sitting there going like really
I do like the ternary expression but
obviously there is scope for abuse and
then you can I have to elegantly format
it ok let's try something else
ah ok I'm gonna stick with the ternary
operator but what I've done here
by the way I'm not making any claims for
efficiency at this point what I want to
do is I want to stretch your thinking
because sometimes people solve it they
go yeah fizzbuzz is really boring in
which case you have not kicked the
problem around enough ok you can make it
really quite interesting you can do some
very strange stuff with it it's such a
small problem feel free to do that
before you try it on your enterprise
code what am I doing here
I'm doing something slightly different
here I've inverted my model of thinking
what I've got here is I'm going to say
there is a set of numbers that is
divisible by 15 fizzbuzz by the way is
normally defined between 1 and 100 as a
problem
so the approach I'm going to take here
is I'm going to say look there's the
numbers that are multiples of 15 there's
a set of numbers 15 30 45 60 so on if n
is in that set of numbers it's fizzbuzz
there's another set of numbers the ones
that are divisible by 3 3 6 9 12 if n is
in that set of numbers they're still a
little bit of sequential dependency
there but nonetheless because I'm really
quite nice here there's a flow is a much
clearer flow what I'm doing here is I'm
turning the problem round I'm not saying
is it divisible by I'm saying does it is
it a member of this set if it's a member
of this set then it's one of these if
it's a member of that set then it's one
of these this kind of set based thinking
is actually one of the techniques that
you can use to crack certain big data
problems what you're looking at has a
more than one way of looking at a
problem there is nothing more dangerous
than an idea when you have only one idea
yeah amia loggers Chartier said that and
it's a great piece of advice so we're
we're changing the problem frame and
this is much more declarative at this
level here's another one
same kind of idea what I'm going to do
here is I'm going to take all of the
fizzies all of the buzzes and all of the
numbers okay I'm going to say look
fizzy's we've got a and off by one thing
to sort out so I'll start off with an
empty and then I'm going to say how do
we define fears well all the fizzes that
you need between 1 and 100 you don't
need the number one doesn't need to be a
fear so empty number 2 doesn't need to
be a fierce so empty
number 3 does need to be a fizz sofie's
empty empty fizz keep repeating that
same 4 buzzes empty empty empty empty
bus and keep repeating there and then
you combine them so now what you're
going to do is to lookups as we see in
the function I'll have the fizzes of n
plus the buzzes of n and if the number
is 3 you get phase plus empty we're good
if the number is 5 you get empty plus
bus which is good if the number is 15
you get phase plus buzz which is good
but what if it's any of the others the
Elvis operator
allows us to deal with that it's still a
little bit of a sequential dependency
but hey you know we've got something
here that's very simple look up what we
do is we just say if there's nothing
there then take one of the numbers
please which we've converted to string
we've just applied the operation over
all of them and again there's that nice
little spanning operator in groovy star
dot which just allows you to say you
know those loops that you're so bored of
applying just do it you know everybody
knows what you mean if you say apply to
string to every single one of these
that's what we're doing so we're done
it's a very nice simple declarative form
and then it gets a bit crazy I might not
explain all of this one this is a recent
solution that I came across is
originally in Haskell and I translated
it into a number of languages this is
one of the versions of it this one has
no branching in it at all
in other words treat this as homework if
you get your head round it what I'm
going to do here is I'm going to create
a lambda or a block of code or closure
if the if n is divisible by 3 I'm going
to pass in the first block otherwise I'm
going to pass in whatever was passed in
it so in other words it becomes an
identity operation it just returns
itself or it returns Fears plus the
operation that's just been passed in so
we're passing operations around on an
empty string buzz does this as well and
then we chain the whole lot together
through composition at the bottom and
magic happens the data flow and the
control flow are identical the
information flow is very elegant I'm not
gonna explain this further there's a
whole talk in that but this is obviously
a little bit too far okay however there
is something we can pick up here these
are all examples how did I know they
worked how did I know they worked I know
they work because I tested them ok and
here is a declarative approach to
thinking about testing we get very very
used to the j-unit style of testing
which is actually a one level j unit is
very declare
if you offer test names you don't
instruct j-unit to go and test things
you declare the test but it's still
relatively imperative here's a piece of
example data we're going to do this and
then we're going to search something
yeah well here's a mark and we're going
to do a whole lot of stuff for them what
I'm going to do is I something like this
I can take a very different approach I
can declare my intent I can say here's
although here's the whole range 1 to 100
I want the fizzbuzz of everything from 1
to 100 and there are a set of true
statements I can make about the result
and then what I want is that all of the
statements that I make are true and I
can say first of all I'm going to list
off a set of properties ok so what I'm
going to do instead of saying and this
is the thing when people do fizzbuzz as
a coding Carter is a test driven
development Carter they often get the
right result but their tests are
terrible in other words you end up with
really bad tests like tests that one is
one test that two is two tests that
three is faced that's great except that
it's not
that's not very intentional you haven't
declared your intent you haven't stated
the properties of the fizzbuzz domain so
what I'm going to do here is I'm going
to say look every result we get is
either fizzbuzz fizzbuzz or a decimal
string between one and a hundred so I
constrain the results set the next thing
I'm going to do is I can say every
decimal result corresponds to its
ordinal position so in other words the
number 43 should be at position 43 every
third result starts with fizz every
fifth result ends with bus notice we're
now narrowing down describing all the
properties that make fizzbuzz fizzbuzz
yeah this is domain analysis basically
what I'm doing is I'm describing a set
of truths about the domain I'm declaring
it this is a very declarative approach
every fifteenth result is fizzbuzz the
ordinal position of every visited to
visible by three the ordinal position
yet cetera et cetera
you need all eight haven't been able to
reduce it beyond eight but but there we
go and then we can convert it into
groovy and yeah obviously that doesn't
read quite as directly but the idea is
that it's still 1 for 1 there's the idea
of a statement of truth
I'm not immediately suggesting you go
out and throw away your nearest you know
testing framework to go and do this but
what I want to do is offer you a a
bridge to what is sometimes known as
property style testing sometimes an
example based approach is very good is
the one that we want and is particularly
for stateful manipulation to be very
very helpful but in other cases what we
want to do is approach a problem
differently and describe it in terms of
a set of constraints that bound what
we're doing instead of telling telling
it what we're gonna do we're gonna say
here is the thing that we get that
satisfies these is the right thing which
is a slightly different philosophy but
let's return to fizzbuzz let's just see
how far we can take this before we
switch to another thing I want you to
imagine because we've already dealt with
infinity you're doing very well after
lunch I have to say you've already dealt
with infinity so I want you to imagine
there's an infinite number of fizzes
okay this is all the fizzes you will
ever ever need not just the one that I
did before up to a hundred this is blank
blank fears blank blank fears blank
blank fizz forever okay so that's one
infinity you handled the previous
infinity so well I trust you to handle
another one because this is all that
well this is out of range actually come
on speak time no the battery's dead ah
there it is
this is all the buzzes you're ever gonna
need blank blank blank blank buzz blank
blank blank blank buzz this is all the
words you're ever gonna need what do I
mean by words this is all the words
fears buzz or fizzbuzz you're ever going
to need so this is blank blank fears
blank buzz fees blank blank is this buzz
etc so that's three infinities keep
count and this is all the numbers you're
ever going to need 1 2 3 4 5 6
yeah 4 infinities doing well obviously
you need to be able to choose between
them and they we're gonna have a thing
here fizzbuzz that combines everything
and that's going to be infinite as well
so there are five infinities up on
screen yeah who knew that HD could take
that much okay right what I'm doing here
is I'm doing this one I'm doing this one
enclosure what I've got here is I've
defined fizzies as the cycle of blank
blank phys cycle just goes on forever
because of lazy evaluation it just says
if you were to ask me what this was I
would be able to tell you but until you
ask me I'm not going to do any any work
I'm just going to say here it is I cycle
from here to infinity the same for the
buzzes the words well it's a little bit
of a hack here no no it's an elegant
workaround it's not a hack at all what
I'm going to do is I'm going to take we
start off with mapping I'm gonna strip
stringify as it converts something into
a string form and the way that I've done
this is I've effectively mapped straw
across all the fizzes and buzzes what
I've done is I've effectively doing a
zip yeah I'm taking fears and buzz and
I'm gonna go blank blank converts to
blank fears blank converts to fears
fears buzz converts to fizzbuzz blank
buzz converse to buzz
so I'm gonna do all of that and then I'm
gonna replace all of the blank ones with
nil which is null which is nothing you
saw nothing except infinity so now I've
got an infinite number of words and it's
not just black it's null null fears null
buzz fees etc etc now I need all the
numbers well that one turns out to be
fairly easy I take the range which is
infinite 0 onwards but I don't need the
first one so I'll just say the rest I
come on the head and then I turn them
all into strings so it's 1 2 3 4 and
then finally fizzbuzz allows me to use a
little a little anonymous work around
here
I'm going to map it turns out that all
this is an elegant hack mmm yes this is
an elegant hack or when it's presented
with a null or nil treats it as false
and so what I'm going to do is I'm going
to choose if you give me nothing and or
something I will choose or something
now I don't just return true I will
return the second thing so what I do is
I select between the words and the
numbers which is quite nice so now what
I do is I go through if I hit blank the
first word is sorry the first word is
nil the first number is 1 or there's
nothing in the first one so I'll take
the second one thank you very much and
the same for 2 and then I hit 3 words
that's fees and so therefore I take that
one that's the first one that satisfies
the or that's brilliant so now we've got
an infinite number 5 infinities worth
but obviously we only need the first
hundred and so we're done now what I
like about this is that at no point on
the screen do we have explicit branching
at no point do we sit there dividing by
3 or by 5 we've refrained the problem as
a stream based problem and a
compositional one which obviously gets
us thinking in terms of well how far can
we take this it turns out we can take it
quite a long way as William Morgan
observed a few years ago I love
functional programming it takes smart
people who would otherwise be competing
with me and turns them into unemployable
crazies so something I enjoy doing as I
like words I run a page on Facebook or
word Friday and I put an unusual word
there every Friday and then just
linguistic and like other language
related stuff during the week so what I
want to do is I want to present you with
a useful word because obviously you're
going to need this every single day of
the week bike winery coded decimal you
know if you see we can just drop that
into a conversation sometime ok what is
bike winery code of decibel a system of
representing numbers based on counting
in fives with an additional indicator to
show whether the counters in the first
or second half of the decimal range I
wonder where that came from
yeah so where do we see this it turns
out we find in abacus systems not the
abacus systems you give to your kids but
proper abacus systems you get 5 beads
and two beads five beads and two beads
that's that's where this system that's a
bike winery coded decimal system some of
the earliest computers electric
electrical and electromechanical used a
bike winery code decimal before
everybody said you know that's a hell of
a phrase bike why no why don't just do
binary yeah that's as much simpler but
one of the classic ones
is the roman numeral system yeah 1 2 3 4
500 ve v yeah there we go
in fact some people reckon it was
actually based on the hands that you do
1 2 3 normally do four and then it was 5
and then and so on and there's that's
ten that's a hundred and so on so you've
got all these various ways of doing it
but this means we're going to try and
figure out the other great problem of
enterprise computing how do you convert
a number into its Roman numeral
representation there are businesses out
there that are old enough that I can
believe this might actually be a real
problem so what we're going to do is I'm
going to fully embrace the enterprise
programming style hell yeah I'm being
paid by the line of code here there we
go that's what it looks like yeah if you
are being paid by the line of code
ignore everything I've said in this talk
this is how you do it don't let anybody
tell you otherwise
okay but what we do is we see regularity
we see regularity in this how do we
factor this out we've got this
alternating if while structure and and
there's there's other elements there
it's just like can I pull this out well
yes show me your tables what I'm going
to do is I'm going to create a tabular
system I'm going to run through it and
I've reduced the amount and then this is
actually by the way this is a general
approach for many many things if you
actually look closely what you'll see
there is a data there is a data part in
a control part and the data part is
potentially changeable the plug-in
herbal but I'm going to take this a
little bit further we've got a for loop
there I feel that I can probably do a
couple of other things with this that a
little more groovy esque but also move
this away from having control variables
and accumulator variables that we
actually change directly so what I'm
going to do is I'm going to replace my
for loop with a dot each I'm basically
going to say there is a property I'm
going to apply an operation to the table
itself I can apply code and pipe it
through the table effectively each time
around the loop I'm going to pet pull
out a pair of value a pair value in
letters and I'm going to operate on
those and run the accumulator result so
we get
we want so now what I'm doing is I'm
saying the table is the declarative
structure and this is the interesting
thing is when you look at the table you
can see the shape of the problem okay
and what I'm now going to do is I'm
going to pipe data through it bring it
to life so that's what the dot is it
makes it more explicit I can take it a
step further and actually use an
injection which is a fault and I really
do have a pure pipeline there I have no
true variables in the classic sense of
the word everything there all of the
results there are effectively immutable
I take stuff and I created a mini
pipeline where I project everything
through and then it's folded together
and I get the final result which gives
me the Roman numerals as I wanted so is
this as far as we can take this problem
this is already very declarative it's
got a certain elegance to it it may if
you're not familiar with groovy it may
be less comfortable to read than perhaps
one of the two previous versions if you
like we're just tweaking it a little bit
but we've made a very nice pipeline here
I I thought this is as far as you could
take it and then a friend of mine John
Jagger showed me and he'd stumbled
across a solution on the web a couple of
years back did it in Ruby and then I
sort of tweeted into Python and then a
few other languages a very different way
of looking at it that it's not an
arithmetic problem at all it's a
symbolic problem what I'm going to do is
I'm going to turn the first I'm going to
turn the number into I'm gonna use
proper full screen based thinking I'm
going to turn the number into unary
you're not sure what unirii is it's like
binary but without the zero that was one
is I 2 is I I three years III and so on
so I'm going to convert the number into
unary then I'm going to replace all of
the five eyes with V then I can replace
any residual four eyes with IV then I'm
going to row oh this is really I'm not
again no claims for efficiency but wow
this is really easy to explain what I've
done is I've created a pipeline that
structures the intent of the whole thing
I've embedded the day
the whole thing what I find interesting
about this one is again this is
something that I could easily explain to
a non programmer by comparison with the
previous approaches which have an
elegance to a programmer but it's not
obvious otherwise and as many of you are
probably more likely to be doing Java
than groover you'd like to know you can
do this in Java
well yes you can actually you can get
away with it just just about but yeah it
doesn't require too much extra now we
did closure before so maybe I can do
something really elegant in closure
because obviously everybody says well
what about real functional programming
you know full-on functional programming
yeah sure let's do it let's resize that
it's kind of like AB you know this is
like geese migrating in the winter it's
sort of a beautiful flocking formation
and it's like yeah that's what they mean
by functional isn't it everything's a
function and you call functions and you
take the results of functions is like
write default functional programming out
in the box makes a complete pig's ear of
this but that's the point is that nobody
talks about functional programming out
of the box they adapt it they they
recognize there's more to it than just
function application so let's try a
different approach here we've got
structure that is based on function
composition ok that's what comp is up
there for from what I can tell certain
languages struggle with vowels and extra
bits in words so it's it's it's it's
definently we're short of the right
letters and comp instead of composition
and food instead of function and func or
whatever but nonetheless we have this
idea we take Niwas it and what we've got
here is a composition what we do is
instead of saying apply the function
create a composition in other words
you've got to reverse it a bit first of
all we do the join we repeat the number
we repeat I for a particular number we
join it all together that gets us on
unary number and then we push it into
the resulting composed function that is
made up of all these there these funds
are our lambdas if it makes you feel
more comfortable and replace numerals I
I with V III yeah brilliant um I can
tidy it a little bit I can make it a
little bit shorter that's kind of
looking liberal a little bit so looking
a little bit more like a table it's
looking more like a structure than a
doing thing than an application which is
getting close but I still unhappy with
the fact that by default function
composition happens in Reverse because
if you want to understand this if you
start reading from the top then this is
the wrong place you need to start
reading in the bottom and you get a lot
of functional programmers that have this
kind of revisionist hebt mindset they
say oh yeah it becomes natural to read
from the end no really it doesn't you
know if you are brought up in it you're
using a language you are using a system
of editing and a system of symbols the
Roman alphabet that is based on top down
left to right okay
fortunately there's enough compositional
structure in the language that I can
replace this with that and I'm also
going to change the replace that I use
and we recover something very much like
the groovy version we can act that
little arrows of a kind of threading
operator it allows you to bind things in
a pipeline and this recovers an
intention here that the replace almost
disappears as noise and we're left with
a table of structural transformations
and so therefore if you like that the
powerful side of functional programming
is not just the functions it's the
ability to compose and restructure and
certain things but it is to recover this
declarative idea the first example I
used with closure was not particularly
declarative at all which is why I say
sometimes not all functional programming
is declarative sometimes it looked in
the sense that we want now all of this
is heading in the direction that I need
to say obviously something about Java
rate streams and so I will do this by
picking on an example that I I I think
is it's an interesting one it's a zero
turn around came up with their cheat
sheet earlier this year for Java rate
streams and there is a sort of elegance
to this but I think it's quite quite
nice and it's the point that when you
are able to hide the mechanics
and state the effect the very simple
effects or desires that you have and
compose those together in a structure
where you see primarily the intent and
then you say there are details and I
don't need to worry about them and a
good stream based composition will look
like that a poor stream based
composition will be just as mysterious
as anything else and so it's not
necessarily any worse but there was a
but there was a bug there was actually a
bug here and so I tweeted and it got
fixed did you catch that watch again and
it got fixed that's not right in fact
the problem is the fix is also wrong but
for a different reason now what I'm
interested in is the fact that it was
obvious by reading what the problem was
and it was partly because of the stream
structure so let's revisit this let's
zoom in what is the challenge here the
goal set is get the unique surnames in
uppercase at the first 15 book authors
that are 50 years old or older I put a
question mark there because is this what
this does this is the first thing they
did let us just imagine that a library
is simply a collection of books which
seems you know kind of reasonable a
library is a collection of books take
take the stream of that map every single
book replace every single book with its
author
okay so we're interested in the authors
pass that on filter it's a little bit
ambiguous select or filter in because
sometimes people wonder am i filtering
in or filtering out but select for every
author that you're getting only select
the ones where their age is 50 or over
then limit that to 15 get the surname
shift it to uppercase uniqua Phi it and
then get a list out of it now the
problem is that doesn't get the unique
surnames in uppercase of the first 15
book authors there are 50 years or older
what it does is it gets the authors of
the first 15 books if you have the same
author for the first 15 books you
haven't got the first 15 book authors
you've got the
a very subtle linguistic thing you've
ended up with a list of one already
rather you're going to reduce the one
it's gonna be the same author you
haven't eliminated duplicate surnames
you've actually eliminated duplicate
authors not quite right so let's look at
the second one well the second one what
you've ended up doing here is you've
moved in a uniqua fine but you've ended
up with get the first 15 unique surnames
in uppercase of the book authors that
are 50 years or older yeah we get all
the books we get all the authors 50 or
over we get the surnames shift to upper
case then unique refiners that's the
first 15 unique names on your bookshelf
if you happen to have multiple authors
who have the same surname then actually
you've not quite met the specification
it turns out the correct solution is to
uniqua Phi in two places go across the
bookshelf go across the library get the
book authors Uniqua Phi those now we are
dealing with unique book authors doesn't
matter if you've got five books with the
same author you've only got one author
now so Uniqua Phi the authors limit that
to 15 then shift surnamed another and
then unique Rifai that and finally we
have the right result now I mentioned
this one to Trisha ji so when we do a
version of this and she's next door
funnily enough talking about refactoring
to Java right and she said Jen will be
really good as if you could show the
full version of these so let's show the
full version because the point the
observation that's been made here is
that simple filters that can be
arbitrarily change are more easily
reused and more robust than almost any
other kind of code you can see more
easily whether or not something is right
or wrong let's try that with while loops
and things yeah it's not going to fit on
that's the first thing you notice change
the font size hey right there we go so
we've got okay that's the first one this
was the second version and this is the
correct version can you see the
difference
I mean obvious isn't it no it isn't you
have to go into everything you have to
look up closer at all of the detail
before you figure out the differences
between them but also
notice there's a fundamental shift in
the style between there and there that
was actually just moving distinct
further up or down that analysis effect
from a coding point of view if you ever
wonder where legacy code comes from
it's the shear resistance of a piece of
code to water to being changed into
something else it's just like you say
I'd really like you to do this and the
code is there like a toddler going on no
the point there is you want to move to a
position where it becomes easy and what
we're saying here is not simply that it
is easier to see is ultimately easier to
work with
d-damn clearly the pipeline model goes
back a lot further how much further
Oh 1964 further Doug McIlroy came up
with the whole idea of pipelines in 1964
it wasn't until about 1970 and UNIX that
it was fully adopted and Ken Thompson
said you know what we're going to use
the pipe symbol and the rest is history
but there's this idea he said look we
should have ways of coupling programs
like garden hoses screwing another
segment when it becomes necessary to
massage data in another way and he
unified this with IO it's a very
profound idea very simple yet this
compositional approach allows you to
have an embedded imperative model
because every unix process is imperative
but to chain them together in a way that
is surprisingly stateless and highly
declarative you can reason about it very
very easily so just for a bit of fun I
did have a go at this I thought you know
what I wonder if we can actually do the
Roman numeral problem just using bash
the answer is yes now actually the
answer is always 42 and it turns out
yeah I create the first two lines there
it's a little bit subtle the first two
lines but nonetheless I create a simple
unary representation and then I use a
declarative approach regular expressions
they were at the beginning and they come
back again and I replace everything and
suddenly I've got Roman numerals so it's
not about the Roman numerals it's not
about fizzbuzz it's not about the
numbers 1 to 100 ultimately the advice
that I'm trying to offer here is the
advice they are more Leonard
the author offered people when you are
writing code you what you're looking for
is a style that allows you to leave out
the bit that readers skip the noise the
mechanics the mechanics is all necessary
this is the ultimate message of any
abstraction is you want to abstract away
stuff but the declarative style is is a
way of thinking as well as a way of
expressing yourself that is less about
the doing and about saying here is and I
connect that with here is it's about
emphasizing the relationships between
things it's not simply a functional
approach and it's not simply pipelines
I've chosen that as a way a method of
exploring but it is about relating the
parts rather than say here is the doing
this anyway I hope that has been useful
and waking you up thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>