<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Hitchhiker's Guide to the Functional Exception Handling in Java by Grzegorz Piwowarek | Coder Coacher - Coaching Coders</title><meta content="A Hitchhiker's Guide to the Functional Exception Handling in Java by Grzegorz Piwowarek - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A Hitchhiker's Guide to the Functional Exception Handling in Java by Grzegorz Piwowarek</b></h2><h5 class="post__date">2018-03-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/919dHYHldkc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay hello everyone its 330 times to
start so um thank you very much
basically for inviting me here for the
second time I really enjoyed the
conference it's a really good source of
knowledge for our viewer right here so
my name is Rakesh Pavelec I'm I come
from Poland were so I work remotely on
Malta I'm a trainer I do some open
source I write blogs and this kind of
stuff so today we'll focus we'll we'll
explore the exception handling but from
the functional point of view so at the
beginning we'll chit chat a bit about
exceptions itself then we will kind of
revisit static typing and type driven
development and eventually we'll go for
some functional programming ideas like
optional try and either for the sake of
error handling so already quite a long
time ago because well this is the quote
from the post from 2003 quite a long
time ago people started noticing that
the mechanism of exception handling well
for exceptions try catching them well
can be a source of a problem because
well if you jump you create abrupt jump
it somehow looks and behave similar to a
go-to statement that venkat these a few
hours ago
so basically the problem with the
general exception handling is that they
create unexpected exit points so in the
world of functional programming you can
pretty much imagine functions well
especially those are referential
transparent you can imagine them as
pipes as something going something goes
in something goes out nothing happens
along the way well at least in the pure
world but so if you know that the only
possible output of a function is what
there
at the end of the pipe then basically if
you observe it if you keep looking at
the output all the time you should be
pretty safe you know because you you can
just handle the values that go out but
with the whole like exception handling
mechanism kind of makes this pipe a bit
of leaky you have holes and exceptions
that create unexpected exit points that
can jump out of different various spots
and mess up your software so they behave
like go toes also those paths that are
created by exceptions are also mostly
invisible in the surf code and often
it's quite it and it's quite easy to
lose them if you go I think and what's
quite interesting throwing out creating
exceptions doesn't come for free
actually throwing it's quite free the
interesting part is that creation of
them is quite expensive and do you have
any idea why this might be yes exactly
i we all know you knew that Mario so
basically when you think about an
exception it can be basically well you
might think about just just a POJO that
that can be thrown but if you go and
inspect the class itself you will notice
that there is one very interesting
method in there a feeling stack trace
that's basically responsible for
collecting all stack frames so that
eventually they can explode in your face
if you don't catch them so basically if
you want to basically read more about
that there's a very cool write up by
high in sky boots cost of causing
exceptions but here comes normal modern
the guy from Nettie and he starts
benchmarking stuff and sees how actually
there's the process of collecting stack
traces and instantiating throwables
affect the performance so he tries few
different scenarios in the first one he
is just throwing and very instantly a
ting an exception and well pretty much
in the loop and the second one she comes
with an idea
well since I'm throwing the same
exception exactly the same context why
not simply well instantiate it once and
then cache it and just keep referring
that but ultimately why not if we know
that if we if we know the particular
context where the example exception can
be is frown why not go further and make
it totally stack less so get rid of
stack class get get rid of the stack and
make a static instance that you could
riff row and those are the results here
and if you can see this is operations
per millisecond on the left side it's
not a mistake there are actually bars
that are that are very low it's less
than 1% of operation per second and on
the right side you have the comparison
with stack less static exceptions
exception being thrown in the same
context and well obviously you can go
there and track the details but you can
see the difference is quite huge so if
you keep throwing out of exceptions it
can actually damage your performance of
your application but however if you
throw that many exceptions you might
have other problems to deal with first
than the performance issues so not all
languages feature standard exception
handling
well we've been working in java for many
years so well it would be hard to work
without that if you think about this but
other languages are fine without it so
for example go approach exception
handling in such a way that exceptions
are enough in exceptional this is just a
value as anything else
well you can be returned can be passed
and there is no any abrupt jumps there
is no like bypassing the normal control
flow or anything this is just a value
that gets returned from a function go
makes it slightly easier because it
actually can return more than one value
from each from each method so for
example if you define a simple method
called foo that accepts a string it can
return more than one value it can return
a string and for an error object and
error can link in such situation is as
easy
basically doing an all track well you
might have expected something more
spectacular here than an old track but
let's spend a second and appreciate the
simplicity all of that function gets you
call a function and it returns two
values and you check if it exists which
will check if an error exists or not and
continue as nothing happened there are
no abrupt jumps no anything
everything is super predictable but
actually you might think but actually
there are exceptional situations that
you might want to signalize somehow and
it turns up obviously go has such such a
mechanism but this mechanism is
dedicated only to situations where there
is no return back if you if you start
panicking
you don't expect your users to actually
recover from that well it's actually
possible using the third methods but
probably you shouldn't do that but
meanwhile in Java people start
identifying multiple different empty
patterns of exception news
well internal abuse of exceptions and
it's not the point now to just go for
all of them and this Java totally it was
that exception handling mechanism that's
in Java it's solved certain problems but
also started encouraged different ones
so now we are today on a basically Java
conference so hopefully I don't need to
encourage anyone to try and like static
typing and statically typed languages
but since there's quite a few blocks or
surfing around kind of dissing this idea
recently let's try to revisit some idea
some good points that we can get from
static typing so for example not a long
time ago Uncle Bob posted a and block
this in kind of Kotlin and Swift that
they are very to mark statically typed
and that in the perfect well in the
perfect world the whole like
responsibility is given to
so you don't need to deal with the
bureaucracy of types but if you want to
enforce certain contract you would write
a test instead so here comes the
question how much time do your tests run
assuming that you have full like
necessary coverage how long do they run
you know five seconds ten twenty one
minute ten minutes I've seen cats
running for two hours but personally
after like 10 seconds my attention is
some order after 10 seconds I'm already
on Twitter or Facebook so this is this
is not ideal so by the way do you
remember the basic idea of agile
manifesto the main tandem the most core
value of that the biggest value of a
drive approach is basically shortening
the feedback cycles that you get with
waterfall you go you sign the deal you
go somewhere for five years or well or
longer
then you come back you present something
to your customer and customer doesn't
recognize what it is I don't want to
swear here so basically by going agile
we in started introducing shorter
feedback cycles to our normal
development everyday development stuff
and basically if you leverage type
driven development and static typing
properly you also can shorten your
feedback cycles from well 10 seconds 20
seconds few minutes basically to to zero
because whenever you write something
that's that's wrong the compiler will
punish you almost immediately so this is
something worth going for that it's like
having properly constructed a type
safety stronghold it gives you an
ability to be much safe it's like having
running tests all the time we know
contract test the test if you're
returning what are you supposed on
you're assigning to another variable
what you are supposed to but actually if
you are dealing with more dynamically
typed languages it's very easy to
benefit from their dynamic Ness because
if you want if you go to JavaScript and
you want to
leverage dynamic Ness you don't write
types well and then then you profit or
not but in Java if you own statically
typed languages if you really want to
leverage the power of the type system
you need to invest into that into spend
time on building this type safety
stronghold that saves you from different
stuff and this is well this takes effort
this is why we often end up with
situations like this with code that is
basically string ly typed and not
strongly typed obviously right because
name surname address phone number eight
those are strings after all right but if
you will ever age the idea of type
driven development and actually try to
save yourself from unwanted for example
reassignments because here you can
easily pass an age as a surname and
everything works everything compiles
well obviously you can write a test for
that if you can assign a to number but
how many tests would we need to write to
like have to be really safe about such
trivial mistakes so like the if you want
to leverage this type driven development
idea you need to craft your own types
with some additional logic additional
checks that somehow prevent you from
doing stupid stuff and for example in we
did that in a few projects we even like
encapsulated simple IDs with simple
Long's into into separate classes and
it's solved and it's saved us so many
times from doing stupid stuff like
passing an ID of someone of awesome
object to to another one by mistake and
actually what's quite interesting is
that Java a few years ago started
actually noticing that you can solve
problems using types and introduced
streams optionals comfortable futures
which basically are also a cool idea
that in kind that allow you to
encapsulate some behavior and kind of
not worry about that when you interact
with the API
so if optionality could be for example
expressed using the type system why not
apply the same approach to exception
handling so by the way this is those
ideas that I'll be showing today
they are very very generic they can be
applied to nightly they work in Scala
they work in Java although in Java you
might want to need you I need some
additional libraries to do that if you
don't want to craft those tools by
yourself so there are tools that are
really worth worth attention there is a
waiver in cyclops
today and we are focusing on waiver
because the syntax and it's highly
inspired from scala so all of you guys
at the tried Scala you will find
something very similar looking there so
the first idea since we we express
optionality using optionals why not
create something by analogy something
for exception handling so there is
something like a try which is another
similar concept you have you can
encapsulate the whole exception handling
it too well a type that expose a certain
API with which you can interact and
pretty much not worry about like like
try key trees and this kind of like
crazy logic just interact with the API
for processing the exception so for
example if you'd like if you would be a
consumer of such an API that that
returns tries you could imagine it's
like this let's have a look at the
starting point starting point would be
to have like what we do right now quite
often so let's imagine a method that
returns certain search results and it
froze an i/o exception because it can
happen some order so in such case if we
wanted to go try another tree - that
would look like it would not have the
frost there any and anymore the return
type would be wrapped into a type that
basically serves as an auto
documentation and tells you this result
well can not can not be proper
there can be exception Sutton can go
wrong so you need to prandtl it properly
and now from the consumer side when you
are running such a method you get all
this you could get all this fancy
familiar API that you get for optionals
and streams that you should be all
familiar with already because
it has been held for four four years
right now so for example the cool thing
about this it is purely declarative so
if you can see here there is no
mechanics there is no if else's there is
no triquetra snow direct instructs to to
your language you are you are pretty
much there the pre-exposed api allows
you to pass behaviors straight to the to
the try object and the cards we specify
what you want to do with the under eval
underlying value if it exists or not so
for example you might want to perform
some action you might want to check some
additional conditions you might want to
log something when something goes wrong
and maybe for example you know how to
recover from certain cases for example
you know from our exception here or
maybe no such element exception you can
still do that and get right on the right
path and eventually at the in the last
line you can if not is something went
wrong you can for example specify a
default value that could be returned in
case something gets wrong so if you've
seen optional Sandstrom API if you are
familiar with that or if you are
familiar with other functional languages
you can see that this is this should
feel pretty familiar because the map
filters flat maps you will find it
everywhere except comfortable future
because support somehow they named it
differently they're funny people okay so
basically if you go for the API you will
see all familiar methods you will see
maps flood maps filters or else's all of
those are for example in optional all of
those are in stream API and they work
just kind of the same way but you can
find also a very specific method
dedicated to exception handling for
example you could find something like on
failure on sex's recover and many others
I don't want to go for the API you can
you can read about that the point is you
will find different methods in different
tools that you that you that you will
want to try there are different tools in
Scala different in cyclops different in
a waiver if you play with cotton and
arrow you will have other methods there
it's not the point to go for all of them
it has to be aware
what you can find there but what's quite
interesting is that it's not only quite
interesting to interact with such
objects from the consumer side but it's
also quite handy from the producer side
when you're producing result and passing
to someone to consume so for example
let's imagine that we want to implement
the previous method gets those results
that was shown a few slides ago so let's
say that we will base our implementation
or on two different methods we'll use
method get from Google that can throw no
such element exception and i/o exception
and there is another method that we can
fall back to is get from Target ago and
this one doesn't throw no such element
exception is just froze iOS exception so
if you would like to implement those
methods you would need to first things
first
put your method that can throw an
exception into the try object of course
you don't want to by mistake run it and
pass result there because well everyone
was evaluated an exception might have
been thrown so if you see in Mario's
talk just just before mine you can see
an idea here that you can basically use
a supplier to make everything lazy and
pass a behavior to a try object and now
everything is lazy and now you can if
you pass the behavior that the try needs
to run inside now you can declaratively
specify what you want to do so get from
Google Frost no such element exception
froze IO exception and now but wait a
while no such element exception ok why
does it need to throw another shippment
exception if there is no such element
found no elements there why not return
an empty list so we can recover from
that we use recover no such element
exception class and recover with an
empty list and after that the whole
processing behaves like no exceptions
were thrown but by going into the source
code we inspect and we see that actually
the method can throw NSA forbidden
exception but well it's verbal forbidden
it's also no results so also again we
recover and default to the empty list
and at the end we specified that
if something went wrong along the way
let's try to fall back in to get from
doctor go it then you can repeat the
process basically
and compose it with another try and pass
it over to the consumer what's quite
interesting is that sometimes you might
end up stations where you will want to
try compose multiple objects not for
example multiple tries and just like
with optional eyes and stream sometimes
you might end up with for example
optional from optional or stream from
stream or try from try you might think
optional from optional it's a great idea
because well you are double safe right
say same weave same with trys okay well
if putting something once to a try
object is well quite safe why not do it
again right now actually it's quite
cumbersome doesn't give you anything and
then you keep adjusting to keep and
packaging them like those Russian
matryoshka so in such cases whenever you
get into situation where you start
nesting stuff you need to remember that
there is a dedicated method from that
called flatmap that help you solve such
a problem also it's quite interesting is
that if you use algebraic data types for
implementing those those types like try
or option you can use them in a very
nice way with pattern matching this is
how it looks from Waiver it's not the
well it's not the most beautiful pattern
matching syntax I've ever seen actually
it's amazing that works but we don't
need to worry about that you have other
tools is the same concept you can be
applied in Scala and what's quite
interesting is that I think not in Java
10 but in Java 11 will have pattern
matching in Java so there we no need for
that for like external libraries anymore
and by the way do we always actually
need to throw exceptions so another
approach will be to actually go back a
bit and try to represent some cases
without throwing exceptions and using
for example options or empty lists
instead so let's have a look at two
methods that we can find quite often in
libraries
now spring repositories and so on so
imagine method called find one that
froze no such element exception imagine
for example integer parser that parses
it from string and froze number format
exception but well we can go try okay
because we read know that that it's a
good idea to remove froze and
encapsulate into a try
let's do that okay but try still allows
us to handle and the underlying
exception and let's actually think if
this is not the case of being able to
with excessive and creating forcing
people to deal with a little bit too
much bureaucracy because actually no
such element exception it doesn't have
any meaningful message in itself okay
then the object doesn't exist okay you
can pass a magic message to an exception
but still we we pretty much well dude
your object doesn't exist same might be
with the parser for example in some
cases you have well net number format
exception but you don't get any me who
makes meaningful message what went wrong
what where worse when per word parser
found a problem so in such case why not
actually drop the exception handling at
all and use optional and try to handle
absence using options and not exceptions
or not even tries it's much easier to
use and your users still have a choice
what they want to do because if they
want to throw an exception they can do
that very easily with options and what's
kind of quite scary if you if you go for
to github and do this very naive search
for certain lines you will see that this
is it be used a lot because in how many
I mean in common situations would you
alike would you want to throw non-immune
or such element exception right quite a
lot of them so but sometimes we might
want to well we saw that go has some
good ideas so why not try it well to
this except normal like exception
handling and use actually error objects
so in such case would
to have some certain way of returning
more than one value from a function and
we could do that basically using tuples
and it works but actually it turns out
that there is it's not quite perfect
tuples work fine if you put non nullable
values inside and suddenly when you
start doing all this new checking well
again we are we feel back home in the
java world because well suddenly of
those overwhelming new tracks everywhere
but there is a way to handle that in a
much more neat way especially for such
use cases the tool called either exists
and actually this is the ultimate
solution try exists basically as a glow
for Java world because if you if you go
to the purely like you to PN functional
world there will be no exceptions there
so why wouldn't I try okay in a purely
functional world if there are no
exceptions there so in a purely
functional world you would use either x'
and keep returning objects representing
something so here it is it's available
in scala waver and in many others and
but how do you use that so the main idea
for either is that it's it can hold
values of two different types one or the
other never both at the same time so
whenever you return value it can either
hold a successful result of your
operation or some object that you decide
to pass there what's what's super useful
is that either is a very general purpose
tool so the tool doesn't you don't need
to use that for exception handling you
can use that for whatever else you want
for example you might want to well model
you might want to model alternate
business logic okay you can do that with
either so you don't need to use this for
exceptions and now since you have two
objects there need to remember that by
convention the right is a success and
the left is a failure
and now here unfortunately there's since
this is very generic tool we don't have
the API is not that fancy
okay you won't have that only
specialized methods as in try stirring
optionals so for example if you if you
need to instantiate them well you have
very simple method you just return left
or right as you need but now since the
either is a general-purpose stuff
imagine you have optionals you have
tries and they are always biased towards
one of the cases optional is biased
towards will existence so if you call a
map filter or flat map on an optional
that exists those methods will be called
on the non the relying value but if you
call them on an optional that is empty
nothing happens
same with try if you call map filter or
something else on and try that was
successful
those method will get called and
something will happen but if you do the
same for try that worse failure it will
short-circuit basically the interesting
part and not doing all those methods
along the way but either is a
general-purpose stuff so you don't know
which on which side there is the value
you care about so you need to be able to
specified it somehow and this is why the
concept of projections is introduced so
whenever you want to interact with any
of sides of either in to create a
projection first so for example if you
care only about stuff that was on the
left side do you create the left
projection and then if you call maps
filters and so on those this projection
is biased towards the left side so if
this value is active if the either is
actually left it will get those methods
will get cold but if you made that
projection and either is right
underneath those will not get cold same
in the other way around if you return if
you make a right projection but if it
turns out there underneath you have left
nothing happens and so on and so on
obviously you can find there very like
also methods that work without doing
projections but they can be quite
cumbersome to use because sudden
sometimes you need to pass more than one
lambda
and this can get note that readable
after all so basically if you want to
work with either you need to create your
own error objects so certain error
object can be as easy as a simple as for
example object case class from Scala
containing and message and for example
an HTTP response you can think about
that as a POJO with letter setters
equals and so on but unfortunately we
are in the data world so we need to
write much more code and oh my god if
you compare this to to Scala that gives
you only one line you could squeeze in
40 first color case classes in there
that's that's quite a lot anyway drug
the side let's have a look how would it
look like in practice
so let's revisit the example we've been
playing with since the beginning today
so we have to get search results that
return try and try holding our list of
list of links but now if we wanted to
leverage our own custom error we would
create an either put the on the left
fetch error and on the right side list
for with URLs and that's all and now
let's have a look how to actually
interact with it so you call get search
results you obtain an either object and
this point you have no idea what's
inside and if you want to process the
result of the operation you make a right
projection and then you keep going just
like with option house try streams and
so on you leverage this melodic syntax
to to process the result you got and
then if you are interested in errors you
may collect projection and apply exactly
same concept so the most important thing
to remember about either is projections
if you got the concept I'm already happy
but either can be used not only for
exception handling so since it's so
generic for example you can use it to
model a model alternate alternative
paths so for example imagine as some
internal library that resolves DNS by
calling for servers so what might can
happen you call it in a server and it
can either
for example we give you a well it can
call on the DNS server but for this case
assume that that it can return for
example the address of another DNS to
hit or a value itself yeah it will work
for that just fine and actually if you
start exploring Scala code you will see
for example that Scala uses it
everywhere so for example this is a very
interesting example of tail call
optimization and then in Scala and they
use others for representing the future
tail calls and so either can either give
you another call all the actual result
if you were on Mario's code I mean
presentation you could see how it was
could be implemented in in Java so the
question is what if your language
actually Java doesn't actually support
that well the most obvious well you
could obviously implemented by yourself
and we actually did some long time ago
we use that approach but now since you
probably since well some someone else
did that you can for example use waiver
dot dot IO which gives you not only all
those tools but also persistent data
collections new functional interfaces
and so on this is just a small piece of
the whole cake and what's most what's
actually the best thing you can do is
actually apply some pressure on Oracle
because technically technically all of
well community can influence and take
part in the java community process and
if you remember for example Java util
date did you like it okay so there was
something like a draw the time most of
us would use that and all those ideas
got sucked into a Java and we never have
Java time I think same with lambda
expressions they started as project
lambda right that got sucked again into
Java and I remember mark Ranko
saying like six years now at nine oh he
was key kept saying that every three
years for a long time the driver will
never get lambda expressions but we got
that so you can apply some pressure
pressure on it so the key takeaways for
today would be well we criticize some
exception exception handling but it is
not that bad it actually works pretty
fine if you don't expect people to
recover from that
so use exceptions for only exceptional
situations well naturally this is the
case well the best good practice that
you can apply here is to use common
sense because sometimes you might need
to do control flow with exceptions but
generally you shouldn't so if you want
to replace your standard exception
handling we you can use try easily to
represent value functions or that can
throw exceptions and then leverage is a
very cool API for dealing with actual
exceptions whenever you are throwing a
no such element exception or something
similar you might want to reconsider
your life choices and try and think how
to express absence in a kind of
different way in this case it's optional
it's more than enough to signal to your
users that that the object is not found
in this case your users have a choice
they can either like unpack optional for
exception do whatever they want and for
more generic use cases you can use
either that can involve use but will
work fine with customer objects or for
modeling alternative paths but actually
it honestly it's quite hard to fully
like implementing the world of Java well
because obviously you depend in practice
you depend on external libraries they
use exception handling so if you don't
want to put Everest everything behind
your own facets it would be hard to use
either and without mixing few different
approaches but you can do this with try
try is very easy to it can be added
pretty much everywhere easily without
messing up everything around also
I think that the waiver library gives
you all of this stuff and it's very
worth looking into that because it
brings as many good ideas from Scala and
functional ideas as possible to Java so
thank you very much I hope I sparked
some ideas into your heads and thank you
very much we have some question time
well it depends how you define what's
wrong okay for example if we are talking
about representing absence without
exceptions actually sending an exception
is it's not like something went wrong
because you send an exception to
signalize a perfectly valid use case
because you are looking for something
and it doesn't exist so probably this is
not a really exceptional situation but
one of the business cases that we need
to consider you know the real
exceptional situation is when you for
example try try to read the file
obligatory file and it's not there or
something like that so in such cases
there is absolutely no reason to use
exceptions for signalizing that because
this is not something went wrong it was
one of possible scenarios that you
should consider so this is basically the
idea well and try if you want to use try
obviously this is how you represent that
something went wrong you signalized by
using a type system you see it's an
outer documenting type you send someone
who receives a try object someone needs
to refill the situation it's like oh I
gotta try
so something might go wrong and now the
API is constructed in such a way that
you actually all the time that you know
that something goes wrong and you can
pass functions that can access that
exception that went wrong so it's all
encapsulated and it's not like I've used
losing information
okay thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>