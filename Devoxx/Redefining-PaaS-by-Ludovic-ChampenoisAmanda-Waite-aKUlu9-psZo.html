<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Redefining PaaS  by Ludovic Champenois/Amanda Waite | Coder Coacher - Coaching Coders</title><meta content="Redefining PaaS  by Ludovic Champenois/Amanda Waite - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Redefining PaaS  by Ludovic Champenois/Amanda Waite</b></h2><h5 class="post__date">2015-11-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aKUlu9-psZo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning it's 10 minutes before noon
so it's still the morning thank you for
staying that long this is the last
session of a very successful a week at
devoxx so we're going to talk about the
the Google cloud platform and how you
can use it to to deploy microservices so
I'm literally from Padua I'm the tlm for
java app engine so basically TL means
i'm coding technique and manager is i'm
trying to manage people that are much
smaller than I am who are developing the
VIP Engine Java runtimes and SDKs so I'm
located in SF this is a view of my
office next to the bay bridge and you
can follow me on Twitter or Google
please google+ if you have google press
hey guys i'm a 90 wait I'm a developer
advocate I work on Google cloud platform
my role is so kind of make the cloud a
better place for developers I sort of
put in my tagline anyway so we're
working with the product things to build
better products and to get your feedback
on to what we're building to make sure
we're doing the right thing I'm based in
London and working for google for five
years I don't have a picture of my
office berger my office is nice as yours
might wild I'll think about it my office
is not in service connected to the cream
h of the Queen back and polishes that
you might my office you can find me on
touch many ways from Google+ or at set
go and I'm going to go and shoot off and
rescue ludos power cable yeah lost
somewhere so we're going to start with a
very simple application you know the
very famous guest book I guess if you
have been using App Engine you know
about guest book we have this
application written in Python go Java
all the wrong times we we deliver this
is what the you I would look like so you
can you know login and enter a message
with your name okay so if you dip dive
too
look at the different services that this
simple application is composed of you
can see create service to create a new
new greeting you can see the hello world
saying I mean free printing whatever
whatever welcome message for the new
user and then the service retrying
retrieving or the list of current
entries okay so usually you write this
code in one single application okay so
the point is not really to to to to
exploit this app in multiple but try try
to find the logical services from a
given app okay so basically the UI is
composed of I mean is interacting with
two services LOL service the guestbook
service and those services can rely on
shared resources like MySQL or Cloudera
store as well as ready ready for caching
or men casual store okay so I'm going to
talk mostly but Java because this is
what I'm doing at Google but this can
apply to two other of the runtimes as
well traditionally you are supposed to
package your application in a Java EE
easier ear file or war file with
potentially a multiple multiple jar
files inside the application okay and
then you you were supposed to deploy
this java ee web application or EF file
to to a cloud provider a platform as a
service cloud provider or like App
Engine and now we you can do you can you
can do it in two ways I mean the sandbox
model which has been out in App Engine
since 2009 so very very old platform as
a service as we going to see now as a
new
the new wave virtual machines and what
you really want is once your application
is deployed you want the platform as a
service to scale it from zero if you
have zero cursor moves to a thousand of
potentially thousands of machines to
serve your traffic for example snapshot
application is using App Engine mostly
the java runtime and have more than 800
million customers sending pictures or
now videos to each other so how can you
better design your application in a more
more easy to maintain and easy to deploy
a way so this is how we were going to
try to map microservices concepts and
principal with what the cloud platform
today from google can can can give you
ok so we have seen the very simple
application guestbook you can release it
as 3 3 modules or three microservices
hello world service guestbook service
and then the wrapper with ease which is
an adventure ok it would be maybe better
and I think you have seen if you have
seen that most of the microservices
talks during this week at devoxx the
trend is really there people do not
really want now to package the
application in a web application or
enterprise archives but they won't read
to start a java mayne ever mayne program
using a jar ok so that would be really
need to be able to deploy those services
in an independent manner ok if you if
you follow the spring good guys I mean
they are saying major not war ok so this
is from Twitter in may 2015 quite new
even though spring boot was there before
but this is this is their motto and i
think it's it's a important message
today make sure not wars and i'm adding
and
we'll see how ok so i will not deep dive
in microservices diamond description but
it's really a new style or emerging
style to develop module applications ok
so you are trying to decompose a large
application potentially tens hundreds of
services into independent parts that
each each of them can can have its own
responsibility ok and micro service can
either be interacted with an user or
another microservice and this is why api
and contract between the services is
very important to define so you want to
define a strong contract between those
layers and the reason why you want to
cut your big application into services
or microservices you can now deploy
those services independently ok so you
can evolve your application in a much
faster and easier way because you just
read apply a small component of your
application assuming that you do not
break compatibility of the contract
between those services so basically you
can deploy independently service you
cannot also versions or service those
services ok so if you want to try a new
version of a service you can push it to
prod and in fact this is what Google is
doing every day you don't even know it
but any time you use a Google product
whether it's google com or the console
or whatever gmail ok some of you are
using the latest build from from the
night ok and sometimes it's failing you
you say well maybe you don't know why
but you reload yet the application and
then you are eating maybe the real
version not the canary version ok so we
do that constantly at Google and the
cloud platform allows you to do that as
well using a be testing and an treasure
and traffic splitting in App Engine
also each microservice or each module as
a better I mean independent logging
capability so that you can you can
monitor a pair of service and logs per
service your application which is a
easier to control in terms of also quota
how many machines you want for this type
of service maybe a bad service will take
much less machine than a very request
oriented service and then cost okay
because depending on which area of your
application you want to control the cost
of those micro services resources okay
what you need also to know is or when
you develop those type of application is
you should always be ready for a service
to to not be there completely complete
failure again this is a true at Google
okay we have plenty of services and
sometimes you know maybe half a percent
or one person of them are failing but
the other services depending on on them
are we turn in a fashion that they can
survive okay so this is very important
that your application is developed so
that at the end the end user is not
really impacted also the design of micro
services is evolutionary you do small
changes you'll deploy them in prod and
then you see you see how it it works
easier to test as well okay so some
example of for example in javelin Java
Java server that can be seen as embedded
providing support for running
microservices is the original App Engine
sandbox that we can describe in a bit
later and then the new emerging web
frameworks like spring boot or vertex or
spark or ninja 300 GDP d I mean all
those all those servers now
written in a way that instead of
deploying application to them you deploy
them with your application so you have
you need you completely control the
versioning of your service so how Google
cloud platform can help you designing
those new type of applications okay so
we're going to go through a quick
introduction of the three big products
that compose the cloud platform the
first one compute engine which is quite
new may be shipped in 2013 maybe two
years ago and it allows you to create
virtual machines okay so you pick you
pick the US you want to pick the memory
size the size of the memories of the vm
you click the operating system and then
Google will lose this vm somewhere in
one of the data centers and then you can
deploy I mean whatever your payload you
want on the other side of the spectrum
App Engine which is in fact the first
product that created the cloud platform
again shipping in 2009 is trying just to
allow you to concentrate on your user
code and not caring at all about scaling
monitoring restored failover all those
all those capabilities and in the middle
a new product that was developed in the
pencils as a QB on a test project and
then delivered as a product in one dot
zero this summer so again brand-new as
three months ago it was 10 I think they
shipped version 1 dot one few few days
ago so still still under development but
in in GA format which is container
engine which is a mix of App Engine
capabilities running on top of
attention so here it's more exposing
whatever Google can do for clustering
and you can you can define a cluster of
powers of machines of workload so that
you don't need to care but we studying
orbiting those VMS the container and
gene product will we do that for you
okay so quick intro compute engine
virtual machines very easy to do nice UI
we're going to see that later in the
demo continue engine basically really a
cluster centric view of your application
okay so here you you you have some
control on how how your fleet of VMS is
a is a is managed using cluster and but
you don't really depend on the corner
because what you are deploying is really
dhoka dhoka images and running docker
containers okay so there is one level of
abstraction above the compute engine
product and then the product that we're
going to focus on where which is
apparently now both the existing product
and the new capabilities that are
developed using managed VMs so here we
really want you to scale from 0 0 VMs or
0 sandbox processes when you have your
traffic so that we have nothing to pay
close to infinity okay again snapchat is
one of I mean is the biggest cloud
platform customer today and there they
are given in terms of scaling is a are
pretty yeah impressive so what we're
going to talk after a little bit more is
those two new modes of App Engine okay
the sandbox model that was done
initially and then the new the new mode
which is managed VMs which is a mix of
App Engine as we know it and VMS and doc
your containers running
in the public cloud okay so this is what
what we provide now okay we have the
sandbox model up to now it's still under
Java 7 why because it's a very secure
environment you do not really as a vm
you have a JVM process running somewhere
in a shared environment or in the cloud
the cloud from google we are working
very hard to deliver Java 8 so i can
announce it today i mean we will we will
deliver java 8 when when we feel that
our sandbox is secure enough so that you
can we can run a customer workload in a
shell on government so this is coming
hopefully next year as soon as we can
okay so this this is happening now and
then the new mode of App Engine that we
call managed VMs so it's really reusing
the compute engine product so basically
or the workload of your application is
running on VMS and we are using again
docker containers to to run this payload
so here out of the box we have a few
default images for java 8 python gonna
jizz and you can obviously define your
own runtime because it's all based on
the dock of technology so if you have a
doctor in made listening to port 8080
and potentially writing the logs in the
correct place then you can you can put
this doctor in match in the App Engine
environment and attention will deploy it
and scale it using the App Engine rules
okay so what what can the product today
provide you for developing microservices
so one of the key aspect of an applet an
app engine project is that it is by out
of the box its multi modules ready okay
so an application an app engine
application can be a collection of
modules or so
basis and each of this module or service
can can be scaled independently can also
be implemented by any runtime so you can
have you can have one in one single
project you can have one module or
service returning go and the second one
written in Java that's completely okay
and each service or module is vulnerable
okay so this is a unit of deployment and
we need of versioning and all those
versions are always live okay so you can
you can send traffic to any version the
current I mean the version will will
will will reply there is a notion of
default default version if you don't
specify it you will go to the default
but you can specify the version when you
send the request so basically you can
and you can use a very very nice feature
of App Engine which is traffic splitting
for one module across multiple versions
okay so by default if you do not use
traffic splitting or your traffic will
go to the default module but you can say
oh I want to send five percent of my
traffic to this new version and then you
can analyze the logs of this new version
again they are separated in the log
viewer and see how your application is
being so now all those projects I mean
the same project give to all the
constituent of the project all those
modules or services the same data store
memcache and ask you so let's see
graphically project one here as you have
deployed to services one and two and
each service has two thousand thousand
one and 10 and version 2 dot 0 so at the
end of the day one single application
App Engine is composed of four running
services and those for running services
they can share the same the same
environment that the platform as a
service is giving to you
basically a data store which is a non
SQL database provided by google memcache
layer we just need to use it it's there
you don't need to boot it or define it
it's available in the platform as well
as a message queue and rescue system ok
so we provide ap is obviously to access
those resources like that a storm and
cash and and task you but we also
provide some some API so that you can
discover module or services are
dynamically and potentially communicate
between them ok so here it's an example
of the module service that API where you
can get the verse the virginals name
based on the name of the module and the
version of it ok so once you have it
then you can you can send you can send
HTTP requests to it ok so very simple to
communicate between services of same
application so to recap these are the
big differences between App Engine
sandbox as we know it today and the
better product which is managed VM so
App Engine sandbox is extremely secure
and because of the security check on
strength we have we we cannot offer or
the power of the JVM so for any poll you
cannot create a a file using this
environment because there is no file
system you cannot create a web socket
you cannot create a thread even even
because we want us to to be able to
scale you from 0 to almost infinity and
we do that by spawning and killing many
many times per day JVMs running your
your process in a very very tiny and
secure environment so there is the
biggest machine I mean the biggest
environment here is maybe too i mean i
mean the smallest
process here is 600 megahertz so it
smaller than your phone okay but we can
scale and we can run many of them at a
given and given point of time so this
product is GA but the networking stag is
not accessible blood balancer it's
completely Oh back to you you don't see
it in fact this is one of the beauty of
the product and we provide no SQL
integrated with data store ap is in
managed VMs okay we try to keep all
those nice properties but we want to
make them open to you so for example the
network stack is available for you in
your document you are running in compute
engine GM so we have nothing to hide
it's your is your working environment
the load balancer is not any more custom
it's a clad load balancer so one of the
key product that you can use with
compute engine so you can define your
own load balancing rules if you want
same for autoscaler you can also use
your own rules to to control the
autoscaler so for example if it's
running today you might want to boot
more services and laying whatever you
know selling umbrellas or whatever okay
you could not really do that in in the
sandbox model what is important also for
AP is we still give you data store
memcache access I mean shared the access
to those shared resources but we are
completely rewriting the app engine API
so that those api's up to now could only
be accessed via an app engine
application v1 or sandbox now you can
access those resources either from a
managed VM environment or even your
laptop or even amazon okay so you can
you can create a data store data
in your App Engine project that can be
accessed from anywhere okay so this is a
big big change compared to the original
app engine model where all those API is
now are completely open and decoupled
from from the App Engine environment
fully open source compliant what it
means is mean that whatever doc your
image you can you can come up with from
the pencils should be able to run it on
on this new environment okay so if we
dip dye very bit more in what we are
trying to offer in the Java environment
for managed VMs we have defined three
bays dokey emerges and obviously you can
extend them but the these are the
out-of-the-box images you can use the
first one is a openjdk eight image so
basically what you deploy with it is a
job that you can create with springwood
vertex spark a very human very all those
popular Java frameworks now and you
define an application an app engine
application with a very very simple a
PMO we kept the pure servlets we dot one
garmin because we we still have many
many customers doing a web app
development using Java EE and here we
have been working in collaboration with
the jetty guy so the guys doing
developing the jetty web server they are
helping us defining the best doctor
image for running jetty workload on top
of on top of a platform platform the
nice thing but working with the jetty
guys is they are the leading the leading
people developing a technology called a
LPN which is a critical aspect for
enabling HTTP to in the stack which will
be out of the box in Java 9 someday I
don't know next year in November but
they are trying to patch the Java 8
runtime to enable a LPN and security
layer so that you can you can you can
use secure HTTP two constructs and for
existing customers we still need to
support them and we still need to
provide them the sandbox API so the
original data story p is the original
mem cache API the original task you ap
is they also need to be able to run in
the management environment so it's
critical for for us to to to enable
existing application migration to the
new world and here it's basically you
take an app engine application like you
could write in 2009 and you can just
deploy it to manage vm by adding one
line in in your configuration file
called happens in web.xml so these are
some examples of what you need to add to
your environment to foreign import
deploy a war file so here this is a pure
the pure OG t nine so not nothing
specific to App Engine and you deployed
with a war file so you add the route
that war file and there are the
jeddah-based area and then Jet Li will
serve it and this is a configuration you
need to write same for running
springwood app dejar application you add
it in the / app directory and you in
rate from the open jdk 8 image that we
have and everything will we'll worry
soon we are still working on it again I
said it's still a better product soon we
will be able to fingerprint your
deployment environment and generate
those two files for you so you will not
even have to to to to specify that this
is an advanced a p.m. or a configuration
file you define a module so the module
name is called service one here
runtime is Java and then most of those
entries are optional but this is where
you can define which type of cpu memory
size this size you want for your managed
VM okay so here we did it we did not
really say I want you know I mean we did
not really say that you can we do not
map the cpu with existing compute engine
machine types okay because we wanted to
abstract maybe those machine types in
two years will change completely there
may be in two years of the startup
compute engine vm will give you twice by
were of today okay but by allowing you
to specify just the number of CPU you
want here then you will be in depend on
will be independent of changes in
compute engine so here for any port we
are saying you did only half a cpu which
mean that it's a micro instance in
today's world you can also specify some
scaling properties there by everything
the platform we have been working on new
tooling so there is a new Google Cloud
SDK tool that unified all those products
com plenty in container and Jean App
Engine as well as data store BigTable
cloud storage so all the product that
offers some some capabilities for a
developer to interact with all those
capabilities are now integrated in a
unified clad as weekend okay so for an
important gene the comment is called
jihad the generate command and then for
App Engine the the sub the postfix of
the command is app which is still in
preview but soon will we're going to get
rid of the preview tag so basically to
deploy an application you just said gee
jacquard preview app deployed abdi ml
and the appium all has to be close to
what you want to deploy whether it's a
jar or whatever for java developers we
have done rapper with maven so all those
capabilities expose in the cloud SDK are
fully available also as a maven plugin
and maven goals so let's quickly move to
a demo and then I will dip dive more in
in API design with Mandy so here is it
big enough but maybe I can make it
bigger so this is a new the new
developer console of the entire platform
okay so you can see a dashboard okay my
project is here okay so i call it def s
not because this is where i was last
week but i have many many other projects
but let's pick only one project so you
have the dashboard and for this month's
this project cost me so far 62 dolls and
i have a few compelling compute engine
instances and App Engine instances even
though it feels says 0 I have some of
them still under development so you can
now select the big big products of the
cloud platform so App Engine
complementing contain your engine and
then configure the networking of your
project so let's first look at this app
engine application as I said a nap in an
app engine application is a collection
of modules the default module name is
called default okay but here i have also
a second module core module one okay so
let's first of all look at the default
module and i can go to the versions
area of the console and here for the
default module I will see or all the
versions of this module okay so you can
see we have a mixed of vm base run times
so these are managed VM app engine
application modules and here Java 7
which is the sandbox the java 7 sandbox
runtime for for App Engine okay so for
an import let's say I click here I will
I will go directly to the URL which is
basically the service name or module
name spark to the works then my
application name and then appspot com ok
so here this is a very simple
application using the spark framework I
don't know if you know the spar
framework but you can you can look at it
here spark ok so again it has not been
developed by google at all ok it's an
apprentice framework that is based on
Java 8 that allows you to create very
simple web application using very simple
way of mapping your heirs to two lambdas
or code you want to run ok so i
encourage you to to spend time if you
want to learn this framework so let's
look at where is well let's rent again
ok so i will create a new user here from
the works i don't know if it will work
but ok
okay oops okay so i just created a new a
new user here to my plate in my
application okay let's go back to the
vervain's so i have another version here
so basically we have activated this this
module or the service i can now activate
this was our module and basically it's a
spring boot java application connected
to the same project so accessing the
same resources memcache data store etc
so i have two entries here the first one
is listing not in a nice way but i'm not
i'm not a UI developer okay but
basically you can see that the spring
application can access the same database
which is shared in the same project okay
so this is something important that all
those versions of this default mode you
will are live and accessible and shared
sharing the same same environment I can
go to another module and then see other
other version of different modules okay
so all those modules consist mean
creates your application because we we
have been using the cloud datastore we
can go to the storage section of the
console and explore explore the entities
that this project is creating so the
devoxx user entity is a one that I've
been using to either we spark or spring
boots so we can query it and see so
where is it
namespace I since we'd oh yeah and here
we would see the new entry that I've
done using my spark java application
okay so this is cool new new new console
you look and feel there is a nice button
here I don't eat it which is activate
Google Cloud shell here we give you
inside in line in the console a common
terminal with all the tooling that you
need to develop your application with
our java or something else so it gives I
mean we install the cloud SDK we
installed get we install maven we
install gradual if you want so all those
run times are here for you to to to use
okay so here i have my source code and
my maven projects I mean all those
projects are maven base okay I can
obviously also open them in an ID and
could be intelligible you know I picked
NetBeans today so here I have four I
mean five a few a few maven projects so
you can look at the pump file for a
spark application very simple spark
application the only thing that we have
been doing is adding this section okay
we have been saying okay this is a
standard solid spark a jar application
you just need to add the cloud as we
kept again so that you can deploy you
can deploy it using something called
like g-cloud apply here so this is one
of the maven go okay but everything else
is a non google centric at all okay
you can run it locally obviously and if
you look at the dependencies we have
added something called jihad Java which
is a new director of AP is to access the
cloud data store from anywhere from this
local jar file as well as when it's
deployed in the cloud so we can look at
some code here I have user service using
using those new api's come Google g-glad
dollar store data store again nothing
specific to App Engine sandbox those
api's are accessible from anywhere
whether your payload is running on the
Google cloud or anywhere okay so very
simple where to access data store using
those new API is from anywhere okay so
you can you have a query language and
then you can create entities or get
entities very easily okay so i will not
deploy from from stage because the
network is too slow here to deploy to
deploy in an image so let's go back to
this environment and i think we have
done we have done enough on the demo
side so let's move back to the
presentation and mandy will now stop
talking but something critical which is
API design for those services and the
new technology that we are going great
job good right ok so when teammates left
submit your questions definitely please
everybody was fast leave you a question
all right so we can talk about API
design and mostly in the context of
google app engine so microservices on
App Engine deployed as modules
luda has been talking about can
ultimately talk to each other in
different ways one is basically making
making http-based restful cause to other
modules within the application or even
to external modules also taskings how
many of you use taskings an app engine
okay less of you than you see but task
queues are extremely powerful and App
Engine them effectively what we can do
is we can cute asks for a queuing up for
a specific module or even for some other
endpoint outside of App Engine as well
the task queues are extremely powerful
and are very good mechanism for getting
that stuff done we also have a mechanism
called cloud pub/sub which will allow
you to do sent very similar but really
for App Engine currently the preferred
ways to use task queues and also we can
use our pcs which we're going to talk
about shortly when it gets a grp see
Microsoft Microsoft is ultimately are
deployed as modules in App Engine and so
therefore they are maintained
independently of each other so we can
have different versions as literally
shown of different modules of an
application so we can revision and very
quickly as opposed to things to redeploy
the entire applications and these
microservices internally will
communicate with each other via very
well-defined contracts and often these
contracts will be versioned so we have
v1 and v2 but with the grp feelers other
options as well and we look at that
shortly and ultimately this is very very
easy to get them to work within with
each other within projects or across
projects and the concept of projects
luda's already covered within Google
cloud platform so once you've deployed
an app engine application it looks
something like this the standard App
Engine URL if you're not map into a
custom domain you can map all this stuff
to a custom domain of your choosing very
simply using SSL as well today which is
something that's pretty new then you
just come along so you'll basically have
my apt I've slot com which is your basic
URL and then for each module you'll have
a subdomain which will be in this case
user service got my appetizer calm and
again they could be using certainly or
you could expose that externally as well
directly
and ultimately four versions will have
version 1 don't use the service or
version 2 don't use a service and you
can map these any way you like using
your own router mechanisms but
ultimately that's the basic structure
what it looks like in App Engine so what
the expectation is when making micro
service calls to your code the client
should never it's actually go directly
to a specific code version the version
you want them to go to should be the
version is your default but you can use
these versions for doing things like
smoke testing or traffic splitting so if
you want to balance traffic across
multiple different versions of your app
maybe to do something like a bee testing
or a phased rollout over time and then
also rolling back and running forward so
that's one of the powerful mechanisms of
versioning and shattuck splitting within
Google App Engine and now grp see so how
many of you have heard of grp see okay
none of it well okay how many of you
have looked at HTTP so and care about it
I got a few of you okay it's going to
it's going to be big some of the places
we won ultimately and probably very very
quickly but it's so powerful but grp see
is a framework that we introduced this
year it's completely open source that
thing go to the grp see the i/o calm and
you'll find a link to the garage it
there you can play with it you can
commit to it and basically this is going
to be an option but with our future ap
is so all of our API is in the future
will sulk HTTP to and you can build HTTP
to clients that can consume those
services they will continue to support
the older mechanisms as well for some
period of time Monday HTTP 1.1 and all
of thee cobbling together we've had to
do it over the years will go away and
see our pcs ultimately based on
everything that we've done at Google
over the years particularly protocol
buffers protocol buffers an extremely
powerful way of using messaging all
sensitive XML and JSON and suchlike
which we came up a long time ago when we
found we had a problem with moving large
amounts of data around our network
protocol buffers are extremely efficient
in that
backed a binary wire format effectively
grp see supports out of the box 10 plus
languages i think is more than 10 i
think there's another one as well and
out of the box so in terms of client
support and server live server and
client stub generation and grp see makes
full use of HTTP two more than most
browser clients will do in terms of
using its binary framing mechanisms
which all this up you should probably
look at it's extremely powerful
multiplexing of streams header
compression all that stuff from HTTP to
and pajama to use grp see it's very
straightforward and see HTTP two it's
only showing forward finish you'll need
java rate and you'll also need a LPN
which is basically a protocol a way of
negotiation protocols because every
client will have some negotiate we're
breaking support HTTP two or not but
these are all backed up in the new
runtimes that dude has already talked
about the grp see edel is basically
built on top of protocol buffers so
we've gone from protocol buffers ocean
to to protocol buffers lesson free and
version free actually supports Theodore
and it has many other changes as well
which are extremely important in terms
of having optional required fields which
is that we used to have we no longer
have that and this is really really good
for backward compatibility which are
touched on shortly and so this is a
typical method typical it'll where we
have two messages a request in a
response message which we can find the
fields within them a numbered a
numerically your had them in order you
can delete your village but you
shouldn't change the numbering at any
time so if you have like one two three
and four and five you delete free you
never use free again because of all I
should have backwards compatibility
issues but you can also extend that and
add new thoughts over time and any
clients that only had the old version of
the client will still be able to talk to
that version of it because they only
maybe understand fields one two and
three the server doesn't expect those
souls 2 beta and ultimately we can
define the service as well as an RPC so
in this case we had to say hello service
which thinks of how I think you should
be the greeter service however question
which sounds a hell
response we should assume messages
defined up there and then some point we
get to building all of this stuff we use
maven and Gradle or we can download the
protocol protest c compiler and compile
all of this stuff on the command line
and then that will generate the required
java transport layer and also all of the
service interfaces for your server and
your client now this is an example and
go run for yours quick tubes and you get
similar it's left eye I'm not going to
war for the code you can see this online
the links are down here we'll share the
slides of you and you can look at it
yourself that is fairly straightforward
all this code is basically built on top
of the generated these generators stubs
and server-side code was generated the
generated I want the same advice it was
generated by the proto c compiler either
by a maven or grade or on command line
and then everything can read is
basically provided by that edel and skip
through that very quickly and ultimately
with grp see we can build polyglot
microsoft microservice microsoft looking
at sort of our mitosis and idea i should
definitely drink of water polyglot
microservices architectures can we call
them saying different how about a micro
services and always keep saying
microsoft i'm going to say amazon it so
we have various different clients
written and different servers written in
different languages talking to each
other in a typical architecture using
micro services with grp see when it
comes to API design basically what I'm
going to talk about here is the bottom
line really the rest of it stuff you
already know but with grp see by a
protocol buffers free we support
backwards compatibility and this allows
for version this api's so instead of
having b1 and b2 and b3 you'll just have
one version of it all of your clients
will work with any version of it because
they are completely backwards compatible
and that's extremely important and
extremely powerful and Lunas really
touching this briefly we talked about
the idiomatic client libraries that we
have and all of our client service API
is ultimately will be built using grp
see although support
grp see internally and what these
libraries we develop in now we we used
to take an API we still do we take an
API and regenerate from it discovery
document we generate all of our client
side artifacts from that discovery
document the discovery document
describes the API itself and that
process is all automatic and it gives us
very very low level code which is not
very easy o matic it's not very melissa
people developing in particular language
so what we've done we've handcrafted
libraries on top of those ones you're
generated ones to provide a much more
idiot idiomatic feel for developers and
this is available for java for go for
nodejs and we're working on all of the
other languages as well and ultimately
used to support all of the google cloud
stuff and there's an example down here
but i can give you some better examples
of idiomatic changes so we're going to
have QA now so I think there are
microphones it's so much fun over there
there's a wide fine here definitely so
if you have any questions please let us
know and we will do a bit faster them
there thank you thank you from Ludo now
are there any questions no wow really
thats we can let's let me ask you some
questions as i can see ivan really is
like on Microsoft services Microsoft
services who are using Microsoft
services no questions are so come guys
nope ah it's a question no no amelie all
right okay so thanks guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>