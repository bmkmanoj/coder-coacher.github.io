<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building Real time Data in Web Applications with Graal js by Christian Wirth and Dan McGhan | Coder Coacher - Coaching Coders</title><meta content="Building Real time Data in Web Applications with Graal js by Christian Wirth and Dan McGhan - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building Real time Data in Web Applications with Graal js by Christian Wirth and Dan McGhan</b></h2><h5 class="post__date">2017-11-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vRV6qy2BlbU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay we'll go ahead and get started
thanks for joining us my name is Dan
McGann this is Kristin Werth and we're
going to talk about real-time data and
web applications withdrawal is just have
to show the safe harbor statement please
don't make any purchasing decisions
based on what you see here today all
right so here's a brief overview of the
agenda we'll start by talking about how
we got here
and then talk a little bit about kind of
where we're at now and then finally talk
about the database and so usually what I
would like to do at this time is a
really fun demo I got to get you guys
involved unfortunately due to a
networking issue I couldn't quite figure
out in time no demo no live demo but
there is video based evidence that it in
fact works and this is one of the
recordings from open world earlier this
year and this is the app that I end up
showing and what I asked folks to do in
the audience it's just a listing of
cities some website ranked 20 cities as
the most livable cities to go living and
I asked folks to vote for their favorite
city and you see on the left here this
kind of number going up as votes start
streaming in and then there's this other
number over here and I asked folks to
watch that number as well and what you
see over time is that the number on the
left comes up a lot higher that's one
you know increment per vote essentially
and the number on the right is gonna
increment much slower and I just asked
folks to remember that and and I kind of
explained that later on in the talk and
then I cheat and then I vote for my
favorite city a thousand times using a
command line tool so no one else wins
that's the demo anyway
all right so let's talk a little bit
about how we got here it's 2007 it was
exactly 20 years ago that we got HTTP
HTTP became a thing and it was a simple
request response protocol right so the
web browser would issue an HTTP request
to the web server web server would read
some static file users Apache something
like that it would send the static file
back to the web browser and the web
browser would render it that was cool it
worked but we got better we realized we
could involve a database in the mix and
make things more dynamic so that web
browser would still issue that same HTTP
request to the web server the web server
would then use some kind of database
driver technology and start issuing
queries against the database get the
responses back generate a dynamic
webpage and then send that back out to
the browser cool now some of you are
probably thinking actually then we do
some complicated work we do we have to
use transactions so our traffic looks a
bit more like this and you know what
we're a global company so we got a shot
our databases so it looks a bit more
like this and you know what based on CPU
and memory utilization we're going to
scale our web servers automatically and
we're doing all that because we've got a
whole lot of users and so really our
traffic ends up looking a bit more like
this I get it this is the reality a lot
of folks are dealing with today
for this demo we'll keep it simple but
just know that the concepts that I'll be
talking about today can be scaled up to
this level with a bit more code that's
all it takes is a bit more code alright
so at this point you could almost say
that the browser is like a cache of
what's in the database right they're
essentially the same in terms of the
data that the user is viewing but then
we all know what happens somebody goes
in makes a change in the database and
all of a sudden the cache and the
browser is stale so that's the problem
well we've had the ability for the
longest time to communicate from the
database to the web server to let the
web server know that there's been a
change the data what we've not been able
to do is go from the web server to the
to the browser and let the browser note
that that cache is stale at this point
that was impossible and it was for good
reasons related to security thus began
the quest to
simulate this kind of thing now raise
your hand if you're guilty of any of
these and I in fact him guilty of all of
them yeah fun stuff right it all started
with the forever frame this one actually
goes back all the way to ie6 you can
still do that one in the latest browser
all the oldest browsers rather and what
you would do is you would you would have
your main web page and inside that you
would hide an iframe and you'd use the
iframe to go out and get new data and if
it got new data you'd proxy it up to the
parent page and just inject it in cool
things got a lot better when we got Ajax
and we started using Ajax polling and we
all give Microsoft and ie a real hard
time but frankly was Microsoft that
invented Ajax
so hats off to them and Ajax polling was
just this thing where you use something
like maybe set interval and you
occasionally go back to the web server
and you'd say hey is there any new data
any new data any new data in the problem
there is twofold one it's a complete
round-trip each time and - you're asking
the web server a lot of questions when
there are no changes and if it has to
then ask the database that's a lot of
work for no reason it just doesn't scale
very well things got better with long
polling because with long polling you
would essentially establish that
connection to the web server asking it
hey you got new data and then you would
just wait and when the web server did
get new data it would send it down to
you so number one you're not asking
unnecessary questions and two you're
cutting down that response time some so
that was really good and that's actually
the technique that Google was pioneering
with Gmail things got even better with
html5 server sent events but most folks
don't even know what they are and
there's a reason for that and the reason
is we got some better technologies and
that brings us to where we're at today
so some new technologies have emerged we
have WebSocket now and we have web RTC
WebSocket is what I ended up using in
the demo but I'll talk about web RTC
first because WebRTC it's like real time
communication you think obviously that's
the technology out of use for a real
time demo but no web RTC is all about
getting peer-to-peer connections going
it's a little complex in that it
requires a turn server to get the
initial peer-to-peer connections
stablished and you can host your own
turn server it's not terribly hard but
most folks are going to go ahead and use
a paid service to do that but it's a
really great technology for streaming
audio and video but also communicating
arbitrary data and just think video
games if you have two peers connected
directly they're avoiding round trips to
and from some middleman so really great
for video game technology but what I
wanted to do was just simple it was just
from the server to the client in that
case WebRTC I'm sorry will some
WebSocket is a much better choice
so web socket is all about just enabling
that bi-directional communication we
never had the ability to do before it
works with HTTP preferably HTTP as like
a you know over line protocol and then
it upgrades to WebSocket so it's really
nice nothing new going on they're
perfect for what I need to do too which
is just push state out now if you're
choosing between these technologies keep
in mind that web RTC is still not
support on some of the older browsers if
you have to work with IE 11 it's not
going to work I've been watching this
global support number over here
increments slowly over time so in the
future this might be a good option
WebSocket on the other hand is already
at 94% globally once you're above 90
percent it's it's pretty safe to use
anywhere unless you work in an
enterprise well you have to support an
older browser so WebSocket definitely
ready to go in that regard here's what
WebSocket looks like if you start to use
it so we have here on line two we're
declaring a variable called socket we're
setting it equal to a new WebSocket
instance we just pointed to the
WebSocket server once we have a socket
instance we cannot event listeners and
there's two events that matter we have
open and message so open means were
connected once we're connected we can
use the socket ins the send method to
send data down to the server or
conversely when the message event
happens that means the service trying to
talk to the client will get the event
object and of course on that will be
some data and we can work with that in
the client now that I've explained the
web socket API to you I would like you
to promptly forget it and the reason is
because like a lot of
API is it's a really low-level API but
it's not very practical for getting work
done instead you want to use a higher
level API on top of that one so there's
a there's a it's an open source project
called socket IO that you can leverage
socket IO comes in two parts you're
going to have a client-side part and
you're gonna have a server-side part and
what it is it's essentially its own
protocol and this is nice because long
polling actually works even in the older
browsers
it starts with long polling and if it
finds that both the client a service
support web socket then it goes ahead
and upgrades a connection so it's it's
great for backward compatibility has a
really simple API all kinds of great
support things like multiplexing and
rooms have your working like with chat
servers or that kind of thing it's
already built in
but Auto reconnect is also a real big
deal like if you imagine you know
somebody's connected and then they go in
the subway or the metro and they come
back out and they open up their phone
again the browser is no longer gonna
have that WebSocket connection right
well socket IO will automatically just
start pinging the server trying to
reestablish that connection getting the
latest greatest data so you don't have
to worry about that kind of stuff it's
done for you now my approach to solving
this problem is to do something a little
strange so most folks when they think
about building a REST API they're
thinking about a public API an API
they're gonna expose to the public
Internet but to get this working what I
went ahead and did is wrote both a
public API as well as a database API and
you can put the public API behind a
firewall just making sure that you know
the browser is only able to talk to that
public API and your database API is safe
and secure behind the firewall but the
idea is that you need a means for the
database to be able to communicate when
that change has happened and then of
course you'll end up pushing that out
through web server so let me do a code
review I'll show you first we'll do this
in two parts I'll show you first some of
the code related to the front-end and
what what I did there for the demo and
then we'll look at the back and a little
bit later
so this project is essentially in two
parts client and server and we'll start
with the client and this is essentially
an Oracle jet based application I won't
get into details of that but if you're
familiar maybe with angular react jet is
just Oracle's alternative to those
solutions and inside the source is where
the main code is and the j/s is the main
app so one thing I needed to do was
bring in socket IO and I mentioned
already that it's two parts so what I
had to do in this client part was bring
in the front-end part of socket IO and
the way I end up exposing that in the
project kind of looks like this so this
is musing requirejs so I need require to
require in socket IO and then an
application configuration and socket IO
all I need to do is invoke it to get a
single instance of socket IO and it just
goes ahead then and connects to the web
server and the reason I kind of wrapped
it in this module here is so that I
could share it then the state and such
with the rest of the application you
only really need one connection back to
the server so it's good to just
centralize this and be done with it so
the next thing that matters is let's
look at the main page where folks do the
voting is here and what they see is a
listing of cities and they're just
clicking the vote button voting for
cities and what happens when they do
that they're interfacing with this
template here it's based on knockout
templating and so they're seeing a list
of data that comes in from the view
model which is exposed here and then
there's just a bunch of methods and
things that you know when they click a
button it invokes the upvote function
which is defined in the view model so if
I open up that view model what you'll
see here is that I end up requiring in
that module I showed you a moment ago
the the
single socket IO connection and I bring
that in is IO and what I end up doing at
first you know when the first page
renders we fetch the latest greatest
data but down below I use on an event
and the event here it looks like it's
name say it's just this string so I'm
saying
io on cities not change and we know
we're going to get some data I just take
the data and push it into that data
source and it goes ahead and updates the
data source in memory and of course then
the view updates to reflect the current
state of the view model so that's kind
of in a nutshell what happens in the
client side and and the server side well
I'll show you that one we get to the
database part
all right so myself I'm an Oracle
database person I don't know what
database you work with but no matter
which it is you're going to need two
things to get this kind of thing to work
you'll need a means of events detecting
when data changes and you'll need a
means of communication when the changes
occur so when we talk about events in
the database oftentimes the first people
think about our database triggers we
could have used triggers for this so
with our cold we have two different
types of triggers DML triggers such as
insert update type triggers as well as
system triggers when folks log in or you
know maybe alter a table that kind of
stuff all kinds of triggers within the
database the way we might have
constructed that is with an inserts
trigger and so this trigger is saying
all right after an insert on the Vote
table and then the implementation for
notifying nodejs I'll show you a little
bit later but this is the type of
trigger that we might have used to
notify nodejs when that change occurred
but this would have been really bad can
anyone guess why this would have been
bad Network bound IO right so when you
think about databases a lot of folks
always IO in general you have you know
level one level two cache you have
memory and then you get to disk and once
we get to disk people are thinking disk
is slow right well what's slower than
disk network and so if you add a row
level trigger that has to communicate
across the wire in addition to doing the
normal insert it already has to do
that's gonna be real bad so instead we
move on and maybe look at scheduling so
Oracle has a really robust scheduling
API it's called scheduler and you're
seeing an example up here of how I can
create a job and this particular job is
of type PL sequel block you can do all
kinds of options there but what we're
doing here is an anonymous block and I'm
saying begin do something awesome and
and and we can set that to frequency
daily but really when I create a job I
don't actually have to set it up so that
it's out you know running all the time I
can create a job and then call it
on-demand and what's unique about that
when you when you do it it basically
spawns
background process to handle the job and
so you're doing it asynchronously so you
kind of avoid some of the issues that
you might have with triggers you're not
like holding things up so I could have
combined these two technologies and so
here I'm having I have a procedure again
the implementation we're not looking at
just yet but this is the procedure
that's gonna notify nodejs and it's
called aptly notify nodejs so now in the
trigger all I needed to do is declare it
as a pragma autonomous transaction it's
a transaction within a transaction and
then call create job and job action just
notify nodejs it's just pointing to that
procedure up there so now it's gonna
invoke that whenever the insert occurs
so this would have worked maybe not the
best option but it would technically
have worked maybe that's going to be the
best option at some databases we have
another technology with an Oracle that I
could have used called advanced queuing
and advanced queuing is a really cool
framework for these kinds of queueing
architectures you could do
point-to-point it's super flexible you
can set it up as point-to-point you can
do pub/sub depending on your needs but
one of the neat features that the
advanced queuing feature comes with is a
notification thing so essentially when a
new message is end queued you can have
it automatically call something else
- then DQ the message rather than having
to pull continuously to see if new
messages have come in for my purposes
what I was doing this was overkill
honestly so I didn't want to do that and
oftentimes you know you may have an
existing table some folks say well
couldn't you do this in the middle tier
and not in the database and the truth is
sure right if everything about it we
could have a lot of the logic in the
middle tier and when an update to the
database comes in the middle tier and
let's say we're using an ORM we could
tie into the rme when it updates the
database we know if something's been
successful here then we could push out
changes to everyone right that would
normally work but what about when you
don't have control and all of your users
aren't coming in through your middle
tier right what if you're working with
an ERP where you can't really touch it
and that way sometimes you might need
another
means of handling this and you just want
to know when data changes and you don't
have that level of control well I
started to look into this and found a
feature I've been working with Oracle
database for over 10 years and just kind
of stumbled on this one by mistake and
it had been there the whole time
it's called continuous query
notification and here is an overview of
how it looks so this is a PL sequel
example there's there's a Java API
there's all kinds api's but this is the
PL sequel API so in the declaration
section here I have to use this type
it's a continuous query notification
registration info and then I need to
initialize that type and I pass in some
parameters here so one is called
callback and that's interesting for me
I'm a JavaScript developer and we work
with callbacks a lot but turns out
callbacks have actually been an Oracle
database for a very long time and then
we have this some other parameters I'll
talk about one of those later but then
we're starting this registration and
what I do is I say I need to open a
cursor for and I have to include this
reference to this function here but then
I can just select various columns from a
table so I'm opening a cursor and
immediately closing it I'm not actually
executing the query that's enough to
register this query with our
registration info and we're done and at
this point what Oracle's going to start
to do is look at the results set of that
query and if the result set changes on a
commit if the result set changes then
it's going to go ahead and invoke this
function here notify the server of
course we could notify no Jes that a
changes occurred that's the route I
ended up going as far as communication
goes again this is going to vary by
database and Oracle we've had all kinds
of communication packages for the
longest time for TCP for HTTP and also
SMTP and mail if you need those what I
ended up going with myself was Apex web
service and application while apex is
short for application Express this is
just a
rapid application development
environment for Oracle but to support
that product they add a lot of PL sequel
packages and one of those is actually
really cool web service and the reason I
like it
if you're doing any kind of rest
communication it's like the go-to
package makes it super simple to do
rest base stuff with Oracle so now we're
getting to the implementation of
notifying the server that a changes
occurred and the signature I do have to
include this notification descriptor
because the notification service is
going to invoke this procedure and it
basically passes along some information
about the change that has occurred
depending on the change you might for
example get a bunch of row IDs telling
you that these have been changed but
there are some algorithms that you know
determine whether or not that's
unreasonable right if somebody updates a
billion rows you certainly don't want to
get that many row IDs so they won't do
that but all I need to do then is
declare a response object to cielab and
just say all right Apex web service make
rest requests point this at my node.js
server and then I get a response and
disregard it entirely because at this
point I've done what I needed to do I've
simply told the node server that a
changes occurred and at that point in
time once the the middle tier is aware
of a change it can do whatever needs to
do they can go back to the database grab
all the data shove it out to the clients
they can do whatever he needs so I'll
show you what I ended up doing here
so we'll back out and go into the server
side of things and remember this is an
odious application I'm familiar with
node you might have noticed the stickers
like JavaScript is my thing frankly I
can't convince Christian that I should
be able to run node on a server so he
lets me use growl j/s that's where we
kind of met in the middle and I'll talk
a little bit about that in a second but
I ended up using a node style app and so
you're seeing a traditional file system
for that as far as socket IO goes what I
end up doing in the database API is I'm
setting up some some different routes
here and I have a route for super cities
and this is the route that the database
is going to come in on it's going to let
me know that there's been a change to
this technically super cities is the
name of the table might have been votes
or something like that but when that
happens then the node server just uses
another endpoint to get the data for
that API and once it has the data it can
then use the socket IO instance on the
server side now to emit that change that
you saw we were listening for on the
client side it's really this simple
you're just listening for an event on
one end and you're emitting that event
on the other end and sending along the
data that's all it takes for socket IO
so they made this dead simple
one thing I'll mention a last thing so
the PL sequel example you saw it works
and as I mentioned Java API is I'm sure
a lot of folks here are Java developers
but what I want to see added is support
kind of native support like you guys
have in Java for JavaScript and so the
way that might look if if we kind of
ignore bear with me a moment
oh yeah
kind of ignored how the PL sequel API
looked we could add something like this
and this goes back to the safe harbor
site in the beginning this may never
come to fruition it likely well it may
not look exactly like this
so what I could do when we start up the
node server is get a connection to the
database using the database driver and
once I had that connection
I could call create subscription and
what you're seeing here are parameters
that are very much like those in the PL
sequel side but I can explain them a
little bit better here the one that
really matters and if you look think
back to that demo where we have two
different numbers right so one number is
representation of the total number of
votes and that's going to increment as
more and more people are voting and the
other number I mentioned was much
smaller and there's a good reason for
that imagine if you will that for every
single vote that everybody here was
doing I was then kind of doing these
round trips right every vote comes in
we're inserting that into the table and
then the change notification occurs and
we're going back out pushing these
updates with every single vote it simply
wouldn't scale and in JavaScript I don't
know if it's called the same thing in
the Java world we have a concept known
as like a debounce where you know there
might be a number of events coming in
sort of as a stream and you're saying no
don't respond to all those events wait
until a certain threshold of time has
passed or or group them together in some
way and that's what actually were cool
supported already which was really nice
so there was this grouping capability
and we can group by type and there's a
grouping value of one unfortunately the
minimum I could go is one second I'm
trying to get him to lower that who
knows if they will but one second was
fine and it surely helped basically I
could take all of the changes all of the
inserts that occurred in the vote stable
group them together as a single change
and then propagate that change out to
all the clients at once from that point
so that definitely scaled a lot better
now in this case Mis particular API if
we if we do it this way once you create
a subscription you'll get a subscription
object which you can then use to
register queries and of course an Oracle
is going to start listening on the
result sets of those queries to see if
any changes occur
and when they do notice here the
callback in the previous PL sequel
example the callback was a peel single
stored procedure but here it could be a
JavaScript function and so that
JavaScript function would again get the
change descriptor and then do whatever
it needs to do is select data from a
table and again you socket aiiowing met
to emit that data howl so this I think
would be a much better API especially
for JavaScript developers but you
already have some great options already
in Java
all right so I mentioned a moment ago
that Christian is not gonna let me run
this application on a normal node server
he's we're gonna settle with growl Jes
and it turns out there are some really
good things about using growl instead
and this is a normal problem we have in
the JavaScript world
I love JavaScript but I'll certainly be
the first to admit some of its
deficiencies one of those happens to be
numbers so what i'm doing here i'm
showing you the contents of a file
called JavaScript jas and you see i'm
declaring two variables value 1 and
value 2 and they're both numbers and
we're initializing them to a string zero
point one and zero point two and of
course after that they're numbers and
when I add the two of these together and
log out the value it's a rounding issue
right some of you might be familiar with
this it's certainly a problem in
JavaScript and there are some libraries
but not a lot of great ways to solve
this problem just yet hopefully we get
decimal but until then not really a
thing but because we're using graal j/s
here I can actually do something a
little bit different and so here's a
different version of the file
and we see what I'm doing here I'm
actually going into Java and grabbing
out a type from math big decimal and
once I have that I can initialize my
variables using big decimal in the same
strings but now I have the api's right I
can use value 1 and add value 2 and to
string that in console.log and i get
exactly what I'm looking for which is
0.3 so really nice technology and I want
to have Christian maybe just talk a
little bit more about Braille Jas ok
thanks then thanks Dan this is just one
example one we found to be useful to you
and easily explainable that you can
access Java classes here and use them in
your JavaScript code now that's not
something entirely new Rhino can do that
Nelson can do that on growl we extended
that idea to a whole bit of a much
bigger set of programming languages we
can do that on basically any programming
language that's the idea of the growl VM
growl VM in principle is based on the
Java hotspot VM
it's a plain Java hotspot VM starting
from JDK 9 in JDK 9 there is a JVM
compiler interface JVM CI which means
using that interface you can use another
compiler there are two compilers by
default in hotspot and this allows you
to add any other compiler some you might
write yourself or growl is the main
example right now growl itself is
written in Java which means it's a
basically it's a Java compiler so it can
use Java code and execute it on hotspot
that's nothing new that's like using the
traditional compilers but adding the
truffle framework allows us to write
language interpreters javascript is one
example here javascript is interpreted
at runtime on a java vm on the grave am
now that sounds very slow interpreting
javascript should be horribly slow we
all know when you write an interpreter
things are slower than what you can do
you want to be able to compile it to
machine code to native code you want
native performance but that's exactly
what growl is doing it's executing your
javascript code first in an interpreter
but then it's compiling it down to
native code to machine code and in the
end the JavaScript codes that you
execute is as fast as with any other
native compiler take v8 or mozilla
SpiderMonkey or or any other example but
we cannot only run JavaScript we can run
more programming languages we provide
Ruby Python our LLVM so C C++ Fortran
and many more and there are academic
collaborators we work with that adds
more languages to that spectrum but it
all really shows it's a broad range it's
not just JavaScript the nice thing and
that's what what dan has shown is you
can interact between these languages you
can sense data from JavaScript to Java
you can call a java method from
JavaScript that
what we've done we've called the
constructor of the bigdecimal class we
provided some data and then we recalled
the add function of that method we can
also do the same between JavaScript and
Ruby for instance javascript and r are
in python and so forth you can do any
combination of those languages and this
will be fast because there is no
language boundary in between in the end
it's all interpreters based on Java
it's a java application so our growl
compiler the growl vm can compile that
to native performance I've already shown
that two years ago here at devoxx just
search for Derek's Grouch yes we have a
demo there where I showed some
interaction between JavaScript Ruby and
and our what the news here today is that
spans application all the server-side
application can be executed on brow
chairs so it's a node.js application
just a normal node.js application with
all the modules that Dan is using
database connection etc beet native
modules or modules written in JavaScript
doesn't matter
grouches can run that and that basically
means you can run any node.js
application now on the JVM interrupt
from notes chairs to Java and interrupt
from no chess to say
peyten you have an existing Java library
in your company you have an existing
Python library in your company use that
from your noches application now when
working with Java we have one big
disadvantage Java itself is a huge
system and even running a HelloWorld
java application takes some time
depending on your machines performance
it will take up to a second that even
the hello world is executed in Java just
because there is so much initialization
necessary we solve that problem by our
own substrate VM substrate VM is an head
of time compiler
meaning it takes all the Java code it
sees so for instance our JavaScript
engine and growl itself and the head of
time compiled stats to native code that
means that we can run on substrate VM
our know chess execution with actually a
better startup than the original node
chairs because we remove all the
overhead that Java itself comes with
there is one culprit right now on
substrate iam you cannot dynamically
load Java code because it needs to be
ahead of time compiled so most Java code
won't work on substrate VM if it's not
known at compile time at ahead of time
compile time we will solve the problem
by moving Java also here so interpreting
Java in itself on top of truffle but
that's that's for the future right now
you have to decide whether you want to
run on hotspot on gray VM which will
give you good performance and allow all
the languages to be run they're all on
substrate to mmm where you can only run
the top level languages here excluding
Java so what's the big deal about growl
VM it allows you this interoperability I
already talked about that
compatibility no chairs how good are we
we can run everything that's in eco
script 2017
so the current spec we can execute it
we're already working on the the next
standard that mascoutah 2018 not sure
what's what will be in there definitely
but we're already working on those
features and compatibility is always
hard to measure what we did is we
downloaded all the npm modules that are
out there think it's four hundred fifty
thousand five hundred thousand already
we checked those that we can run using
the maka test framework which is
basically sixty thousand and of those
96% just to give you a number
they run without any any problem
whatsoever
compared to v8 even those that fail
might just be setup issues sometimes we
pass more tests NBA to
from tests then v8 being the your
original engine in noches but in general
it will mean that if you have a no
chance application and we tried it with
with Stan's application chances are very
high that it will work on your machine
with with garages allowing you to Ave
interoperability for X for example now
performance how could our being in
performance I don't have slides again I
had slides two years ago in in the
presentation but we are basically on par
with existing engines sometimes we're
20% faster sometimes we are 20% slower
on substrate VM we are also as good as
other engines on startup on JVM we need
more startup time so it takes a bit
longer for your noches application to
reach peak performance but especially
for a node.js application it shouldn't
really matter it will run on your server
for long time anyway and if it takes 10
seconds to warm up that shouldn't matter
so much if anybody of you is using it or
will be using it and you find something
that's not performing very well please
give us some information about that we
will we're happy to look into any
problems that you might find another
very cool feature about growl growl VM
is tooling talking about different
programming languages and combining them
what you also want to do is to debug
them together so you have a JavaScript
application that calls into Ruby that
calls into peyten
and that exercise some day Java data
structure we can provide you with the
debugger and further analysis monitoring
tools etc that are language agnostic so
they work across this boundary you will
see a stack frame in your JavaScript
application that is inspecting a ruby
object that has some Java data in itself
that's ongoing work on our site also
some research involved there but we can
already connect to existing tools like
the chrome debugger and you can with our
on chromium you can debug for instance
on our application in the chrome
debugger using that approach
if you want to try out what I just
talked about on the Oracle TechNet work
OTN you can download a preview of that
for Linux and Mac OS and most of what I
said is open source on ready so on
github grow VM you can download that
yourself build yourself javascript is
not open sourced at the moment but
chances are very good that it will be
open sourced within the next months
we're still trying to get all the
approvals for that but we're looking to
that Ruby peyten and are and Grug itself
so the Java compiler they are open
source already you can download them and
build them yourself right now
or use the image we're also javascript
internal chess support is included so
much for our presentation thank you for
your for being with us here and if you
have any questions to other parts feel
free to ask them now are there any
questions so our C calls in piping
supported I can give you a two-part
answer yes they are supported just as
they would be in normal piping so for
normal Titan you need you need this
native libraries we have the same
problem in no chairs no chests to some
degree is implemented in C so we need to
support it anyway
so that works but then you still have a
language boundary in between you have C
code you have piping code the other
answer is you can execute the C part in
interpreted mode on top of that stack
which will allow you to for instance
debug it analyze it monitor it both is
possible right now I would suggest the
direct call because this is not perfect
yet it might work it might not work but
it's possible in in both ways yeah
thank you for that question the next
talk in room number six if I'm correct
is Twitter they are using growl BM in
production so Christian telling uh it's
just the next talk in room number six if
I'm correct please double check who is
using that for instance and we are right
now ramping up several Oracle internal
projects that will use that but Twitter
is a think very good example they use
the JVM a lot and they use growl VM now
for some of their use cases and Chris is
happy to tell you more about that so a
wait what the question was a way to sync
when will they arrive in JavaScript the
funny thing is so what what I learned
when I started working with this
technology is that they have a node
binary so you're literally calling node
just like you would with the regular
node except that it's precompiled with
growled joyous and or growl instead of
v8 right and the when I did know - v2
check the version it was six point
something I can't remember what it was 6
vo was seven though now async/await
support was actually added to node.js in
seven point six but my application had
already been converted to a single
weight and it worked fine so even though
it's because they inherited it from v8
even though I was running technically on
an older version of node async/await
support was already there because of of
ground so vehicle script 2017 compatible
and I think you think of way it was at
at 17 or 16 not sure about that but it's
already there there will be new features
in 2018 but basically it sits there
already I think we have some troubles
with these structuring the result of an
async function that might not work on
Rogers at the moment but yeah yeah it's
very cool any other questions
all right thank you all very much thank
you
so get on Sakai please come down and
we'll answer it here</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>