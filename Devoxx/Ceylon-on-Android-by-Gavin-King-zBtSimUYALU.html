<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ceylon on Android by Gavin King | Coder Coacher - Coaching Coders</title><meta content="Ceylon on Android by Gavin King - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Ceylon on Android by Gavin King</b></h2><h5 class="post__date">2017-04-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zBtSimUYALU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I'm gonna talk it's gonna be a short
talk so I'm going to talk about getting
salon start getting someone working on
the Android platform and running on an
Android app and so on
to recap so that salon is a relatively
new programming language which features
a powerful and you know we think very
elegant static type system it's a type
system that is flexible but that is
rather fussy so it finds more bugs at
compile time when you're editing your
code in an IDE it has built-in
modularity which is very important it
has support for multiple for execution
of multiple virtual machine platforms
the JVM Android JavaScript Dart that's
important you know the language is
defined in a way that it's not specific
it doesn't have constructs that are
specific to any of those virtual
machines and instead has is defined so
that so that the constructs which it
does have make sense across a wide
variety of virtual machines you can drop
down and write code that is specific to
a particular virtual machine platform
but that is but you know when you're
doing that okay you can't do it by
mistake salon features you know powerful
interoperation with those like with it
with other languages on those platforms
with Java when you're running on the JVM
with JavaScript when you're running in a
JavaScript VM with dart when you're
running on the dart VM it has excellent
tooling our CLI our command line tools
are excellent
we have plug-ins for Eclipse IntelliJ
and the the IntelliJ plug-in also works
in Android studio I'm going to
not because in this talk I'm going to be
able to make a whole lot of you know
great use of it but rather because it
almost sort of gets in the way when when
we're using Android so you know
generally you know in under most
circumstances modularity is one of the
is one of the you know really you know
wonderful you know selling features or
whatever a so on what it offers is you
know language level constructs rather
than you know kind of build system level
constructs for defining modules
expressing dependencies between modules
you know saying my modular I'm writing
depends upon these other modules I'm
getting from somewhere else and for
controlling visibility between program
elements in modules so I can have for
example a private package within a
module that's not visible to to other
modules that depend upon my module
things like that um it provides
versioning this is rather important okay
I write depend upon a certain version of
a module and then at assembly time I can
override that version and say I'm
actually depending upon a different
version of all of the module that's one
of the things which is sadly you know
from what I've seen still missing with
with the jigsaw stuff in Java 9 is
versioning it features a whole system of
module archives and module repositories
you know so when I compile some code
with salon it doesn't produce classic
class files on a in in a directory it
produces a car file which is a sort of a
sort of a jar with some additional
metadata in a well-defined module
repository so I'm onto repository
something like a like a you know a
little bit like a maven repo something
like that and because of the tooling for
the language understands what these
module archives are what the module
repositories are you know the compiler
the runtime the the IDE or have the
ability to automatically fetch
dependencies from from within repository
within the repositories they know about
going all the way to salon herd which is
the central community module repository
it features module isolation at runtime
so I can have multiple versions of the
same module within my running program
however I will say that this depends
somewhat up on what platform we're
running on okay so on does have its you
know does have its its own module
runtime which provides that module
isolation in in certain situations for
example if I'm deploying my program as a
fat jar or as or on jigsaw then I lose
that that module isolation and then I
would only be restricted to having one
version of a module at a time in my
program the module system features in
operation with both maven and with NPM I
can import a module directly from maven
just by just by naming the maven the
maven module I'm using in my module
descriptor and then and then I'll be
able to use it if it's maven it's gonna
be Java I can use it within my um its
classes and within my salon program
likewise with him p.m. what I'm running
on JavaScript VM
finally what's the you know what's the
thing we've been working on a lot quite
a lot recently and is actually you know
super cool is a notion of assemblies and
assembler tool so an assembler tool so
assembly is the process of taking a
module and its dependencies and
packaging them up into a single archive
which is a sit which is a you know my
whole program packaged up and and and
executable so there are similar tools
for first of all something a for and you
have a new format that we've just you
know that we've just come up with called
a salon assembly archive it's a dot cast
file so that's essentially a you know as
a zip an archive containing all the
module archives inside that sort of you
know sort of Russian doll packaging
whatever you like you know along with
all the bits you need to you need to be
able to run that
that that assembly so including the the
module runtime yada yada yet they're
also assemblies for JavaScript is also
assembly authorized for JavaScript
so essentially actually actually a
better way to describe it is an assembly
archive is essentially a zipped up
module repository along with along with
the extra things that are needed to run
the program.we but there are there are
additional assembler tools okay so so so
so assembling your programmers in a
salon assembly archive isn't the only
option we can assemble it as a fat jar
alright which is you know kind of great
unless you just you know it's just a
just you know repackages all the classes
out of the module and all its
dependencies into a single a single doc
jar file and you run it using Java - jar
we can reassemble a module as a wire so
that basically you know repackage is the
modular dependencies as a wire for
execution on on Java EE we could
repackage it for execution of Wi-Fi
swarm so that well if I swarm is like a
is like a fat jar that contains a Java
EE environment together with your
program we can repackage it as a jig so
we can reassemble the program as a
jigsaw em Lib directory so we could run
it on jigsaw as a maven repo so that you
know you can you can easily you know use
the module from from within a build
that's using maven or you can assemble
it you as a dark as a dart assembly so
so there's a bunch of different options
there depending upon what is the runtime
environment you're targeting yes
yeah it's gonna be yeah it's gonna be
it's gonna be a pretty yeah it's going
to be a server application server second
flat location right whistle little more
yeah I met you I I guess what I guess
with the Wi-Fi swarm option I guess with
salons form that's the neighborhood talk
so on so on
you've got you got a bit more you know
you've got a bit more options because
it's your writing up you know I guess I
you know whatever kind of Java EE app
that you know did Wi-Fi swarm would
support yeah with with with salon war I
mean you're producing a wire I mean
anything you can do a noir I mean you
know it could have VG bees or yeah yeah
so all that's kind of all that's good
the web dot XML is kind of is kind of
aggregated in there by the by the
assembly tool alright so what you what
you get is you just get a wire right and
then you can throw that at your at your
yeah you're certainly ain't you there's
no there's no equivalent salon ear
command if you wanted a package in the
air or something but I don't haven't
seen any desire in the community for
that at all but but certainly you know
so I'm always useful okay so today we're
gonna talk about Android and the
question is you know what away you know
why is that even interesting you know
I've already kind of alluded to the fact
that the modularity aspect of salon is
is a lot less useful in this environment
and we'll come to why in a second but
you know what why would I you so on an
Android and what would I get you know
first of all look this is a lot this is
a language which is much more type safe
is you know really a lot more you know
fussy is the word that come to mind but
I mean you know meticulous about
checking about checking the types of
things and checking that what your code
is sound and so in general we attack
many more errors at compile time and
we're gonna you know the truth of talk
will say that you know one of them
major classes of error is that where
we're going to see is is is errors
relating to null which is you know and I
think you know I'm gonna clarify what I
mean about that in a second
you also get anonymous function so you
know Android as far as I understand it
still doesn't support Java 8 so you know
if you want to be able to use you know
if you want to program with first-class
functions you know that's that's
something you'll get with what Salon
salon offers a very powerful very
powerful facilities for processing
streams you know we have we have a
stream a notion of a stream that was
designed you know kind of separately you
know and before before Java streams API
so it's a little bit different to Java
streams API and it's I don't want to say
it's it's not better and it's not worse
it's a little bit different it can do
some things that the Java streams API
can't do and it can do and and it can't
do so you know and there's a couple of
things that it can't do that javis great
dreams API can do can does do but it's I
think overall much more you know more
convenient to use than Java streams API
and it's enhanced by the notion of
comprehension so you know when people
think of processing you know streams in
in most languages they're thinking about
using these operation you know these
famous operations like Mel filter reduce
and they can be great you know often but
but there are quite a lot of cases where
it's actually more I find it nicer to
use as syntactic constructs called
comprehensions okay so our comprehension
is you know the syntax derives from from
mathematics from a set the set
constructor
you know syntax in mathematics for you
so you know basically you know for all
X's in some set you know such that some
some condition you know and so and so
comprehension that you do you know
iteration
iteration on exactly this was more
declarative than that but but but let
you select from some some set of things
some stream of things they'd let you
transform the values or let you filter
the values in a way that's a little bit
more that that's actually significantly
more flexible than what you get with you
know fill the map fold because you know
it's sort of at fall when you're
collecting from multiple sources
multiple streams you kind of have to
think about how to package things up
into tuples and and and it gets a little
it can get it you know and that's
possible but it's better but you know
often it turns out to be a little bit
cleaner with comprehensions you know the
great wonderful thing about about salon
which you know I think the community you
know is totally overlooked but other
newer languages that are coming out
aren't overlooking it and are you know
and are picking up on stuff things like
typescript done Union intersection types
for you know really really changed the
way you write code really make a
language with static typing especially
in object-oriented languages static
typing much more much more flexible and
really result in you know a type system
that's more understandable that gives
you more understandable errors that that
that is easier to reason about
you'll get tuples okay tuples are I
don't use them I didn't I try not to
overuse them I don't use them you know
all the time but there are times when
it's when it's when it's nice and useful
to have tuples in the language you get
type inference and you get flow
sensitive typing flow sensitive typing
is the idea that if I test the type of
some reference to a value then the act
of testing of that reference will also
narrow so so you know in Java you very
often say if foo is an instance of bar
then you know bar bar equals typecast
and and
and that's you know for Bose it's it's
it's kind of silly and and it's and it's
also you know kind of kind of bug prone
alright it sounds you know I replace
this you know I have to use a typecast
which is not you you know which is not
really you know protected by the
compiler which in which which can fail
at runtime so so flow sensitive typing
says that if you know if I test the type
of something and I know that that foo is
a bar then then the compiler is not
going to throw away that information
it's going to remember that information
and let me use for as a bar within the
within the scope of where I've done that
test and it turns out this is this is
something we use all the time especially
since you know combined with with with
null safety you know it's it's
especially important in this in this in
this context when I have something which
might be know I need to check that it's
that it's not null and keep using it
yeah yeah I want to have it right
exactly when I have these constructs
like Union types and and and now and
it's just it's just really it's just a
really important thing that goes hand in
hand you know you have much better
support for for programming with with
immutable objects and with immutable
collections in salon that may or may not
be it's unclear to me how much relevance
that he has to Android developers but
certainly I imagine there are there are
some Android developers who care a lot
about about you know a more you know
functional style programming with with
immutable things for example you know
Salons language module you know offers
things like immutable sequences and
tuples and and and and basically
everything everything in there except
for one container type are immutable
values in salon by default immutable if
you want them to be if you want to
assign to something you have to
explicitly declare it variable and and
overall you know it turns out that
naturally you just wind up using using
immutable things and using you know a
lot more and using things like variables
and mutable collections a lot less and
it turns out that you you know actually
lose much by doing that you also get you
know as you know a syntax which which
allows for you know a rather streamlined
definition of you know model or data
classes you know classes which just
package together a few a few values the
thing we use for our domain model or
something like that all right so that's
just a brief you know you know there
should be enough there that you guys can
see that this is this is something that
makes sense there is something you know
there is enough there that you know you
might you might want to you know
consider it okay so the challenge for me
was you know as a total novice complete
outer novice to Android development
I wanted to port a non-trivial Android
app which is this universal music player
from Google which is a which is a little
I mean it's not huge and it but it's
also not tiny from Java de salón so it
sufficiently large that you know was a
good test of real-world usability of my
tooling of my of my language you know it
exercises enough Android API is it's not
just using you know the most basic
things you know and obviously I wanted
to use Android studio with the salon IDE
plug-in this is you know I use IntelliJ
with the with the plug-in all the time
but you know Android studio is it's not
exactly IntelliJ and so I wanted to see
how well that worked in practice
practice I've had a couple of bugs and
to make this as realistic as possible I
did an unholy rush alright so I was
really didn't have much time to dedicate
to this task the first hurdle you run
into when trying to use salon for for
Android development is Gradle so you
know the most natural and you know when
you're starting on a small project kind
of kind of
you salon is it is it you just want to
use the salon compiler on itself you
just compiled things with with the idea
with salon you know compiled so won't
run so the compiler has dependency
resolution and management you know
including maven Interop all that stuff
as part of as part of the module system
it's all built in so there's no you know
the the thing that people kind of use
build scripts for is just I mean it's
not it's barely even I mean I mean I
mean it's not even it's not even really
really important you know all your
dependencies are defined there and in
your module descriptor for your module
no on the other hand you know so that's
that's great but but in the world of
Android Android is extremely dependent
on the use of Gradle for dependency
management you know you run a Gradle
build that expands our assemblies into
jars generates these art or Java files
features bit just bits and pieces of the
SDK from all kinds of locations
it runs Dex which is a which is a you
know post compilation phase and an
Android once these all these dependency
to find in build dog Gradle and you know
skip it office i well you know these
dependencies are ultimately they aren't
they maven modules anyway what can I
just you know this you know get so on to
fetch them for me and and you know step
corrected me and he said no no no it's
not it's not that easy so they're all
over the place they're they're not
really they're just not really you know
they're not jars they're and there's no
there's essentially no way to get away
from the use of Gradle if you're trying
to do Android development so the
solution is the salon Gradle plugin for
Android okay so this integrates the
salon compiler with androids build
process right and so we'll have a look
you know to set it up you know requires
a little bit of boilerplate right so you
have so I mean there's minimal
boilerplate there all I basically
all right well it's a little bit it's a
little bit something a little bit extra
but basically basically it's it's here
what your boy you need to set up here's
where we where we set up the both the
basic salon plugin for Gradle and then
the Gradle plugin for Android okay then
I'm gonna list my dependencies as normal
as I normally would as excuse me as
normal for Gradle okay as a normally
would for Android here and then I set up
salon here I'm gonna name the motor with
module I'm compiling I'm gonna give it a
path to salon because I'm using I'm
using like a snapshot build of salon
this ordinarily wouldn't be necessary I
set this to true let me explain what
what that is so what is it and that's
that's basically I mean yeah that's
basically it so so that's uh so that's
just a bit of boilerplate you know they
did you would just basically come to and
look at this example happen and coffee
alright took me a bit of fiddling to get
it right but essentially it's not
essentially it's just it's just pretty
pretty basic so what so what is this so
what does this plug into well what it
does is that it lets Gradle fetch all
the the jar archives that are that are
needed for your Android app and then it
aggregates them together cradle built
into a standard salon module repository
layout alright which means that then
from salon I can import those those
modules in my module descriptor here so
you can see that you know here I have
this this duplication
over here I'm naming these these modules
for Gradle to be able to fetch them and
then over here I have to I'm importing
them from the this this salon module
repository that they're being copied
into bothered by the Gradle plugin so so
you know look guys I hate this right
this is awful
alright having to name my dependencies
in two places is really terrible alright
and you know change the version of
something you got to change it into
places and blah blah blah blah blah what
can I say I mean it's it sucks but you
know it's the it's the only way right I
even you know I even found that you know
typically usually you know when you when
you use this plug-in when you use the
you know it's actually 60 using a salon
tool which is called you know salon in
pork jars you know important we put the
jars into a into a module repository I
even found that you know because the
Android stuff comes with you know broken
metadata you can even see the broken
metadata here like tripping up IntelliJ
I mean it's just giving intelligence is
giving me
nonsense errors or Android studio I
should say I mean is there is a rubbish
you know so salon was complaining so I'd
to just say you know force imports true
stop doing they're kind of the turn of
validation that it that it usually does
and that's what can I say I mean it's
just like a pretty fragile the whole the
whole build and and run system of
Android is just pretty fragile as it was
my conclusion so you know one last point
here on this is that you know the Gradle
plugin is pretty good you know it
supports mixing of you know things like
mixing of Salon and Java code in a
single module and all the things you you
would expect so you know the integration
with with Gradle you know the solution
works but you know I love it
copying files around makes a build
process even a bit slower than it
already is you know how much that
matters I don't know given how slow the
build process is to begin with you know
what I would say about that is you know
if you're using Android you want a
language which finds as many possible
bugs upfront as possible because because
because building and run
and testing it's like so slow you know I
have to express my Belgian dependencies
twice as we've seen you know on the
other hand okay overall it's a pretty
robust solution okay and if we tried
anything to do anything smarter we would
probably end up with something really
fragile it would break between Android
releases and we'd probably be in was a
were in for a world of pain so I think
you know ultimately this is the best we
can probably about the best we can
probably do there alright so how did I
go about you know okay
so I set up this this this build you
know now I you know I have a bunch of
Java code that I'm building instead of a
bunch of salon code alright and it was
working right now you know my next step
was obviously to you know port most of
these Java classes you know I left a
couple in just to show that just to show
that we can still mix job and salon you
know to or to to port all this code to
to salon right and how did I do that I
mean there was a ferret there's a
there's a decent amount of code there
guys it's not you know it's not a huge
app but it's so the answer is that the
IDE has a function called paste Java or
salon so I you know I can you know I
basically just select some Java code I
go over to a salon file and then it's
edit paste Java salon and it very slowly
I'm tried you know tries to transform
that to that Java code to into salon
code and you know what it it works
really well it does most you know 90% of
the work of translating between the two
languages you know the languages are
sufficiently similar that you know this
translation can be be reasonably you
know automated and give you something
sensible at the end and this process of
incrementally pasting is also is also
reasonable since the since the salon
compiler allows you know module to be
written in a mix of Salon and Java code
I can do it bit by bit and and try to
keep the keep the app working all the
way along along the process right so I
go you know kind of one class at a time
or one you know whatever
and and so that works okay so where's
the pain the first source of pain is
that our IntelliJ and this is not and
this is a limitation specifically the
plug-in doesn't yet make salon
declarations visible to Java source in
the same module if they're in different
modules okay then I can certainly have a
have a job have a job you know have Java
code that depends upon salon code and
that's no problem but if there are
they're in the same module
I mean tell EJ can't make that
connection now the code actually
compiles and runs fine okay it's just
that we get these annoying read errors
highlighted in the Java code and that
makes this incrementals
so either kind of ignore the read errors
which is what you know frankly what in
practice actually did or we try to you
know and we try as much as much as
possible to translate incrementally
bottom-up right so we start with the
model and then we go to things a bit
above the model and then we go to the UI
at last and so we kind of try to keep it
so that so that there's a much as
possible we have sorry that's nonsense
no I mean top-down sorry shirts that
incrementally top-down so we have you
know sorry so we start with that with
the UI so that so that said salon
declarations are depending upon Java
declarations rather than the other way I
was stupid and went bottom-up and so I
had to deal with these red errors right
you know the other option is we could we
could separate things into two modules
but I didn't do that the second source
of pain with the rewrite is really the
handling of of null ok so let me you
know what I mean by this you know lots
of Java fields of you know if I have a
Java class it's very common that the
fields of that that you know class or
are implicitly initialized to null okay
but it's rather hard to mechanically
you know the salon - you know para tres
Java salon tall it's very hard to
mechanically distinguish which of those
fields are implicitly known which are
which are actually initialized within a
constructor or whatever the problem is
exacerbated by some nasty patterns that
are used in the Java world which
shouldn't be used probably where instead
of initialization being done in
constructor initialization is done a
little bit later in some sort of you
know callback method oncreate or you
know initialize or after or something
right and and there are some ja there
are some you know Android api's which
work like this okay so in this case you
know you have this field with you which
is actually you know in principle known
now Bakr but because it's it's
initialization is delayed until after
the constructor and and it's done in
some magical method that you know has
some life cycle that we know that you
know pays Jarvis alone can't really tell
anything about you know it's awfully
hard for patience still there's a long
to distinguish you know which of these
fields are really no and so basically
you know kind of does the best it can
but you know really most of the time it
just goes all right you know this field
I don't know and so then I have to come
by you know mechanically and fix that
all right
so I want to get a little bit deeper
into this problem so when I talk about
null safety I don't just mean that my
language has nullable and not nullable
types okay to me that's the you know
that's like a 10% solution that's like
the crap way all right so so to see what
I'm really talking about we're going to
come to this this idea that in Java null
is the default value for an
uninitialized field doing worse than
primitives where it gets initialized to
zero or whatever but let's let's set
that aside okay you know
so things that are by default
initialized to know and Java doesn't
even doesn't do anything do any work at
all to present prevent access to
uninitialized fields not even if you
declare them final okay so you can see
you can see you know the value the you
know this now value all right now now if
if so one more you know would follow
this same approach and you know there's
some other languages okay you know
floating around at the moment that I had
that do you know that also the do
followed this approach and claim to be
null safe and and and I would argue that
that's you know a misunderstanding if
someone were to follow this approach
then these novels of these unofficial
eyes and initialized fields could leak
out into into values and and and and
method return types which are not now
and thus resulting in you know
unsoundness in the type system okay and
then we could get you know the same
problem of no pointer exceptions far
from far from the point of of the bog
where where a null was assigned to
something that's that that's not
supposed to me now and and so you know
the for this problem null safety is a
much amount is as much about
initialization logic as it is about
anything else
so in still alone in order to preserve
the soundness of the type system or null
can't be assigned to something that's
not now something that's declared on now
we actually have some pretty
heavy-handed compile time validation of
your initialization logic in a class or
whatever it is okay so the compiler
actually looks at your initializer the
the type checker looks it looks at how
you've initialized your feel and
prevents you from accessing the fields
of your own class in a way which would
which would expose an uninitialized
value of a field now this is a hard
problem right and it's and you know the
best we could do the which is which is
pretty good is too heavy-handed right so
it has too many false false positives
right too many cases which it'll reject
which are not actually
in particular it's can't handle circular
references
alright so circuit there's no way to set
up circular references a circular
reference between two objects in a way
that the compiler can see that that is
safe okay so what we have is we have an
annotation called light which marks a
field as being initialized later and the
behavior of that is that if I access a
late fear that I'll suppress the compile
time checks on on on ensuring that it's
not accessed before it's initialized but
if I do at run time accesses before it's
initialized don't get an immediate error
at run time okay
that's still better than a
nullpointerexception far from the point
of of access of you know an initializer
anyway so I know that one a little bit
deep so you know the point of all that
is that you know the translation to Java
in law involves lots of manual
intervention but divided between or
decide between all these cases so the
field really is knowable I need to look
at the code and decide so the field
really is nullable i need to declare its
type you know may be whatever may be
time okay all right if the field can be
definitely initialized in the
initializer constructor of the class
well I don't need to do that you know
then it's then I'm okay
if the field really is initialized just
once but in an oncreate type method so
late then I you know what if we're not
sure what I'm doing is using the late
annotation okay and you know know that
any one of these cases the field might
be variable in which case I need to
annotate it variable so there was a this
was without question the most the most
difficulty that was those involved in
the rewrite was was really understanding
really was what was the initialization
model of this java class and that's
because you know what I mean
Java kind of encourages you to play a
bit fast and loose with that stuff and
that's a source of bugs in Java and
initialized fields or
and you know so all this was
sufficiently tricky that actually
screwed up atop us a couple of times and
when I ran the app I got you know
initialization errors and and you know
ouch but but they were better than
tracking down null pointer exceptions I
would say that those were basically only
problems I you know the only bugs on
candidate runtime except for one which
I'll mention later you know it is
completely usual and completely normal
in salon that the compiler finds my bugs
as soon as I typed them you know there
was one class with such a complex
initialization logic that you know I
really had to struggle a bit to come up
with something that compiler would
accept what can I say and I'm just just
wondering which which class that would
have been show you guys
yeah I mean so you know you can kind of
see you know you can kind of see the
kind of things I end up with you know I
have you know all these fields which are
set up which are initialized actually in
the relation in this this oncreate
method here right and so I have to mock
them away you know I mean in a way this
late annotation is the you know can I go
back to what I would get back to what I
would have with Java sort of sort of
yeah look if I if I you know if I could
I mean like I need to be a bit careful
here I'm copying Google's code all right
perhaps there's a way to write this
class that doesn't involve doing the
initialization in the oncreate I don't
know I didn't you know trying to try to
figure that out okay maybe there is a
way but the way the way the the code I
was working on work was was to do the
initialization of all these things here
in this and there's a lot of stuff here
right that there's business being
initialized right in this in this
oncreate method and you know whereas it
would be far more natural in salon to do
this sort of initialization in the
initializer in the constructor or
whatever okay if we were initializing
those you know right here in the
initializer you know I would have here
is you know value music provider equals
blah blah blah right if all they're
doing if I were doing it in a
constructor I would just have music
provider that right so you know I had to
learn to take these late to suppress you
know to allow that initialization to
happen you know later down the track you
know on the other hand as other examples
just in that one you know there's other
examples like this where what we really
have is something which really does
start out no and really is variable okay
you know and if you look we look at the
Java card it's hard to tell this case
from from these cases we were just
looking at right they look the same in
Java okay but do you know in this case
you know once you once you carefully
look at yeah once you carefully look at
how the things used in the java code you
realize oh this is actually a you know
this is actually something which is
assigned and reassigned and can be null
in between okay
another thing another thing I change and
nothing that took me a little bit of
time is that you know it's extremely
common in Java to have a local variable
which is you know which we kind of say
oh I set it to something then if
something set it to something else then
if something else said it to something
else where we have a local variable
that's assigned and reassigned you know
and paste Java whistle on handles that
perfectly well it just annotates the
thing variable cause it's can see it's
being assigned but that's kind of bad
style and so I felt like I should
eliminate all those all those uses of
variable and rewrite the code slightly
and it turns out cleaner to do that
something I found was extremely common
in
in this in at least this this Android
code was lots of switches over integer
constants now this was a real surprise
to me that you know in 2017 we have
stuff like this right this really
surprised me I thought that we wouldn't
still have stuff like this
given that Java has any known since I
was a surprise and and salon and one dot
3.2 doesn't actually allow you to switch
over integer constants like that because
they're not guaranteed to be disjoint so
in order to let myself write code like
this and make that make the translation
easier because there's quite a lot of
places that we're doing this I you know
I kind of kind of got bought reporter e
writing switch cases LC if so I what I
did was I degrade I downgraded a
compiler error to a warning so you can
see that without this suppress warnings
here it says you know case refers to a
constant value so you know these are not
provably there's these things these
cases here and not provably disjoint
okay but you know why sir and i suppress
that warning so i've used that in quite
a few places in the code to let me just
just to make the translation easier so
now we can switch on incident integer
constants we're always able to switch on
integer literals because the compiler
can prove that those are disjoint so as
promised i was able to use anonymous
functions okay also able to make use of
you know anonymous functions in a couple
of places however this turned out to be
a little bit disappointed to say that
this was less useful than i had expected
because quite a number of androids to
call back types are abstract classes
instead of they're not instead of single
abstract method interfaces okay so the
same classes are in fact their classes
with a bunch with several abstract
methods okay
so you know which is to say that
androids the androids api's aren't
really set up either for Java you're for
salon or for Java 9 and that even when
Java 9 comes they're gonna get a lot
less value out of out of anonymous
functions and perhaps people are
expecting so I was wound up you know
using our version of anonymous Costas a
little bit different to javis instead of
lambdas I have open an issue to request
that we had support for using for
conversion of anonymous functions to
single abstract method classes
specifically for use for Android
development another problem I ran into
was something that I pulled my hair out
for about a whole day over which was
that when I was translating the code I
changed a which one was it was
no I don't report it was anyway there
isn't there is an API in Android which
accepts a single abstract method
interfer interface and so I used an
anonymous function and I thought
everything was great
there's another place where anyway it
turns out that the identity of that
thing matters and that the identity of
the single abstract method object I was
supposed to be passing in was supposed
to be the actual class that was that had
something that was using this thing and
and this introduced a bug right and I
wish did a serious amount of time over
that I know I think the API was terrible
and I think it was even more terrible it
was utterly undocumented the the sample
app doesn't you do a whole lot of
interesting stream or collection
processing you know I did use you know a
couple of trivial you know I did do a
couple of trivial things I'm sure we can
find them here you know you can kind of
say oh you know I used a comprehension
here you know this class became a lot
simpler you know there's another one
where this
you know I'm using you know some stream
processing functions you can see here
and somewhere else here find you know I
meant simplified the code a little bit
you know certainly certainly nicer than
what the previous Java code was doing
Java you know free Java eight code was
doing but there wasn't there wasn't much
in the app for me to really be able to
point to and say hey look this is
amazing for now I didn't bother to port
the code to use Salons collection types
insulin collection so I just lift it
using Java util collections right
because they work fine you can use
there's no reason there's no reason
writing salon to avoid using Java
collections they they work absolutely
perfectly fine and so on and you know
unless I would have wanted some
particular feature I just didn't have
enough motivation okay here's a his his
so the java language itself doesn't
support null safety but a number of java
libraries offer nala ball not now non
null etc etc annotations okay which you
can use to to try and introduce some
null safety into your java code okay i
particularly love them i love everyone
who uses these on their api's okay
because this alone compiler can look at
them and when it's assigning a type to
these things you know from the point of
view of the salon of the salon code it
will see that these things are either
nullable or not null and assign this
correct
salon type as you know maybe through
offer right if it doesn't have one of
these annotations and it cannot then it
then the compiler realizes it doesn't
know no kind of marked a method or field
as rule that all this might be now and
I'm gonna have to insert some runtime
type check and and you know so let make
sure that that null doesn't creep out
doesn't leak out and cause and soundness
in your salon code but you know it's not
as good as as having it really be you
know a truly type safe at the point of
interface between the languages now
Android has a nullable annotation where
and I thought perfect great but
unfortunately it's declared retention
source and I understand that at all it's
crazy
seems it seems utterly nuts to me so
it's absolutely useless to us and that
was really disappointing because some of
their api's doo-doo-doo so you know I
forgot to UM I forgot to show you what
you know so let's say what the app looks
like you know oh what happened here
suddenly the phone got really big oh
when we changed I changed screen mode so
you can see I can run on the Android
emulator so you know my my conclusions
of all this process were you know I'm
actually really happy with the end
result
the code is significantly cleaner it's
significantly more typesafe I know that
you know you know I'm you know from my
experience and from looking at what I've
what I've wound up with you know
maintaining this code would be will be
extremely hard for me to introduce bugs
when I when I change it you know someone
is a very very type safe language you
know there's not gonna be you know nulls
aren't gonna creep into my code anymore
you know the you know this happy is you
know it's it's okay but because it's you
know kind of basically most of its you
know sort of pretty where's my sound off
are you kidding me well so it plays
music
right it really does I promise if I
unplug this great so you know I mean
it's pretty cold a little app okay how
long I spent trying to make it play
music so you know overall but most of
the app was pretty you know kind of
pretty mechanical UI oriented plumbing
code you know shifting you know dealing
with you know some pretty you know I
don't I slightly complex Android API
eyes and you know so I didn't I didn't
have a chance to really show off you
know anything about so long that's
really awesome that really made it you
know the code really really really
different but you know it's still it's
clean its good Sloan IDE on Android
isn't perfect it does have one huge
advantage over other languages on
Android which is the Salone problems
view right unlike developing Java on
Android if I you know change something
so for example here you know and then
you know I switch over the problems view
then salon will will you know in the
background type check the entire project
and show me all the errors that I've
caused across the entire project so this
doesn't happen in the in the in when I'm
developing Java on Android I have to go
up and you know and explicitly open you
know this file to see that to see that
that error occurred okay that's that's I
mean it's it's terrible coming from an
eclipse background like I do you know I
find that just you know amazing that
that IntelliJ doesn't do that so we
didn't think that was good for for this
good enough for the salon pro plugin so
no what was that change I mean you know
if I fix it then when I when I get back
home you know just tough Jackson the
project so that's a big advantage one
thing that really annoyed me is that for
some reason you know the debugger works
more or less I can step over code and
and you know it works more or less for
some reason setting breakpoints in salon
code didn't work when I ran the code in
the in the Android emulator
that's not normal I'm not sure if that's
something related to Android studio if
it's something related to Android we
need to dig deeper into that would you
fix that I did run into a several bugs
here in in the IDE and I'm done thanks
for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>