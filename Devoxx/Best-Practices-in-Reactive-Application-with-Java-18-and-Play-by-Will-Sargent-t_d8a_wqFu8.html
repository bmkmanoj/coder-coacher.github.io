<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Best Practices in Reactive Application with Java 1.8 and Play by Will Sargent | Coder Coacher - Coaching Coders</title><meta content="Best Practices in Reactive Application with Java 1.8 and Play by Will Sargent - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Best Practices in Reactive Application with Java 1.8 and Play by Will Sargent</b></h2><h5 class="post__date">2017-04-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/t_d8a_wqFu8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">imagine more people will be filtering in
as it comes in but hi I'm well sergeant
I work at light Bend on the Play team
and play just recently celebrated its
anniversary came out five years ago now
which is really strange so it's good to
go back and reflect over some of us
especially when describing some of it
too well basically from first principles
so who here is heard of play hands up
okay pretty much everybody that's great
who here is used to play first hand okay
we've got a couple of hands in the back
let's see who who knows or thinks they
know what a reactive web application is
yeah yeah this is actually an
interesting sort of dichotomy and and
one I actually like initially wrote up
these talk notes for us we talk about
play and we talked about reactive and we
talked as if we know what that means but
the truth is that reactive is fairly
simple it just it means different things
in context and as a set of assumptions
and underpinning so we don't usually
talk about when we talk about reactor
which is like let's plug this thing in
here up like this other thing in here
but we don't really talk about what
we're doing and why and how this matters
and how you plug this into something
that might not be reactive or might be
blocking in some way so plays been
around for five years as I said we just
released to dot 5 13 and we have a 2 dot
6 milestone coming out which is going to
support HTTP two so that is really
exciting and real soon now and because I
know that the first five minutes of any
video presentation is usually something
people skip past we're going to start
off with a little demo right now showing
why we can actually call this stream e
here which is an
named for the duo 5x series so we have a
example here called play chatroom java
i'm just going to start it up you can
see the chat rooms java is something
that we download off of the web pages so
if you look at the download plays
download page right up here you can see
you can download a starter page for
newbies you can download a seed template
you can download samples and if you
download any of the samples here the
java projects this one this first one
here is the one that i'm showing you and
you can actually download this and it
comes with its own zip file you just
type SBT run and then you can try this
out in your own machine right now so
this thing has started up we're going to
bring up one machine over here or one
type of here i should say and we're
going to bring up another tab over here
so we've got two loops bring them over
there okay so I've got to chat rooms
type into one shows up in the other one
so this is a very simple play
application under the hood you want to
see what it looks like it looks like
that so this sets up a source we have a
merge hub we send it to a broad car tub
we set up the flow we send it through
web sockets and then we specify a text
protocol and then there's some stuff
down that we don't show about same
origin extra security but that is it
text you send up into the server goes
down through to all the others all the
other clients that are registered for it
and we can do that in one two three four
five six lines of code so this is
reactive streams this is the stuff that
react to streams was actually originated
with them was built with akus tree we
play integrate with akka streams seem
seamlessly and
so all the anchor streams features that
we have we can actually plug in and be
able to pass through all of our
streaming stuff so that is one thing
that play can do right out of the box
right now you can go home and download
all of this we also have examples
showing server side sockets and showing
other examples of file uploads and
streaming uploads and streaming
downloads and things but this gives you
something to play with like right here
right now and the bigger question that a
lot of people have on going to play is
deceive us and they're like okay well
that's cool but how does this work for
my company like why would my company
actually want to use play and the answer
is play is fast play is really fast if
you look at Game of Thrones you're
watching Game of Thrones you're watching
something which is essentially play it's
major league baseball and they work with
HBO and they stream all of the stuff
through web sockets all of the data that
you see is coming through nitro actually
found great improvements using the Nitro
and HootSuite HootSuite I believe
actually managed to reduce their servers
by eighty percent or so so they're able
to just scrap them because we found out
that play was so efficient linkedin
linkedin actually moved to play for all
of its individual rest api needs and
it's interesting you should really go
look at this slide deck unfortunately i
can't really go through it myself but
you can see so here's the HootSuite one
eighty percent luring customers AWS bill
and you can see walmart canada actually
said that it reduced its development
times by two to three percent sorry two
to three times not to three percent
slightly different so yeah so a lot of
people say a lot of nice things about
play and the fun answer is play as fast
because we're awesome
but the truth is that players fast
because it is a reactive web application
and the reason why that matters is
because reactive web applications have a
very different architecture internally
so when you're looking at CPUs and
you're looking at CPUs these days cpus
these days can be fairly huge like a
skylake processor which is the one
that's actually coming out like early
this year or something it's got 32
physical course on one processor all of
those cpu cores have to be fed data a
CPU is like a wood chipper if you don't
actually feed it things to do if you
don't feed it jobs then it's essentially
idle and it's just sitting there it's
not doing anything so a big part of play
and a big part of the architecture of
out play is to make sure that those CPUs
spit stay occupied and stay busy all the
time so whenever you're seeing play run
through something play has a number of
clients that send an HTTP it sends in
stuff it processes it it sends it back
out how does it actually do that
effectively well the way that it does
that effectively is it takes all of the
CPUs all of the cause inside of the
single sink CPUs and it says I'm going
to create a thread for each one so each
thread maps roughly not always
necessarily to the same core but you've
got 32 cause you've got 32 threads and
it just keeps all of those cause busy
all of the time if you've got an
entirely saturated thread pool then
you'll see your CPU go to some like
ninety-five percent well you'll get
great throughput you aren't necessarily
great great latency because the job do
you can actually wobble a bit on that
but you will get as much out of the CPU
as you physically can and so play is
reactive because it actually does that
and it manages to do all of that by
mapping functions with futures so that
when you're actually calling something
you can say I have some work to do I'm
going to send it off to where it's going
to be most appropriately used and we can
get into the technical details about
that but the big difference between play
and the blocking API is that if play is
waiting for something if you're waiting
for something and you're doing it in
play then that's actually not a good
thing because save got an eight core cpu
and you've got eight threads if you've
got something which calls out to the
database and you've got it calling out
to the database and it's waiting for
that response back you've not just taken
up a thread you've taken out 18 of your
cpu processing capacity because while
it's waiting for that request while it's
waiting for that response to come in
from the database it's not giving you
data back anymore and you can't render
any more pages the CPU could be doing
other work but it's not going to because
you told it to do this and so it's going
to keep doing that so so reactive
applicate reactive web applications take
the idea that you should actually move
things between different threads and
different thread pools when you have
some things which don't show up at the
same speed so the idea is you always
keep DCP you busy and the CPU never has
to say that it's borden it needs more
work so let's start off by showing you
what this actually looks like so here is
a play application here is the homepage
so let's go over here and let's start it
up we've got SPT the run the build tool
and we're just going to let this go
through and start itself up and while
it's doing that I can show you the CPU
beep sorry the Java home page showing
you the manual where everything is kept
and initially we are going to just have
this run inside of a database what we're
going to have this run against a
repulsive
that's local so we're not going to have
anything where we are having to worry
about threads or thread pools internally
and we have to worry about the efficient
usage of this office system we are going
to show you there we go so here's the
play rest api bring this back up but and
you can see here the basic structure of
a play application when you come in and
you make a request it's going into this
index page and you're seeing okay it's
rendering this with it 200 and it's
calling this and when you see the views
you're seeing that this maps to this
HTML template over here and the route
saying that it's going to be the root
page says is mapped over here so we have
the method over here on the side and we
have the router over here on this side
if you've seen play it's very similar to
play and then we have the functionality
and the functionality says we can go and
we can see if there any post here so
right now we can see we've got some
Jason and we're just going to spit out
this link title body etc and what this
does internally is it shows you here
we've got a post controller and this
goes to so I've got a routes this goes
to post op routes this goes to post at
rats over here we've got something
saying on here on the routes inside of
this we call this lift method this goes
in here and calls out to this guy so we
have a resource which is the thing
that's rendered for the Jason so this is
in Jason style and then we're going to
have something on the back end which
takes this jason and actually maps it
through so we've got a repository on the
back end and we're saying when we get
some data back from the database we are
going to change
it up a little we're going to add this
link into it and we're going to hand you
back a resource as well so one is the
data object on the back end we've got a
presentation object on the front end so
we've got this data over here and we've
got this data over here so this this is
what happens when you talk to the
database and then we've got this
repository which is calls list and then
that goes back to an in-memory wall
story here and this is fast like we can
call this and we can just say get the
stream of data out and just list it and
what will happen is it'll just run
through all of this it'll all happen on
the same thread there won't be any
latency before sorry there won't be any
delay any waiting or blocking because
it's all happening internal to the
machine and everything's cool so that's
what happens when everything is good and
we can go ahead and we can actually add
some metrics to it now so we can say
we're going to add this wrapper around
it called post action and this post
action is an annotation which we can say
all right when we get this we're going
to add this metrics registry so this is
koda hell metrics or yeah metrics if
you're familiar with it and we're just
going to say we're going to mark this
and we're going to time it and then when
we're actually done we're going to close
it and then if it turns out that it's
not Jason and we just say we only accept
that it's a translator so we can do a
lot right off the bat this very small
amounts of code in play but let's find
out what happens when we look at the
database and unfortunately I did set up
a load test on this using gattling so
you can run this on your machine
unfortunately this is a fairly old
laptop and my cooling fan broke down
last night so it took awhile for me to
understand like when I was running load
test why my computer would shut down so
unfortunately I can't really test this
right now but at least I did find one my
computer was making funny noises and
then dying yeah this is these
things they don't tell you about making
slides so we've got a something that
looks like the same API right okay so
this is stream and this is post data and
we've got a post controller right here
and we're just calling candle find and
it's calling everything and it should be
great right so here is the check out
this revision so here is the in-memory
repository we're just returning the
singleton lists here's the jpa
repository the GPA repository call sis
jpa api which yellow saying and then we
have a couple of things in here to wrap
this in a function and say che PA with
transaction and then we're pulling it
out of post data over here so if you
look at post action here sorry no post
action post data this is actually an
entity now so standard jpa and then you
can see this is returning a stream and
for select and it's returning a post
data and it's returning an optional for
when you want to do a get so we are
we've expanded on the API a little bit
but it's still fundamentally we call the
post repository and it gives us data
back now problem is is that the JPA
repository is on another machine and
it's a database and it's jdbc is a
blocking API so it's not running at the
same seed at the CPU so if you have
something that's running at a different
speed than the CPU what you need to do
is set up in a synchronous boundary
around it so that you can say within
this area I'm going to use a different
thread pool and then if this thing
blocks over here it doesn't matter when
it completes the future will return me
this value and this value will actually
drive that result back to the response
that will result back to the browser
because we will know at that point that
we actually get the computation that we
can continue rendering this request so
we don't want something that
actually using post data here we want to
set up something that uses a completion
stage and completion stage is the
java.util concurrent way of talking
about futures so when you actually when
you're saying I have a completion stage
of post data you're not saying I have a
post data right now you're saying at
some point in time I have a post data to
give you but it may not be right now and
so when you say I have a completion
stage then you can take that completion
stage and you can say okay cool when you
do this I want you to take this and I
want you to turn it into this other
thing over here and then you can return
the result of that and that is really
what makes play a reactive web
application is we have the notion of
threads we have functions and we can
combine functions with futures so that
we can perform a synchronous
non-blocking communication so that when
we have things that don't move at the
same speed in play we can actually say
here is a blocking just JP a repository
here is the put walking postal story and
here it's here is the non-blocking
version and then you can say we've got
completion stage and we are doing a
supply async so let's bring up SBT again
and while we're doing that on what I
would like to show you how we actually
configure the database on the back end
so we've got in-memory database driver
so this is a simple test database we've
got some jndi setting we've got some jpa
and we've got a fixed connection pool
here and the fixed connection pool is
the thing that we actually wrap with to
JP a post repository so this is if you
look at it here is the JP a
configuration that we have and then
there is a formula for determining how
many how large your thread pool size has
to be and how many database connections
you need and this is interesting because
it turns out that the number is the
number of physical CPS physical course
that you have x 2 plus an effective
spindle count which means that the
number of database connections you need
is like nine so you've got a connection
pool of nine call at ten it's a nice
round number in this case we've got a
two cpu machine so this really should be
five but that's perfectly fine for now
and we just set up an executor and some
throughput and say that we have a fixed
Rupert size on this side to be able to
say that we want to configure a thread
pull over here as well so we've got a
jpa post repository and we are saying we
want to post execution context the post
execution context when we look at this
guy calls out to the configuration that
we already got and just does a look up
and then from that it's actually the
same thing it's a execution context
executor which maps back down to the
same thread pool access so here we go
we've got it's almost exactly the same
API here we're doing the same selects
and the only difference is that now
we're calling
why a sink and we are supplying this
execution context whenever we are
calling this and then on the front end
all we have to do here is we've got a
completion stage which is being called
out here so this says okay we've got a
database from the back end we're going
to take the Stata base from the back end
we're going to turn it into a resource
and then we've got this thing over here
we're going to say we've got these posts
we want to turn these posts into a list
then we're going to turn into Jason then
we're going to send them out out of the
front and then that's all you need to do
as long as you're actually specifying
that you have a different thread pool
and you passed an execution context you
can come you can send in a completion
stage of result to play and the
completion stage results play just says
get to this when everything else is good
so will render then there will be
another execution context but that comes
along but at the end of it you will have
a joined-up completion stage and it will
just keep running through that and if
it's blocked it'll do work stealing
it'll move on to something else so those
course will always be kept busy so let's
see that at work as it's going by the
way am I going too fast too slow I'll go
all right good yeah so um I just let's
see github yeah yet that's a java chat
room example we've got a Java rest api
example this guy okay so this is the
finished version so if you go to github
com and you go to play framework job
played dash Java dash rest api dashed
example this is that this exact thing
it's got a couple of extra things that
will get to but you can see and we don't
have like the blocking stuff but we
you have a timeout post purple story so
that's fun so yeah so we've got the JPA
in the background we've got a handler
sitting in between it just doing the
presentation and the reason the handler
is important is because like right now
we're doing Jason at the back end but we
could each we could be doing XML or you
could be doing HTML and so we want to be
able to do to switch easily between
content representation with the same
data so that's where this comes in and
on the front end we've got the post
controller and this does what you expect
and then we've got the action sitting in
the middle saying okay when we go to all
of this go ahead and do this and you can
see here there is a little extra code
here because when you do a completion a
sink if you get an exception in this we
want to be able to say don't give us any
details or anything just returned a
server error so the way this looks HTTP
and one of the nice things about play is
it actually has a hot reload that
feature built into it so as we re
compile code and touch it we can do that
on a running server and just have
immediately matchup and here I actually
change the type of this guy so I may
have to do that because this was
actually an integer only changed it to a
long so let's jump up to the top and
we've got SBT type run use the built-in
server over here
and now we've got call this it's going
to give us a 404 I think because we've
got not got anything found here at this
point so girls having compiles the tooth
codes which are the two clips things
which actually changed in Scott plus one
we called circuit breaker because that's
what I was playing with last so here
we've got an empty list so okay we're
going to go ahead and we're going to say
let's do a post but call us again and
then let's repeat that with the posts
and then we can say all right now you
can see that doesn't different ID every
time and it comes up now one of the
things we want to do because we have a
project that we are putting together and
we have a database call we've got play
working fast but we still need to be
able to do something so that if we get
if we don't get a response from the
database back fast enough we can still
return something so what we actually
have here is we have a timeout so you
can have a non-blocking time out that
you use in play that says you've got a
completion stage over here and you've
got an incoming data base request
happening and if this render doesn't
happen within this amount of time render
this other future instead which is going
to give you a gateway timeout so this
tells you that something didn't work in
the back end so we go ahead and we say
all right do it down whereas a town so
this says here we have a timeout
wrapping this dou call and then we also
if the database is acting up and is not
returning any results at all that as the
database is completely down we don't
want to waste any time in being able to
tell the user that the database is
completely down or might be overworked
we're just not getting anything back
we've just got too many error messages
so one of the things that we can do here
is inside of the post repository we can
set up a circuit breaker and this
circuit breaker will just put a get
around the look of this get this get
will actually wrap this checked
exception here thus sqlexception and so
when we call the disc then you can see
we've got a service unavailable the
service unavailable is because when we
got up to this post action it went
through and it said we've got a
fail-safe exception and therefore the
circuit breaker is open and let's return
this instead and so this gives you a
play applicator play application a
reactive application which uses the
database the most effective way that it
possibly can use as a CPU the most
effective way that it possibly can the
memory player stateless so you can throw
requests that are all day and all night
and it won't keep hold of any HTTP
sessions and it works in mechanical
sympathy with the machines that you've
got so the memory yeah the memory that
you are actually using is for the
request itself it lives in Eden it's
really easy to garbage collect you can
handle a lot with a fairly small GC heap
size and you don't have to suffer from
the GC overhead of having huge heaps
that you have to run through all over
again so so yeah that that is the best
practices as far as I can make them in
inside of a one hour slot for talking
about a blocking database and how to
make play work with blocking api's on
the back end so at this point I would
like to show you a couple more cool
things
one of them is a in addition to the
external Izzy this thing we have we have
the ability to render things not just
for a single page and not just streaming
for Jason so if you have a single page
web application play is really popular
for those so LinkedIn users it for a lot
of react stuff and a lot of ember stuff
I know they have something called
Pemberley but they also linkedin did
something really cool where they said
let's actually use threats to our best
advantage and let's start rendering a
lot of different things at once so this
is something that's called big pipe or
pagelets this particular example is
called pitiless where you can actually
render different sections of the page in
parallel and have them all filled out as
they're coming in so all of this you
pull in a request it kicks or several
requests to the back end all of that
data comes in at all turns into futures
and as they come in all of this page
each section of this is actually
rendered individually and if it times
out only that particular section times
out so that's cool and we also have a
number of modules here come here Jones
so we actually have a modules directory
which talks about all of different
things you can do with API hosting
assets sprite authorization North Anna
gation datastore database migration etc
there is a lot there play users juice
underneath the hood but we actually have
the option of working on spring or you
can actually use compile time dependency
injection so you can actually get play
working on dagger 2 and at that point
you can simply say all of this stuff if
it doesn't compile it doesn't actually
have a dependency for it the code won't
actually compile at all and that just
means that whenever you're running play
you
run play completely secure in the
knowledge that you're not doing any
runtime dependency injection at all okay
all right so I feel I've talked rather a
lot I would like to open the panel open
I would like to open the floor so that
if anyone has questions I can fill you
in and also I'd like to know what it is
that you're doing and what it is that
you're interested in play for and doing
things with okay so who's interested yes
yeah yeah so that that really goes back
to so if you look in the application
conf here its size to the qatari hikari
connection pool and here you can see
there is a page and it's called qik recp
about pull sizing where he talks about
the algorithm for determining how many
requests a second you can actually get
out of a cpu out of a database and this
is oriented towards the max number of
connections on the database slide so
here I did cheat a bit because I assumed
we only have one play application server
and so the number of play application
servers that you have you have to divide
by that to make sure that it matches the
total on the database side but for this
we've got a one-to-one so this is fine
but you don't need nearly as large pool
as you think you do and you should also
be load testing in all cases to be able
to find out where it is that you're
getting data not working in terms of
doing the best possible tuning it turns
out that light Bend has a production
suite which has a fantastic monitoring
option it's available very cheaply and
well I shouldn't say cheaply but it's
very cost effective because it knows
exactly what all of the threads it knows
exactly what a kerr is doing internally
and it can tell you where your overhead
is so yeah if you're going into
production I highly advise that you have
all of your monitoring and operations
set up because it really does it's one
of those things where it's like you can
get the best possible performance out of
play having said that you know like CPU
time is expensive I didn't realize how
much service actually cost until like I
saw the bill one time and it was like
okay all right that now I understand why
people are intent on saving money on AWS
so
yeah yeah this is this is actually
Hikari cpu is the connection pool that
play users underneath the hood and he's
written quite a lot about performance
and about getting the best possible
optimized load out of the machines so
he's done quite a lot of work and he's
frankly more than willing to talk about
it so yeah there's a lot of stuff okay
yes yes yep yes so if you go to the Play
Framework download page the seeds
actually we we have been gradually
rolling out on the Gradle support
because we're still not sure about the
fine inches of it I'm personally far
more familiar with play but if you
download and start up a new project play
java seat or play Scola seed then you
can find that there's a great old file
inside there to just run it and it has
hot reload capabilities and I know that
LinkedIn uses this extensively yep all
right questions all right cool thank you
very much you've been great
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>