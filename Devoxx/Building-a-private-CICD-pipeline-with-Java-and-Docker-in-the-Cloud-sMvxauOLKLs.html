<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building a private CI/CD pipeline with Java and Docker in the Cloud | Coder Coacher - Coaching Coders</title><meta content="Building a private CI/CD pipeline with Java and Docker in the Cloud - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building a private CI/CD pipeline with Java and Docker in the Cloud</b></h2><h5 class="post__date">2017-04-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/sMvxauOLKLs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you for being here in a very loft
floor of the very last day appreciate it
and now we're going to talk about
building the private CI city pipeline
with Java and docker a my name is borrow
and develop advocate with AJ frog at J
bar on Twitter and pretty much
everywhere else and this is basically
what I do in my job and today we're
going to talk about docker so that
usually requires a lot of both actually
before we start just to calibrate a
little bit the level of my talk and
let's do some fun polling so I'll show
you some questions and you just keep
your head your hand up until it's not
relevant to you anymore
okay so let's try that who heard about
docker everybody all right now keep your
head and hands up until it's not
relevant to you anymore who can do the
tutorial all the hands are still up and
who played with it a little bit in their
job mainly for pride some stuff okay
most of their hands are still up and how
many to get the production or you can
take down the head now yeah yeah that's
okay that's okay
in any hands still up in production one
two now he's just filming two three okay
so that's that's normal that's a normal
picture it wasn't really polled because
I knew exactly the results so it's kind
of the manipulation and and this stock
will try to answer this question why you
don't take dr. interaction and and give
you some advices that will build up your
confidence in docker so you actually
will be able to do that since all of you
know about docker and all of you play
with it and does it tutorial and
everything
I will happen
peeps the next slides that are
explaining what docker is and we will go
right here that's the answer to my
previous question right so what the
problem with docker and this is what we
hear from a lot of our friends users
customers etc is that it adds another
level of this OPEC not from the parent
level that we are not sure what's going
on right so what I'm going to talk with
you about today is kind of building the
integrity and the trust you need to be
able to run docker safely in production
now and the reason I'm speaking about
being a developer advocate is Jeff frog
and not working with an ED docker is
because I think that we as a company
have a very long-standing relationship
with docker and that the picture depicts
it and if you didn't if you aren't sure
what's going on is a frog is hugging the
whale right just to make sure that this
is what's happening here it's hot we'll
have Dhaka right and and then the reason
we are dealing with docker is that so
this woman hikes the creator of docker
send on stage of docker con 2015 and in
San Francisco and asking the audience
the same question
that's another manipulation of mine
let's play it again so what he means by
this question who is using docker is
nothing else is you know think about the
company and you're a software process do
you use any other technologies except of
docker so that's kind of the question so
he uses dock and nothing else no one
that's perfect
with this small audience it was the
exact same result of course at dorker
corner thousands of people in the
keynote
just because using docker nothing else
doesn't make any sense doctor that this
whole container analogy works very well
here because in the real world no one
will
a company that only ships empty
containers back and forth doesn't make
any sense
there is something in it and the same
with docker there is something in it we
are at devoxx so probably most of you
put your java into dr. am i right
java yeah okay and the rest of you put
other things like maybe NPM JavaScript
and dotnet or Python I don't know what
doesn't really matter you have something
in it and what we do as a frog is we
manage those binaries those docker
images together with other technologies
to provide you with the link between
them that you need but that's an
corporate plug that I plug that I won't
do now - not what we are going to speak
about now is patterns that apply to
docker images as they apply to other
things so we are all a software
engineers software architects when we
have a new technology of this is what we
do we look for all technologies that do
something pretty much similar and then
we check whether we need to adopt the
best practices of the patterns that we
have from there and and the continuous
integration pipelines that we build with
our software you are exactly the same
for years now right it's it's it's
something as we do for decades and this
is more or less what we know how to
build right we know to take the bills
and to run them through this promotion
permit when on each and every level we
have less and less build survive and we
take them through more and more a
significant testing right so we start
with using tests it was using a unit
test all of our code is being checked
whatever survived the unit tests passed
to the next level the integration test
and then to staging manual QA etc etc I
am that's exactly the same picture on
its side and that's a diagram that I
loved a lot from Michael who Thurmond
and his book agile ALM what you see here
is the exact same promotion pyramid when
you take your artifacts and
pass them through what Michael calls
quality gates and those are exactly the
checks and you promote them from one
repository to another repository and all
the way to production environment and
you do your checks on its way now and
again I really hope I didn't say
anything new on the last two slides we
do it for years when we know exactly how
to do it so why the hell won't we do it
with docker and and the answer is Chuck
Norris and well the answer is daughter
build daughter build is extremely
powerful and easy build tool to
manipulate and work with and when you
have such a tool everything looks like
nails and what naturally we try to do is
using daughter build instead of more or
less everything so instead of the
promotion pipeline that I showed you in
a previous slide with docker a lot of
the times the natural tendency is doing
that instead of promoting the artifacts
that we build we can just promote the
builds file and docker build it on every
step that's a very natural tendency of
ours and it actually makes sense
because it's very easy to promote a text
file it's as easy as tugging it
differently or moving it between
branches or or something like that we
don't need any new tools we don't need
anything complicated promoting a text
file is super easy but but the problem
is that faster she builds are not always
in the way to go this is an image of a
completely built and complete
residential building in Shanghai China
that collapsed hopefully before people
moved in I'm not sure we will ever know
um well yeah so AB there's no problem
with building docker again and again on
every
of our continuous integration pipeline
from scratch and I thought about
creating this ridiculously broken and
bad build file and and and then I just
went to the Internet and I googled like
docker built the internet is full of
those github starter positive you know
like clone repositories popular stuff
all looks like that and in this
marvelous example every line of this
docker file is in trying to fetch a
latest version of dependency except of
you know creating the directory and then
running something which is of course
very bad and now just to remind you all
of you know docker so especially those
who take it to production and those guys
should now stop me and say what the hell
is wrong with you
this is no how we write right we can fix
all that so let's start with fixing the
base image reference the from statement
how do we fix it versions right
someone said versions of course let's
fix it boom fixed is it didn't fix it
now who thinks we didn't fix it why
someone can update the tag right so so
the targeting token are not immutable I
can create a new image and retarget with
the same tag but why would I do that
we know the semantics of a release
version mundo 1404 should mean today
exactly what it meant in April 14 when
it was released is it is it the same
image today why not security updates
remember heartbleed hardly there was a
lot of fun wasn't it we don't like to
update our server software we don't like
to update our Ubuntu version and and and
in order to for selves to get the
security update to fix heartbleed
canonical releases secure
the updates inside release versions 1404
today is not 1404 in April 14 three
years by now how do we fix it how do we
make sure that the front image is
absolutely always the same what can we
use latest is definitely not guarantee
that it's always the same the other way
around it guarantees that it's always
new one huh we'll get to that
thank you and I didn't pay this
gentleman fingerprinting you know this
guy that's a chance an old file now the
chatter of the file guarantees that will
always be the same file right didn't fix
it looks like so why do I do you know
which version of Ubuntu I'm using now I
I think I just slapped on the keyboard
and this is what it 10 apps with right
this is very reliable but completely
useless
I have no idea what version of founder I
use so this aside however how we fix
those how we fix those anyone yes thank
you very much of course we can specify
versions and we should specify versions
because we can put like the very latest
version of Python or the version of
Python that we know that is good and
version that the good version of no jazz
but how do we know that thanks to this
gentleman he knows how debian up.get
works he knows that he can nail down the
versions how about this guy how reliable
a repeatable build of ambient clean
install is can we rely on that
I guess the answer will be it depends
right if you know your maven very well
you can work hard and make sure that it
always be the same how about that
that was reliable right I guess my point
is you cannot rely on your dollar bill
scripts to emit the same image after
each and every build and you are in a
very big danger of getting that you run
your local build in development and you
get an image you expect the same image
to be in production but it can be a
completely different one or even a
slightly different one but definitely
not the one that we spoke about right so
M this is not the way to go and we can
take another pattern and get a lot of
inspiration from it and that the an
immutable a similar pattern from a the
great Martin Fowler that say do not
change the server's in production
instead every time create a new server
and run into production and we take this
idea of immutability to our blogger
images as well and we say promote
immutable and server and stable binaries
all the way from development to
production through those quality gates
do exactly that build it once and then
promote and here are our quality gates
again promote promote promote through
quality gates and you might say now okay
this guy's clearly obsessed with gates
what's going on well I do have good
reason I have to say because quality
gates ensure that everything is exactly
where it should be when you have
separate repositories which are
firewalled from the buy environment that
you need you can guarantee that your
production environment swamp kubernetes
measures whatever you use will only see
and get access
to the repository that you specified and
to the images which are qualified to be
in those stages you guarantee that you
won't end up with untested images being
deployed to production and again this is
not you we do it with repositories in
maven all the time we know exactly that
our deployment tools share part and
symbol salt whatever if they only can
access a production ready repository of
artifacts it will always deploy the
production ready artifacts for
production right how hard can it be
and why I am wasting your time on a lot
of them the conference well because
docker dog hair makes this single
operation very very difficult and that's
because of the repeat of limitations
which are not exactly justified just
like this limitation was and and those
limitations come from how the docker tag
file is built and a dog dog tags syntax
is built and you can see here that the
command of docker tag receives a
registry horse as a part of the tag with
user name and any name in touch and the
separators between those different
tokens of daughter tags are forward
slashes the problem is that in this
universe forward slashes are already
taken by some other very popular
standard the URL so if you have a
forward slash that separates between the
registry host and the tag name how well
can you have multiple registries per
host you need to separate them with the
quantex URL but after the slash don't
you already have the tag name how can we
support that dr. Deb docker q8o they're
staging in dhaka prod under the same
horse when after the slash you are not
allowed allowed to put
anything except of the tag name so
that's kind of the same I would say the
same level of limitations which are here
with us to say and we need to find a way
to deal with them and of course the
natural way of dealing with that is that
and but after you have you gone through
this stage the next one will be trying
to find a workaround and and fair enough
we do have a workaround in print me in
shape of virtual hosts and or virtual
ports so what we can do is we can
translate this syntax of registry host
and tag name and this is how the request
looks like pretty much the same registry
host and then the tag name we can
translate it into this URL that has the
context name the virtual repository name
and the tag name by using a URL rewrite
techniques which are available in any
modern HTTP server so here is an example
of an Genie that does that and what it
basically said is when the request comes
to port 5001 forwarded to dr. death we
will have the same for docker staging
dr. prade etc etc and this is how we can
have separate registries from the docker
point of view pointing to the same
artifact repository in there I would say
normal artifact management point of view
right so we will have that and then we
will successfully tag our doc your
images with whatever host this is going
on with for five thousand and one and it
will successfully work now the problem
is how do we promote promotion as I
remind you would be moving the artifacts
dokin images from registry to registry
taking them from development registry to
staging to production will eat
require recharging depends on the tool
that you use if you just install
multiple dock you're registered in the
same host and give them different
virtual port or physical ports then yes
you need to download your artefact retag
it and upload it again considering we
are talking about huge files daughter
Imogen are big that might be not the
optimal way and hear a little bit more
of shameless plug of j4 go to factory
although it can be of course is
accomplished by other tools as well is
the virtual repositories that we use so
here we have artifact or repositories
which behave as normal dokie registries
and tools can access them by their
virtual host and virtual port but the
promotion here will be done behind the
scenes andrey tagging will be take care
for you automatically so now when you
want to move a docker image from dev
registry to staging registry to
production registry all you will do is
issue a rest api request that will take
it through those stages from one to
another and more so you can group them
into a virtual repository and then just
expose a single registry that will show
in docker images from multiple
repositories as a single reached and and
to give you an example how you put all
that we learn to use and i will give you
an example of a docker system that we
will build in the last the ten means
that we left with so let's first of all
look at the container that we want to
build eventually and it will include
three main parts we will use a base
image
let's take central s for this example
and then we add a framework that our
code will run with it and in this
example it will be JDK 8 and JBoss red
head wildfly on top of it and then some
war file basic
example again it's a word file which
runs some Couchbase application but it's
really a just an example so this is what
we want to build and we will need two
different bills to create this container
and we will need two bills because
that's exactly the number of different
release cycles that we see here and what
I mean by different release cycles is
how frequent we change the version of
components inside obviously we change
the war file every time we have a new
build being it after each and every
application commit when you learn commit
to a two argued by our developers in the
continuous integration run and it ends
up with a new war file that's not the
story for those guys we will update
things like the version of our
application server the version of our
JDK and the version of our base image
much less frequently maybe there is a
new release of Java that we want to take
its what once in a couple of months a
new release of a wall fly about the same
new release in central s once a year
once a couple of years right so the
release cycle of those two and the
release cycle of the war file are
completely different and that's exactly
why we need to build so first let's talk
about the framework build the frame or
build we take a verified base image and
by verified I mean the one that we
checked we agreed that this version of
Centaurus is good for us we will use
that and then we add system dependencies
and in system dependencies in our
example our jdk and not tomcat won't
won't fly and we take them from a
trusted source as well like your
in-house repository and then the most
important party part of all that is that
we own the base image and then it's
going back to the
a comment of this gentleman when we
spoke about how can we make sure that we
have no surprises every time we run
daughter built em and a version of
Center s is somewhere in the wild is
changed is by owning your base image
when we own it no surprises can be there
and and that's the minimal framework
built daughter file right it doesn't
have any dependencies at all all it
takes it takes all it does it takes
ownership on some base image so in our
example these types and ownership on
center is seven and we will use these as
our base image starting now so we are
100% sure that no changes in central s 7
out there will affect our system anymore
right so we own the base image and
application build is also very simple
now we use framework as our base the
Java a build file runs and then we add a
single file to our base whatever our
java build actually a produced and then
we're done so here is an example of how
this built so we use our own framework
and then we add a single file to our a
to our base to our frame and here in
this example I take the war file from a
release or posit or e and and that that
will be by debatable question and the
question is is the lifecycle of my Java
war file can be verified if my Java can
be verified outside of the docker image
that I want to take it means can I take
this war file through the promotion
pipeline of its own from development to
release without taking it into daughter
the answer depends of course on your
process sometimes yes
and then you will take it from the
release and sometimes is now you need to
build your dog your image as soon as
possible and test everything with the
docket image and then of course you will
take the war file not from the release
repository but from the development
repository that's up to you and here are
a couple of more questions how the hell
why the hell do I take the latest
version here and those brackets release
actually means take the latest release
am I allowed to do that did we speak
about not depending on the latest
version but this is mine right the war
file ended up as a release in early
repository after a promotion pipeline I
can be sure 100% that whatever is in the
religion posit Ori is good and if I am
sure about that I can safely take the
latest one and it's actually the same
with the framework although we rely on
latest this is our latest if you
remember we verified it we build it we
own it we can safely take the latest
framework it is as good as any previous
one and this trust that we built into
both any version of framework that is
released for us internally and any
version of our application that is
released for us intention internally
allow us to do something cool which is
called this sandwich testing pattern and
that's another pattern that we talked
about the sandwich testing pattern is
the flavor of integration pattern which
is very rare because there are not a lot
of situations that you can do that and
that's something between bottom up and
top bottom testing when you test two
pieces of your system once against the
other in our example this is perfectly
normal
so those are two pipelines we have the
framer pipeline from development to
production we have an application
pipeline from development to production
and we test them with
so every time we want to test the
application we can test it against the
latest trusted version of the framework
and every time we want to build a new
framework we can test it with the latest
trusted version of our application right
and that simplifies a lot of things but
can bring us to this problem of what
happens if two changes are incompatible
with each other what happens is my
application now relies on something that
I need to be do in my framework and I
cannot do it before my application
changes and the solution for that will
be a good system of triggers that means
that you always should release and test
new version of application every time
the code is changed and you always need
to change to to test the latest version
of the framework every time something is
changed in your daughter file this is
how you allow that those tests will
those releases will be frequent enough
so you will always have the latest
framework or the latest application that
you can test the other counterpart with
it and and with this wonderful animated
gif that you can stare for hours I'm
done and I think that's time for all of
us to go and hear the glorious Java
ports that are reunited here at devoxx
yes and that's a big deal at least for
me thank you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>