<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>RIBs - Uber's new mobile architecture that scales to hundreds of engineers by Tuomas Artman | Coder Coacher - Coaching Coders</title><meta content="RIBs - Uber's new mobile architecture that scales to hundreds of engineers by Tuomas Artman - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>RIBs - Uber's new mobile architecture that scales to hundreds of engineers by Tuomas Artman</b></h2><h5 class="post__date">2017-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/FfwZSk6VRVY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right hi thank you for coming to
this talk I think it's one of the last
talks of the night or of the evening and
we'll get some beers afterwards which is
always exciting my name is Thomas
Hartman
I am a mobile engineer on the mobile
platform team arriba my home base is San
Francisco but I'm essentially here to
help the Amsterdam office and the
engineering office over there with this
conference and I thought it would be a
good idea to you know try to give a talk
at the same time to you guys I'm going
to talk to you about essentially our new
RHIB architecture that we have created
over the past one and a half years I
want to talk about the motivation why we
actually created a new mobile
architecture MVC mvvm MVP our you know
pretty pretty good architectures to
begin with but we started to stumble
into problems as our engineering base
grew I want to talk to you about sort of
the motivation of that decision how we
came to that decision the process that
we went through and in the end I want to
talk about the architecture itself give
you sort of an overview of what we built
and how it works we open sourced the
rhibs architecture or the architecture
framework a week ago and we've been the
number one trending Java repo on github
further for the full week except for
today where we dropped to number three
so hopefully we can change that today by
having you all give us a star at some
point going into why we build a new york
texture we sort of have to step back a
bit and talk about the history fever as
well I'm just gonna glass through this
rapidly no that's not very engaging for
a technical audience but five years ago
this was the entire mobile team that
ever had three people I think two wires
engineers someone under an engineer
working super hard on off site creating
the the first application or the the
second version of the application that
was to be the uber rider application
since then myself i junked three and a
half years ago and
we had 15 engineers working on mobile at
that time and in those three and a half
years we've grown to 400 mobile
engineers essentially working on you
know two primary or three primary
applications and then some some smaller
ones as well so what we built was sent
or what what the guys in the picture
build was essentially this application
um I don't know if you've used uber two
years ago I'm if you have you probably
remember this application a year ago we
launched a new rider application which
was a full rewrite of what we had and
we'll get into why we did a full rewrite
because usually that's not you know the
the most sane thing to do when you have
grown business this was the application
it worked fine for for a number of years
it was essentially your vanilla MVC
architecture and we started having
problems from the time I joined three
and a half years ago there were already
you know problems to be seen that you
know maybe MVC doesn't work at our speed
even only with 15 engineers we started
having problems were multiple teams were
creating functionality and features in
the mobile application in one place
where all the integration happens you
had to test multiple multiple paths from
multiple teams in order to make sure
that your application worked and me for
example my first project that I did was
the destination entry on this
application I do remember that I counted
twenty three different cult paths that I
had to manually go through to make sure
that the application work because we
weren't super keen on you know having
unit tests or you a test back back in
the days because we're moving moving so
fast so it was it was pretty pretty
overwhelming to develop new features on
this and it was it was becoming slower
and slower as we started growing I just
joined when we started to have the hyper
growth phase and essentially a year
later we were already at hundred
engineers are working purely on mobile
at the same time we started to have
problems with the design itself or the
design rails that we had in our
application and this is an actually
screenshot on the right of an
application and when the user is in
Chicago
if you look at the bottom tile down
there that's all the products that are
available in Chicago and when you know
the designers designed the application
they figured you know we maybe have like
three or four of them but you know the
city teams wanted to you know put in
more and more products and it became
like this at the same time the map area
grew all the time
smaller and smaller because feature
teams wanted to have their own
functionality in there they wanted to
put in banners for example the the pool
manner that you see share your ride
split the costs was something that you
know the pool team put in to promote
their feature and you didn't really have
good guidelines on on how new features
should be you know should be should be
put into the shared space that every
team integrated with so we ended up with
um you know quite a few examples of you
know pretty bad UI where you had
multiple of these banners later on top
of each other and you barely could see
the map because of that and one and a
half years ago the design team came in
and said you know you probably have to
redesign the whole application in order
to you know be successful years from now
and in order to to come up with a design
framework that would allow us to to
build an application that you know not
only supports the the status quo that we
have but you know years to come from now
and we started seeing ourselves in in a
situation where we had an old
application that had a pretty big
codebase and we had a lot of engineers
so we could technically go through every
right but everybody was super concerned
rewrites usually sound super bad you
don't really want to go into them if you
don't absolutely you know have to I
guess many of you already have you know
experiences from from rewrites going
wrong and instead of three months taking
three years and we didn't take that
position lightly either we spent
essentially a year trying to migrate
trying to change the existing
architecture you know put in better
state machining in order to help you
know our engineers to
move at the speed at which they wanted
to move out but in the end when we saw
the new redesign we looked at it and we
were like this is going to eventually
change you know how the application is
built and every single feature at least
on the view set needs to be rewritten
and because we didn't have a very you
know coherent architecture at that point
that also meant that you know business
logic would have to be rewritten at the
same time so we decided that we should
do a full rewrite and again we didn't
take that lightly I think at that point
we were privately evaluated at 70
billion dollars as a company already and
this was essentially bringing in all the
revenue so we really you know thought
about it for a while before before
jumping into it so the next step is you
know when you when you want to react
attacked your application and you want
to put in a architecture that supports
large teams because that was really our
problem having having hundreds of
engineers every single day committing
code to the same code coined by a code
base and and sort of keeping them
somehow you know not clashing into each
other we we needed to come up with
something and we started with well if
you're going to do a full rewrite you
wanna take the time and figure out you
know what you want from that we write
what you want what you'd want from from
a architecture and we came up with six
goals that we wanted from from a new
architecture the first one was four
nines of reliability and it it doesn't
sound like you know a thing that an
architecture would really help you with
but we found ways of making you know
that reliability you know be be helped
with with the architecture choices that
we made reliability is not only crash
free rates it's everything else like if
a user can't for some reason complete a
flow or a funnel that essentially means
that you know the user couldn't take a
ride which means we failed the
application didn't crash but it still
didn't didn't work so four nines of
reliability was important for us and
wanted to make the architecture work for
that we also wanted to do this once and
I'll have to come back
three years from now and do a second
rewrite so you wanted support lubbers
growth for the next years
whether that be eight hundred or a
thousand engineers working on the same
application we wanted to provide rails
for both design and code hugely
important to be able to say here's how
you should code in this new architecture
in this new application here's how you
should design for this new application
you saw the problems that we had these
are in design before we because we
didn't have to have guidelines or rails
for for designers and it wants to make
sure that they would be able to come in
still have their freedom within a
certain context to design the feature as
they wished but still conform to a
certain set of guidelines in order to
not you know stray from the overall user
experience we wanted to put monitoring
in as a first-class citizen as well
something that the architecture can help
you with if you can test your of if you
can't monitor your application then it
might as well not exist like you don't
know what it's doing you don't know if
it's running you don't know how many
users are using it you don't know if you
know users are successfully completing
certain flows so we want to make sure
that the architecture would
automatically give every single team
monitoring for free out-of-the-box we
wants to do XD risk SP experimentation
as well whenever we put in new features
and functionalities we do an a/b test
nothing really goes in without
experimentation we want to make sure
that you know a feature that we put in
actually hits the bottom line and makes
an impact somehow and finally once you
also make magic we want to make sure
that the architecture would be able to
create an application that was whose
performance was second to none and that
would gracefully degrade as well um when
he went to low networking conditions or
low-end devices so these were the the
for architecture goals that we set out
to accomplish maybe a seventh one that
we added sort of later was that we
wanted really both of our mobile
engineering teams iOS engineers and
Android engineers
to really work on the same kind of
codebase to work on the same kind of
architecture to be able to create
functionality and features together and
not having to sort of you know spend
twice the amount in you know figuring
out how how something should be
implemented we have a process called RF
seeing requesting for comments
throughout the company whenever we put
out a feature the engineering teams will
send out a document detailing how
they're going to implement that
functionality and previously you would
always have an iOS RFC and you would
have an Android RFC and we wanted to
make sure that you know you didn't have
to do two different documents
implementation documents but that we
could talk with the same terms we could
use the same class names we could use
the same terminology and that you know
implementation details when it came to
UI surely you had to differ between iOS
and Android but maybe on the business
layer side and and how you implement
that feature only one explanation was
necessary so you could essentially
double the effectiveness effectiveness
of your mobile teams when they were
designing a feature so how do we how did
we do this we we started in January 16
and we launched in November within the
application and this was a full rewrite
of everything from from from start to
finish we started with a pretty small
team because we we didn't want to you
know tell anybody to stop working on the
existing map we were still a growing
company in still are and the we didn't
want to pull feature teams out of their
their daily work they wanted to make the
existing application better and we let
them so we said let's spend half a year
trying to figure out how we were should
be building application applications
let's do that somebody in isolation
without you know getting too much input
from others maybe inside that was a bit
of a problem we should have more
actively sort of engaged the entire
company to take part in designing the
architecture or at least you know being
able to give some input but we had a
team of eight people 400 engineers for
iOS engineers working for six months
trying out everything so we start with
MBC can we make MBC better nope
can we do a movie em can we do MBP we
had a take on Viper and we built out
core flows for all of these different
architectures and we tried you know
whether it would work for us or not and
in the end we came up with no did one
word like that the problem is that all
of these architectures are based around
the view menu based around things around
the view everybody has to integrate in
one point and that becomes a mess at the
scale that we had so we decided that you
know it's time to write our own bone
architecture and we we started to build
out what now is called ribs and six
months in we were pretty happy with what
we had we had done that in isolation
beaver you know writing super ugly
looking core flow features where you
could take an uberx trip and I actually
you know have a working application and
we invited the first team that the core
flow team to join us in this rewrite 20
engineers from the core flow team jumped
on boards and starting started reporting
actual designs and actual functionality
over to the to the architecture and at
that point we realized that um now we
hadn't really taken everything into
account we had missed quite a few points
for example you know complicated
animations that we had had had taken no
no take on at all or we we missed that
you know people would want to somehow
manage you know multiple views and
coordinate their animations you know
together and the current architecture
that we had was you know wasn't really
suitable for that so we make changes to
the architecture working together with
that first team and two months later we
thought that you know we were we were
there that we had a good architecture
that would scale for all four teams that
would give us all the goal set and once
at the beginning and we essentially open
it up to everybody else we then to all
the other teams instead you can now port
your functionality over and they did
some teams started immediately because
they knew that it would take them three
months to switch everything over some
teams didn't bother they still continued
experimenting on the old application and
just in the past in the last few weeks
ported their functionality over but
and we launched in November and we the
launch you know went pretty successfully
we had some problems obviously because
it has a it was a full rewrite and full
redesign some things that we didn't
anticipate in in some countries but
overall you know we met the reliability
goes you know pretty early on by having
rewritten everything we were close to
four nines of reliability on on the
mobile application so where we are today
is a brighter application that has two
million lines of Java code a million
lines of Swift code which should sound
you know pretty big to everybody it
sounds super scary to me whenever I see
this this obviously includes unit tests
and UI tests so this is not all
production code that runs in in the
mobile application but it is a lot of
codes it is a lot of teams the code base
is huge
we support the application in I don't
know 68 countries or so with different
feature sets in in multiple cities so in
the end what we ended up building was
essentially two things we built the the
core architecture which we now call rips
architecture and on top of that we built
the application framework in order to
support the user specific use case on
the rhibs architecture we made sure that
you know we have things like dependency
management react data flows testability
compartmentalization scoping because
that wasn't enough we had to integrate
things like monitoring and analytics
that would integrate with our back-end
systems that Weaver on top of the
architecture the roofs architecture is
is the the one that we've open-sourced
when if you want to use it at some point
if you give it a try you probably have
to build something on top of it as well
it will be a basis or a starting point
for you to start using architecture that
scales for for big engineering teams and
the application framework is something
that we might be looking into into open
sourcing at least pieces of it for
example the plugin management some point
in the future so what does ribs stand
for ribs stands for router interactor
builder
an optional presenter and view these are
the core building blocks of a rib and
the rib is a core building block of the
application we will jump into what these
all mean in later in this talk but for
now know that there's a thing called rib
which has five five different you know
pieces within it and they're called a
rib the one thing that we wanted to
solve really with this architecture and
we found you know two big problems that
none of the other architectures could
would be able to solve was the massive
view controller problem or fragment
problem you know if you go to iOS the
choke stands that MVC stands for massive
view controller on the Android side you
know our fragments were huge as well if
you go into the records flow which is
essentially the first screen that you
see where the user can then start you
know taking products putting in cheapest
location searching for location that was
five thousand six thousand line of code
all essentially integration code and
super hard to maintain written by I
don't know two hundred engineers so
nobody really had a good take on take on
that the other problem that he had was
really convoluted state machines this is
an actual screenshot of our state
machine that we implemented for the
breakfast flow on the old driver writer
application where essentially you could
you know it requests you could confirm
your location you could select the
product there were some other views in
between as well and all the lines are
transitions from one state to another
and when you have transitions like these
essentially means that every single one
of these state pieces or things needs to
know about you know the the next one
they're going to because they need to
handle some sort of animation and we
looked at these two problems and it
turned out that you know we we had a a
common solution for for both of them and
that was a state tree we thought to
ourselves wouldn't be awesome if you
could just design the state of her
application or entire application as a
tree
and if you're now shaking your head
that's exactly the same thing that we
did we initially through this idea of
because applications mobile applications
are inherently integrated you've got you
know awesome views that animates that
morph into one another where you really
need a state machine we saw on the
previous slide but we still looked into
this we continue down this route and in
the end we we found out that yes it's
it's possible it is possible to take any
application and model it stayed as a
tree some of these nodes could have
multiple children active at the same
time some of them will have none but in
the end you could model every single
application at least we haven't found an
application that he couldn't model with
this very nicely so this is an example
of a very simplified model of the rider
application you've got the root rib
whose responsibility really is to figure
out whether the user is logged in or not
you've got a logged in rib which gets
attached when the user logs and I love
da grip when the user is it's not locked
in and are things like the menu the on
trip thing the location editor the
favorites let's look at the decisions
that a rib does here in the case of
routes we wanted to make sure that in
ribs everything is as compared to map
compartmentalized as possible that all
these business logic units make the the
smallest amount of business logic and
the smallest amount of decisions
possible so every single node in here
doesn't know anything about anybody else
it knows that it has a child it doesn't
know what happens in that child and it
makes a local decision to move the state
tree forward or backward in this case
when the root rib initializes the
interactor which is essentially the
piece that drives the business logic
makes one decision and one decision only
throughout the entire application do I
have a user token I'm told I have a user
token if I don't have a user token
attached the logged out rip if I have a
user token or if I get at some point a
user token
move the log grip and put in the logged
in room that's all it does and at that
point nobody else in the application
will ever need to have to handle user
tokens or authentication or anything
it's handled
up in the top if you're attached on one
side you know that you loved in if
you're attached on the other side you
know that you loved out so the locked
out rip gets attached
now it's rib will do probably something
more complicated it will have a user
forum where the user can enter its
credentials press the locking button go
back to the interactor the interactor
will send up a network request and
somehow and I'll show that later in a
slides how we how we pulled this
together this back end request that is
sent by the locked out rib comes back
and is applied to the state's the data
state of her application and the root
rip is informed that there's now a token
so because the root rip again has only
one decision to make do I have a token
don't I have a token it now got a token
so what it does it attaches the
locked-in rib and it detaches the
logarithm and everything else in this
state tree makes similar very simple
assumptions for example the logged in
rib again you see it has three children
it has request menu and on trip as it so
happens the many Europe is always
attached there's no business logic
associated with it
but the request rib and the on trip rib
are mutually exclusive so the logged in
rib again looks at the state of the
application and sees whether we are on a
trip or whether we are not on a trip if
you are on a trip we attach the on trip
rib if they're not on a trip we attach
the request rib and thus the application
moves forward if at any given point in
time our data state changes and we get a
a trip object the locked-in rib will
again utilize or you know execute its
business logic it will remove the
request rib associated all the views and
it will attach the on trip
rip this state wrist this state is also
inherently business logic driven all of
these ribs are essentially business
logic units to this point we haven't
talked about views at all every single
rib can come with its views but the the
big differentiation between ribs and
other architectures is that we route or
we we have business logic guests at the
core of the application and the
architecture not via logic we use follow
the business logic not the other way
around
some of these these ribs are highlighted
and in green meaning that they come with
their views some ribs might not have use
at all and to give you an example of
what that means in in terms of the
application you've got the menu which is
associated attached up at the top left
you've got the location editor which is
at the top and you've got the shortcuts
down here another thing to notice is how
this separates all the pieces nicely
because a rib doesn't know to which
parent it is attached to it only knows
what children it has attached to itself
it has to live in a world of its own so
if you take for example the location
editor rib it doesn't know where it is
it has been assigned to a certain area
on the view by the parent so when the
request rib attached the location editor
rip it said you can draw here and it has
been given a area to draw in and
location editor draws in that area if
it's being moved around it really
doesn't care if it's being resized and
probably rerender itself but it knows
nothing about the world outside of
itself so you can really go into the
code of the location editor and can live
in your own world you don't have to go
outside you don't have to go upwards you
make notifications than those
modifications will only affect logic
riri rendering of the of the location
editor and the same applies to
everything else we could move the
location editor to other ribs as well
what we can reuse them and just listen
in on on what
they what they provide to their
listeners so the attachment between or
the the result passing between these
rips happens through listeners when you
create a rip you pass in a listener
interface that is essentially used to
deliver results from the location editor
in the location editor it's super simple
the location edited at some point will
say the user selected a location and at
that point it's up to the parent to do
something with that information to show
a quick demo of how this looks like I
have to unfortunately use an iOS
simulator because we don't have this
functionality already on Android yet and
we're gonna just launch the application
in debug mode it will have a small local
webserver that we can use to have a
application running that will inspect
sort of the logs that get triggered by
automatic logging and we have this small
website that will render the rip tree as
it happens and as it as it moves around
so this is the initial rip tree of our
application that just got launched we
start off with I don't know if this
visible root router main router router
router request router home router or
feed router and so on so forth
so let's drill into the view in the feed
the feed is down here when I move it up
you see that new riblets are created and
they're created by Allah scroll up and
this is pretty useful information to
sort of be able to debug things I can
see what gets attached I can sort of get
a good understanding of what has been
built in this rip and I can use it for
debug purposes for example if I move all
of this down I still see that they're
attached which is you know probably
something that we shouldn't do like
we're consuming unnecessary memory here
and we should probably you know clear
out these pieces same if you go into the
location editor something big happens we
switch entire entire ribs into a new
section of the application if you go
back we switch it back if we select a
certain location we get a request router
that gets that attached to the right
router and all kinds of
riblets that get get associated with it
and again if I somewhere in here create
a location I get the same location
editor but now attached to the request
router and yeah so this has been working
for us pretty well and even though we
have a lot of animations that get
synchronized all over everything in a
move smoothly into into one another we
still haven't found a case where
modeling your your logic state as as a
tree in a mobile application wouldn't
work and really the benefits that you
get out of it is that you can now
compartmentalize all the pieces of of
your application you can hand it off to
different engineers engineers will
create a feature and nobody else will
know that that feature exists it will be
attached somewhere and that's all sort
of you know the knowledge that ribs have
of each other they know that you know
they have to create one they have to
attach it they have to maybe passing a
listener to inspect the events that come
out of that rib but that's the
interaction you can integration you can
do between ribs and it's actually in
force you can't do more you can't go in
and grab something out of that rib that
interface for that listener is the only
thing that you can use and that
enforcement has has it worked pretty
well for us so going back into into the
state tree happens so that dependency
injection works beautifully with this
tree as well we have a thing that we
call dependency spoke scopes we have a
entire talk on this I can point you to
links later but let's look at example
let's say we have the access token and
the access token is used by multiple
ribs throughout the application because
whenever you make a network request
essentially you need to have access to
an access token otherwise you can't call
the service so in this case the routes
creates that access token we call it
dynamic dependency that we then hand
down selectively to one of our children
the root will never hand that access
token down to the opt-out rib so the
locked out rib never can get an access
token which essentially means that if
you try to move some of these ribs to
the other side your compiler won't let
you because that dependency cannot be
fulfilled so if you take the favorites
move it up to onboarding now go compiler
will say I don't have an access token I
can't touch it from being from the
dependency graph so you can't add me
here it can be moved downwards so logged
in obviously gets guessed that access
token and it again can decide where
where to move it usually we allow you
know pretty much anything except for
maybe some mutable classes or mutable
streams that we have anybody who wants
it when it's created can can take it so
everybody underneath that first dynamic
dependency can get access to that access
token if you then for example arm are in
the locked in ribbons we are on trip the
trip object that we received from from
the service essentially you know says
where we are what we're doing who our
driver is that is received by the logged
in rib and the locked in rib we'll pass
it down to the Entrepreneurship trip at
this point is attached and the trip
object is passed down and anybody who's
attached to that on trip
underneath on trip arm will will be able
to read that trip object as well and if
he for some reason complete that
again the locked-in rib will create a
new trip request object which then can
be fulfilled and filled out by by all of
the other ribs that are associated with
the tree that goes into request so let's
dive into the in terms of a rib
we should saw the state tree which
essentially is the overview of how you
built the application and that's maybe
even the the biggest point of what we
did with ribs because that makes it
possible to you know builds big
applications and have you know huge
engineering teams working on a single
app instead compa compartmentalize
things in a way that your engineering
team can be effective so we start off
with the interactor the interactor
essentially is the brain of your
application of your rib it drives all
the business logic there are other
architectures that call it the
interactor as well so essentially it
doesn't know anything about the view it
just takes in streams or objects make
some decisions run some business logic
and then decides whether we should go
further in the application somewhere or
somewhere else
you can also make network requests if it
wants to get some more information if it
wants to go search for a location that
is the thing that you know does and
drives all that business logic the
router is pulled out of that interactor
and while the instructor makes the
decision on when to go somewhere else in
the tree the router knows how to we
could and we've been talking about sort
of moving the router into the interactor
but for now we want to keep it you know
outside to compartmentalize a rib as
well and to remove the the the amount of
code that we have in in one interactor
so the router will be called into by the
interactor the rank interactor will tell
it to go to the logged in rib and the
router will be able to build the next
rib and attach its attached its views
and hand you know control over to that
next ribbon
we've got the Builder which is this
essentially you know most stupid part of
the entire rib it just builds the whole
thing usually we don't even need to unit
tests it's because building is it's
mundane it's essentially you know
unfortunately boilerplate code it builds
everything passed in the dependencies
and off you go if you have a problem
they're usually your compiler will tell
you and there's no unit testing
necessary and then we've got the two
optional components which are the view
controller on iOS and the optional
presenter if you have a more complicated
view that you know really would use a
view model where you know the data that
you get from the interactor isn't really
formatted to be presented um usually use
a presenter to create a view model to
then call into the view and sets the set
accessory attributes and the view
controller is super dumb as well it just
has all the views puts them in a place
and then waits for somebody to call in
and set properties on those views set
label texts or you know putting colors
or whatnot so these are the the five
pieces the most important ones are you
know the the interactor the Builder and
the router hence we call it ribs and you
can have a view controller and option
presenter and here's a diagram of how we
use it like this goes a bit beyond what
rips itself is but it died a de did
because it sort of gives you a good
overview of how the events flow within
within a rib so if you start off with a
interactor and let's see let's be in the
locked-in rib for example the interactor
will give any data model to the
presenter in the case of a locked-in rib
there's probably not much data to give
maybe there's you know I don't know the
time that currently is if you want
presented somewhere on the screen the
presenter will create a view model and
then call into the view to set these
labels the view in this case probably
would be two input fields and a next
button when the user fills this in and
the next button is pressed the view
we'll call it the presenter and tell it
what just happened it'll say actually
this button it bones indicate intent the
presenters responsibilities to change
that UI event that happened into an
intent so the presenter will say AHA we
click this button on this view that
means we the producer probably wants to
login I'm in order to logon let me read
that user name and password from those
two text input fields and let me then
call into the presenter into the
interactor saying interactor please
login with this username and this
password the interactor will check this
request might run some business logic be
like mmm can this user login yes this
user can log in because the username is
you know more than three characters and
whatnots so let's make a service call
and that's when we move out at sort of
the rib we probably have some networking
component inject it into ourselves and
we call into the service saying please
look the user in with that rib and what
will happen in the service will go into
the backends the backend resolve that
give an access token if the user is
actually there the important part here
is to note that we will actually at this
point not receive any response in the
locked-in rib because we want to manage
states in a waiver we cannot break it so
we've said in our application framework
that whenever you make calls to a
back-end service that still change the
state of your application you can make
that request but you will just receive
an okay if it's exceeded you will never
receive the data back because if you
receive the data back you could mess
around with it you could get out of sync
in your application instead we say any
service endpoint that is being called
that changes state in any way has to be
registered globally with a handler
pointing to a stream and we use our
extremes for this that will receive that
data in this case there would be a rider
stream whose user would be filled out
with probably a username and access
token and that stream is accessible by
the root rib and the root rib would be
listening in on those state changes on
on the stream and then make the decision
to move forward to the locked-in rib
so that's how we model our applications
like what are the what about the other
architectures the the biggest thing that
I can tell you is it'll probably work
nicely for you like there's nothing
wrong with with other architectures if
you at some point get into a state where
you know you think of growing your
engineering resources or you know
looking at hyper growth then you
probably want to look girly into making
sure that you know architecture actually
supports growing your engineering team
and have a look at reps because it would
work for you at that point so the
biggest problems that we've seen in all
of these MVC mvvm MVP and and Viper is
essentially you know that the view is at
the center of everything and you can't
really break it apart easily and it's
sort of your view and business logic are
locked together and obviously you get
the massive view controller in MVC and
MVP m we do have a few sorry I was on
the next slide already so what did ribs
give us if you look at the writer
application today remember we had a
million lines of code and iOS and two
million lines of code on on Android we
broke their entire rider application
into about six hundred ribs that's how
much we how many we have today
many of them are reused throughout the
application you can just plug them in
somewhere else if the interface matches
it just goes in nicely
that means interface both ways it needs
some dependencies and it will want to
talk back to its parents arm so if both
interfaces match you can just move
things around as you please
most of the RHIB classes have under 300
lines of code and this was a super
important metric for us we wanted to be
sure that you can go into anybody's code
have a look and in you know some in a
good amount of time understand what the
thing is doing and if all of your
classes are under 300 lines of code
that's pretty pretty neat obviously we
do have very complicated ones as well
that go to a thousand lines of codes
but you know most of them are under 300
lines of code all of the business logic
is very very well tested we started with
a writer application you know five years
ago that wasn't tested at all and now we
have almost full full test coverage now
for all the business logic that that is
important again the architecture helped
us by putting interfaces in between
every single components some say it's a
bit heavy and some you know the the
biggest complain that we've gotten from
our engineering teams is that there's a
lot of boilerplate many use rips because
every single interaction between for
example an interactor and a presenter or
an interact or and a router goes run
interface because that makes it has the
the code testable but you get the
benefit of having well tested code we
also asked our engineer engineer
engineers what they thought of the
architecture and we had you know massive
increases in NPS NPS stands for Net
Promoter Score essentially a measure of
you know how how willing a person would
be to you know to promote a certain
architecture or a certain thing and we
had you know absolutely huge increases
in this so our engineer seemed to like
it and we seemed to be able to non
commit some you know very fast as well
we do have a few resources there's a
github repo obviously for ribs and if
you have a computer with you I'd ask you
to go in there and give us a start
because you want to get back to the
number one trending repo in Java nobody
has a computer all right don't give us a
star we have a few video resources if
you want to I would suggest you look at
dependency hierarchies because I only
glanced over those we've got like 20
minute talks on on each of these at
these URLs we're talking about ribs
internal as well and a very interesting
talk is about plugins as well so we use
the report tech chure to plug in eyes
all of our application essentially all
of our features that are not core are
plugins which can be turned off by the
server side and we have guarantees in
place that we can turn off all the
plugins and all the optional features so
that a user can take it
which is important in a mobile
application because when you launch a
mobile application when you send it to
the App Store's there's no going back
you you're sort of stuck with that
version forever I'm so it's important
that you can you know turn things off
for example our map is a plugin you can
turn off the map and you can still take
a ride without a map or scheduled rides
or most of her products are just plugins
and that we can turn off in case you
know something goes wrong and that is
really my talk thanks so much for
listening I will be we have a booth
downstairs I'll be at the booth drinking
a few beers if you have questions you
can find me there afterwards
Thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>