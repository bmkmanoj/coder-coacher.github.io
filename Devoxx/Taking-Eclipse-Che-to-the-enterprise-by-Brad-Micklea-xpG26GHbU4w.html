<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Taking Eclipse Che to the enterprise by Brad Micklea | Coder Coacher - Coaching Coders</title><meta content="Taking Eclipse Che to the enterprise by Brad Micklea - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Taking Eclipse Che to the enterprise by Brad Micklea</b></h2><h5 class="post__date">2017-04-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xpG26GHbU4w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright so this presentation is about
taking eclipse cherry the open source
project out to the enterprise and making
it more kind of enterprise friendly
what's involved in that while you might
do it and we're we're going with that so
first of all what is it Clips shade how
many people in the room have heard of
klipsch a two all right good hold on
love let's back up so cliff Shea is a an
open source project in the Eclipse
Foundation it is distinct from the
Eclipse desktop ID and a lot of people
kind of associated clothes brand kind of
almost exclusively with that desktop by
de but the Eclipse Foundation actually
has 120 other projects of HK is one now
che actually doesn't use a lot of the
same code as the Eclipse desktop ID and
there's obviously some pretty good
reasons for that one of which is that
the desktop IDU is built using SWT as a
desktop app and we of course need it to
be a browser-based up these jbt the the
java development tools and in a couple
other things from the cross foundation
as well what k is there was also a
little bit different than the desktop ID
it's not just a browser-based IDE it's
actually a developer workspace server
that uses containerized workspaces based
on talker and then the kind of browser
based ide sits on top of that so
although the browser-based idea is what
people see is what kind of my catch your
attention in fact at least in my opinion
it's it's not kind of least interesting
part of what she is doing and you're to
see I think with code Envy that a bunch
of the power you get from this really
has nothing to do with the browser-based
ide in fact you can use whatever I de
you want with code Envy so codenvy then
really takes what eclipse k is which is
you know the stack that handles the
docker based run times and the
browser-based ide and has a number of
plugins you know get plugins SPN plugins
SSH made and all those kind of things
you come to expect but it adds a great
deal on top of it just to kind of
simplify it out you know
ones are multi user an authentication
obviously it's going to add permission
controls it's going to add you know
multi-node scaling and a number of
DevOps tools to back up the database
migrate databases out of those nodes
upgrade all those things which as an
Operations team supporting thousands of
developers using codenvy you we need now
when i'ma show here in the demo in just
a second I want to just kind of walk
through step-by-step because there's a
bit of a mental shift that you need to
make if you're thinking of a classic IDE
and a classic developer workflow versus
one which would be used within codenvy
and the biggest thing is that for a
developer when you typically think of a
workspace you're thinking of your source
code the set of dependencies and maybe
some configuration but the runtime is
wholly separate right because the
runtime is whatever you've installed on
your laptop or your desktop and that
although the code gets deployed kind of
down to that runtime the IDE doesn't
really have any strong connection with
that one time it doesn't adopt it it
doesn't hold on to it doesn't codify it
and that's the real difference because
what we're the klipsch a bring is
lapping the runtime itself into the
definition of the workspace and that's
fundamental and incredibly important
because it means that if i'm on a mac
and he's on a Windows and he's on a
Linux the runtime is built into this
container as is the source code as is
the configuration so that as that gets
passed around or replicated and
duplicated for not different members of
the team it will always execute the same
way so as a developer now I don't need
to be responsible for maintaining and
creating the runtime infrastructure
required for the project that I join
they're just they're in the same way
that the code with github is just there
so we're kind of from following that
same paradigm and I'm going to create a
long time in code Envy I can therefore
start with dev run time somebody's
appropriate just kind of for me and
and myself but it's kind of more
interesting at the enterprise level of
course if I start with a production runs
on something which represents exactly
what goes on out there where my users
are and i can do that because i can use
a docker file which defines a single
machine or i can use a compose file
which identifies a number of machines
and their relationships to each other
and we make this little bit simpler as
you see one again the tool by creating a
number of custom stacks and built in
stacks so that you know you don't
necessarily need to start off knowing
docker understanding docker file and
compose syntax there's things that just
are there that will just work but also
needs an enterprise every project is
different and the runtime is as critical
or component in the successful execution
of that application as is the source
code and there's as much care that it
needed around maintaining the correct
version and the correct typing and all
that stuff for the runtime as there is
for the project once I have that
production run time though I mean I the
developer I need to do more than just
what is allowed in production if I could
only do with that runtime what I was
loud in production I would have my hands
tied kind of behind my back so even kind
of you actually inject agents into the
runtime so you don't need to change the
runtime definition itself instead you're
injecting things like a language server
which brings you you know auto complete
and error checking and all those things
for your language of choice you're
injecting a debugger you're injecting a
sink agent you're injecting a terminal
all these things get injected so that
the developer I have all those tools
which I'm used to which I need to do my
job they just happen to be on top of a
production grade runtime then of course
i'm going to import my project or
projects the workspace can hold multiple
projects from multiple repos even read
those are different types I could mix we
pose from svn with my glucose from gift
the code is then live synced into the
docker container so it's not my job to
remember when I've made a code change
and push it into the
it just happened and that creates that
kind of nice smooth flow that you know
developers like I mentioned at the very
beginning just kind of restate you you
can actually develop in code Envy with
with any IDE so once the one time is
there once the code is there and
everything's been injected and synced
then the question is do I want to use
the Eclipse a browser ide which is what
i'm using the demo or do i want to kind
of mountain sink to use the Eclipse
desktop IDE or intelligent or emacs or
bi or sublime or whatever it was that I
really liked so when we look at our
enterprise customers for example we find
that a large number of them will use the
browser-based ide but there are
certainly in a you know a non-trivial
contingent that is going to continue to
use the IDE of their choice they've got
muscle memory they know it makes them
efficient and comfortable we don't to
break that now that this you know of
course a set of rest for work space
api's which allow you to
programmatically interact with the code
to run time and everything else you can
actually then begin to build
integrations with other tools and that's
the next step because in an enterprise
especially the development workflow is
tied to a set of tools hajira might be
used in order to organize all the
stories all the tasks for the developers
each day and so there's the opportunity
to embed within a JIRA issue the URL to
a code Envy workspace so that now when I
open up a JIRA issue as a developer I
simply click on a link and regardless of
what I have on my machine I'm gonna get
the correct runtime I'm going to get the
correct code on its own branch you know
and all the commands I would need to
execute that application how to build it
how to run it how did it bug it
everything kind of pre-built so it makes
the workflow and the onboarding for the
developer into that project or into that
issue very simple and clear similarly
Jenkins if I have a failure in my build
programmatically we can create a
tailored workspace for that particular
build and look at the correct project
correct branch to correct commit ID so
that can begin investigating that broken
build again by clicking on a link as
opposed to stashing my own environment
and having to build up what I think is
the correct target environment for that
failed bill as far as the guesswork out
then the last thing is the collaboration
with the team and this is obviously very
important because you want to be able to
as you know a team lead or is a project
lead create a stack in other words that
the definition of that run time for your
particular application you can work with
you know kind of in a kind of DevOps
model where that could be a stack taken
partly from production with some extra
stuff it could be directly from
production it could be you know a stack
for hacking that is not meant yet for
production maybe you're just doing an
investigation a lot of choice there you
can create sample apps workspace
onboarding what it's really interesting
and may have time to show is the
pre-commit feedback the idea that before
I actually commit my code to the reef oh
gosh this back up in normal cases when I
want to get feedback on my app I have to
commit the code to the repo see I then
build it into a test server and I say
hey product manager docks guy you know
whatever stakeholder is go to this URL
on the staging server on the test server
whatever have you and you can see what I
just built that does it meet your
requirement but that's kind of an
efficient because I already committed
the code to the repo at that point it so
the answer is no that simple
requirements at all then I got to go
back it out which is a pain so what is
much better is to do that before you
commit to take the URL of the workspace
that you've been working in and say
stakeholder look at what I've built
before i go and committed and tell me
i'm on the red track if I am commit push
go if not we work no harm no foul all
right so let's get into the demo
alright so this is code ending this is
what we call the user dashboard this is
kind of where I organize my work spaces
my stacks all the things i'm going to
use as a developer or as a team now i
want to start by creating a works but
reading workspace and do that by
clicking add workspace and i want to
choose a run time that is custom to me
based on my kind of production
environment look at the runtime tab and
unfortunate because lose iam it's not
obvious but there's a stack authoring
I'm going to go and grab a compose file
there's my compose file I'm just going
to drop it in and this one I've kept
fairly simple it's using a database
which is my sequel it's got some
environment variables it needs I'm
giving it a gig of ram got something all
the des machine which actually i think
imma call app it was like a more natural
name and that's based on ubuntu jdk 8
docker image we give it too big and of
course it depends on the database the
database will be limited first now we do
syntax checking on this but this is all
clean when errors i do get is that the
environment need something called i def
machine it needs to have some one of
these multiple machines designated as
the one into which that source code will
be live sankt so i don't really want my
source code in this case blog sent to my
database obviously so i'm going to
choose my at machine I come down here
you can see I can see the source for
this I'm just gonna hit dev to inject a
terminal inject SSH capabilities and the
rest of the IDE tooling so this can be
some of the intellisense and the ability
to connect back to the code and be
server all these things that I need now
actually before I go and you can see it
that a terminal ssh for example I'm
gonna go down I guess yeah that my dear
day I'm gonna add a terminal to my
database as well all right
I'm going to save that workspace all
right and I'm gonna go ahead and open it
now you can see here that we're starting
docker building the container look
obviously starting with the database
container and we're building us out
although it's going to standard air that
is actually just standard edit
information just didn't miss piped so
we're building up the database now it's
creating that getting rid of setting the
table setting off parameters unless
death in a second one that finishes you
can see another machine pop-up called
app underneath processes there and again
a second set of docker instructions are
going to roll by that's going to be
obviously the creation of that app
server machine which in this case is
like i said jdk 8 on a bun to running
tomcat kind of fingers crossed it all my
external repos are available now the
first time i do this it takes a little
bit longer when i'm doing it from recipe
because i actually have to build the
docker image if I was doing this
actually in an enterprise setting
typically I would just reference and
already built enterprise damage and this
would be of course much much faster but
it's kind of fun to see the DIA the cake
get made here so there's my app now that
my database is fully up and here you can
see some of the processes that are being
injected in well you did see them now
we're starting the tomcat server that is
you inside the container itself this is
just about done
alright that's the leader he's my
windows here cuz they have zoomed in
fairly heavily okay so at this point now
I've got run time I've got a pair of
machines I can start criminals on either
than these terminals I have root access
into that container and if I were to
give this same recipe to someone else
they would get their own distinct set of
containers but with obviously an
identical configuration now it's time
for me to import a project on the pull
this one from github and my dream is a
little bit too big here now we're
pulling in the sources and the next
thing we're going to do is it's going to
ask me about what type of project this
is and project typing is an important
part of let's check so it doesn't just
take source code willy-nilly it wants to
be able to provide helper functions that
are appropriate for different types of
projects so for example in this case
this is a java maven project and that's
going to kind of tell chey a be aware
that there's a polym xml expect one know
that mvn clean install is a typical way
for you know this project to be built so
there are certain shortcuts or
assumptions then that can be made on
behalf of the developer which makes
things easier for that developer all
right so there I've got my app my code
has been pulled in I can go ahead and
start opening up the actual code itself
now within the editor I've got some
fairly typical things here in terms of
code holding second there we go get rid
of some of this stuff I've got auto
complete with all the proposals I can I
was not really much in this particular
one you know what let me open up one of
the actual service implementations and I
can do for example a rename okay you can
see it's fairly instantaneous a lot of
people i think assume that a
browser-based ide is going to be slow
but the reason why it's instantaneous is
actually fairly simple one of the things
that the che does which is quite clever
is it the language server itself is
embedded inside the container so it's
essentially local to the code local to
what you're working on so we're a lot of
cloud ideas I think try and centralize
that job and have everybody calling out
to some centralized language server
which on the surface appears more
efficient in fact decrees a great deal
of latency and is what results or what
causes that kind of sluggishness that
people tend to habitually associate with
browser-based ide so the case is
obviously gotten rid of that now um next
step is I want to be able to run some
these things now because I'm building
this from scratch there are no pre-made
commands typically if I were doing this
for my team of course I would create
this insert a bunch of relevant command
and then say that as a stack so that
anybody else you built on that stack
would automatically get the right
command but once again let's let's make
ourselves some sausage here so you go
and edit the commands this is amazin
command so I'm going to choose that I'm
just going to call this build and deploy
taste in my my commands now basically
the do a clean install it's skipping
some tests it's taking the resulting war
file from my target directory and
dropping it into the
a tomcat and then going ahead and
starting tom cat so common series of
steps but one which once I add it to my
workspace everyone can take advantage of
they don't need to all kind of rebuild
now of course if they want to do
something specific they can build on top
of that and you so all right so I'm
going to run that build and deploy and
then you go we're executing all the
amazing commands again fairly snappy go
recover what if I actually pull this
down again and go see that there is now
a project explorer a new target
directory I should have pointed out
beforehand that there was no target
directory now there is obviously because
I've gone built it and my app server
started up so I go and run this and this
is my clinic application which I need to
make much larger I've been into active
list this is you know if i go to find
owners this is going to find all the
others in the actual database you know
so we're making cross container calls
and in getting all the goodness back now
I completed that change i made in terms
of refactoring hasn't gone broken
anything so it's it's safe to kind of do
my pull request so let's do that we've
got a handy pull request panel which
makes my life a little bit easier of
course you can use you know get tools
from our menu up here including things
like a gif I could just do a quick
compared against origin master and it's
going to show me those changes I made
here
so I'm going to go ahead and create this
this pull request I can also do pull
request from the command line i'm going
to create a new branch actually and we
call the dedlock's call this factor and
create PR ah now this is helping me out
a little bit hey w didn't commit your
changes I want to do that so I am going
to do that this is where you know I
think a lot of times this type of
interface is really good for fairly new
developers once maybe don't need all of
the complexity and features of a of the
desktop ide and you can see we've gone
and done me the polar quest and whether
we don't want to do although we're
trying to smooth out workflows we don't
want to overtake or try and replace
existing workflows it just makes sense
they just work for developers and you
know the the pull request interactions
with in github just work and so we're
going to open this up on github as
you'll see it is a standard pull request
really differences and I can go and add
comments here at stuff I did not need
comments in my actual pull request which
I should have done but what's actually
kind of cool and what I really wanted to
call attention to is that button so a
bunch is automatically added and what
that button does is it wraps the
definition of that workspace that I just
had as the contributor so that anybody
who comes to do a code review does it
need to worry about whether they're on
the right branch or whether they've got
the right runtime dependencies or
anything else they simply click this
link and once again it's going to go
back to that code Envy system and it's
going to instantiate I mean contain it
now in this case it's not working
because i'm using our hosted cloud and
I'm limited to three gigs of RAM which
I've already used but the workflow I
think you know makes sense and is and is
clear so you can imagine now where
before to do a set of code reviews if
you ever had to leave the github
interface to do them it can take some
time
kind of you know get your own
environment setup identically this makes
it incredibly easy I click on it I get a
new tab I get a new ide I can build I
can run I can debug it doesn't affect
any of the work on doing any of the code
on touching and then I can close it when
I'm done after I make my comments all
right now all of this is kind of
depending on a concept that we call
factories so a factory is a way to
template eyes a specific workspace
configuration so what I've just created
is this 227 00 i should give them a
better name but let they want to create
a factory now based on that workspace
first of all why would I do that we've
now to do that is because if I give
somebody the URL in my browser I'm
inviting them into my set of containers
and that may be okay sometimes made us
exactly that i want sometimes i want to
you know get another guy on my team and
maybe knows the api is better jump into
my actual containers with my code and
help me to sort out a couple things
really quick great but in many cases and
in fact most cases what we see in the
enterprise is that people want to take a
definition of workspace that they've
built up and now shared as a template
with the rest of the team so that each
team member can have an identical but
separate set of containers in the same
way that i typically want to work on my
laptop but you want to look on yours
it's on the cultist factory dev rocks
for obvious reasons and there we go to
270 so that's the workspace that i just
created that is exactly as I like I'm
gonna create and that's it it's done
another two links which perform an
identical function they anyone who
clicks on those they would have created
within their accounts a set of
containers with the same run times of
the same project sources to the same
branch all that goodness with the same
command the only difference is that the
top one includes transparent naming
which is useful inside an organization
so you know who owns this factory if
there is an issue with it I know exactly
to go to this is Brad's dr. let's go bug
Brad or an object ated version which is
helpful for if
I need to get feedback from folks
outside of my organization perhaps from
a partner from stakeholders from a
customer and I think then we configure
this you know away from what I did for
myself to make it appropriate for my
team so perhaps for my team I want to
increase the size of the database maybe
some of them do more database work that
I typically do and so for this to be
valued as with all of them let's give
them a little bit more meat there or
perhaps I want to add a new command
perhaps I want to remove a command I can
do all of these things the other thing
that that gets used a lot within our
enterprise customers is the ability to
run a commander open a file upon
execution of this factory so the URL not
only provisions the workspace it can
actually automate actions within that
workspace so for example if I'm creating
a factory based on a workspace for QA or
for docs people who have a familiarity
with the code but maybe don't need and
aren't don't want to be heavily into the
code base I might have it automatically
build and run the moment that the
workspace has started so that they're
ready to just click on that preview link
open the app and start playing with the
application at its current state that
can be very helpful for them get out to
hunt around or open file is what we
often use in cases where we're
dynamically creating these factories in
response to certain events for example
if i get a build failed notification
from Jenkins and the builds failure is
identified as being part or resulting
from a particular file I could have that
file automatically opened in the editor
person doesn't need to hunt around to
figure out which packages it in it's
just there a very very convenient now
the workspace definition itself and the
factory definition are both JSON objects
so you can see here the JSON definition
and it's really quite readable it you
know includes workspace definition
information you can see here my full
composed syntax here's my project
definition information where is the
location
type of project it is I've got my
command information and I've got meta
information about me as a user the be
kind of owner of that so that's it I can
take any one of these and once again if
I stop the workspace this time stop
without a snapshot actually and once
this is stop I'll just use that friendly
URL I don't know if you guys can
actually see it not really a and is just
going to go and create the identical
workspace digest pad all right not once
again okay so that's kind of the high
level on the usage of codenvy within an
enterprise we have integrations with
JIRA as i mentioned jenkins you can take
those urls though as you can imagine and
put them pretty much anywhere I mean
URLs can be can be dropped into just
what every app now relax that you look
like there's a lot of different options
but to keep things relatively simple I'm
showing kind of the simplest example so
typically for an enterprise especially
this is installed behind the firewall
codenvy does host a SAS version of all
of this at codon vio and people can sign
up for free and they get three gigs for
free and they can you know buy more ram
and all that stuff but for most of hours
after a hundred percent of our
enterprise customers they're not
comfortable having their developers in a
shared resource public cloud like that
with the source code so just get
installed behind a firewall and that
could be in a VPC on amazon or you know
google cloud or whatever have you or it
could be in vm it could be you know
wherever it wherever it wherever you
want where the requirements really is
just that you put it somewhere where
docker can be executed because codenvy
itself is a collection of 11 docker
containers so these are brought up in a
and compose relationship much like what
i just showed so the master is what
handles of course the authentication
that's what your databases
that's what's reading all the requests
to the various what we call machine
nodes the machine nodes are where the
actual workspace containers are run now
I can integrate with ldap or ad that's
obviously going to go into the master
and my daughter registry my artifact
leave on my source code repo all need to
connect to both the master and the
separate machines now I don't need all
of these things of course you know dr.
registry is included with code Envy but
it is you know a fairly straightforward
insecure registry and every enterprise
that we work with has a secured registry
you know that they want us to go out to
and that's what happens now clients come
in through the master so they always
have the same URL and then they are
distributed through to the correct
machine now today he the default
mechanism for orchestrating those
containers across those nodes is dr.
swarm however Red Hat is building and
kind of extension to check which will
allow that to be executed on sight on an
open shift cluster instead and managed
that way through kuba Nettie's multiple
different options now in terms of
getting started with it it's super
simple basically you just go to wear to
a computer that docker runs on you type
docker run codenvy / CLI start and it's
going to kind of guide you through
essentially building the full docker run
syntax for code India itself we have to
use certain things like mounting the
Dockers sock you have to mount a data
directory all that kind of stuff in
terms of managing codenvy it's also
fairly straightforward because all the
stateful information that is required is
all kept underneath a single directory
so it keeps it nice and simple for
knowing that if I back up that directory
on a periodic basis if I need to migrate
data I just need to grab that directory
everything is there that's where the
postgres databases that holds the user
information it's where the config
information is for every part of the
code Envy system it's where all the
stateful logs are kept so all of that
stuff is kept and excited the containers
the containers themselves can be
recycled at will without losing any
state now earlier this year we released
codenvy 5 based on che 5 and if any of
you are familiar with a clip show
there's some things that went into 5
that we're pretty exciting so multi
machine work spaces I showed you that
today and the ability to work with those
production doctor files the injected
agents we've added a bunch of
intellisense and they're going to be
adding more and more and how many people
heard of the language server protocol
couple ok so the language server
protocol is an open protocol that was
started with red hat and microsoft and
codenvy and defines a transport
mechanism between a language server and
language server is what provides the
autocomplete business in tax checking
all that good stuff and an IDE client so
this is actually a really pretty big
deal because it means that as a language
author I can create a single language
server and it's going to work with the
classic clips desktop ID with a cliff
che with microsoft PS code with with
with with with whereas before I would
have had to have created a separate
language server implementation for each
of those targets and then for us as the
creators of an IDE it's fantastic
because it means that we don't need to
build in hyper specific tooling for
every single language you know with our
own effort every time we simply need to
grab the new language server and poured
it into the product so C sharp go PHP
JSON typescript I'm going to be
forgetting some Python are all language
servers that are in che already there's
about another 20 or so that are being
built and various stages of completeness
that will be added over the coming
months so just very quickly to a stage
where as an IDE the chavis browser IDE
is really legitimately supporting many
languages at a high level
kind of you know professional capability
and that's that's a big deal too and a
lot of the enterprises we talk to
because we're we tend to excel is in the
more complex environments in the larger
more complex enterprises and in those
cases a lot of times the teams are
multidisciplinary and the services
especially we look at a micro services
style architecture are written in
different languages and it can be quite
nice for the developer to be able to
shift from you know python to see to
Java to JavaScript without needing to
always change IE as long as they get a
rich enough set of features one other
thing that's coming is intelligent
commands I'd wanted to show that today
but unfortunately I had some issues this
morning connecting to the server where
it's on now codenvy adds a number of
changes both for developers and then for
what we'd call kind of DAB ops teams
it's kind of a bastardization of the
term but for developers first of all
we've got ldap support has been nicely
expanded so now fso is much simpler and
easier and that makes like for those
folks easier there's a kind of
organizations or a team's model now in
place so that as a developer or the team
lead I can create a team and then have
kind of default sharing with the members
of that team so that I create a new
stack it's just going to automatically
be available to my team I create a new
workspace automatically available to my
team factory automatically available to
my team it just kind of smoothes out a
lot of that process the docker ization
of codenvy was new 45 which also brings
an offline install and this is an
important for a couple of our customers
who have high security environments and
they really want to be able to make sure
that they can do this download it to a
kind of a DMV type server run a number
of checks on it to make sure it's safe
and then move it into the secure
environment which in some cases is fully
disconnected from the internet and it
still installs it can still do you run
and a good lab integration was on it now
in terms of DevOps we've added auditing
for work spaces and user access so that
it's clear for the folks managing the
install who's going in which workspaces
are most pop
which ones are aging out that maybe I
can remind developers that they can go
and delete there's a centralizing of the
database cross-platform backup and
recovery support for AWC CR and
snapshotting which didn't show actually
I probably should have one of the things
that we can do a lot of people worry
about as soon as you say it's a docker
container with my code in it is oh wait
a second so when it stops all my state
goes out the window I don't know if I
like that as a developer and you
wouldn't and you shouldn't so what
happens with code Envy is that by
default when you stop a workspace we
actually snapshot it so we save it off
as everything in the exact state of sin
so that when you restart from that
snapshot you're in exactly the same spot
you were before you of course have the
option of stopping without a snapshot if
you're just going to trash the
environment and that was what I wanted
to cover and we've still got 10 minutes
which is good that was just wrote where
I wanted to end up because I wanted to
leave a little bit of time for questions
are there any yes yep
yes if the test native is not part of
the of the recipe or the definition of
the database image then they would not
have it now what some organizations will
do is create recipes or images that
include test data specifically for that
purpose and you could have multiple
recipes for machines in related stacks
so that you say the developer okay you
can start with your hack space back then
move to your you know pre-commit
validation or testing stack and then to
your productions back fennekin
absolutely yes oh no for sure so by
default we can create that extra factory
in the in the commit but you could
easily or in the pull request pardon me
but you can easily just take copy your
particular URL copy it into there and
say you know I've added special test
pages so click this URL to actually give
the code review use the snapshot it is
right now and and the other technical
folks will keep me honest here but
that's it's not terribly automatic there
would be some kind of manual movement
you'd have to do there yeah yeah it
that's a little trickier
you can well so we be doing in that case
if you be probably creating a plug-in
for example for J and then compiling it
into a custom assembly so what you would
do for code Envy is you would take the
plug-in to code Envy and recompile
codenvy to create a custom code Envy
assembly so it's not so much that you're
moving the custom che assembly over it's
that you're moving the plug-in over and
then creating a custom code Envy
assembly well so yes it is totally
possible first answer second thing is
that the license you need a license to
allow you to do that to use the rights
to do that but the source code for code
Envy is publicly visible so that's of
course different than open source but
but it is publicly visible so yeah yeah
we totally encourage people to do that
we have a lot of companies that have
kind of what we call OEM code entity
created their own custom assemblies you
know large ones and small no pleasure
look what company arrested on my
okay cool we have a lot of customers in
the financial sector the security of the
system the fact that the source codes as
mentioned land on the developers machine
is a great interest in those environment
any other questions
all right well if you do have questions
later where we've got a boost up in the
exhibit hall kind of beside the B IBM
booth there so it should be pretty easy
to find alright thanks very much guys ok</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>