<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Collections Refueled by Stuart Marks | Coder Coacher - Coaching Coders</title><meta content="Collections Refueled by Stuart Marks - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Collections Refueled by Stuart Marks</b></h2><h5 class="post__date">2017-04-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/q6zF3vf114M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">coming
my name is two remarks to work in the
core libraries team in the Java platform
group at Oracle I work on Java and the
JDK and one of the things I work on is
the collections framework so the talk
today is collections refueled and so
collections has long history I'm going
to do a very very brief history that I
am going to spend some time talking
about Java 8
even though Java 8 has been out for
almost 3 years now there are some
interesting features that were added to
collections Java 8 that don't seem to
get enough publicity so I'm going to
talk about those a little bit and then
move on to some new features in Java 9
so there's a Twitter hashtag collections
revealed you can see that up at the
upper right so if you want to tweet to
me during or after the presentation I
will look at that hashtag and respond to
any questions there or it's a small it's
a small crowd if I have time we can take
questions at the end and I'll be around
the conference for the rest of the
afternoon as well alright so history of
collections so Java is now over 20 years
old and the collections framework is not
quite as old as Java it is is almost
almost twenty years old the java 1.0 was
introduced with what we now call the
legacy collection so there was no
collections framework in the very
beginning the old things vector and hash
table or hash table as some of us call
it but those were replaced in jdk 1.2
and that's the collection framework that
we're all familiar with with the
interfaces collection list set map and
so forth and the concrete classes to
back them up the usual usual suspects
ArrayList hash map hash set and so forth
so those were introduced in 1998 and so
that was nineteen years ago and so those
are in in use daily in fact the paper
just came out
a few weeks ago or actuals pre-published
it's going to be published at the
conference this this summer I think
basically did an empirical study of the
usage of collections and it turns out
ArrayList surprise surprise is the most
used collection in Java some some very
large fraction might have even been a
majority of uses of collections our
ArrayList so moving on quickly in Java 5
in 2004 generics were added to the
language and that had a huge impact on
the collections api's and so by now I
hope everybody is converted over to
using genericized collections instead of
instead of the original raw collections
and the other big addition in Java 5 was
the addition of the concurrent
collections I'm not going to be talking
about those today but that's a whole
whole kind of related framework that has
some overlap with the collections
framework and then along the way various
individual implementations were added in
various releases such as a ray deck
priority to you know new mapping room
set and so forth so those are very
specialized collections they don't get
much general use but when you need them
they're there and they are really useful
alright so Java 8 collections
enhancements so I think most people are
aware that the big features of Java 8
were lambdas were added to the
programming language and the streams API
was was added to the core libraries so
you know really interesting feature
really useful I hope everybody is using
them but backing them up are some
additional language features in
particular interfaces can now have
default methods and static methods so
that's that's an interesting language
feature I'm not going to talk about the
language enhancements themselves what I
do want to talk about is the way we use
those language features in the JDK to
enhance the collection framework in JDK
8 and so what we did was for the first
time I say the first time ever in 15
years I think for the first time ever we
actually added
methods to the collections interfaces
and so that was a big deal about default
methods prior to default methods you
could not compatibly add methods to an
interface otherwise would Budhia it
would be an incompatibility
so in java 8 with the addition of
default methods it's now possible to add
methods to interfaces and we went ahead
it did so and so collection let's get er
able ya iterable collection list got a
few new methods map map and comparator
and spend a little more time on because
they got quite a number of new methods
the interesting thing about this well
couple interest a bunch of interesting
things those new methods were i mean it
it's not a requirement that new methods
have to use lambda but a lot of those
new methods were added from the
standpoint of oh now that we have this
new method when we when that new method
can accept a lambda it can do many more
powerful things so i have a bunch of
examples of that starting effect on the
next slide so the iterable interface has
been there since java 5 but basically it
allows you to use the enhanced for-loop
so in java 7 here I've kind of pairs of
code snippets on the top there's Java 7
and then down below a rewrite of that in
Java 8 and so in Java 7 if you wanted to
iterate over lists you could use the the
officially it's called the enhanced
for-loop some people call it the for
each loop I tend to avoid calling in
that because there's now a method called
for each so Java 7 you write the
enhanced for-loop
but in Java 8 what you can do is call
the for each method and pass it a lambda
and what it does is it executes that
lambda on each element in that list and
so that's that's a little syntactic
nicety but interval is inherited by
every collection implementation so all
the collections are now enhanced by
having this for each method on them and
in fact indeed all the other methods all
the other default methods are inherited
all the way down the hierarchy so what
we've done is by adding default methods
we have enhanced every existing
collection even ones that were were not
introduced
in Java 8 alright continuing on the
iterable actually this is iterator not
iterable but if you've ever written an
iterator you had to write has next
method and a next method and oh that's
right you have to also write the remove
method well I don't want to support
removal so you always wrote throw new
unsupported operation exception and so
now there's a default method on iterator
called
remove there's a default implementation
which simply throws unsupported
operation exceptions so this is really
nothing more than convenience if you're
writing your own iterator you simply if
you if you don't override remove you you
well you don't have to override remove
anymore and if you don't you get the
default behavior which is to throw an
exception which is pretty often what you
want because they're relatively few
iterators support removal but if you do
want to support removal in your iterator
you just go ahead and override it like
you always did
alright now he thinks getting a little
more interesting here because instead of
just sort of syntactic niceties we're
getting into some bulk operations so
suppose you have a case where you want
to run through a list and remove
elements that match some criterion so in
Java 7 you could you had to write the
for loop you had to write it out kind of
the old way by using an iterator so you
a key point here is that you cannot use
the enhanced for loop because you can't
remove things from within a loop
otherwise you will get a concurrent
modification exception and so what you
had to do was fall back to the original
loop loop using an iterator and then if
something matched you called remove on
the iterator so that's the java 7 code
and it it's it's kind of bulky
especially you know even compared to the
to the enhanced Fork of the enhanced
for-loop code that that you would write
if you weren't removing something now in
java 8 there's a new method remove if
that takes a predicate and the semantics
are that predicate is applied to each
element of that collection and if the
predicate returns true
then it removes it from the collection
and so that's that's pretty nice I mean
so you look that that you know four or
five line four loop there collapse down
to a single line makes things much nicer
but it's not only a syntactic advantage
it's actually a performance advantage
and so if you consider iterating over an
ArrayList if you remove something from
an ArrayList it has to have to shift all
the elements up in place and so if you
do that repeatedly within an ArrayList
then you get an order n-squared
performance because it's repeatedly
shifting the tail of the ArrayList back
up as as elements are deleted and so
remove if in Java eight is optimized for
ArrayList what it does is it is it keeps
track of which things are removed and
then does the copy and operation all at
once and so we've reduced the algorithm
from N squared to order n at the same
time we've made the code a lot more
concise and so the the benefit here is
that the remove if operation it's its
internal iteration and it's raised the
semantic level of the API so instead of
looking at the collection from the
outside and picking at things one at a
time we're now saying okay remove all
the elements remove all the matching
elements that's basically what this says
so the implementation takes advantage of
that with a better algorithm all right
moving on more more new default methods
the list interface has couple new
methods on it one of them is replace all
and so what that does is it it replaces
every element in list with something
else so suppose you wanted to do that in
in Java 7 again you could use the the
old fashioned or the original style of
for loop using a list iterator and then
the the example here is suppose you
wanted to run through a list of strings
and convert them all to uppercase so you
could run a list iterator over the list
and set each element to the element
converted uppercase so that's the top
code snippet there but most people don't
do that I don't does anybody ever
you list iterators any show of hands
here no I think Lissa diretor I mean
it's it's interesting and powerful but I
think nobody uses it and well and the
reason is a if if you had different
kinds of lists then you would want to
use an abstract way to iterate over them
using lists iterators but since
everybody is using an ArrayList you
might as well just index into it and so
that's the second code block here and I
think everybody would probably write it
this way or you just index from zero to
size and then set you know just call set
and get using using the index operation
and that's perfectly fine if you know
you're operating on an ArrayList if
you're operating a linked list then that
will slow drastically but you should be
using linked lists anyway and that's
that's a different talk so anyway in
Java eight this gets even better so we
just called the replace all method and
give it a lambda function or method
reference in this case that transforms
the element so we say string colon colon
to uppercase so it takes a string
converts it to uppercase and replace all
just runs through for every element
replaces it with its with its uppercase
equivalent and so in one line we've
replaced those loops that kind of did
things sort of one at a time now when
people see this they often say oh I want
to change I want to change this list so
that every element is is transformed
into something different of a different
type and you cannot do that with replace
all for that you need to use a stream
stream out the elements transform them
into something of different type and
then collect them into a new list
alright so another method that was added
to the list interface is sort so well
big deal instead of calling collections
lot sort on a list just called list dot
sort what does that buy you well a
couple things so the the collections dot
sort method had to operate on a list of
any implementation of
and so the the most generic way to do
that is to copy out the list elements
into an array sort that in it would be a
temporary array that was temporarily
allocated just for the purpose of
sorting sort the array in place and then
copy all those elements back and so the
default implementation of list dot sort
does exactly that because it doesn't
know who it's inherited by however
ArrayList dot sort again ArrayList being
the most commonly used collection
ArrayList dot sort overrides the default
implementation and says hey I am an
ArrayList I know I have all my elements
stored in internal in an internal array
I'll just sort them in place in fact
there's something called arrays dot sort
so all it does is turn around and call a
raised dot sort on on its internal array
and so we've we've saved a bunch of
memory allocation and we saved a copy
out and a copy back in so the override
of raela store actually is buying us
quite a bit here and in turn collections
that sort simply turns around and called
sort on on the list that it's provided
so you don't even have to change your
code so if your code is using array
lists and you call collection dot sort
you get this new behavior for free all
right now I'm moving on to map there are
a whole bunch of methods added to map
but I'm going to run through I think the
most some of the more interesting ones
here but they're a lot more than I can
cover in this talk so in Java 7 if you
wanted to do something for every element
of the map like print out you know print
out the key the key value you know print
out each key in value you'd use you
usually do a loop over the entry set of
the map and then do something useful
within that for loop and so in java 8
there's a for each on a map it's just
kind of like the for each on interval
except that instead of taking instead of
taking a function that takes one
argument
by function which takes two arguments
the key and the value
so you can write a lambda expression
that does that and it you know it's
mostly a syntactic nicety but what it
does is it instead of you having to
iterate over the map entries and then do
get key and get value it just hands you
the key and value separately so it's
much more convenient in that way similar
to lists there's also a replace all on
map and so again you can you can in Java
7 you have to write a for loop over each
entry map entry has a set value method
so you can actually modify the the
underlying entry in place but replace
all does that for you and so the
semantics here are this takes a lambda
that takes two arguments the key and the
value and the return value is the
replacement value and so if we want to
change all of them the values in the map
to uppercase we just write it here k v
arrow and then call v dot to uppercase
so this is kind of limited i mean if you
want to do exactly this it's wonderful
but it can only change the values in the
map you can't change keys and you can't
change the types of either the key to
the value so there are limitations there
if you want to do those things you have
to go over to streams and stream over
the map entries and transform things
that way all right now here is kind of
an extended example and i'm going to set
this up by talking about multi maps
which many people are familiar with but
if you have a one of the things about a
built-in map takes a has key value pairs
but most importantly they're for every
key there is exactly one value and in
many cases you might want to have a data
structure where you have a key that maps
to multiple values and so the various
libraries such as eclipse collections in
guava have multi set excuse me multi map
data structures built in JDK does not
have one and sometimes if you can't use
one of those libraries what you have to
do is say okay I can't use a multi map
so instead I'll write out a map
up from say if I want a map from string
to multiple integers I would have map
from string to set of integers and just
store that in a regular hash map and in
seven in Java 7 and earlier this can
actually get pretty painful so here's
some code to do that if I want to put a
value string string and an integer into
my multi map then I first have to say ok
get the value for the key to see if
there's a set already there if there
isn't then I have to create a set and
put it into the map and then finally
after that I have to add the new integer
value into that set there's a similar
thing for rule except kind of in Reverse
I ask you get the value corresponding to
this key and if it's non null then I go
ahead and remove it from the set oh but
also if the set now became empty I want
to remove the whole thing and in fact
all right I'm out of room on the slide
so it's already it's already the code is
already too bulky so it turns out there
are a bunch of new methods in Java 8
that make things like doing things like
this really easy so one of them is
compute if absent what's interesting is
that the the concurrent hash map prior
to Java 8 had some of these because you
really need atomic composite operations
on concurrent on a concurrent map so
these some of these have been promoted
to the main map interface in Java 8
anyway so compute if absent is an
interesting thing here what it does is
it evaluates the lambda expression that
you pass it if if the key is absent and
then it takes the result of that and
stores it in the map and interestingly
regardless of whether it actually did
that computation or not it returns the
value corresponding to the key so you
have to pick through this a little bit
carefully but basically what this does
is add the new hash set if it's absent
and then so so that we have a set valued
multi map and so what the return from
compute of absent is the set of integers
and then we just go ahead and add it and
so I'm not going to go through all of
these in detail but you can kind of see
they have the same flavor remove is kind
of the same way there's kind of
complicated expression there but what
remove can do is actually so there's
there's a there's a dual to compute if
absent which is compute if present and
what these can do is if the return value
is null and actually has the effect of
removing a mapping from the map and so
if you run through a multi map style
collection their usual map kind of
operations like I show put remove
contain size values and so forth
basically with the new default methods
on map all of these turn into one-liners
and so if you don't need to have a full
multi map implementation and most
applications don't maybe you just put a
bunch of stuff in and then say okay I
want to you know I want to I want to
deal with these particular cases you can
you can kind of get the effect of your
own multi map just by implementing a few
of these one-liners so in fact this
isn't even the half of it so I show
computer if absent computer present and
get our default which are new methods
new default methods on map there are I
think there's well I'm not even going to
go through them all they're a bunch more
and what you have to do is go through
the Java doc and look for things things
on the map interface that are since
since 1.8 but anyway I think these are
the most interesting ones here all right
so there's another interface that we
spent a lot of time on in Java 8 which
is comparator now comparators are in
their simplest form are pretty easy but
when they get complicated they get
really complicated and error-prone and I
think there's there's a whole other talk
to be done about comparators themselves
but what we did in Java 8 was add a
bunch of helper methods or combinators
which take which which construct simple
comparators for you and then also come
comparators to return to create new
comparators that give more complex and
interesting behavior and so what that
should allow you to do and it's not
quite there yet but probably in a large
fraction of cases what these new methods
allow you to do is take a bunch of hand
coded open logic and compress it into
function essentially successive calls to
these comparator methods that provide
that provide composite functionality and
make things much neater alright so I'm
going to run through a quick example
here which is a two-level sort so
suppose you have is it a person class no
student class or something like that
just say student has a last name and
first name so I want to do the first
level sort on the students last name and
then for students that have the same
last name I want to do a second level
sort on the first name but there's also
a catch because maybe we don't have the
maybe we don't have a first name for all
the students and the first name might be
null so if the students first name is
null then those should sort before
before all other students that have a
non null first name all right so let's
look at what you have to do in Java 7 to
do that I'm not going to pick through
all this code but you can kind of
eyeball it and say ok we get the last
name you compare it and then alright so
so if the last names are equal then and
get the first names then we do null test
and then you know there's a little bit
of dancing around here and I'm pretty
sure this code is correct but I'm not
entirely sure you could pick through it
and in fact if I introduced the bug then
it would be really hard to see that
there actually was a bug because there's
lots of lots of little conditionals in
here lots of little details if you swap
a one and a minus one in the wrong place
you know boy it's really hard to it's
really hard to determine that by
inspection
unless what you do is you go out and get
some sample data and pick through it or
step through it any bug or something
like that so this stuff writing this
kind of stuff is really error-prone
and I see a lot of questions on Stack
Overflow and forums about what's wrong
with my comparator and so forth and it's
not surprising because this is really
it's really detailed and if you don't
get it exactly right you have a subtle
bug that that can creep in alright so in
Java 8 alright so this is this is a
little bit of a refactoring so instead
of calling collection stop sort we call
students thought sort and instead of
using an anonymous inner class we
convert it to a lambda and you know that
helps by you know 10% right so we got
rid of a line or to a boilerplate code
but basically that bulk of custom logic
inside the comparator itself is the same
and it suffers from all the same
problems and unfortunately I don't have
time to go through this in detail but
you'll have to believe me that this code
is the equivalent of the code on the
previous slide and so what we do is
there's a there's a new method called
comparator dot comparing and it takes
what we call a key extractor so in this
case it's get last name it's just a
function or just a method that gets a
field out of out of your object but
what's interesting is a typical Parador
is highly stylized code I want to get
the field from this object I want to get
the field from this object and then
compare them and so instead of writing
that out by hand comparative comparator
dot comparing does that for you and so
you just say which field you want I want
to get the last name ok boom there's a
comparator that compares last name
there's another method on comparator
called
then comparing and so if I have five a
comparator and this first comparator the
result of this calling the first
comparator is that the values are equal
then I want to apply a second-level sort
and that's what then comparing does so
it takes two comparators and smashes
them together in this particular way to
give you a two-level sort so instead of
having a bunch of conditional logic that
does that for you it it allows you to
build up this composite comparator from
smaller comparators
and then Noel's first is kind of the
same thing so generally we want to do a
string comparison but what if the string
is null well you're going to get a null
pointer exception
well nulls first is another utility
method that says okay I'm going to do a
comparison and I want to sort nulls
first so it sets those aside and then
for non null things it just calls the
calls the regular comparator so again
the flavor here is that we're building
up a complex comparator with lots of
weird conditionals and stuff that you
saw on the previous slide by composing
little bits of pieces so we start with a
natural order we we sort the nulls first
and we then we're sorting the results of
first name on that and that's the
second-level comparison within the
first-level comparison of get last name
so there's a lot of stuff going on in
this code that that saves you the effort
of writing all the complicated
conditional logic on the previous slide
I should have put up this slide because
this sort of explains it here but anyway
that this basically says what I what I
just tried to explain and so I'll make
sure this slide that gets posted and so
you can take a closer look at this
afterwards all right so after this now
that's the end of the Java 8 segment and
I can start talking about Java 9 now all
right
ok so what the the little bit of history
of of what went into Java 9 there have
been a couple efforts over the years in
Java to add collection literals these
have always been proposed as language
enhancements in Java 7 there was project
coin and one of the proposals that was
entertained was to add collection
literals and some proposals were floated
around but that that never went anywhere
after Java 8 there was a JEP JDK
enhancement proposal it was a little odd
it was a research jet but basically the
idea was to was to scope out what was
required to add collection literals to
the language and the
result of that was a decision that we
would not add collection literals to the
language and it's it's I think the the
most succinct way to explain that
decision is to observe that unlike many
other languages and systems Java has has
clearly defined architecture where the
JVM is separate from the java
programming language and the programming
language is in turn separate from the
libraries and collections are a library
construct and so if you mix the idea of
collections too closely into the
programming language itself then things
get to be very uncomfortable so the
question is suppose so as we have a
programming language syntax that creates
a list okay well what what lists your
that Beach should that be ArrayList well
ArrayList is fine for many things but
suppose I wanted it be mutable suppose I
wanted it to be sparse or suppose I want
it to be something else and so it
wouldn't be too difficult to do
something simplistic in the language but
then that would bind too tightly to
particular implementations in the
library and so if we didn't want that
tight binding then we'd have to design a
programming language that that somehow
had a looser coupling with the library
maybe ended up calling collections
builders or something but basically
since the language and the library are
are architectural II distinct building
something like collection literals
across that turns out to be great amount
of effort if we want to preserve the
flexibility of keeping the collections
framework at arm's length from the
programming language so anyway so the
upshot of that is we decided not to add
collection literals to the language and
instead what we said was let's add some
convenience api's to the existing
collections framework and that will get
us probably 80% of the benefit of
of collection literals but it's much
much simpler to do right it's a library
only construct so it's just AP is we
didn't have to we didn't have to make
any changes to the the JVM or the
programming language or the compiler or
anything they're just they're just new
library api's and they're pretty useful
there are a few cases where it would be
nice to have language support for it but
I'll talk about those in a minute but
otherwise I think it came out pretty
well and they're quite useful and I
think you'll you'll like them
alright so the design goals for the
basically so their convenience api's and
basically they are all static factory
methods so we are adding methods to
static methods to the interfaces to
produce collections collections
instances so the main goals of these new
api's are convenience and brevity to be
as close as possible to collection
literals as possible but we wanted them
to be space efficient you can gain some
space efficiency if you have an
immutable collection since it doesn't
need to be modified you can pack things
in in a different way and save a lot of
space and also the the collections
instances returned are actually
immutable which is kind of a new thing
in in the JDK all right so anyway so JDK
9 is work in progress
this work was integrated quite some time
ago so any any recent build of JDK 9
will have these in it and so I encourage
you to download JDK 9 and try them out
but the interesting thing about this is
this on it on its surface adding these
API is like well gee you know with an
hour's thought you could write out a
bunch of write out the api's and
implementations and I think I did so in
fact I did so several times but what was
what was interesting was that there a
surprising number of issues lurking
under the surface and design decisions
that we had to go through so that's
that's what the rest of this talk is
about so quickly here is the overview of
the new API is in JDK 9 so there is a
list of
taking zero one two actually up to ten
arguments and then list out of taking
varargs so that will create a list with
however many elements you pass
there's set of which is the same thing
there's also map thought of and math is
different because it doesn't doesn't
take elements of a single type instead
it has to take key value pairs so for a
fixed number for a small number of key
value pairs we pass alternating keys and
values but if you want more more than
and there's no way to do a varargs for
that so if you want more that we've
added a new method map dot of entries
alright so for efficiency reasons so
this is a snapshot of the Javadoc for
the the map interface so for efficiency
reasons we've provided zero through ten
over six tardes
because varargs unavoidably has an
overhead of constructing and copying
elements into an array and so in order
to avoid avoid that we provide six dog
overloads and so I don't know how many
of you were here at the opening keynote
when chet haase gave his you know
technology business talk I thought he
was pretty funny
I would like to be as funny as chat was
but I'm still working on it but I think
I have potential because when I posted
this API to read it somebody said is
this a joke so anyway here are some
examples of the new API is in action in
Java 8 actually this is kind of three
examples glom together
there's list set and map and so if you
needed to create a list arrays out as
list isn't too bad if you need to create
a hash set containing specific things
well the easiest thing was to create a
list and then put it into a hash set and
then map I think is the worst you have
to create a map and then call put
successively into it and on the bottom
you can see Java and I mean say list of
set of and math autos and it's all right
there and it's pretty nice so so
now so there's a variation here which is
if you wanted to to create a map with an
arbitrary number of pairs then you have
to switch over to this map dot of
entries method which takes a varargs
varargs parameter of map entries and so
creating a map entry is kind of can be
kind of complicated because there's
there's a map the the most common
implementation of map entry is abstract
map sought simple immutable entry which
is quite a mouthful so so one of the
other things that this adds is a static
factory method called math dot entry
lower case entry that just takes two
arguments a key and a value and returns
a map entry instance and so here's an
example of that because this exceeds the
number the six starred variation the
fixed arg overloads of mapped of so we
have to we have to use map dot of
entries and then pass it you know a
succession of entry objects all right so
they're a bunch of design and
implementation issues that I alluded to
earlier and so I'm going to step through
these pretty quickly here and the time
remaining so handling handling an
arbitrary number of mappings is what I
just what I just talked about we ended
up at that solution after considering
about fifteen other alternatives I
should I should write those up sometime
those are those are interesting they all
have pros and cons but but when you have
when you're faced with a lot of choices
you can't just look at and say I like
this one better than that one so I
actually did come up with a set of
criteria for what what I wanted out of
this API and so obviously simpler is
better less boilerplate but an
interesting one is the API should be a
compile time type safe so some of the
alternatives and some of the
alternatives that people proposed if you
have keys and values of of different
types then the most common super-tight
might be object and so how do you and
and you you can't have a VAR args that
has different types and so some people
said oh just take a VAR args of object
and you know yeah we'll deal with type
of
safety that's okay it's like wow I don't
think so job is very very much very much
focused on static static type checking
and compile time so having arguments
that are not checked at compile time is
is kind of a dodgy thing to do so
another thing is we wanted the number of
elements to be known at compile time and
so you can have a you know an
alternative was to have a builder so you
just call build you know add add add add
add or something like that and the
problem there is you have to in the
process of building you have to
accumulate those and that could involve
successive reallocations and copies
because you don't know how many times
the guy is going to add entries before
building the final map and so what we
wanted to do is again at compile time
have the size be statically known or at
least not statically known but known at
the initial entry and so varargs does
have that because when you receive a VAR
x parameter you get an array of a fixed
size and so you know that that that's
the number of elements you have so
another common one somebody said oh just
have just have two two arrays of
different things and and that's that's
fine two arrays at different types an
array of keys an array of values and and
that's fine that's fine that kind of
works you have to do some cross checking
to make sure that the arrays are the
same size but when you write out code
that does that then the keys and the
values unless you contort your source
code in a very strange way your keys are
going to be very far away from your the
corresponding values and so it's like
yes you can do that functionally in the
API but we need write source code it's
just not going to work so anyway and
then ideally we would like to avoid
boxing where possible and it turns out
that we were able to satisfy all of
those accept accept boxing so I went
over this already there's a new
convenience method called entry which
takes a key and a value you can pass a
succession of those to the map dot of
entries method so that's what we we
ended up with it's not perfect it's a
little bit more verbose than I would
like
but I think it does satisfy most of the
criteria and it works well all right so
here's something here's something fairly
new in the Java world which is immutable
data structures and so the the instances
returned by these new methods are
immutable which means that you cannot
modify them so I want to stress that
this is what I guess what we call
conventional immutability so it's just
like a regular Java collection it's just
that if you call a mutator method like
add or put then that is rejected with an
unsupported operation exception I want
to contrast that with other libraries
and other language systems that have
persistent or immutable persistent data
structures where you can sort of modify
the data structure but what you get is a
new data structure that has sharing with
you old one that is not what this is
this is kind of conventional
immutability anyway this is good because
there are a lot of cases where people
could use immutable data structures if
they had them in Java and so the very
common case to initialize a table of
things or list or something at the at
the beginning of a program and never
change it for the lifetime of the
program and so you don't want those
accidentally being changed and if
there's a space efficient way to store
them then you want to do that because
you know if you know that the destructor
is never going to be changed then why
pay a space penalty for the flexibility
of potentially modifying the data if
you're never going to do that so there
were they're there historically have
been unmodifiable wrappers in the
collections framework and that's kind of
the closest thing to general-purpose
immutability that was there up until now
so what you had to do is create a
mutable data structure populate it and
then wrap it in an unmodified alrea
oh and then throw away the reference to
the underlying one and that sort of
gives you immunity mutability as long as
you remember to throw away the
underlying reference but unmodifiable is
actually a different concept so in the
idea the unmodifiable wrap
is that they are views onto another
collection that are that do not permit
modification but if you still have a
handle on the underlying collection then
you can modify that so so even so if you
if you call into somewhere and it gives
you a nun modifiable view that means you
can't modify it but you cannot trust
that it will never change
so because somebody else might be
modifying it so this idea of
unmodifiable that already exists in the
collections framework really is
different from immutability and so these
collections cannot be modified unless
you go in like with reflection or unsafe
or something like that there are no
api's that modify these collections
alright so here is here's an interesting
wrinkle that bears some explanation the
iteration order of the hashed set and
map implementations that are that are
returned by the new collection factories
the iteration order is randomized and it
literally is randomized now if you look
at sets and maps in the existing
collection framework then there's some
words in there about the iteration order
is unspecified but historically the
iteration order has been pretty stable
so from from if you iterate over the
same collection multiple times it will
be in the same order
even from run to run or even from JDK
release to JDK release if you put the
same elements into a hash map or hash
set they'll probably come out in the
same order and the problem is that a lot
of code grows to depend on very stable
iteration order and from time to time
something will happen that will change
the iteration order like if your program
gets different input it might cause the
hash set to the half of the hash set or
hash map to rehash everything and then
things will come out in a different
order and your program will break or in
the JDK sometimes we've had to make some
performance enhancements or some
security vulnerabilities or something
where we would change the iteration
order of a hash map and people yell at
us a lot when you did that because you
broke our code it's like
well you know we come back with a finger
right yeah you're not supposed to just
hand on the iteration or but but we
can't we can't take that line too hard
because when we change the iteration of
hashmap our own code breaks right and so
what happens is it's like oh where's the
where's the dependent interdependent in
ordered pendency in this code I don't
know where it is just just change it to
a linked hash map that will give us
stable iteration order and then the
problems go away and it's like ah so
that's that's really uncomfortable but
the fact is we have the worst of prior
to Java 9 we have the worst of both
worlds we have iteration order that is
unspecified but that is stable enough to
low people into thinking that that it
actually is stable and then when it
changes
lots of stuff breaks so the solution to
that for the new collections only is
that the iteration order is randomized
so what happens is that the @vm launch
basically gets a random random number
which is XOR it into the internet hash
code and so the effect is that from one
run of the JVM to the next the iteration
order of the set and maps returned by
the new factories the iteration order
will change from one JVM run to the next
and so the hope is that this will flush
out any any code that has latent
dependencies on iteration order and that
those problems will be flushed out
during development and testing and so
that they they won't come out in
production but also actually it's also
buying ourselves some flexibility here
which is we may want to go in and
reorganize the internals of of the way
that entries are stored in these maps or
sets and we want the freedom to be able
to do that and get you you know better
you know better performance better space
efficiency and so forth without having
to worry about preserving iteration
order so that's one of the toughest
things if if you have to preserve
iteration order that's a cost that needs
to be paid even if it's not actually
specified and so we wanted to avoid that
so again this applies only to the new
collections
returned by the new collections factory
methods the existing collections you
know those are going to stay the same I
think adding randomized iteration of
those randomized iteration order to the
existing collections is is not something
that certainly not something we're going
to do by default maybe there would be an
opt-in thing for for debugging purposes
but nothing more than that
okay another characteristic of the new
collections is that nulls are disallowed
so I think in retrospect the new
collections introduced sorry but when
the collections framework was originally
introduced back in one point to the main
collections did allow nulls and in
retrospect that's that's been regarded
as a mistake nothing recent has allowed
allowed nulls in particular the concur
none of the concurrent collections allow
null entries and the reason they're a
couple reasons that one is null shows up
in special kit in special places in the
api's so there's the case of math get if
that returns null does that mean the
entry is absent or does it mean the
entry was present but its value is null
so you have to you have to do something
else to disambiguate but there also some
things in the especially in concurrent
collections the like map dot compute
like I mentioned before if if your
lambda expression returns null that has
the effect of removing the entry as
opposed to storing a null into the map
and so null is is very important special
case that's useful for AP is in that way
also it's really useful to have nulls
inside the collection as special
sentinels and so it makes you know if
you actually look at what the what
things like hash map the the regular old
java.util hash map has to have a bunch
of special cases in case somebody wants
to store a null in the hash maps because
by default null means there's nothing
there and so so there's special cases
sprinkled throughout the code and it
just just makes things more complicated
in error-prone alright so another
another wrinkle here is that
when you're populating a set arm map it
throws exceptions on duplicate entries
and there's a bit of rationale here I
think I need to move on a little more
quickly but if you have a big table like
this here's an example there's a there's
a duplicate entry in here and I think
either you know most most systems use
last one wins which means that if you
put this if you compile this into your
program you would actually have one
fewer entry than you expected and you'd
have some weird behavior runtime but if
you actually put this into Java 9 and
we'll throw in a legal argument
exception and say that well hey this is
a duplicate entry and so the point here
is that this is a this is a library API
that is modeling collection literals and
so if you have a collection literal that
means you're writing out all the values
and so if you put in duplicates that's
probably an error I'm very sorry about
this I'm running short on time so I have
a bunch of stuff to say about space
efficiency but really the existing I
just want to say very briefly the
existing collections especially things
like hash that are pretty space
inefficient they use lots of objects and
lots of pointers to different objects
and so if you put a couple entries into
a hash set it takes 152 bytes to
represent a hash set with two entries so
the new set implementation is much more
compact so if you have a new immutable
set with two entries it only takes 20
bytes instead of 152 bytes so once again
I will have to skip beyond this there
couple a couple things the design
rationale here I'll post these slides on
on the web so that you can see them and
I'll also be available for for questions
afterwards but I'll just move directly
on to my summary here so the collections
framework is 19 years old and it's it's
old but we're still working on it
there are lots of new enhancements in
Java 8 we saw all those new default
method
that add new functionality to all the
existing collections and then in Java
nine we have our collections convenience
factories that provide new compact
immutable collections and they're much
much more convenient to write and I
encourage you to go to the JDK 9
download page and download JDK 9 it
should be in any recent build and
encourage you to try them out so thank
you I'm sorry I don't think I have time
for questions but I'll be available
afterwards for a conversation thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>