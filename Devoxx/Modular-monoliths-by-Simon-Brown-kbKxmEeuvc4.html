<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Modular monoliths by Simon Brown | Coder Coacher - Coaching Coders</title><meta content="Modular monoliths by Simon Brown - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Modular monoliths by Simon Brown</b></h2><h5 class="post__date">2016-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kbKxmEeuvc4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello good afternoon devoxx we live in
interesting times don't we and I'm not
talking about politics if you look over
the past few years in the software world
we've gone from big design up front to
in some cases no design at all just bad
we've gone from creating lots of
excessive documentation to nothing we've
got this no horn area no estimates thing
which doesn't mean don't do estimates of
course we've got this whole no projects
thing which is the same thing and now
monoliths versus micro-services we pitch
these things as extremes we'll pitch
them against each other monoliths on one
hand we build everything into a single
codebase a single deployable thing we
have tooling to support this we know how
to do this we've been doing this for
years
refactoring simple if we want to make a
single one line code change we have to
read the whole thing
on the other hand we have micro services
you instead of deploying the single
thing you break your thing into lots of
things these things can be built in
different languages they can have
technology agnostic interfaces we can
scale these things easily gives us a lot
of agility we can do polyglot
programming and persistence but there's
a lot of complexity here especially
around the operational and you know
monitoring type concerns the hidden
assumption of the whole monolith thing
of course is that they're evil one lists
of horrible big balls of mud and I'm
here to tell you that that's not the
case and I've been saying this for years
there's nothing new here essentially I
wrote tweet about this while back I keep
saying this if people can't build one
list properly mic services won't help
244 retweets
it's quite proud of that up class by the
architect Clippy I see you have a poorly
structured monolith would you like me to
convert it into a poorly structured set
of microservices no thank you
4031 retweets what how do we up class
the architect Clippy who I'm not going
to talk about this slide so that's kind
of second scene I live in to these
Jersey and Channel Islands sorry the
echos really worth it
so those shows you on the map can you
see Jersey not really even on this
gigantic screen if we pinch the zoom in
get to be closer pinch one more time
there we go this Jersey so it's a small
islands and I'm asked by five population
about hundred thousand people I'm the
author of these two books here so
software architecture for developers and
this is really about making architecture
much more accessible to us the software
developers I'm also the creator of this
thing here called structure Iser and
structure Iser is some web-based tooling
that lets you visualize document and
explore your software architecture in
essence if you like web sequence
diagrams plant UML it's a way to create
architecture diagrams and models as code
the reason I like visualization and
diagramming is that if you have a good
well-structured
software system a good well structured
code base you can visualize it really
really easily imagine you have a big
Java system it's a million lines of code
may be broken up into 100,000 classes
and let's say you give me your codebase
and you want me to draw you some
diagrams to visualize that codebase
well what I'm not going to do is draw
you 100,000 small boxes you know one per
class that's just a ridiculous thing to
do so I'm going to use its abstractions
instead and abstractions essentially you
know it's about grouping smaller things
together into bigger things we don't
call
these things things we call the modules
component services subsystems layers and
infractions allow us to reason about
large or complex code bases it's about
reducing the cognitive load essentially
and this is great because it allows us
to describe a software system using a
small number of things but the caveat
here of course is that these
abstractions need to reflect the code
and often they don't I go and visit
organizations around the world and they
show me these beautiful looking
architecture diagrams and then I say
that's that's lovely now showing me the
code and the codes totally different are
the two things never match this happens
a lot when the big forms we have here as
an industry is that even now in 2016 we
don't have a common vocabulary so we
don't have a standard ubiquitous
language to describe software and
specifically static structure we think
we do but we don't we often use words
like module and component and they're
very vague and very fluffy let's imagine
we're building the world's most boring
web app it's a web app talking to a
database this is what we do this is kind
of what we do in your area if you go
look up the words component in the
dictionary it literally means part of
for some of us the web app is our
component of the entire system and for
other people
components live inside the web app so
that's one of the big problems we have
here and the way I solve this is by
creating a very very simple hierarchy of
static structural building blocks that
we can use that to then describe the
static structure of our software for me
a software system is made up of a number
of containers a container is something
that simply runs your code executes your
code or stores will host your data in
real terms is something like
JavaScript app a server-side web app
spring MVC for example a console app
database schema a file system whatever
if we look inside those containers for
me they are made up of components so I
want to use the word component to mean
something running inside a container
it's a grouping of related functionality
behind a nice clean interface and
because I mostly deal with Java my
components are made up from classes and
we're done so this is a really nice
simple way to think about the hierarchy
the static structure the building blocks
once you have this sort of thing in mind
and you might have to take this and
tweak it to fit the language that you're
using you know functional JavaScript
whatever you can then draw some diagrams
and this is what I call my c4 model
context containers components in classes
essentially what I want to do is create
a set of diagrams that are maps on top
the code base where we can zoom in and
out at different levels just to give you
a really quick example here
whenever you fetch Jersey 2008 I created
the site called tech tribes it's a
content aggregator for the local tech
industry in this local people businesses
blog posts tweets events jobs and so on
that's the context diagram for tech
types the Box in the middle with the
monkey that's my thing that's the thing
I built this diagram shows people and it
shows external system dependencies we
select it we pinch to zoom in we get to
level two so this is the container
diagram for the tech tribe system and
all I've done is I've expanded out that
monkey box and it shows you there's a
spring MVC web app at the top there's a
standalone console app at the bottom and
a bunch of databases in the middle we
select this standalone console app the
thing that reaches out to the outside
world and pulls data back we select it
we pinch to zoom in we get two
components so this diagram showing you
the components inside that console app
essentially there's a spring schedule
task lurking in the middle gets kicked
every 15 minutes it uses a bunch of
connectors at the bottom they call out
to the
world and there are some other
components at the top that pushed data
into the data stores my sequel Mongo or
the file system there's a tweet
component the tweet component is a
really boring basic crud component and
all it does is it throws tweets into a
Mongo datastore and allows you to get
them back out again that's it so we
select it we pinch to zoom in and then
we can see the implementation details of
that component oh the sharp-eyed amongst
you might have realized something's gone
wrong here on the previous diagram I
said there was a tweet component there
is no tweet component on this picture
the initial implementation of detect
tribes application was a layered
architecture it was a fairly standard
typical layered architecture web staff
business logic staff data access stuff
and that's what this diagram is showing
it so it's a class diagram I'm showing
you that there was a service layer there
was a service package with a bunch of
stuff in it and there was a data access
package or layer and nothing on this
diagram says tweet component so where's
the component it's gone
well my diagram I have this nice chunky
abstraction called a tweet component and
when you look at my code I've lied to
you it's totally disappeared and of
course you might say well it does really
exist so you know it's a combination of
these interfaces and classes operating
across a layered architecture so it
consists conceptually yeah but it
doesn't exist in the real world does it
I've basically made something up and
I've lied to you I've told you a
different story and that comes back to
this thing you know you have a bunch of
diagrams that's showing things like
components and then you open up the code
and they never quite match George
Fairbanks has written a fantastic book
about software architecture
it's called just enough software
architecture and he calls this the model
code gap essentially we have a model of
our system it's a high-level model we
use terms like component module
subsystem layer to describe the
architecture but we don't have these
same concepts and constructs in the
languages that we use to write programs
so I'm guessing a bunch of your Java
developers here given we're at a Java
conference mostly in Java is there a
layer keyword no is there a component
keyword no same thing we what we do when
we're creating things like layers and
components is we're grouping together
interfaces and classes inside packages
that's typically what we do mccain java
9 hopefully we'll get modules in our
have modules but you know typically
we're we're creating things like layers
by using the basic constructs we have in
our languages so the two worlds don't
match this is not an EPROM of course i
found a paper from the the 90s and even
in the first two opening paragraphs it
basically says the same thing ask an
engineer to draw you a picture of the
system they're working on you get a nice
high level picture reverse engineer a
diagram from the code and you get a very
low-level but accurate diagram but it's
totally different to the one that the
engineer draws it's two very different
ways and models to think about the same
thing so although we often think and
have architected discussions in terms of
stuff like components we're not using
these things and languages we're using
classes and interfaces and namespaces
and packages and a lot of time we're
still doing this layered architecture
thing so let's imagine we're building a
web app we're gonna have some sort of
controller layer with web app stuff
we're gonna have some sort of business
logic layer and we'll have some sort of
data access layer
this is a fairly traditional typical
pattern and I cease I still see this a
lot why do we do this well the books
tell us to here's a picture I stole from
a spring book the basis says if you're
writing a spring web app do this it has
a bunch of layers you turn the page
tells you why substitutability testing
separation concerns blah blah blah you
downloads sample code off the off github
it's already created that layer
structure for you you go to stack
overflow I'm building in Java system how
do i structure my codebase somebody goes
our there's a maven archetype that can
do your layered architecture for you
okay same in the.net world ruby whatever
so we've been pushed and encouraged to
create these layered architectures now
this is often what we call packaged by
layer in the Java world so we take our
code and we package it in a horizontal
layering strategy and this is normally a
strictly layered approach so our
controllers should only call our
services and our services should only
call our data access objects and this
makes perfect sense of course in order
to do this in Java what we normally do
is each of these red boxes is a package
that's how most people do this in order
to call something in a different package
you have to start making lots of your
code public and since or once you have
lots of code that's public there's
actually nothing stopping you calling
from your controller writes down to your
data access thing you know bypassing the
service and that's why although we start
off with this architecture and it's all
nice and everybody's happy over time
without checking and discipline you get
a mess and this is ultimately what
happens to layered architectures if
there
left unchecked and of course the tooling
doesn't necessarily help here there are
some tools you can plug into your build
process that do things like architect to
a violation checking and and those sorts
of things but I don't see many people
using them you might be thinking or this
layer stuff is like 10 years ago we
don't do layers we do ports and adapters
or hexagons or clean architectures that
may be so but guess what these are just
layered architectures too I'll prove
this to you shortly
should we consider layers as evil and
harmful I think that's a big stream
especially for you know just after lunch
on day one of a conference but I think
we have the wrong idea of layers and
software if you look at something like
the OSI and network stack with the 7
layers each layer builds on top of the
layer underneath and provides additional
abstraction in in the software worlds
our layers are something different
so our UI is not a more abstract version
of our database for example there's a
great talk by Ralph Westville and if you
skipped about 13 minutes in he has a
whole comparison between OSI and the
software stack and he says they're
totally different so we should perhaps
stop thinking about doing layers there's
also something called cargo cult and a
cargo cult is basically doing stuff but
we don't really know why
now blindly applying something without
really understanding the reason behind
it and perhaps layering is another cargo
cult maybe that's a better way to think
about this now we're just blindly
adopting this layering approach to our
code but we're not quite sure why maybe
layers are important but maybe something
else is more important
maybe the layers are just an
implementation detail of a bigger
construct and maybe it's that bigger
construct that we need to understand and
figure out and discover there's a great
blog post by uncle Bob Martin a while
back called screaming
architecture and he says if you look at
most code bases especially Web Apps if
you look at most code bases they all
look eerily the same because mostly the
top-level organizational structure is
around horizontal layer or technology
web stuff business stuff data stuff and
he says this is different from the
building world if you look at the
blueprints for a library it screams this
is a library given that various spaces
and things like wires with houses and
hospitals and schools so maybe our code
base needs to scream something more
about the domain we working Marta fowler
wrote a post on is blinky called
presentation domain data layering and he
says this layered architecture thing is
a good starting point it's very simple
a lot of the tooling is set up to help
us do this however once you start to get
any significant size or complexity in
your application you need to start
modularizing inside the layers one
example he gives is is what's typically
referred to as packaged by feature so
instead of doing the horizontal layering
you do vertical layering the vertical
layering is typically based around a DDD
aggregate roots or domain concept or a
feature set something like this so this
is another way to organize your code
essentially have the controller the
service the data axis stuff sitting in
the same package so now when you look at
the top-level organizational structure
of your code base you can see domain
concepts and features this is nice but
it doesn't necessarily solve any
problems because if you have feature set
a and feature set B and they're nice and
decoupled and isolated and then feature
set C comes along and it needs something
from a well now you need to make
something in any public again and the
big ball of mud ensues
George Fairbanks the rescue George is my
hero he says what we should use is an
architectural e evident coding style
it's a great way to minimize and
hopefully eliminate that model code gap
an architectural evident coding style is
essentially dropping hints and metadata
into your code so that your code
reflects your architectural ideas and
intent that sounds very grandiose in
real terms it's something like let's use
naming conventions so we have a box on
our diagram its names logging components
let's make sure we can see a locking
component thing named in the code maybe
it's about name spacing and packaging
conventions maybe there's one namespace
or package per component maybe it's
about adding machine readable metadata
you know annotating your components with
an ax component annotation things like
Java modules Osei modules maven modules
again maybe there's a module boundary
that corresponds to a box on the diagram
for example the way that I organize my
code is is using a technique I call
package by component and what I really
want to do essentially this is a poor
person's Java 9 module system given what
we have today and what I'm doing is I'm
putting each component in its own
separate Java package so I treat my web
stuff as a separate component and I
bundle together the service and the
repository the data access logic into a
component it's a really simple
refactoring so if I go back to my tweet
service example the class trimer on the
left is what I had before
so there was a tweet service interface
and they really horribly names default
tweet service implementation class
that's used or dependent on a tweet data
access object interface with and as a
Mongo implementation so what I've done
is I've taken my tweet service rehouse
dip in a different package
and I've renamed it to be tweets
component so now it matches that box I
had on my diagram we're all good so far
default sweet terraces horribly horribly
names I do apologize so what I did is I
refactored it and I renamed it to
something even better of course now it's
called tweets component imple okay
that's not an improvement as far as
naming goes however what I've done is
I've made it package protected but no
one else can see it it's an internal
component implementation detail so who
cares what's called the tweet Dao I
delete it I'm going to come back to that
later because there's a bit of
controversy around that and the mungo
implementation I just shipped over as is
and I've also made that package
protected so essentially what I have
here is a public interface and some
package protected component
implementation details so now if you
want access to my a list of tweets you
have to go through that tweet component
interface you can't cheat and go
straight to the Dao you can't go
straight to database but please don't do
that so we have a way to start enforcing
some architectural integrity here from a
code perspective this is what it looks
like I have a component super package
everything underneath that is two
separate components you can see here on
the left those are all of the files
including the spring config associated
with that individual component and I've
also added an @ component annotation the
add component annotation has nothing to
do with this talk whatsoever however if
you go and find these things you can
draw a diagram something real easy and
that's what structure Iser does
essentially so now going back to our
component diagram we have our tweets
components at the top we select it we
highlight it we pinch zoom in array so
now we have arts cleaner progression
from you know these coarse high level
abstractions down into the code what I'm
trying to do here is really introduce or
reintroduce modularity as a thing
think about a principle let's get people
thinking about building nice neat
modular in this case monolithic
applications one of the things mike
services does really well is introduced
a set of impermeable boundaries via the
network of course you have a bunch of
code it's sitting behind at a remote
eval interface if you want to use that
micro service you have to go through the
remote interface you can't see inside oh
I'm trying to do the same thing with
java in a world where we don't quite
have java nine modules yet in order to
do this you need to make some design
decisions and you have to start asking
people well how do you actually design
software if you want ten minutes of
entertainment grab a coffee and go and
ask your team how they design software
it's brilliant
nobody can answer this question it
normally starts out with things like we
take requirements and we create a design
right how do you do that well we do it
at a whiteboard right what are using the
whiteboard for we're drawing pictures
what are you drawing pictures of our
design yes exactly what are you drawing
on the whiteboard boxes and arrows what
do the boxes represent components see
slides fifteen minutes ago
how did you decide to draw three
components and not two
I'm using my experience what none of
this makes any sense and eventually gets
point where I say look what's your
decomposition strategy
how are you taking the problem space and
decomposing it into smaller things and
they're like I know we're using my
experience again it's like just go look
it up on Wikipedia for goodness sake
but there's a whole Wikipedia page on
decomposition paradigms zero DDD
functional decomposition volatility
driven decomposition there are lots of
ways to decompose a thing into smaller
things and sometimes this amazes people
it's like yeah this is a computer
science concept just go look it up in
the 70s
one of the classic papers on the
criteria to be used in decomposing
systems into modules and he takes a the
same application and decomposes it two
ways and the trade-offs and the benefits
of the two different approaches that are
enormous and again that's what I want to
get people thinking about one of the
nice things I actually think Mike
services has done is its reintroduced us
as an industry to design and
specifically stuff like decomposition so
we have our module monolith how do these
components interact inside our
monolithic codebase again you've got
options it doesn't all have to be
synchronous method calls you could do
stuff synchronously or asynchronously
you could throw a local message event
bus thing in there or we could throw
messages out to a proper you know
distributed messaging system you can
throw events around your monolithic
application all of these are design
choices that you get to make where'd you
put your domain classes do you put your
domain classes inside your component
boundaries that's one approach or do you
have like a big bag of domain stuff the
all your components share again why not
again there are trade-offs with each of
these approaches and you get to choose
you try out and refactor if it doesn't
work shared code and utils it's the same
with the micro versus world do we share
code across our micro services or do we
copy/paste do we do a you know open
sores github style thing where people
pull whichever version of some shared
code they need again entirely up to you
you get to choose and this doesn't stop
at the code normally it's the database
and the data model that is that horrible
big ball of mud it's normally that's
that's really really hard to untangle
and again just because all of your code
is in a single monolithic jar app it
doesn't mean you can't use polyglot
persistence why not
source stuff in Mongo here my sequel
here cuz
under here why not again it's all
decisions and these need to be conscious
decisions not just we're doing stuff
because we think we should you know
we've always built a gigantic java
system running against an even more
gigantic Oracle database and that's the
way we do things here right stop that
start thinking the devil here is
definitely in the implementation details
right so I'm gonna I'm gonna blow some
UML at you so there are four UML class
diagrams here and these represents
different architectural approaches to
structure code in a web app for example
so let's imagine we're building a web
app and it's doing something with
customers on the very left is what we
might typically see in a layered a
traditional layered architecture there's
a customer controller doing web stuff
there's a customer service doing some
business logic and there's a customer
Dao almost a fairly traditional fairly
simple the next one along is what you
typically might see with a ports and
adapters or hexagonal style of
architecture for those who don't know
what our ports are adapters architecture
is basically there's an inside and an
outside the inside is where all of the
business and domain logic sits the
outside is your interface to the
technology world the box in the center
containing the customer service customer
service imple and customer repository we
can argue about naming that's the inside
that's the business part and the top and
bottom are the web and the data access
the third one that's what you might see
with a package by feature approach so we
have a single Java package all of the
customer stuff sits inside it easy the
one on the on the right is what I do
what I call package by component so my
customer controller is a separate
component and all of the other customers
is a separate component when I was
putting this talk together and following
some feedback from previous editions of
this talk I really tried hard to find a
good canonical example of a port and
adapters architecture on the Internet
and it couldn't find one and this really
surprised me and what I see with most
ports and adapters architectures is that
all of the Java classes all of the Java
types are made public go read the books
go looking github you'll find the same
thing people don't care too much about
using the Java access modifiers and they
just write all their code as public I
can see some people smiling in the
audience now this is obviously ringing
some bells the thing here of course is
it's all if all of your Java types are
public there's absolutely no use in
using packages packages are designed to
give you some sort of encapsulation if
you're not using the access modifiers
there is no encapsulation essentially
you're just using packages as an
organizational structure like folders
this has some interesting implications
so here's a really neat trick if we if I
show you that diagram again and I take
away all of the package boundaries
because they don't matter because in
this case let's imagine all the types of
public we get this I felt the intake of
air then all of the diagrams are exactly
the same so if you make all of the type
public or all of the types public
there's actually no difference between
these architectural styles you have to
shift the boxes around to line them up
but there's no semantic difference Oh
huh so although we like to think of
these as conceptually different
architectural styles if we abuse Jarvis
access modifiers and make everything
public they're all just exactly the same
so that's why ER and this explains why
most ports and adapters architectures
just look like glorified layers
essentially however Javas packages
although not perfect have some use and
if we bring back the packages and we
start to fade out with the use of color
the Java types that can be made more
restrictive package protected in this
case we get a very interesting picture
so you have to work this through your
mind with the layered architecture
example because our controller depends
on the customer service interface the
implementation class can be made
packaged protected that the caveat here
is you need to be able to instantiate
one of those things and the iframe works
like spring will quite happily in Senshi
eight non-public classes and not sure if
that's good or bad but I like it
same with the dao with the ports and
actors model it's exactly the same
you can make your JDBC customer a
repository implementation
package protected provided you can
provide an instance of it and the
service implementation again depends on
the repository interface with the
package by feature approach you do need
an entry point into that package
somewhere about frameworks force you to
be public some not so much
but then everything inside that package
can be made package protected the caveat
here of course is if you need to access
that customer business logic from
outside the package you need to start
making soft public again which is why I
prefer my option on the right here so my
customer controller that's my public
entry point there's nothing else there
and I have a single interface my
customer component so again that's quite
interesting
applying java success modifiers allowed
to do some very interesting things here
testing right so this talks about to get
a little bit more controversial than it
already has has anybody seen this if
you've not seen this you should I highly
recommend it you won't agree with a lot
of it most of it if I'm honest however
there's some really really good nuggets
in here and one of them is you know if
we look back 10 or 15 years we did lots
of mocking of stuff so we're writing the
code against our database we want to
write unit tests against our database
well that's slow so what we do is who
are mock out our database and now our
tests run faster right if we fast
forward to 2016 I've got a macbook
retina here 16 gig of ram nice fast disk
we have docker and vagrant and i can
spin up a database environment in a
number of seconds a small number of
seconds of that so some of the arguments
we use for doing lots of mocking and
stuff in the past and no longer as
applicable as they were there was lots
of controversy core by this paper DHH
the rails guy jumped on this is when
yeah I totally agree
don't let your test drive your design
and it sounded like on the face of it he
was attacking TDD and I think what he
was really saying here is don't chop
your codebase up into lots of really
tiny parts just to make your codebase
testable I do see this with things like
spring for example because you can
depend everything people do literally
depends inject everything and then have
these millions of things running around
at runtime and it's really hard to
figure out what on earth is going on you
know maybe we need to only dependency
inject the larger chunks we go right to
my tweet example I said I got rid of and
I removed the tweet data
it's a subject interface so the question
becomes how do I unit test my MongoDB
tweet Dao icon but more in more
interestingly how do I unit test my
tweets component in pull without talking
to the database I can't
I've hardwired these two things together
I have no way to produce a substitute
Mongo to a MongoDB tweet Dao here okay
some of the mocking frameworks will let
you do that but it's kind of hard I've
made my life harder now you'll notice I
still have a layered architecture here
by the way so I have a component
boundary and I have layers inside my
component so I can switch out Mongo
really easily but I can't test it in
isolation summit so easily
the simple answer is I don't do unit
testing wait that's it we can move on
now coming back to the cargo cult thing
I wonder if we applied the same
principle to unit testing right we've
just been taught to do lots of Rea
low-level unit testing why why is this a
good idea is it a good idea in my
current code base because I've worked on
systems that have been very integration
heavy and we've literally had like three
unit tests across the entire code base
but we've had lots of automated tests at
a much higher level of abstraction and
I'm going to bring the testing pyramids
triangle thing into play here and this
is the typical traditional advise we do
lots of very fast running low-level unit
tests these cover a large percentage of
our code base this on the face so it
sounds like really really good advice
what is a unit I don't know if I was to
poll everybody here we'd get hundreds of
different versions of what our unit is
for some people a unit is class for
others it's a single method for other
people it's not about static structural
and building blocks it's about behavior
and features so there's no easy
definition of unit but we're basing a
lot of stuff on this definition so let's
forget that if you're really lucky you
might have some integration tests these
are the things that are slow they're
brittle they always fall over the
weekend and you just at ignore them yeah
I've done this as well right what's an
integration test well for some people an
integration test is integrating units oh
great now we're back to this thing again
what is a unit what are we integrating
the more common definition of an
integration test is that we're
integrating with something outside of
our control or something slow like a a
database or the internet or a micro
service or whatever if you're super
lucky you might have some UI functional
acceptance tests and top perhaps
automated so on the face yet this is
really good advice and this gives us
lots of options so if I'm putting some
good component boundaries around say my
server somewhere but I'm my repository
in this case I can test the service in
isolation by mocking out the repository
there are ways we can do that I can
write some integration tests you know
with the repository thing against the
real database or I could just component
test the whole thing through the public
component
interface and that's what I do in my
tweet component so I don't unit test it
but I do have a bunch of automated tests
and they basically spin up an instance
of the tweet component and they use the
public interface and go all the way back
to Mon going back again
and this is good because I own the Mongo
stack Mongo is very fast I can spin up I
can kill it off so because I own the
whole stack this makes a lot of sense in
this situation and what I'm really
trying to say here is instead of blindly
unit testing everything at a very low
level of abstraction
why don't we perhaps think about
shifting our testing focus up a level
now let's figure out if we do have some
structurally significant building blocks
like components why don't we test those
instead a bunch of caveats apply this is
no silver bullet by any means this works
really well if you own the whole stack
so with my tweet component I do earn the
whole stack I own the Mongo schema I can
spin the whole thing up if I'm dealing
with asynchronous behavior then I might
need to start introducing mock points
because that gets a bit tricky if I'm
talking to a third party service over
the Internet
I'm gonna have to sign introducing a
mock point because that's often not
going to work for example so you have to
take this approach and and see if it
works for what you're building I really
don't like that testing triangle I think
the terms are ambiguous and I don't
think it's very helpful what I want to
do is really start aligning the tests we
write with the code we create the shape
is not necessary to important here you
know triangles versus how shapes I want
to get away from the naming as well so
rather than me just using the word unit
test I want to use the word or the term
class tests so my class tests test a
single class at a time you know mocking
out other classes around them this is
typically what we mean by unit tests the
very fast very low-level the very
precise they do a very limited amount of
testing and work so there's my class our
tests if we step up one level in my code
base I have a bunch of larger slightly
slower running
tests and these spin up the components
and test through the public interface if
we step up even further I have some
system level tests that poke my system
from the outside this is your automated
API and you know selenium-webdriver type
tests we might do the same sort of thing
a micro service this world as well
imagine you're building a micro service
in Java you might have a bunch of class
level tests testing it inside the micro
service and you might have a bunch of
service level tests on top testing that
service through its public remote will
interface the reason I've used this
naming is because I think the names of
the tests needs to reflect the
constructs they're testing so that's the
way I think about this I have to be
slightly careful with this next slide
because people will photograph it and
take it out of context so what I want to
do is I want to achieve the maximum
level of code coverage from tests with
the minimum amount of test code there
are extremes of course on the one hand I
could write one absolutely gigantic uber
test from the outside of my system that
tests the entire system from the outside
and that's a horrible horrible idea
on the other side we break our system up
into millions of small things and we
unit tests each of those millions of
small things individually again they're
extremes I think there's a nice happy
balancing point in the middle here
writing component level tests in my
experience gives you a good chunk of
code coverage with actually quite a
small amount of test code it's again can
be at supply it's a sliding scale in
essence I want to link up the
architecture the way we think about and
structure our software systems with the
codes so reducing that model code gap
the code and the test should relate to
each other and the test should relate
back to the architectural constructs and
this is true whether you're doing
monolithic
sorry monolithic modular systems or
Microsoft's it's the same principle
applies it all of these three things
should tally up why is this important
quite simply it's about maintainability
of software and the maintainability of
our software is normally well it has
some weird inverse proportional
relationship with a number of stuff
public classes dependencies or maybe the
number of micro services the more things
we have the harder our system becomes to
understand enhance maintain for me a
good architecture gives you agility
that's one of the things a lot it seems
for kind of aiming for hey let's create
a code base it gives us agility allows
us to move fast react to business change
quickly an agility is another quality
attribute it's another non-functional
requirement when we sauce out with our
blank sheets of paper and we're trying
to figure out do we go micro services or
monolithic or something in-between we
ask ourselves this question how much
utility do we need and we let the degree
of agility guides that decision rather
than just basing it on hype and of
course it's not just extremes there is
something in the middle and that middle
ground is a modular monolith you create
a monolithic application you make sure
it's really really well structured and
motorized and then if there are parts of
that monolithic application that you
think could benefit from being ripped
out and made a micro service well then
you do it and because you've got nice
seams and nice boundaries in your
monolithic code base it's easy to do
again caveat supply your data model
needs to be nice and decoupled as well
but you're creating those nice modular
things you're creating those impermeable
boundaries in your monolithic codebase
you're minimizing the amount of things
that can call inside your component and
for me well-defined in process
components living in a monolith
application is a fantastic stepping
stone to a micro versus architecture if
if the mike rizzo assess architecture
gives you some benefits that you are
looking for polyglot programming being
able to scale it separately version it
separately release it separately and so
on and so on and so on
so what I'm saying here is essentially
choose a micro services approach maybe
in certain areas only if it gives you
benefits otherwise you're just going to
end up with a horrible big distributed
ball of mud and I'd really do not want
that to happen I see so many people who
have this horrible messy codebase and I
think micro services will solve that
problem and to a degree I grant you it
might because you have some impermeable
boundaries you're putting networks in
the way so people can't see inside your
services but it comes down to that
design it comes down to that
decomposition if you get your
decomposition strategy wrong and I'm
sure Sam Newman will say this as well
you're basically just setting yourself
up for failure
so in closing thoughts if your software
system today
is hard to work with or maintain or
enhance it's up to you to change it
right do the architectural refactoring
start putting in some seams and
boundaries and think about how to
motorize your existing code base think
about how to align the software
architecture view of your system with
the code think about Georges Fairbanks
is architect level encoding style think
about potentially dropping some hints
and metadata into your code so that your
code reflects your architectural ideas
you end up with a nice a bunch looking
at a nice bunch of diagrams that reflect
the reality of your codebase what
concrete advice can I give you today
right here right now what advice can I
give you that will start fixing your
stop making every class public right
it's as simple as that in many cases
start using java's access modifiers in a
better way more appropriately
some might say properly when we get to
Java 9 jump on Java 9 and start
minimizing the surface of the things the
modules that you're building you know
it's the separation between public and
published interfaces I can't force you
to do this it's a muscle memory every
time I find myself writing a class if
I'm not using tooling I go public class
are without thinking damn the IDS will
create public classes by default half
the time the Tor other tooling will do
the same thing I don't know how he fix
that problem
I can incentivize you though every time
we do this without thinking you stick a
euro in a charity pot a euro is worth a
lot now believe me we're depends beside
the Bungie loop so yeah start off
thinking about using Java success
modifiers properly and my final closing
thought is basically this if you can't
build a nice well-structured monolithic
application please don't go anywhere
near microservices
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>