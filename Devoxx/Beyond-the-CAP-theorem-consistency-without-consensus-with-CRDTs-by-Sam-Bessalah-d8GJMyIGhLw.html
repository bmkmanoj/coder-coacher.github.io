<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Beyond the CAP theorem, consistency without consensus with CRDTs by Sam Bessalah | Coder Coacher - Coaching Coders</title><meta content="Beyond the CAP theorem, consistency without consensus with CRDTs by Sam Bessalah - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Beyond the CAP theorem, consistency without consensus with CRDTs by Sam Bessalah</b></h2><h5 class="post__date">2015-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/d8GJMyIGhLw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon I hope not to tire it so
so welcome to this talk so my name is
some freelance software engineer I spend
a lot of time working with data
processing tools distributed systems are
more passionate about distributed
systems and actually diving into the
theory of it but yes it's something that
I like so I want to for this conference
to talk about sororities because you
hear about them a lot so I was like yes
let's propose something I wasn't
expecting it to be picked up so I was
surprised so thanks to the CHP so just
so you know careful is torque you have a
lot of buzzwords in it don't use them
just for fun it might sound a little bit
too pedantic so and just for the sake of
knowing it my talk is really buzzword
compliant so you can use whatever I say
here you just like your sound very smart
even if you don't understand anything
just use some of the thing I'm gonna say
so just for your own good so like I said
I usually work like I'm sure many of you
here work we've distributed computing
restricted systems it's usually a really
bad idea if you can avoid them really
avoid them
they're just bringing more problems but
of course the solve a lot of problems as
well and in reality whether we like it
or not we are all building distributed
systems we are all wearing building
api's we also have systems that need to
consume a lot of users we need to scale
them we need to guarantee that our data
is consistent we have to be sure that
everything we're riding has to be
replicated we are going to lose our data
if somehow amazon goes down so we are
working one way or another we start with
something that's small and we end up
having all these disparate systems
that's everything we all know and when
you work with distributed systems unlike
what we tend to think we haven't yet
been able to beat the laws of physics
some vendors might come and say how
database can be
a cup fear and compliant database but
the e in the gray in the CAF theorem
stand for acid so yes I returned to add
some guarantees that actually do not
exist and in disputed computing you have
these fallacies
that you know all of you I'm sure I've
have already heard of that there's
always not a system where the network
don't count on it doesn't matter how
much you say that yes I have diskette
Network bets
I don't know 1 million gigabytes link
that actually guarantees me that
everything I write is gonna arrive
somewhere that's there's always
something that happens and that these
are the kind of thing that you need to
take we need to take into account and
more often than not there are reason
like I said to build these distributed
systems who want to guarantee fruitwood
our architecture is guided by things
that are inherently distributed we want
availability fault tolerance and also
economics we want this rich system
because buying a scallop system that's a
big box is really expensive so we want
to take cheap boxes and add them as
needed so there are reason that we go
with them and sometimes we end up with
these things this nice data basis
depending on what you ha you have one of
this sequel so if you in the seventies
you didn't have it so sometimes we had
new sequel databases and somehow those
no sequel databases they are no yes but
we still have sequel on top of it
doesn't matter which one you choose you
still have distributed databases
disruptive systems at one point or
another but to make them work in those
distributed systems I'm seeing people
picturing everything so yeah with these
distributed systems like I said there
are laws of physics that we can beat you
have also have root theoretical laws
that actually formal demonstrations of
how the system behaves so one of those
field the one of the theory in there I
mean distributed system comes from what
chords with cuts theorem
who knows recap theorem here ok
most all the rumors like a theorem which
is good so the cap theorem usually it's
this you have availability in this which
systems have consistency you have
partition tolerance and it's usually
said that you have to pick two because
you can sacrifice partition table
tolerance but more often than not not
seeing that as being either CP or AP
that actually have a slider that's where
we can tune your consistency between
Volvo correct level so what we call with
availability that all the clients must
at one point find some replica date or
some replicated data we have to
guarantee what guarantee consistency we
have to grant any partition tolerance
and you have different of different kind
of products that you have here
some of them are in the part where they
want to do need to do a trade-off
between availability and consistency so
you have things like MongoDB HBase or
Google BigTable all over systems that
actually want to be highly consistent
but in a partition tolerant way so they
can accept to have some loss of
viability but they want to lose
consistent data that's not what we're
going to talk about in this talk we're
gonna talk about systems are actually
available take the path of being
available sacrifice a little bit of
consistency by using what's called
eventual consistency but in the mean
time actually being able to sustain
partition tolerance especially network
failures so data consistency like I said
we usually go for the descriptive system
we win within our applications because
we want to guarantee some consistency in
our data in our different node in the
way they behave to do that if you using
an acid database well you have all these
laws that have been there that you can
go but in the distributed systems
already like in systems that are ap
available and partition tolerant we tend
to go with different kind of methods one
of them is using consensus systems we'll
see what they look like we use things
like locking services for those who know
zookeeper in the room
and you have some algorithms like I like
to call barbarity the not barbaric just
me making fun of myself because at some
point when you read about them you say
why how come people coming this kind of
crazy ideas but there are ways for that
so in distributed consensus we only do
it to have data consistency what you
usually have in a transactional world
like to be able to come back in an AP
system most of the time I mean almost
all the time you don't have transactions
you have things that look like
transactions but you don't have them but
in other systems you have you want to
have something that look at transactions
to guarantee them what you do you have
things that descripted consensus which
is almost impossible to have especially
in a distributed world because it's
really hard to have to add to do you
have things like multi phase commits
state replication so you have to
replicate your states and guarantee that
these states is working perfectly is in
line like if your States it's not
falling behind it's not going to fly so
yes and you have things that I'm sure
all of you know like to face connect to
face commits that you have in our DBMS
but these are blocking because they want
to guarantee that every applications are
homemade so you don't want to go to down
the road so you block and you have a
coordinator that actually say okay you
can write you can go this way and it
really induce deadlocks when you have
multiple concurrent writes
when using two-phase commit yes at some
points you run into deadlock so you want
to avoid those kind of things and you
have things like free phase commit which
is non-blocking
and like - two-phase commit and three
phase commit which is nice because it's
blocks it doesn't block but one when you
have int when you run into timeout it
aborts the transactions and it works
back your transaction and your operation
but one problem in a distributed context
is that it fails easily when your
network partitions so not suitable for
distributed applications and you come
with algorithms like one known as boxes
when you look when you google paxos you
land on the island of taxes in greece
which looks nice peaceful
and very good but when you read
algorithm instead if it looks like
something like this
you like Wow why such a beautiful place
the name of a beautiful roofless and the
double state machine like that compact
I'm not gonna dive into all these crazy
things so taxes is an algorithm that was
built to actually solve the problem of
consistency in distributed system so
it's a consensus system it was written
by it was first I lost Leslie Lamport
that's one of the gods of this routed
computing or descriptive systems who are
the guy behind vector clogs
but those TLA for those who into this
kind of fence and Bacchus is a very
complex state machine it was too
complicated to implement that the gap
this is the guy who wrote the first
paxos came up with a paper called Paxos
made simple so yeah because it was too
hard for you had to go back and write
something simple for you so yes but this
was so hard and it's still hard to
implement today you have exports and
faxes to go to go down this world and
most of your packs was library that you
have that are very good because people
spend a lot of time writing them so when
cut when someone comes up to you and say
oh yes I've started writing packs of
last night I think I'm gonna be done
tomorrow say really fun and Baxter's was
still too hard that people came up with
things like an understandable consensus
algorithm so yeah that says a lot about
versus the complexity of this kind of
thing which this is the new thing that
that's being used today in many systems
like kudu that's when you have storage
system we have an even in react in
fluids DB the user consistent system
this system is called raft which is
simplified but not damaged simplify but
and understand the volaterrae consensus
algorithm so yes and you have other
services who knows the zookeeper here
who uses zookeeper who loves the
zookeeper no Barracks hell or a surprise
why because ooh keeper is something
that's used in all the big data world I
mean it does a lot of things but one
thing that was built first is to do
locking it's a locking service so it
helps you
right do consistent operation into in
your data in your in your system
zookeeper was actually wasn't also
actually something that came out of
nowhere it came out a Google published
paper called Chevy that's the internal
that's internal locking system and that
paper gave it and the guys from Yahoo
wanted to implement something different
so they brought they took one of the
product they were inspired by the
protocol from Google called Chevy and
started and put another protocol called
Zab that protocol sab is what inside the
zookeeper today so it's all the places
zookeeper everybody uses the keeper if
you like it or not at some point you end
up with this valley we're using Kafka
using missiles I don't know what ever
Big Data thing that you have you want to
do service discovery the only problem
with zookeeper that leaders too many
things the one thing this is very well
did or election locking service it's a
bit of a pain to manage but it does that
very well that's zookeeper let's go back
to this thing with the calf theorem so
we have like I said availability
consistency we seen zookeeper Paxos is
kind of thing but there are also over
terms that you have to go with in
distributed computing when you have when
you are in a distributed system usually
you hear things like strongly
serializable applications so usually
when it comes I'm not gonna dive into
all this thing I don't remember even
half of them but just remember usually
when you see a linearize ability and
serial as serialize ability linear
stability meaning that each operation
has to be somewhat instantaneous so when
you're doing write or read you actually
most rhythm ending having them to be
sequential
that's what you have waving zookeeper or
something like that and so as ability
that's when you're dealing with multiple
operation multiple output so you want to
guarantee some kind of or consensus
between those kind of operation so that
and within those systems you have over
kind of consistency level that do goes
them you have read Reaper read committed
you have a whole lot of papers to read
if you want to understand all of these
things so just bear with me let's stay
on the high level
and let's let's keep going but like I
said we've seen zookeeper we've seen all
these things and all the different level
different level of consistency of of
course instance levels will different us
literally nurse abilities to face
commitment forfeit I mean those are a
lot of things but at the end of the day
which we trying to do one way or another
is actually thinking about how our
different nodes in our system are
behaving if my load is dead what am I
gonna do
is it gonna take right is it gonna take
great but in reality when we want to
deal with data the consistency of my
data is not something that should be
fought off at the node level so what you
trying to do is actually think about
this at the data layer so it's your data
if you think about data you think about
what data structures so that's what
we're trying to do here yeah yeah this
this was okay so less than last night so
he had this is what this was supposed to
be the first line okay looks like I want
to do it too fast
yeah so this is a desire venture system
this is why we want eventual consistency
we talked about this
yes I'm not seeing the mirror here
because I have to sweet you have just to
move my mom I think so yes before we
dive into all the problem like I said
most of our data we're thinking about
our data our consistency not the way
would not behave with our our data level
let's look up some AP systems we cannot
see what are what we usually call
dynamic systems like Cassandra and the
react our Voldemort
those are system that were built
actually using the Amazon dynamo paper
so usually what you have you have the ha
they are actually peer-to-peer system so
all the system maintains some kind of
replication of the data they're not
synchronized between them so they give
you the nice properties like high
availability they make a trade-off
between having high availability and
consistency so they're eventually but
they want to build something that we
call eventual cost
so let's say we have a right to one note
for example in in this ring this is the
first rights and we have three let's
return let's write somewhere else at B
and B wants to write concurrently at
vina note that contains the value free
which word is gonna be taken which one's
gonna be right we can use value its
value on free are we going to read at
the end at a tree on which one is gonna
be correct well you have this one way to
manage this so you need to mean you need
to manage this conflict you have
conflict resolution and you have many
ways to do that so one of the way is
what we call semantic resolution meaning
let's say for example I have a shopping
cart
like that's the standard way to think
about it so here our shopping cart added
one element I've removed it but I'm
adding another one but since my system
is not atomic what value do I have in my
shopping cart
well that's semantics relative
resolutions gonna tell you well use your
business logic if you want your customer
not pay more well you give them the last
one to remove the last version that you
removed and I'm gonna take that one if I
can afford to actually add another thing
to my custom of it to to my customer
basket and then I'm gonna resolve that
so you let the application the business
rules actually decide what's gonna be
right for you another way is vector
clocks vector clocks actually maintain
vector clocks and last word in vector
clocks are on the right here Delta
clocks actually maintain a version of
each operation so you have a vector when
you write you have a merge operation and
can do some kind of reconciliation to
have the correct value you have another
thing that's usually having like in
Cassandra which is last write win last
fight win meaning that will last value
that have written is the one diamond
turned out that I'm going to consider
but when you do that for example you
have two rights over there writing a you
have written B you have a B and have a C
coming over there since the lasts right
is winning while the B has is gone I'm
not
to be why you've lost it I will have
lost some consistency so these are
trade-off that you make depending your
application can afford to do this kind
of these kind of things
sometimes you can't afford to do that
and this is the problem that sororities
try to reserve so what are CR it is they
called conflict-free replicated data
types
that's the name of the oddity meaning
that you try to do operation on your
data types without conflict where ever
the convergent or commutative we'll see
how the work afterward and those two
oddities actually come from award coming
of Herkimer actually branch out of a lot
of the research was in inria in Paris
and in some universities around the
world and they have become quite popular
so now you can see them in many that
astrologist Atascosa applications as
well so this is the paper that actually
describe what's the oddity a high is
it's something like a 50 P 50 pages
paper so it's a bit hard to dive into
them because have these formality
notations you have these algorithms and
we're not going to dive into all of them
but actually see a few of them you can
see how the works and how we can
application so like I said we take
consistency with your disease not to
Vinod liver but to data structures so
that's what we care about and the good
thing with the oddity is that their
states converges always end up having a
result the result that an outcome that
is expected at one point to a single
current value that what we have and it
doesn't mean they don't need to have is
an external system to actually guarantee
that the state is converging to
guarantee their consistency so you don't
need taxes you don't need a locking
service an overhead as well we just have
data structures that in our own state
actually maintain different operation to
converge to a current value and one
thing about reality is that they are
monotonic meaning that every operation
that you are that you add that you have
actually adds information that's taken
into account to guarantee a current
value of afterwards and your data is not
immediately destroyed which can be a
drawback we see afterward but that's
what you're trying to do and most of the
thing actually are really transplant of
application you don't have application
doesn't need to know the details of the
implementation usually like you will see
with react of Cassandra most of the time
you have C oddity but nobody knows they
actually see what it is we think that
they are doing some fancy feeling waiver
with consensus algorithm system out
there but the actually solid is doing
the work you have to type of C oddities
you have those called state-based C
oddities
they are called convergence oddities and
you have operation base C oddities we're
not gonna dive in too much into the
operation based C oddities we're gonna
stay a bit high level and see some of
this dip is also at it is there so what
our convergence
sure it is the properties I mean all the
replicas I mean you have your data so
like in the ring with Cassandra or react
you write to some you write you dated
some replicas their state is replicated
all over the place to some replicate and
those verticals are connected between
all the between each other otherwise you
don't know because the oddities use
Gosset mechanism to actually broadcast
either the state or sender operations so
your replicas have to be connected at
some at some point and usually in
covered in convergence the oddities
what you have is that they have it and
at least once semantics so they don't
guarantee that you have uniqueness
between your operational in your dinner
state already de but at least they
usually guarantee that you have written
at least once you think within this
reality and the state is actually since
its cover so the state is actually going
in a linear way so they are big moving
up for delay to following something that
looks like a partial order in
commutative you are details
well the same thing apply have all your
application all your pikas has to be
connected but since in commutative she
are the TV not broadcasting your states
will actually your operation you don't
want to lose the operation that you
added that you've sent so you need to
enforce having a reliable not
necessarily network but a way to
broadcast reliably your operation
that's a bit of a program sometimes but
it's very important if you just
broadcast in your States it doesn't
matter because since your data at some
point is replicated you still hold you
can still always find very that before
but when you broadcasting actually
operation yeah it can be a bit tricky at
one point and this is very good when you
have a portion of our in a Huntley
committed we see why so let's dive into
fancy words now and now you can feel
smart so this is the real definition of
see oddities now just say what has said
it is who knows what a monad is why a
monad is a what is a functor in the
category of under functors right nobody
knows the joke well that's the more
that's here it is of the same thing
there are idempotent commutative monoid
good now you know it's all the thing you
have to know sure it is no light
that's the fancy that'sthat's one of the
sensors we can play with them what this
means
idempotent commutative monoid it's also
called adjoint semi-lattice
so yes fancy words but they actually
mean the same friend what is a mano it's
something that has a neutral element and
is associative it has an associative
operation committed cetera you know all
of them idempotent meaning that an
operation which is serve with one
element gives that same element again
that's called also it joints in my
lattice we'll see why these what a joint
simulator look like an operation of
itself gives itself it's cumulative it's
associative as well why do we need these
things well let's look at a convergence
ERD T what you actually doing is that
since you broadcasting all your states
at some point you need a merge operation
at one point if you're broadcasting
yourself several times you don't want to
have duplicates so your mode operation
has to be idempotent so you're giving
yourself it's associative so you can do
this for order this tomorrow
it's committed you can it's commutative
so the order is Amara it's associative
then you can do that the field the way
you want you can do start with each
replica at some point state is going to
converge associativity when distributed
comes
King brings parallelism or computer and
it helps you do this kind of things you
have the same thing here with
convergence EDT this is the state you
have a source X 1 X 2 X 1 X 2 X 3 bills
are replicas this is a vector clock and
you have this rules you have all the
changes that happens on every replica a
broadcasting operation and at some point
have to merge with the local state
that's what's your duty does this is a
converging security this our operation
that our max that our max operation and
added and an addition those are
operational are actually see my latest
our monoids so we can do this kind of a
person between them so you have a lot of
sororities in the paper we have many
many c oddities but we're not going to
dive into all of them because that gonna
be a little bit exhaustive and some how
we use this because it's better to
actually dive into the paper with the
tape of this demonstrate with the proofs
and see how they work but we're gonna
see a few of them so remember i talked
about last white winner
Weaver with Cassandra or in Dynamo
system well last white green actually is
a register itself because it has emerged
operation I'll bet you losing some data
before but it still is your duty that
converges to a state you can actually
make sure that you have a vector clocks
when you're losing the data so you have
to convert a little bit in in a smarter
way afterwards but this is something
that you can do and we have counters
p-sets graph and maps we're gonna see
counters and some kind of sets because
all of these graphs and maps are a bit
complicated and they might require no
decision to do all of them but let's
look at G counter edge akhantar is
actually a control that you can only add
element doesn't do anything you can't
remove we going to grow on the counter
so how it works you have replicas one
two three you maintain a vector for each
element when you do operation you
broadcast your state to one replicas you
do the same thing for all the other
replicas and at some point you keep
adding so it's actually easy you're just
adding a demand by the merger about when
you merge where you add enough for how
much
in addition so you always have a coke
instead that's properly having upwards
but it's really limited what can you do
with something that you can only add at
a much it's immutable what's fine but
how can you read an application like
that you want to have something that you
can remove element as well so you can do
operation you can do this many kind of
operation to do analytics this is what's
called ap encounter the p encounter is a
positive and negative counter so to do
that well you maintain two G counters
one that you can only add positive
elements so you increments and another
one you decrement so you have a negative
and a positive you do the operation at
the end of the day you have a difference
and you have the proper results so if
you do in plus one plus one plus one you
maintain different operation on all kind
of states and that you can do at the end
of the day they going to converge this
is a high-level view of P encounters yes
and yes the result is the difference at
the end every day
so sex sets is an interesting thing sets
are a bit of a problem when it comes to
C or D T's because they're hard to build
stuff on top of the hard to build
because set has elements are unique that
guarantee this kind of things but the
good thing with them is that you can
build on top of sets you can build maps
graphs just using assets so if you can
have AC oddity that's that's built as I
said well you can do a lot of things
with them let's take a simple set a grow
on leaf set just like BG counter you
have a G set that you can only grow you
only have one operation it's adding an
element and the states like we've seen
with the with the Jack diagram before
it's going to converge to having a set
with the proper elements that's nice but
I want collection where I can remove
elements how do I do that well like with
P encounters I'm going to have the
ignore kind of so that's called
two-phase sets why well they used to
Jesus as well one to add elements
another one to remove elements but
there's a trick in the middle
is that you can't add already removed
elements to do that you see if you have
added an element you removed it well you
can add anymore how does it do that well
it maintains something called a
tombstone state items instead a
tombstone is actually when you've
deleted an element you haven't deleted
really you actually have added it to a
node to a set let's say okay this
element is deleted I'm not gonna remove
it for those who use Cassandra you know
that because you have tombstone and
tombstone has half timeouts that make
them expire and remove from the system's
and this is the same thing that you have
to be set and for two P sets you can
whip over kind of elements if you can
add and remove well you have observed
something some over sets that come on
top of this one of them is called
observed remove set which have the same
thing but while you can actually go into
some kind of atomicity and we've set
like this we can build things like
graphs well with graphs we can do a lot
of things like say Google Docs for
example be doing editing you want to
know okay this person have edited this
kind of thing with this say with this
addition I can do a lot of things those
are graph there are built using sets and
oversee oddities you have a lot of this
and you have one interesting sets that I
want to talk about it is the last right
window last working element sets well
what it does is actually add a time
stamp on your state based operation so
what it does for those who use Cassandra
list so this one's a bit familiar
because Cassandra has a time stamp for
all the operations and the clew of a
greatest time time time stamp mean we
winds because it tells you that that's
the last operation well you can have
them with a set as well and build other
things so you can see this as being
Cassandra columns
Cassandra columns are actually see what
it is and we see there we see a little
bit clearer how so like I said you have
a lot of she oddities I'm not gonna dive
into them you can build maps with sets
as well by mountain keys and set values
in different kind of set maintaining the
operation in more sets while you
actually doing that but it's a bit
comparable
there are ways to actually do that then
we have a lot of libraries if you using
react most of the new react actually
have see oddities embedded in all the
collections Cassandra as well we see how
we can find out so see oddity in white
why are we seeing them
well we doing something called call me
maybe who knows Connie maybe yeah you
have a question okay yes not Carly
Jepsen Rae song just for those who were
trying to find not the song but
something called Jepsen who knows Jepsen
here okay so who knows affair same
people of course so yes what is Jibson
well Jepsen is actually a work that has
started something like two years ago I
think by a guy called called Kyle
Kingsbury you can find him on Twitter by
the name of a4 I used to call him when I
see him every time from the database
layer so he spent a lot of time actually
diving to documentation and actually
testing the good thing that might agree
with him or not is that you can
reproduce some of his results so it's
well documented it's well researched so
it's not the truth the real truth
there's no such thing anyway let's it's
actually a baseline to actually test
something may not agree with him say
okay this doesn't doesn't work with my
with my requirements but it's a useful
work so what it does is actually test
network partition failure in that in
descriptive data stores so for example a
lot of data stores actually failed not
just because they were bad but just
because the were not very well
documented and somehow the database
actually uses and you are using systems
to play with what we call the cap
theorem to actually adapt with this kind
of fence but what you see is that at
some point he tested two systems that we
gonna use now react and Cassandra and
we've react that was something like two
years ago of this has changed since then
but the tests we've react actually
should react losing a lot of data during
network failure so react we were using
vector clocks as we do
they were using they were not using last
flight wings but they were using
verticals and when some kind of network
partition were happening react was
losing data close to 45 to 40 percent of
the data that was coming into react
which is not something that you actually
want to advertise yourself if you said
if you selling react I mean that's a
problem but in react they had something
called C or D T's some collection that
were I think there which were actually
counters there were P encounters they
had operation based strategies as well
they were have the you know the first
actually have maps that were CEO duties
but those were not losing data so you
had something called like strong
eventual consistency built on top of
react but they were not that will
advertise now they have become common so
when you read with react documentation
what you see every time C or it is
here's your atiba but there's a reason
for that because they help you solve
some problem the same goes for Cassandra
Cassandra doesn't say that they have C
oddities but in effect some of the
collections in Cassandra behave like C
oddities gets under contrast for example
do not do look a little bit like
strategies but not much but Cassandra
columns are in fact sororities some of
Cassandra collections sure that they we
can lose the DES within natural
partition the good thing is that now the
test acts come comes with Jepsen bundle
within Cassandra so you can test
yourself but you're not losing data when
you look when you use in Cassandra
collections so it shows exactly where
are see oddities will good things that
we don't really care on where they are
but we can see we can you use them
without actually knowing and the
actually solving real problems but not
just in descriptive data stores there
are another system that I call that's
called Rashi that's built by SoundCloud
so this is some club as a fan out fan
Ignace is the fan out writes like
Twitter that you have when you will read
the song so you have to call multiple
microservices and when you reading have
to call different macro services as well
you have to converge into one coherent
state and they built a data store for
that which is like a time series based
at the store it's not really time series
but yes you have time stamps they could
have built it on top of Cassandra's
of course it would love what but they
chose Redis so basically they have Co
deities the same that that our product
went about or you know or set P
encounters G set C IDT built on top of
Rayleigh so you have distributed radius
radius instances that we would use that
actually console using c oddities and
you can find them these are using
projection at son cloud and on every
level companies these are really
interesting thing and have one set
specific specifically at some cloud
that's actually make you work with Time
series data so it maintained your stage
you can do somewhat worse on that that's
a something they called Roshi sets but
yes it's a nice thing to little to look
at and charities are not just within the
test was like I said but also in
adventures when you do things like in
events or some good as CQRS here that's
something that people talk about this
day CQRS
even so so insecure is basically you
maintain a log of of your data you have
a journal actually and within those
drawer at some point you have to
maintain you have to guarantee that you
are going to do some pad will get
somewhere and you want to have correct
states at one point you have this
framework or this library called
eventuate which is built on top of a cup
of vodka sorry but this library uses
vector clocks for some operation but
they also use see oddities so basically
what you do is that since you have all
you events are already ordered by your
log since you using a log here for
example well you can have a set a
two-piece set that works I mean that
could be set actually go and see that
your data is unique and that converges
into a current state you can have these
treated logs all over the place and
actually use that which is funny because
I'm a big user of Kafka for example
Kafka uses partition that actually loves
themselves but to guarantee the state of
the replica which live replica is the
leader they have to go through Sookie
for together to have the to guarantee to
have a little fun do leaders have to
have a little relation so yes you can do
the same kind of things we using just
these kind of data structures but
see oddities nice but yes then come at a
really stiff cost as well and as you've
seen that we maintain a lot of states
you don't have one version of your data
you have multiple replicas and you have
different version of the data which
brings a huge lot of garbage for those
who have really sensitive to things like
performance sometimes this may come of a
problem now there are ways to work
within that by man by managing correctly
your tombstones sets for example so you
have to evict your data at some point
you have to maintain only some kind of
operation so you're limiting the way
your data is actually used where your
garbage collection is going to work but
it's not something that comes from free
and also you can't easily model
everything as a simulate it's not all
operation can be idempotent not all your
data not all things can actually work
being a model that's never the case
so there are some types some class of
application that you cannot actually
bring in to see your duties and at some
point it brings some strange behavior
where some kind of operations your data
if you have real network failures where
your data is not coming in and coming in
at usual at on bulk and coming in the
end you can't actually predict how how
you see you fail your system is going to
manage failures well this can lead to
some kind of weird behaviour so those
are things they care so you test in
Photoshop not introduction sorry it
tests that for reality it tests that
before you go into production and try to
run something like Jeff's on top of it
induce Network failure and see how it
behaves but that's one point you need
something like that you need a strong
consistency system if you want to
guarantee that yes I mean exteriority is
that's good but at one point you need
some stronger consistent system to
actually guarantee that your system is
going to work properly so we still gonna
rely again to things like facts or
zookeeper or whatever you want but yes
and use them really when you want
availability when you have something
like a coherent eventual consistency and
you want available that's the if
availability is really
portal to your system will use this
that's really good
and not use it for your building
application no that's not good enough
that's a video forum for that you still
have system that actually works so use
them don't do crazy things that I want
to be over build somewhere so please
don't say that was because as you know
please and really like anything any
technology it's not a panacea so use it
with quotients so I didn't want to dive
into into all the sea oddities all the
things so one just to be a little bit
high level I don't know how many of you
but that's what I have so if you have
any question I think there are still a
lot of time she won't talk
thank you questions okay well I guess
we're good you twenty minutes out so
enjoy</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>