<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Advanced Modular Development by Mark Reinhold and Alan Bateman | Coder Coacher - Coaching Coders</title><meta content="Advanced Modular Development by Mark Reinhold and Alan Bateman - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Advanced Modular Development by Mark Reinhold and Alan Bateman</b></h2><h5 class="post__date">2016-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WJHjKMIrbD0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning welcome to advanced modular
development I'm mark Reinhold my
colleague Allen Bateman and I will share
speaking responsibilities for this
session
um quit a few quick poll questions to
start with who who was in introduction
to modular development yesterday okay
good so you've got the you've got the
fundamentals if you did if you weren't
there who saw the keynote segment
yesterday okay so you at least got an
idea of what's happening great how many
people have downloaded and played with
JDK nine early access builds okay that's
a little more than usual how many people
have been really brave and downloaded
the jigsaw specific early access builds
one two okay well that's you you are
brave souls indeed okay so let's get
going here this is the second of three
sessions that we're doing here at devoxx
Belgium this week we did introduction
yesterday this is advanced and then this
afternoon I'll be presenting project
jigsaw under the hood which is kind of a
deep dive into the the science of the
module system you know exactly how
readability and accessibility work to
give us reliable configuration and
strong encapsulation so this talk has
two parts the first part is about
migrating applications and the second
part is about migrating libraries so
it's kind of a dual top-down versus
bottom-up kind of a thing I'll do the
first part and Alan will do the second
so application migration to begin at
heart a typical java application has
three layers at the top you've got your
jar files the bottom is the JDK and in
the middle of this kind of sandwich
thingy is the filling it's a bunch of
jars that you downloaded from the
internet and through in the classpath
tested and they hopefully hopefully seem
to work in partridge jigsaw we've turned
the JDK into modules so you the bottom
layer here is now these these pretty
models in this case we have Java base
and Java logging and Java sequel and
drop xml the benefits of modules are
twofold you get strong encapsulation so
that no one outside of a module can
access its internals and you get
reliable configuration so models know
what they need and there's no need for
you to configure the class path and deal
with all of its in Herald inherent
brittleness if this sounds good you
might be wondering how to turn your
application into modules let's put some
names on these jars like blue ones
to get started let's assume that the
main application is my app dot jar and
it has some helper code in my lib top
jar let's assume further that this cloud
of third-party jars is actually just
three it can be simplified to just
Jackson the jason processing library
jackson comes as three jars the the core
jar data binding and annotations of
course run the application today you
have to ensure that the class path is
set up like this you wouldn't have to
bother with that if my apt jar in my lib
dot jar were actually modules as shown
here turning each jar that you've
already got into a module is a fairly
natural way way to proceed it's not
always possible especially if the jars
have cyclic dependences amongst their
classes but let's assume that that's
okay for now now whenever you see a
module you should ask two questions what
does it require and what does it export
requires is is how we get reliable
configuration and the exports are what
determine strong encapsulation let's ask
these questions for each of our
prospective modules here my app and my
lip one way to find out what a module
might require especially if all you've
got is the jar file is to run jaidev's
on its jar file Jade EPS is a tool in
JDK
and it's actually been updated quite a
bit in JDK 9 it animal analyzes classes
in jar files and finds whatever classes
they refer to in other jar files or in
the JDK itself these are the results of
running Jade EPS on my app jar in my
live jar the classes of my app jar make
use of classes in Jackson quart jar and
Zach Jackson data bind R and of course
also might live jar plus my app dot jar
uses classes from the base module like
object and string and from dropouts
equal my live jar is just the last line
here it only uses classes from base
modules so that's nice and simple with
this knowledge we can write the module
declarations that we need for our two
modules here's the module info Java file
for my Lib all it requires is Java dot
base we don't actually need to write
that of course because the compiler will
insert it for us but it's shown here
just for clarity now Jade EPS can't
realistically help you with exports so
let's say that my lib exports a package
called conduct my app dot Lib dot util
to the my app module that we're going to
make in a moment this is a qualified
export because it's specific about which
other modules can access the package now
let's turn to the module info Java file
for my app it requires my Lib the module
that we just created and Java base and
drop a sequel and of course we know it's
going to use Jackson's so we'd like to
rewrite requires jackson core and
requires jackson data binds but wait a
minute does that mean we have to write
module info files for them too that
would sort of be a pain if only there
was some way for the jackson jar files
to somehow become modules automatically
well indeed there is such a way and
that's called automatic modules if we
had those we can write the module invoke
java file from my app like this we have
a beautiful module graph with my app
depending on my lib in jackson core and
jackson data bind and also on java base
and java sequel
so automatic modules an automatic model
it's a jar file that you just put on the
module path rather than the class path
once you do that you have a real module
you don't have to change the jar file at
all the module name is derived from the
jar file name that exports all of its
packages and it requires all other
modules in effect automatic modules mean
that today's jars are tomorrow's modules
without change once automatic models
spring into existence for Jackson core
and data bind and annotations the module
graph looks quite different
the automatic modules basically require
everything they require each other and
all the modules then JDK image and all
of your modules as well the reason for
this is to provide the maximum
compatibility surface for code in jar
files you might think that the module
system could run Jade EPS on the
automatic models that start up and try
to figure out which modules they require
but not only would that be slow but it
in the end wouldn't actually help very
much and the reason for that is that
libraries you find in the filling of the
sandwich if you remember often make use
of core reflection the java.lang reflect
API and they do this to inspect classes
dynamically and this is how frameworks
like Jackson data bind work Jade apps
can see the use of quarry flexion but
because the names of classes reflected
upon are typically computed dynamically
there's no way to determine upfront
which classes will be inspected so this
visitor shows how Jax and data bind is
doing the reflection thing when code in
my app calls the Jackson API it passes
its own class object the intent is that
the Jackson data bind model can create
an instance of my value but this won't
succeed because we never got around to
saying what my app exports because it
doesn't really have an API we didn't
write in exports for it but it needs to
export some packages at runtime anyway
and you know this is a common thing that
you run into when you when you use
frameworks it's quite likely you would
find this in your own application code
the solution for this problem is to
declare my app as an open module with
the open modifier in front of the module
keyword an open module opens all of its
packages in a way that allows a
framework like Jaxon data bind to
reflect over its internals in effect you
get the benefit of reliable reliable
dependencies but without the full power
of strong encapsulation frameworks that
reflect over application code are a
reality and everyday Java development
and they aren't going away it's
important to support them so application
code can't always be strongly
encapsulated we think that the open
modifier is a clear statement about the
nature of this module it's open for
reflection but it's definitely not
exported for compilation without the
open modifier a module is strong it
explicitly defines an API via exports
classes clauses and is not intended to
be deeply reflected upon by frameworks
although you can actually arrange that
on a per package basis if you really
want to
so let's come back to the overall mantra
graph it is pretty messy but it's way
better than when everything was a jar on
a class path for example in the model
graph here there's no arrow from my lib
to my app so there's no danger of code
in my Lib accidently reaching into my
apps internals on the class path code in
my lib jar could access code in my app
table jar quite easily and that's what
causes the maintenance headaches further
down the road if you think about it the
class path is actually pretty insane
with just 10 jar files you get 100
possible ways for code to interact
because the class path is a way for
looking up arbitrary classes regardless
of what jar file contains them in a
sense the class path is the ultimate in
erasure whatever you know about the
structure of your system the class path
throws it away and connects everything
to everything else
this means that conflicting classes and
missing classes and generally slow look
up every time the VM needs a class which
is
well pretty often right with modules
you're telling the compiler and the VM
what you know about the structure of
your system and finally they actually
hear you speaking of the compiler let's
see how to run it we've got the Jackson
jar files in the Lib directory we treat
them as automatic modules by putting
them on the module path with a module
path option we've got the my app and my
lip source in the source directory we
tell Java C about this with a new module
source path option this is required
because there's a new level in the
directory hierarchy for the modules
themselves it goes source / module name
/ module invoke Java and then the
regular old package hierarchy the the
result is class files in the mods
directory we run jar to build my Libby
are based on the classes in mods / my
live then we run jarred to build my app
dock jar from the classes in mods / my
app we also specify the main class with
the main class option because the jar
files have monthly info not class file
files we refer to these as modular jars
you can run your module Erised
application with this very simple
command-line because a module pass and
you tell it the name of the module to
start with all of the information in the
class path in the past is riff from the
past is now wrapped up in the module
info dock class files
remember the explicit models are located
in M Lib and the automatic Jackson
modules are located in the Lib directory
that's why there are two things on that
path so to recap we modularized this
little application with two techniques
first we built modular jar files for our
own code by writing and compiling module
info dot Java files second we created
automatic modules for third party code
simply by putting their jar files on the
class path without touching them if you
like you can think of this as top-down
migration which probably makes you
wonder is there also bottom-up migration
well indeed
there is to answer that question
here is Alan right thank you
library migration so for this part of
the presentation you can just forget
most of what Mark said for the last ten
minutes because we're going to start at
the bottom and work our way up so we're
rolling back to the slide that Mark had
near the beginning where we have the
platform modules at the bottom and then
we have a this big cloud of jar files
that we are going to now attempt to
migrate to explicit modules we see use
exactly the same example we will use
Jackson jar files three jar files and we
will make the assumption that they're
they're well-formed there's no split
packages there's no cycles in other
words they're actually good candidates
to be modules so our goal is to migrate
what is in like blue and in this cloud
of jar files we're going to migrate them
to nice green modules so in in these
slides green is module orange is the
class path so what we want to get to the
point is is that these modules declare
exactly what they do they declare their
dependencies and they also declare their
exports so that they can take advantage
of the reliable configuration and the
surrounding capsulation the mark talked
about so exactly as before when you meet
modules that you have to ask two
questions what do they require what do
they export we've got three potential
modules here Jackson core Jackson data
bind and Jackson annotations so we're
asking me asking the same question of
each one of these three modules mark
show J Depp's doing a static analysis on
my app and my lib we can do the same
thing with the Jackson jar files by
running J dips and get an idea what
their dependencies are so mark mentioned
the J dips is a very useful tool is
indeed a key aid for doing static
analysis and getting an idea of what the
dependencies are on jar files it's in
JDK 9 it has a whole bunch of new
options and we'll be showing some of
those
we work through it the J tips - s gives
us a summary of the dependencies I give
it as input a a class path of jar files
are a set of jar files and it prints out
what the dependencies are in this case
Jackson annotations and Jackson core are
very simple when you do a static
analysis on them there is the only types
that they're reference are in the base
module or Java base where we're
java.lang string and Java an object
exists the Jackson data bind module is
more interesting in that it has static
references to types in other platform
modules it also has static references to
types that are in the Jackson
annotations and Jackson core modules so
from the output of J tips we can
actually construct a little diagram that
is the dependency graph at the top we
have Jackson data bind that depends on
Jackson core it depends on Java SQL and
you have XML and of course Java based
because every module depends on Java
base core and annotations are much
simpler they only have types of
reference and types in Java base so just
keep this dependency graph in your in
your head because we leave this as we as
we work through it I'm not going to use
J tips again this is this is an option
that allows me to generate a candidate
or at least an initial starting point
and form my module declaration so the -
- Jen - module - info is an optional J
tips to generate a starting point for
your module declaration it generates a
module info Java for each one of the jar
files that you give it there's two
options - there's a sorry there's an
option - and Jen module info which is a
directory where to generate this these
these these initial starting source
files so when I run Jade EPS and the
three jar files it will generate three
module in photo Java's in SRC slash the
module name and then the name of the
file is module in photo Java so this is
this jaidev's option is not in jeddah
Kate because JDK does not know anything
about modules this is a new up
in the upgraded version of j-dub sits in
JDK 9 so let's look at one of these
module info to see what Jade EPS has
generated and we're going to look at the
generated module info for the data bind
module the reason we're looking at that
one is because it's the most interesting
one so at the top of the module
declaration if you remember from
yesterday all modules and start with the
module keyword the name of the module
open curly brackets and then the
requires and the exports clauses for the
requires Jade EPS has generated a
requires clause for each one of the
dependencies that it sees with the
static analysis it additionally does an
analysis on the signatures of the
methods in in the for each type in the
in these jar files so it knows whether
there's references to types in other jar
files or other modules in the signatures
and that's how it's able to to be able
to include the transitive modifier or
not if you remember from the intro slide
you use the transitive modifier I mean
when you have a module that has in its
API signature some types that are in
other modules you don't want the
consumers of your module to have to go
and remember to do a requires on this
other module that you're exposing types
from in your API so Jade EPS is able to
do that and which is a good starting
point for generating the module
declaration Jade EPS has no idea which
packages in the jar file are part of the
API that are in that library so it
generates an exports clause for every
single one of the the packages that are
in that jar file now for this part of
the presentation we will pretend that
we're the maintainer zuv Jackson library
are the the the Jackson and Jason api's
and we will know much more about these
api's we will know which which API
packages are really part of the API
we'll know which are the implementation
packages so we'll be able to edit this
and remove the lines that
makes sense and that's exactly what we
will do in the next slide we will assume
I'm not one of the maintainer zuv
Jackson well we will assume that we are
and we will assume that anything that
has a dimple in the package name is
internal implementation and should not
be part of the API so if I were to edit
this generation module info dot Java the
first thing I would do is actually
remove these lines because they should
be not exported I don't want any the
consumers of this module to be making
use of the types that are in the input
package there may be a lot more
mainstream maintainer x' who should be
able to have a lot better ideas to what
their api is i would hope that the
Javadoc that they produced for this
library will only include the packages
that are a better part of this api but
the point is this is a good starting
point to get you to your module
declarations for these libraries that we
are migrating to explicit modules so now
let's go and compile our three module
declarations and we will compile it with
the rest of the source for the these
three Jackson libraries we will assume
the the same module source code layout
which is SRC slash module name and then
the module in for the top level
directory of the of the module source
and then all the packages organized as
they traditionally are so this is the
this is a module layout where you've got
an additional module name as in the in
the full path to the to the source I'm
using the Java C dash dash module -
source path which is the multi module
compilation I'm going to compile all
three modules with one Java C command so
I'm just using a bit of shell foo with
it with with using fine to find all
other Java files that are in the source
tree and I'm going to compile all of the
FIH those to Java C and it will compile
them all into in this case the mods
directory so the - G - Java C specifies
the output directory they're all going
to be to be compiled into the mods
directory and Java C will do the right
thing and compile them into mods slash
module name and all the class files will
will be created under that
we've now got our modules compiled I'm
now going to package them and I'm using
the jar command and some of the new
options that there are to the jar
command in JDK 9 so as in the intro
sleaze and presentation yesterday we
talked about and some of the new options
to jar and that because they jar has
been significantly modified to support
canoe style options to support options
to support modules and we're using some
of the new options here so I'm using jar
- - create - - file and I give it the
name of the jar file that will create
this jar file I'm giving it the location
where the class files that are going to
be packaged up into the jar file
additionally I'm using the opportunity
to add versioning information to the
packaged module as part of creating that
package module so this is the
opportunity to add versioning
information and which is which is useful
for diagnostic and reflection purposes
and later later on so 3 jar commands to
create 3 package modules now let's look
at the resulting module graph remember
green is module orange is our class path
because we've left Maya Pande my lip on
the class path for this part of the
presentation this is a much cleaner
module graph now each of the modules has
a small set of dependencies and very
very clear what they depend on so it's a
nice clean graph no cycles now I'm going
to run this now running this is a little
bit complicated initially because I am
mixing the module path and the class
path my app and my lib are still on the
class path for the command I'm going to
show you and this is this is the sorry
this is the original command I should
say where we had everything on the class
path we no longer have the Jackson
libraries on the class path so this is
the command that we end up with so this
in this command will initially look
complicated because I'm mixing modules
and the class path
my class path has my app and my Lib
exactly as before for the module path I
give it the dash dash module path option
to give the Java launcher the location
of the modules and I additionally have
to give it the add modules option to
tell it which modules to resolve
remember what I was saying yesterday at
the intro slide our intro presentation
my module path may have thousands of
modules in there there is nothing in my
in the in the in the application on the
class path to say which modules it needs
so I have to give a hint to the Java
launcher to tell it which modules to
resolve I know that my app and my lip
make use are so Maya makes use of the
data bind module so I'm having to tell
the launcher please resolve the Jackson
data bind module and locate that on the
module path so to commit this is what
the command looks like where I've got
modules from the bottom up and I've
still got my main application and some
helper library on the class path so now
we can start putting things two things
together and when I say putting things
together is we'vewe've in this part of
the presentation we started at the
bottom we've migrated some of our
libraries to modules at the beginning of
the presentation mark migrated my app
and my lab to modules when we combined
them together we end up with this nice
module graph where it's modules all the
way from the bottom up or from the top
down right before when I look at my my
app and my lab it's clear what they
depend on when they look at any of the
jar files in the middle it's very very
clear what they depend on now I'm going
to start running these all as modules to
see how this looks
so my Lib directory we listen we if we
if we look in there we've got five
modules so these are the the modules
that Mark created at the beginning of
the presentation and the three Jackson
modules that we have created in this
part of the presentation the command
that I'm using to run this has now
shrunk a little bit in that I'm just
giving you two options the module path
where it finds the modules and the dash
M option to give the initial or the main
module and that will just run
so that's really really nice well we can
go further we introduce the linker
yesterday and I'm going to use the
linker now to M to actually generate a
runtime image that has my up in there
and we will see how to how that works so
this is the jail in command yesterday we
use the jailing command and a very very
simple version of it where we just asked
the jail link tool to create me a
runtime image that had a small set of
modules in it we will do the same here
but we will use more some more Advanced
Options exactly as we do with Java C and
the Java launcher we give it the module
path where to locate the modules we give
it the add mods sorry add modules option
to tell the linker what modules that you
want included into in the runtime image
the jailing tool will generate the
transitive closure and will create a
runtime image in the output directory
that I give in the - - output directory
because this is the advanced
presentation we use a couple of Advanced
Options I'm using the - - compress
option to do some compression on the
image and I'm also using the - - strip
debug because I want to strip to buggy
information from the class files and
make the resulting image a little bit
smaller because I may want to
redistribute it for example so running
j-link what I end up with on this
example is a runtime image that is
26,000 bytes or just over 25 megabytes
which is not too bad when I look in that
in the bin directory of the result of
the resulting image I see that Java
launcher as before and I also see that
the linker has generated in launcher
from my app when I run the list modules
option with the Java launcher and in
this runtime image then I see the
modules that have been linked in so this
is the transitive closure of my app my
app depends on my lip
my app depends on Jackson's data bind
and and Jackson data bind appends on
Jackson core and Jackson annotations and
there's a small set of platform modules
that have also been linked into this
image so I've ended up with four seven
nine modules in this runtime image which
is really nice
so now let's shrink the command down a
bit more for this runtime image I can
just do Java - n my app I do not have to
specify the module path to this this
command because all the modules are in
the runtime image it doesn't need to
concert' you on the filesystem to go and
find just find my modules and because we
have generated a launcher which is what
jailing tool does when it sees modules
that have an entry point it will
generate me in my app and launcher and I
just need to run that and know no
command line options needed which is
really nice so shrunk my command line
again and there's because there's no
additional dependencies no options no
match of path here and that is it for
this dick the main point is is that the
module system allows us to adopt modules
at our own pace we what marked it in the
beginning of the presentation is in my
graces at some application and a helper
library two modules without depending
without requiring the libraries that he
depended on to also be migrated you can
actually start migrating applications
before the libraries libraries
additionally could be migrated to
modules before and before other
libraries they can be migrated
independently and that's really really
powerful particularly when we're
actually retrofitting the platform to
support modules when there is so much of
an ecosystem and so much so many
libraries out there so it's really
really good that you can actually run
migrate my libraries independently of
others you've also got a flavor of the
the types of modules that are in this
proposed design you've got the explicit
modules where I've typed a created a
module declaration I've typed module
space module name I've declared what the
dependencies are what packages are
exported and you've also seen how the
automatic modules where there's no
module declaration I'm just using
today's jars as modules on the module
path without any module declaration
there are automatic modules so gives you
a flavor for that and we didn't go into
a huge amount today on the normal
modules versus open modules I say normal
modules in quotes is
I really mean modules that we just have
module space the module name and versus
the open modules which are essentially
open for deep reflection by frameworks
mark touched on us and maybe another
another day we might do a presentation
once this is more baked on what this
actually means but I hope you've got she
got a flavor for Migration and the
different types of modules and in the in
the module system we'll end up with one
final sentence on the slides here
go forth and module eyes some more
information and we have we're developing
the module system in project jigsaw so
this is the link to the project page and
the mailing list and also the early
access bills the early access Bills of
project jigsaw are a little bit ahead of
the regular JDK nine bills because they
are a bit more bleeding edge there you
have implementations our early
implementations of some of the features
that aren't quite yet ready or quite yet
agreed to bring into JDK 9 but we would
hope to address that soon and that's it
so we have a lot of time for questions
so I think mark is going to come back up
for for questions on this so you know in
terms of logistics is there's a there's
a microphone that's up here under the
lights and it would be easier if you
have questions just to use the
microphone because it's very very hard
to hear people here and also because
this session is being recorded we have
to would otherwise have to repeat the
question and probably get it wrong
don't all get up at once yep someone
running now they're just leaving
what do you safe by actually packaging
all this stuff into a nice compact page
sorry what was the beginning of that the
mic wasn't do you have any idea timings
on how much you save on style of time
and all that good stuff startup time so
through heroic efforts of Allen and
others we've managed to reduce start-up
time by just a little bit which probably
doesn't sound very impressive but if you
think about it it actually is because
now when you start up even you know
something trivial like hello world the
model system is became the gear and
going and finding modules and reading
module and class files and doing
resolution and doing all the consistency
checks and setting up all the module
information in the VM so it's doing more
work and it's taking a little bit less
time now so that's just the immediate
effect
we do expect longer term that
modularizing the platform will enable a
bunch of other kinds of improvements to
startup time the most promising one is
probably ahead of ahead of time
compilation to native code there's
actually there will is it in yet we're
not quite the äôt stuff in process yeah
yeah so good so on on its way into JDK 9
as a somewhat late-breaking feature is
as an äôt compiler it's in nine it will
only be on Linux x64 it will be used to
ahead of time compile the base module
which is where all of the startup stuff
happens and that should give us another
boost in startup time in JDK 9 it will
actually be available for experimental
use on your own modules so if you want
to go play with a ot compiler and all
the advanced stuff that it can do then
then feel free and let us know what you
learned so as a high-level start startup
time has to has two aspects one is we've
managed to not only preserve it but
reduce it a little bit in in the near
term the other is the long term enable
with enablement of really
technologies such as ahead of time
compilation I was fingering specific up
your Maya application we've gotten rid
of a lot of megabytes you actually end
up with pretty small pie so that the
fact that the image is smaller you know
probably helps some in terms of just the
iodine cache behavior and paging and
whatnot but I don't think it's gonna
have a huge effect no the main thing
with having a small runtime image is
it's much easier to end much smaller to
redistribute so instead of distributing
the entire runtime and every one of the
the JDK modules which are application
if you're redistributing this small
image yeah and it's not just
redistributing but if you're for example
deploying in the cloud you can make a
small docker image that is then cheaper
to replicate you know across a bunch of
machines and a bunch of instances you
know ret rather than I have a half
gigabyte docker image you can have maybe
a 100 megabyte docker image and that's
generally a good thing in a cloud
environment right thanks a small
question
I saw the command line parameters
changed in the latest JDK 9 builds but
what was the reasoning to change the
shortened version of module path from -
MB - just - B which doesn't sound
logical to me to Google and Jeb - 93 I
think I've got that number right but and
so there's this is an informational JEP
sorry JEP is is JDK enhanced proposal
which and so this JEP outlines has all
the guidelines for moving to be new
style options which is what we're trying
to do in JDK 9 so we're preserving all
of the all of the original options that
have been in the JDK and but we're
moving to do canoe style where it makes
sense these long and verbose canoe style
options have short forms and the
guidelines is that they be single
character options and that's why the
that's why we moved from the in the
early bills we were using - MP but we've
actually moved to - P which is just
think of it as path and it actually
works quite well once once you get over
that transition all of the old options
was before hi I have two questions the
first question is you have to give it
into my Lib modeling for exports of each
and every classes that you want to
export so let's say that today I'm
releasing my Lib with some sort of ApS
that I want to expose to another app and
and tomorrow or after the next release I
want to have some more ApS to be exposed
then I'm I'm forced to recompile with
the module info containing the list of
exports new API is it does it not
because earlier it is easier that all
public API is are exposed now it is not
the case from JDK 9 so don't you think
that it has more delivery cycle than the
earlier versions do you mean is more
effort yeah I mean it has to come
through the development R&amp;amp;D and then
delivery it has to go plus you have to
change in the module info dot Java to
contain new api's that you want to
expose presumably your recompiling your
application not necessarily initially I
have all the APS already available but
then I didn't expose it initially well I
assume you didn't it export all the
packages initially because you hadn't
decided or they weren't quite ready for
release it's it's just it's just another
so the the the intent the intent is that
is that module info Java lives in your
source code along with all the rest of
your source code and that the whole body
of source code defines your module both
both both the sort of module part of it
in the module info plus all of the
regular Java source files that define
classes and interfaces or what not so
that that thing as a whole needs to make
sense you can have it you can have one
version of it that exports one package
you compile that make a modular jar ship
it and then three weeks later decide oh
well and now I need to export an
additional package that you've got your
source code and you know they get or
whatever you you add the export to the
module info dot Java you make whatever
other changes you need to your code
compile it package it and and and ship
it it's it's it's meant it meant to be
one thing so it shouldn't be a ton a ton
more work and the advantages you get in
terms of strong encapsulation you know
we think are generally worth the effort
okay and the next question is um your
versions of Java had the option of
dynamic class loading and everything now
does it mean that in the module info
only those that are exported can be
accessed
so that boot class part finding the
public API is that another class can
dynamically load are all affected I mean
yeah dynamic class loading has not gone
away but there but there are are now
further constraints if if a module does
not export a package that contains a
particular class then from the uh from
outside that module actually the class
can be loaded but you won't be able to
access anything in inside instances of
it so all I mean earlier all public
methods and ApS can be accessible but
now it does not be the case yes that's
true and I yeah and we I I'll cover this
in a bit more detail in the under the
hood talk this afternoon there there is
this somewhat counterintuitive thing
going on here where forever you know for
twenty years public has meant public if
you can find a class you can access you
know everything that's public in any
particular instance
now public no longer necessarily means
public but public will mean you can
access it if it's expose exported and
and required going in the other
direction and the short-term implication
of this at least for existing
applications is they just won't be able
to access the GDK and turn the API so
there may be some some dot star API that
is public and it is no longer accessible
in JDK 9 Thanks
trying to get my head around this whole
jigsaw someone ring is jigsaw just run
and compile help tool or is it also used
for dependency management because what I
have not seen yet maybe it was in the
introduction part I would expect on the
requires part of the module info I know
exactly what you're gonna say keep going
sorry keep going oh that's my question I
have I see that you declare a version of
a module in the package info but not any
requires so versions in a package info
oh that's what I just understood from
your colleague at packaging time I was
giving the version string to the jar
tool to add it to the packaged module
right okay so some of you have probably
heard this answer before I'll give it
again yeah first time today at the
introduction yes no worries that this
this is probably the most frequently
asked question why can't you why aren't
their version constraints on requires
you know why can't you say requires you
know requires Jackson dot data bind
version greater than 1.3 in less than
2.9 or something like that well there's
a little story behind that
early early prototypes of jigsaw some
years ago we actually did have version
constraints on requires
and we were we were thinking about well
how will this model system interact with
all the build systems that people are
currently know and either love or hate
or both right
and we realized well hmm Maven's got its
way of dealing with version selection
and dependency management and handling
conflicts and everything and then Gradle
has a somewhat different way of doing
that that is even more flexible and
configurable and there are you know
there are few build tools and kind of in
the long tail of build tools that do
things and yet other ways there might be
future build build tools that do things
in in maybe more optimal ways we're
actually on the verge of integrating a
very sophisticated solution to version
selection in this early prototype at the
same time fortunately we were thinking
about how this build system interaction
problem and we realized wait a minute
whatever you know if the model system
did version selection and dependency
management whatever we do is going to be
different than some popular build tool
out there and it's a complete
non-starter to say okay everybody you
want to use modules you need to throw
away your build tool you can't use maven
anymore you can use Gradle anymore that
would just be like huh you guys are
insane you're not yet that completely
unrealistic expectation so it's really
important to work with the existing
tools ecosystem and then thinking about
it further we realized you know at an
abstract level modules are kind of
they're a little bit more on those you
know some sort of Platonic ideal of a
program component it actually when
there's a prospective where it makes a
lot of sense for models to be
independent of things like versions so
modules are this fundamental do kind of
program component there they're like
classes but with a wider scope and and
and some of different characteristics
and it's perfectly fine to have a build
tool it's actually a good thing the
build tool is what intermediates between
the somewhat abstract notion of modules
and the very concrete and
world messiness that we find in build
systems and maven central and you know
the real world of jar files sitting in
file system so that's the perspective
that we've taken and it's it is a little
bit surprising it'll is a little bit
dissonant to many people at first but
most people our experience has been once
we explain this and they think of it I
was like oh well okay yeah maybe that's
not so bad and you work with it for a
while and it actually will become fairly
natural at least in our experience and
the experience we've heard from others
so far so that that's why there are
there are no versions in the module
system okay I hope it works out we do I
even see on HDI that the services that
you use you have different versions and
so that's only runtime so yeah we'll see
how it works out
Thanks we will yeah I mean I related
point out matrices we've got some time
is another related question that people
often ask is well why don't you support
multiple multiple versions of the same
the same module at the same time and
that was another big simplification we
made some years ago makes the entire
system much simpler if you want to if
you can do multiple versions of the same
model at the same time but you have to
go use a somewhat more advanced API the
layer API which is there for container
applications and you know sophisticated
applications that actually need to
support that kind of thing but if you
know most applications that don't run in
containers like app servers or whatever
you know most applications they live on
the classpath today and today on the
classpath if you have multiple versions
of a jar file you know you're you're in
trouble you might not know it yet but
you're in trouble so it's actually not
that necessary for normal applications
to support multiple versions so we don't
okay thanks all right this is kind of a
big question so feel free to answer it
the way you want with regards to class
loading it seems like the number of
classes that are now available the class
paths are fewer because you're you can
limit that in fact maybe zero right
on the other hand it seems like the
algorithm for looking up those classes
is a little more complex because the for
example automatic modules you can make
that graph really complicated if you
don't know what you're on what you're
doing so my question is basically with
regards to performance and also with
regards to maybe unexpected side effects
or gotchas or whatever that future
developers might encounter with regards
to modules any tips any info that kind
of thing okay well in terms of and
computing the transitive closure and the
resolution happens I start up and it's
actually pretty fast it's it's under
five milliseconds at the moment and with
JDK 9 now if you come along with a big
class or a big module path and you've
thousands of of modules in there it
actually scales pretty well and we've
actually written quite a few benchmarks
to exercise module paths with thousands
of modules tens of thousands of modules
compared it with the class learning
performance of the class path and it
just completely beats the class path of
course because once it's once once
modules have been found there is no
longer any linear search of the class
path define type so it actually works
out quite well yeah and that's a huge
win I mean a thousand jar files on the
class path when the VM goes to load a
class that starts with the beginning
each time it looks in each one right
once you've once you've resolved a
module graph and set up the class
loaders with the proper delegation then
the module system knows that therefore
any given any given package in any given
module you go here right away you don't
need to look in any other artifact just
that one thanks
I had a question about the linker
previously if I want to well if someone
downloads my application you download
the char and it uses the installed Java
which then is updated which you can
still do that later does not replace
that it's a new thing you can choose to
do but therefore I've got the question
in the exported image you have part of
the JRE are there plans to leverage
let's say the optional presence of an
installed JRE that is updated no no I
think you choose one way or the other
and and there are many applications
we're making a custom image is actually
not the right thing you continue to ship
a jar file or an executable you know
uber jar fat jar if that's better for
your scenario okay when linking is is
not is not meant to replace every but to
every current use of jar files with the
fact how you would use how to migrate
actually our applications currently I
suppose the modules are loaded more like
as they are required as with the classes
are loaded only when they aren't
actually needed is there a way or flag
or something to add actually all the
modules and this would also facilitate
us to actually and upgrade to JDK 9 I'm
sorry I didn't understand what you're
asking is there a flag to do what to add
all the modules in to have it available
and to not have to search for each
individual
dependencies that I have and actually
just put everything there like I have it
actually right now in JDK I have
everything from JDK available right so
when you run an existing application on
the classpath and with JDK 9 then it
works as it did with Jada case all of
the platform modules and that are linked
into the runtime image they're all
available to you they're all so all of
the types in those modules and all the
api's that you're using they will all
just work wait and only the Java basis
so when you run them ok so there's
actually a gyp 261 where all this is
really documented but when you run
something on the classpath all of the
modules have export API is that are in
the system image and you could just
think of those as being resolved at
startup so if you're using let's say
you're using swing or AWT and they're in
the desktop module than the desktop
module will actually be resolved at
startup when you're running a classifier
application those are the necessity to
require the well you're on the class
notes you've got no requires now if you
were to migrate your application to a
module and you're writing a module
declaration then you will put requires
Java desktop and that will cause that
module to be resolved but if you if
you're just moving from 8 to 9 it'll
just work exactly as it did before
in general we take we've we've we've
taken great great pains to make sure
that if you have an application that
works on the class path today with with
8 or an earlier release it only uses you
know standard supported api's then the
same command line will work with 9 as I
showed yesterday in the keynote
you know swingset a copy of swing set to
jar from 2004
you know runs perfectly well and not you
just type Java dash jar swing set to jar
and it works so you don't need to think
about base or anything else you can
completely ignore the existence of the
model system if you wanted so just
dependent so this
will happen only when your start to
actually implement imagine exactly
you only need to think about it if you
start to to use modules you know wait
wait when your just run swing set
internally the launcher is doing
resolution but only on the plot it's a
built in platform modules you're you're
completely unaware of it and that's as
it should be
thank you hello when and how would
modules be available in GE in what Java
Java enterprises Java EE right yeah so
what little tip do not ever say je e in
front of any of the Java EE spec leads
they will a little live
that's an excellent question we've you
know as you might expect we've had you
know quite a few conversations with EE
spec leads and other other people in the
in the Java EE world you know it's not
it's not up to us obviously but clearly
you know the the intent here is that a
future version of e will will adopt
modules in in a sensible fashion and
there are features in the module system
specifically meant to support
application servers and and those
current kinds of scenarios might you
know my guess is that ee 9 since the
number matches is will be the one that
has models integrated but if GA runs on
gdka
9 what models be supported by if if you
if you write an application using Java
EE 7 or Java EE 8 it will run perfectly
well on on Java SE 9 it'll be completely
unaware of the fact that there are
modules under the covers it follows the
previous question you have now an option
in maven to give when you're making app
war files as the container will provide
these libraries now when we are moving
to Japan 9 how are you
module info is going to dictate one
version but you cannot be sure that in
app servers that particular version is
going to be available so so until the
Java EE specs say how modules work in a
Java EE environment there is no concept
of modules in Java EE so Java EE 7 Java
EE 8 you know they they should run fine
on top of Java SE 9 but models are
something of which they're completely
ignorant and that's fine make sense
any news about optional dependencies are
they require static try out the jerk
jig start early access bills yeah
require static has been in in for a few
months a requires static is a way to say
that a module is required it has to be
there at compile time but you are
willing to write code to deal with its
potential absence at runtime it's also
useful for things like modules that only
contain annotations that you don't want
to bother to worry about it runtime okay
thank you hmm those thanks for being
here thank you we have time for one more
at least okay I was wondering why do we
need to specify transitive dependencies
why doesn't it just figure them out what
do you mean by why do you need what do
you mean by transitive dependency in
this case okay if I'm not mistaken in a
talk yesterday you said one of you said
that in in the file that specifies the
module you need to also specify the
prime the transitive dependencies the
dependencies that I mean with with with
requires transitive yes maybe okay right
so this is a potential confusion of
which which we're aware so requires
transitive is not actually specifying
the transitive dependencies as you might
think of it from maven this is what we
used to call this requires public and
that was an even worse name requires
transitive is less than ideal but we
haven't found or heard of a better
suggestion for the term requires
transitive is how you specify implied
readability so if you if you're writing
a module that just needs some other
module for its implementation purposes
you just say requires the module system
does all of the transitive closure
computation what requires transitive
means it's a very local kind of
transitivity if say your module uses
Java dot sequel types not only on in its
implementation but in its API the not
that requires transitive oh is a way of
conveying to users of your other modules
that use your module
hey for free you also get you know a
virtual sort of requires on Java dot
sequel you don't even have to say it so
it's it's a very local transitivity that
you're specifying for the benefit of
modules that use your module if anybody
has a better a better term we're open to
suggestions but this is one of those
really hard naming problems it was
requires public for a long time and that
was that made sense in a certain way
what was confusing now or now work
requires transitive which has this other
confusing thing to it but we've been
through long lists of of words and
looked at many Fusaro for for this and
nothing better is crop type so we only
have less than a minute left
Oh time is up in fact so thank you very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>