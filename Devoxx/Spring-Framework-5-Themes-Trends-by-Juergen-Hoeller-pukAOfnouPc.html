<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Spring Framework 5 Themes &amp; Trends by Juergen Hoeller | Coder Coacher - Coaching Coders</title><meta content="Spring Framework 5 Themes &amp; Trends by Juergen Hoeller - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Spring Framework 5 Themes &amp; Trends by Juergen Hoeller</b></h2><h5 class="post__date">2017-03-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/pukAOfnouPc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right well welcome from from my
sites to the Spring Framework session to
wrap up at least to be one of the
wrap-up sessions of this year's Vox Dei
Zurich e is my pleasure to be back in to
be back in Zurich since I've actually
had quite a bit of a quite a
relationship with the Swiss Java and and
spring ecosystem and community and well
the timing this year is is perfect since
we are right in the middle of the Spring
Framework 55.0 well development phase
were actually about to wrap up we are we
are just about to enter the Release
Candidate phase we released a Spring
Framework 5 to the m5 this morning and
we aim for a release candidate very soon
I will get to that so for the purposes
of this presentation I am going to take
a bit of more of a strategic perspective
where we're going to look at central
themes and trends which happen to be
driving the Spring Framework 5 effort on
our end these are largely industry
trends that we connect to Spring doesn't
live on an island it never did we we
always very consciously look at the
ecosystem around us at the state of the
industry at the requirements that common
our application architectures of the day
kind of feedback to us so it really is
very much a preparing for 2017 plus that
we're doing here we take the opportunity
with Spring Framework five not only to
do the usual stuff like raise the
baseline Java 8 plus and so forth for
the entire framework we enter new
territory
in previous releases previous major
releases for example spring filmic for
that was like the WebSocket support
which was actually quite quite huge
engineering effort that kind of saw the
light of day in spring formal fall ago
and this certainly is now our reactive
web stack materializing in springtime at
5:00 we'll get to all of this let's
start with where we are just quickly
summarizing so spring from a fall of
three was intentionally a sort of extra
bonus feature release in the folder X
line it's almost a little bit of a 5-2
the whole back port and early back port
of 5-2 though it wasn't originally
planned but we decided to do it to bring
a couple of refinements to our existing
production branch so in case you're
wondering why fall of three was a rather
rich release he was I mean it basically
it contains stuff that another project
you would only get in the five two
though but we decided to port it because
JDK six seven because existing
production environments because
websphere seven there are there are many
reasons to do some refinements that are
technically easy to translate into the
spring framework for the X architecture
in for the three here so this is our
current production branch already out
for well almost a year then how soon the
full of three generation is going to
take the role that 3.2 currently has so
that it recently had so it's up for an
extended support life it's the last
photo the X feature release and it will
enjoy a long maintenance life at least
until 2019 in parallel to spring from AK
5 to the X so what's coming here well a
few things what's available here a few
things but before we go into feature
details there's a little graph that I
recently generated with our own stats
this is actually the download graph for
Spring Framework releases of kind of the
past year so it's basically from the
fold of three release candidate face to
two now of course take them with a big
grain of salt
download graphs but those are maybe in
central downloads of the spring core
artifact so only a single artifact count
and it's quite a nice trend I am not
entirely sure what what January 27 it
does tell us here to have such a steep
rise there but the the download stats
tell us a lot we actually break them
down by version we break them down by
artifact the we actually are very
numbers driven well not very but numbers
inspired at least in making some of the
decisions we can find out which modules
are particularly popular which modules
are in rising in popularity or declining
in popularity and we see in particular
through the version numbers whether
certain maintenance releases are still
being picked up or that still worth
maintaining certain branches how quickly
people adopt for the three or over for
the two or previous for the next
releases download statistics tell us a
lot so in for the three just very
quickly now some stuff is new this is
actually a typical spring component
class right but the new part here is the
commented out at Auto Wyatt
one of the little new things before the
three years we don't insist on an auto
Wyatt annotation for a single
constructor scenario if you want to just
design a constructor based on dependency
injection principles and leave it up for
the framework to figure out that this
single obvious dependency injection
suitable constructor is to be picked at
runtime it's particularly nice from a
design perspective when maybe the
component doesn't even have any
annotations for other purposes it
doesn't have to have any notation for
injection purposes
without extra metadata right we're
talking about the conventions for the
annotation based programming model there
has been quite a bit of fine-tuning in
fall of 3 here and some of this might
not be particularly obvious like in this
configuration class it only works in for
the three because it uses a dependency
injection construct an injection point
at the constructor level for a
configuration class this wasn't actually
possible before because CG lip
subclassing of configuration classes
really requires some special support for
this so as a 4.3 you can do what you
maybe intuitively thought you could be
doing anyway which is freely designed
your constructor signatures even for
configuration classes which in spring
are regular component instances and
regular components should be able to do
what all components in the spring
component button can do including
flexible constructor signatures with
dependency injection even at this level
so that's also new in for the three and
well this is a pretty much up to date
spring MVC controller in terms of its
design now contrast this to let's come
as a contrast here with the new for the
three variants of the mapping
annotations get mapping in post mapping
this has been quite there has been quite
some heat in that debate but we
eventually decided that we are shipping
convenience variants get mapping post
popping patch map input mapping and
delete mapping as of fall of three those
are literally just precomposed
annotations this is not rocket science
you could build those annotation to
yourself just by meta annotating them
with that request mapping and doing the
Alliance's on D on the attributes we
just decided to ship them out of the box
because there has been a pretty strong
drive pretty strong feedback that we
really should be having more convenient
versions for the typical rest endpoint
mappings and the java annotation design
allows us to replace the attribute names
here like pow
and method with a single unnamed
attribute as per the Java annotation
rules if there's only one that you
commonly specify by baking the HTTP
method name into the annotation names we
are basically free to leave this single
attribute this convenient a true value
attribute up to the path commonly so
just these are just pointers to some of
the things we have been working on this
is intentionally in for the three
because it's a continuation a kind of
wrap up of at the central for dot X
theme which is refined dependency
injection flexible dependency injection
arrangements and in particular the a new
annotation based component story overall
with its use of composed annotations of
custom annotations of flexible
combinations of semantics into a custom
annotation all of this really comes
together and for the three and this
basically as complete as we ever
envisioned it to be with spring from ik
5 we're taking the opportunity to set
different things sort of to to focus on
different themes to set different
priorities to some degree the
application framework as we know it in
spring is very much perceived from an
annotation perspective these days in
recent years we tended to focus very
strongly on annotation based components
the call of the framework in spring is
still very very generic agnostic of
annotations spring is not an annotation
centric framework the co of the
framework and the absolute majority of
the facilities in the framework only
react to certain characteristics
indicated by annotations but they are
not based on annotations themselves and
we're making some good use of this
flexibility in 5 as we're going to see
there are a couple of important baseline
upgrades with
finally based on JDK 8 and it's largely
a Java EE 7 baseline if you're using
servlets it should be Soviet 3 that one
plus now and it's only JPA to that one
person that we support kind of the
obvious from a 20-17 perspective while
at the same time already focusing a
little on the next generation so on jdk
9 and servlet for and being validation
to the door for example we have support
for chained unit five that we ship
already since Sam had a achievement five
top this morning
Ju in five is not actually finally yet
but our support is very up-to-date with
like madison rayne enjoy unit five and
since it's co-developed between
basically chain at five and and us where
we we are not only a an immediate
consumer we've also been a sponsor of
the J unit five effort initially you may
remember the giant five was actually a
crowdfunding initiative and had some
corporate sponsors as well and we've
been we've been among them so in terms
of infrastructure themes we we have a
interesting selection here it so it's
some some things are obvious
we always track the latest jdk we always
directed a disturbed specification but
the the embracing of Kotlin that we're
doing the the first-class support for
the Coplin language that we're doing in
Spring Framework five might not be as
obvious and the our our very strong
venture into a into the reactive ways of
into reactive processing architectures
and into a functional ways of of
configuring endpoints and of configuring
the co container are also slightly out
of the ordinary if you look at it from a
very traditional spring perspective
those are really quite different ways of
architecting a spring based application
so a couple of of deeper
sites for some of the core or those core
things and I'll keep those rather brief
we'll spend most time on unreactive but
a few words at least on jdk 9 and this
may may ring a bell
if you've seen Nicolas gdk9 talk today
it's very much we very much share the
same attitude here JD King 9 is not just
about jigsaw the jigsaw module system is
obviously the key engineering effort in
JDK 9 but there's a lot of goodness
coming with JDK 9 that's worth embracing
even if you don't care about jigsaw or
if you don't see yourself using chick so
because of compatibility concerns with
existing libraries and so forth I mean
jigsaw is fundamentally a fine idea this
whole idea of the of the JVM
understanding module boundaries and
enforcing module boundaries having
structural information at runtime that
it can use for efficient lookups of
certain packages known to be to live in
specific module boundaries this is all
fine from a conceptual perspective in
practice it comes at a certain cost in
particularly if you're using a modern
day stack with the party libraries and
so forth I'm going to show you just an
indicator of how this works with how
this can work with spring but the
central point here is we need to embrace
JDK 9 no matter what there's no point in
hanging on to JDK 8 forever we need to
embrace it for compact strings for the
garbage collection hands meant for the
efficiency measures in in in the jdk
zone startup times for the new protocol
stack that's finally HTTP 2 ready we we
need to embrace it for what it is even
just as a runtime for our Java 8 based
applications there are immediate
transparent benefits to be gained from
just taking those applications and
deploying them to JDK 9 so the very
minimum we can do is to take our
existing systems keep stay on the class
path
and deploy them to to JDK 9jt canines
currently scheduled for end of July and
it still has a chance of actually
happening
from my perspective at the end of July
there are never guarantees of course we
have been tracking gdk9 for a long time
already
so the the efforts on our end towards
run time compatibility are very complete
we do not ship specific support for jt9
features yet there's not actually that
much that we can do we thought we are
going to support a new HTTP client but
it's not actually part of Java SE 9 now
more comprehensive support is coming in
the in our in a further in a future
generation in possibly in 5.1 on our end
for five to doll and even four for three
it's largely about taking an existing
spring based application running it on
JDK 9 and having a smooth out
out-of-the-box experience and that is
very much the case already and it will
be even a little bit smoother as we move
towards our GE release in June there are
a few things we can smoothen out even
for more complex setup still so this is
our primary focus use of the spring
framework modules on the module path is
kind of an an opt-in bonus from here I'm
not trying to de-emphasize chick so just
apply a very pragmatic attitude if you
want to have an easy smooth upgrade stay
on the class path many libraries did
that their job already to the degree of
being able to work on JDK 9 on the class
path without any issues for for jigsaw
well this is a module system with
visibility boundaries with visibility
enforcement you need to opt into it
fully if you do chick so basically do it
wholesale take your entire dependency
crafty third-party modules that you are
using the spring przemek models that you
are using put them onto the jdk 9 module
path declare your own
application modules as chicks'll modules
include the module info descriptor
express your requirement your visibility
requirements to the frame of GPRS and
the third-party APR that you're using
through this module info descriptor in
jigsaw this is what we're aiming for
right now
we're not actually shipping module info
descriptors ourselves we're relying on a
mechanism in JDK 9 called automatic
modules if you put the spring framework
chars and corresponding other jars like
hibernate or Jackson onto the module
path STI record the char files as you
get them from maven central right now
then JDK 9 by convention treats them as
automatic module derives a module name
from them gives some default
visibilities to them they see all the
other modules on the module path if
necessary this is a pretty fine
arrangement it's still a little bit of
effort to get there but if you're
interested in in in making it work it's
entirely possible right now with the
exception of they are not being complete
tool support for it Gradle doesn't work
with on JDK 9 yet and the ideas are
still a little bit lacking in that
respect but for forest simple scenarios
testing sample applications it's all
good already and the tooling support
will certainly happen certainly hurry up
and be available shortly after JD Kenai
GA we may ship module info descriptors
in in the future this is not yet clear
when and how
because automatic modules have a strong
benefits we don't need to know the
module metadata the module names in
particular of other collaborating
libraries so in such a scenario it has
strong decoupling between the modules on
your module path they don't need to know
each other's module names necessarily
this is a great benefit in the open
source ecosystem that we live within for
the time being there may be there may be
a move towards a stablished module
namespace we're certainly going to
participate in this once it really
materializes in the ecosystem
it's not strictly necessary anyway for
the application perspective so what we
are trying to enable is essentially this
you should be using you should be able
to use chicks are fully including module
descriptors as they're meant to be in
your application modules everything else
is secondary whether the frameworks and
libraries that you're using ship module
info descriptors is almost irrelevant as
long as you can properly use Chickasaw
in your application modules all right
very brief a note on HTTP two but I
personally find it very important I'm
not going to iterate over all the
benefits there are a ton of benefits in
HTTP two I mean just just a reminder
this is the first major revision really
major revision of the central
communication protocol that our web
architecture czar using it's the first
revision in basically 20 years I mean
even if HTTP 1.1 only released
stablished itself in the industry a
little bit later than 97 it's been 20
years between the actual releases of the
specifications lots of parties lots of
stakeholders here did their job already
from the browser's even the mobile
browsers to quite a few frameworks and
servers we are lacking a little bit in
the servlet space at least that's the
way it can be perceived because we are
still on server through that one and
it's only so late for that all really
enforcing HTTP to support well that's
not entirely true because servlet for
enforces HTTP to support it it makes it
a mandatory requirement for several
containers to comply with several Adel
there's nothing preventing servlet
through that one containers from having
an HTTP two-storey with maybe a little
bit of extra setup necessary and some
workarounds for the missing LPN stacks
on JDK 8 but this is all doable even if
it's a maybe not ideal right now it's
already doable for example against
Tomcat 8.54 jd9 dot
recent versions of undertow the web
server underneath wildfly they all have
HTTP to support already for quite a
while so innate HTTP to enabling an
existing tomcat jetty undertow based web
architecture is not rocket science at
this point it will become smooth on
silicon and with you out of the box a
LPN stack possibly on a few GTA decayed
update with a back port of that updated
protocol stack so that's all fine and
servlet for enforcing this is great but
we don't have to wait for it
there's no excuse we shouldn't think we
shouldn't point to serve it for and just
use it as an excuse for not HTTP HTTP to
enabling our existing systems we can do
this right now and we should at least
spend the time to find out what it takes
to make it happen right now to prepare
for it HTTP to enable service right now
from a spring perspective we we go into
both directions so the in particular in
the spring boot and spring oil platform
space there's already support for these
latest generations of tanka chatty and
undertow
we are tracking servlet four very
closely as well so there's API level
support in in today's five 2005 release
already for servlet four if you're
running on a separate for container
there is not actually that much more to
do so ever that for is not that
interesting API wise the most important
effect that servlet for the DOE will
have is to bring a the entire servlet
container ecosystem up to http to metal
all right a sneak peek into what we do
in towards towards more functional
styles I've already mentioned that the
annotation based story that was with us
for quite a while now
pretty much sees a wrap-up a a feature
completion point in full of three at
least from from from our perspective
there's always room for improvement but
you get the point
fundamentally it
anything we ever meant it to do in
spring five we are entering different
territory we're trying to design setup
variants that are maybe useful forward
for different kinds of applications
different kinds of setups the functional
B registration API is a not meant to
replace like component scanning in large
enterprise applications they're meant to
be used maybe for micro service
architectures for force services for
systems for applications which tend to
be more functionally designed all the
way through and we just want to provide
the means for the spring application
context set up to be nicely aligned with
a general functional design in a spring
based application each other eight
foundation that we have right now they
each have eight minimum requirement
makes this of course a little bit easier
there is a lot lots of goodness in Java
eight for functionally oriented API
design the Java util function interfaces
stream optional at all of those things
out of the box available out of the box
now and that they can be used in hard
API signatures that we're shipping is of
course a great enabler the just to give
you an indication of what this can feel
like in current spring five milestones
this is what you can do on a on an
application context like a generic
application context or antigen configure
application context which can also be
populated with an annotated components
of course mix and match as you see fit
but you can also use a functional
registration style reduce the components
by class and a supplier creating an
instance supplying an instance of that
class so what we can see here up here
for example it's just a supply
implementation actually creating the
instance for this bar component and it
uses a callback into the context to
obtain a reference to a
forant component so instead of using
annotation driven injection
it's a programmatically composed
arrangement of of callbacks of course
very simple here but this can be scaled
to quite some level and it can even be
customized as you can see below here in
this variant there's a couple of extra
parameters that we call beam definition
customizers so setting additional
characteristics like the lazy init flag
or anything else you possibly want to
add to the beam definition can be done
in in-line lambda expressions within the
call this is in particular a quite nice
experience for smaller focused
deployments smaller services composed of
just a few components and a few pieces
of infrastructure where the arrangements
here
can also be nicely decomposed know ye
the actual registration of certain
groups of components can happen in
different places against the the same
application context this isn't quite the
the end of that story yet for us it's
just the beginning we are currently
exploring further variants and you're
going to see another functionally
oriented registration variant in just a
bit but we this is basically the
beginning of a different perspective
that we're taking from from how to
consume the facilities that spring is
providing the particular benefits are I
guess obvious right no external metadata
no annotations either there's no
reflection involved
so technically up here there's
reflection because we're calling the
default constructor but if you want to
work around this specify a method
reference to the to the constructor and
there is literally for this kind of
setup no reflection involved the moment
that you started your people are seeing
reflection comes back in but not at the
construction level not at the container
level this can be a benefit in its own
right for us it's not essential to avoid
reflection this is not actually a kind
of requirement anywhere right
it is a nice theme to work too
to allow use of the entire course spring
container without any use of reflection
is kind of one extreme of a kind of
usage spectrum that we're exploring and
this is where the Cockney in support or
at least it's one of the points where
the copying support comes in we actually
have coupling support all across the
framework now we ship a couple of
coughing extensions in several spring
modules company has a really nice
extension mechanism where existing jars
can easily ship cotton extensions that
are picked up by the cotton compiler
automatically by convention this is what
we're doing in spring five now and the
set up example that we've just seen
looks like this in coupling in pretty
dramatic coupling I mean you can argue
about what's more idiomatic than the
other variant but this is basically
Copland's Java style above java oriented
style and would I prefer to call like a
Gradle style usage of coupling with the
inline type expressions this is
equivalent to what we've seen before
this is basically the Java 8 lambda
method reference style of of using those
functional registration facilities what
we're seeing here is the cotton
equivalent and it's literally using the
same methods just a couple of overloads
for cutting cake flowers references and
and for couplings are type inference
from from lambda expressions so all the
benefits we you can possibly get by not
repeating yourself we are doing what we
can do here what we technically can do
here with codling this is really nice in
the end in particular when combined with
use of coupling for repository
implementations for web endpoints
there's a lot of potential in cuddliness
language and it actually is something we
typically do in major releases in Spring
Framework 3 we've introduced our own
spell expression language in spring
framework for we introduced very broad
and deep support for groovy for the
groovy language and in spring from AK 5
we decided to do the same
first-class treatment for coupling and
we actually have a really good
relationship with the coupling team at
JetBrains as well so we actually are
tracking copying 1.1 right now so this
is very very up-to-date there's even a
little
of coevolution where we are feeding
while we're giving some feedback back to
the coupling team in time for their
cotton one that one release so they are
very very open as well towards working
with us on a kind of really sweet end
result and a very sweet overall
experience when using coughing with
spring all right
reactive this is certainly the most
important effort we have right the
broadest and deepest engineering effort
we have in spring from AK 5 we are
exploring facilities like a whole style
of setting up a spring architecture
spring based stack following the
reactive principles right following
reactive processing guidelines we
actually take this pretty far it's not
just about reactiveness it really is
about a complete reactive processing
architecture from the bottom to the top
from the data stores to the web
endpoints all based on a record library
with an event loop so it's not just
about a reactive style it really is
about reactive infrastructure all the
way through the principles that we
follow are not to no surprise as opposed
right it's the reactive manifesto the
qualities of reactive architectures
really shine in certain well shine more
in certain scenarios than others
reactive is not for everybody and not
for every kind of system it is a
different way of composing your your
processing architecture of composing
your endpoints of composing your your
datastore interaction in a different way
of setting up the infrastructure around
it
instead of a large thread pool which
typically is to be found in a server
container it's replaced by an event loop
triggering composition pipelines with no
blocking operations anywhere I mean if
you still have locking operations there
are ways to get them in with worker
thread pools and so forth but
fundamentally it's a different way
of setting up a an HTTP web architecture
it's very much connected to well a
general industry trend where we are
trying to make the best possible use of
the hardware facilities out there and
the operating system facilities out
there so instead of just having idle
threads waiting for data stores to react
we intend to maximize the throughput
through the system threads basically are
never really idle if if there's enough
load and the processing in and the high
load is very predictable so one of the
quality is not X not explicitly
mentioned even here is predictability
under high load a servlet based
architecture can scale very nicely but
it tends to result in sort of non
predictable behavior or non non equal
unfair behavior between different
clients where clients
where-where-where requests coming in on
the high load are not being treated
fairly necessarily and there are no
guarantees to be given reactive
architectures have a very different
quality to bring it to the picture here
and a central central mechanism
underneath any reactive processing
architecture is the reactive streams
model reactive streams basically are an
interaction arrangement between
different parts of your runtime stack of
a reactive processing stack like between
the HTTP server and the data store and
the frameworks involved the this idea
with a publisher subscriber model where
a subscriber explicitly indicates that
it is capable of processing a certain
further junk is is actually pretty
simple this idea of back pressure where
a subscriber indicates that it is
actually capable of further processing
and kind of prevents a publisher from
from flooding it right it basically
tells the publisher to stop until
further Elliman
down the pipeline I actually able to
consume and process the elements so
there's there's flow control between
publishers and subscribers this is
essential in order to make the best
possible use of threading resources in
an event loop arrangement to only be
called back when new data can be
produced and consumed right so and if
the network stack is not able to send
any further data back to the client
we don't actually trigger the data store
the data store doesn't send the data to
us we don't have to buffer it we don't
have to wait and block when writing the
response so the this idea with a back
pressure enabled reactive streams
architecture is central to project
reactor reactor se is literally a
project writer reacted org this is a
distinct project it's basically a sort
of Eric's Java equivalent and Eric's
Java rethought and tightened up on a
Java eight basis and with a server-side
focus this is what reactor 3 provides
reactor is a a pivotal sponsor product
it's a project and open source project
and it's also showing up in a couple of
pivotal products already so it's
actually in in in quite heavy use but
aside from from other stakeholders
spring from Mach 5 is based on reactor
and uses reactors in particular
internally as the central reactive
library that we are using at the same
time reactor is not just an internal
component it also has two dedicated user
level types called flux and mono which
we're going to see soon so it also has a
user level impact we're going to get to
that with a quick sauce example in a
moment to be clear about how we're going
about this in spring filmic five we are
shipping to web stacks in parallel in
the spring from a five core distribution
there's the traditional servlet
container stack
known as spring web MBC this is largely
the same as it was before of course
there's a revision we're doing a little
bit of overhaul a little bit of
alignment some reuse of facilities but
essentially it is still the spring web
MBC as you know it on a servlet stack
with direct exposure of the servlet API
if you wanted to with the same similar
based SP is that you may already have
integrated with and that third parties
have integrated with on top of the
spring weapon BC stack you would
typically be using the ad controller
model that controllers that get mapping
request mappings the typical annotation
based endpoint model of recent years
that's the typical but actually not the
only way of consuming spring water
machine today in parallel to that we
have a reactive stack the reactive stack
is potentially adept adapted to a server
container underneath the covers but it's
not based on the servlet API it can run
on Tomcat and Chetty but it actually
uses Tomcat and Chetty as reactive HTTP
service it's not using them as a serving
container it's not using them through
the servlet model it can be adapted to
nettie which is the key parallel option
here at are very different but highly
efficient
networking architecture and it can also
be adapted to a metal core actually not
under to serve it and until has a
lower-level
HTTP server that's not served at best
that we can directly adapt this to there
is a layer of reactive HTTP abstractions
on top reactive stream spaced reactor
based back pressure enabled on top of
these out-of-the-box options underneath
and there is a new variant of our of a
web framework on top that we chose to
name spring wet flux so spring wet flux
is basically spring web MVC but on a
reactive web stack and a a reactively a
reactive all the way through web
framework so it's not trying to
direct the reactive facilities it's it's
embracing them and it of course has
differences to spring weapon we see very
strong differences but at the same time
we're trying to align them to have a
similar not identical but similar usage
model similar style in in terms of
endpoint design annotation based
components or programmatic components so
this is best explained by looking at
least as a sketch of source code what
we're seeing here looks like a spring
MVC controller doesn't it well it
actually is a wet flux controller but it
is following Springs general annotation
based component guidelines as we are not
only using them in web MVC but also for
example for WebSocket endpoints and and
messaging endpoints look closely these
methods are not processing an incoming
request they are returning a pipeline a
processing pipeline for the given
request so if I get user request comes
in the user slash one comes in here
we're going to take the we're going to
take the incoming argument we're going
to pass it into a repository we don't
see the repository here but let's assume
that the repository is reactively
enabled as well the repository does not
return the user object in this case it
returns a mano of user mano is one of
the two reactor at the to reactive API
types in reactor mano represents
essentially a single object a processing
pipeline for a single object or non flux
down here has returned from a sketched
find all operation here flux is a stream
of user objects in this case so a a a
sequence of potentially more than one if
you are familiar with Erics Java
fundamentally flux is sort of observable
and mono is sort of single and
completable combined
so in in contrast to Eric's Java where
we have quite a number of different
reactive types in particular in our HR
between the mean time reactor only has
two for those very common very common
scenarios so the essential part of the
processing architecture here is that we
reduce the such a controller with the
reactive web stack the reactive web
stack natively understands what the flux
and the mono means it triggers those
endpoints the endpoints return the
processing pipeline and based on the
availability of the incoming requests
payload and the availability of the
outgoing responses output stream we are
going to start processing them the
processing architecture is going to
register these mono influx return values
that you provided and it's going to
trigger the next step of operation
whenever it's actually capable of
processing them it's kind of an event
loop architecture common to actually
many many processing architectures out
there anyway but sort of a little bit
out of the ordinary from from the
perspective that we typically come from
which is the servlet model so we are not
processing the entire request and
generating the entire response within a
thread that we own we just return
basically instructions for how to
generate a response from those endpoints
if you have a repository underneath
talking to a data store that's
reactively enabled has a reactive driver
you may just pass the outcome that you
get from the repository through to the
endpoints for this reason we don't just
support flux and mono we actually
support the arcs Java types you can
declare observable and in single here or
you can declare Java two's flow it'll
here the our processing architecture
natively understands what those types
mean and adapts them internally this is
in particular useful if you have data
store drivers or other third party
libraries that natively return
arch Java types you can just pass them
through to the spring web flaps a web
flex processing stack or if you choose
to use our Java right you don't have to
use reactor we just suggest the use of
reactor since it's the most direct and
most concise way of expressing yourself
here
our extravagant of legacy reactor had
the benefit of a late birth here and it
had was already able to learn its
lessons from Eric's Java and he it
actually benefits from a call from some
collaboration with the RH Java team even
David Connick the project is of rxjava
to actively recommends reactor if you're
on Java eight and you're doing
server-side applications then David says
use reactor because rx Java two with its
Java six basis is really designed for
different architectures Androids
client-side use and so forth and the
migration is very straightforward the
operations are very similarly named etc
so to wrap this up the annotation based
Martin is not the only it's not the only
model that we we provide it's a it's one
variant of consuming a stack the other
variant is what we see here and I can
only really kind of whet your appetite a
little this is a programmatic
registration facility for for web
endpoints and the this notion of a
router function that we see up there is
basically the equivalent of the notation
based path mappings pointing to what we
call a handler function so with a router
function you're programmatically saying
like for this incoming kind of request
for this predicate bind it to this
handler function and for the other like
it users bind it to that other handler
function handler function is a
functional interface you can use the
Java 8 method reference index to bind it
to end points that are comply cos that
are compatible with the handler function
signature so the idea is that the in
this case this delegate
has equivalent methods takes the
incoming server request this is the
programmatic equivalent of what we've
seen before basically takes the path
variable builds a reactive processing
jane converts it and passes it into the
repository has a mono passes the mono
into the server responds it's even
simple of course for the final operation
where you get the flux directly just
pass it into the server response body
builder and return it this is the most
flexible variant that we're offering
here it's a very direct interaction with
the runtime wet processing stack in a
completely functional style no
annotations no reflection involved but
of course a very different stylistically
right I mean those those two classes
basically those those pieces of code
Express exactly the same endpoint
processing rules just expressed in a
very different style and in case you're
wondering you can of course use the
inline lambdas for the same thing so if
you don't need a delegate because you're
you're processing operations are very
straightforward you could also pass them
into the router function as inline
lambdas the Java eight language allows
us to use a method reference or a lambda
expression so that's exactly the same
code as before just differently
structured with an inn and lambda
expression there's a lot of power in
this and I can only really kind of hint
at that power here and we are only
really starting to explore they use in
in in in in larger architectures here so
there's a lot of potential in this I see
it as the beginning of a very
interesting journey on our end in five
two though that's going to continue over
the five tedx releases so this is
essentially the core themes of Spring
Framework five five two though RC one is
you in April we intend to go GA in the
June time frame already with everything
mentioned here being complete to the
degree of of you of being usable in
production there's even early cherokee
nines important servlet for support
so once gdk9 is out and several
containers are out you can immediately
start using Spring Framework five on top
of them
and it's based on hopping one that one
already so where else is that's going to
materialize just in time so lots of
things come together here we are not
developing this on our own we're
actually collaborating a lot both with
the react and Rh Java teams with the
cutting team there's a lot of
coevolution here which I find personally
find particularly exciting and this is
the spring from a core release of course
there is a corresponding spring data
release chain spring day decay shipping
out-of-the-box support for such
reactively enabled repositories against
data stores where this is actually
technically feasible and where there are
reactive drivers available and when
there's a spring boot to the dough
coming built on Spring Framework five to
the one spring data K where the reactive
web status that we currently have on
started spring that IO are going to
reach production quality we have preview
with reactive web status on on on our
website already but spring boot to the
dull will still take the better part of
this year to really reach production
quality not only in the the actual
technical stack here but also in the
dependency management in finding a
dependency a production level dependency
set up that we can support once spring
to the dough goes J alright that
basically sums up this little tour
through springtime back five themes well
thanks for your attention I hope there's
there has been a little bit of
inspiration or maybe a kind of maybe
there are a few a few already itching to
to play with this feedback is very very
welcome it's the perfect time for
feedback here we're currently in m5 to
fight the last milestone ramping up
towards our c1 the time for feedback is
now but of course it's welcome at any
point even afterwards all right well
thanks so far if there's any questions
I'm happy to take them still or if there
if you want to have a one
conversation or in conversation in a
smaller group about those things just
come up to the stage thank you all right
any any questions for the like like
reactive interaction with the relational
database there are initiatives but
there's like a PostgreSQL that has a has
a dedicated project for a reactive
reactive driver oracle has one but it's
it's in very experimental stages so
fundamentally it wouldn't even call it
JDBC it's a sort of different way of
interacting with the relational database
let's see when those things materialize
the reactive drivers for some of the EDA
alternative data stores are much more
advanced because they are more naturally
supported in in in the corresponding
backends so the like even in Couchbase
and so forth there's there's already a
number of years of experience in
supporting reactive architectures there
which is of course in a great help right
and we see our efforts here also as an
enabler hopefully some other
stakeholders in this industry in this
ecosystem are going to be motivated to
maybe ship their own reactive drivers
and reactive stories a little bit
earlier as well if we start doing so on
our end right
spring security yeah it's of course also
part of the release train for boot to
the doe the spring security has to do
quite a bit of work because a lot of its
facilities are essentially served at
best at the moment and we have to find
equivalent hooks you know equivalent
decoration mechanisms they are already
at the end Webb flux and it's in the
works with spring security I can't
promise when exactly it's going to be
available all I can say is definitely in
time for spring boot to the door there's
going to be a complete solution on
spring security's end as well I can't
see you at all so please just shout at
me if there's a question I I frankly
don't really know the status you'd have
to check with them the spring security
has another DD the core spring security
is run by a by rope winch who are a very
direct connection to but there are a
couple of community modules and it's
always a little hard to tell about the
level of engagement there is at the
moment but if you have a particular
interest in certain like certain spring
security modules say Sauron the raise it
if there's nothing happening in those go
to the forums I'll go to the issue
tracker and our take open issues that
you care about and escalate them by just
doing a fresh comment or reopening them
if they've been closed due to in too due
to inactivity we essentially very we're
very community driven many things that
we're doing very directly connected to
feedback that we get to priorities that
we hear about so we we we are always up
for delivering solutions that are ready
for the mainstream or that at least are
have a potential of being being adopted
in the mainstream so we really want to
know what you care about
to focus on on the right parts of the
story right any and you remain in
question otherwise if you want to have a
chat I'm available here it just come up
to the stage afterwards and we can when
keep discussing otherwise thanks again
and enjoy the view project</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>