<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JUnit 5: Next Generation Testing on the JVM by Nicolai Parlog | Coder Coacher - Coaching Coders</title><meta content="JUnit 5: Next Generation Testing on the JVM by Nicolai Parlog - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JUnit 5: Next Generation Testing on the JVM by Nicolai Parlog</b></h2><h5 class="post__date">2016-11-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/VfC00bby8XQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay looks like we're on hi so my name
is Nikolai and I don't want to bore you
so I'll start right away with Jamie five
quick question before that has anybody
seen this talk before because if you
have now is a good time to leave it's
going to be very similar to what you've
seen before
okay other than that who's used a need
for ever Wow last month last week today
yeah cool cool I need your help because
when we start I gonna have to ask you
some questions and eat your answer let's
go over here so I see my slides yeah
Janet five is work in progress so that
means that there will be at least half a
year more before any general
availability will be released so if you
want to provide feedback because you're
missing some feature or you have a good
idea now it's a good time to do that and
these are a couple of links when you
will see the talk the slides online soon
you can follow me at here me PI effects
on Twitter I put them online today or
tomorrow the interesting things you can
also Google this is a good up get up
repository of course there's a great
user guide which you can read at like
I'd say an hour or two and you will know
pretty much everything there is to know
about j-unit they're active on Twitter
and also I write articles on my blog
that being said I'm not part of the team
I'm just interested in the project ok so
now let's start with the basics and the
basics will be how to write and generate
five tests and what I will show you now
is actually valid Jenny five tests and
they will look evenly similar to what
you might know from journeyed for so
similar in fact it might not always be
easy to spot the difference so I need
you to do that so this for example is a
very genuine five test what's new and
you have to scream so I can hear you
know public exactly see it just package
invisible
oh yeah somebody that's a package right
what's new here
static No
so these are the life cycle methods
right it's different names right before
each they used to be called before and
before class notes before each and
before which i think is a nice addition
a nice change sorry too because these
names are less technical okay what's new
here disabled exactly used to be ignored
now it's disabled but it does exactly
the same thing except that it takes a
string that you can write in while
you're disabled it I think ignored
didn't do that so that's new what's new
here
say I'm done Friday so do you think it's
in the public API and no lost most
likely not but we can create that in a
way that fits seamlessly into the whole
thing and we will see later how that
works what's new here exactly the
parameter order this is a really small
detail but I like it so much because it
always annoyed me that this was going to
beginning the message would go in the
beginning and then you know sometimes
you have one sometimes you don't and
then the arguments that you really care
about that jump around like crazy so I
think that's a cool change this one is
so easy even I can do it you cannot
create lazily create the message
this can be an interesting optimization
if you have in the failure case you want
to create a very expensive message you
usually would do that on every run even
though hopefully the test would really
ever fail now you can defer that and you
just pay for the lambda there which is
basically for free and you can evaluate
the actual message when you need it
what's new here so at all
exactly a certain L so I can hand it a
couple of parameter sorry a couple of
lambdas which do their own assertions
and it would execute all of them and
will give me all the results so before
if I would have just done this without
the land that's just decisions then the
first one would already fail because
it's City I'd not see and I would never
see the other ones this now is different
with assert all you can do that it looks
like this so you can see all the results
which comes in handy in many situations
what's new here
so it rolls exactly you just give it the
type of exception you're accepting and
the method you want to call and it will
fail if that exception is not thrown and
it also returns the exception not yet
and miles don't do it doesn't milestone
three it will and you can use that
exception that is returned to make
further assertions you used to do this
in jail unit four by writing expected of
there but that's gone as well as time
out both carnauba realized with
assertions which I think makes more
sense because it is more precise
especially expected exception at the
problem that you never knew where
exactly the exception was coming from if
a different method would throw the
exception you were expecting then you
test my pass for the wrong reasons
what's new here lest it what could it
possibly do yeah we need this exactly
well that's what it can be used for so
what it does in the first place is it
just executes all the tests that are in
here or in here as well so that was a
runner to do that in Jaina for now you
can do it out of the box so you can
organize your test basis in inner
classes test cases sorry in inner
classes and you have the great advantage
of being able to use life cycle methods
at each point here to gradually provide
the state you want to let's look at
something different display name well
that's kinda obvious right some kind of
display name let's see how they work
together this is a screenshot from the
for me tell you J which is currently
supporting chain of five ignoring this
for a moment the Jaina Jupiter line
there you can read it pretty clearly
testing a stack a stack where new after
pushing the element is no longer empty
and what happened here is that this each
of these new nodes in this kind of
dragons tree is a new nested test class
and the display name was used to provide
a nice display name so if you introduce
a detail
style programming and testing this
should be really great for you what's
new here
somebody else yes the parameter exactly
well I call it my server to make
perfectly clear this is some server that
I implemented a class that I provided so
how can the test have parametres how
would Jane it know which which instances
to provide and we'll see that soon so
whatever you seen so far in this in the
basics we've seen that life cycle
methods work black before well it hasn't
seen it I promised you that the case
they just renamed many details were
improved like small things like public
that we don't wanna have to do which
were like kind of annoying or weren't
perfect like expected exceptions nested
and display name make a really nice way
to structure tests in a very readable
way especially on the tool output
parameter injection we haven't discussed
how that works but we saw that it never
exists and we haven't seen any lambdas
so far which is a little bit
disappointing because you know Jane is
five used to be called a nerd lambda in
the beginning so where are the lambdas
since I'm disappointing you in the 445
minute version of this talk will now go
into dynamic tests and how we can use
that to prove write test with lambdas
unless it's just a 30 minute version so
we're not doing that so that's all great
right we sign a couple of new things but
the subtitle of the talk is next
generation testing and this is more like
a nice improvement testing so we have to
see how well my this promise comes in
let's look at the extension model when
you think about Jana for how was it
extended there were two mechanisms the
first one was there since 4.0 which was
runners a runner had the advantage that
you could do everything with it and had
the disadvantage that you kinda had to
do everything with it you could extend
some existing class but you had to do a
lot of coding to many only make a small
change in what the test actually does
but the more limiting problem was that
they could only have one runner at any
time so if you wanted to use the spring
runner and the Mojito Runner and the
parameter ice runner and the nested test
classes rather than the other flock you
can just use one of those
so in Jenny
four-point-seven rules came to the game
so the idea was that you can use rules
you can with many of them and you can
apply them like this which I guess most
of you already seen and there are much
more lightweight weight which means it's
easier to implement them but they were
also limited in what they could do
it's not entirely precise but I think
it's a good estimation to say you could
mainly do before after kind of things
like before a test was executed and
after or before a life cycle method when
I succeed execute it and after but you
could not model all you wanted to do
with that which meant that there are now
have two extension models and neither of
them is all-encompassing you have to
choose which one you want to use as an
implementer as some of implements an
extension both Kamath serious drawbacks
and compositions among rules were not
always perfect so while the extension
model in jenefor is generally good I
mean change for it's been around for a
long time there is room for improvement
and in general five a different approach
was taken the idea was to have extension
points over features which means let's
not implement all the features that we
want to have as a core feature but maybe
design extension points to such a degree
that we can implement some of our own
features or with via these extension
points and this is exactly what they did
so quite literally jan 5 has a concept
called extension points and this is them
and there will be a test afterwards so
you have like three seconds more to
memorize them three two one go awesome
so it's not that important which exactly
they were there's an extent well we'll
take them again so we can see some kinds
in some things you might know like
before each you know there's a-- before
each method so corbett might make sense
parameter resolution we saw that you can
someone provide parameters or an
extension point there makes sense but
what exactly is an extension point
that's pretty easy it's an interface for
each extension point you have one
interface and usually they only have one
maybe two methods so really focused on
one specific thing to do that well and
then you have to implement the extension
you have to you know provide you have to
assess the call
text in which test is run and you can do
that because Janet five will collect
everything well everything that you
might meet and put it into this kind of
test context which you see here and then
it calls your method with that so when
you implement for example the before
each callback
you just have to implement this one
interface and adjust it for implement
this one method and Jen if five will be
gathering all information put it into a
context and calling a method with that
and if your extension is not totally
trivial
it might want to do a might want to
interact with several extension points
so you just implement several interfaces
let's have a small small example let's
say one of benchmark tests so for each
test method you want to write the test
that elapsed to the console how exactly
do we want to do that well what I wrote
down down there is pretty technical
already it's extremely close to the
implementation before a test execution
wanna store the laps as a story
sorry store the launch time and
afterwards we just print the elapsed
time that's kind of trivial right and it
is when we look at the bank's market
benchmark extension it's really simple
we implement these two interfaces before
test execution and after test execution
we use a field to store the launch time
which by the way we shouldn't there's a
mechanism for that we're not going to
cover that here but I will show you a
link later where you can look this up
and then we just implemented two methods
and before test execution is extremely
simple you just write the current time
me list to the launch time field and
then after test execution you have to do
something which at least resembles logic
you have to actually subtract the launch
time to computer the elapsed time and
then you print the message and because
it's fun we use something from the
context in this case the display name so
if the test that was run was called my
full bar test then the output would be
test my fubar test took a no hundred
milliseconds that's how you can access
the context if you want to okay so you
remember this right and I already kind
of gave it away that this is not really
in the API so let's see how it works
to implement something that this a
tests there are two extension points one
for the whole container meaning the
whole test class and all the nested
classes and one for individual tests
we'll look at the second so the test
execution condition is the interface I
have to implement evaluate is the method
I have to implement and returns the
condition evaluation result which had to
cut short to make it fit on the slide
also again we get the text extension
context as before but we don't really
need it here this informational
implementation is also pretty simple we
just check whether it's Friday and
however that is implemented and then we
use the static factory methods on
condition evaluation result either
disabled or enabled and you know if we
turn this ml you can see what this is
going Jain five Kostas methods sees that
the return result says I'm disabled and
then it will just not run the test and
if we do this on a container which is
very similar we would Coralie not run
any tests in the whole container Connect
example you talk to our parameter
injection powers Network again there's
an extension point parameter is over
this is I think the most complicated one
because it has all of two methods so the
first one is supports whenever Jane it
encounters a parameter in a test method
it asks extensions like do you support
this parameter type or in general to
spot this parameter not only the type
through support this parameter in this
case our extension is aimed at the my
server type so we just check we get from
the parameter context the parameter and
check its type and see whether it's a my
server class where we should do some
thing which works better with subtyping
but you know whether you get my meaning
so in this case if it's a minus or we
say yes we support it and then later
Jane it will ask her to resolve this
instance and give it actually an
instance of my server the interesting
thing here is that this parameter
context contains a lot of other
information for example you can use it
to access annotations either on the
parameter itself on the test method in
this case we didn't need this because we
say we create all the my server
parameters but imagine for a moment how
a mojito extension would work mojito is
able to basically
every kind of type but it shouldn't mock
my server because maybe I want to do
that so if I have the mojito extension
in plain and we'll just say look I
support everything I just returned true
here then it would always be more key to
providing an instance which I don't want
so the very basic mojito extension would
just do something something different it
would require the user to add an add
mock annotation to each parameter and
then here it would check is the
parameter I'm supposed to support is it
annotated with a block and if it is I
say yes and if it's not I say I don't
support it okay so far we only talked
about how we bright extensions now we
also have make Jane it aware of the
existence of this extension so it can
actually call them and this is the
mechanism the basic mechanism to do that
just extend with write down your class
and you're done
I think spring does something similar
but that's not it's not nice right it's
very technical and it's not a good way
to transport the information so what can
we do we can use meta annotations
there's my prescient experiment of
looking how often I can put annotation
on the same slide like one two three
four five I think if you don't know
about meta notations in Jane s or in
Java you cannot inherit from another
annotation so if you want to say my
notation it's like that one over there
you cannot inherit from it which may be
do with types but you can do is you can
apply that annotation on yourself if
it's written in a way that that works so
your meta annotating yourself and if you
ever written an annotation you know that
for example you have to provide the
retention policy was also method method
meta notation because retention policy
can only be applied to other annotations
so applying notations to other notations
is nothing nothing new the interesting
part is that genuine five supports this
mechanism by checking method notations
so whatever chain of five looks for
specific notation let's say it looks for
the attested notation it doesn't simply
look at the method and say is this
imitated with a test no it looks at the
method looks at all the notations it has
and looks at all of their notations and
their notations and so forth to
exhausted the whole
tree basically but it's a subtree it's a
forest but anyway till it explore all
the possible annotations that are on
there directly or meta annotated and
evaluate that set was really cool
because that allows us to create our own
annotations that fit seamlessly into
Jane and five this is how we do it
the first thing up there was our disable
on Friday notation we just created and
maybe we need some other meta notations
here but the only one that is important
for us right now is this extended extend
with so whenever Jane of five sees the
disabled on Friday notation it goes
looking for more invitations on there it
finds the extent with a notation applies
the extension and that calls the
extension at all the interesting parts
in the life cycle so we can use it for
other kind of stuff let's say for
example you're running off integration
tests which many projects do so it makes
maybe it makes sense to identify them in
a different way in this particular
instance we can take them the feature
we're not going to explore but it
largely means that you can tell Jana to
just run things that are tacked or not
tagged with that particular tag so for
example you could have one run which
runs all tests which are not integration
tests not tagged with integration
another run which runs only the text
only the ones tagged with integration we
add a test to the integration test every
extended with our benchmark extension
because you know then integration tests
are slow so I want to benchmark them and
because we want to maybe use the mice or
a parameter or a lot we put on that
implement that annotation as well sorry
that extension as well and now we can do
all of this it's really cool now we can
just write a normal test test login for
example and we just provided with the at
integration test a notation Jane we
recognize that it's a test to recognize
that it's tacked it will apply our
extension and will actually just work
blah blah if we just work which is
really nice way to write our own
extensions in a way that you can't
really tell the difference they don't
stick out like a foursome a sore thumb
also this one maybe because integration
tests okay so summarizing extensions
we've seen that you have more
flexibility because of me
extension points and they compose well
they're pretty well customizable due to
meta notations but left are some small
details which you can find behind the
link again how is this next-generation
testing it's just a nice way to use Jane
at five so let's go further and look at
the architecture when you look at the ER
level of Jane at four then you could say
that it's not even architecture it's
just Jamie for with hem crest hanging on
outside and this artifact is used by
everyone you wanna write a test as a
developer he used that one you want
extension you use the same art effect
you're an IDE or build tool you want to
provide Jane it features same artifact
there's no separation of concerns and
this is not just something to whine
about it's actually had a lot of
negative impact on the project because
our tools provide us with a lot of
awesome features but the Janie API was
not always powerful enough to provide
them so what do you do if there's some
you know the informations in there but
there's no API to get to them I use
reflection and this was used to an
extent that even individual fields in
special classes were reflected over
so even renaming that one field would
break tools you can see you as a
maintainer of such a project that is not
the nicest way to program and you can
never make any reflections of internal
stuff because somebody might be
depending on it since the tools are
important part of Jane and success you
might also not just want to say well bad
luck for you guys just find another way
so nothing was really safe tools were
bumped implementation details and
maintenance and evolution were made
harder than there should've been and
this kind of maneuver Jamin fall into a
dead end
Gianna's link which was one of the
initiators of jn5 rewrite said that the
success of jane as a platform prevents
the development of gender as a tool the
tool that we were test against could not
be developing mmm well enough because
the platform that Jane has a platform
also ubiquitous that everybody
integrated on it in a way that prevented
further development so Jane did five
took a different approach from the
beginning on the idea was that we need
these concerns one have an API to attest
against you want to have a mechanism to
write describe to discover and run tests
and want to have an API for tools to run
these tests when you look at this you
might wonder which API on which
mechanism exactly because I mean the
tools should always use the same API but
I mean Jane 5 has one API and Jenny 4 is
a different one is there some potential
there and indeed there is the mechanism
to discover and run tests is further
split apart you have a specific engine
for each variant of tests so we have an
engine that runs Jane 5 tests an engine
that runs nearly four tests you have an
API for that and then we have something
orchestrates different engines so when
I've been saying Jane at five I've not
been lying but I've been imprecise
that's just a umbrella for three
different sub projects we so far only
talked about Jana Jupiter which is the
new API and which has an engine that
runs these tests as a test author you
will never see these engines then this
Jane at vintage which does the same for
Jana for tests
so the Jane for art effect can be used
to our test against and the degenerate
vintage engine can then run these and
then you have the platform which is new
that's never been in Jamie before this
concept you have the platform engine
which is the interface that these
engines implement you have a couple of
other ones but you mainly have the
platform Runner which is the API that
tools used to run tests so this is how
that looks you would write your tests up
there against the Jenny Jupiter API down
here are the tools they communicate with
the junior platform runner so that for
example that Hill had run all the tests
in this package then the runner goes to
the engine implementations and tells his
Emeril Engine implementations to run all
the tests in the package and then each
engine looks into this package and looks
for tests that it understands
gen-5 around Jane and 5 tests for
example so that means now there is a
clear separation of concerns with API
for developers and API for tools well
that's kind of nice right but we're
coming close to the end so where's the
next generation I promised
I think this is it this is the important
part because this opens up the platform
this means that whatever you want
whenever you have a new kind of testing
thing that you want to try out that you
want to implement or use an engine for
example you want to run Jamie for tests
within the architecture create an engine
or don't because it already exists test
Angie you want to let's have the same
exact support as Jane it write an engine
or whatever you can think of whenever
you can come up with write an engine and
runs within the jn5 platform and gets a
lot a lot of the pool support that janet
has so this what what this would be
would be looking like so just to make
clear the test Angie part is totally
made up just as an example but you can
see here how they integrate these
different engines into or implement the
same interface the registers themself at
the service loader and the random will
find all of these and then call them so
let's let's look into the future let's
say all tools that we know of build
whose all the ideas they have native Gen
5 support now the tools are discovered
decoupled from implementation details
and they can support all frame routes
almost equally were equally well there
might be some details were it still not
possible but largely they can support
fully support all of these tools so
whenever you want to create a new
framework or using your framework you
have much higher chance of getting good
to support because before if you write a
new framework you have to either
convince people to use it without food
support which is hard or write plug-ins
for all the tools which is hard or
convince the tools to maintain errs to
integrate your framework which is
unlikely because nobody uses it so now
you have as an develop of a framework in
the use of a framework much higher
chance to start with a good support of
the box and I think this might lead to
new generation of testing frameworks and
the success that Jane had had as a
platform becomes available to everybody
and I think this could herald a next
generation of testing on the JVM this
could mean that we see much more
creativity when it comes to writing
testing frameworks and trying out
testing frameworks because it's much
easier to convince you're technically
door somebody asking a company to use a
tool that at least has frame
their lease has got to support so
summarizing the architecture with a
clear separation of concerns API for
developers tools and also new frameworks
to implement and the platform opens up
and can you can have to support for
everybody and that's a little bit more
to the store which we're going to cut
here I said we after we look into the
future and imagine J need five supports
already there we're not quite there yet
so let's spend the last two minutes
looking at where we are actually when it
comes a to support right now this is of
course moving target so this might
change quickly if you want to write
tests it's really easy you just pick up
this artifact in your start running
tests now if you're concerned that some
of them might fail at some point you
might want to run them as well and then
the kind of luck unless using IntelliJ
which has good support so perfect but it
works fine the other tools not that much
I didn't find an issue on the Gradle
issue track and NetBeans issue tracker
all that information is like a month old
maybe should check again and maven
eclipse there are issues there in both
issue trackers and there is progress
being made it's just not there yet so
assume you wanna you have written some
general five tests and we'll try them
out right now how do you do that apart
from using IntelliJ you have a couple
other choices actually I said earlier
how it can run Jana four within Jana
five you can also get go the other way
around you can never generate five tests
that annotated with this genuine
forerunner and that runner understand
gender five and runs three or five tests
and you can also do this for a whole
package and all sub packages which is
really nice when you do that you can
just say look in this package are all my
Gen 5 tests you put this class somewhere
in your code gen 4 will pick it up the
general platform Allah will be in charge
of looking through these packages and
running all the gen 5 tests that works
quite nicely gonna run them with build
tools there is a Gradle plugin and may
even offer a provider but these were
implemented as proof of concepts by a
Jana five team these are not adopted yet
by the maintainer of the bill tools but
actually maven is now the maven shofar
providers now being moved into the maven
project so this might change soon and if
all that is too fancy you just want to
console there you go there's a there's
an artifact for that you download it you
have to figure out a little bit with the
dependencies and with the jars you have
to put in there but then you can do this
you just say look these are the paths to
all my compiled test classes run them
all or run a specific one and the cool
thing about this is it already
understands unit 5 pretty well because
it was written for Jaina 5 so get nice
colorful of output with a lot of more
information this is actually the most
advanced integration because it's just
printing through the console everything
else is still losing a couple of
information for example it's a test
names or something ok so two can set up
you can start writing tests right away
only intelligence native support I think
running if using different tool running
them with engine if force you could
compromise times up good because one
last slide so we've seen a new API with
some incremental changes the Jupiter API
which changed some details a lot of
difference actually which i think is
good we have looked xx tension model
which i think is promising and going the
right way still not perfect yet but a
lot of issues open and there will be
addressed I'm sure how the architecture
opens up the platform and while to
support is not there yet it might be and
this would be a stronghold for Jane 5
good to support for all the other
frameworks as well so for you in the
beginning I want to bore you now I'm
Nichola you can find me on Google+ if
you want to on Twitter or this is where
write articles and if you read more
about Javas I'm an editor for siphon
Java channel we recently opened up and
there's interesting stuff there
pass particularly about Gen 5 in Java 9
and with that I'm done thank you very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>