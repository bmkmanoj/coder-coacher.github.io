<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Javaslang - Functional Java Done Right by Grzegorz Piwowarek | Coder Coacher - Coaching Coders</title><meta content="Javaslang - Functional Java Done Right by Grzegorz Piwowarek - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Javaslang - Functional Java Done Right by Grzegorz Piwowarek</b></h2><h5 class="post__date">2017-03-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NxbatgLY3V4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well it's a last session for today so
I'm glad that they're well I hope there
are so many of you because I don't see
anything because flight so let's get it
started my name is driba Spielberg I
come from Poland and basically I work as
a software developer in a software house
in Poland talk and besides this I am
retired professional player yes this is
a thing I'm also a musician in like
bands that basically of my other
musicians listen to okay if you really
want to find me anywhere there is the
only one Twitter handle which works
pretty much everywhere okay so before we
jump right into the main session how
many of you have been today to all extra
livestock about functional data
structures okay I don't see anything
because of like so I I'm not assuming
that everyone does raise a hand okay so
if you enjoyed this there there will be
much more functional goodies coming on
from here he was talking about only
about one very big topic about
functional data structures but obviously
there are much more things that can be
brought to Java to make it more
functional okay so few years ago in 2014
there was a Java 8 release which was
well pretty spectacular okay because
suddenly after so many years of pure 00
p and java 8 was getting lambda
expressions and some other tools that
were known from the world of functional
programming or into something special
okay some people hated it some loved it
but anyway everyone anticipated it so
yeah it was supposed to be something
very special something very good and
many people were actually even saying
that this is this the Java 8 is
functional now well but if you have a
deeper look you can see that the
function f of data it is lambda
expressions and well to like optional
streams computable features and
not really much else okay so actually
some people over there they were
claiming that even though the functional
aspect the aspect of those two that were
introduced well it wasn't perfect okay
to start making jokes that the testimony
to Marvel applied and the whole
functional aspect of Java is just
writing code like this like using
streams for basically querying simple
filtering of stuff so after some time
people started noticing stuff so first
things why only three functional control
structures when I'm saying functional
control structures I mean stuff like
optional stream future comfortable
future because poof like Scala they have
to get much more okay they did try
either validation lazy and some other
stuff why not bring this stuff to in
Java if you are bringing some functional
truth already there's there was no
concept of memorization introduced don't
worry you don't know what it is we are
getting straight into this there was no
lifting on functions and functional
interfaces we are getting to this no
pattern matching which is very common
tool used in functional languages like
Haskell list Scala and no couples okay
after so many years we still need to
write our own topple soldiers use one of
billion github projects that contain
status well first time regions still not
here and even the design of some classes
between tools like optional for some
reason they were not made Sarah Sarah
Sarah table and he terrible and guys
from Java they have very good
explanation for this well the
explanation go something like well it
was not intended to be well I don't
really buy this because it's it's not
that problematic but let's say that well
it's a good explanation at iroko you can
denied the biggest problem for me was
that of course javab javon needs
to be backwards compatible all new
releases needs to be backwards
compatible so if we had like AP is all
the api's they still need to stay there
and we can only add new ones and this is
problematic because now we are mixing
few different approaches together and
there is no one convention on all along
the code and it becomes problematic okay
because we might get right miss
something another thing is when people
started playing with functions lambda
expressions they notice that if you
encounter a checked exception in a lamp
does body it's super painful because for
for some reason you can you need to
manually try and catch it and basically
just swipe it under the carpet or just
repackaged into an untracked exception
it happens because all those functional
interfaces that were introduced in july
eight they don't have frost cause in the
method that represents the lambdas body
well it's problematic because if you
have like very long stream of operations
along long chain of operations and let's
say that you are using some external
library for mudafucka modifying
something in there and each of some of
those methods flow checked exceptions
the code becomes ugly okay because
suddenly we're try catching everything
but the real thing is that we are only
worried about the fact if there is
exceptional not but we are going to try
catch n n exceptions in the worst case
also there's something like state
pollution what it is people were started
having problems with the fact that you
have so many names for functions in
India height and they were introduced
function interfaces on the basic one was
called function but there would
therefore different specializations of
it so you had function by function
predicted by predicate consumer by
consumer unary operator binary operator
and specializations for as a mother
stuff okay um it was Republic okay
because if you were browsing new API is
you were encountering goes a few words
and it will try to process
and obviously even some very simple
operations could have been done in a
much easier way okay because such thing
cooperation as mapping elements in a
stream still contains a lot of
boilerplate code that could not could
not be there well probably the list is
could could be much longer let's go
further so Before we jump straight into
Java slang and we'll see what the wrong
gig gives you let's have a look at this
simple signature okay so the name is not
very meaningful we have a list of inputs
list there there's an output a return
value of course and since they're there
is a list on the input and even the
output we probably all well we've been
cutting a lot so probably we have some
kind of intuition about what can be done
inside it okay let's have a look for it
for a second okay and now I actually
tried bother to implement it let's see
what's inside okay so I bet you didn't
expect this okay so what's happening
over there I tried to put a lot of bad
product practices into implementation of
this class so you consider that we are
modifying some in some inner state of
the object we are modifying some
external state we are modifying param
throwing some unexpected exceptions and
pretty much taking some values from the
outside world that were from the values
that were not declared as inputs of this
function and also missing I'm pretty
much everything around us well and this
can be problematic okay because the
reality is that when will be erratic
methods even simple methods we don't
have only declared inputs and declared
output okay reality is that we still can
have values hidden input and hidden
outputs okay so if there is like an
instant if your instant taste of your
object for some reason influences the
possible result of your function of
this this is a hidden important because
it is like this same with a global state
okay if this changes the possible output
it's an input same with outputs imagine
situation that when you mess up some
internal state and this influence is
another results if you heat input of
another method and this change is a
mutable global start we change with some
other state froze exceptions okay it
becomes very very cumbersome very
unclear and imagine now what happens
when we are trying to compose solutions
with methods that we have out of here in
inputs and outputs okay suddenly at some
point this will just explode and good
luck with debugging this so in
functional programming what we are often
aiming for is a situation where when we
are defining something defining
functions we we defined it in a puree
which means that when we have inputs and
outputs so there's only they are on
their own direct relationship between
them okay so if we if we accept two
parameters those are the only things
that can influence the output so
basically in such case we have small we
are building small predictable box and
now when we are composing our solutions
from small and predictable blocks well
usually it works more often than stuff
the desk as out of hidden stuff inside
it so here I like to say one thing about
there's a common misconception because
if you go to some message boards and
stuff you all for your folk and you can
you can see many times there are people
discussing and basically assuming that
what defines a functional programming
language is the presence of lambda
expressions well it couldn't be further
from the truth because obviously under
the lambda expressions is something nice
to have in function languages actually
it's all about sending being able to
pass behavior some way and guess what we
are still able to do this in previous
Java releases okay because if you want
it dusted started afraid we still were
able to provide it with a anum anonymous
implementation of a class of an
interface and end to work is ok so it
was still some kind
like cumbersome way of doing lambdas
that tilt worked okay so actually I
found a really nice definition there are
many definitions about functional
programming but this one what I want to
focus on number during this talk is the
functional programming is about writing
few functions about removing hidden
input and output as far as you can so
that as much as so much as much of our
code as possible just describe a
relationship between inputs and outputs
this is what describes those perfect
small blocks that we will be using for
composing solutions that that just work
eventually so by having small blocks
predictable we are we are hoping that
that stuff will work but there is also
what what we need to say right now is
that there are two very common concepts
that are related to this which is
immutability and reversal transparency
so obviously when we have this direct
relationship between inputs and outputs
but it wouldn't be very useful if we we
don't have a determinism okay that which
we call a function with certain
parameter and that the result of this
call can change okay so being refresh or
transplant is super super important
which means basically is when we are
calling this function with the same
parameters we always get predictable
results well not predictable always the
same ok this is super important so
Prince what is that that week after
creating objects or functions because in
functional world functions are objects
to those should be immutable and
unchangeable because in this way we are
making language we are stripping
language from many possibilities were
many possibilities where we could make
mistakes and if we manage to build the
solution that works out of it well it
usually works so another common
misconception is that Mario is here no
ok we can we can you can you can talk
about it so basically there is there is
this another misconception that
functional programming it's all about
just throwing away writing code without
side effects with ability well but
actually the world
around us is there are side effects and
meet ability everywhere so it's not
about just getting rid of it but we want
to abstract things out we want to
encapsulate everything in such a way
that we won't be dealing with direct
problems that those things cause okay so
let's start talking about actually how
to how to how to implement this in
everyday life but becomes problematic
okay because we know that functional
programming exist without lambdas like
in divide well there was a guava after
all with some functional concepts
implemented but it's really hard to do
to write functional code like this if we
don't have right to for this and if you
have a look at Java collections API well
it's one of the most important building
blocks of Java okay it's all in all IP I
seats in external libraries you are all
there are contracts that were the
interstate past instances of those
interfaces and they have methods like
add remove clear and if you look at what
they return they they either return
nothing okay and I return boolean or
some other metadata that tell us if if
operation was successful or not this is
problematic because we do if we want to
use immutability in the context of
collections well going to design am
indeed a different way well obviously we
have something like immutable
collections well amitabh of wrappers for
collections in java but what happens
when you call and add or remove nice of
them you get you get an exception and
this is not how you want to design it so
this is very problematic aspect and if
you are dealing with surf stuff you use
some time thing to do problems that
usually would not be there so for
example this is a very common problem if
you have a set and if you want to put
some objects in there and if you modify
this object suddenly outside this set
will lose the identity of this and good
luck with the bugging this okay because
about such stuff we might not be
thinking consciously all the time when
we are coding so the Java slang
is basically enough answer to all those
problems it provides the right tools for
the job if you really want to start
playing around with functional code so
what Java song is well yeah it's pretty
complex structure but at the end of the
day is basically set of new functional
control structure so tools like streams
or stream optionals and so on and the
whole new redesigned collections API
this is fully persistent and immutable
so if so if you went to all X talk now
now you know or what it means also we
got like couples finally and the new set
of functional interfaces data will on
steroids in comparison to what we got in
Java it so basically there are free
building blocks of java slang and there
are few words of disclaimer the java
slang is going for small revolution
there will be small happy changes those
are now in alpha version so now today
i'll be covering the stable production
version that anyone can use f alpha is
not stable yet so the first thing in
Java 8 we've had functional interfaces
but unfortunately the RIT of them was
maximal to RIT means the amount the
number of parameters that were accepted
so if we encounter situation where we
had more than two well we need to write
another interface the other thing was
the the and some non-intuitive names of
functions so what was introduced into a
song they were created new new
interfaces in a very predictable manner
because there are names okay there is a
function and there is a number in a funk
in the name that signifies the RIT of
function so everything is super
predictable because we are representing
everything by function and if you know
and if you know what are you looking for
it's quite easy because if you're
looking for five parameters you're
writing typing function five okay but
imagine what would happen if you follow
the convention in Java it because there
is function by function well and that's
all but if you want to go further site
through try function quad function Quint
up well my English
to break down at this point anyway let's
go further so those are just simple
functional interfaces but there were
problems with checked exceptions if you
remember so for this special reason we
got a set of like another functional
interfaces which are well almost exactly
the same like the one we I talked right
now but they have those frost clause in
the in the method of functional
interface so if you ever want to use on
some kind of if you've ever encounter
some kind of checked exceptions in there
you can use checked click functional
interface and you won't need to try try
and catch it try to catch an exception
what's also super super nice that you
can compose them together apply function
composition to them well this sector are
you same thing that was available in
Java 8 but besides this we have also
something I called function lifting
because if you see if you have a check
function we are not always sure we if we
get result or not okay there are certain
combinations of parameters that might
result in a situation where we get an
exception well which means there is no
real value computed for the set of
parameters and lifting can change at
rank function into normal function we'll
get to this in a second there's also
carrying implemented and memorization
which is which is my favorite thing over
there let's see some examples okay so
when we are talking about lifting I
created here a function that froze in
this case an unchecked exceptions when b
is 0 and let's say that we want to lift
it okay so make sure that it never
throws exception it's super easy because
we have static kutta method that allows
us to achieve this but what happened
over there if you can see that the
returned value change okay because in
the first example we had an integer but
now we don't have a result for every for
every for all combinations of parameters
so in this case we can represent the
result as an optional as an as an option
okay that which returns and optional
with the calculated
value if everything went correctly and
if there was exception the option will
be empty okay so in this case we can
avoid having exceptions and when prone
in lambda another fun thing to do is
caring which is basically changing a
function of arid of a higher RIT than
than than one into the function of
parity of one it it allows view it but
it's done in a such a way that function
instead of returning a result it returns
another function with a smaller arity in
such it's very easy to create and is
much easier to understand if you see an
example so you can do this super easy
way because there is an instance method
called carried and as you can see when
you do this suddenly the our new
function our new result function is of
RT of one and it will turn another
function this time another result so
what does it give us and sometimes it
makes super easy to apply partial
application so suddenly let's say we
here we had a function that was
representing summing of two elements but
by transferring this converting into a
carriage version now it's super easy to
apply partial application and pretty
much fix one of the parameters over
there so now if we take a carriage
version and calculate the value we get
another function but this time in this
particular context this function will
will not be a some anyway well it won't
be a sum of two parameters to be some of
one parameter which is basically in this
case it means there is a function that
always add a two to your result so if
you are abstracting out some more calm
more complicated stuff you can use the
form of functions for easy partial
application and he comes the fun part
about memorization so a few minutes ago
we talked about immutability referential
transparency and so if we know that
basically we operating on something
that's refreshing transparent we can
after calling a function and getting a
result we basically know that this
result will will will never change so
why bother with recalculating the value
all the time if we know it will all be
the same so we can pretty much just cash
the results and always keep returning
valued from cash and this is what the
motivation is about after you evaluate
certain function or expression for given
parameters let's scare those results and
each time in the future just return them
from cash and this is what memorization
is doing so if you want to convert your
function into a memorized version of
course it's super easy you have an
instance method memorized you just call
it and as you can see the the type is
totally the same as in the task so only
the like implementation changes so let's
have a look at a simple simple example
well example is very bad actually but it
really so let's create a function of
math.random ok random is totally
opposite of something that we would
consider a friend shot transparent ok
because we expected to return the
different value each time so let's break
it ok so we can create a memorized
version of random and what's happening
over there is we call it first time and
after calculate getting their first
value it gets certain Akash so when we
call apply again and call the function
again the value gets returned from a
cash and in this result we we are
breaking the random function then
basically makes is making it a function
it always returns the same value from
cash ok so that we all for functional
interfaces let's go two tuples CC cells
as something that you can consider like
an inanimate object ok is like a special
way that allows us to group some some
objects together in situations that
doesn't really well you might think that
some situation don't really deserve new
class to be created only for example to
stirring two values together so you can
do this in a super easy way with tuples
of course it follows the conventions
using java slang so if you want to
create a new object everything off
method and sure it is well obviously
it's immutable as everything in Java
song and it has also much more aware
nice methods for interacting with it so
for example we have method map no you
probably know this from optionals and
streams from Java or from other
functional languages so it offers the
same convention you can provide your
function that will map the values that
are inside obviously that additional
methods like transform that allows you
to basically take a virus inside and
calculate another value well and stop
even like converting the whole the hotel
into a sequence in weedy terrible
another one of the most well outside the
most important building block the whole
Java flunkies is a mighty value which
represents a pure value that kind change
its each state in the vast lank you have
you have also option which is which is a
value we have tried lazy and either
future validation and what's super
import so what's super nice about it
that if you traverse the code type kirky
you will notice that although those that
all the value interface at some point
extends an interval this is super super
sentai in some situations because
basically all of those containers like
option option can have something inside
or not try can be successful or not lies
you can be initialized or not future can
have already value or not validation to
be validated or not everything have
those two states and those can be
considered intervals okay then consider
collections or of max of one element and
what's super nice is that to collect the
hoke classes from collections API they
are their values to which means
outscored they are immutable and they
extremely terrible so we already know
that this is this is the point this is
how you can mix it with normal
collections idea because this is the
only common denominator that you have
between Java Frank and collections ipi
the terrible
so let's have a look at some examples
this one is probably well we would be
quite quite worrying for you because
most of you probably already know
optionals from Java it but just just to
refresh how it works you put some value
inside optional you put it in this up
computational context of new ability or
not and now you can declaratively
provide functions to the two option that
will be performed that signifies an
action that we performed on values that
are inside and at the end we can just
handle situations where they were in
turns up this nothing is inside well so
so far so good it looks just like in
July it but there are some situations
like have you ever tried to filter the
list of optional and try to find only
those those present values well this is
how we do it you need to type these to
the stream then filter out and find only
values that are that have dloan the
optional that are present well you can't
extract it in one run so we need to add
another map call and now extract
explicitly value from an optional well
and then collect well well it's not not
that bad but I always had a feeling that
there should be like an easier way for
doing this okay so in Java songs you can
hear you too you can benefit from the
fact that option is an interval because
when you are a trying flat map in
incorrect context of streams it accepts
another sequence of elements okay so for
example if I list of lists we can
flatten the structure using a flat map
method and this is what's happening here
because we are treating an optional as
SN interval in this context we are
chilling with the container which is
empty or not so when we have a list of
optionals when calling flat map now we
are basically just collapsing the whole
structure were empty optionals become
nothing and optional it have something
inside they become only do the single
value so as you can see this is super
also and I was given the stock sheet and
like two months ago and someone noticed
that this is flat map or recently and I
can condense it to the right over this
okay yeah yeah so this hash okay so try
it's another concept quite similar to an
optional in optionals we're dealing with
no ability button try we are doing the
link with exceptions so we are what we
are putting inside a try is something
that can produce an exception and
handled it in a knife and in the clarity
way so for example if you have well
let's create a new uri the you right
they love throwing different kind of
exceptions so we are throwing the whole
call inside and wrapping the internet
try then we can use this very similar
API so case we have instrument optionals
you can also use map methods for telling
the coterie what should be done with the
result of the top eration and then in
the last line we can specify the kind of
situation where something that happened
and exception appeared another nice
thing to have is a slic the api is it's
a similar as you can guess it all falls
same convention so what it is is a way
of representing a lazy lazy computation
and also this is super nice because you
can be lazy and now you can pretty much
operate on and using the same map map
filter methods so what's happening over
there we have lazy off and VLC it's not
a video player is just a very long
computation okay and in this case we are
we are creating lazy of the result of
VLC method and then perform calling
object to string and string to uppercase
what's super important now is that we
defined like we expressed our will we
express a real what do we want to do
with the result of the operation we want
to to string it and then to uppercase it
but other thing will be performed when
we actually try to reach the value by
performing a get method
well so we are bringing we are coming to
functional data structures well
functional data structures well at you
if you went to all X talk you know that
there are purchasing immutable and I
also saw also to keep adding that they
have preferential transfer ential
transparent methods to like the just to
remind viewers of course this is this is
super big topic and if you can just go
through a revised or like stock but the
whole idea over there is that well it's
quite easy to create an immutable but
it's very hard to create something
that's efficient because imagine
situation that if you are very in your
just copying in a very simple way you
have a list you need to add element and
you can't modify it you need to create a
new new version of it and so you're just
copying the previous one with a new one
what if you but what if you want to add
a 1000 elements okay although you get
all keep creating another and had their
elements infinitely and this is
problematic well so this is where
function later structures came into play
persistent collections so they are not
only immutable but they are designed in
a special way in such a way that you are
reusing the previous versions of those
created list so in this case they are
created in such a way that the single
list is created of a red element and
another list recursively okay so when
you're creating new versions of a list
by adding elements they're all mutable
but they reuse the previous versions so
if you have a list of one element and
you want to another one you add element
and big the new element becomes the head
of the new list and the previous lives
becomes the tail and basically in this
way all structures are implemented and
itself allows saving us a lot of out of
memory actually the other them download
on the list okay we have we have sets
maps it get cues it gets us a bit more
complex in the situations because it's
not that easy to implement this so
usually like queues you can implement
using different different combinations
of lists well just eox talk so basically
if you look at the whole type karoke of
collectors java on collections api
you will see a lot of familiar elements
you will see something like our I
charsequence vectorstock least stream q
wait but stream let's focus on this one
for a second because stream in Java 8 is
basically a fancy form of iterator that
allows you to perform computations in an
item declarative manner but Java flunk
this is this is not a iterator this is a
full normal collections the problem with
Java is that was that those streams were
non-reusable so they could be called
only once and you try to call them at
the column again there was an exception
so here the problem doesn't exist it's a
economic normal collection in Java 8
they were forced to attend it's like the
drag this to not pretty much to not
break the whole collections API well
actually honestly I like the solution
because this is this is what they could
do with trying to force backward
compatibility and this is the the most
coolest part i hope i hope you can see
this when i first time played with java
8 streams I i used my ide control space
and i saw a lot of many a lot of a lot
of methods I cost I was overwhelmed a
lot but after sometimes there I'd
knotted noticing that some methods are
missing there well have you ever missed
any method from stream API guys hmm okay
for me well there's only one person said
something so i guess that everyone else
is that pretty much got everything they
needed in stream api so for example for
me there was something yet i could sleep
missing okay something the tool that
allows you to like zip two streams
together and create purse or for example
something super easy like this things by
but not using equals or hash code but
some extra externally provided
comparator but here in java flung it
becomes overwhelming again because if
you open your ID and co
those methods you have so many new
methods like up and up and self okay you
can return the head you can return the
last element you can return them as
options of course you can zip from with
many different ways you have a distinct
and also this thing by work and provide
a custom comparator well any have events
such a fancy methods as combinations
that returns a collection of all
possible combinations of elements that
are stored in a stream well interpret it
offer only streams that had the certain
nice and fancy API but in July flank it
applies to base all types in collections
API so as you can see it's pretty
Universal and pretty cool so you can
even amaze your friends well or scare
them by implanting stuff like this
believe me it works it's a Fibonacci
sequence in content and I purely
functional way don't ask me to explain
this okay so let's get back to the most
interesting thing the pattern matching
that was implemented in Java slang
unfortunately of course it does it's not
done on the language level okay we can
change this well sometimes we can but no
we don't want to include this in our
library but so it was implemented using
basically about in having many static
methods and it works well it doesn't
work as well as well did this one in
Scala or in Haskell but still it's
usable in like simple everyday use cases
so what patent atty needs to just in
case but I matching is a like a very
fancy way of having a switch case you
are you are making some values against
different cases what super nice that
switch coil well switch case in Java is
pretty limited but pattern matching
usually super powerful because you can
match you perform matchings using many
multiple ways so as you can see here
it's a very simple case where we have
basically cases where you provide
predicate and if the matched volume
matches the return
The Associated value is to return so for
example if if our I integer is even a
falls into the first case that the even
string is returned if it's not it's it's
odd well and if there is any other
possibility there you have a question
mark obviously sometimes you have
situations where you don't want to match
everything so here you have another
option well another option which is a
option method to so even if you don't
want to like close all possibilities
using cases you can always use option
but in this case you will return you
will instead of a return value you will
get an option so if there was any case
that was matched you will have an
optional with something inside and if
there wasn't you get empty one of course
you are not limited to you think
predicates as the asst cases obviously
you can perform matchings by providing
the values so of course you can match
them you can you can mix those
approaches you can create product you
can use predicate in some in some cases
and in another you can use the simple
values but what's super cool actually
bought pattern matching is that it can
be structural what does it mean well in
the previous example basically provided
it with oopsy view of simple values ok
but what but the fun thing is that you
can perform you can go deeper with those
with those metrics so as you can see
here we created a set of cases but now
we are performing matchings in the
second line in the second case you can
see that we have a local date that
matches 2016 here and you have those
dollar signs which are basically
wildcards so what it means in this case
what will averring all local dates of
2016 will fall into and now you can
basically access extract this value that
was a monofin and a day and do something
with it so it's super nice you can
perform matchings on on this one under
the structural level
unfortunately it doesn't he doesn't work
with cursive Lee actually at some point
it was implemented Daniel Dietrich said
that when he implemented this
unfortunately it well it worked with a
small amount of parameters but if you
get more parameters basically the code
generator would generate so many
possible cases so many methods that
would probe that just abuse all possible
physical like JVM limitations when it
comes to like having a amount of methods
in one class so yeah this works
intervals lang only on one level and if
you want to use this with your custom
types you need to unfortunately you
generate a little bit of code so that
it's possible so yeah most of most of us
won't do this if you need to eat with
another dependency and generate code so
what's super nice is that he all those
things like option tries the dosa
basically abstract classes which have
subtypes and you can perform matching
using those subtypes so in this case we
are matching an optional but we know the
doc signal can be some with something
inside or none with nothing so in the
first line over there we are matching an
option of this has something inside we
are putting this wild card over there
and extracting this value and using it
for calculating the result in second one
obviously there's nothing to calculate
so we are turning a string also what's
super nice is that when when you want to
use predicates in your in your cases
well there are multiple situations where
you would keep reinvent keep reinventing
a wheel so the first one comes with many
predefined predicates that can be used
out of the box and those cases become
members suddenly much more readable when
you just use them if you can see you can
attract is in any of none of instance of
is no no no I didn't include them here
here you can see how it could look like
in a real life situation for example
let's say that you are parsing
common line param parameters and if you
have let's say help or minus h like
display help in a second and i cap minus
VR version and in this case display
version and if you didn't get well and
if you didn't recognize what's in their
class just run nothing in this case
what's also super nice is that you you
are not limited to using pattern
matching in Alex standalone way it
blends pretty nicely with all other
stores that you got there so for example
why not use try why not use pattern
matching set of try or optional in a map
or recover call and make different cases
for different types of exceptions that
we got it's super powerful in this case
so basically this is how the over the
high level overview of jealous lon looks
like of course there is much more stuff
into this we have different different
additional modules there's a secret
breaker this is actually not a part of
java slang anymore you have another
module for joy for jackson you have
special module for property testing we
have also telephone match which oh this
is the dependency that allows you to
generate your own your own classes that
can be used in pattern matching so I
hope that I got you interested in to
this I notice that the whole vox Dei
story he's a lot of like functional
oriented so I think that if you want to
start playing with functional code
probably stream API optionals and the
vast rank is a great place to start with
because you don't need to basically
fight with a new syntax but you can just
use your all you can you can stay home
in Java and try to learn those new tools
one one by one so thank you very much i
hope you enjoyed java stock
do you have any any questions so a
microphone is going to yes I think thank
you for the thought it looks very much
like Scala so I was wondering why don't
you just use first thing yeah so of
course it's officially inspired by Scala
well the answer is pretty pretty easy
well I don't know applicant Poland and
in many situations well imagine
situation where we are in a lot in a
project that goes on for seven years for
banking or ensuring students and you go
to your Co both and say do you know what
just throw away the Java 5 and the right
clover Haskell okay in many cases that
doesn't that doesn't work like this at
least few years ago in Poland two very
hard to find a real project where you
could use color well now if we now it's
now it's pretty common but a few years
ago tools problem but still if you are
working someone somewhere and probably
you can't you haven't already changed to
scala because of some problems because
there are some limitations business
limitations to this is the nice and easy
way of making your own java work much
easier to business can see for data
structure so i can say collapse to data
structures in the face manner which is
important ok can you can you rephrase
the question you mean like like vs I I
may have in other languages selling
groups let's say the situation and
methods concord how to combine different
Jason now 142 now unfortunately do that
as pure does add a simple simple simple
simple collections you don't have stuff
like this you unfortunately
do you have experience with integrating
child planning existing projects with EO
yes basically am collection will break
your code yeah I mean there's who I've
been working on one project where we had
like were mixing Java slang with Java a
lot yeah into problematic we had
hibernate over there and it was really
hard to like make first it to work with
we had hibernate in spring web it was
answering data it was quite hard to make
it make it work all together now we had
now there is some integration with
string data which makes it quite a bit
easier but unfortunately yes we needed
we had places in our code we had we
needed to stick to pure Java and some
place to really stick to jealous thanks
to do it was very hard to integrate them
together because what it would
essentially mean is to it pretty much
repackage one to another once another
both ways it didn't make much sense we
were lucky because stream API was
floating up for our for our situation we
are like most case eighty percent of
cases with simple mappings and filtering
xandret collecting stuff but still when
we wanted to do like a little bit more
complex calculations we still could like
pretty much in caps encapsulate this
okay and perform calculations using Java
slang if there were some method that
would be beneficial for us I will and
then perform your packaging but yeah we
used functional interfaces will you stop
off we used for collections API in small
contexts were basically word for
calculating stuff but not using Java
plug-in API is because it would be on
hand in many situations but I was
working in a project I was we were doing
this from a start it was like a document
scanner and we managed to implement
everything using Java slang and it
worked super nice for example we had the
such a nice thing like generation of
sequences of images that would be
rotated a bit for just fine-tuning the
the reading OCR's and word pretty fine
now I'm working in a copying project and
honestly we didn't you telephone because
when when you have cotton you have set
of new collections over there and you
have optional types built into like the
language syntax and that could be again
problematic at some point so this is how
it looks like so we have three
situations one project where I were we
decided to not use Java slang one were
we adopted but carefully and one were we
used it fully and it works nice when you
compare I don't see I don't see who is
speaking yeah I'm here okay when you
compare the standard collections API to
Java slang what's your experience
regarding performance and memory
consumption in real life projects in
various projects those projects were
working with well those the performance
were we could we couldn't feel any
difference okay because the real cases
were like we're working on hundreds or
thousands of elements and this we
couldn't reveal any impact but obviously
when you use that as long there is some
impact okay because when you use Java
API it's mutable and it's non Fred safe
ok but when you compare it to giraffe
lang-java slang get slower okay it can
be on average two to four times slower
but it's fred safe totally ok and just
like Alex lives said today it's all
about there's always on trade of ok you
get a thread safety but it's slightly
slower ok so probably if you really want
to find you an application you you might
want to consider using normal normal
java java classes especially when you
know that there is only one thread
jumping jumping in there so basically i
never experienced any problems with
performance but obviously there is an
impact if you want to see like really
good comparison that there is micro
benchmarking mode
bill starts embedded into a maven maven
Tom in the project you can call it and
see by yourself comparison against
scholars scholars II and some other
stuff what's interesting that those
collections are quite faster that what
you can find in skala see in the worst
cases like 10 times faster you like even
when in the priority queue example I
think does this does help okay thank you
a lot</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>