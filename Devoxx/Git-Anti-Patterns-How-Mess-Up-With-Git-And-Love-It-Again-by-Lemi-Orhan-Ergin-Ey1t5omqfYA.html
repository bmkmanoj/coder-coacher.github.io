<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Git Anti Patterns How Mess Up With Git And Love It Again by Lemi Orhan Ergin | Coder Coacher - Coaching Coders</title><meta content="Git Anti Patterns How Mess Up With Git And Love It Again by Lemi Orhan Ergin - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Git Anti Patterns How Mess Up With Git And Love It Again by Lemi Orhan Ergin</b></h2><h5 class="post__date">2017-08-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ey1t5omqfYA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">chased everyone it is fantastic to be
here so I'm really happy to see you all
let me start with with a story of mine
it was 2009 as far as I remember we were
we had been using a centralized version
control system for a long time it was
SVM we've been we've been using it since
2004 and if you're having troubles the
network in the company was poor and
whenever you need to share your commute
with your friends you have to wait and
wait for minutes and we were we were
really not happy and on those days we
were thinking about switching to another
version control system and our technical
leaders suggested to move to get a 2009
we were I was not aware of kids I
searched at Google and notice that it
was written by Lynn storables hey that's
interesting if Lee knows everyone has
respect to Linus and if Lynn stalls as a
name is on something you can expect some
good cool stuff right and on the other
hand when I searched the articles and
tutorials and I was confused I mean it
seemed to be any heart to adopt because
I couldn't understand the snapshot
mechanism of a distributed version
control system and many things were
unclear but anyway we must take it and
in few days we moved hundreds of
repositories and 250 million lines of
out to get then we start to have
troubles because we didn't know how to
use get well and few weeks later one of
my fans just sitting in front of me
shouted and screamed we can't he said I
he lost three days of work and since we
were the guys who I mean who think
people think that we we know get well at
that time we try to help him but
couldn't find the solution and at the
end he rewrote the whole three days of
work again and that was a breaking point
for me and I I thought I should have
learned better did get better and I
pushed myself to learn it to practice it
again and again and I started notice
patterns and it's the kind of anti
patterns like tons of tons of errors
tons of Miss behaviors while using it
and you may see patterns in everywhere
and you may see anti patterns in
everywhere so in this session I will
describe the anti patterns that I found
in my career
okay let me introduce myself anyway very
briefly my name is Demi and from
Istanbul I've been working as a aegis of
a craftsman
at Ezekiel is equal is a payment service
provider you can call it as a stripe of
Turkey and I've been developing software
since 2001 and I am a community guy and
I really loved working at communities
and I I founded a software craftsmanship
Turkey with my friends and we organized
several conferences as since 2006 and
I'm loved
I get a tent now I will log it because
it's it not because it's written by Lin
stalls and that might be the reason but
in the end ed get has a fantastic
internals and internal mechanism and
that fascinates me a lot
therefore I really love using it and but
one point is important do morph you
learn get you become more comfortable
while using it like a team scrum a scrum
is easy to learn but hard to master
right and get is get resembles scrum so
you have to practice it you have to
learn how it works
in order to use it properly and now we
can start we can start covering
antipatterns one by one so and I know
that many of us just commit and push
regularly you commit and you push you
commit and you push if you do that it
means you are using it as Dropbox and
and unfortunately Dropbox is a better
tool more efficient tool in order to get
backups and if you are using in that way
please stop using it use Dropbox instead
instead is a better tool for that
ok and in order to not to use get as
Dropbox we have to learn get and the get
internals how git works how it behaves
when you when you run a command we have
to learn it briefly so I will describe
you how it behaves in a few slides ok so
it has two mechanisms and beat those
mechanisms get governs everything so it
give get governs your files and folders
and and branches and all references get
keeps your files and folders as objects
what it means is that they are direct
they're kept in the file system as
compressed object compressed files and
they are stored in the dot git folder
that get folder is a git repository so
if you see a dot git folder you can
imagine that it the code they're the
things that are they are versioned and
if you remove that keep repository it
means you lose all the versions but you
have still the source code there and
also get handles all files and folders
in an object graph is a directed acyclic
graph which means there are no cycles
and no B directions and it puts all
objects there and n handles handles the
diversions and in that graph okay i'm i
will show you briefly so you want to
check you want to keep the versions of
the this source code okay so you have
you have packages and you have a source
code you have a file there and you want
to keep the version so whenever you call
get in it so there is a dot keep a
poster is created and the cache is
created you can call the cache as the
staging area that the index file inside
that key folder and they are created but
they are empty so um you can also want
to create a repository on the remote
site and the upstream a what you need to
do is get in it - - base but it
it creates a git repository without any
source code you cannot see a dot git
folder in the remote however you can see
all the things inside of the dot git
repository on the remote server ok but
it's empty - I mean the default accept
default files and you want to and you
want to keep the version so first you
need to do is you need to do git add git
add simply add your files to get its as
as stated in so when you call git add
get in check the files and folders and
creates objects and compresses them via
very liberal algorithm and and puts to
the object databases that is the objects
folder ok objects directory and also it
creates entries in the in the index for
index file so and a get put all your
files and folders in a graph so here you
can see the graph of that sample so it's
so so simple I mean it's like what we in
a what we program in in computer science
department in universities so it so it
terminals are files and notes are
folders ok and whenever you create a
comet whenever you commit your changes
it's lightning fast because it just
creates one just one file you know
nothing nothing extra it is it creates
just one file and it puts your local on
your objects directory and therefore it
is lightning fast when you commit but
it's local and here you can see that
your comet get creates an another node
and and the pointer for branch your
master range and the head pointer and so
it creates references now
and your graph will grow from now on and
whenever you create a new commit you can
see that your graph it enhances with
with the new objects and you know the
new terminals here you can see your new
commit shows the the folder and five
structure and some of the files are
shared some of the files are recreated
because they are changed the bottom of
the file on the bottom is just change
therefore whenever you commit the only
change for that file you create a new
object and you share already existing
objects for the other files and when you
create a new commit you can see your
graph enlarge enlarge and enlarge and a
do cool stuff you can see that the
commit you can see those commit nodes
those are the ones that we see in the
commit graph but we cannot see does
those files and folders in our commit
graph they are hidden and now let's
let's push them to remove when you push
them to the server you simply upload
your files and folders nothing extra
nothing more just an upload and ours is
like an arse increment and that is the
simplicity it in for Indian a mechanism
that keep govern the objects is so
fascinating and if you imagine that your
your colleagues they are just pushed to
to the server and and you have you want
to get all their commits to your local
and what you need to do is first you
need to run the fetch command get such
simply downloads all the files and
folders all the objects so some of the
text with messages
also objects and you download them to
your local but here you can see that
your your local files your source code
has not been impacted and then you
should do is a merge activity when you
run and fetch hem git merge five head
it means you you should get all those
changed objects and and impact your your
source code get contains many hidden
head pointers like share peak health or
ik hat merge head there like seven or
eight different hats you cannot see them
but they are there they are there
because you are toward reversing your
get graph we regularly and like when you
fall into a conflict you have to
rollback about it or continue so with
those old head pointers get knows where
the the processes stopped then then
hopefully there is a shortcut comment
git pull git pull simply runs get such
and get merged ok and let's update the
last comets if you really would like to
update last commit what you need to do
is get to to compute two comments are
are very proper for that so the one is
git commit dash dash amend and the other
one is soft reset they have a very
slight difference but in general they
are very close to each other when you do
a soft reset at the graph the pointer
the branch pointer and the attached head
pointer just moves backwards to the to
the previous commit and your last commit
becomes inaccessible and for your
current branch the entry in the cache in
the staging area disappears
okay and here for example when you do
that your pointer just moves backwards
that's all that's all that that's
perfect
and let's quash the last and comets if
you really would like to squash and
commit then what you need to do is get
reset or get reset - - mixed the mixed
reset simply simply get all your source
code as if they have you you haven't
been committed yet and in your source
code you can see all your last income
changes as as uncommitted and unstaged
so in that sense you can see that you
can imagine that the pointers the
pointer moves backwards again and also
the entries in your branch and in your
head they are just removed in the
staging area and you would like to get
rid of all commit sell for for a reason
for 4m and comets of course then what
you need to do is the Heartless that you
may use hard reset from time to time
it's one of the most dangerous comment
because you may lose your uncommitted
code if you forget okay and your your
changes are are gone okay let's let's
move to another another antipattern so
are you brave enough to jump to a comet
whenever you like version control
systems are time machines so since it's
a time machine you should be able to go
back to any commit at any time but but
it's risky isn't it I mean if you go
back to a random commit you may
encounter a fully messed up source code
right the test might fail the
application might not work so it's risk
however that is an anti-pattern it
should not be like that
so due to that anti-putin we always put
tons of tags bonds of branches and we do
not believe them because if somehow we
would like to go back we should find out
that tag or that branch so here this is
a real real screenshot and there are
tons of comets like this they're comic
messages are the same so is the last
commit means the feature is completed it
depends I don't know no one can know so
there all day they're half half done
half done not done and at the end it's
done or is it really done so we have to
we have to understand it
so the log branches right get is very
very famous about branching and very
powerful and we really love creating
branches because it's so easy when you
create a branch you're old only clade to
anybody that's all - any bites off
pointer however when we when we create a
branch and check out into it we leaving
it we live in it for a long time a
creating a branch and moving into it is
like leaving home for a trip if you come
back in few days you may see your houses
if you've got the people they are
waiting there and you might not see any
differences in the city however if you
leave home and come back two years later
even it is possible that you might not
found your your house so so we have to
keep our branches short now for example
this is a real scenario it's a highway
pattern
around 40 branches they are waiting to
be merged they are there they are
waiting to be merged but how how can
people can merge after six months it is
written and it's been waiting for there
for six months and no one can merge it
back easily okay
and there is a cure I mean I can I will
propose some cures but fear few slides
later okay and we we really would like
to we we we have to validate our comets
before merging but is it really possible
I mean we are running conscious
integration servers it runs your route
test after every commit you create a
code reviews via tools or you are doing
pay programming but at the end most of
the time whenever after your merge you
do the validation do you remember that
that graph from for from a flow get slow
right I've been like using it flow for a
long time I mean four years and it seems
after after spending years with it and
now I see that the tons of branches and
you have to you have to check and
validate your comments after you merge
and that too late you have to get
feedback immediately you have to get
feedback from your colleagues before it
is your branch is really merged ok and I
have some clues about it so few slides
later em and Alden a consulting
companies for a long time and I see lots
of different keep branching mechanisms
for every release they create a release
range or even weeks
for the release they create a release
branch and these branches are waiting
for comets and em and they use therapy
for everything do you use terrific
people love it
terrific is the ultimate comment for
some of some of the guys like architects
like technical leads they are there to
do terrific because no one can merge
tons of different comets in one day I
mean you have a release today and the
your manager says that I don't want that
features I want those features but not
that one but you already merged what you
need to do is you cherry pick one by one
each commit to your current release
branch and that's an anti-pattern okay I
will come to that point again
okay so commit graphs commit graphs
should be well understood should we
should be readable because they are
there for developers developers
developers hate documentation right we
hate it
however we document a lot like writing
tests like commit messages like we are
pretty clear we are creating commit
graphs because we created and someone
your colleague the guy sitting next to
you needs to read it if that is the case
we are creating documentation a lot and
commit graph is a documentation and it
should be readable but how can we read
those things as a mountain mountain
pattern in the comedy club highway
pattern level pattern and mountain
pattern so how can we how can I
understand something happens there what
happens there so it should be readable
and when I'm stood okay what is the cure
so there is no single cure of course I
mean a get is so powerful that everyone
might have different idea
yes and your ideas most probably might
be better than mine therefore those the
things that I will describe that they
work for me but they might not work for
you and in your conditions so I should
state that beforehand okay thank you
and so the philosophy is commit early
commit often perfect later and publish
once it is written so simple but but
it's not so simple while practicing it
so let's start by keeping your branches
short living what you need to do is you
need to separate your your feature into
tasks like in scrum right you have
features if your feature is big you have
to split it into short Sprint's and
that's the point you have to you have to
you have to separate your feature into
short testable parts and we will we will
commit those things okay now you have to
commit early commit often you do not
need to check if the tests are passing
that's that's okay for for now and even
it might not compile that's okay you
commit you commit early and often
because you need versions each get is a
time machine you have to go back to any
commit for any reason now you are
working on a feature and get committed
early and commit often but do not push
it push is an important comment and
according to me people can pay for push
comment I mean you can pay one euro for
each each push so you have to stay away
from push for four five times I mean and
then do not push okay wait for it what
to wait so um
so your connects they are pushing rights
they are pushing before you so you have
to get their their community or local
what you need to do is please do it with
a pull rebase without using tool rebate
I mean we'll be using a bear pull
comment you might have seen some
anomalies in your commit graph I will
have a different section for it and get
pulled I stash we base origin/master
simply get all comets from the total
origins master to your local master and
it makes a rebase and it moves your
comet on top of it okay and do not
forget the push if you already push the
remove because you are changing will
commit history okay
if you commit already you have to force
push to remove and now it's say it's
time to synchronize your your source
branch which you can use git fetch
origin master color master does the most
use used comment in my team in these
days okay now now it's time to make it
single if your branch contains only one
feature you can squash it into one
commit what you can do is you can use
reset that's fine you can reset to to n
commit backwards and make it a create a
new commit or if you really would like
to prepare a em commits from n commit
then you can use interactive rebase
interactive rebate is a wonderful do you
feel like when you are or you're
configuring your gift to push a
satellite to Mars and like it's
incredible now you squash it and we also
of course may create a new
comment of the words and and what you
need to do is you have to I mean you
should you should push it to production
therefore you should use feature flags
or features toggles likes em mentions in
the previous session it is important and
you disable it is important to overcome
all these anti patterns and I can
summarize the things that I described
till now in in one slide
feel free extra points are very
important like you have to deliver
frequently what I mean frequently is
like few times a day at easy go we are
deploying to production like four days
of once in a four-day however we feel
that it's not it's not good and we have
to make it more frequent like once a day
and our next aim is few times a day so
you have to build your content delivery
procedure on on your system ok and for
for code reviews you can use github flow
Gaeta flow is it is a cool is it is a
really working mechanism for for your
branching model ok and do not forget to
delete branches please please the
branches are there for for your for
keeping your unfinished work but
whenever you finish your work and merge
back to your source branch you can
delete it you should handle which
commits contain is blonde which commit
belongs to which which feature from from
your commit message not with your branch
name now
there are some other cures what are they
I can I can mention few more cures with
you in a very first place so developers
really love using user interfaces right
especially while using it I mean we
click on the push button what it does is
it runs get at point which which get
every changes every change in your local
and commit to it and push it through to
your to your upstream however that means
you are using your get like Dropbox so
avoid using user interfaces or
applications and there are some
exceptions of course like when you need
to resolve the conflict or see a diff
you may also see a commit graph even
though I use terminals for seeing the
commit graph you can use or use
interfaces but avoid it okay you have to
no get well
therefore you should use get from
comment prompt terminal sorry and and
and no one wants to lose the I committed
codes
yes right I mean therefore you should
use git stash or git reset with - -
merge or you can directly committed what
is git reset - - merge it tries to do
it's a hard reset by the way however if
you have an uncommitted code get checks
if the things that I reset it has a
conflict with the things that are newly
written in our source code and if there
is a conflict it stops I mean it
prevents you from deleting uncommitted
code if you really would like to do hard
reset you can use more
reset and even though even though you
agree that yeah we should keep our
branches short you might have some monk
living branches then what you need to do
you can squash it you should squash it
yeah you can say that why I am squashing
I mean it's a long living branch it's a
the death turtlecom it bear so why
should I wash the squash it in 99.99
percent of your time you won't need to
go back to any intermediary commit there
so they are there but no one needs it
the if you imagines you squash it
nothing will muscle will nothing will
change in your life
so therefore in our team we are
squashing all commits in in in a future
branch or we can create more than one
commit of course after of the of the
squashing also stop stop adding all your
changes to your your next commit because
I'm sure that your changes might contain
a bug fix they're a part of the feature
and the refile part of refactoring so
you do a get at that a dot and you get
all the changes and push in one commit
do not do that hopefully aj print tools
has a mecha is an feature like local
change set with that local change set
before even even creating a commit you
can separate your changes into logical
sections logical groups that is perfect
you can use it we are using very heavily
and also
you can you can use a partial F partial
ad seems a little bit weird however if
you get used to it it's very powerful
and with that with that comment let's in
that example we have yet at read me file
we have two different changes but we
would like to add only the first one not
two second one what you need to do is
you first add the first one and not the
second one to your commit so at the end
whenever you prepare your commit
whenever you do a check status you can
see that your changes are added and
modified at the same time in the same
file ok and commit messages are read by
your colleagues and their read for to be
understood therefore they should be
written widely
oh yeah that's boring it's boring to
write commit messages but we should we
should spend time for writing commit
messages what we can do is we can have
some guide guidance what it means
hopefully it has a template mechanism
for keep commit messages so you can you
can use that you get the - commit -
template that takes the file but
whatever at the end you can use it for
example in that sample
whenever you really need to add
something at that template is opened and
it directs you and it shows you some
some guidance points you should remember
those points ok and it really helps to
improve the quality of your commit
message ok now let's go back to the
initial story so what should have
happened what what happened to my
colleague why he lost
his three days work because I've been
thinking it for a long time
why why why he lost his three days of
work and I have some ideas
no one knows in fact the real the real
reason however I have some ideas one
idea is my friend
unfortunately he checked out through a
comics ed peg
he might believe that it's a branch but
its attack and he fell into the taste
head state the Texas State means that
your head pointer is not showing a
branch pointer so head pointer is now
alone it's alone in the ocean so that's
dangerous right or another idea my
friends might try to run I get the sad
comment just for trying I don't know why
but he might try and he might get a
conflict whenever reset stops due to a
conflict you stopped in and detect head
states you have to abort it or you have
to fix that conflict and continue so you
have to handle that conflict before
moving on therefore most probably that
might happen so but my friends couldn't
notice the detached estate and worked
for three days my poor friend
then due to a reason must prove the duty
a bug-fix he checked out to master
branch but here
three days of work disappeared they are
there you cannot lose your comets in get
very easily by the way but they might
disappear because imagine the graph
theory get cannot enter that graph from
those green nodes get cannot find those
nodes by traversing the graph they are
there but it cannot find it now we know
that that might happen but we know that
there is a clue and there is that there
is a cure for it so what we need to do
is we need to run git ref lock get ref
lock is a lock
keeping your movements of your head
pointer and it is specific to you so
your friend might have a different red
lock down different output when he runs
red lock and you can for free from the
red lock you can start to check your
entries one by one you might use get
show comment get show commit ID simply
shows the internals of your get the data
so it shows the data for your commit and
you can find your last last commit there
and you can create a branch for for for
showing it how to enter the branch how
to enter the graph okay now git can
traverse the graph and find those those
missing notes okay and
if you think that you lose something
while using it no worries
because it's really hard to lose code if
you may lose your uncle uncommitted code
if you do a hard reset other than that
it's really really hard to do so feel
relaxed and just use git ref lock those
are the things that I can describe
I have additional 15 antipatterns but it
takes time therefore I hope we can meet
on a meter board on an event in the
future and we can cover all the all the
other 15 meetups thanks a lot
ma I believe in the power of Kaizen I'm
a full time apprentice therefore your
feedback is very valuable for me please
send your feedback via the app or or via
social media thank you thank you very
much for coming thanks
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>