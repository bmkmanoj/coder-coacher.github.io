<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JShell: An Interactive Shell for the Java Platform by Robert Field | Coder Coacher - Coaching Coders</title><meta content="JShell: An Interactive Shell for the Java Platform by Robert Field - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JShell: An Interactive Shell for the Java Platform by Robert Field</b></h2><h5 class="post__date">2015-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jziVaht480w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right if you're here to hear about
Jay shell the new interactive way to
access the java language you're in the
right place
I'm Robert field I'm the architect of
Jay shell and the lead engineer I'm a
member of the Java core language and
tools group at oracle oracle has to tell
you that anything I say could be fiction
because we haven't shifted yet so what
am I going to talk about I'm gonna talk
about what J shell is why you would want
to use it including who would want to
use it and go through how you would use
J shell and then actually see it in
action and then talk a little bit just
kind of 10,000 foot view of what the
architecture of the J shell
implementation and the API are and then
we'll about questions and I'm open to
questions as long as there's enough time
as we go along so starting with what is
J shell actually I want to know a little
bit about you if I can't see you at all
who's heard of J shell before DevOps
okay and who who's actually used J shell
okay well I think that's one and for
whom is this entirely new in here okay
pretty much everybody okay J shell is a
tool well it's a tool and an API but
what I'm going to be showing primarily
here is the tool for dynamically
interacting with the Java language it's
what you may have heard of rebels or
read evaluate print loops usually in
dynamic languages this is a rebel for
the
the language so basic ideas you type in
a snippet of Java code and immediately
see the results the implementation of je
shell is deeply integrated in the JDK 9
platform and it's part of the JDK 9
platform and it builds on top of the JDK
9 platform and we'll talk a little bit
about the implications for that so what
I'm going to be showing is the tool is a
lot easier to show a tool than to show
an API but everything the tool can do
the API can do which means if you don't
like how the Tool Works you can have
that functionality quite easily in your
own or if you want it built within your
own tool it's also important to talk
about what J shell is not it's not a new
language the whole point of it is to
have interactive access to pure Java
code every snippet of Java code accepted
by J shell is corresponds to a
production in the Java language
specification so it's very literally
pure Java but just pieces of it and
people say I've told said frequently
well can we add this and this because
we've always wanted that in Java it's
not going to be in this either because
this is not a new language it's an
interactive access to the present
language and note this is not some
replacement for the compiler the idea is
this is a way to explore the compiler
still how will you compile programs and
anytime you have a tool that works with
you know source code there's a
temptation to well if you add this and
this and producing you have an IDE we
really don't want to slip down that
slippery
there's an API for adding this
functionality to IDs and we're we're
working on that and we encourage more
addition to other existing language
tools okay so why would we want J shell
there's really kind of three audiences
for J shell one is programmers that are
new to Java
Java or in fact if this is your job is
your first programming language so you
can start with typing an expression and
seeing what that does that's a much
easier starting point than declaring a
class declaring a main method with you
know defined string arrays and has
access permissions and so forth and not
knowing what any of that means you can
start a reasonable point and build up
from that and all of us are newbies
again and again as new API has come out
or we want to use API as we haven't used
before or new language features are
added to Java so it's a it's a way to
learn those very effectively ongoingly
though it's a way for prototyping for
building up complex code at immigrant
Glenn granularity you're interested in
type in type in the thing you're
thinking about see the response and
build up from there okay so if you want
to explore now without J shell you're
basically stuck using the edit compile
execute cycle and you need to build a
full program you need to write some
class for the class declaration put in
the imports you need and you need to
clear our main method and put it in
prints or whatever however you want to
see your results so you know when you
mean to cycle through this you edit the
code to create it and you go through a
compiler
IDE to compile it and then you execute
it so here's our example without J shell
so everything in bold black text is what
you would type you'd enter an editor you
type in your class declaration your main
method declaration you might've put
print lines with system out and then you
wouldn't need to compile it and then act
and if you're lucky it will compile you
won't know to get to that point then you
execute it okay and you see there is
okay in this example by the way is your
for example you want to know the
difference between right shift and
unsigned shift so the results we get
back on negative numbers so the results
we get back our first - more and that
tells us what happened happens with the
regular shift but the response we get
for the unsigned shift is obscured by
the fact that I printed it in decimal so
I can't really see what's going on we
then need to go through back through the
cycle change that to print in octal or
hexadecimal code you're interested in
and immediately see the results that's
all there is to it
so in this case we type in the first
expression we're interested in - a shift
- we see the response which says that
it's - - you'll notice also that it says
it's created a temporary variable called
dollar one that's so if the value the
value you're interested in you want to
use that further you can reference it
with dollar one now we type in the
second one and with the unsigned shift
and at that point and we see the result
at that point we've done everything we
wanted to do in terms of exploration
that was on this slide without Jay Chou
in here okay well now we want to do an
an octal we're gonna use a printf print
it in octal now notice I didn't say
system.out.print line then printf I just
said printf well that's actually a
method we've added and I've said we're
doing pure Java so we'll talk about more
about how that gets to be in there and
we're still pure Java so how do we use J
shell you once you have a JDK 9
installed you just type J shell and
you're there there and there's two kinds
of input you can give to J shell one is
the snippets of Java code I've been
talking about the other is commands to
get information and control how J shell
works those that both both of these by
the way can be tab completed we want to
keep down the amount of typing you need
to do so for example you want to create
a variable foo you just type in string
foo equals in this case howdy in this
case it will tell you it's created that
variable what the type is and what the
value is what about a method so we went
to create a Fibonacci method we typed
long Fibonacci open brace hit return
notice this time it gives us a different
prompt it knows that's not that input
isn't a complete snippet of code and we
can enter our whole method at the end it
says we've added a method
you can also add classes interface enews
annotation interfaces in this case we
just have a simple interface to convert
a floating point number into an end and
what about just expressions you just
type the expression we can use the
method we just created and call that
Fibonacci method with ten we immediately
see the expression value again there's
temporary variable for that statements
you can put in any statement as well in
this case we're using the temporary
variable from previous slide and printf
and there's our statement and it
immediately runs and you see the value
what about imports
well actually J shell comes with a set
of imports predefined but what if you're
using something as your talk before
using swing well you just type in the
import for swing and it doesn't have to
be in order it can be at any point
that's true of all of the snippets you
enter you can add the import as you go
along in fact the only kind of Java
snippet of Java code you can't add is a
package declaration that's because
everything in J shell is in one
predefined package okay let's just do a
few examples here so we could define a
lambda expression using that interface
we just declared define the convert the
conversion from float to it using math
round and we've added that lambda we can
use the lambda immediately test it out
see if we got what we want and we say
lambda convert 2.5 and so the other
thing you get immediately
errors in this case you can see that it
won't let you just turn 2.5 which is a
double into a float and you get an error
and shows where the air is and you can
add the the cast you need to do to make
that work you don't have to retype this
from scratch J shell has it has a
history mechanism you can just basically
go up arrow and edit what you have and
there your results
what about commands the commands are
differentiated from snippets by having a
leading slash they do a bunch of things
like they show the state of your
execution that they allow you to
configure how J shell works including
how it displays they set up your
environment let's say what your class
path is and things like that and what a
start up is the start up is and I'll
show what that means a little while it
allows you to look at your history of
what commands and snippets you've
entered the commands to have to have
completion they also have shortcuts so
the most useful command to start with a
slash help which lists all the commands
there are this list both the shorthand
civil character version which there's
some arguments since you can do tab
completion that you don't really need
you could do we could just have slash
out a hit tab and it would fill in the
list and some of them have optional
arguments like the list there shows that
it lists all we're not going to go
through all these commands of course but
the help is there when you need it okay
a real common command you might want is
the list so list all the current active
snippets this is a list of the stupids
we've added in the previous slide and
note also that it has a number in front
of it that's the snippet ID
and that idea is something used to
reference it to edit it or if you no
longer want that as part of your set of
snippets to drop it you also see that in
back traces and a bunch of other
quarries you can query for which
variables you have here we see both the
explicitly defined variables like foo
and Lam and the temporary variables that
have automatically been created for us
similarly there's slash methods to get
information about methods and slash
classes to get information about classes
interface you know it's all about okay
it's often useful you're not writing
programs with J shell but you frequently
want to go back to where you were and
continue so you can save what you work
in with a slash save if you exit J shell
you can then re-enter it open it back up
and it will reread them re execute them
and basically you're starting from where
you were
now the first flashed list I used didn't
have any parameters slash all will show
you all your snippets remember the first
time I use slash list I said all your
current active snippets that doesn't
include your startup snippets it doesn't
include any failed snippets or
overwritten snippets so in this case
list list all shows what you start with
before you've typed anything and there's
a number of imports that people find
generally useful like Java util and i/o
and so forth
net and the very last thing you see is
there's a declaration for printf it's
just because you don't want to have to
even though you can for simple things
you can just enter them in return and
that's the value of expression you'll
see immediately the results often you
want to print things as as part of a
method you don't want to have to type
out system.out.print printf so we've pre
declared that because that's a valid
snippet we've not changed the syntax of
Java but we'd really like this all to be
imports and we're we're hoping this guy
over there will help us add princess and
Prince line and all those interesting
things as static imports to Java so we
could use those anywhere in our Java
programs basically we want them to be as
close to one to one
as possible so okay wait wait so first
of all who who thinks this set of
imports is exactly the right set you you
wouldn't want to change any of this
nobody okay how many people would want
to customize this your set of imports
that you would typically use would be
different all right well that's good
because you can change your start up but
basically with this set start up command
will set your start up file that you'll
use every time you start up you can use
save start to get the current set to
just modify it note that you can put
commands as well as snippets in a start
up file so for example in these in
feedback you're seeing a lot of people
are gonna go well that's really verbose
and it made that may change because a
lot of people say that's a relief or
boast but I actually like for a new user
starting to see something that is really
friendly well by changing your
start up you can add a slash feedback
command to set your feedback level so
you can set that to be concise and both
snippets and commands have command line
editing thanks to Jay line two you can
go up and down through your command
history you can hit enter to re execute
a previous command you can use Emacs
bindings to edit what you had before and
you can use tab completion to complete
an entry also in the case of you've got
to a call to a method you want to see
what the arguments to that are you can
use shift tab finally if you're
executing something and it's taking too
long or isn't in in an infinite loop you
can hit control C and come back to the
prompt all right well this is where you
actually get to see J show in action
okay so I just type J shell and that's
alerts to it um now I'll get my cheat
sheet back okay well let's start simple
we'll define a variable
okay we've typed in the variable
declaration and there we go
notice I didn't have to put a semicolon
at the end of an input any snippet it
will automatically detect that you're
missing a semicolon put that in for you
if you want to know the value of
something like s I can just type ass hit
return and you see the value now let's
show tab completion what can I do with
this ass I can do s dot hit tab get a
whole list of things I can do with
strength so for this example let's say
we want to convert it to uppercase and
go to up and I can hit tab again it
would help if I type that right here we
go
and there we go and it's converted it to
uppercase and notice it's put that in a
temporary variable we can look at the
Tempur bearable by just hitting entering
the name of it okay the next thing you
want to do is how do you work with
things how do you replace previous
definitions and look at the history so
let's say we want a a method that given
a string gives us half of it back
we'll use I just hit tab to get this up
there is again I'm a really lazy typer
and then I want to look at the line
because that's half of one half of the
length again hitting tab
/ - and there's our method definition
well let's give it a try that's part of
what you can do in J shell is
immediately try things out so let's say
1/2 rabbit and we get 1/2 but actually I
wanted the first half not the second
half I don't the way I would get a new
definition for 1/2 would be to reenter
it now I could just retype it from
scratch and it would recognize that it
has the same signature and that would be
the new definition so that's basically
how you replace things again I'm lazy I
can just go up first level shows the
previous thing I did
second up takes me back to my definition
I can just go in here and make it the
way I want and now notice instead of
saying it added the method half it says
it modified it and then over wrote the
method and then I can do my test again
and there we go have rabb first half of
rabbit ok build up the complexity a
little bit more let's say we want to
define a method for the volume of a of a
cube so not a cube I mean a sphere so R
we need the radius as an input to the
method and return so it's three 4/3 of
pi times the cube of the radius and well
said the coab let's make it actually
cube
all right now it says it's declared that
definition but I didn't tell it what pi
was and I didn't tell it what cube was
this is basically a for reference
like sometimes you your code will need
before it references either because
there are circular references valid
circular references or if your prototype
in a prototyping mode you may be like
this well this is what I want to do in
the middle of the definition you want to
reference things that haven't been
referenced yet it it allows that it's
added this following a method but it
says you can't actually invoke it in
tell you declare what pi is until you
declare what cube is well let's say if I
ignored that let's call it anyhow it
just says you've attempted to call it
but you haven't you haven't defined what
pi and Q Bar well the way we want to
define what PI is is math star okay and
so now we can try out volume again see
if we got it to work now no it says you
still haven't defined cube
yeah but X is usually x times X times X
and we can try it again and there we go
we have a result is that the right
result you may catch what's wrong that's
that's just PI not 4/3 PI the reason is
that was in the integer division so we
can just go back up here edit it try it
again and we have the result we want all
right before I go further anybody have
questions at this point
okay so the question is let's say you
define a method and then you decide you
wanted different parameter on it or add
a parameter well if you have a method
with a different signature in Java it's
a different method it's a method
overload and those are perfectly valid
so you will just defined an overloaded
method yeah so you can basically say so
so there's our methods we define
following cuban what have you i can slay
slash so our volume declaration is ID 15
and I can just say drop 15 and that's
not one of our methods anymore
so I saw another question yes can you
have it so you can use so you notice one
of the and the middle ish of the screen
there is a slash class path command you
can basically specify a class path for
your so you you can basically work with
your existing code and and do calls into
your existing code or libraries or
whatever you want you can add anything
on your class path you want that answer
question yeah
so the question is you get different
temporary variables if you call the same
thing and basically the we initially
kind of assigned temporary variables in
order we realized we don't want like
numbers for temporary variables and
numbers for snippets so the snippets for
which the temporary variant will make
sense like an expression have the
temporary variables correspond to the
snippet number so if it's snippet 10
it's gonna be temporary variable 10 so
you'll get a new one every time
yes it will return the line number in
the method and so the question is if you
have an exception the back trace what
does it show it will show the snippet
number actually that's we just changed
that functionality so it's currently
broken but we we know about that we'll
fix that quickly the snippet number and
the line number within the snippet all
right let me let me move on okay one
more so the question is can you open
from the command line and yes the you
can as a parameter to the JCL command
you can basically specify snippets what
you're basically you know a file to open
and execute okay so I get a bunch of I
get requests to like how do you use that
and the user stuff in the real world
well here's a case where only back up a
second so as much of the functionality
as possible has been built directly on
top of the JDK tool structure and so the
source code analysis uses the compiler
and so one import is also handled that
way but I needed some information that
the compiler api's couldn't get me so I
used a pattern so it's a pretty ugly
pattern you can see you there and I
developed that using J shell because
it's really much easier to play with
that rather than cycling through the
whole program every time so let's look
at that so it there's there's our ugly
import pattern we can
oops import
so let's let's do a match or it helps if
I use the right punctuation let's test
out let's see if it works for as kind of
a standard import Java laying star does
that match well but it gives me back is
a matter that doesn't even tell me if it
matches but I have this temporary
variable 18 in this case I'll use 18 and
then I'll query whether that matches it
says yep that matches the pattern good
so that works and I can also ask well
part of what I extract in this ugly
thing is the full name of what's being
imported so let me do the group quarry
of that for the full name and it's got
back java.lang star that's exactly what
I wanted well I want to be able to test
a bunch of things so I can write a
little test code this is a great way to
test things out by playing with them so
let's make a test method giving a string
of an import that we want to test to see
if it matches we'll get a match or
called M which is the import pattern and
a matcher tab to complete it of that
import imported s and then we'll do an
if that match or matches
yep
if it matches then to printf use that
printout function we had before and
basically show so if we got the the
results we want which is the the
rightful name and the right name which
is what I'm trying to extract out of
there so I go am dot group thing wrong
here is not group but there we go M
group full name and M group of name so
now I'll be able to just check those
immediately without having to manually
type in those queries and then otherwise
if it doesn't match we need to know that
immediately so we'll say no match
oh yeah I mean I'll need another okay
printf else without if that's oh I see
okay so we'll go back to our test method
and we want to close this there we go
uh-huh so now we have our test method
and we can test a bunch of interesting
things like one thing that was reported
was that if I put a space after a dot
here that the import matching doesn't
work sure enough we had a no match so we
need this is actually a current bug
it was just reported and so I can see it
and fix it and try it out here I could I
can type in tests for other things well
is it broken also if the space is here
you know sure enough now I could go
through the whole process of actually
fixing this bug here which I tried to do
as a demo but it takes more than a few
minutes I have okay any questions about
that
alright one of the things well actually
I'll come back to that alright so at
this point I will go back to my slides
and
talk about the architecture and API huh
so my kind of goals I had my guiding
principles for this were to create
something compatible both currently with
the current Java and something it would
stay compatible some people know this is
not the first time the people have tried
to do a rebel for Java and the problem
with them have always been they never
quite matched and they really quickly
got out of date as Java continued to
evolve we didn't want so it's this this
code is built on on the platform
directly to prevent that we didn't want
to keep chasing corner cases we'll let
the compiler team chase the corner cases
and the VM team additionally we want it
to be really easy and natural to use and
so that's a place we've certainly tried
to do that and that's a place where I
love input people saying that's a little
awkward or where do you or whatever it
is that isn't natural this is the time
to give us that input and to me actually
the API which allows this functionality
to go and other tools for kind of
scripting kind of functionality for for
my personal use I'd rather use a GUI
based grapple we did we thought that was
just way hanging over the edge of the
slippery slope so this is a command line
Ruppel which is what probably the most
people asked for and wants simple and we
want it in other development tools so
the API is essential what's the
architecture so the the big orange block
there is the J shell implementation and
that's built right on top of the Java C
compiler the standard compiler in the
Java platform
and what it uses is the compiler API
there's AP is defined public API is
defined for the Java compiler to allow
you to do compilation and that's how the
compilation works in this in addition
there's the execution
well execution is done in our remote
process the reason is if you do
something to crash you basically don't
want to crash your tool that's one
reason the other reason is because
you're replacing what's effectively
replacing classes we want to make use of
the redefined classes mechanism that's
part of the debug architecture so the
remote process is controlled kind of by
a direct socket but also by the JDI wood
interface which is part of the java
debug architecture and so the compiler
the compiler the language syntax stuff
is using the standard compiler so that
stays consistent the execution side is
running on a top of a standard JVM so
the execution semantics stays consistent
now that's the JCL implementation the
JCL implementation provides the JCL api
the tool I've been showing you is is
basically just a tool sitting on top of
that API it doesn't have any special
permissions for anything and for all the
command line editing stuff we used
off-the-shelf
functionality that that we've heard good
things about and what's work really well
for without us which is jailing any
questions about the architecture
okay wait a bit
what about yes the question is is there
another implementation of the client or
is it only the question is there a sling
client so basically there's no
restriction because what you've got here
is the standard Java compiler anything
that you compile with a Java compiler
you can compile with this module the
whole package thing and you can use your
existing classes that use any part of
Java anything you can execute you can
execute on this so royboy just did a
demo earlier today using swing so you
don't need a special client for that
system application and right
right okay so so the question is some he
wants to be able to incorporate J shell
and introspect on that particular
application that's that's not part of
what it would provide there's a lot of
interest in basically wanting to be able
to hook up with save long-running
processes or something the the ability
for this to talk to some other process
is potentially there and that's not
going to be part of what goes into JDK
knowing so that that might get you what
you want but that's not currently what
what it supports okay the API which is
how you would either create your own
repple how you want it or add this
functionality for scripting or add this
functionality for some innovative idea
that I haven't thought of which my
favorite ones use the API this is you
know the super simplified version of
what the API is you start with an
instance of the J shell object which has
a bunch of stuff on it but the most
interesting thing on it is eval
so eval basically takes a string which
is a snippet input and what you get back
is a snippet event and at the bottom
there and a snippet event basically
tells you what's happened in terms of a
snippet so it will have whatever snippet
or snippets were created
whatever snippets were changed by what
you did remember so we had the
Declaration of all when we added cube
that changed vol because it's now a
valid snippet so snippet events are not
just for the current ones you've created
or modified they're also for what
changes have happened to dependent
snippets if this is something that would
execute like an expression
the snippet event will have the value or
if it failed it will have the exception
there's also another snippet returned by
a snippet event so in the case I
mentioned of a the adding the cube
declaration that changed the volume
declaration so for the change to volume
you will say the cause snippet is the
cube if it so will tell you tell you the
dependency information okay but anyway
you wind up with snippets in this case
you type in a new a new snippet string
you'll get back a snippet event which
will hold a snippet object a snippet
object is an immutable object defining
the source and basically what kind of
thing it is and from that you can query
for all that static information some of
the information about a snippet changes
like is it currently valid like for
example the wall snippet changed over
time so for that you need instance about
the state of J shell itself and about
the snippet so you can ask the jl
instance about a snippet to say what's
its status just for example any
questions on the API okay well cool
thing is J shell went into JDK 9 to 3
weeks ago so if you download JDK 9
either the binaries or the source it's
all there and you can you can try it out
by just downloading JDK 9 the plan is
again this is you know reality might
interject itself the plan is for JDK no
line
to ship in September of 2016 and I don't
know what else is okay what else is
interesting on this slide is the Cola
project so we had our own repository for
a while that's that's no longer
interesting because it's in JDK 9 now
but what is interesting on this project
page is there's a mailing mailing list
which is a great place to interact with
the team give us feedback or or
contribute there's also a corresponding
JEP 4j shell which is two to two and I
talked about the team well so that it's
me plus Yan Lakota also we really
believe in the open JDK and we have
Shania hodo the senior Yoshida who's
contributed to the project and we would
love to have you as a contributor as
well I've had a number of advisors
inside and outside of Oracle who who've
helped us out both in terms of reviews
or cheerleading or advice and now I met
questions any more questions yes
right so that the question is does J
shell create its own JVM process or does
it can it connect to an existing one and
that's what I was talking about for so
the the in jdk 9 it creates its own
process I think there's a lot of value
potentially connecting to an existing
process but we're not trying to hit that
for jdk no yes
question is will this be back ported to
JDK and I'm not aware of any plans to do
that it would probably not be a really
big deal but actually it it would be a
fairly small deal but I have not aware
of plans
so yes the question is that history
searchable and it is not of course so
the history is something specific to the
tool that's not part of the API with you
know within the tool there's not a right
so I understand so you would like to be
able to search through the history
that's not something well that's the
first time we've heard that request and
so no it doesn't do that off to think
about that so I can get more that's the
kind of feedback that would be
interesting tell me about why and how
that might be useful and send it to the
kola mailing list and would love to get
that kind of feedback yes
oh yeah I was going to do that in the
demo so question was it doesn't do
completion of parameters per se but oh
that was okay and I have more have seven
seven minutes let me actually show you
let's get back into J shell and well I
showed you the API
why don't we explore that API within J
shell itself kind of go metal on it jdk
dodge j shell is is where the api is so
i said there was you create an instance
of a j shell let's call that instance sh
for shell and there's a static method
that's used to create it and hitting tab
shows that it's called create so we now
have SH is an instance of J shell and we
can use it to do an eval let's let's
eval something how about into X equals 5
so we now get back a list of snippet
events there's actually only one snippet
an event in there the the one for that
variable so we can snip it event and
we'll put it in an event called EVT well
what we got back was a list not a and
it's the wrong temporary variable - so
it just didn't know about that but okay
what I would have done there was it
would tell me it's a list so let's just
cheat and get the first element of list
now I have a snippet event there and I
can look well I can see what things I
can do on on a snippet event I can ask
for its cause snippet its value what the
snippet is an exception the status
previous status all kinds of cool things
so let's say we want the value the value
of that is five because we've set X to
five we can look at what the status is
it's a valid snippet so forth um I could
do more there but that's probably I was
going to show you
completion of parameters sure there's
anything we can also go back to our old
the history last you know is preserved
from the last remember we entered J
shell what we had still have the history
of this
it indefinitely still looking for
interesting things to do I don't know
what split a stream actually and that I
can go shift-tab
in this case it's not very interesting
there's only one completion which is
that it wants to take a character
sequence if there were mole or more
would lift list them all right time for
a couple more questions yes
okay so I get a lot of questions like
can you do this in J shell well
basically if you can do it in Java you
can do it in J shell you can run any
code the the stuff you type at the J
shell command line is in one packaging
and the main thread but you can have as
many threads you can access any
libraries who want there's there's no
restriction on what you can do in J
shell that answer your question yes is
there completion on variable names yes
there is and there's a bug that there's
a fix for and it's not in that makes it
slow and lousy in demos but it's fixed
it just hasn't I have to quit talking
and go do reviews and then don't work
okay I'll show you one more thing in in
two minutes which i think is pretty cool
in terms of showing that it's not going
to go out of date which is so some
people may have heard of valhalla the
new type system work that may go into
into maybe jdk 10
well that's built on top of JDK nine and
I can use a Valhalla image and access
functionality in that like Java any util
which is a new package stream stream
it's probably just a temporary hack
package actually Oh and okay now we can
probably more interesting thing I can
show here
what could I send a range say a range of
1 to 100 I get back a stream of int but
notice that's lowercase int add more to
this demo but I have 30 seconds so feel
free to find me afterwards and thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>