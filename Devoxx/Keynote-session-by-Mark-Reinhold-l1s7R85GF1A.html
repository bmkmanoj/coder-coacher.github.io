<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Keynote session by Mark Reinhold | Coder Coacher - Coaching Coders</title><meta content="Keynote session by Mark Reinhold - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Keynote session by Mark Reinhold</b></h2><h5 class="post__date">2015-11-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/l1s7R85GF1A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right good morning welcome Java 9 is
primarily going to be about modules this
is probably not news to most of you here
in the room but as part of the bigger
picture
well I how does this fit in because
after all Java is oh my goodness is 20
years old this year I've been working on
it for most of those years which is I
don't know maybe a mistake I'm not sure
how is it the Java has lasted this long
why is it still you know so popular well
we've had a fairly basic method for
evolving it we identify a pain point in
the platform something that's affecting
everybody who uses it whether their
developers deployers or users we figure
out what the missing abstraction is and
then we add it to the platform if we do
this right then it will look like
something that has been there all along
now we can't always do that sometimes
Java has been criticized for being a
platform that where's its history on its
sleeve and that's largely because of the
strong commitment we've always had the
compatibility but we've been reasonably
successful here and there now these
abstractions might be big like generics
or Orlando so they might be small like a
missing method or a class or or a
package you know the point is to have a
coherent evolutionary path where you
figure out a motivation for something
you know we don't just do a feature
because it's cool we don't just add a
language feature because OC char passive
we do it because it makes sense for the
platform that we have in the platform as
we see it going forward we're always
trying to preserve Jabba's key values of
readability simplicity universality and
compatibility so exists some examples of
some of these big changes I already
mentioned generics this was a big big
change in Java 5 the main pain point we
were addressing there was the fact that
until Java 5 most collections you write
write code that manipulates collections
it was essentially dynamically typed it
was still strongly type typed but it was
dynamically typed you make a list of
strings and you pull something out of it
well all the compiler knows is it's an
object and you have to go
to a string which is tedious and then
you might make a mistake somewhere and
it was just you know it's a very very
painful your collections classes in
particular became much easier to use
once we had generic types a second big
change a big big change to the platform
was the introduction of lambdas in Java
8 the pain point there was it was just
enormous ly hard to express code as data
to move code around to be able to
abstract over behavior so that we could
write frameworks that would make it easy
to root to exploit large large
multi-core processors so lambdas were
the answer there in Java 9 we're looking
to address to pain points and it turns
out they have we think a common solution
one pain point is the class path the
brittle and error-prone class path the
other is the massive monolithic JDK the
missing abstraction and the comma
solution here is the introduction of
modules to the platform this is what
we've been working on in project jigsaw
and open JDK for a while now and it's
another example of a long term
investment in the platform
most people know why the class path is
bad by now this this problem is so
infamous that it even has its own
Wikipedia entry you can look it up jar
hell jar hell is a term similar to DLL
hell used to describe all the various
ways in which the class voting process
can end up not working yep here's a
class path
now this is from Hadoop which is
actually a very well engineered system
we've spent some time using it as a case
study for for modular ization there are
110 jar files on this class path how do
you tell if something's missing
um well that's hard how do you tell if
there are any conflicts build tools like
maven can do a pretty good job based on
artifact name but if the artifacts
themselves have a different name but the
same contents there could be a conflict
and you won't find out until you have a
nasty bug after your system has been up
and running for two days is it safe to
change an internal API hmm
what's an internal API this is the class
path right the Claddagh the class path
is your jar files are not components is
the fundamental problem jar files are
just containers that are file systems on
sticks and you stick them in a row and
you search them linearly from front to
back looking for looking for a class the
class path is a way to look up classes
regardless of what component they're in
what package they're in or their
intended use if you think about it it's
sort of amazing that systems like this
even work but they do so this is the
class path there's the monolithic JDK
the the monolithic nature of the JDK
from the very beginning yeah well at the
beginning wasn't so bad cuz a really
small remember but it's grown it's big
and this this pain point has several
aspects one is that it doesn't fit onto
small devices even those small IOT type
devices that if they have processors
capable of running an SE class VM but
you don't they don't necessarily have a
memory to hold all of the JDK especially
when your application is only in use is
gonna use a little part of it that's
just a waste it's even a problem in the
cloud and you know sure big machines
have plenty of disk space and plenty of
memory but in the cloud it's all about
optimizing the use of hardware and if
you've got thousands of images and each
is carrying the whole copy of the JDK
for an application that's only using a
little bit of it
well that's wasteful to the JDK is it is
just it's this monolithic system it's
grown up from the beginning as one
system over the years we've we've done
what we could
with the facilities that have been in
the language from the beginning to try
to keep components reasonably separate
from each other but there are in Devitt
ibly some surprising connections because
anything can refer to anything else
somebody working on CORBA over here can
decide oh there's a convenient API over
there in AWT Wow let's use it no problem
well that makes sense when you're
monolithic but not so much when you're
not so we need tools to define proper
components for the platform so that you
can choose just what you need is the
classpath the right tool for the job
well now as I said jar files aren't
components and those who think if they
beat those annoying questions about is
anything missing is is anything
conflicting how do you ensure
consistency is it safe to change your
internals these aren't questions we want
to have to ask about the platform itself
related problem is well because there's
no such thing as an internal API we have
a bunch of internal classes that people
have used over the years in various
various packages whose names start with
Sun or have AB the string internal in
them Khamsin internal other other
internal things and despite us having
warned against using these for many many
years if there's a web page I found in
the Internet Archive from 1998 the
documents this people have used them
anyway well they're convenient you know
base64-encoded sure why not it's there
it works you know in cases like that or
just for convenience and out of I think
you know developer laziness other cases
like Sun disk unsafe well ok fair that's
the only way you can do stuff like that
the problem with these internal api's is
they become a significant maintenance
burden for those of us who work on the
jdk itself they make it difficult to
evolve the platform perhaps more
importantly they make it difficult to
secure the platform the JDK has lots of
packages many of them are public they
are part of the official se standard API
or they're supported for use as JDK
specific api's but many of them are
private all these things that start with
sun dot those were never intended
for outside use and some of them contain
very powerful api's that can do nasty
things like send this gun safe or
reflection when you're running in a
secure environment how do we keep
potentially adversarial code from using
this well we've got one method drop
lying security manager check package
access if you forget to invoke that
method somewhere to restrict package
access guess what you may be looking at
a CVS s10 that's no fun performance
finally is is another another issue now
peak performance of Java is pretty good
these days but startup performance
continues to be a frustrating problem so
monolithic JDK classpath scalability
maintainability security performance the
problems of the class path we think the
missing abstraction here the common
solution and the right tool for this
particular set of problems is modules
now as proposed modules are not a layer
built above on the platform on top of it
they're there they're built deeply into
it they're a fundamental new kind of
program component implemented in both
the language and the virtual machine
they go well beyond the class path to
provide two key features one is reliable
configuration the other is strong
encapsulation
how do modules fit into the ontology
that we already know well a module is a
kind of a component what kind of
components do we already have we have
classes and interfaces classes and
interfaces get organized into packages
and packages now get organized into
modules so module is a collection of
packages a container of packages it
names the modules upon which it depends
and it can export specific packages for
use only by the modules that depend upon
it how do we define a module well we've
read a little bit of code
here's a module declaration a very
simple module declaration it says this
is a module whose name is comm dot food
bar it names the modules upon which it
depends
in this case it requires some library
module combat food as it exports to
specific packages for use only by the
modules that depend upon it it exports a
package called come conduct food a part
at alpha and another called kam food bar
beta okay so this is a construct in the
java programming language how weird you
put it well by convention these
declarations go in a file called module
- info Java the day.this is kind of like
package - info Java the dashes they're
intentionally because that makes it an
invalid class name what do you do with a
dot Java file well of course you compile
it
you run Java C and you get a little
class file it's a compiled form of the
module declaration we call that a module
descriptor it has a set of so it is
somewhat different name in that form
because we we intend over time to add to
be able to add additional information to
it there you often have information at
build time that's handy to put into a
module descriptor but would be
inappropriate to put in the declaration
itself how do you package up a module
well we could define some entirely new
format but that would make adoption prey
a really tricky challenge so instead
what we've done is define modular jar
files so a modular jar file is a jar
file looks like pretty much any other
jar file but it has a module - input
class file at the root the beauty of
modular jar files is if you build them
properly you can you can make it so that
a modular jar file can work as a module
on Java 9 and later and it can work as a
regular jar file on the class path on
Java 8 and earlier because in those
early releases they'll just ignore the
module descriptor so we have our module
comm fubar it requires Compu Baz which
also has its module declaration and say
we've got another module confu app which
is our actual application and it uses
the confu bar library and maybe it does
some sequel - now what about the
platform itself
where-where's java.lang object whereas
doubling string where's where's IO well
we use the same kinds of declarations to
define those
we started with with this graph many
years ago when we began this effort as
you can see it's it's quite quite the
bowl of spaghetti the important thing
here is is the base module way up there
in red that the base module is the
module that you always need it has
fundamental things in it like java.lang
object and java.lang system and
java.lang string now you might ask the
question okay suppose I just want to
print hello world how many of the
modules in the system will I need and
the answer is kind of depressing because
well everything can refer to everything
else and so my gosh just to print hello
world
I'll need I'll need a Jack's P parser
I'll need CORBA I'll need some JDBC
stuff what thing out what's going on
here well what's going on here is a
couple of decades worth of technical
debt which with over several years of
painstaking work we managed to to clean
up and eventually come up with something
much simpler to understand so this this
is the the SC SC part of the module
graph in the current the current jigsaw
prototype builds as you can see Java dot
base the base model is at the bottom
lots of things depend on it the base
module doesn't depend on anything else
you want to print hello world all you
need is the base module so this graph is
defined by all of the dependents
relationships amongst the SC modules and
as I said these are defined in in module
declarations here's the declaration for
the base module it requires nothing it
exports a whole bunch of stuff no
surprises in this list every module
implicitly requires Java dot base you
can write requires Java type base if you
want to but if you dump the compiler
will insert it insert it for you drop a
dot base is the only module that
requires no others and it's the only
module that's known specifically to the
language and the virtual machine now how
our platform modules packaged well we
could use modular jar files at least for
some of them but a lot many of the jdk
modules have ab native code and in them
they have configuration files and
licenses and other stuff that you need
to need to carry around so we've devised
a new form
called J mod files J mod J mod files are
sort of jar files on on steroids they
have they handle native code and all of
this other stuff they're they're not
intended really for execution they're
more of a transport format used to build
JDK the JDK and JDK like images alright
so we've got our three modules an app
module a couple of library modules we've
got the platform modules and we want to
we want to run our app so all of these
modules collectively will refer to them
as the observable modules to make use of
them at either compile time or runtime
when we try to treat both as uniformly
as we can we need to figure out how the
modules relate to each other based just
on what this app needs so what do we do
well we interpret the module
declarations by reading the module info
dot class files we start with with confu
app it requires calm few bar and it
requires Java dot sequel
okay so we're we're building your graph
and oh yes it requires dropping up base
because every module requires Java that
base we look at our next declaration
comm fubar it requires comm Kubas it
exports some things and it depends on
database confu Baz exports some stuff it
only depends upon Java base Java sequel
requires logging everybody's favorite
logging API and job XML and Java nut
base
logging only requires Java to base xml
only requires Java at base and the base
module itself requires nothing we're
done okay so transitive closure there
you go very very simple computation so
this graph expresses the notion of
readable modules so one module can read
another if it's got an area if it's got
an arrow to that module in this graph
readable modules are the basis of
reliable configuration we can tell if
something is method missing we can tell
if something's duplicated let's look at
the compo app module declaration again
suppose we add requires comm foo
whatever then we compile it which
we compile it we try we try to run this
well at compile-time and run-time there
is no comet ever module compile-time
you'll get an error message module not
found at runtime you'll get an error
message too when you start the Jerry
when you run when you start the VM
module comm few whatever not found
required by comm few app you don't get a
class definite found error ten minutes
after your application started you get
this message right away so that's
reliable configuration what about strong
encapsulation the strong encapsulation
to is driven by the information in
module declarations let's look at them
again and and annotate this this Malvo
graph that we built conf you app it
doesn't export anything konbu bar it
exports confu bar alpha and come to bar
beta confu baz exports this this mumble
package sequel exports a couple of
things
logging exports logging xml exports a
whole bunch of stuff and base exports
even more stuffs and now we know not
only how the modules relate to each
other but what each module exports to
the modules of the reader this is how we
get the notion of accessible types code
in one module can only access a type in
another module if that first module
reads the second module and the second
module exports the package containing
that type accessible types are the basis
of strong encapsulation so here's an
example suppose in the confu bar module
we have a combo bar beta internal
package only meant for internal use and
it's got some beta imple class that's
used across the entire Compu bar module
but is not meant for outside use if comm
foo app tries to import this and use it
what will happen well at compile time
you'll get an error message beta imple
is not accessible because package confu
bar beta internal is not exported if you
manage to compile it by some subterfuge
because your code is out of sync or
whatever and then you go to run it
you'll also get an error message
exception in thread main i won't read
the whole thing
but note that the the error message
tells you that we try to be very
descriptive in these messages they tell
you what cannot be accessed where it is
and why it cannot be accessed so to
recap the essence of the module system
we have module declarations in module
info Java files we compile these into
module descriptors module info class
files we package modules up either as
module or jar files which are now proper
software components rather than file
systems on sticks or J mod files for
cases where we have native code we have
the notion of observable modules we
start with some set of modules that we
wish to use some subset of we run the
transitive closure computation to
resolve a module graph that gives us the
notion of readable modules from readable
modules we get reliable configuration
and then finally by interpreting exports
we have the notion of accessible types
which give us strong encapsulation so
these two properties reliable
configurations strong and capsulation
are uniformly enforced at both
compile-time and run-time so the
configurations of large systems are
essentially correct by construction
alright going back to our pain points
let's see how modules help address them
scalability whether to small devices are
large large large devices as we've seen
modules let us use only what we need how
do we how do we get rid of the stuff
that we don't need well to create custom
runtime images that contain only what
you need we've developed and developed a
new tool a tool that I remember asking
james gosling about 20 years ago why
doesn't Java have a linker well the
answer was obvious at the time right
it's mainly it's mainly mainly dynamic
linking well what we've done is we've
introduced a linker an optional linking
step with a tool called J link J link
takes in modular jar files and and or J
mod files front it runs the resolution
algorithm and figure it figures out the
smallest set of modules that you need
and then creates a custom run
image that only contains those modules
so if you have an application that only
needs you know sequel XML base and and
RMI then you can build a minimal runtime
that contains just those plus your
application all in one nice tidy package
ready to put in a docker imager or
whatever you want for performance we've
taken the opportunity to restructure the
internals of the Java runtime to it to
enable a bunch of interesting kinds of
future work so currently in Java Java 8
and this it goes way way back to 1.2 the
rut runtime is laid out this way there's
there's a bin directory a Lib directory
in doors text RT jar and and a bunch of
other bunch of other stuff we've we've
fairly completely redone this so this is
a change that is affecting tools and and
some applications into a cleaner form
we've set we've separated out
configuration files from the Lib
directory they never they don't belong
there we put them in a place that makes
it clear ok these are things that you
can edit to configure your runtime
environment we've put things in into the
Lib directory that are mainly intended
you know these are these are parts
fundamental parts of the platform that
you shouldn't mess with if you do then
you're probably playing with fire we've
gotten rid of a number of things
the endorsed standards mechanism is gone
the extension mechanism is gone RT jar
is gone the platform's classes are no
longer carried around in a jar file
which is pretty much the most
inefficient format you could possibly
choose to store classes in a runtime
system instead we've developed a new
format happens to be called j image it's
it's very efficient highly optimized
intentionally not documented because we
want to retain the right to change it
over time to make it better so this new
format that this will enable all kinds
of cool stuff J the J link tool has as
plugins for example that'll let that
make it possible to compress things in a
custom way to emit information that you
don't need in your runtime and we're
also looking at how to integrate ahead
of time compilation
ahead of time class data share anything
things like that into this framework to
improve startup time security and
maintainability so we are going to
conceal most internal API is the jdk
behind the strong encapsulation boundary
defined by modules this is going to
break some libraries and existing
libraries and applications now we know
that some of these internal api's are
very broadly used and we know that lots
of lots of interesting products and
libraries depend on them so we're not
going to take them all away right away
the ones that are very broadly used will
remain available in JDK 9 we are we've
been working for several years now on
defining public supported replacements
for those api's as these these supported
replacements become available the old
ones will fade away after allowing
usually a full release cycle for people
to adapt some of the more obscure
internal api's which there's some
evidence that some libraries or
applications use we're just going to
hide there is a way to get at them via a
command line flag to prepare for all of
this there's a tool called Jade EPS with
Jade upses in JDK 8 there's an enhanced
version of it in in the JDK 9 early
access builds Jade EPS is a sort of a
Swiss Army knife of static analysis for
jar files you can run Jade EPS on a jar
file you can ask ask it analyze my use
of JDK and journals and it will it will
go through and tell you at least four
from a static analysis point of view
what internal api's are you using it
will even suggest what you should use
instead so if you want to if you want to
start preparing for JDK 9 today you run
this tool on your jar files figure out
where you're using internal api's and
work to remove those uses finally the
classpath well with with with modules
and and and the module system we're
providing the tools so that you can
bring the benefits of reliable
configuration and strong encapsulation
to your own code but
it's up to you to use them wisely it's a
long road ahead we do not expect modules
to be adopted as rapidly as some other
features we don't expect Java 9 to be
adopted as rapidly as some other
releases and this is due to a few
reasons one is well this u9 is going to
be a fairly disruptive release we
concealing internal API is getting rid
of some some old crufty features yeah
some some stuff is going to break and
that will slow adoption another reason
is that well it's just it's just the
nature of of the feature modules are not
lambda lambda lambda was a jetpack right
you could you could read about it you
could get going right away you could
write little examples you didn't need to
change a whole bunch of stuff in your
system to leverage it models are not a
jetpack modules are more of a seatbelt
they they make it safer so that you can
build large systems you more quickly but
it will it takes relatively more work to
get going with them so jigsaw itself has
been a fairly long road we started
working on this problem back in 2008
it's it's it has been a long road
there's that there's a bit more left to
go it's an example of another long term
investment like generics or lambdas
where we see a pain point we we think we
know what the missing abstraction is but
we take the time to get it right because
we want modules to be a strong
foundation for Jabez next 20 years so I
have barely scratched the surface in the
time I've had here there's lots more to
learn my colleague Alan Bateman and I
are giving multiple sessions this week
to dig into to Jake's jigsaw in more
details today we have prepared for JDK 9
which is mainly about the the
incompatible changes in 9 introduction
to modular development is is kind of the
first baby steps into okay what is a
module how do they work how to use them
in practice advanced modular development
covers the problem of how to migrate an
existing application either from the top
down or the bottom up or some
combination
the tube if you have additional
questions that we don't answer in
sessions you can come to ask the JDK
architects session on Thursday Allen and
I will be there along with a couple of
other folks from Oracle you can ask us
about jigsaw or anything else if you
like and then finally for the for the
real rocket scientist level stuff
project jigsaw under the hood on
Thursday covers the real science of the
module of modules in the module system
the semantics how everything works in in
some detail so this is a big change it's
still a proposal we really value
questions and feedback that we get here
so I encourage you to come to these
sessions for more information all of our
work is documented either in JDK
enhancement proposals which you can find
on the open JDK website there are our
five jep's 200 201 to 20 to 60 and to 61
and the module system itself is going to
be a feature of the Java SE platform so
it has its own jsr jsr 376 thank you
very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>