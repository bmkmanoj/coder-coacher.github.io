<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Move Slow and Mend Things by Kevlin Henney | Coder Coacher - Coaching Coders</title><meta content="Move Slow and Mend Things by Kevlin Henney - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Move Slow and Mend Things by Kevlin Henney</b></h2><h5 class="post__date">2017-11-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1kklyq4XYpw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning is that on can you hear
that yes excellent right so we've talked
about speed interestingly enough this is
a wonderful coincidence because mark
Reinhold was talking about speed of
delivery and then we've also been
talking about insane velocities at the
subatomic level I will include some
physics in this talk but I'm afraid it's
going to be a little bit more
fundamental a bit more Newtonian and
funny enough one of the things we were
talking about last year
Stephan and I was well let's put it this
way take you I want to take you back a
year to the time the nightmares began
actually nightmares began around June by
my reckoning and but the the nightmares
culminated in an event in the US which
happened to be the first day first
conference day of devoxx
because that came as a bit of a
bombshell we're still waiting for the
bombs to actually go off but that's a
matter of time more than anything else
and I told me Stefan about a talk and
some talks though I was doing where I
was trying to look very much
at the connection between developers
what they do how they do it and the
consequences that they have so that's
kind of what this talk is about it's
it's a number of different things
brought together but if you were to ask
me what is this talk about it's about 40
45 minutes long that's the best I can do
so move slower men things what do we
mean by that well this is clearly in
opposition to new fast and break things
which is an old engineering saying
popularized very much very recently by
Facebook and I want to offer a
counterpoint here because we have an
obsession with just getting things out
there just a few weeks ago just in
anticipation of this talk somebody I was
talking to a developer we were looking
at something and he said I can't get
this code working this is a precis this
is the pre 280 character era so I have
reduced it accordingly but you can
imagine
the real conversation when when expanded
up to 280 I can't get this co-working
did you check it before integrating it
yes checked it in the interpreter we
were talking we were messing about with
some Python did it work there no now
this story is not unique
all around the world of software there
are people going well I didn't quite
work there but there's this kind of
deep-seated optimism and to be a
developer you have to have somewhere
within you an optimist because otherwise
you wouldn't do it okay you may have
pushed it down really deeply but it's
still there there's a deep-seated
optimism that hey just because it didn't
work in the test environment in the
repple or whatever you know what if I
just put it in the production system
magic will occur and it will just you
know I will cross my fingers and things
will collide and it'll all work out yeah
and this guy the funny thing is this
this was a recurring story with this guy
it was just like well I didn't work
there so I put it over here in the
bigger system it's just like no you
isolate things this is the this is the
law the principle of modularity we make
things smaller in order to understand
them it's basic reductionism here but
reduction isn't not everything so I will
get to that so we do have this obsession
with speed and it's not helpful in fact
the problem actually that we've ended up
with is that a lot of the time people
refrain they say oh no yeah we do out
velocity we even see it in a lot of
agile development when people are
talking about the progress through a
sprint through their features they use
the term velocity it really bugs me it
really bugs me somewhere in my past I
have a physics degree and this kind of
basic stuff really bugs me they have the
lowest velocity and speed are not the
same okay it turns out that if people
did care about their velocity then that
would be a really good thing okay
just keeping things flat we have the
idea that velocity has direction and it
turns out that going at high speed in
the wrong direction is not helpful okay
this is what most projects optimized for
they optimized for speed they should be
focused on velocity it turns out that if
we understood the direction
we were going we would do better things
hey guess what our technical debt is
rising yeah but we're getting the we're
getting these releases our customers are
unhappy customers yeah we are getting
more bugs or we're getting more code or
we're getting more we need to focus on
all of these things it's an N
dimensional space that we're actually
navigating through to is a very simple
number we can deal with that but there
is this idea that you're not just for if
you are just focused on delivering
functionality you're a crap developer
and your company is going to burn out
fairly quickly
everybody says that speed matters first
to market matters we know this is a
false statement
anybody here still using Alta Vista
right okay all right and I want you to
think about mobile phones again the
operating systems and the phone
manufacturers that we're using now first
to market is irrelevant unless you
actually care about being there for a
while it's how long are you in the
market okay that is what matters
let your opponents make those mistakes
first okay
that's what competition is partly about
so if you want to talk about speed let's
talk about speed what is it it's
displacement with respect to time okay
it's kind of a distance so so what is s
well let's let's let's do this let's do
this measure here's a burn down chart
here's all this OS is I'm going to use a
really technical term here so bear with
me s is short for stuff okay that's a
little too technical we can replace it
with story points or you know anything
else that takes you a fancy but there is
this idea here's all the stuff we're
going to do and then we burn down over
time or I prefer to be a little more
constructive I like the idea of a build
up I tend to call these build up charts
some people pull these burn up charts
I'm speaking as somebody who has a deep
interest in spaceflight and who's also
had children who've had fevers burning
up is a really bad thing so I prefer
build up it's constructive quite
literally we're going to talk about
incremental development here is Inc
gentle yeah after a period of time you
have more stuff than you did before that
is the basis of incremental development
so s is for stuff now the problem here
is how do we measure s this is where our
obsessions get a little bit distracted
okay so a little bit of dimensional
analysis time is a time thing well that
was easy
maybe you measured in days maybe you
measured in hours maybe you measured in
weeks maybe you sit there and you know
because your development process is so
magical mystical maybe you measure it in
phases of the moon you know because
that's what you see when you come out at
night can I've just finished the debug
session yeah now the question is what we
measure stuff in terms of and this is
really this is a difficult thing and
unfortunately or where we take
measurements really important we end up
measuring the wrong things and often
people sort of say well I want you to
we're gonna burn through stuff we're
gonna use proxy measures like story
points or even if we use real points we
end up with a measure of time it turns
out that in many cases these measures
that people say when they estimate how
much effort is this are actually proxy
measures of time this turns out to be a
measure of time against time I wish more
people had numerate degrees when they
went into project management this is a
measure of utilization it's not a
measure of how fast you're going it's a
measure of utilization or at best the
quality of your estimation that's it
you're not actually measuring what
people are doing you're certainly
measuring something and that only keeps
people very happy because there's
numbers and people like numbers we're
not in the petabyte level here well if
people can show numbers with decimal
points that's always impressive if
people say oh it's about a week that
doesn't sound impressive if you say
that's going to be our we reckon that's
a four to three hour and 22 minute job
it's just like wow that's precision we
really care about accuracy precision is
irrelevant okay when it comes to
building things that we have not yet
built before so how do we deal with the
unknown how do we deal with actually
making progress okay it turns out that
there's kind of a there's a there's a
number of loops that people like
this is John Boyd's doodle-loop
John Boyd US Air Force pilot he
basically basically this is this kind of
orthodoxy of how to teach fighter pilots
and what are you gonna do you observe
what's happening you orient yourself you
understand where you're at and where you
want to be where you're at and where you
want to be that is the basis of the
concept of velocity I am here I want to
be there this is direction okay it's not
about the speed aspects about the
direction aspect then you develop a plan
for action and then in the greatest of
Star Trek traditions you make it so okay
so the point here is you've got a
deliberate approach to this instead of
running after things we're going to
cycle through things the idea is that
the cycle is a revisiting and that is a
fundamental concept that a linear
thinking model does not give us now I'm
going to flip this to 180 degrees
because that's just fun actually there's
a reason I'm doing that it turns out
that people are always pushing these
models out and they're always loopy
here's another one it aligns perfectly
the names are different they've been
changed to protect the innocent PDSA
sometimes PDCA plan-do-check-act the
Deming shuart cycle plan establish a
hypothesis a goal or or what it is that
you wish to do this idea of hypothesis
is really interesting in software
development you are not building what
you already know okay we solved that
problem a long time ago yeah if you
already know how to do it then it's
probably in a library okay if you
already know how to do it it's probably
in your intellisense the thing is you
are building something that you haven't
built before oh it might be similar to
but it's not identical the identical
problems been solved so I've got an idea
about how I'm going to do something I've
got an idea about the architecture I've
got an idea
about the performance and I think that
this might be the way to do it I've got
an idea about the domain model based on
my understanding of the business and I
think this might be the way to do it I
don't yet know but it's a hypothesis
what do we do with hypotheses we test
them okay so we're going to do something
about it we're going to
that into action then we're going to
study it and then they were going to
revise act here is different from the
unicycle unicycle and we're gonna act
we're going to do something now what's
interesting here is this is the
foundation of empirical thinking what
you're doing here is you're saying
here's the thing I've got an idea
here's a hypothesis what are we gonna do
about it well let's just try it okay
what are we now gonna do this this is
the hard bit by the way you see there's
a line there's the top half and the
bottom half I often refer to these
things as the water line the water line
if you look at a ship in this in the
water the bit you can't see is below the
water line an iceberg it has a water
line there's an awful lot more below it
the problem is that much of our business
much of our day-to-day work is focused
on everything that is above the water
line if somebody says oh you know
planning yeah I can show you that I can
show you planning in post-its I can show
you planning in Gantt charts I've got
lots of ways of showing planning doing
I've got a whole office full of people
doing yeah you can see doing this you
can see doing this in check-ins you can
see doing this in past tests you can't
kind of see doing this in the way that
they show in films my kids were
desperately disappointed to discover
that software development is not the way
it is portrayed in movies okay in movies
you got some pounding industrial rock
you've got multiple screens and somebody
is just hacking on something the last
minute the code is projected on their
face that's the reason I do
presentations it's the only way you can
get Co projected on your face and it's
all very exciting a roomful of
successful software developers from the
outside speaking as an observational
point of view is no different to a
roomful of people looking at pictures of
cats on the internet it is most
disappointing so we have to look around
for different ways different proxies of
doing this so plan and do you're highly
visible but study what was that so what
does that look like we're thinking we're
thinking real hard and then we're gonna
think about what we're gonna do next
exact it turns out this is the bit that
moves you from mere incrementalism and
speed obsession to understanding
adjustment so
it's a new idea it's not a new idea
it's an idea as old as software
engineering now software engineering
sometimes people this is a classic
conference the NATO conference 1968
Garmisch and some people say that the
conference invented this term this is
not exactly an accurate but there are a
couple of things I want to observe here
first of all just look at the typeface
it's beautiful its glorious this is
1960s this is Gil songs which by an
amazing coincidence is the same font
that is used for 2001 a Space Odyssey
release the same year ok coincidence I
think not
ok mysterious things happen in that film
it's wonderful now the point here is
Margaret Hamilton best known for writing
the software for Apollo 11 or being one
of the key people there and basically
giving us a concept of what soft
software fault tolerance is about she
coined the term originally and a lot of
people say oh well this is set up kind
of like things like the waterfall
lifecycle and anything grained this kind
of plan driven thinking rather than plan
do study act plan do study act we do all
our planning in one go where there's no
deliberation this is not true now I'm
not going to say that the 1960s were
definitely the epitome of human
civilization although there are days I
look at the newspaper and think you know
it wasn't so bad but if we look at
various things spun from a check-in slow
oh it's absolutely lovely the design
process is an iterative 109 68 I will
tell you one thing which can go wrong
with you you're not in the laboratory
and my terms design consists of flow
chart and tilt well obviously there was
no other design notation around but the
basic idea of you can replace that with
anything you like but the idea of doodle
draw think talk to somebody whatever it
is but clarify your thinking flowchart
until you realize until you think you
understand the problem write code until
that you realize that you don't that is
perfect there the rest of this document
is so dry and yet I don't know who this
guy was I've done some googling about
Kinslow can't even find a first name a
check Kinsler
but it's some pretty interesting stuff
but there's some dry humor in there I
love it go back and redo the flowchart
write some more code and iterate to what
you feel is the correct solution we knew
the answer in the 1960s I'm not saying
this is perfect but something happened I
don't know was it disco was it I don't
know 1970s yeah whose Flair's of disco
one of the two but you know we see
within this document there are gems of
wisdom but there is a fundamental thing
here my favorite one of my favorite
authors Neil Gaiman you have to finish
things that's what you learn from you
learn by finishing things the whole
point is to give yourself the
opportunity to do something do it again
do it again learn move further now what
does that mean for software development
as a whole what it means is that there
is no concept of design and refactoring
refactoring is a part of design there is
the bit that you say forward there is
the bit where you say here is what I
think here's what I'm doing and here's
what I now understand and have learnt
and this is what I change if full design
cycle must include this concept
otherwise you build up all kinds of
problems you build up technical debt and
so on but I'm resting here we're going
to talk about improving the design of
existing code what do we mean by code
now for a lot of people they have a very
specific idea of what they mean by code
for a lot of developers they have a very
you say cones yeah a programming
language or an IDE pops into their mind
without their even thinking about it and
when it sometimes people when you ask
them about the code assets of their
project they will tell you but they're
normally thinking primarily of like oh
it's the Java code it's the Scala code
it's the and they're thinking of that
no no I'm talking about the test as well
I'm talking about scripts I'm talking
about the XML and talk about all of it
it's all code okay it all has a formal
grammar it all has a meaning and without
any part of it something in your system
will not run or there is a piece of
knowledge you are missing so when I say
code I mean in the broadest
comprehensive term way possible but
there's another way we can look at it
it's codified knowledge that is what a
code basis there are we often have many
parallels for thinking about what it is
that our code is but I wanted to think I
want you to think about is codified
knowledge it is a basic collective
understanding this is what we currently
believe and this is how we are building
it this is how we've organized this is
our understanding of the domain this is
our understanding of the technologies
and this is our understanding of how
we're going to do this now some of you
might be sitting there going well oh
that's a bit uncomfortable because our
system is a mess what does that say
about our knowledge what it says this is
another way of looking at technical debt
is that unfortunately we have a problem
with updating our knowledge what we find
is that when we come to a system we end
up with this is what we thought last
week this is and what we thought last
year simultaneously with what somebody
thought five years ago and all of these
are current and present that is our
problem we would like there to be this
is our current understanding and have
everything be as close to our current
understanding as possible rather than
having this kind of like sort of
knowledge splurge okay you can kind of
look at the code and from a knowledge
point of view you can say yeah this is
postmodernist this is pre-renaissance
you know it looks like that in some
systems yeah so there is that feeling
but codified knowledge this is a
knowledge base manage it as a knowledge
base so what does that mean for the very
process and practices of software
development if what we're talking about
is the gathering of knowledge and I
don't mean just going on kind of new new
courses and new talks and learning about
new api's I'm talking about
understanding how to work with people
understanding how to work with the
domain understand learning all of this
stuff it's it's it's all knowledge
acquisition that is the primary axis
it's not a production model software
development is not a production thing it
is a knowledge acquisition thing the
production problem was solved a very
very long time ago the basis of
production is here is what I want to
build and then it's built it turns out
and Derek in the previous talk put up
Fortran Fortran is a really important
language in history I wish you would
stay there
okay I was a Fortran programmer once it
is it is if if you want to get paid by
the keyword by the line do Fortran I
recently had to revisit Fortran for a
client and I was astonished at how much
code was was involved I mean earlier
mark mentioned you know velocity in Java
it's just like if you like verbosity
ditched java immediately you are in the
wrong place my friends yeah go for
Fortran however historically very very
important late 1950s it gave us a sense
of here is a thing I would like to have
built and a way to build it it's called
a compiler okay it's a solved problem
software development is not a production
model it is a knowledge acquisition
process that is what you do now I would
just like to point out that knowledge
acquisition is a term that you use to
your superiors and when you're trying to
make a case for something so tell us
about your self a development process
well it's based on a knowledge
acquisition model mmm sounds impressive
the rest of us just call it learning ok
knowledge acquisitions got more
syllables more words more references to
Latin yeah learning nice and simple so
what does that mean what that means in
practice that how do we get knowledge
from one place to another through
communication and it turns out
everything is communication face to face
conversation the code those check-in
messages there's conversations by the
coffee machine everything this is all
communication and what we're after is
two it doesn't matter if one person
knows something
brilliantly and nobody else does we need
to spread the knowledge around there is
this idea if you like that it is not
that we lack the knowledge I think in
software development to be quite frank
based on some of the things I've looked
at recently I think we have solved
pretty much all of the problems that
software development has ever thought of
as a problem all of the problems that
companies are experiencing or a very
large lemme let me not say all over a
precise definition of all 100% so let's
talk about 95 plus percent of the
problems that organizations experience
with software and its development
are solved problems the problem is not
that we haven't solved them it's just
that we haven't got the knowledge
distributed around it's a little bit
like William Gibson's quote the future
is already here it's just not evenly
distributed we actually know how to do
all this stuff it's just not in
everybody's heads at the same time so we
need to get that knowledge around what
does that mean for our view of software
architecture and what a code base is
software architecture is a social
negotiation we tend to think of it as a
technical product and we tend to focus
on certain qualities but actually it's a
it's a it's a it's how we talk to each
other what you're doing when you own as
a software architecture is arranging
who's gonna talk to who at what time
what are the things that are going to
change what are the things you don't
need to worry about one of things you do
need to worry about which means it's a
model of participation now that's quite
important because software development
it's one of those things that we
definitely notes lots of people get
involved it so there is this verb Jax
magazine recently I was interviewed and
I made this point the biggest advantage
of autonomously working teams is risk
reduction through increased group
intelligence group intelligence that's
what we're trying to do you know I mean
it the idea of harnessing up a bunch of
developers and you know sort of
attaching them to a machine is very
cyberpunk you know it's very cool it's
not quite what I'm after but you are
after harnessing Team intelligence but
it turns out that just getting a bunch
of smart people together is not enough
okay there's a little correlation
between a groups collective intelligence
and the IQs of its individual members
okay collective intelligence is a is a
slightly slippery phenomenon you know it
doesn't always work out sometimes you
end up with groupthink and mass
stupidity yeah that may be on your team
in Britain we have referendums we've got
lots of different ways of demonstrating
that so do not assume you are immune to
it in other words there's something else
here not enough to have individually
intelligent people you need to have a
way of coordinating this model of
participation how are they getting on
with each other my code is brilliant but
your sucks does not help because it
means overall the code sucks there's a
sharp discontinuity in the code base and
it turns out that the other person may
have
exactly the same point of view which
doesn't really help so what we're
talking about here is how do we get
people working together this actually
comes from a particular piece of
research a few years ago if a group
includes more women it's collective
intelligence Rises you could be smarter
but I want you to think about this what
we're looking at here is a point that
James Surowiecki made in his book the
wisdom of crowds why the many are
smarter than a few strictly speaking
what I'm interested is not why but when
because there he outlines very very
specific precondition to an intelligent
group to a smart crowd the four
conditions that characterized wise
crowds diversity of opinion you need to
think differently if you're not thinking
differently then it turns out you're not
all thinking okay and the point there is
it's okay we're not talking about toxic
individuals you've always get one kind
of socially crazy individual that kind
of brings down the rest
no don't recruit them we're not talking
about them we are talking about the fact
that not everybody has to think the same
way they draw they they are not
necessarily influenced by other people
and they are able to draw from their own
experience and own knowledge if you
recruit people for company fit or people
like us then what you've just done is
you've actually killed off the some of
the greatest inputs to group
intelligence and a lot of these are very
standard HR but also standard ways in
which people will run startups they will
look for people like them an aggregation
turns out it's no good having all these
brilliant ideas you have to bring it
together the codebase is one place to
bring it together the kitchen is another
place you bring it together these are
all part of a larger system so when I
use the word system I use it very
differently to the meaning of software
system these are around the software
system the other thing though is when we
talk about this stuff when we talk about
speed we're obsessed we're very simple
we're human we're very simple we talk
about things like size it's apparently
size matters which I think's like scale
because it's very impressive from a
business point of view and when we talk
about craft it's this kind of question
of like you know yeah these are both
these are both watercraft
you know it's just like some
organizations favor the smaller model
some say oh no no we we're doing proper
development and you can sense the proper
development or real development comes
with its own font and emphasis when they
say that oh I see what you're doing your
recommendations are fine for a little
team producing toy fizzbuzz solutions
but we're producing enterprise software
we know this because we've got project
managers and we've got enterprise in the
title of other there are by the way if
you don't use the word enterprise there
are a few others that people like to use
they sometimes projects have the word
integration in them that's always a
clear signal global is another popular
one there's lots of different indicators
I still prefer enterprise for the Star
Trek overtones but there is this idea
that what we do is we get more people
and we get more code and we bring it all
together we make it bigger because this
is the basic concept of economics of
scale that would drove the Industrial
Revolution but it turns out we are doing
thought work we are not doing production
work it turns out that knowledge based
work is not a case of mass parallelism
just just just launch the cause and see
what happens soft way to Vallon does not
have economies of scale friend of mine
now and Kelly observe this in beyond
projects it has diseconomies of scale so
I I wanted to reconstruct an equation
and actually I went a bit further than
the equation I was shown something
relatively early in my career it was a
paper and I'd lost the photocopy which
shows you how old it is for those of you
who are too young to know what it is
photocopying is kind of like a
socialized form of scanning okay but I I
had a photocopy of this this paper and I
thought oh I'm gonna try and reconstruct
it and I discovered I actually went a
bit further so let's just state yeah
this is it's simple thought experiment
T's time t1 completion time for one
person how long is it gonna take one
person to do all of the software
development tasks that we need
everything that's involved so I'm not
just talking about coding I'm talking
about deployment I'm talking about the
business requirements I'm talking about
the whole thing all software development
related activities okay then
we step into modern economics in the
industrial revolution we're going to put
n people on a division of labour okay
two people were going to get twice as
fast three people go three times this is
fantastic this is brilliant
wait a moment there can you all do it at
the same time yeah turns out that
there's another equation we may care
about okay the portion you can do in
parallel can you do everything at the
same time now this what happens here
what what informs P what informs P is
the architecture the coding standards
the specialization of roles the
artifacts that are deemed necessary or
appropriate for the project it turns out
that this we create wait States now you
may find it you know then sent many
organizations you don't necessarily find
people sitting in wait States looking at
pictures of cats on the internet we use
other work to fill up the spaces yeah we
organize oh well we're always be busy so
well you know we'll make ourselves
busier with that project when we're
waiting for that project the portion in
parallel turns out to be absolutely
critical and this reflects the
organization around it in fact we were
Ennio this one mystical dam does law we
normally apply it to processes rather
than people okay however this is a good
opportunity for me to point out this is
an idealized model people are not
plug-and-play but there is you know this
is a simplified model um but we go
further what about the fact that people
need to communicate with one another and
talk to one another in the worst
possible case you created a work
environment and an architecture you
created a code base and a culture that
requires everybody to talk to everybody
else at the same time okay
that's the worst case scenario so this
is a reflection of your architecture and
all of these things and there is a
communication overhead so this is the
worst case scenario
it only gets slightly better which
mitigates that but there is this idea
that you get a little bit of control in
that now a lot of people kind of look at
that and go that's really kind of cute
there's lots of parentheses in there I
have no idea okay
people love graphs there you go boom so
what do we learn from this we learn that
if you put no developers on a project
you don't get any progress you also
don't get any bug
so it's not all bad okay it will take
infinite time now as you start adding
people things speed up but what's really
interesting is the form of this curve
the only way you can really change
things is by changing the collective
knowledge not the individual it's the
collective knowledge the flow between
people the architecture there's a few
things you can change you can change the
scope as well the problem is we're very
simple those all sound a bit subtle
we're very simple we like the dial
called n we like that dial and it
becomes a self-fulfilling prophecy
because what you end up with is over
here all the way over here this is where
the consultancies operate yes that'll
take 15 graduates to work on your
project and will charge you per the
person hour yeah it becomes a
self-fulfilling prophecy and then you
get organizations say well you know we
had a project about the same size two
years ago and there were 60 people on
that and that wasn't quite enough so
this time we're going to put 70 people
no try try 30 try 15 be bold and this is
a point that it turns out that above a
certain scale there is no indication and
we've seen so many different examples in
the world of software there's no
indication that functionality correlates
with number of people what it correlates
what number of people correlates with
the amount of work the amount of
busyness and you know he mounts her
self-importance and we end up with some
insane examples what my favorite ones
was this one guy took T SAS application
they had a head this way application got
yes I'm aware of that here yeah so a
head this way because obviously this is
what people need when they enter the
u.s. is you have two security gates
there and there and you have an arrow
and you randomly press it and it goes
left or right telling you which cue to
go in that'll really randomize the
terrorists they'll be completely
befuddled by this you know well you know
didn't see that one coming Perry that
cost fifty thousand dollars to create
and two hundred and fifty thousand
dollars to deploy I want to be the
company
was doing that okay it was an ILO as an
iOS application somebody created this in
ten minutes in a YouTube video and you
know what he was using Android and you
know what he's been fairly relaxed he
was making some mistakes if he really
hurried he could have done it in five
minutes so ten minutes at a slow pace I
decided you know what I think I can do
better than that so the thing I just
showed you on my phone I decided you
know I don't think you even need that I
said I think you can do this in my least
favorite language JavaScript let's just
do this yeah we do that there you go
unload on click there we go
it's script yeah that I'm gonna be I'm
gonna be proper I'm gonna put body and I
can't be pods by HD ml in there you go
that's it that's all that's all you need
I would like to you know I showed this
to my kids and my teenager just looked
at me and said dad why you could have
got paid fifty thousand dollars for this
so no no son I'm trying to debunk the
industry I'm trying to get inside there
I try to shake it up okay yeah whatever
fifty thousand dollars and he knows that
the pound is in a magnificent slide it's
in a swallow dive to the bottom of all
the currencies at the moment so he's
thinking that's nearly 50,000 pounds you
know so the point here is that typing is
not the bottleneck this is a phrase I
came up with about 20 years ago and
Sebastian homido a few years ago created
this beautiful graphic sometimes we
approach things as if this is the
problem in software development maybe
it's not production maybe it's typing
speed maybe maybe that's what we need
we've solved that okay we'll just give
everybody typing lessons and we'll have
the debate about keyboard style and all
the rest of it but this brings us right
back to this question move fast and
break things this is a good thing or a
bad thing I was asked well the short
answer is it's a thing it's a context
specific thing context matters when
apply within the appropriate context it
can be considered a good thing an
invitation to experiment I emphasize
this idea that experimentation I think
is fundamental to the nature of software
we are building a thing that is new in
some way it is either new technology
it's a new domain and we've got new
people whatever it is we are doing
something that is novel in some way
maybe
mostly novel 100% of it is know if
nothing's ever 100% you but maybe it's
mostly new and requires an immense
amount of research effort or maybe it's
a variation of something but the
variation means that there are things
that we do not know so this invitation
to experiment freely without constructed
without restraint to discover new ways
of working and thinking if our job is
knowledge acquisition then thinking is
part of that and maybe we should be open
to the idea that you might get a few
things wrong and you want a framework
for allowing yourself to get things
wrong and not completely screw things up
to break out of an overly comfortable or
start place on the other hand when
applied outside the appropriate context
this whole idea of move fast and break
things can undermine people in their
work it's quite arrogant okay it's quite
irresponsible it means that we start
making mistakes because we are being
careless or because we genuinely have
been careless in the sense of making I'm
not paying attention but also it means
that we don't care since apathy so I've
used the so list of our Facebook our
weekly talk about any social media
buying in talk about Facebook because I
had this rather interesting experience
where foolishly for some reason I
decided I would submit a bug report to
Facebook and I was given this standard
apply or apply your feedback will be
used to improve Facebook I have not
noticed that happening thanks for taking
the time to mat take a report how much
time look at the look at the timestamp
31st of December 1969 that's that's time
travel kids that's awesome that's great
but I don't believe it for a second okay
so I mean I was I I was alive but I
don't think I was busy submitting or in
a position to submit such such a report
but that's suspicious that's kind of
like just before the beginning of time
you want to know about the Big Bang yeah
so Derrick was only dealing with the
beginning of time I'm going back further
knew there's a progression in these
talks you see I'm going back to the
moment before the begin recognizing off
by one era
I reckon it's time T number seconds unix
time it's gone minus one and it's just
taken us back before the first of
January
we've got that so yeah we taken a lot of
time fact let me take you back 10 years
for those of you who something some of
you this might bring back fond memories
okay this is what the Dutch rail website
used to look like and yeah especially
the exception
apparently it turns out that this was a
well known exception because I use I I
was visiting a friend I was at a
conference in Amsterdam and my friend
was in diving text and I thought I'm
gonna go and visit him but let me get an
earlier train there are no earlier
trains there is only Javadoc not null
pointer exception yeah you can tell how
far back this is I mean this is like
this is I was using brazilís so it's
not even Firefox or Chrome um but this
is the interesting thing what we have
here is a revelation that tells you a
great deal about a system there's a sort
of a question here about what's going on
it's it's basically when you drop a
system instead of smashing apples here
I'm going to take some software and I'm
going to drop it and I'm gonna see where
it breaks and where it fractures it
shows you the fault lines it shows you
how it was built it shows you something
at that moment you lose all
encapsulation if you hadn't already
guessed because of the word servlet if
you hadn't already guessed this was a
java-based application it's now visible
to you when we say encapsulation we
don't just mean keep stuff private in
your classes we mean just generally
don't plaster your technology listing
all over your URLs that's you know it
says I've got a perfectly encapsulated
system so why can I see dot JSP dot RB
dot PHP whatever in your URL that's a
that's a betrayal of that and when you
get a stack trace you get this glory
you're using that version of Apache at
the point there is there's a failure and
you see inside the system you see how it
was built so I see it's Java I also
notice other things other things like
how did this get through surely there's
an idea that you should never ever let
this kind of message get through to a
user
okay surely there's a big outer try that
says okay we're going to respond in
Dutch or in English but we're not gonna
respond
okay surely there's this and isn't this
testable can't we test this and what so
the other thing is what kind of culture
produced this what kind of high sense a
group of developers who are under
pressure under speed which is reinforced
a year and a half after this when I
visited the Netherlands and at a
conference I used this slide and
somebody came up to me afterwards they
said you know they still have that now I
don't know if this was at the time if
this was a cherished piece of Dutch
culture you know it defines what it
means to be Dutch you know this is this
is this is us this is how we think yeah
but to imagine that this bug had been
there for a year and a half to the point
that random people on the streets knew
about it that so I think that team were
operating under immense speed what the
quality of the product yeah so anyway
it's got to the point that I collect
these things I collect screenshots
photos of software failure people now
send me this stuff you know you can tell
the technology yes in PHP but it's got
to the point now that somebody actually
coined last year I'm apparently I'm now
I'm now a thing a kefflin any screen
it's calls and indeed this morning on
the way in well done Paul wherever you
are so this is fresh from this morning
oh my way to DevOps Kevin here and
whoops central brilliant there so
apparently I'm now a yeah I had a
question from a friend recently saying
how does it feel to be identified with
software failure that's a very good
question to the point that there's a
conference in Bristol agile where I live
agile in the city this was last year my
the organizer got me he said look
there's a there's a Kevin any screen
downstairs I want to take a picture of
you showing the screen and then I will
post it and then you can retweet it
brilliant anyway agile in the city was
last week so we did this so you know
this may set up a tradition now a point
here is that software failures of any
kind can be amusing and the
these are often inconvenient in quirky
you're going through a station and it's
an inconvenience so you're looking at
something going on oh I I was hoping I'd
be able to tell what platform I was
going to be on but instead I've got a
Windows reboot screen but sometimes it's
more expensive sometimes it has greater
consequence this is an artist's
impression of the sky ferreira Lander
for the ExoMars mission it was supposed
to land on the surface of Mars in
October last year actually it did land
on the surface of Mars October last year
but it's Gizmodo reports not always well
so yeah Pirellis inertial measurement
unit went about its business for some
reason I am you calculate the saturation
maximum period persisted for one second
longer than what would normally be
expected at this stage when the IMU sent
this bogus information to the Crouse
navigation system it calculated a
negative altitude it's positive way is a
very it's a very sort of framed way of
saying it was underground so I read the
the inquiry you've got a loved
spaceflight oh it's an anomaly an
anomaly I must use this for cab you
Larry next time your system goes down
and causes your customers immense
distress we apologize for this anomaly
so I read through it because of the
error in the estimated attitude that
occurred parachute inflation GNC
software projected the range
measurements with an erroneous off
vertical angle and deduced some negative
altitude it turns out that the angle the
calculated angle of the craft was over
90 degrees now for those of you who
remember your trigonometry from school
if you're taking the cosine of an angle
over 90 degrees then it goes negative
and it turns out that this has some
really interesting consequences it also
turns out there was no check for this
impossible situation because that could
never ever happen and so what happens
well this thing now thinks it's on it's
on the ground so what it does is it says
hey guess what we need to go into
landing mode so ditches it ditches the
backshell it ditches the parachute it
does all of this puts out the Landers
brilliant absolutely only one problem
you're 3,700 meters above the ground now
it turns out that although Martian
gravity is is only about two-fifths of
Earth's anything more than zero is
significant and so indeed scaparelli did
land and they've seen the crater from
orbit
but what we're looking at here it's a
really interesting point here simple
testing can prevent most critical
failures this is a testing this is
wonderful paper that looks at a number
of production systems and one of the
most interesting ones almost all
catastrophic failures are the result of
incorrect handling of non fatal errors
explicitly signaled in the software and
it turns out that we can recreate a vast
recourse of these if we try it turns out
that there is a really interesting point
here now when people look at when they
think about software failure when they
think about testing they are looking
very much at a narrow view of what's
involved they are thinking of the
technical stack they're thinking old
testing will slow things down but I want
to present to you the idea that actually
testing is a much much bigger thing
there is decided yes testing does slow
you down at one level but it allows you
to avoid certain certain surprises this
idea of thinking of the technical stack
beyond a system gives us this idea it's
wonderful book christmas is coming
always designers think by considering it
in its next larger context when people
focus on algorithms when they focus on
the basics of their code they focus on
simple correctness ideas and they don't
focus on interesting consequences so to
go back a year we have this interesting
well I'm not just blaming Facebook here
it's just that they have a readily
identifiable brand it's true of many
things Facebook is now in the awkward
position having to explain why they
think they drive purchase decisions but
not voting decisions their systems are
optimized for giving us more of what we
think we want they are organized to
influence and how much do they influence
us some of you may or may not be aware
of this experiment that Facebook ran a
couple of years ago we show via a
massive experiment on facebook that
emotional states can be transferred via
emotional contagion leading people to
experience the same emotions without
their awareness that N equals nearly
700,000 is a reference to the number of
participants who did not know that they
were volunteering for this this is quite
important because
Facebook actually changed its terms and
conditions' about a month after this to
kind of retrofit it it turns out that
you can make people happier or sadder at
this mass influence level by adjusting
the content of their feed and the point
is that feed was optimized for one
particular reason and it does it very
well but now what we're doing is we're
seeing this stuff and love you've got oh
this is terrible this is terrible this
is just like a beater stream you see a
bee testing is based for a commercial
product there is the idea of well yes if
we use this approach it empties people's
bank accounts to buy our products faster
now is that more or less moral I'm not
going to answer that question I just
want to offer you the sense that when we
come to test and frame and specify and
think about our systems there is a
continuum somewhere between innocent a
be testing what is the better website
and the extreme emotional contagion with
major side effects and if we're running
around at speed we're gonna miss stuff
so what I like to do is just end with
this idea that yeah move fast and break
things make sense but we need to
understand the context in which it makes
sense
software is by its nature and
experimental activity it's also
utilitarian commercial activity and we
need to understand where those
boundaries lie and we need to understand
that some of the time we need to kind of
pause we need to slow down you get
faster sometimes by pausing okay in
other words don't spend more time doing
the wrong thing with greater energy that
may look more visible but it's a case
like hang on what would be the better
option here what what mistakes have we
made that I can now fix and ultimately
it comes down to learning thank you very
much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>