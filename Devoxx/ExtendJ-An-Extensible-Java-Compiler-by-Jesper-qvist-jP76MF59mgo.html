<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ExtendJ: An Extensible Java Compiler by Jesper Öqvist | Coder Coacher - Coaching Coders</title><meta content="ExtendJ: An Extensible Java Compiler by Jesper Öqvist - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>ExtendJ: An Extensible Java Compiler by Jesper Öqvist</b></h2><h5 class="post__date">2017-03-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jP76MF59mgo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone I am yes purchased I am a
PhD student at Lund University in Sweden
and today I want to tell you about
extend J so what is X 10 J well it's an
extensible Java compiler and it's a
research compiler that was developed at
my university the first version was
developed by two Bionic mom and I made
the java 7 extension and the java
support was added by a master student
named Eric who gee mom and one
interesting thing is that each java
version we add as an extension upon the
previous java version the compiler is
open source and i am the current
maintainer so what are the goals of this
compiler well we want to try to make it
as easy as possible to add extensions to
the compiler extensions adding new
analysis new language constructs like
operators or new semantics and metrics
tools currently this compiler is being
used for research projects for
experimenting with new java language
features and for our course projects in
our compiler scores so there's an
optional course project where students
spend around three weeks with some
compiler topic and they can choose to
try to make an extension for X 10 J so I
want to show you a few extensions that
have been made to show what's possible
to do with x 10 J so one extension that
a student group made for the course
project was to add static analysis
chicks and they added several static
analysis but one that I can show that
it's very simple and I can show the full
implementation is this stringy quality
checks so
what this does is it checks if you use
the equals operator to compare to string
up to string objects and in Java if you
know Java you probably know that that
this is bad because it compares the
object references and that's not the
string contents so what you want to use
instead is the equals method so this is
the full implementation of this static
analysis and it's written in a language
called just add and it's generated into
Java code so justa days meta compiler
system which generates your compiler for
you and the first the first thing you
see is a line that says that an error
message should be added to the EQ expert
that's the equals operator if it matches
some condition and the condition is
specified by so called attributes which
is this the next part below so the
attribute bad string EQ is true only
when the left and right-hand side of an
equals expression have type string and
we can map this to the source code we
saw before then the left and right-hand
side of eq expert are the left and right
hand side of the EQ the Equality
operator so another extension by a
student group is they had a more
ambitious project they wanted to add the
spread operator to Java so the spread
operator is in for example groovy it's
very useful for collecting say the names
of all people if you have a collection
of people so you can use the spread
operator to collect members of objects
or call some methods on a collection of
objects and this project was quite
ambitious and they they didn't get so
far but you can see this code i'm
showing here has
new operators so they had to add new
parsing to the compiler to support this
and they added static analysis so this
small example goes through the compiler
they made another extension is one that
I made and I made this in collaboration
with German professor for a paper that
we wrote about multiplicities in Java so
the idea of multiplicities is that it
should be very easy to program with
multitudes of objects and it should be
very similar similar to how you program
with just one object at the time so the
code here is working compatible code
where the any annotation tells the
compiler that the people object can
contain multiple persons and that the
concatenation operator normally it only
operates on primitive types and strings
but here use it to add objects to a
collection and then you can call a
method on all objects in this collection
by just calling it as if it was a single
object so I can demonstrate this working
here so i have my compiler and i
compiled this test file which contains
exactly the code you saw in the slide
and then i can run the code to see that
it prints out what I expected so both
Alice and Bob print out that they are
working and just for fun i can i can add
a new person there into the collection
rebuild and then run it again and now we
see that there is a third person who
this work method is called so hopefully
this shows how you can do some really
interesting extensions with the system
but how does it work so to show that i
want to show you how the internals of
the compiler looked and in general a
compiler takes source code and it parses
it in
you an abstract syntax tree and then it
does some work on that abstract syntax
tree and either it generates executable
hopefully and unfortunately some cases
you get errors the work the compiler
does is mainly transformations and
analysis in the abstract syntax tree so
the analysis check if there are errors
that need to be reported and then it's
transformed into an intermediate
reputation tation or to bytecode so
unfortunately this I think to be the bit
crops here but on the left hand side we
have how how is like a regular compiler
structured well it's usually divided
into passes so you run a series of
passes which are implemented as visitors
where each visitor walks over the whole
abstract syntax tree and does some
computation and transformation to the
tree and it writes information out to a
shared data structure and then the next
pass reads data from that data structure
and that its own work so in the
traditional compiler construction there
is a dependency on the order of passes
so if you want to add a new path you
have to insert at it in the right spot
and it also affects this the shared data
that other pass is used so you have to
be careful that you may your changes
don't screw up the work for subsequent
passes so in contrast to this in X 10 J
we used something called attribute
grammars so we declare so-called
attributes on the ast nodes attributes
are essentially equations that define
some property of the node for example
you can have a type attribute which
gives you the type of the road if it's
something that could have a type and you
can have a declaration of tribute which
will find the declaration for example
let's say you have a variable
and you want to know where where it is
declared so you use the deco attribute
to find that and these attributes are
used to generate errors and byte code
executable code and we do this by having
top-level attributes on the program mode
so that the root of the tree here is
represents the whole program and you
just evaluate the errors attribute to
check if there are any errors in the
program and one nice advantage of using
attributes is that the execution is
automatically scheduled so you don't
have to think about the order dependence
which you have in the traditional
compiler with passes and also there is
no shared data structure the attributes
themselves represents the the data
that's computed another advantage is
that attributes favor small-scale
complicated computations so with the
visitors in in your traditional compiler
you tend to make large computations
because you walk over the whole tree you
don't want to do that very many times so
it's favorable to to combine many
computations into one traversal but in
the attribute grammar case with
attributes we we tend to write smaller
computations smaller logical units and
this means that it's it's better for
decomposing into your extensions so you
could reuse the type attribute without
having to run a whole path so I can show
you to make this more concrete I have a
program here which visualizes the
abstract syntax tree in X 10 J so on the
right hand side here is a java program
and on the in the middle is the abstract
syntax tree for the java program and i
assume then on to the if statement in
the middle here and i can click on nodes
and it will highlight
then the node in the program text so I
clicked on the if statement and it has
highlight to the whole if statement so I
can go in here and look at for example
the variable access there and I can on
the left-hand side it's a list of all
the attributes on this node so I can go
in and for example look at the the name
attribute and I can click on that to
evaluate it so now it computed the name
obviously the name attribute is a very
simple attribute because the the name is
just a literal in the source code but
more advanced attributes like the type
or the declaration can be computed just
by by using this interface and if we
take the variable axis here we want to
figure out the declaration I look up the
declaration attribute again by filtering
this list and now it points out and now
I have to zoom out so I apologize to
Texas little bit a little bit small here
but I get this green arrow which points
on to the actual declaration of the
variable so again I be selected by
mistake but now this arrow points to the
Declaration and I can click that
declaration and see all that it's that
part of the source code so this tool is
of course useful and useful for
exploring what you can compute in the
compiler to see what's attributes you
could use for your extension because
that's one large part of making and
extensions having to find these
attributes and I could also show you how
to make a very simple extension and for
this we have a very small base project
that you can use to start making an
extension with and this is just a
project that doesn't do anything it just
runs static analysis on a Java file
and if I run the executable the jar file
I already built this it's as my input
file contain your errors and the input
file here contain contains the beef
statement we saw previously with the
food equals beer test so I would like to
add the spring equality check that I
discussed previously so how can we do
that well we have to add some attributes
and I can go in here into an aspect file
that I prepared and uncomment my
attributes and this is essentially the
same code that we saw previously I
uncomment it and then I rebuild the
compiler and now when it's building you
can see that it's generating java and
this is the justice system which takes
your attribute specifications the code
above and it generates java code and
then that java code has to be compiled
to generate the executable for the
compiler so now we have compiled
everything and i run it on the input
file again and now it says that we
should replace equals operator here so
you can see that it has detected our
problem and we can update it here and
run it again now it should contain no
errors so that's a very quick
demonstration of how to make an
extension in the system and its we we
try to make it very easy to get started
with and our students to use this they
have about three weeks to learn the
system they haven't had any previous
experience except having been introduced
to the concept of attribute grammars and
they they managed to to make useful
extensions in this time so that was all
I wanted to show you
and if you want to find out more you can
go you can head over to extend JS org
where we have documentation about it and
how to get started and tutorials and
stuff like that and if you want to learn
more about attribute grammars the
justice system we have a home page for
that as well so thank you so much for
listening you have any questions yeah
that's a good question and we can you
can analyze control flow and data flow
so yes the question was if you can
analyze control flow graphs or data flow
in extend J and the answer is that you
can build extensions for that and then
use those extensions and we have
extensions for control flow and data
flow analysis already the data flow
analysis i think is little bit all day
with a little outdated for for the
current version version of xn j but
there are two control for extensions one
that I I made during an internship at
Google which analyzes only if you can
select I'm only interested in for
example method calls and then you can
get the control flow graph which
contains only the control flow relevant
to method calls and I think the links to
those extensions should be at extend J
dot org but yeah there are extensions
for that so any other questions okay
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>