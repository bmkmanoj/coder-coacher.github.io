<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java EE 8: What's New in the Java EE 8 Release by David Delabassee | Coder Coacher - Coaching Coders</title><meta content="Java EE 8: What's New in the Java EE 8 Release by David Delabassee - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java EE 8: What's New in the Java EE 8 Release by David Delabassee</b></h2><h5 class="post__date">2017-11-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9VnVZ3j8yDQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so first welcome to this session thanks
for coming it's quite early so today
we're going to discuss Java 8 something
if you have been following the news that
I will also quickly address is e4j and
basically what applies for Java 8 today
we will apply for e4j and e4j for those
who don't know that basically that
Eclipse project that will host the
development of the next iteration of
Java so my name is David Alaba say I
come from Belgium so I'm mostly local
you can find me on Twitter at the rebus
see I work at Oracle in the Java and
container native platform organization
so I do report directly to HQ in the US
so in our org we are responsible for
technologies such as Java EE Java EE but
also open source projects such as gas
fish Jersey open JDK and other stuff
like for example WebLogic server which
is our java ee commercial product we are
also doing other stuff cool stuff like
FN project so a polyglot open source
Savalas platform which has been launched
a few weeks ago at JavaOne so today i'm
going to discuss about java 8 before I
do so some logistic so this was me a few
months ago and I J focus in Sweden and
someone in the audience said that it's
not a real conference unless you read
Oracle safe harbor statement at least
once so please enjoy you can try to
understand what it says but basically
you shouldn't make any process decision
based on for what statement look on
forward-looking statement that I will do
today Java 8 is finalized and has been
released so we're on the safe side so
today I'm going to discuss Java 8 I will
basically give you a quick overview of
the new thing that we have done in a
Java 8 and in a nutshell Java 8 is about
not the modernization of the platform
and simplification of the platform and
you will basically see that through my
presentation today
so the first API that I want to discuss
is jax-rs so in Java 7 we have updated
Jack's arrest to Jack's arrest - and the
big thing in Jack's race - was the
addition of a client-side API so if you
look at Jack's arrest that that was
basically a server-side framework that
you can use to easily expose rest
endpoint but when you had to consume
those hand points you basically had to
write your own client code either using
third-party library or using a very
low-level API such as HTTP URL
connection that's that has been solved
in jax-rs - we have an easy-to-use
client-side framework that you can use
to consume your rest endpoint it works
like this so we have this notion of a
client-side jax-rs container so you need
to have an instance of that client
container so client the other new client
will return you this client then from
that client container you need to
construct the web target so that's
basically where on the network the
remote endpoint is from the web target
you will then construct the request so
that's why I'm doing here in this case I
accept application Jason type I can set
some headers and so on and then once you
have the request you will issue the
request to get some response at some
point in time that's what I'm doing here
so this is an HTTP GET request I expect
to have a list of forecasts as a return
so now we have this fluent based API
that you can use to consume a rest
endpoint the thing is that in this code
this is a blocking call so as soon as
you do the get basically your method
will not return until the remote
endpoint has send the result back and
this is so because we are using the
default invoker which by nature injector
is - is blocking so it's a synchronous
invoker so you see in the first example
I'm not specifying an invoker so that's
a blocking call now the good thing is is
that injector is - we also have an in a
synchronous in block invoker so if you
look at the bottom of the slide we have
this assing method so that that is
basically the same request but this time
we are telling to the jacks or extra and
container that we want to do this
request invocation in a nasan fashion
and if you look at the return type now
we don't have a string anymore but we
have a future of string so that
basically means that we are
a future object that we'll be able to
use at some point in time to get the
result that will be sent by our remote
endpoint get the result or get the error
that might happen so we have a future
object so that means that at some point
in time we will do a get on that feature
object and you know that doing that is
basically a blocking call so yes we have
an a synchronous behavior in a jax-rs
too but we are we haven't solved the
issue because the first call is not
blocking but the second call the one
that will get you the result is a broken
call and also you have to so this one is
locking so something that you have to
make sure is that given the given the
fact that you are going through the
network it's maybe a good idea to set
some time out on the jax-rs level to
make sure that if the network takes too
long to really send the result back your
code will not be stuck forever and you
might also set a timeout on the gate
itself but again this is not a solution
because at the end of the day this is a
blocking call the good news is that in
jax-rs 2 we have also had an invocation
callback facility to basically overcome
that issue with the asking behavior that
is blocking so we have an invocation
callback with two callback completed any
fail so completed will obviously be
invoked when we have the result from the
remote endpoint and failed will be
invoked if something goes wrong so it
works like this so this is a pure jax-rs
client invocation so it's a nothing
request invocation but this time when
I'm doing the request I pass it an
invocation callback implementation with
my to call back right so the completed
callback and the fail callback so that
basically allows us to overcome that
blocking issue now if we put if we put
that in perspective with a very simple
microservices like scenario where we
have a travel agency services that will
provide to user some potential
destination with what
forecasts and quoting surprising
information for all the destination that
would be suggested so it goes like this
so the user connect to the travel agency
services the travel agency services will
have to implement some kind of
orchestration to basically consume the
four back-end services so the first week
quest will go through the customer
services to get the travel story for
that given customer once we have that
the travel agency services will invoke
the destination services to get some
potential destination to suggest based
on the history of the customer and once
we have the destination that we're about
to suggest we want to invoke the weather
services and decoding services to add
some pricing and some weather forecast
to the destination that we're about to
suggest so that means that the travel
engine services will have to implement
this very simple orchestration between
the multiple back-end services using the
jax-rs
client-side API now if we put a weight
on all the requests that we have to to
do we know that we don't want to do that
in a synchronous fashion why because
let's say that we have 10 destination
that we want to send to the user so that
means that for its destination we will
lose a lot of time because we'll have to
do 10 requests to get the querying for
that destination and then we'll have to
do another 10 requests to get the
forecast for those 10 destination so we
want to do that in an icing fashion
because we see that there's some
dependency between the request
invocation for example we first need to
have the customer details before
invoking the destination services but
for example once we have the destination
so once we have the 10 destination that
we will suggest we can invoke in
parallel the destination sorry the
recording services for that given
destination and the weather services for
that same destination and we'll have to
do that time time and if you see at the
end of the day the overall time that it
will takes to get all the results would
be shorter so if we try to implement
that using the jacks or s2 API
well first I will simplify that that
services so order originally we had
for back-end services but for the six
sake of time I will just pretend we have
two services the weather services and
the destination services so if we look
at the jax-rs to existing asking api it
would work like this
so we first do a request it's a nice Inc
request right so that means that so that
request is basically to get the
destination that we want to suggest to
the users so it is a synch request so
that means that we need to pass it an
invocation callback that invocation
callback has to be taught or completed
method so that basically when we have
all the distinction to suggest once we
have all the destination to suggest we
will do another request we will
basically take iterate over all the
destination and do another request which
will be an icing request its time so
that means that we have to pass it a
completed callback so basically one so
that second request is to get the
weather forecast
so basically when we have the
destination and weather forecast we put
that in a synchronous my synchronized
map and obviously we also have to deal
with the error so we have to implement
to a fail callback for the two
invocation callback that we have so I
guess that you you see where I'm going
to so this is basically going to be a
mess it's what we tends to call the
callback hell that's also why I hire to
simplify the code from for services to
to services just to try to make it fit
on two slides that code is very
difficult to write debug and maintain
the good news is that injects rs21 so
java 8 we have at our invoker we have
this rx reactive invoker so it's nothing
invoker but it's reactive one and if you
look at the return type of that one it's
not a future object but it's a type it's
a compression stage of the response side
that is being sent by the by the request
by the response rate so the completion
stage API for those who don't know
that's an API that has been added in
Java SE 8 where we have this notion of
stage or stage being an a synchronous
task
that may or may not produce result and
the completion of a task can trigger the
execution of another task so basically
the completion stage API give us this
ability to define the orchestration that
I was mentioning earlier so we have this
notion of a synchronous task pipeline
execution that we can easily do so an
example would be this one so we have a
first week quest
so it's ask request but we are using the
reactive invoker
so this first request given we are using
directive invoker returns as a
completion stage
so this first request is basically going
to an external services just to get my
public IP address we then have a second
request which take a JSON object and
this one is wrapped in a function and
that second request basically take just
an object and no sorry it takes just an
IP sorry yeah it takes an IP and that
one will basically get invoke external
services to get the geolocalization
based on the IP so now I have those two
requests that I want to chain in a nasan
fashion so all it takes is to use the
compression stage API of se8 so I first
do the first request then I'm using the
den couple doe then compose method
coming from the completion stage API I
pass it my second function so basically
I'm saying ok do the first request once
you have the result once that request is
done you take the result of that and you
invoke the function which which will get
the result of the first request and that
faction happened to be another jax-rs
I think invocation so the second request
invocation is done so then I just need
to basically do something with the
result of the second a request
invocation and in this case it's just a
simple consumer so I have this travel
agency services running on my laptop so
I have the travel agency I have
everything running in fact on my laptop
so the main services that perform the
orchestration and then the for back-end
services so if we look at
so for example I have here so I will
zoom a little bit so I have the back end
services so if I find work this one I
will get some result and everything is
randomly generated so if I invoke it
multiple times I will get a different
result I have a quotation services right
so from Boston sorry from Paris to
Boston it goes to that much now what I
have running here is also the
orchestration using different approach
so the first one is this one the
synchronous one so let's invoke it and
well you see that it takes a bit of time
like well more than four seconds and if
you see here what we have we basically
have the story of the customer we have a
few destination that we want to suggest
to the you to the user like this one
with each time the forecast and the
pricing information and we have that
multiple time so this is the pure
synchronous approach now what I will do
I will invoke the same one but using the
sync approach using the invocation
callback facilities of jax-rs - so not
the direct X raise to 1 and well you see
that it was way faster under 900 means
sorry just around 900 and 900
milliseconds so below once again and
again we have all the result right we
have the destination to suggest and each
time we have some pricing information so
just something related to this a few
weeks ago well it has nothing to do with
Java yet but its few weeks ago I was in
Tel Aviv where I gave basically the same
demo and you know sometimes when you
leave Israel you have to go to a
screening interview basically to explain
what you have done so I was a lucky
winner had to go through that interview
before leaving Israel and I basically
had to explain what I've done the day
before so well I did a conference on
Jack's rest - oh and can you tell us
about jax-rs - well Jax rise - and Jax
rise to 1 and y he heard a new stuff and
obviously the guy on the other side
which is an army officer had no clue
what I was talking about but I had to be
convincing so I had to show my slide and
then in my slide at some point in time I
had a slide demo so I had to do idea
about my demo in front of an army
officer and I can tell you that the
blocking behavior that takes nearly 5
seconds is really long when you have to
wait in front half army officer believe
me anyway back to this one so what I
have also here is basically the same
orchestration scenario but using the
compression stage API so the aurochs
invoker of jacks raised to 1 and if you
see basically we have nearly almost well
we are on par with the pure I think with
the jacks rest to invocation callback
facilities and again we have all result
and so on so basically in terms of
performance where we are on on the same
level not faster not slower so back to
the slide so the question is really when
you should use this new Oryx invoker
well as soon as you have any services
invocation where you have dependents you
between the services you'd better use
the RX invoker because clearly the code
is easier to write maintain you can do
it using the pure I think API of jax-rs
- but that's clearly difficult and also
the arcs invoker is using this new
compression stage api of java c 8 which
is nice having said that we also know
that the compression stage API is not
the only reactive API in the market so
the jax-rs specification has been
designed in a way to allow to allow
other API to be supported it's up to the
jax-rs implementer to decide if they're
going to support those so for Jersey we
support the compression stage API that's
mandatory but we also support the guava
reasonable feature and Erika
energy over two so this is something
which is quite nice I will skip this one
this is a small feature so another big
addition of jax-rs to is SSE support so
SSE is basically a one-way mechanism
that can be used to push from the server
payload to the client it supported by
most of the stand well most of the
modern browser and this is something
which is widely used so we're we're
having support for sec in Jack's arrest
on the server side the doors on the
client side and obviously if you are
using Jack's SEC support on the server
you can combine that with let's say a
browser that support SEC and it's
JavaScript API so injector s-21 we're
having a discipline interface SSE event
which basically just represent an SS
event it's extended on the two side of
the connection so we have outbound SS
event which is the server side view of
an SS event and then we have inbound SSE
event which is the client side view this
is one way only
so it's server to client so that means
that you will create the event on the
server and on the client side you will
not create an even will just consume the
event that are coming through your sse
channel so we then have this object
basically to represent the SSE
connection so SS even thing is a
connection it's an outbound connection
so this is a server side view of the
connection and now it works well the
idea is really to leverage as much as we
can from the existing jax-rs API so this
is the stand after jax-rs
resource method so we are on the server
side we are injecting to object SS even
thing so the connection object and SSE
an entity object which is just some kind
of convenient object that we can use to
make our life a little bit easier then
we just we are just using the standard
jax-rs annotation so this one will
answer to a get that's his path
in my on the network and it will produce
that specific SSE media type right
there's nothing really special here then
at some point in time hopefully you're
as several end point will have to push
some payload to the connected land to do
that you just take the connection object
so the Evan think object which has been
injected and you invoke the send method
on it and you are done what you need to
do we just need to pass it some SSE
event and that's why I'm using here this
SSE object that has been injected is
basically an easy way to create easily
SSE event you will do that multiple time
and you will see at some point in time
when you are done you will have to
actually close the connection on the
server-side right so this is very easy
to use we also have this SSE broadcaster
so that's an assist but castor is just a
collection of connected SSE endpoint so
instead of sending a one to one so you
send directly to the connection object
so you are sending directly to a
connected SSE remote endpoint if you are
sending to a broadcaster you just
broadcast to all the connected as
assessing point of that given
broadcaster then we on the current site
we have assess event source so that's
basically the client side view so we saw
we have the client side container we set
the web target of our remote SSE
endpoint then what we need to do we have
to create the connection object so SSE
even source we set the target we have
the ability to configure it and we will
invoke the build method to actually
construct the object so we are not
establishing the connection at this
point what we also need to make sure we
need to make sure that we do register a
few callbacks one that will have to be a
register is the one that will consume
inbound SSE even type so basically that
that guy will be called whenever there
are some incoming SSE payload coming in
in this case I'm just consuming it so
I'm just painting what is being sent you
can also for example in a register a
throwable type if something goes wrong
that one will be invoked
and then what you need to make sure is
to own the connection object itself
invoke the open connection to open
method so that's basically where you
tell to the client-side container to
establish the SSL connection to reduce
all all the callbacks and so on
and from that point on at any time the
remote decision point will push through
SSE payload automatically your consumer
of in bonus event type will be invoked
and obviously once you are done you need
to make sure to close the connection so
here I'm using the try with resources so
I don't really close well the connection
is automatically closed for me so that
was a very shot of a view of some of the
new stuff that we're doing in Jack's
rs21 SSE and this new Ericsson worker
actually the two major feature of
jacksters two one but there are a bunch
of other smaller features now let's talk
about what we're doing on the JSON front
we are doing two things we have updated
JSON p1 one so the JSONP api that has
been added in Java EE 7 has been updated
and we have introduced a new binding API
so if we look at the first one JSON P
basically doesn't p11 is about to about
adopting stand are coming from the JSON
space the first one JSON pointer is a
standard that is used to basically
reference a location within a JSON
document so it's a very easy to use
syntax so you see an example there slash
event slash location for example so such
event mean we want to use the object
whose key is event and in that object we
want to use the object with key is
location so if we look at a concrete
example so I have a JSON P object whose
JSON representation is on the right side
of the slide so it's an array of two
conference so if I want to use the JSON
pointer
API I first need to create my pointer so
in this case slash one mean we one in
the array we want the object at index
one so we want the second one and in
that object we want the key value whose
key is Venu so now that we have the
pointer we need to do something with it
so we have a human that we can use
yet value is one of them so on my
pointer I invoke the gate value and I
pass it which JSON document I want to
work on and basically what I will get in
return here would be Hilton I also have
the replace operation given it's a
replaced operation we need to specify
what the new value will be and what you
have at the on the right side at the
bottom would be the new document when we
perform that operation something which
is important to mention that J's NPAPI
is an immutable API so that's why when
I'm doing a replace operation I get a
new object we're not changing the
original object and then we have a few
additional operation that we can use
like how to remove and contains value to
test if we have a specific key value so
another standard that is part of JSON
p11 is adjacent patch again the name is
very abuse a patch is just used to
modify a JSON document so the patch in
itself is a JSON document so that you
have an example on the left side so we
have a JSON patch in this case with two
operation so a patch is a JSON document
with one or more per operation and the
patch is atomic meaning that if it one
of the operation fails the complete
patch is aborted the adjacent patch is
using the JSON pointer syntax so that's
why you are for example the first
operation is the replace operation slash
the path is / 0 slash the new so if
we're going to apply this one so slash
zero mean the first object / the new
means the key value with key is Venu so
it's a replace operation we it work so
we can move on to the next operation
it's an ADD operation and this this time
we are having a new key so that would be
the end results now if we look at the
Java side of the API we have two JSON
document the first one is the document
that we want to apply the patch to and
the second one is the JSON patch itself
so we first create a patch using a JSON
document and then we just need to apply
the patch to us
specific targets so that would be the
document that we want to modify again
this is an immutable API so that means
that we would get a new document now
something that we have in jizan p11 is
also this build off button this API
where we can directly create the patch
so we don't have to go through JSON
document creation to create a patch we
can directly construct the patch
basically on the fly so this patch has
for example two operation
so copy replace yeah something is wrong
in my slide because when I create a
patch using the patch builder I need to
make sure I invoke the build method at
the end to actually create the patch but
anyway you get the idea so we create the
patch using this operation then we
invoke the Bill method to actually build
out the patch and then we apply the
patch to the document that we want to
modify a tough stand out that is part of
JSON p11 is merge patch so in JSON patch
you basically averages on document with
operation that will be applied to
another JSON document in March but the
you want to modify document but this
time we will just use key value to
basically describe the difference or the
operation that you want to apply to a
specific target on the Java side of the
API it works exactly the same way so we
have this two way of basically modifying
edges on document but the nice thing
about this until one one is that we also
have the reverse operation so we have
the differently to compare to document
and what we will get in return would be
a JSON patch or merge patch that will
describe the difference between to
document something which is also part of
JSON p11 is this so this is pure JSONP
1.0 code running on top of AC 8 so I'm
using the stream API and you see that at
the end I basically have to write my own
JSON collectors because there is no JSON
collectors in JSONP 1.0 in json p11 this
is salt so we have introduced specific
design collector so you don't have to
create your your own JSON collectors and
then there are a bunch of other smaller
stuff that are done on the JSONP
now let's move on to this new API that
is that is added to Java a SC sorry
- Java 8 that's doesn't b11 so it's
basically API that you can use to
Marshall and on Marshall Java object to
and from JSON document so it's
convention over configuration so the
specification defined basically out the
mashing and in mastering will be done by
default and you as a developer will have
the ability to override that behavior so
it support a basic type it's also
support a bunch of specific JDK type
like you are URL your I date for example
on the dead side on the JSON side we
have one way to represent the date
that's a string on the Java side we have
a bunch of different types so the so the
specification clearly defined the
conversion between the two support
classes with any returns collection
hooray enumeration and so on and so on
and we are have an example here so I
have this simple POJO which is a list of
event so if I want to convert that to
JSON document or JSON document I need to
have adjacent the object so doesn't
builder create will get me that as an
object
I'm not specifying anything so that
means that I will get the default
behavior and then I just have to invoke
the to JSON method I pass it my Java
object and what I get in return is a
string with that specific JSON payload
right so it's very easy to use
each of you see work the other way
around so this time I have sorry so I
have this JSON document that is on the
right side and I want to convert it to a
Java object so again I'm using the JSONP
object this time I'm using the from JSON
method I pass it my string that
contained my JSON payload I pass it the
type that I expect to get and while what
I will get in return would be a Java
object with all the fields coming from
the JSON
pilot obviously I can pass it a reader
or an input stream that's something that
is supported by the API so the way you
will customize the API is for example
using annotation so in my previous
example I haven't specified anything so
that means that everything was inferred
from the java type in this case if you
look at the class even for example if I
don't specify anything the event name
would be even name right but this time
given that I'm using this doesn't be a
property annotation it's basically a way
to tell to the API that I don't want
that field to be called on the JSON side
even name but I want it to be called a
conference you can apply those
annotation at different level and there
are a bunch of way to configure the
behavior of the JSON B API you can set
the naming strategy in which other the
property should be said what should be
done with if you have been re maybe just
some property that you want to ignore in
the in don't conversion what should we
do with the null by default that would
they will be ignore but in sometimes
what you might want to carry them and so
on so we saw that by default if you
don't specify anything you will get the
default behavior you can use the
annotation to configure the API but you
can also use this our JSON the config
object to basically specify out do
nothing and in moshing should should be
done so you create that configure that
configuration object and you pass it to
the design-builder create to create a
specific jason the object with that
behavior and more importantly something
that i didn't mention is the fact that
the design be apply at the end of the
day just a standard api that is sitting
on an existing doesn't be framework i
mean there are there are already a lot
of Jason B framework so we don't want
rings on the wheel so you as a developer
we have to we'll have the ability to use
the standard API and then you will have
the possibility to switch to a different
Jason B frameworks so I think that today
there are three frameworks that are
supporting the design B API if you don't
fit if anything you will get the
reference implementation which is
Eclipse eosin
but you could switch for example to JSON
for example you
you want to do so so let's move on to
the web front on the web front the big
deal is sublet for several at four is
about hiding support for HTTP two so
server-side HTTP to support there are a
bunch of other stuff that are done in
sublet for but clearly a servlet for
it's really about having support for
HTTP two now I don't have the time to
explain each chip between two details
but a cheapy one one was a text-based
protocol HTTP two is a binary based
protocol in HTTP one one if you need to
fetch multiple resource from the same
host your client has basically to do
multiple requests that means opening
multiple TCP socket which is very
expensive in terms of resources on the
client side but also on the suicide in
HTTP 2 given that it's a binary protocol
everything happen over that single
connection that is open over socket
obviously but in HTTP 2 we have this
notion of streams which is just logical
connection so over one physical
connection you can have multiple logical
connection and at the end of the day
this should reduce the latency of your
web application so if you just have to
remember to think about HTTP 2 it's a
binary based protocol and HCP to
preserve all the semantics that you have
been using for years so we still have
this notion of request response we still
have this notion of a cheapy headers
HTTP cookies we still have the notion of
verbs and so on and so on so for you
developers nothing is changing nothing
is changing unless you want to use a
specific feature of HTTP 2 which is
server push so server push is basically
about giving the ability to an HTTP
server to proactively push resources to
a client so in eg p11 the client will
request the server will answer with one
response in HTTP to the can't do a
request and the server has the ability
to answer with one response or multiple
response and this is typically used to
push stuff in the cache before the count
even knows that it will that the count
will need those resources so if you want
to do that you will have to change your
code
so this is always so the push API is
always tied to an incoming request so
it's not like as I see where you have a
completely asynchronous fashion way of
pushing stuff to the client there should
always be an incoming request and then
the server can decide to answer with one
or more responses so I have my incoming
request here and I want to have a put
builder object from that for that given
incoming request then I have the ability
to configure the response that will be
used to push the resources like setting
headers for example and if you see I
need to specify the path of the
resources that I want to push to the
client and then I just need to invoke
the push method so this is basically a
way to tell to myself at container to
try to push that resources proactively
to the plant now there is no way to know
if the resources will be effectively
push to the client so you shouldn't
assume that because you have pulled the
resources that it will be there at the
end but at the end this is another way
to try to reduce the latency of your web
application now if we move on on the on
the web front we have JavaServer faces
and the nice thing with JSF 2-3 is that
it supported spit you out of the box
because it runs on top of Solid 4 but it
also support HTTP to server push
transparently so you take an existing
JSF application you deploy it on top of
a servlet 4 on top of a Java 8
application server and automatically
your application your JSF application
will use not only HTTP 2 but also server
push and you don't have to change the
code for that so this is one of the nice
addition of in GSF 2-3 but I mean there
are a lot of goodies in GSF to tree like
for example we have a WebSocket
a component so you can directly support
you can push in fact a payload from your
JSF application using a JSF component so
the web socket API is not exposed all
you are using is the standard standard
GSF component with the standard JSF
programming model so on the web prompt
we have a servlet 4 and GSF 2 3 now
let's move on to two other API which
part of Java 8 and that is CDI and bean
validation to those two API are led by
our friends at reddit and if we look at
CDI 2 so first CDI is clearly the
background technology of Hawaii what I
mean by that is that if you look at most
of the api of the giant platform they
are using they are relying on the CDI
api it's a quite rich API so we
obviously have dependency injection but
we also have context capabilities we
have interceptors we have an even
mechanism and so on and so on so at the
end of the day the CDI expect what's
getting a little bit too too wide too
rich and if and that was clearly an
issue for people who wanted to use some
part of the CDI API typically on top of
July see so the API was so so rich that
well the CDI container was sometimes
bigger than the application the Java is
the application that was going to use it
so CDI 2 is mainly about boosting the
adoption of CDI outside of the Java
ecosystem so it's not something that is
clearly important for us today as a Java
developers because basically CDI the
whole plot the or CDI API is part of the
platform but that's something which is
quite important for the CI ecosystem so
what they have done in CDI - first they
have split the specification in 3 so you
have CGI core so that's the base that
the core specification based on that you
have CDI for Java C and then based on
that CI for Java and that's what we see
what we Java are consuming we are
consuming the whole CDI API something
else that has been done related to that
effort in CI 2 is basically to
standardize how you can bootstrap in a
standard way or CDI container again this
is not something which is important for
us Java developers because the CDI
container is managed by the java
application server so it's not an api
that we need well we need to use if we
are just programming against the
standard java api the SS in CDI - there
are improvements that are very useful
for us Java developers like this so
forth well if you have been using
you know that we have these this knife
even mechanism since the I wanted zero
in fact so it's a producer consumer
patterns implementation and there is no
tight coupling between the even producer
and even consumer so it works like this
so somewhere in my application I will at
some point in time fire an event so you
see this even type fire so basically I
just want to raise an event I have the
ability to attach some payload and then
somewhere else in my application I will
consume that even so I have a consumer
so a consumer is simply a method that is
using this at observe annotation so this
is basically to tell to my CDI container
that this method should be invoked
whenever that given a method is fired
the thing is that you can have multiple
observer this is a pure synchronous
behavior so if you have multiple
observer until now you had no way to
know in which order they would be
invoked it was up to the CDI
implementation to decide that in CI two
we have the ability to set the ordering
of when we have multiple observer so
it's a it's a welcome addition now you
can know exactly in which other there
will be invoked and more importantly in
CDI two we also have these so if you
look at the previous even event example
everything was done in the same thread
it this was a synchronous so you fire
the event and in the same thread you are
consuming the event in see in CDI two we
have a sync event so it works exactly
the same way so you see that this time
I'm using the ferrocene method so I want
to fire this method in a nursing fashion
you see that the return type is a
compression stage object so that
basically means that I have a an object
that I will be able to use at some point
in time to for example check if
everything went fine or if there has
been some error and then I also need to
specify on the consume inside that this
is indeed a nursing consumer so again it
works the same way so I have a method
but this time I'm using the at observe I
think annotation to tell to my CI
container data see this is indeed a
nursing observer so this is a very nice
- the overall Java programming model and
also you see that on the jax-rs side we
are using a compression stage for the
reactive invoker on the CDI side we are
starting to use the completion stage API
- so basically you can try to combine
things in a more even driven way using
those API another API which is led by
reddit has been validation - if you look
at bean validation - to focus adopting
Java C 8 and introducing new constraint
validation that were part of Ibanez
validator
so basically standardized validation
that were already part in either and
validators so for example in java c 8 we
have the ability to set annotation on
target rice type so we can do this kind
of validation now with bean validation -
so for example the first example so we
have a list of e-mails and what you want
to do in this case you want to apply the
not null and the email validation on all
the element of the list so not on the
list object itself obviously but you
want to make sure that all the emails
you have in your list are not null and
also comply with our email validation
bean validation to support optional type
that has been sorry the optional
container that is part of LCA it also
support validation using the Java EE
date and time API in Java C 8 we have
the ability to repeat annotations so now
you can also repeat constraint
validation without any tricks in bean
validation - so moving on and I will
conclude by talking quickly about this
new API that we are hiring to Java 8 and
that is the security API the name is a
little bit misleading the fact that were
hanging API security API in it doesn't
mean that Java was not secure before the
goal of that API is we to simplify how
you can apply security aspect in your
java application so one of the thing
that this API is adding is this notion
of identity store an identity store is
basically an abstraction where you will
store a call
details like user name and user details
and so on behind the scenes it can be a
database and LDAP doesn't really matter
and the identity store will basically
perform the validation but at no point
in time the in the identity store will
directly interact with the color so this
is an example of an identity Sora which
is defined in the security API the in
here this is digital so this is a
database identity store so basically I'm
using this annotation to specify our our
my my user our store in my database were
seven LDAP one end of you see you have
the ability to write your own identity
store so you just need to implement this
identity store interface and you just
need to implement in fact the validate
method you can also use an entity store
to get additional details then you will
have to implement the gate color groups
method to something else which is part
of the security API is new new
authentication mechanism facilities for
web application it's something that we
already have in the platform it's the
just pick API but if you have been using
the just pick API you will agree that
it's a very difficult to use API so this
is basically a simplification of that
and just for web application and we
expect the notification mechanism to
leverage the identity store that I've
just mentioned before so the
specification is defining three
authentication mechanism basic code form
out and custom form Ochs so this is very
basic but you as a developer I have the
ability to write your own authentication
mechanism using these HTTP
authentication mechanism interface and
again
the only method that you need to
implement is devided request method so
if we put that into perspective so we
have a servlet that we want to secure so
we want in this case we only want to
allow the user in role foo to access
that servlet so in this case I'm I'm I'm
passing it a custom cpiotto notification
and we can
so it's it's my own implementation so I
need to make sure that implement the
validate request and I'm injecting a
custom identity store and this is all it
takes to implement a custom CP
authentication mechanism using a custom
identity store so you see that it's
easier than it was before so we have a
few minutes to wrap up so Java 8 is
really about modernization and
simplification of the platform so I've
shown you a few example on now we we
tackle that one of the things that I
didn't mention is that Java 8 is been on
is this initiate so basically whenever
we had to update an API we try to make
sure that we could leverage what was
provided by AC 8 what's not on my slide
is also all the the API that went
through maintenance release like GPA for
example so in GPA now we have the
ability to support a stream API we have
the ability to support the date and time
API of the YCA so Java 8 today does fish
5 everything has been finalized
you can use GlassFish 5 today to play
and use all those API and obviously
shortly we will have other
implementation coming on the market
everything is on github so you are
really uncorrect to check what what is
there and what you can do with those new
API now I have like one minute to
quickly talk about efore day so this is
a slide that I was using last year
because there were a lot of discussions
regarding the future of Java EE and a
lot of further and well a lot of
questions anyway so now that we are
finalized Java 8 first we as Racal will
support Java 8 in our commercial
supported product WebLogic we expect
other applications of that also support
Java EE 8 but we want to basically
tackle all the question that were that
were raised in the past like from 7 to
80 text for years which is too long for
the market today so basically what we
have said as a Racal the distort of Java
EE well we want to open source the the
development of Java so
we are moving the development of July II
to the Eclipse Foundation to make sure
that basically we can evolve the
platform in a more rapid pace and we
also want to make sure that you as
developers have the ability to more
easily contribute to the development of
the platform this is done under the
afford a project and under the Eclipse
Foundation this is something I mean we
are just at the early days of that
effort we have announced announced that
mid-august since then
IBM Red Hat as join us pirate ami tribe
are are also helping us so if you want
to learn more about it 4j I would
encourage you to come to a panel that we
have tonight where we Oracle IBM red
that pirate Tommy tribe the London Java
community will basically discuss you for
J and you will have the ability to ask a
question and make comments about me for
J because we really think that if or J
is key for moving the platform forward
so with that I would like to thank you
we are just in time well I have 30
seconds for one questions so is there
any questions yes sir so the question is
what happen if the pointer so is so
basically using the J's own pointer if
you point to a syntax syntax that
doesn't exist in the JSON document you
will get an exception any other
questions so I will conclude so we have
the panel tonight there is a specific
session on bit validation too and then
we also have a session where we will
discuss in a little bit more details the
pattern that we can have using the
jax-rs
compression stage support with the CDI
compression stage support so thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>