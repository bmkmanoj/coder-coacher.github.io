<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>55 New Features in JDK 9 by Simon Ritter | Coder Coacher - Coaching Coders</title><meta content="55 New Features in JDK 9 by Simon Ritter - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>55 New Features in JDK 9 by Simon Ritter</b></h2><h5 class="post__date">2017-04-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CMMzG8I23lY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning actually no good after ten
past twelve good afternoon welcome to
fifty five new features in JDK 9 I
submit I'm actually quite impressed to
see so many people here the reason being
that there have been three JDK 9 talks
in a row
there's Joe Darcy then there was Trisha
and now there's me so you get to hear
about JDK 9 from a slightly different
perspective now obviously in JDK 9 is
let me see about three now it's about
four months away from when it's going to
be released and I say that with
confidence that July the 27th is when
Jane K 9 will be released
it is now feature complete sort of
there's still some work going on in the
area of jigsaw but from the point of
view of the rest of the features
everything is actually in there and
they're now on the ramp down phase in
terms of only fixing critical bugs that
will affect to affect the the next
release now what I've done is to go
through 55 new features in JDK 9 which
means we need to move in a reasonable
pace and the first section that I've
created for this is major features
things which are significant in terms of
changes obviously the biggest of those
is modularity in jigsaw now I'm not
going to spend too long talking about
jigsaw because I want to talk about lots
of other features as well but it is
worth mentioning a few of the things
which are happening from the point of
view of modularity and the way that
jigsaw has been implemented first of
those is that the standard class
libraries that we use in Java or
changing from the point of view of how
they are delivered to you in the JDK up
until now we have a single jar file arti
jar which contains all of the class
libraries we can use something like four
and a half thousand in JDK 8 those have
been broken up into a series of modules
and if you
look in the j-mods directory of the JDK
you will find there are 94 modules
currently it has changed a little bit
over time but there are now 94 modules
in the j-mods directory one of the big
things in terms of how jigsaw is working
and the effect that it may have on your
code are that the private AP on is which
you are never supposed to use from RT
jar the ones that were there to make the
public api's work most of those have
been encapsulated that means they're now
no longer accessible to your code as I
say you are never supposed to use them
they were never publicly documented they
were never publicly supported lots of
people however have used them and if you
look at things like libraries if you
look at things like frameworks
frequently they have made use of things
like Sun misc unsafe in order to improve
the efficiency and the performance of
some of their code things have been done
to try and alleviate problems of
portability and backwards compatibility
so right now there are a couple of
command line options which you can use
to turn on the ability to still access
some of those API s so things like some
Mis gun safe clean a couple of
reflection ones these can be accessible
if you add the - - add exports if you
want to import them into your your code
you want them accessible from the module
or - - add add opens is if you want to
access them through reflection so you've
got two command line options that will
turn on the encapsulated critical ap is
also the source code for the JDK has
been made more modular and so now the
idea of using modules in the JDK means
that the source code has been
reorganized to support that module
system this in itself is not the module
system it's just that the JDK modules
obviously have to have source code
associated with them and therefore the
modules are built from that
um just got a little bit more about
modularity in jigsaw because this is
such a big thing in terms of feature
compatibility is an issue it's something
which as I say the fact that the
internal API is the private API is are
being encapsulated is going to have an
impact on some code now you may not have
used some miss gun safe you may not have
used any of the internal API s but most
likely you are using libraries you are
using frameworks and as I say many of
those have used these things there are
ways of overriding the encapsulation
already mentioned but one of the big
things that was in our is just literally
yesterday was what has been called the
big kill switch which is sounds quite
dangerous really but what it actually
means is that you can effectively turn
off modularity you can say right
modularity is going to interfere with my
application code I need it keep working
in JDK 9 so if you set the - - permit
illegal access it will turn off the
modularity system underneath from the
point of view of accessing these AP is
the other thing you can do if you are
concerned about backwards compatibility
you can take your application and you
can simply leave all of your classes all
of your jar files on the class path you
can ignore the module path and you can
simply keep everything on the class path
and you can run your application just as
it was run before so that will will
maintain backwards compatibility with
existing applications and hopefully with
the introduction of the big kill switch
this will make things easier because
there have been a number of things that
have been discussed on the mailing list
that have caused problems even with the
ability to override some of the
accessibility to the encapsulated api's
j-league is another feature related to
modularity and what this allows you to
do is to build a runtime which only
contains the modules that you need for
your application
it's like a stripped-down version of the
runtime for a given application what you
do is you take your module that contains
your application from that the compiler
will be able to build a module
dependency graph and it will know what
modules your application actually
requires and then it can build a
directory structure which looks very
much like the JDK with the JRE in it you
will find a bin directory you will find
a comp directory you will find a j-mods
directory you will find a Lib directory
if you want to create something like
that you can do something like J link -
module path j-mods add modules and in
this case we're just going to have one
which is Java base which means that this
particular runtime will be no real use
since you can't do anything and you
output it to a directory great if you
then run the Java executable within that
directory structure and you say list
mods what you'll get back is Java base
saying that's the only module that is
available in this runtime if we were to
do this for a more realistic example
where we've got some kind of application
which depends on a number of modules and
we do the same thing we list out modules
you will see Java based Java logging jar
SQL jar XML comas all app Zoop Zita so
all the modules you need but none of the
ones you don't so there's no caller
there there's no desktop there anything
else is left out the observant amongst
you we also notice that there's a little
bit of extra information met at 9.0 at
1.0 you may be getting excited you may
be thinking yourself oh look we have
versioning in the module system do not
be excited do not get excited about this
at all
because that is there simply for
information purposes and actually put a
quote here from the documentation the
state of the module system and it says
it is not a goal of the module system to
solve the version selection problem so
don't get excited about using versioning
in your application code in fact the
designers of the module system really
don't
thank versioning to the point that at
the moment the way that module system is
defined is if you try and sneak in
versioning by calling the jar file that
you put your module in say foo - 1.0 or
food - 2.0 what they're going to do is
they're going to strip off the number at
the end so that you can't sneak in
versioning that way now whether that
actually gets through to the end of the
development phase there's a little bit
debatable at the moment because of
course there are some libraries and
packages which use numbers at the end
which aren't versioning so you know but
there's all sorts of examples of this
that people come up with and so it's
quite likely that that is going to
change before the final release but
we'll wait and see
next thing factory methods for
collections so one of the things that is
often the kind of thing that we want to
do is to create a collection and to be
able to provide a set of values when we
create the collection and up until now
it's been quite complicated and in fact
if you look at an example here what
we're going to do is we're going to have
to create a set which in this case is
going to be a hash set we then have to
add each element individually ABC and
then if we want it to be an immutable
unmodifiable set we then have to call a
method on the collection to say use this
or in fact we call the collections
utility methods unmodifiable set pass in
set and get back and unmodifiable one so
that's you know a lot boilerplate code
and is not very clean really so what JDK
9 does is introduce a new set of methods
which allow you to do things like this
so set string set equal set of ABC one
line of code rather than five now the
way this has been implemented is that
there are eleven there's twelve methods
that have been added to the list the set
and the back class interface right and
so there are versions that are
overloaded which are from 0 to 10
elements so there's a specific method
which takes 3 hours
there's a specific method X 4 5 6 and so
on but there's also one which takes
varargs
now the reasoning for this is that in
order to make the code more efficient
it's easier to have a set of overloaded
methods which take a variable number of
arguments or specific number of
arguments but then once you go beyond 10
you can use the VAR args version of it
and so you can provide an arbitrary
number of values to the particular
method string enhancements streams were
obviously one of the big features in JDK
8 very popular from the point of view of
providing a more functional style of
programming few things been added to
this there's a couple of new methods
drop while and take while these are
quite similar in structure to the way
that the Skip and limit methods work at
the moment skip and limit allow you to
as the name would suggest skip a certain
number of elements on the input stream
before you start taking them and
processing them but the way you do that
is by specifying a number so you have to
have an absolute value associated with
that limit is the opposite of that where
you say I only want to take the first n
elements of the input stream and then I
want to drop the rest of them again an
absolute value drop while and take while
do effectively the same thing in that
they will either take a certain number
of elements from the input stream and
then stop or they will ignore a certain
number of elements from the input stream
before starting but the way that that is
done is rather than using an absolute
value it uses a predicate so you can
have a condition associated with that
and say I want to drop while this
condition is false once it becomes true
then I start taking elements one thing I
would say about that is that you do need
to be a little bit careful because if
you have an unordered stream you could
get a situation where you say take while
certain condition is false once it turns
true I stop taking elements from the
input stream but if it's an unordered
stream you may well get elements in the
input stream that
would have satisfied that criteria after
the stream stops taking input elements
so just be aware of that using an
ordered stream will eliminate that
problem the iterate method has been
improved so there is now an iterate
method which looks a lot like the for
loop so you have an initial value you
have a condition associated with when
that iterate is going to stop and then
you have a third argument this is what's
been added third argument which allows
you to say what happens on each
iteration of that iterate so it looks
like the existing for loop from the
point of view of the the structure of it
the firewall files dot lines has been
included now which is a way of having
parallel access to the lines of a file
what this means is that if previously if
you try to have something like a
bufferedreader attached to a file and
read the information from that
processing it as a parallel stream it
would run very very badly because
clearly it's a sequential stream of
strings being read from the file you're
trying to process it in parallel they
don't match there's a real impedance
mismatch there files got lines memory
Maps your file into memory and then
divide it up based on line breaks and
tries to separate it out in terms of you
know however many threads you want in
terms of the parallel processing that
way you can have each thread being able
to access strings from the the lines
from the file independently and
therefore you can get a benefit from
parallel processing rather than
sequential processing optional now has a
new method and it allows you to get a
stream from an optional might seem a
little bit strange but essentially what
you're going to get is a stream of 0 or
1 elements depending on whether is a
null or a value associated with that
optional multi release jar files this is
the idea that you can have several
having said that the the designers of
jigsaw don't like
versioning what they actually going to
allow you to do is put multiple versions
of a specific class file in a single jar
file and the idea is that the version
will be associated with the version of
the runtime so you will have a JDK 9
version of your class you'll have a JDK
10 version of your class JDK 11 version
of your class you'll notice I didn't
mention JDK 8 or earlier so this only
starts at JDK 9 so right now a multi
release jar file can only support one
release which is JDK 9 when we get to
JDK 10 you'll be able to support two
releases and so on and so forth but
right now it's a single multi release
jar file which is kind of strange but
anyway that you have to start somewhere
I guess that's the point
so few changes that have been made in
terms of the way that works so the class
loaders have been updated to support the
idea of multi release jar files the jar
file API itself has also been adapted to
support this and the relevant tools
things like java c java p jep's and so
on have been adapted repple J shell
again this is a very major feature what
we got here is the idea of a read eval
print loop this allows you to do simple
prototyping I must admit when I first
saw this I sort of thought to myself ok
it's kind of like a novel feature but
I'm not sure how much I'll use it and
then you actually start writing code and
you think yourself Oh wouldn't it be
good if I could just test this little
bit of code without having to like run
it through the whole compile the
compiler thing and so you go to jail and
you type in your code you go all
actually that's really good because now
I can test what's actually happening
with my code and then I go back to the
IDE and now I understand what's
happening in a clearer way and I can
test things so it is actually I find a
really useful thing of course you can
tell how old I am because green on black
so it's kind of a comfortable feeling
for me because it's more like a vt100
terminal concurrency updates a couple of
things that have been changed here what
are the really sort of substantial
things is that there's now a more
reactive way of doing streams
so there's a publish/subscribe framework
this is all around the idea of having a
synchronous non-blocking support in the
same way that you've got our X Java and
other sort of reactive frameworks that
are proven to be very popular at the
moment this is all based on the idea of
a flow so there's a flow class and then
associated with that you've got
publishers subscribers processors and a
subscription and the idea is you can
have a submission publisher utility
class so you can say right I want to
have a subscriber to a set of messages
from a publisher and then you'll get the
the various messages being passed back
and forth that will happen in an
asynchronous way to current subscribers
and you have to implement the flow dot
processor so there's a reasonably simple
way of doing it and it's a nice clean
API for that concurrency updates again
so from the point of view of completable
future completable future is introducing
JDK 8 this has now been kind of extended
a bit to add some new features things
like the idea of delays and timeouts
there's also better support for the idea
of sub classing the completable future a
number of situations where people want
to be able to do that and there are some
new utility methods there's things like
a minimal completion stage there's a
failed stage and two that I particularly
liked which was the idea of a new
incomplete future and a failed future so
there you go you can have a failed
future in hot deprecation so deprecation
has been around for a long time right
back to JDK 1.1 when the deprecated Java
doc tag was introduced and then in JDK 5
the deprecated annotation was added to
allow certain elements of the API to be
marked as no longer being required and
at some point in the future they may be
removed now if you look at the number of
elements that have been marked as
deprecated there's literally hundreds of
them there's something like 300 methods
that have been deprecated in the stand
Java API up until now absolutely none of
them have ever been removed which is
great for backwards compatibility but is
not really ideal from the point of view
of evolving an API in a clean way in JDK
9 as part of the modularity changes six
particular methods will be removed that
have been deprecated in the past six
public API s that have been deprecated
in the past are being removed in jk9
that's all to do with the ability to be
able to separate out the the runtime
libraries into the specific modules but
deprecation itself is being updated so
having the deprecated tag having the
deprecated annotation was problematic
because there were too many situations
that that trying to cover without
providing enough detail about what was
actually happening so now if you look at
the deprecated annotation there are two
new methods that are being added to that
one is the for removal method which
returns a boolean true or false and what
that says is will this particular
element ever be removed because there
are certain situations where you want to
say well there is a better way of doing
this but we don't want to remove it
because it still makes sense to leave it
in the API other ones are in the
situation where yes they really do need
to be removed at some point so by
marking them for removal the idea is if
that comes back true it will potentially
be removed in the next release that's
the goal is to remove them and remove
them in the next release associated with
that there's also a new method called
since it returns a string and what that
will do is will return you the version
when that particular element was
deprecated so you will see you know
version 8 version 9 version 10 so on a
number of deprecated tags have been
added to various methods and so on in
the API but interestingly two methods
have been given a reprieve so they've
had the deprecated tangle removed so if
you look at Java awp AWT component
there are show and hide methods there
they were deprecated in JDK 9 they are
no longer deprecated they've been
brought back from the dead as it were
and then there's also a very useful new
command called JD press scan which will
analyze your code and it will look
through you basically give it a jar file
or you can give it source code and it
will look for it and it will tell you
where you have used deprecated methods
so give you a report on what you might
need to change milling project Queen
so project coin was back in JDK 7 and
that was the idea of adding a number of
small language features things like the
diamond operator things like strings in
switch statement and the try with
resources way of doing things things
that are changing there are some again
very small changes to improve the
language little bit one of those is that
a single underscore is no longer going
to be valid as an identifier so hands up
anybody who's used a single underscore
as a variable name I see nobody that's
good well the good news is that if you
really do want to use a single
underscore as a variable name you can
actually just make it a double
underscore and that's still valid
because I tried it and it will work not
because I was actually writing code
where I wanted to use an underscore as a
variable name but anyway the reason for
this is so that understand single
underscore can be reused in the future
to indicate situations where you have a
variable which is a parameter that's not
going to be used so a good example of
that is if you have a lambda expression
with a single parameter which is not
used in the body of the lambda
expression by using the underbar you can
then make the syntax potentially simpler
and and just kind of make it more
readable in that sense private methods
in interfaces because JDK 8 introduced
the idea of default methods and static
methods being supported in interfaces
essentially adding multiple inheritance
of behavior as well as multiple
inheritance of types it now makes sense
to also add private methods you can have
a private static method or you can have
a private instance method
and so what that will allow you to do is
to have helper methods associated with
the default methods or the static
methods in that particular interface try
with resources is being changed slightly
so that now rather than having to
declare the the definition of the
variables that you want to use within
the try block you can actually access
variables from outside of the try block
but they must be either explicitly
marked final or effectively final so
they behave as if they're final you can
then reference those within your try
finally block and the code will actually
take care of ensuring that the finally
Clause is called and so you can do
things like closing files or terminating
things as you need to save logs on
private instance methods this is just a
fairly minor change which relates to the
fact that safe varargs simplifies the
way some of the things work from the
point of view of eliminating some error
messages that's what warning messages
that you get which actually don't really
need to be provided to you because it's
a safe situation so now in addition to
constructors being able to have safe
varargs associated with them final
methods and static methods private
methods will also be able to not be
marked with the safer of varargs
annotation the diamond operator with
anonymous classes is also being extended
slightly to use type inference in a
better way and the reason for this is
that if you look at the way things work
with the diamond operator this is to do
with generics so use the diamond
operator where you don't have to specify
the generic type explicitly if you look
at generic types and anonymous classes
they don't quite work together in the
way they should
in jdk 8 and earlier I mean I said they
don't quite work the way it should in
terms of the compilation so now I'm
allowing the type inference to work in a
slightly better way it means you can use
the diamond operator when you're using
an anonymous class
next big section is updates in terms of
standards because it's obviously always
useful to make sure that we are
supporting the latest version of the
standards that are relevant so first of
these is Unicode so we have Unicode 7
and Unicode 8 that have been provided
since JDK 8 was was launched and if you
look at Unicode 7 there are two thousand
eight hundred and thirty-four new
characters I look to that I thought
really two thousand eight hundred
characters they managed to find so if
you look at that a little bit more
detail what you find is that there are
mostly emojis that have been added to
Unicode seven funnily enough there's
also the ruble currency symbol and the
currency symbol for Azerbaijan so just
as a small piece of information and then
in Unicode eight we added another seven
thousand seven hundred characters there
you go how is that possible if you had
it you know during nearly three thousand
in Unicode seven how did you find
another eight thousand for Unicode eight
and the answer is again a lot more
emojis but also interestingly they added
support for Cherokee in lower case
already had Cherokee and upper case they
added Cherokee in lower case so great ok
that's the way it works so now you can
do that also in terms of some security
stuff so it's update in terms of the way
the key stores works so now it's public
key store cryptography is twelve is
being used by default rather than the
Java cryptography Java key store sorry
html5 Java Docs so making the Java Docs
a little bit prettier keeping things
update and also moving to the sha-3 hash
algorithm so trying to keep ahead of the
hackers few other smaller features now
property files can use utf-8 and what
this means is that you can use Unicode
for your property files that means that
now because we support unicode eight you
can use lowercase Cherokee in your
property file so you know
I'll have to shout in Cherokee
resourcebundle API have to be updated to
deal with that then there's this thing
called D RPG based secure random
implementations drbg is a deterministic
random bit generator I must admit I
looked at that and I thought in an
oxymoron a deterministic random bit
generator I don't know but anyway we now
support that and then the xml catalog
API which is a way of supporting some of
the metadata to do with when you're
processing xml so now there's a support
for the oasis xml catalog api version
1.1 and that works with the java api for
xml parsing things that have changed
inside the JVM next big section so the
first of these is that the default
collector is changing in JDK 9 so this
is something that you definitely need to
be aware of if garbage collection and
the way that works is important to you
right now if you're using a server class
machine which dates back a few years and
so it's a dual processor 2 gigabytes of
memory or more you will be using the
parallel collector because most people
like low pause collection it's now going
to be G 1 as the default collector G
ones been around for a while so it's
fairly mature it works very well its
production ready and as I say it's a low
pause collector few things were also
added in terms of JDK 8 some the updates
that improve the way that G 1 worked
things like the ability to have
concurrent class loading was added
however having said that I work for is
also you get a very brief sales pitch
here which is g1 collector falls back to
a full compacting collection if it can't
keep up with the rate of allocation and
the write that garbage is being
generated that means you will still get
significant pauses in your application
code so if you don't want those you can
always try and zing zing is a pause this
garbage collector we have sold the
problem of garbage collection so if
you're interested in that
happy to talk to you more about that
afterwards better string performance
strings we use a lot in Java so any way
that we can improve the performance of
how strings are handled will be an
improvement on a lot of application code
compact strings is one of the things
that have been has been introduced in
JDK 9 now what that is about is not
compacting like not using alternative
encodings to to compress the strings in
a different way but it's really just
making the way that the space is used in
the string class more efficient it's a
fairly small low-level feature that you
won't really see anything any great
benefit from unless you're using a lot
of strings and doing a lot of string
processing the other thing is the idea
of using the what's called the CD s
archive which is the common something
rather way of storing things so this
enables you to share strings between
different JVM s so you can actually have
multiple JVM and rather than having to
have copies of strings in all the heaps
of those those JVMs you can have one
copy and it's actually shared between
them so it's better if you're running
multiple JVMs the the way string
concatenation works has also been
modified so now it's using the invoke
what's actually using the it's the way
that works internally is being changed
so that you've got a different way of
doing the bytecode sequence and it's
using the invokedynamic bytecode so that
it can shift the implementation away
from the compiled time code to when the
code is actually run on the JVM and that
gives the ability to have not just
slight improvement in performance now
but it also allows for changes to the
way the JVM handles string concatenation
in the future without having to
recompile your code another feature that
has been added is the graphics render
renderer so if you're using graphics in
your system then at the moment there is
an open source implementation that's
part of the open JDK that's called pices
if you get the binary from Oracle they
actually replace that with a closed
source version called duct
that gives much better performance to
address that there is now the thing
graphics render are called Marlin which
gives pretty much the same performance
as the ductus 1 but is open source and
this graph here which looks very
complicated is essentially measuring
impact of the graphics renderer on
application code GREEN line is where you
can see the Pisces renderer so
essentially what you're seeing there is
greater latency associated with that
whereas the blue and the red which are
pretty much on top of each other are the
ductus and the modeling graphic
surrender Esther they're fairly similar
in terms performance some smaller
features improvements to contended
locking so what this does now is again
internally it does some different things
in terms of field reordering it dozen
different things in terms of the cache
lines are used so that when you have got
a situation where you've got multiple
threads or trying to access the same
lock things will work in a slightly more
performant way leveraging CPU
instructions for certain hashing
algorithms and encryption algorithms a
lot of processors now have the ability
to support Hardware of hardware
acceleration of this so now that's going
to be used directly from the JVM this
gives quite a lot of speed-up you see in
certain tests of these things then you
get a speed-up of somewhere between 34
and 150 times what you have before
JavaFX
for those of you using it that's been
upgraded in terms of gstreamer so that's
the way of rendering video to the screen
so there's new version of that it's
updated
that's replicas are used in terms of
media class gives you better security
better stability and as I say better
performance couple other smaller
features in terms of the JVM you've now
got a segmented code cache so what this
does is again just reorganizing things
internally in the JVM and how it caches
the code that's used where you've done
adaptive compilation of
particular methods so you've got
separate non method profiled and non
profiled code logging logging has been
unified in the JVM so rather than having
lots of different ways of doing logging
for different parts of the system
there's now common way of doing that for
all components of the JVM and related to
that is the idea of GC logging so GC
logging now uses the unified logging to
give you the messages that you need in
terms of how your garbage collector is
working specialized changes to JDK 9 so
one of these is very small change it's
called spin weight hints and as Zul
we're we're very proud of this because
we proposed this as a jdk enhancement
proposal and so as i say we rock the
idea of this is to help with performance
we're always very concerned in terms of
making sure the JVM performs as well as
possible what we wanted to do is prove
that the jet idea works for companies
outside of Oracle not many people have
actually proposed Jets who are not part
of Oracle we're one of them and this is
the first one that's actually been
accepted and integrated into the JDK it
is a very small change but potentially
with huge impacts because it changes or
adds a method to the thread class since
thread classes use a lot in Java we need
to make sure that any changes made to
that are very carefully controlled and
reviewed very carefully so we're adding
one method on spin weight to thread
class what this allows you to do is to
tell the JVM where you think that the
processor might be spinning in order to
wait for a particular situations happen
there are certain things that can happen
in terms of the hardware underneath
where rather than actually spinning the
processor it will actually in effect
pause the processor the advantage of
that is that it gives you better power
consumption and it also means it will
wake up slightly faster so it's again
very low-level feature but potentially
it can be useful especially if you're in
a big data center and you've got a lot
of this going on it will
potentially save you heat and energy
variable handles so this is working
towards a replacement for some Mis gun
safe some Mis got and safe is still
accessible in JDK 9 but the idea is it's
going away
so will be encapsulated in JDK 10 you
won't be able to access it anymore
obviously because people have used it a
public API needs to be made available
which gives people the same
functionality but in a documented and
supported way variable handles are part
of that and what variable handles allow
you to do is to take some of the
instance variables you have associated
with a particular method particular
class and then you can put a fence
around them from the point of view of
memory access you can treat them in
essence as if they are if you have
several operations you can treat them as
an atomic operation without having to
put them inside or use an atomic class
instance so there's already the atomic
class as part of the concurrency
utilities but that's obviously a lot
heavier weight because you have to
create an instance of that class and
then you have to use your instance
variables with it now what you'll be
able to do is say right I just want to
fence around this set of operations and
the the JVM and therefore the CPU will
treat them as if they are an atomic
operation there are various things that
you can use with a variable hand also
there's compare an exchange compare and
set as you would expect get an add
getting a set a quiet fence release
fence so there's simple ways of actually
using that enhanced method handles so
method handles have been around for a
little while they introduced in JDK
seven what this does is really just
extend the way that you can use method
handles so now you've got support for
the idea of a loop using method handles
you also got support for the idea of try
finding blocks using method handles
different ways of doing argument
handling so that you can do spreading
which is where you take a number of
argument if you've got an array of
arguments you can actually spread them
out into individual arguments collection
which is the opposite of that you take
the arguments and then you
packaged it up into an array and folding
which is where you can sort of say okay
I want this set of arguments from the
whole set and doing things with with
that in ways that make sense
few more lookup functions in terms being
access method handles so now you have
the idea of non abstract methods in both
interfaces and classes being able to
method handles associated with them some
smaller features in respect to this so
compiler control there's a now a way to
do this this is the JIT compiler not the
java c compiler so you can actually tell
the JIT compiler certain things through
the use of a directive file so you can
give it information about how you want
it to deal with adaptive compilation
when it's when it starts up and when
it's running it also inject those
changes using the j command command and
you can say right i want to change
something at runtime of how the compiler
for the JIT works in respect to C 1 and
C 2 a few changes around the process API
what this is intended to do is to
provide you with more information about
what's happening at the operating system
the reason for that really is that
operating systems now are very common in
terms of the way that they treat
processes so you have a common set of
data that's associated with those things
so now you've got the idea of a native
process either as a process or a process
handle you've also got more information
about those processes the process ID the
arguments that were provided to that
process the start time the CPU usage and
the name and then in terms of using that
obviously there is some control so
depends on the security managers how
much information you can actually get
from the process itself housekeeping
things that have been changed in that
respect so new version string format
this is this is a good idea but is also
potentially something that might affect
backwards compatibility if you rely on
testing the version string associated
with the Java Runtime you may have to
change your
code to taking account of the the new
way that this works the version string
in Java has always been a little bit
confusing because you have this way of
expressing things depending on whether
you look at the JDK externally or JDK
internally so we have right now you have
JDK 8 Update 1 2 1 right well ok that
means we've got JDK 8 update 1 to 1 but
also if you look internally you'll find
it's actually JDK 1.8 dot 0 under bar
one new one to one which is you know ok
so why is it 1.8 well the answer to that
is that back in JDK 1.2 or yes JDK 1.2
that was when Java SE 2 job 2 SE came
about because they decided to rebrand
Java Java to see how Java 2 version 1.2
then he had Java 2 version 1.3 Java 2
version 1.4 and then they decided ok
there was never going to be a Java 3 and
so it will be Java 5 ok so we're this is
where marketing meets engineering and it
doesn't necessarily always work so
you've got this different problem of
understanding the the actual stream what
numbers are involved but also you've got
this problem of the way that you have
updates so is JDK 7 update 55 or JDK 7
update 60 which has more patches well
logically you would say 60 that actually
is 55 just because of the way that it
works so now there is a new simpler way
of doing things there's going to be JDK
major minor security and patch so for
different elements to the number easy to
understand by humans easier to
understand by code because you can pause
it much more easily and this is much
more based on the idea of semantic
versioning the structure of the JDK and
the JRE is changing so if you look at
JDK 8 and earlier what you have is the
JDK and then below that you've got a bin
directory bin directory has Java in it
it has Java Sea has Java age and so on
it has a Lib directory which has a tool
jar file in it
and then you've got a JRE directory
within JDK if you look in that you've
got a bin directory bin directories got
a jar in it which means you've got two
copies of Java they may be a symbolic
link but there's still two copies of it
and you've got a Lib directory with RT
jar in it that's all changing in jdk 9j
uk9 uses a flatter directory structure
now you have JDK nine you have a bin
directory with one copy of Java in it
Java C Java H so you have a conf
directory which is where any of the
files which you can potentially as a
user change will be placed before they
were kind of distributed around and it
wasn't clear whether configuration files
should be changed by you or whether it
should be left alone now anything in the
Cole directory is something that
potentially you could change and the Lib
directory is not going to have any jar
files in it
there's also J mod file a jmo directory
which has all the Java modules in it the
Lib directory has a native code that's
required for the particular JVM that
you're running no more JRE directory no
more tools jar and MRRT jar few smaller
features searchable API documentation of
this is just the best thing this is my
favorite feature in JDK 9 the fact that
finally you don't have to scroll all the
way down the the list of API is in the
Java Docs to get to string for example
you can just type it into the search bar
and and it's only taken them what 22
years to get to this point it's
incredible there we go annotations
pipeline so this is just the way that
the the annotations processed internally
so you've got some complications in
terms of having repeating annotations on
types and the way it works with lambdas
so it's just a cleaner way of doing that
sort of parse or API for now as horn so
that you can interact with that
programmatically rather than just
through the command line
general cleanup disabling a1
certificates mostly there's a few
situations where they still are accepted
but the idea is to move away from them
because there are an old standard which
people don't want to use anymore
click the app that APR anybody still
using adverts I don't see anybody okay
so that's not going to affect anybody
deprecating the API so unfortunately
tumbling Duke will be no more things
removed from JDK 9 so in addition to
adding lots of new features some things
are being removed I mentioned there were
six api's that had been deprecated
before and were being removed from the
public set of API s at add and remove
actionlistener that are in the pack 200
and the log manager classes as I say the
reason for those things being removed
are because of the the need to be up
separate out code so that you can have
distinct modules and not have the
situation where when you have one module
it just depends on everything else in
the JDK through these bizarre kind of
connections so this was pulling things
apart the ability to select a Java
runtime version from the command line
has gone away so - inversiÃ³n no longer
accepted and the demos and the samples
that were included in the JDK haven't
been maintained they're out of date so
they're actually going away as well
couple of other things have being
deleted the JVM tools interface the H
prof agent that is going away it was
only ever intended as a demonstration of
JVM TI most of the features of that have
been replaced by other tools so if you
look at things like J map that will give
you the similar functionality the J hat
tool is going away that was an
experimental tool that was introduced in
JDK 6 it's never been supported and
there are much better visualization
tools around that you can use instead a
number of GC options are being removed
as well so if you look at JDK 8 these
are all deprecated so you give an
advanced warning if you use them in JDK
8 you would have seen a warning saying
these options will go away mostly it's
about removing bizarre combinations
which nobody really should be using
anyway and we don't want to be have to
test them so things like somebody using
a parallel new collective with a serial
old collector
I mean why would you possibly do that so
that's going away other things which are
really going away is the idea of
incremental concurrent mark-sweep so
that's just not really necessary anymore
so it's going away and some of the the
CMS foreground stuff as well so those
are disappearing as options one thing I
am going to briefly talk about this the
idea of incubator modules and what this
is is allowing the development of the
API in a way that things can be rolled
out and let developers test them before
they become part of the standard the
idea is to say okay here's here's a
module because now we have modules in
our our system here's a module that
contains a new API for well in the good
example here HTTP 2 you can take that
you can use it you can test it you can
see whether it works in wave you expect
it to and you can give feedback to
Oracle and the open JDK team and then if
they need to make changes they can
before it becomes part of the standard
rather than just deciding this is how
the API will work and then finding after
it's part of the standard developers
don't like it and then having to try and
deprecated things and change them why
not make it so you could try it before
it becomes part of the standard so
that's the idea of incubator modules
just to summarize JDK 9 big new features
modularity as I said there's a number of
things around that in terms of backwards
compatibility the the big kill switch
will hopefully address some of those
problems there's all the smaller
features as well new API screams the
reactive API J shell lots of things I've
talked about in terms of standards
performance the way that things working
one thing I would say is test your
application with early access versions
see whether your application runs see if
there are any problems there's more time
you have before it comes the release the
more time you have to address those
issues one thing I will say as well
again my final sort sales pitch we
create a version of open JDK which we
call zero it's a binary distribution
that we build from open JDK we run the
TCK on it we make it freely available on
the stand platform so Windows Mac and
Linux as I say it's completely free
if you want we will sell you a support
package at a very reasonable price
compared to other competitors in that
space and we support older versions as
well so we support JDK six seven and
eight and the early access versions of
nine and we will take security fixes
from JDK 8 when they're in open JDK and
we'll back port in seven and six and
then we will upstream those into the
open JDK project as well so talk to me
if people any more interest in that so I
think we probably have less than so at
this lunch time so if anybody's got any
questions put your hand up done silence
okay so thanks very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>