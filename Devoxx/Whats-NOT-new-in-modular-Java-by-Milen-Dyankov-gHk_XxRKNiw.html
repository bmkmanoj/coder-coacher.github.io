<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What's NOT new in modular Java by Milen Dyankov | Coder Coacher - Coaching Coders</title><meta content="What's NOT new in modular Java by Milen Dyankov - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What's NOT new in modular Java by Milen Dyankov</b></h2><h5 class="post__date">2016-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gHk_XxRKNiw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone got to see you here
considering what's going on in the other
rooms and thank you for choosing to come
to my talk my name is Melania echofon
I'm going to be talking today about
what's not new in modular Java and
speaking of which did you write modular
Java and already how many of you have no
one wow did you attend the sessions
about jigsaw and modularity okay most of
you okay good how do you like it who is
impressed why what's going to happen in
Java nine oops okay now I understand why
you're here okay we're going to be
having a slightly different look at a
modularity in Java in general and when I
say not knew a lot of people are
confused so that what do you mean not
near it's a lot of new stuff going on in
Java nine that's absolutely true and if
you think about all the frameworks all
the implementations and all the details
is whole lot of a new thing going on
there that's not what I mean when I say
not new what I actually mean is not new
in terms of a concept in terms of a
concept of modularity the way you apply
modularity to java applications and the
results did you get out of a modular
java application before we dig into that
though let's answer this question why it
is important to talk about modularity
now and you probably notice that already
that you know i think it was like four
three four sessions on modularity in
java already and roughly the same amount
of sessions last year so this is the
evidence that i could find about the
attempts to modularize java this goes
back to the year two thousand and five
with GSR 277
actually I believe there was an attempt
even before that but for some reason I
couldn't I couldn't back up that
information with any valuable source but
it wasn't before 2014 when GSR 376
showed up when the whole thing about
mobilizing java becomes serious and we
were expecting it to appear year after
year month after month this is from dead
works last year and this is the question
someone put on the table on the under on
the whiteboard will we use jigsaw and
2016 and as you can see they got it
right whoever answer that but I like
that sentence down there which says you
can priority are from my cold dead hands
and trust me I wasn't the one who wrote
it by the way if if you want of you
wrote it come see me after the talk and
the reason I'm saying it is is because
I'm going to have a lot of references to
osgi just to show you some of the
concepts and and how how the different
problems were approached over the years
and and what worked and what didn't as
you can see you probably not as that
genre is modularity in Java non is so
important that Oracle is postponing the
release of Java nine because objects oh
and they've done it actually twice this
was for march now it's July and I
wouldn't be surprised if that happens
again and that's not to say that
something wrong with Oracle just
modularity is really hard it is not a
trivial task and it just takes time to
do it right so I'm totally not surprised
by these delays the question there is
what is modularity when we say it's
complex it's it's this and that but what
actually we mean when we say modularity
and here's the tricky part because this
is where the quote from Allison whoa no
one comes in place when I use a word it
means just what I choose it to me
me neither more nor less so when we say
modularity it means whatever we choose
it to me there is actually no strict
definition of Margaret I mean you can do
the exercise and go to some you know
dictionaries or Wikipedia or it will
find a whole lot of definitions of
modularity there is not a definition of
modularity that everyone in this room
will agree with and so that we have a
common understanding of mod modularity
is and that is indeed a problem so back
in 2011 doctor grayham charter is
proposed a modularity maturity model now
those of you who familiar with in how
maturity models in general works may
kind of recognize the same thing here we
have like six levels of modularity and
the first is ad hoc meaning you have
nothing no modularity at all the second
is decoupled from artifact means you
don't really care about who brings
modularity to you but the modularity
itself then it's actually modularity
when you decouple yourself from the
identity of the thing then you go one
step further which is loose coupling
devolution and dynamism and now I'm
going to go in details in a few minutes
so this was the original proposition and
I think now when you just read the
titles it doesn't really make immediate
sense what it is if you start actually
go and see the presentation and dig into
the details it starts to clarify like
what exactly it means actually that's
not quite correct he introduced level 7
which is called Peter Koreans and it's
only available for people who are Peter
Koreans and if you don't know who Peter
Koreans is that's probably the most
knowledgeable person on earth as far as
modularity concerns is concerned the
pillar Koreans didn't stay quiet on that
and in the forward of a book called java
application architecture actually
referred to that modularity maturity
model and he said well if i were to do
it i would redefine it i would just use
five levels
and I'm just going to call them
unmanaged managed proper isolation
minimize coupling and service-oriented
architecture I say when I was preparing
this talk i was like which model should
i use how do i explain it to people and
as idea i'll go with my own which i call
buzzword compliant modularity maturity
model and the reason I come up with this
is because for my observations from the
last several years this is how we do
programming today it's buzzword driven
we come to a conference someone tells
you this is the technology that you
should be using you go home so excited
and next thing you know it's in your
portfolio in your company or something
we heavily buzzed were driven whether we
want to admit it or not especially with
the micro services and containers hype
don't try to convince me that's not the
case so here is your buzz word driven
modularity maturity model so level one
is the model at the bad guy anyone doing
monolids well brave people in this room
ok so the monolith is the bad guy and
meaning you build the whole thing
together and you are totally unaware of
your own dependencies because
everything's in the box right so we put
it in the box is there now you can go
one level up and you can say wait a
minute I actually want to split things i
want to have multiple pieces that are
independently deployable and this way
you come or well not in the penalty
deployable but independent of each other
or whatever in that particular case
independent means see you split things
apart and call the models and now that
is the time where you become aware of
your infrastructural dependences so you
basically know this artifact can only
function if this other artifact is
present okay well how its present as
different story typically it's probably
putting a jar file on a class pad or
things like that now at level 3 you want
to be aware of functional dependencies
so you
you are not actually saying hmm I need
an a module of that name but basically
say I need someone who can do this right
and then there is something right a
container or something some kind of of
obstruction that can tell you well yeah
yeah I can do that and then you depend
on that thing but then you still coupled
with the implementation of that thing
now level 4 is the discovery level where
you actually go even one step further in
the abstraction and you basically say
now I don't really care who as long as
someone does this thing and I can
delegate that job to that guy I'm good
to go right and this is where you don't
really care about what is what is it
around you don't really care whether the
artifact is there what this class is
they're basically saying I need someone
to be able to do this thing go find one
for me okay and level five is when you
basically decouple yourself from time
and and by that i mean the couple
yourself from change you acknowledge the
fact that your situation of today is
your situation of today and it's not
necessarily your situation of tomorrow
tomorrow things may change and you
prepared for that so you've designed
your dependencies and you're in your
requirements in a way that when
requirements change tomorrow you can
actually easily adapt to the new
situation so with that in mind how do
you do things like modularity in java a
level one well that's java there's
nothing fans in here to do composites we
typically use maven and i don't mean the
maven maven as a build tool but maven as
a repository of artifacts so we
basically just say yeah go grab me this
jar file and I depend on that one to go
on more abstract level you probably
going to use things like CDI spring or
java ee were you actually now not not
expressing dependencies between
artifacts but you're not expressing
dependencies between components this
component requires that component and at
the end of the day you still need to do
the wiring with the artifacts but you
are like one level higher in the
understructure logic now anyone willing
to take a guess what gives you level
four in Java not surprised because there
is no technology that gives you a level
four as far as I know the only thing
that gives you all the levels far up to
level 5 with sexual osgi at the moment
as the only technology I know of that
allows you to do all these things and
yeah I'm not aware of every single
technology that exists so there may be
others that I'm not aware of but the
most popular one as of today is
basically always gia and I know what
you're thinking it's scary now I'm not
going to be convincing you to use osgi
but i will be using osgi as a reference
because osgi has been around for over a
decade trying to do these things and
during the ears has encountered a number
of issues and has had to deal with those
issues and when we now introduce
majority in Java we pretty much face the
same issues so the purpose of this
cooperation is not to tell you this
technology is better than that
technology but basically to show you how
two different technologies approach the
exact same problems this is where your
job jsr 376 or JP ms or jigsaw whatever
you want to call it fits them so it kind
of a little bit here a little bit here a
little bit here anyway wonder why is
that and the reason is was a decision
when this project started that it needs
to be simple it needs to keep things as
simple as possible so the whole blonde
model arduous was not an option so let's
look thing to to those things in a
little bit different perspective from
application perspective that thing is
your application and what you see inside
those are your classes and as you can
see they nicely cooperate with each
other Oh make sure that's a lie that's
not your application
application is more like this so down
there you have bunch of classes that
actually come from the platform you have
a whole lot of libraries and in the
middle and up there somewhere is
actually your application it's a big
mass of classes that's what it is so
years and years ago this thing called
osgi came around and said well let us
solve that problem so what we're going
to do on a platform level there's not
much we can do because we don't own the
platform right we just run on top of the
platform so that's something we can do
with the platform itself but there is
this thing called class loaders so if we
could actually jump on those class
loaders and manage the way they load
classes we can actually build the whole
stack up in a very in a much much better
way so this is where it comes a dynamic
multi-layer modular architecture known
as osgi now the question is and it was
meant for applications that is an
important thing to remember here the
whole idea of osgi was to give you a
framework or a concept to build
applications it was never the goal
avoids GI to modularize java as i as a
platform so it wanted to give you
something to build modular apps the
question is what you do with this middle
part and everyone optimistically decided
that since it's just so easy everyone
should be building bundles which is the
name of a module in the US GI world and
if you've done any osgi development
anyone doing osgi all right several
people if you don't know is your
development or adores you are
development you know how well that
turned out to be it as bunch of
libraries out there that never actually
became abundance and it's a big issue
with trying to make them a proper
modules so this is where who is GI ended
and this is a quote from Peter perience
again which says that uh many people
claim that horse guy's heart and then
actually don't realize that what is hard
is a modularity and I highly agree with
that and actually you observe that today
when people start doing things with
jigsaw day I we build model or
application all these years and now they
don't work with jigsaw because when Java
itself started to enforce the exact same
constraints conceptually same
constraints it turns out their
applications too don't work the same way
they didn't work with osgi except before
there was always GI to blame for that
and now it's like you can't blame it on
Java right because obviously Java is
doing it right so this is how GSR 3764
jigsaw or JP has want to solve the
problem well they own the platform so
modules are now first-class citizens
which is a good thing honestly now the
fact that Java itself has a notion of
modules it's a much better world the
problem becomes right up there because
all of a sudden you are asked to do
modules in your applications so let's
get back to the thing when when the the
GSR started the goal of that GSR was to
modularize the platform it would the
goal of digest our wasn't to provide a
environment or a tool or a library for
building applications on top of that
platform that kind of came up as a I
don't know at what time exactly and how
but that evolved from modularizing the
platform once modules were in platform
all of a sudden someone decided that
that's a good idea to actually build
applications that way okay so it's not
okay I've been criticized for this slide
because it's not really that you have to
you must use modules there are obviously
ways to not do that but the reality is
sooner or later you will be forced to do
it because of the whole environment
around you doing it
in the same thing applies for libraries
now all libraries needs to be modules
because if you do modules in your
library is not that you need is not
available as a module basically library
is useless so the expectation is that
sooner or later everyone in this world
will be just building Java modules and
this is where the thing about new and
not new comes so everything below that
line is actually knew there was no
notion of modules in Java itself the
platform wasn't module or every time we
wanted to run a hello world you had to
package the whole Java think now that
changed the whole thing about that line
is totally not new it's not new in the
sense that if you were in a situation
that you had to do more if you wanted to
do models before you could do so there
was nothing preventing you from doing so
there wasn't a system in place that
allows you to do this for over 10 years
so conceptually there is nothing new in
that space as far as your options are
concerned as far as what you could do so
this is what's going on right now a lot
of people discover that yeah the world
is not as pretty place as data or this
so now we go back to keep it simple and
the question that you want to ask
yourself is when keep it simple it's not
enough because it's a good idea ok let's
let's make it easy for developers let's
keep it simple that didn't you know just
sit down write a bunch of things and
unread module stuff well it's not always
the case it's not always the case and
for to illustrate that I'm going to use
an analogy which we often use in in
software development we compare building
a product to start building a program to
building a product so when you build a
product you start from a material you
got some materials you produce some
intermediate products out of them then
you can buy
those products and at the end of the day
you end up producing your product so
let's say you want to produce a rabbit
like this what you're going to need is a
bunch of things you're going to need
some software for that it going to
probably need some tools you're going to
probably need some hardware maybe some
wiring you probably need computers so
those are the things that someone
produces and gives to you in order for
you to be able to do your job if you
think about it further though those guys
that produce those things for you they
also need some other things that someone
else produces and gives them so they can
do their job so we end up building this
kind of the dependency graph thing and
if you think about this dependency graph
there's something terribly wrong with it
and what's wrong with it it's a cyclic
it's it's beautiful it's like we
programmers we would create it like
because we like that thing like
simplicity and but if you were to draw
this as it appears in the real world I
bet you would probably draw an arrow
between every two nodes in that in that
graph because the guys down there
producing Tuesday are probably using
computers and those are probably using
software and so forth so essentially the
world it's not that simple what happens
in real world is we have to have 235
whatever entities to come together agree
on a thing to get the job done that's
what happens it's not so simple like I
depend on you and you depend on that
other guy but for because we develop
person because we want to keep things
simple which is going to draw the world
as a unified like a cyclic graph so to
kind of simplify that thing so you have
entities and these entities offer you
something and other entities is using
that something is at the end of the day
put everything together and produce a
product that is exactly how we think
with build applications we have
artifacts artifacts export some
functionality we use that a
functionality in another artifact at the
end they put all these are
build our application so without a
knowledge in place let's compare the two
solutions that we have in different
levels so that's level to where you try
to decouple yourself from the artifact
in order to decouple yourself from the
artifact you need to provide an ID and
you need to say I don't really want the
jar file I want any jar file with that
ID okay and below is GI you can do that
in the manifest MF files and Java nine
you can do that in module info Java now
your artifacts you know ser plain old
jar files and Jace are 376 you could
either use jar file or J mode that's new
packaging thing for for German I'm sorry
so that's pretty simple that's almost
identical with one tiny little
difference to which I'm going to come
back later there is no notion of
versioning those modules in Java 9 where
which means if your artifacts change
over time there is no way for the system
to know which version of that particular
artifact you want to use and why is that
a problem we'll see in a second so level
3 if you want to go one step further you
want to D copy yourself from identity so
before that you depend on this other ID
come spring whatever oryx bring whatever
or hibernate or something that's the
idea you don't really tell what exactly
from that thing you want to use but say
I want that thing now you want to go one
step further and both frameworks allows
you to do this in osgi you would just
say export package so this is the
provider side the provider describes
what they produce for you so basically
they say come my company my package is
what I'm giving you oh by the way I do
have a lot of other stuff in this box
but you're not allowed to touch it
because that's my internal stuff right
same thing goes with module info
just say experts provide a package so
that's pretty much identical the
difference comes on the other side when
you try to tell what is it that you use
now historically doesn't even know is GI
may recall there was a header known as
require bundle and in that require
bundle you put the name of another
module and it basically my module
depends on that other module that is
essentially what Java 9 gives you it
gives you it requires other module so
you now depend on the provider of the
thing that you actually need any main
thing okay why is that even bad and boy
how is GI had knows that well osgi
nowadays uses import package which
basically tells the framework I care
about that thing I don't really care who
produces it or where it comes from as
long as someone is able to give me that
thing I'm good to go and there's a
fundamental difference which I was
struggling to explain to people until a
recent blog post showed up and in 4q by
new Bartlett and in KY Hagbard who put
those two images on it which clearly
explains the situation why is that a
problem so that is the first so before
you have a modular a and module B and
uniquely say that a package in module
being needs a package from module a in
the other scenario you have a model a
and module B and you say module B needs
module a and it's all good now over time
you realize that your package your
module a has become too big and you want
to split it into two modules so you have
now a and a prime and then you split the
packages half of the pack one package
goes to be 18 the other one goes to the
other a now begin the first case
scenario because your relationship is
defined on a package level if you just
put this
modules in the runtime it all works
together because they don't no one cares
where they come from it just scares it
they're there but if you only have a
package relationship now you don't know
do you need the oldie or do you need the
new way or do you need both or wait a
minute you can't have both because the
system restricts you from having more
than one package with the exact same ID
so you all have a son in a situation and
you don't have versioning so from that
perspective you're all of a sudden in a
situation where you don't really know
what are your dependencies that put into
the like human environment would go like
this in osgi world you would say I need
a power plug I don't care who provides
the power plug as long as someone gives
me a power plug I'm good to go in Java
nine world you would say I depend on foo
because I as a developer know that foo
produces power plugs and I as a
developer know that foo is the only
thing allowed in this world to produce
power plugs and this significant
difference is who knows down here the
system knows now up here in Java it's
you that you need to know and every time
things change it requires and developer
intervention to actually change things
to actually tell the system oh by the
way now you need those other things okay
so that is a significant difference the
required bundle thing it's if it's
something that existed in still exists a
nice job but it's not used it's
something that costs so many troubles
over the years that anyways GI developer
nowadays going to tell you stay away
from that don't even don't even think
about using it the other thing is
versioning so in this case I can
actually say well I know power plugs
change over time so what I need is
actually a power plug that was produced
between version 2 and 3 there is no
notion of that
in Java 9 so you basically need to know
you as a developer need to know that
this module that you use actually uses a
specific implementation specific version
even though it's not a in the API and
and you know exactly which version of
the module we need to put on the module
path because system as well will not
help you in any way so that is one
significant difference and the other
thing is what if you use things from
someone else and then you give things to
someone do they need to know what you
have used now in some cases they need
because for example say I'm producing a
computer am i bought a power plugs that
I used to power my computer so if my if
my customers want to change that power
plug they need to know which power plug
is compatible with the computer today
both and in osgi world you can say it
uses whatever power plug versions and so
forth so you basically give them this
information now how they going to use
that information that's up to them in
Java 9 world you basically tell them
well guess what we use the food module
right which produces power plugs and
because now you bought a computer from
us you also depend on foo so you
introduce a transitive dependency for
the customer whether or not he is
actually interested in that and that in
many cases actually renders to be a
significant problem so if you think
about level 3 you see that there's
something's covered but not not really
decoupled from identities you still tied
to the identity of the thing that
actually provides stuff to you okay so
let's go one level up that's level 4
where you actually want to decouple now
from the implementation itself and for
for that to happen
you need to be able to negotiate things
you need to be able to say I need those
things and find me someone who can
provide those things now how do you do
that annoys yeah well energy I you have
this thing known as a resolver and
resolver is the one that looks for these
two things known as requirements and
capability so every time you create an
artifact you can say this artifact has
these requirements so you can say I
require to be able to do this to believe
and on the other side you have another
artifact that is saying I can do this
for you so for example you can say in a
word I need for my device to function I
need to be connected to a power outlet
or actually I need power I need someone
to power me up somehow you don't really
say I need a power plug the spiral
plucked is just one of the ways that you
can get power but as long as someone can
power is you you good to go and then
some other thing comes in and says I can
do that I can give power to you know
different things so now the resolver
goes like oh you need that and this guy
can do that so let me hook you guys
together and you go and do this thing
and get the things done how do you do
things like that in in Java and well you
can't there's no notion of a resolver
whatsoever it could be probably done by
some external system by some external
tooling it may be partly needed by Java
EE and maybe something be implemented in
Java EE but that's just you know me
saying that maybe mm no service loader
is going to be on actually on level 4 5
next level and I'll talk about that the
this here is wiring artifacts this is
basically replacing your maven
dependencies you
instead of saying I need spring you say
or instead of saying I need jax-rs for
my application to work you will
basically say I need something that is
capable of serving restful services I
don't care what it is as long as it
complies with this contract right so
this is on on the on the artifact level
but it's a good a good question which
leads us to next level so you see it's
very basic on level four this is level 5
where you have the service registry no
SGI which is a concept where you create
much kind of similar concept to
requirements and capabilities model
except here you're dealing with your
application internal so you just
register a service when you register a
service you provide a lot of metadata or
as much as much memory as you need and
you say this is my service it is compile
it fulfills this contract and it can do
those things and then some other service
instead of being directly dependent on
your service can actually go to service
registry and say okay give me someone or
give me everyone or give me a list but
filtered through those criterias give me
services that can do these things and
then you get the references and then you
can do whatever you want with that you
can't do that in in Java on you can use
a service loader how many of you
familiar with the service loader in Java
nine how many of you know it exists one
two three four five six people in the
whole room so for your information
service loader is not a new thing it's
been around i think i may be mistaken
but at least since Java 1.4 is it ok I
was thinking this before ok so thank you
so it's java 6 so it's it's not that old
but still old enough
and when the whole room we have like six
people that are aware of it now what
happened in Java nine is they moved the
service loader into the module
definition so now it's aware of modules
but functionality wise it can be used
the same way as before which is your
feeling basically this is my service
please inspect the jar file and loaded
for me and there's no notion of service
registry there are no notion of
filtering services or any of those more
complex things that you may want to do
to fully decouple yourself of ownership
and in time especially there is no
notion of dynamism in Java 9c you cannot
once you load a service it can it cannot
go away it's there for the life cycle of
the application well that's not entirely
true there are layers a notion of layers
in Java 9 you can you know remove things
from layers but it's a lot more complex
than just a simple service registry so
those are roughly how things compare and
if you want to go in more details
obviously I'm just scratching the
surface here if you if you go deep into
details you may figure out that ok can
actually do some things to some extent
but as you can see there are problems
that were solved over the years which
still appear to not be solved in Java 9
and then this brings you to the question
ok if those are non prob known problems
and they did it the way they did it mean
Oregon Java does that mean that data is
wrong did the whole modularity wrong and
the answer to that is no they didn't and
the reason why answer is no is this it
all depends how you want to define
modularity so when they wanted to do
module or Java they were talking about
modern Java platform they wanted a
modular Java platform and they did that
and did
it very very well so as far as Java
modular platform is concerned I have
nothing against that I actually very
much like what they did the problem is
when you try to introduce okay in the by
the way this is the like a copy from
jigsaw site I believe with the goals
that Java modular needs to the problems
that needs to be resolved by the Java
modular system and all those are
resolved if you look into what they do
with Java nine and jig so they solve the
problems that they wanted to solve so
it's so good level 5 modularity was
never one of those problems okay now the
problem for me or becomes when you try
to introduce that exact same solution
that you used to build a modular
platform for building applications
because those are two totally different
concerns building a modular java
platform is a totally different concern
than building a modular java application
right and it requires different thinking
so i think the whole problem is trying
to map those 11 to one and trying to
tell people against look we did it for
the platform so that means it should
work also for your application it may or
may not now a lot of people in the US GI
community believes that that's actually
a good thing because when people start
using modularity and jovanna and they
will realize how limited it is and they
will start looking for better solutions
and therefore they're going to go to the
osgi i'm honestly not quite sure this is
going to happen but did me and just to
let you know you have an alternative if
you want to what the final question that
i want to address today is and that's a
question that i've been asked a lot is
ok you have this five levels of
modularity but do you need them do i
need to build my application at level 5
no
that's the answer you can stick with
level one if you do hello world you can
go anywhere in between level two three
four if thats what fits your business
requirements remember in the end of the
day you build a placate you building an
application to solve a particular
business problem so you choose the right
technology for what you need to do what
your business problem is what your
business cases it does not mean that
every time you start building a java app
you need to go all the way level 5 with
dynamism and everything because
obviously may not make sense where it
makes sense it makes sense when you want
to acknowledge the fact that you don't
know things the sense of modularity is
not knowing if you are building
application where you expect
requirements to change and you expect
that your application needs to be in
easily in a situation to adapt to new
requirements that is replaced part of it
change an implementation illogic
introduced something else then you need
to acknowledge the fact that things will
change eventually and prepare for that
that is the case with a company that I
work for which is called liferay and we
historically produce our what was known
as a Java portal today is more of a Java
platform for building applications that
thing is pretty big where is the last
coat I believe if it goes like some
don't see the number from here 10
million 06 millions last coat or
something like that that's a pre huge
beast it's a product that is widely used
in in bikaner prices and at some point
of time it's billed as a monolithic
application it was built as a monolithic
application at some point of time we hit
the ceiling said that's it we cannot do
anything anymore with that what that
beast because every time someone touches
something something else breaks on the
other end so the question was how do we
how do we
do with that thing okay microservices is
the obvious answer that everyone's going
to scream except we are not building
this for ourselves this is a product
that we offer to other people and right
now it's totally based on osgi it still
delivered as a single platform except it
contains over 100 apps over 600 modules
and 2500 microservices so if we were to
choose a micro services architecture the
way that everyone's talking about today
imagine us going to a customer and
trying to give them that thing and tell
them up now that's all good you'll
figure out how to manage it that would
never work so in our but on the other
hand we have all kinds of customers we
have customers in telcos and banking in
universities they do whole different
things with that platform there's no way
for us to know at the time we're
building that platform how would they
use it this all of them is going to use
it in a whole different way so the only
thing we could do is we could try to
build it in a way that is as modular as
possible and as adaptable as possible
just to give you four examples this is
an example of requirements and
capabilities usage so if you want to
build a rest service and then deploy an
osgi you basically just say you require
capability that's nice jack contract
java jax RS version 2 XL that's a lot of
code well don't have to write this there
is tooling around that that actually
does this for you as long as you put the
right thing in the right place on the
other hand if you want to say okay I you
know liferay I do appreciate that you
can serve rest services but I don't like
your implementation I actually want to
use this other thing that serves restful
services you just put your
implementation up in in the in the
system and say provide capability osgi
contract that's it those are my
dependences version 2 and you could have
as many implementations of the contract
as you wish
as many clients of that contract as you
wish and you can change them at any time
no down time required now another
example is how we use the service
registry so this is basically using a
component framework known as declarative
services but you there bunch of other
component frameworks in osgi which you
may or may not want to use so this is a
sanitation so you put at component and
basically register something as a
service which goes to the service
registry which means if your client to
that service uses totally different
components framework can still get that
service that is so for example if you if
you build your services with spring and
you try to use them with juice you can't
do that because you have two frameworks
that are non interoperable operate able
in any way right here you have that
problem because you have the main
service registry where everything is
registered and it doesn't matter which
technology used to actually register or
search for a component so the flip side
of that is at reference annotation in
which case you could say I could just
put at reference and that's going to
give you a service or you can actually
find define how you want to reference
that service for example you could say
ok the current analogy is multiple
meanings I want every single thing that
implements that contract and it's
dynamic meaning I'm okay when things
change they go away and show up during
the life cycle of the application and
the policy option is greedy meaning even
though you have wired me already if
things change please let me know and
rewire me again so well you can leave
any of these out or change the options
so that gives you the flexibility to
decide you as a developer decide do I
want to be statically wired to that
other thing once forever until the
application is stopped or do I want to
react to changes
right it's your choice you don't no one
tells you oh that's the framework that
that's how you should do it you decide
whether it makes sense or not that thing
allows you to optimize for
predictability so obviously cannot
predict everything it's things that may
happen it will happen that you will
there's no way for you to predict them
but there are fear large amount of
things that you can think of and well
you know what we provide this service
but maybe someone would want to actually
have more or less okay let's let's make
it a service register let's make it
dynamic let's allow people to search for
that service right so you optimize for
things that can change over the last
time of your application and that is
what is called what I call an
application agility now you talk about
agility every time you go to a job
conference and this typically reference
to a process how you build software how
you organize teams how you I don't know
stand-up meetings or you know all the
other buzzwords so we so obsessed with
agility when it comes down two teams but
our applications that will build our
static they are built with this mindset
they start they establish a state and
that state will never change until we
shut them down and that's okay for a
fair amount of applications out there
but for a fair amount of application out
there it's not okay so if you are in
this use case where you actually need
your application to be dynamic to react
to changes then then you want a more
dynamic modular framework thank you one
shameless plug at the end of the
presentation we do organize a conference
no called mode curve which is actually
next week in Germany so if you want to
hear more about modularity feel free and
welcome to join us there thank you
and I think we still have 12 minutes for
questions anyone I barely can see but if
you raise your hand and I don't see you
shout ok I see I think no questions ok
you can come see me after the
presentation or outside or you can count
down to our bottle it's probably too
late already thank you guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>