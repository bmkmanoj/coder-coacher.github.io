<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java EE 8 by Linda De Michiel | Coder Coacher - Coaching Coders</title><meta content="Java EE 8 by Linda De Michiel - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java EE 8 by Linda De Michiel</b></h2><h5 class="post__date">2017-04-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/OXsdKzBIUzU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay thanks for coming everybody
I'm Linda de McHale I'm one of the Java
EE 8 platform specification leads and in
this talk I'll be trying to focus on the
talk and ignore the beeping which I
guess is also being captured by the
audio and I'm gonna give an overview of
where we are currently with a Java EE 8
platform I'll probably talk faster than
I should just to be sure that we're
getting through the contents of this
talk so brief disclosure what I'm going
to talk about is still preliminary Java
EE 8's and final so don't make serious
decisions on this basis I'll start with
some brief words of background as to how
we got to Java EE 8 and what our goals
and plans for that technology have been
and then in the bulk of this talk I'm
going to focus on the main component J
SRS of the Java EE 8 platform so the
road to Java EE 8 of course started with
Java EE 7 Java EE 7 for us was a great
oops sorry Thank You Edie I have two
devices here I'm looking at one that I
control and one that I don't really
control so Java EE 7 our themes were
focused on support for html5 enhancing
our web tier ap is modernizing them
continued focus on ease of development
largely through leveraging CDI and
injection and then what we can think of
is modernizing the Java EE
infrastructure so when we started
planning Java EE 8 we looked around at
emerging industry trends and things that
we wanted to be sure to incorporate in
this release such as support for the
then emerging HTTP 2 standard it's now
been validated as a standard support for
reactive programming better use of Java
EE in the cloud you could run your Java
EE 7 applications in the cloud but that
really wasn't
the target of our work back then
improvements for security and so on so
we identified we identified a number of
themes that we wanted to focus on for
Java EE 8 again continuing our work for
HTML 5 and web tier enhancements ease of
development through CDI and
modernization of our infrastructure when
we announced Java EE 8 these were the
jsr is in our original plan for the
platform of course the platform and web
profile CDI bean validation which cut
across all of our jsr s and then
improvements to web tier api such as
incremental improvements to JSON
processing and new api for jason binding
servlet a four row because of the HTTP
to work improvements to rest for
reactive programming and enhancements to
JMS a new api a modernized api for
management and then a new security api
to simplify security in the platform
after we had gotten underway we had a
good kickoff for this release and then a
number of our spec leads got
unfortunately diverted into other tasks
so we had a hiatus in the development of
EE 8 when we surfaced last year and
looked at where we were and what had
been going on in the industry we
realized that one we needed to get ee8
out we needed to focus on getting it out
more quickly than our current path would
have led to and we needed to focus more
on what was critical in terms of support
for the emerging trends in microcircuits
aport for running our applications in
the cloud so the world had changed and
we needed to change Java EE 8 to
accommodate it we announced some
revisions to this plan at Java one last
year and we followed up with a large
Community Survey that we hoped would
validate the modifications that we
thought we needed to
this shows the results of that survey
you can the URL here is useful I would
encourage you to check through to that
blog so basically the results here are
to focus on technologies that were
important for support for micro services
like rest JSON servlet to accelerate our
delivery and to deprioritize areas that
we didn't think were as relevant in in
this for this purpose so this reflects
the updated plan i've grayed out those
technologies that we're not pursuing as
part of a e8j MSS a matured JMS is a
mature technology instead of enhancing
it in a 2.1 release we will require JMS
2.0 as part of Java EE 8 Java EE
management had barely gotten off the
ground will fall back to the existing
management API as part of the platform
and MBC the enhancements we had planned
for an action based MVC API we're in the
process of donating that jsr Ivor grim
stead who was one of the leading
contributors in the expert group has
graciously agreed to take that one on so
it will continue but it won't be part of
Java EE 8 so this slide graphically
summarizes what's in in this release
Jason the highlighted technologies are
those j srs that we're focusing on that
are undergoing major enhancements the
ones in blue are included they are
either unchanged from EE 7 or in some
cases there are relatively small scale
maintenance releases that will be
associated with these JSON B is new to
the platform it was the number one
requested item when we had surveyed back
in 2014 I think it was and security
security has just released an early
draft review we expect that will be
including that
part of ee8 as well okay so now I want
to focus on some of the new features in
these Jay SRS and since this is an
overview talk I'm going to need to be
brief and just show brief code snippets
a number of our spec leads or expert
group members are here at the conference
and they'll be giving talks on related
topics and I'll give you some pointers
as we go
first up JSONP we had introduced the
JSON processing API as part of Java EE 7
in this release we're updating it to
stay current with emerging IETF
standards in particular JSON planar JSON
patch and Jason merge patch and we're
introducing some updates to integrate
with features that have been added to
Java SE 8 so what adjacent pointer is is
it's a string syntax for referencing
into adjacent document it's not yet
attached to the document you use the
api's associated with the Jason pointer
interface to to associate it with a
document and their API is for extracting
values from the target document and then
for transforming for creating a new
document from the target document so if
we look at an example here we have an
adjacent array of contact information we
can create a pointer from the json
factory class now this pointer is not
yet associated with this document we
associate it with the document by
passing the document as an argument to
the get value method in this case and
then we can extract the value which here
since it's indexed as an array is the
mobile phone of Duke so we can also do
operations to update the document in
this example again the documents the
argument
to replace as is the replacement value
for the pointer but for the the
reference of the pointer so we can
modify the document to to have a new
phone for Duke okay okay the other Jason
patch what Jason patch is in ITF is it's
a document that expresses a sequence of
operations that are intended to be
applied to another target document and
there's a fixed set of these operations
namely the ones that I've listed here so
the way the Jason processing API treats
this is that you construct a patch using
Jason patch builder methods that
correspond to these operations and then
as with the pointer you pass the
document as an argument to to the apply
method which will apply the patch or you
can retrieve the document and the you
can get back the modified document as a
JSON array so looking at another example
so here we use the JSON Factory class to
create the patch builder and in building
our patch we use this fluent API to add
the operations that we want in this
patch we're going to replace the value
of the mobile phone again and we're
going to remove the second element from
this array so we build the patch and
then we apply the patch and retrieve the
result so the result is going to work
one thing that the Jason patch standard
says is that the the operations in the
patch are applied sequentially so you
can apply a subsequent patch operation
to the result of a previous patch
operation I'm just showing something
more simple here but but that's that's
the way a patch works so first we're
going to replace the value of the mobile
phone and then we're going to remove the
second element from the array
Jason merge patch operates somewhat
differently and I'm not going to go
through the api's here but the way this
works is you construct a patch that you
compare against your target document and
depending on how the comparison shakes
out then you're going to get a
modification and the result so if the
member is there and in both the original
and the patch but with a different value
then you apply the value of the patch if
there is no such element in the original
then you add it and if there's a null
value in the patch then you remove it so
the other enhancement that's important
in this JSON processing release is
integration with the lambdas and if we
look at the example here we've got what
I think of as a JSON query that's
filtering over it's filtering over a set
of females contact info entries and as
filtering it's filtering out the females
and extracting the names of the female
members and collecting it to a list so
what we've lost here is the fact that
we're exiting the JSON world and we've
just got back a list of Java strings a
Java list of strings but by enhancing
JSON with with collectors that are JSON
specific such as here a to list collect
sorry which is here collectors for
converting to JSON arrays we've now
gotten back the result in a form that we
can just simply pipe it to further JSON
specific operations and they're also
collectors to JSON object and group by
collectors okay so I want to switch over
now to the Jason binding API this is a
new to this release and the way you can
think of it is in analog to jocks P that
is it provides a mapping between JSON
text and Java objects
so you can serialize and deserialize
between the two its provide it provides
a set of useful defaults but also two
forms of customization through
annotations which are good for
small-scale customizations and then it
gives you a runtime configuration
builder that lets you apply
configurations that lets you apply
customizations in addition to those that
you and also user-defined customizations
in the form of adaptors
it's got provisions for plugging in the
JSON binding provider of your choice so
you don't need to use the built-in one
so two key interfaces here Jason B
builder which is the entry point into
this API and that gives you operations
for setting the configuration properties
and for choosing your provider and then
Jason B which you construct using the
Jason B builder which provides the
serialization and deserialization
operations so to look at a small example
here we're creating an inventory a list
of cars we got two cars we got a prius
and we've got a tesla we're adding them
to this array list and then we're using
our jason builder to create an instance
of the jason be class and then we can
just simply serialize these objects to
to a JSON array and you get a result
that looks something like this
so for customization you could customize
via annotations in this case we're
defining a different mapping for the
first name property we're going to
assume that the target document when we
deserialize is receiving the target
document has an actor has an element
called name and we're going to
deserialize into
into first name of this class by default
the binding the mapping is using
properties and not mapping private
instance variables you can control that
and the second example we're showing how
you would map the first name instance
variable which would ordinarily not have
been mapped so there's a fairly wide
range of customizations that you can
apply the naming of properties the
ordering if you want the ordering in the
JSON document to be different which ones
to ignore how to handle nulls what
should be visible what your Dayton
number formats are and you can define
custom adapters so an adapter is a class
that you would implement it implements
it should implement the I think it's
called Jason B adapter interface which
has the methods for serialization and
deserialization of mappings so in this
example we're creating a Jason B config
we're saying that you know we want the
result to be formatted and we want to
use the car adapter that we've defined
and then once you you give this config
to to create when you're creating your
Jason B instance and and this this
adapter is going to be used in the
mapping of those classes there's
something else you can do here with it
with this API namely in creating the
Jason B builder you can specify the
provider that you want use so we don't
want to use the default provider of our
implementation we can simply specify the
provider that you want and since Jason
there a number of open source Jason
binding implementations so this is quite
relevant I think
okay I want to switch over now to jax-rs
there are three key areas the jax-rs 2o
is planning to address in this release a
reactive client API support for server
sent events which are also part of the
html5 standard and then support for
non-blocking i/o so in terms of client
API jax-rs introduced a client api
in the 2.0 release with Java EE 7 and
this simple example shows you one of the
forms that this can take in this case
we're creating we're creating a web
target resource and then we're applying
the request from that resource and
getting the result back as a string so
notice that this is all synchronous
jax-rs
to o also introduced an asynchronous
form of this API so if you use the async
method instead of just getting back to
your result you're going to get back a
future and then you can you can check
when the result is available and so on
using the standard futures api's or if
you want to be fancier than that then
you can specify a callback handler which
will notify you when the result is
completed now that doesn't leverage what
we have in Java SE 8 so what Java with
jax-rs
to 1 has done has been to introduce a
real reactive client API so notice the
RX method in this invocation so instead
of getting back just a future what we
get back is a completion stage so you
can now use all of the power of the
completion stage API is in Java SE to
specify how you want
to sequence or combine or to concatenate
if you will these results and how you
want to handle exceptions and what kind
of priorities you want to give to what
results in this simple example we're
just we're just accepting the result and
printing it out this is a what accept
takes is a functional interface so we
are just passing in the print line
method and we're going to we're just
going to print out our result in this
example we have two invocations so to
completion stages and we're going to
combine them so our result will be
something like hello Bonjour which is a
little bit silly and when we do the
combination and then we're just going to
print it out again okay so moving along
a little more quickly I think
server-sent events are another one of
the key enhancements in Jack's rs21 if
you're familiar with the RI Jersey the
way these api's are shaken out is is
somewhat different from what's in Jersey
so server-sent events are targeted
allowing the client to subscribe to
event notifications from the server and
the way that this works is the client
establishes the connection to the server
which is held for a long time it's
reused by multiple notification
notifications from the server the client
opens the connection and then the server
can send back as many messages as are
appropriate through the connection
there's a special media type for this
which was defined by HTML 5 namely text
event stream and an event itself is a
structured object it has an ID a name
data field most important is the data
field which contains the payload for the
event
so two key AP is on the client-side sse
eventsource which is used in opening the
connection to the web target and
subscribing the consumer
I put consumer here in capitals because
it's a functional interface is defined
in SE 8 and then you can close the
connection and an inbound SSE event
which models on the event and its
payload so on the client you would have
something like this in a really simple
case again you create the web target and
then and then that from that we're going
to create the event source we're going
to create the event source and subscribe
it and the argument to subscribe is is
the consumer that's going to be invoked
when the event is received and then when
we open the event source then the
process starts starts off and you start
receiving events on the server side
instead of an event source we have an
event sink this is injected as a
parameter to the resource method that's
going to be invoked and it corresponds
to the HTTP connection back to the
client sses a I guess you can think of
it as a factory class it's used to
create outbound events and broadcasters
broadcasters allow you to broadcast to
multiple clients so here this is this
code snippet represents a resource
method on the server side notice in the
produces annotation we're using the
media type server sent events this
equates to this enum and this is a
jax-rs UNAM this equates to to the
string text event stream so when this
method
invoked then the event sink is being
used to broadcast to the to the specific
client
okay I want to talk next about servlet
before we talked about servlet I think
the key thing is to to say some words
about HTTP - this is now a standard from
IETF its goals are to address the
limitations of the existing HTTP
protocols 1.1 I think was dates back to
1999 so it's fairly fairly old in in our
terms to reduce latency to support
parallelism without the workaround of
using multiple connections to achieve
parallelism address the H the
head-of-line blocking problem and other
performance limitations of the existing
protocol so the way this works is by
multiplexing over a single connection
with multiple streams and the streams
themselves are broken into frames where
frames are self-describing so a frame
has information about its order in the
stream as well as the stream to which it
belongs
so this protocol allows you to do
prioritization of streams so you can
push more urgent data out first it gives
you a server push capability whereby on
the server side you can anticipate data
that's going to be needed by the client
in advance of the clients request so the
client can cache this I can cache this
and this allows you to to use to
optimize time that wouldn't otherwise be
used and there are header compression
header compression facilities and other
enhancements so looking at servlet this
is the big-ticket item and servlet for o
most of this work is under the covers
that is it's not visible at the user API
level except for server push and server
push was added in the early draft
release of the servlet for dido spec so
you can download that and examine what's
been done with this API and one of our
spec leads for
servlet ed Byrnes is here in the
audience if you'd like to talk to him
later on about enhancements to servlet
JSF is a mature technology and with this
release this is a dot release it's
relatively small scale it's addressing a
quite a few community requested features
actually an enormous number of community
requested features when I first prepared
this slide deck I think there were over
600 issues that had been addressed in
this in this release so many of these
are targeted at better integration with
other api's and with java java SE 8
leverage of java SE 8 features it is
also specification lead for JSF so if
you have questions about JSF it's your
friend so the question arises given that
we we paired the action based MVC API
from Java EE eight why are we continuing
with JSF JSF was so far along it was so
near completed that it certainly made
sense to make this part of Java EE eight
and I think JSF is now at his proposed
final draft stage and we'll wrap up very
soon CDI is one of the key technologies
in the platform for ease of development
the goal of CDI 2o is focused mainly
around support for defining how CDI
behaves outside of a Java EE container
that is how you can use CDI in Java SE
environments so one of the key features
here was an API to allow you to
bootstrap a CDI container in Java SC the
spec was split into three logical parts
not three documents but the spec
distinguishes among course EDI that is
those features that are common in both
SE and EE environments and then those
that are specific to
each 4sc this consists largely of the
bootstrapping API and for EE there are
it defines the rules for integration
with EE specific technologies for
example how a JB's our CDI EJB session
beans function as CDI beans and how
resource injection works in addition
there are some other useful enhancements
I'm going to talk now about observers
and events so this is what things look
like in CDI 1 1 you obtain an event and
then you can fire a notification to the
observers that have registered for the
events and there are two observers here
and they're expecting payment
information so these observers they're
invoked synchronously with the firing of
the event and there's no defined order
among observers so if an observer
terminates with an exception then the
subsequent observers aren't going to be
invoked in your observers chain stops
CDI 200 has added two major enhancements
to observers one of which is the ability
to order these synchronous observers and
the way you do that is you use the
priority annotation with your observer
argument and so in this case we've
ordered these two observers they're
still invoked synchronously i was
talking about mrs so the ability to add
priority for a parameter was added in a
minor mr2 the common annotation spec so
that underwent NMR in this release and
CDI adds the ability to have a sync
events and the way this works is both
parts need to line up you need to fire
your event as async so fire async and
then your observers are observes async
what the CDI spec says is the
these observers there's gonna be the
firing and the observing are gonna be on
different threads
it doesn't say however how many threads
there will be for observers there could
in potential potentially be water there
could be a thread perps or but the speck
the specta sand doesn't require that so
because these are async you you can't
use the priority annotation here because
there's no guaranteed ordering if you do
I think it's just non-portable beam
validation is also undergoing a 2.0
release being validation is one of those
API is that again is usable across
various component types for some cases
it's more tightly integrated you can
think JPA for example than with others
but you can always invoke being
validation programmatically in any
component so being validation has been
enhanced with support for a number of
java SE 8 features time api's you can
have annotations that are applied to
java time types repeatable x' and then
constraints applied to collection items
and optionals and there's some new
constraints I think non-empty has been
added but email is still I believe under
discussion the specification lead for
the previous releases of being
validation the Manuel Bernard is here at
the conference that I know he's going to
be giving a talk on being validation I
think it's later today I'm not quite
sure about that but I know he's going to
be here today so I would go to that if
you're interested in learning in depth
so to give a couple of small examples
you can use the past future annotations
with Java time types now you can use
repeating annotations so here we've
assigned different groups
different types of users and depending
on the depending on the relevant group
than the requirements for this passwords
differ on in these examples we're
showing how you can apply constraints
with container elements when you insert
into this map than the constraints on
the validity of customer and account are
both going to be checked you can apply
constraints with optional containers and
then you can apply even new constraints
so the final API that I want to talk
about is Java security this is a 1.0
release so this is new and its goal is
to modernize and simplify Java EE
security api's the early draft was just
released last week so in the expert
group has been asking for much feedback
so I would encourage you to download
that and send feedback to the expert
group it introduces three new API so far
security context and HTTP authentication
mechanism API and an identity store API
so some of these are trying to simplify
by using common approaches and
mechanisms or to take the more complex
api's and remove them from the developer
view or possible and it it provides it
allows you to leverage CDI injection to
do this so security context this is
right now under some heavy discussion in
the security expert group as to whether
or not security context is actually
needed and again they're looking for
feedback the spec lead is speaking this
afternoon will Hopkins he's giving a
talk on this on the security API so
again I'd encourage you to go so one of
the things that the security context is
trying to do is to provide more uniform
api's across the spec with get caller
principle and is caller and role this is
intended to supersede the the plethora
of naming conventions that have been
used by the component technologies and I
I've just Illustrated servlet and EJB
here but there are more so the issue was
well do we really need to do this there
there are few subtle differences among
among these api's and the containers so
I'm kind of on the fence with us one
myself and authenticate which is used to
invoke authentication in servlet it
takes a request response and some
context information I think that so this
one's still under debate perhaps more
important is the HTTP authentication
mechanism API which is intended
specifically for the server servlet
container and it's modeled on Joss pick
and the just pick API is intended to
delegate to this you write to the HTTP
authentication mechanism API which is
simpler to write to and you can define
methods that are invoked for validate
request that's invoked before do filter
or do do service so you can specify
custom authentication in these in this
method secure response that's invoked at
after the termination of the filter and
service methods you could use this for
example for encryption if you want it
and clean subject which is used in
response to logout might allow you to
clean up user specific state like
cookies the HTTP authentication
mechanism itself can delegate to the new
identity store API that's been added
and identity store has two purposes it
has methods for authentication and it
has methods for authorization and it's
optional as to whether which of these
you implement you can implement both but
the goal here is to interact with user
stores for authentication information
and group information there B is for
LDAP database and embedded identity
stores right now embedded is design
mostly just for prototyping because you
wouldn't want to store this user
password information in your app or with
your app and the credential the validate
method provides a credential validation
result which which itself can wrap
different types of credentials and you
can also obtain the group information
okay I'm pretty much out of time here so
just to give you a quick overview of
where we are today CDI has just
completed its public review ballot at
unanimously passed so congratulations to
the CDI expert group some of these api's
are further along than others Jason B
JSONP and servlet not servlet jax-rs are
all at or past the proposed final draft
stage servlets anticipating sorry Jack's
JSF is anticipating the final release
shortly and then others are somewhat
less far along both jax-rs and security
have recently released early draft
reviews did I do that yes I did sorry
so just to sum up this is obviously work
in progress if we're working very
aggressively with the target release
date of this summer as our target we're
being very aggressive it's all being
done as open-source implementations you
know GlassFish and then the the some of
the component plug-in implementations
jersey yas on for Jason B and if I
didn't say it enough times we really
want contributions we want feedback on
this work the first URL here is into the
Java EE spec project on java.net this
has a table of all of the jsr s that are
part of the Java EE platform and it's
got links to their user group and their
webpages their Gira's so hopefully
everything you need to send feedback to
the specification leads and the projects
adopted jsr is a wonderful program where
users can get together there
these have been historically mostly
juggs but you don't need to be a jug to
to do an adopter jsr to aggregate
feedback and channel it to an expert to
channel it to expert groups so many of
our expert groups are participants in
the adopted jsr projects heather van
kora is one of the our prime advocates
for adopted jsr if she's here Heather I
can't see you but please wave your hand
Heather will be in the exhibit area and
feel free to contact her about adopted
jsr and if you have technical comments
regarding the platform as a whole you
can certainly send them to be but more
useful would be to send them to the
users list for the platform for the
platform jsr and that's available at
this link and that will go to the
to the members of the expert group for
the platform I'd love to take Q&amp;amp;A but
we're running late and I want to give
the next speaker a chance so if you have
any questions I'll be here I'll be on
the exhibit floor with I think night
hacking and and I'll be on the exhibit
floor and I'll be available there for
any kind of questions so thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>