<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CloudFoundry or Kubernetes/Kubo: Choosing the Right Platform for the Job by Pieter Humphrey | Coder Coacher - Coaching Coders</title><meta content="CloudFoundry or Kubernetes/Kubo: Choosing the Right Platform for the Job by Pieter Humphrey - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CloudFoundry or Kubernetes/Kubo: Choosing the Right Platform for the Job by Pieter Humphrey</b></h2><h5 class="post__date">2017-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2fK_sKaLF1Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">excellent all right hey everyone thanks
I know it's the last session of almost
last day we've got a bit of time
together so thanks for coming so I'm
here my name is Peter Humphrey I'll
introduce myself in a moment but yeah
here to talk to you about cloud foundry
or kubernetes and a little bit about
choosing the right workloads and
therefore the right platform and what
that means for developers and operators
so real quick who is using kubernetes
today could you just raise your hands
it's a little bit of a right ok few
people who's using cloud foundry today
ok few people all right well the rest of
you just shout out it a few things that
if you didn't raise your hand to either
of those options what are you using AWS
bare metal as your GCP don't jump it
once all right I'm just curious nobody
do so um I'll introduce myself real
quick so I got said my name is Peter
Humphrey at work I have the privilege of
working on the spring team with smart
folks like Marc heckler here up front
and Original Gangster Thomas Rees Berg
who's hanging out there in the corner
very quietly trying to be unobserved and
on the spring central Twitter handle I
do a lot of the marketing for the spring
team organize conferences that sort of
stuff so one of the first times I've
been able to speak at devoxx so I'm
excited to be here and wanted to know a
little bit more about you um so again
show of hands
classic three-tier monoliths is that
what you develop for the most part ok
modular monolith Alice Simon Brown okay
great anyone doing cloud native full-on
micro service ok great couple but yeah I
know you are uh any function as a
service fans pure functions okay all
right you guys are always on the cutting
edge so as you can imagine companies
really do have a lot of ways to package
and run their workloads on the cloud so
you know Greenfield apps you know a lot
of times these are going to be you can
choose the latest modern technology
right greenfield apps maybe you can run
microservices spring boot is a pretty
popular choice these days brownfield
applications often these are is V
applications packaged applications a lot
of times these days it used to be you'd
get them what as a zip file tar ball or
you know an install shield installer and
there people are moving away from that
right sometimes ISP applications are
even delivered as docker containers
these days a lot of those applications
require stateful storage and they have
clustered workloads maybe they're
requiring specific ports to run on this
sort of thing often this is sort of the
lift and shift use case right and so
batch admin type workloads are another
popular one
like I said event-driven functions
lambdas very most recent entry onto the
scene you have to know how you want to
trigger functions and run them on the
cloud so maybe you even Data Services
you're running databases or you're
running Mongo or no sequel databases so
there's a lot of ways to get to the
cloud right there's a lot of different
type of workload that people are working
with these days so most of our clients
at least at pivotal and I think most of
you your goal is what to pick the right
run time for each workload so are you
going to run maybe go direct to a
virtual machine directly on an AI as
like AWS or GCP or for a juror or maybe
something higher order is appropriate I
as is pretty low level these days
ironically I mean it's good enough but
containers certainly becoming a very
popular option right and there's a lot
of container Orchestrator offerings I
think the popularity of kubernetes has
really driven most of the major clouds
and a lot of the software vendors to
offer some sort of container management
services certainly with kubernetes
lately you're seeing I think pretty much
every
your vendor now has some sort of a
container management service or are you
going to go full application platform
historically I think we've called these
paths right platform is the service or
the container Orchestrator being
containers of service and then the most
recent entry service right
the idea is to pick the right runtime
for each workload so let's look at that
as a slightly in a slightly different
way and what does that actually mean so
if you're looking let's start at the
left okay
what are you the developer what do you
feed into this input if you want to
deploy your workload as on a container
management system what does that
actually mean so your input to that
equation is typically just a container
right docker file or some other sort of
Linux container image formats platforms
that's like sort of one level up the
abstraction tree right it's it's higher
level there's more guardrails there's
less flexibility but there's more
productivity so you're not really in the
business of building or maintaining or
patching the container at all you just
supply your app to the platform and it
takes it from there maybe that's a
binary or maybe it's a git repo depends
on the nature of the platform sometimes
they're different and then the container
excuse me the plat platform will provide
the rest of it so it'll help you build
the container itself handle things like
the level seven network routing logs
metrics monitoring this is all sort of
done for you automatically so and then
going another level up functions right
so there you're building on a container
orchestration and a platform and all
you're really doing is providing a small
parts of an application and you're
delivering maybe the context around when
the rules under which it is to be
executed maybe some context around that
function when to trigger it right so
you're not even providing a full app as
it were
so I'm gonna focus in this talk I'm just
gonna focus more on these two on the
left side here the container
orchestration and the application
platform because title the talk was
kubernetes and cloud foundry
maybe next year I'll come back and talk
a little bit more about lambda and
serverless offerings as well but I'm
gonna stay on the on these two left side
for that for the time being so as you
move over to the right things get less
complex for you as the developer there's
less moving parts there's less things
for you to deal with right there's less
tools and you get more efficiency as a
result the more to the excuse me to the
right the more to the left you're going
it's lower level right so what does that
mean it means it's more flexible but
there's not as much productivity right
out of the box there's not as many
guardrails right there's not as much
done for you because that's how you get
that's how the flexibility comes into
play right less less less on the rails
as it were so let me just look at that
from a slightly different perspective
okay
just basically restating the same point
but just look at it slightly differently
I mean hardware that you can do anything
on top of bare metal right that runs all
of eyeties workloads 100% anything you
can imagine you can install and run on
hardware but it's the most work right
you move up one level you're on I as
maybe you get 80 90 percent of modern IT
workloads you can run in a VM directly
on I as these days but again you're you
have some constraints to deal with right
move up another level you get to the
container orchestration now you have
progressively even more restrictions now
you have to expect an ephemeral
filesystem well you probably had to
expect that before inside of VM but you
have even more restrictions that you
need to deal with again another layer up
application platform even more
restrictions but more productivity until
you get all the way up to server lists
the strategic goal I think for for any
dev organization or company should be to
push as many of the workloads to the top
as possible or is technically feasible
but again title of the talk how do you
choose the right right abstraction for
the workloads you have at hand because
no one of these really is best suited
whatever for whatever unit of work you
have in front of you right
there's always an optimal choice
so let's you know if we're talking about
any kind of flat form here whatever
platform you choose however you're going
to deploy a code that you've written
you're gonna be dealing with operating
it at some point right DevOps is here to
stay
the idea of infrastructure is code and
you as a developer needing to be
concerned with infrastructure and
automation this concept is not going
anywhere it's here and it's we need to
get used to it right so we separate
these two would all call operational
challenges into two wide groups there's
the stuff that you have to do the day
you install the software the day you set
it up right so that's your build then on
the second day after you've got the
environment set up then you're into the
operations stage and you have different
challenges at each phase right so day
one how do you get something set up
maybe on that good either is is already
multi cloud or a leaves that possibility
for you how can you get CD pipeline CI
CD pipeline set up so you're not doing
manual release processes that are
dangerous you know take up the whole
weekend who's had to deal with the
situation of hey it's time for the big
bang release let's cancel our plans this
weekend because we're gonna be on call
if things go off the rails anyone had to
babysit the release over the weekend
yeah a couple of you okay not a lot of
fun right not something any of us would
really like to be doing how do you get
the consistency in the environment
installation here's another case for
CICE tooling but you know shell
scripting etc but how can you get some
kind of consistent set-up experience
right how do you get some leverage there
and then how long does it just take to
set up you have 500 pages of
instructions to get through or can you
script it can you make a pipeline to do
it for you so ideally you want this to
be happening in hours not weeks so
before getting this demo environment set
up for today I had to go through a fair
amount of documentation just to get
Cloud Foundry running on Google cloud
platform rights I was sitting there
let's say Wednesday last week preparing
for this and I'm looking at 50 pages of
installation installation instructions
and a lot of it is like IP address
ranges insider notation and I've
forgotten that stuff years ago right so
I'm you know trying to figure this out
fortunately one of the other tool Smiths
at pivotal had written a concourse
pipeline to help install Cloud Foundry
for me on GCP great because I wanted to
focus the talk today not on how I
install GCP that's kind of boring right
this is infrastructure to me this is
below the value line and stuff that I
don't want to care about so much right
I've completely forgotten cider notation
and IP address range conventions I mean
for example and I don't really want to
remember them either it was a scarring
experience the first time so um
day two yeah you know we let's say great
you you muddle through you get an
environment set up now you've may be
deploying some opera pulling some
applications to it now how do you
operate right how do you do this thing
long term well they're vulnerabilities
in software right there's patches that
you're going to have to deal with at the
operating system level and at the
application library level that you know
spring people sprint we you know will
produce libraries fixes everyone will in
the US you've probably heard the news
from this company Equifax right that got
hacked with struts bug so it's important
right how you operate this stuff and how
you patch it should feel normal and
especially if you're at big enterprise
and you have hundreds or worse even
thousands of applications how the heck
are you gonna manage that so scaling how
do you scale up right how do you upgrade
new versions of both the application the
operating systems or maybe even the
platform while maintaining uptime
hopefully and then operating the
platform ideally you don't want to have
a staff of 10 15 20 people dedicated to
operating it right this is the classic
model from 10 years ago where you have a
web logic or a WebSphere and you have a
separate ops team that really knows
absolutely nothing about the code you
just wrote so when some
bombs what happens who do they call
right after ghostbusters they call you
because you're the only one that
understands the Java exception that got
coughed up from the bowels of the
application right most operators are
gonna go home I don't know goody hello
so let's cut out the middleman right why
bother with that's you know this I think
is the essence of the the DevOps concept
so all right so generally speaking
platform challenges right so let's get
more specific so the two platforms that
I mentioned the beginning to talk cloud
foundry and kubernetes probably the
let's talk about each one in turn
so cloud foundry is this is where you're
you're kind of this is your mindset I
think when you approach cloud foundry
you're saying hey I just run this app
for me I don't care how I don't want to
deal with the platform details do it for
me I'm gonna feed you a binary or maybe
maybe it's a git repo or something in
the case with cloud foundry and the Java
build pack you feed it a jar file or uh
you know a container a dock or image or
something and you say just run it for me
provision the DNS get the application
instance is up and running handle the
lifecycle management I'm not interested
right I don't mean to manage all these
knobs and dials so maybe in this case
the platform is going to take care of
creating a container and you're not
going to have to do source to image or
you're not gonna have to go to docker
hub and download something and then
monkey with it and until you're happy
with it right the the in the cloud
foundry metaphor build packs a la Heroku
which come from a what 2012 the Finnick
of this concept has been around for a
long time build packs build a container
for you and you know exactly what pops
out of that process every single time
there's no ambiguity right you know what
level the operating system is you know
what version of Java it's running you
know what version of Tomcat is in there
even if you oh I have to pop in a New
Relic agent right you know exactly
what's gonna come out the other side of
that process sometimes you're gonna
docker hub grab a docker image and it's
like mystery meats right what's inside I
don't know hey wow somebody left a copy
Erlang in there what the hell right or
more more commonly nobody bothered to
slim down the docker container so it's
fatter than a VM right in terms of the
of all the cruft that's in the operating
system anyone seen that movie before
yeah okay
two three gigabyte docker image wrong
you're doing it wrong go do it again
right so um but the platform should give
you the Box logging metrics tracing
things like monitoring the point is not
a lot of additional configuration
required whatever the features are that
it gives you and then you should be able
to create and bind to external services
off the platform on demand ideally not
having to open a ticket right you want
to be able to call an API and get access
to a database rather than ask the VMware
administrator for a my sequel VM that
takes a week to provision you just lost
a week right if you could do it right
then and there boy wouldn't that be nice
so the other thing of course operations
you know being able to operate things
consistently reliably like I said
pipeline based deployment so that you
can speed up the rate in which you are
pushing code to production scaling
things up patching and upgrades so in
cloud foundry this is powered by Bosh
I'll talk about this a lot more okay and
then I'll get to kubernetes so Bosh what
is what is that anyone heard of Bosh but
I just curious okay well hey awesome Wow
alright so I'll tell you a great so then
I'll tell you a quick little story about
Bosh very very very short if you haven't
turned it before this is what kind of
compliments a container orchestration
engine and provides release engineering
deployment capabilities lifecycle
management monitoring managing the
embedded operating system inside the
container that sort of stuff so at
google kubernetes
is meant to run in tandem with something
called bork anyone heard of borg before
okay so borg is google's you know this
obviously predated bosch
she's actually Borg plus-plus so kind of
a funny little coincidence there you
take Borg plus one plus one letter in
the alphabet is what s plus one letter
in the alphabet is H Bosch is literally
Borg plus plus so we hired this guy a
few guys away from Google very early on
like 2012 timeframe some really
top-flight sres that were involved in
making Bosch excuse me Borg and they
said we want we love Borg we like the
concept it does a lot for us but we want
to do it better we have some
improvements we want to make and that's
the genesis of this Bosch tool this is
the backplane of the entire cloud
foundry system and as you will see very
shortly it's also becoming the backplane
for kubernetes it's the way it works at
Google and that's going to be the way it
works at pivotal as well this Bosch is
handling tasks love the variety that you
see here on the right okay so it's a
very wide scope it does quite a lot I
won't read you off the slide but I think
one of the things I'll focus on for the
moment is the health monitoring and the
self-healing which is pretty cool stuff
let's see actually I'm just gonna take a
quick break from that and show you one
thing just use this diagram as a quick
analogy kubernetes would kind of map to
this part of cloud foundry being the
container Orchestrator and Bosch is
where you take a very very very
important design design decision where
you're saying I am going to embed the
operating system inside the release
management in the cluster manager not
inside the container and have a bunch of
snowflakes so why is that so important
because what it allows Bosch to do is
repave fleets of VMs with zero downtime
right if I get a CVE from the operating
system level we work with Ubuntu and
canonical which by the way I have to
admit those guys are amazing they turn
around CVS sometimes in a matter of
hours and we've been able to turn them
around through our updated stem cells to
our customers in a few hours as well we
had one customer who has over 2,000
application instances running on Cloud
Foundry use containers they repaved
there
entire environment with zero downtime in
less than five hours and deployed a new
fix pretty pretty interesting
capabilities in that regard that you as
the developer don't really need to be
that concerned with so so that's pretty
cool the the the help of the operating
system management not a fun business for
anyone really you know what kind of
value do you get out of that but I want
to focus on the health monitoring a
little bit Cloud Foundry provides a
couple of levels of high availability so
your app instance or container can fail
and cloud Farney will just make sure
that it comes back right your process
inside a VM can fail Cloud Foundry will
detect that and bring it back
your whole virtual machine that's
hosting a number of containers could
fail Cloud Foundry will bring that back
as well or you can even set it up so
that it fails over from availability
zone if you lost the entire AZ you can
set it up so that it will load balance
and just cut right over to the other
availability zone so your applications
that you're running are protected at at
least four levels now kubernetes bit
different kubernetes your default
mindset is a little different than when
you approach cloud foundry but for good
reasons
right kubernetes maybe is you're
thinking okay I have a containerized app
I want you to run it for me but I'm
going to tell you how I want you to run
it so I'm going to be explicit about it
and take the time to do it
because I care about the details because
in this case for this at work load of
this application the details are
important I need the control so this is
where you know prepackaged applications
from us a software vendor or maybe you
have things that are cluster aware like
databases or I don't know anything
that's replicated in the cluster really
like let's say old-school WebLogic
server running a name clustered mode or
the much more common case stateful
dealing with application state databases
right things like Mongo orchestra spark
the demo I'm going to show you in a few
minutes uses elastic search any elastic
search users
in the audience I'm just curious couple
people okay if you do not use the
elasticsearch before guess what it's a
search engine shocker didn't mean spoil
the movie for you but customization is
sort of you know how am I going to
deploy it exactly what ports are gonna
be open and how am I going to operate it
to maximize the performance and the
reliability so this is you're in the
driver's seat a little bit more I think
you get the idea but the thing with
kubernetes is that there's a reason why
kubernetes ran in tandem with borg at
google and why it runs in tandem with
bosch at pivotal because kubernetes is
not exactly easy to operate and if you
are sort of lucky enough to be working
at a company where they believe in
DevOps and they believe in things like
CI CD you're on the hook for some of the
operations aren't you right so this you
know this this starts to matter
kubernetes you know it's a great piece
of software it just doesn't address
these sorts of things that you see in
the slide doesn't provide the high
availability so I believe master and EDD
nodes are not a che by default can't
really you know scale the pod service
within the nodes excuse me it does
handle the pause scaling of the pod
service but doesn't really scale masters
the kubernetes master node that hosts
the API and the sed VMs and stds where
kubernetes stores most of its its
application states and then things like
health checks and healing upgrades you
know who manages this system you know
role upgrading a large fleet of
kubernetes container of kubernetes
clusters can be very difficult this is
just sort of out of scope right it's not
a knock on communities it just doesn't
it's just not its scope so we're
partnering with Google pretty heavily
and also VMware and our own engineering
releasing something called project Kubo
which was announced a little bit earlier
this year at Cloud Foundry summits in
Santa Clara so
we're going through some branding stuff
there but the idea is that we're going
to run kubernetes on top of Bosch and
provide that missing experience and
provide those missing features so that
you can do highly available kubernetes
clusters on any cloud right if you think
back for a moment to this diagram and I
know you may or may not be familiar with
cloud foundry but at the bottom here one
of the other things that Bosch does is
it disconnects you from the underlying
infrastructure as a service provider so
in the case of VMware that's vSphere
right
OpenStack if you're running on premise
if you want to run an open if you want
to run on public cloud it's going to
disconnect you from GCP as your Amazon
Web Services now when I say disconnect
what do I mean anyone care to speculate
on what they think I mean by that
okay don't know jumping once what's that
well sure but I mean concretely what are
we disconnecting CPU Ram disk network
this is the basic primitives of Aya's
right not necessarily the higher-order
services that but they provide like
Google's tensorflow or something so that
that gives you the the portability
across clouds and allows you to
basically take kubernetes clusters and
say I'm gonna run kubernetes on top of
asher or other unlikely combinations so
um that's gonna like I said address your
day one build type of concerns where it
will help you deploy the environment and
hopefully do it a lot quicker than
having to do it manually right
it took me let's see after I ran the
automated installer for the pipeline
installer for cloud foundry on GCP which
took about three hours to instantiate
all the VMS and configure everything um
getting a kubernetes running on Bosh
took about another two three hours just
because I had never really done it
before sort of first pass through so
provisioning it definitely made it a lot
less painful in fact I had a
whole bunch of other provisioning to do
just to get the demo to work if I show
you really quickly what some of that was
involved there what else do I have so I
have this is the Cloud Foundry instance
that I have running for the
demonstration it's running on top of GC
P and let's have a quick look at the
installation dashboard I've got a few
products installed there that the demo
application will use and I'll take a
break and describe that in a minute
right so I've got a couple things all
set to go this I've got I've got the CPI
for Google Cloud elastic runtime is the
core Cloud Foundry and then I've got
some tiles for Redis rabbitmq MySQL but
rather than have to download it set up
some sort of docker image and fiddle
with it all literally I just download a
pivotal file import it here and then
when you click into the tile you get the
opportunity you know you just have to
configure it and say okay you know I
placed I placed my data center in Google
US central one a you know and configure
it here through this through this kind
of walkthrough and you set up the plan
plan settings so the idea is that
developers can self-service these
environments right you provide a
marketplace in Cloud Foundry and then
you're not having to open a ticket as a
developer and wait for a VM it's an API
call and it happens instantly right but
this this sort of setup allows the
operation staff or the more senior
people to set up the possible universe
right so great yeah I've got Redis but
um I don't want to let someone provision
a 200 gigabyte you know Redis instance
right no no I don't have that many
resources or I don't want someone to do
something that expensive so you create
plans and then the developers can
consume those hopefully this makes sense
I just wanted to show it to you so you
get the idea
point is it's a bit easier dealing doing
this and having Bosh handle it all the
implementation for me then me physically
downloading Redis and setting it up on a
VM templates or something and then of
course you still don't have the sort of
control over the
self-service provisioning you know it's
just what's in that docker image and you
can't necessarily prevent a developer
from provisioning the docker image and
then assigning you know an insane amount
of resource to it disk or memory okay so
so that's the build part right let's get
it set up
give me an environment and then like I
said the the operations what happens
after the fact once you start running it
and deploying things to your kubernetes
clusters on top of Bosh so that's where
you're gonna appreciate things like the
ability for these VMs to self-heal and
for Bosh to monitor these VMs or
containers and be able to have elastic
scaling for clusters be able to do
things like rolling upgrades high
availability and support multiple
availability zones they even across
availability zones so this is the open
source project that we're working on
with Google and VMware excuse me and
then we are commercializing that this is
sort of pivotal as thing we do a lot of
work and open source and then we provide
a commercial product on top of that that
uses the exact same open source bits but
has some commercial value add we
frequently could just call this an open
core strategy I'm sure hopefully that's
a term that's familiar to most people
but idea is that it's the same bits as
the open source plus some other stuff so
that other stuff in this case what does
that mean there'll be the commercial
version of this would be something
called a pivotal container service with
a little nod to Google gke where the K
is container with the K I guess maybe
it's kubernetes I'm not sure we don't
know really but that's just going to
give you the dial tone effectively to
use a telephone telephone metaphor on
kubernetes where you know here's the
health management aggregated metrics and
logging so you don't have to ssh into
five million containers when something
goes wrong all the logs get aggregated
for you so you have one place to go and
dealing with things like auto scaling
you know volumes and persistence
interfaces and of course providing the
the control plane but there's still
things missing
here right what if you probably want
some sort of image registry for your
your docker containers if you're using
kubernetes they need maybe you know they
need to be security scanned in there and
you might even need things like controls
around that especially in a larger
company environments you might need role
based access control right to those
container images the other thing that
kubernetes provides you is a pretty
simple networking it's a flat network
right everybody can see everybody so in
more complex scenarios you might want to
do you know dynamic load balancer
provisioning or you know have role based
access control for the actual networking
bits or maybe you need to do more
complicated micro segmentation of the
network and not just have a flat this
requires some sort of overlay network or
software-defined network so that's a
little bit where VMware it comes into
the picture because they have a great
software-defined networking solution
they're called NSX right so we'll
support that out of the box so basically
the difference between the open-source
and the commercial is really just that
harbor image registry and the nsx t if
you want you know not everybody needs
network segmentation at that level but
it's available it's there for you if you
want it in pivotal container service as
well there's a DCP service broker out of
the box I'll talk about that in a second
um so you know and then of course the
kubernetes cluster itself all running on
top of Bosh which in turn can run on any
of these clouds so that's that's just
the quick what what is actual big little
container service
now some users some kubernetes users
will want to slice and dice they're a
single kubernetes installation and make
it multi tenants that's very common use
case in fact I think that's most
frequent but what we're seeing with some
of our customers especially the larger
ones is they will want actual they'll
end up wanting a separate clusters for
separate workload profiles and they
don't want to have a single all-singing
all-dancing multi tenant cluster they
want to break them apart
but the consequence of that is what you
have more suddenly fleets of kubernetes
to manage right so without something
like Bosch behind it it gets a little
more difficult the GCP service broker
this is what allows you to create Bosch
clusters on demand so you are literally
just typing at the command line let's
see on I'll show you my existing cluster
real quick um oops you know get services
oh sorry wrong window so I have an
existing cluster up and running and I've
got a few members here I'll get pods so
you can see some of the instances yeah
so I've got a docker image for elastic
and Cubana and then a little maven
repository that I used for just taking
some files so I could get access to my
HDPE I'll show this to you in a demo in
a few minutes um but for services X
Cloud Foundry is very simple let's have
a look at some of the different services
that are available on my this
installation
come on you can do it well those little
mice running around on the cloud
spinning the wheel or getting tired come
on folks okay um well well I'm just
waiting for that to return creating it
is almost as simple once you have it set
up inside of cloud foundry and you have
the plans for vision and that sort of
stuff then for the developer creating a
kubernetes cluster is literally not much
more complicated than what I just typed
CF creates service named the service and
choose the plan so it's about that easy
to create a kubernetes cluster if you do
that without Bosch well it took me I
mean some people even like to instance
you know if you talk to Red Hat they'll
tell you to install kubernetes on bare
metal that takes quite a while right
it's certainly not CF create service and
then have something mmm did I lose
internet connection here hold on one
second no okay ah there we go
yeah so this installation there it is
there's my Kubo cluster microbrew
Nettie's and then I have a Redis rabbit
my sequel and just like another database
for a different demo already set up but
again I was the this service is
provisioned by the service broker so
that's what this square up here on the
Left where it says GCB service broker
that's what that does right it allows me
that interface so that I have a simple
way of provisioning clusters and I can
do it via this CF command line great
okay so hopefully that gives you a bit
of a flavor for what I mean now and I
see a pivotal container service and what
the difference between the open-source
bits and the commercial is and then in
addition to provisioning you obviously
you're you know you can use the service
broker to deep provision environments
and scale them and and configure them
for the marketplace the other cool
things about the partnership with Google
in particular is going to be the
constant compatibility so kubernetes
release is pretty frequently right now
it's somewhere around every three months
sometimes more often so that's a
quick pace to keep up with right you
know how do you keep up with that
release cadence and still be able to do
things like rolling upgrades without
downtime well how do you deal with
security patches again that's where vash
will help you right
so when google the nature of our the the
agreement we have with google is that
when they deem aquella kubernetes
released stable enough to run on their
cloud as gke google container service it
is instantly synchronized and reflected
with what we offer with pivotal
container service so you can have
confidence that you're always running
the latest and greatest kubernetes and
with something that is still relatively
young and releasing that quickly that's
pretty important
you want to make sure you get the latest
features you want to make sure there's
you have something that was approved
tests are blessed by google in some way
rights they are certainly the majority
of committers on the on the kubernetes
projects okay so um so that's
interesting now how does this all relate
back to the title of the talk
choosing the right workload for the
right platform right we think that
people especially the pivotal customers
will probably end up leveraging more
than one obstruction so Cloud Foundry
and elastic runtime or as we now call it
pivotal application service is great for
a service tier right fantastic for that
that's where you want your stateless Web
Apps your REST API layer that's where
you want that sort of thing to live
inside of here inside of elastic runtime
managed by Bosch leveraging various
platform services pivotal container
service or Kubo this is a great way to
deal with more stateful works workflows
more stateful workloads excuse me things
like databases things like elastic
search maybe like I said earlier a
WebLogic server running in clustered
mode or something like that now um how
do they work together I mean like I said
the broker is a uniform experience but
working to integrate the networking as
well so if you declare routes in your
kubernetes cluster that they'll be
synchronized if you have the CF route
sync configured correctly it will allow
you to expose those kubernetes routes
directly to the Cloud Foundry go router
or you can just bypass that and use the
typical kubernetes routing without the
integration so that I do have it set up
this way for the demonstration
so that the routes that I have set up
with the labels and kubernetes are going
actually through the front door of Cloud
Foundry so the routes are synced so
let's talk about this use case I've got
some spring boot apps basically running
as my service tier on elastic runtime in
this case it's something called spring
cloud dataflow
which I'll explain a little bit more in
a moment but they're essentially spring
boot apps do we have any spring boot
users in the audience we're just curious
a few okay
it's just spring users in general Java
EE something else I guess you would have
to tell me what that is but I figured
that it seemed like most everyone in the
room is on one other or some combination
of those things so great uh serviced
here running over here on the left side
right you with me so far
then on the right the demo I've got
elasticsearch running inside of
kubernetes instead of a kubernetes
cluster so I'll talk about spring cloud
dataflow in just a second so let's let's
see what this looks like in action a
little bit now elasticsearch has this
cool little demonstration that they have
published on their website example work
set on earthquake data so they are using
a NSS data from the californian or there
are a northern earthquake northern
california earthquake data center so
it's a nice little data set what does it
actually look like you know when it
comes right down to it
hold on one second there we go this is
basically a bunch of CSV vile CSV files
delimited by a star right so this is
just geospatial in
about where the earthquake was and the
magnitude of it and that sort of thing
now
using elastic search in Cabana I can
visualize this in a you know dashboard
so what I'll do is just let's get
started here
there's the create index okay so first
thing I'll do is I'm just gonna create
some indexes in elasticsearch and there
we go okay yeah let's make sure this is
turned off yeah so I've got to turn that
off
okay just bear with me for one second so
I'm gonna start by creating some indexes
and this is just the create in its index
script it's not doing anything too crazy
um create index it's just basically
doing a curl and then it's dropping in
some JSON here to configure some new
indexes and drop the drop the existing
data so now in elastic search which I
have over and Cubana
excuse me over here now I have kind of a
blank dashboard with no data at all so
I've just set up some indexes that's it
right okay so how do I get this back and
actually showing me some earthquake data
well let's do that
so yeah let's look a little bit with
some of the components of the system
enlarge this a little bit so you can
read it more easily okay so on Cloud
Foundry I said as I was saying before
I've got some a couple different apps
I've got this data flow server here
these are all spring boot applications
data flow is a spring is something
that's built on top of spring boots that
allows you to do data pipeline
processing and is essentially kind of a
core integration architecture that you
can build multiple integration
initiatives off of so right now I'm just
I'm just going to go in and delete the
streams that I had so I can show you
recreating them let's get rid of this
guy now the nice thing about the
integration between dataflow on Cloud
Foundry in particular is that each
little component is just a separate boot
application so once I delete that stream
for
the server if I go back here to Cloud
Foundry and I ask it what apps are
running look all these are gone right so
the this is the cool thing about
dataflow is that as it implements steps
in a pipeline just each little step is a
separate boot app so this is true
micro-service architecture in action
right because if let's say I need to
scale up committing data back to
elasticsearch all I need to do is scale
up that one boot app right I'm not
horizontally scaling a monolith and
wasting a lot of resources so um right
so I just deleted the stream there and
what we can do is let's take a peek at
some of the other some of the other
components of the system real quick
right yeah oh yes of course
um I think I showed the Kubb CTL a
second ago right and this was just a
very very simple like I said very simple
docker container that's running
elasticsearch this is my kubernetes
cluster and then I have then I had a
maven repo that's just it's only purpose
is actually really just to serve a few
files for the purpose of the
demonstration I could have used a static
web server build pack or something like
that if I wanted to but um all those
data flow components are removed now
that I have destroyed the stream right
this is the stream is what's going to
get me from and data flows purpose is to
get the data as an input for from this
file into elasticsearch that's its role
in this architecture right it's pretty
simple but pretty simple for the
purposes of the demonstration but for
you know this is a pretty generic
application toolset that you can use for
nearly any integration scenario I'm just
going with something simple here so
let's take a look at how this plays out
so the nice thing about spring cloud
dataflow one nice thing about it is
there's a comes with a DSL
domain-specific language um that you can
use to define streams so if I go over
here to create stream and drop the
definition into the
editor it sort of lays it out for me I
can do it via command line as well if I
wanted to there's a shell for spring
cloud dataflow and you know you just run
run the shell jar file and then targeted
at your at your installation and then
you have a non compiled you know dynamic
shell experience where you can kind of
tab complete your way through things
create streams destroy them manage their
lifecycle and implement custom actions
more senior developers can extend the
system and create verbs effectively in
this DSL for more junior developers to
work with they can just use the DSL and
don't have to bother with a more
complicated language like Java perhaps
so let's run this stream or let's talk
about what this one's doing I'm gonna
bring this to lay down to one minute and
then all it's doing is after waiting
it's just gonna call a URL make it an
HTTP call to go get that earthquakes
text file and then it's gonna start
parse it for you that's what the
splitter is for so it's just saying hey
separate everything else via the star
delimiter and then let's sync it back
into elasticsearch datastore now you
might very legitimately be asking
yourself at this point what's happening
there that looks like a little bit of
magic you know let's let's let me just
show you a little bit about how easy
that one is the elasticsearch sync is
just a Java class and it's only a few
lines of code basically it's a spring
bean it's an again boot application and
it's very similar to creating creating
spring integration channel adapters I'm
just defining a few bindings and auto
wiring a few things setting up a stream
listener and working with the payload a
little bit then I have one other class
to run it as a spring boot up and then I
have some configuration where I'm
pointing it at the elasticsearch URL
lassic search server
and creating some getters and setters so
not terribly a lot not a lot of
development to create a sink for for
elasticsearch out of out of spring cloud
dataflow so um let's see let's let's go
ahead and create this stream now and
let's give a name and I'm like to just
deploy it straightaway awesome ok so now
if I go back to the CF command line the
cloud funding command line hey cool it's
starting a bunch of servers for me right
this is the nice part about the spring
cloud and understanding how to work with
Cloud Foundry and platforms like this
directly is it just in turn you are
using this high-level DSL under the
covers it turns around and is just
starting a bunch starting a bunch of
boot apps that implement all that logic
for you and make them independently
manageable and scalable as
micro-services so that'll that will come
up take them out there we go now they're
all started we can look at them too in
the GUI we don't just have to use Cloud
Foundry as a command line experience if
you go to if you use a pedal apps
manager you get a sort of GUI driven
experience this is the Cloud Foundry
instance I have running on GCP and there
are all these same applications right
here are the ones that I just just
created you know what do these actually
look like you know this is a this is a
piece of code without any user interface
so if I clicked on this link it wouldn't
take me to anything but if there was an
app that had some UI in it I would just
click on it and it would take me right
there because Cloud Foundry generates
all the dns and all the routes so you
know if there was a UI it would just
take you right there so um the other
interesting thing is that these
components are bound to rabbitmq so if
you remember it's a processing pipeline
right let's go back and look at that
where was the how do I see it again
definitions yeah that's right ok all
right so it's a multi-step pipeline if
each one of these is a separate spring
boot app
and how do I get the input and output of
each step from one of the other right
there there's a network gap in between
them so rabbitmq is going to we're a
bind to each one of these boots
applications and make sure the inputs of
one step goes to the output of the next
and is reliably delivered right because
that's what RabbitMQ does and then
ultimately all the way to elasticsearch
but again you don't have to set this is
nothing you had to deal with right this
is all kind of managed for you without
any development work so that's why you
see a RabbitMQ bound to some of these
system components so if I go back to the
demo space and you know same story for
all the others right okay
so I've got a stream deployed um let's
go back what was it next um yeah okay
so um right so we talked through that
now if I go back to cabana and hit the
refresh button those processing
pipelines are already at work there we
go I've got some data flowing into
elasticsearch right away and then if I
configure that sync correctly every
second I've got about 9,000 records in
there so far every second or show every
second or show or so it should update
and I should get a few more yeah there
we go see counters continuing to
increment and the Cabana visualization
is sort of progressively unfolding right
now again just a quick reminder you know
this is all live data running on GCP
kubernetes running on top of bosch again
in turn on top of google plot cloud
platform so no no trickery here this is
all real live stuff and this is my own
cloud that I own and manage on top of
GCP and my own Cloud Foundry that I own
and manage on top of GCP that's running
the kubernetes clusters and spring cloud
dataflow so um yeah I think one more
maybe there's a little bit more data
still coming with seolin yeah okay so it
just continues to pipe in data to
elasticsearch and visualize it's um any
questions at this point I'm just going
to take a quick pause
anyone anyone quick questions or shall I
continue
okay stop me if you want um alright so
um let's head back to some PowerPoint
for minutes okay cool right so um before
I was talking about a sample use case
where you've got boot on the service
tier and more stateful stuff or cluster
aware stuff running on kubernetes so I
want to talk a little bit about that
stateful that stateless service tier and
why boot is such a good choice for that
service tier why boot apps generally are
work really well on that service tier
when you work with Cloud Foundry you're
working with something called the Java
build pack generally speaking like I
said you can supply to docker container
but the boot apps are built by something
called the Java build pack this is a
Heroku concept that's been around since
almost 2012 we're a cloud foundry has
adapted it and improved it and provides
you some features like being able to
support the boots self executable jars
and it will even help you set the Java
memory management settings so if you
supply a build package jar file it will
take some nice educated guesses about
what the memory settings should be and
make sure that you know it's not gonna
barf as soon as you deploy to Cloud
Foundry because you forgot to set the
memory settings it might not take you
two years into operation with the
settings you know you probably still
want to be a responsible developer and
profile your applications somewhat and
tune the memory but it can go a long way
to helping you there also what happens
if the application crashes when you're
in a virtualized environment how do you
get a heap dump how do you get a thread
die how do you get a heap dump out of a
java application on the container right
the the Cloud Foundry the cloud platform
may destroy the container before you can
even SSH into it and find out what the
heck was going on that's been a sore
point for a lot of people in the cloud
running Java actually so there are some
ways to to at least get a histogram of
the JVM heap and so you can figure out
what
what the expensive method was or what
was running away with memory anyone ever
worked with the at profile annotation in
spring okay okay so this is a nice
bucket for you set your environment
specific variables any configuration you
put in those classes we need to poi to
Cloud Foundry it just automatically
enables the cloud profile for you so
that means you can change endpoints and
port numbers and URLs without him to
recompile or restage your whole
application I showed you the the apps
manager a moment ago for Cloud Foundry
and it will work and integrate directly
with spring boot actuators like the dump
the heap dump at the trace that sort of
thing it allows you all sort of change
the logging level of spring boot
applications directly at runtime and
when again when you're running on that
CF state stateless tier service tier as
I like to call it you may need if you're
doing micro service applications
you're gonna want container to container
networking of some variety right you
don't want micro services always to have
a public IP address or publicly named
DNS right you want to get out of that
business you want them to be discovered
dynamically so these are basically the
ability to say I want certain firewall
rules at the container level I might
need to I might need to communicate with
another micro service running in another
container on Cloud Foundry without going
all the way through the front to other
router and coming back because that
would give you rather large amount of
network traffic and then the other
probably the best reason is something we
call spring cloud services with Springs
approach to micro service architecture
today we've done a lot of work to
integrate the Netflix open source stack
with with not only the spring
programming model but with that Cloud
Foundry service tier that application
runtime we've worked the the some of the
more important ones are the
configuration server and like I said
spring is giving you sort of the client
side of this in your applications Cloud
Foundry can provide a pre-built Linux
virtual appliance that is a
right out-of-the-box push-button
configuration server so this is get
effectively is a network service right
so rather than have the configuration
embedded inside your application where
if it changes it needs to be recompiled
restage to be deployed you're going to
get it at runtime and you're asking a
hashing core vault or a git git repo to
say hey please give me the latest
configuration and then push it out at
runtime to various applications this is
very powerful and it's a way for you to
deal with more ephemeral environments
like containerized environments where
things may be popping in and out of
existence they're not going to have a
static IP or excuse me they're not going
to have a publicly addressable route
they're in fact going to get the
information on where they are from a
service registry dynamically again
another reason why containers might need
to communicate directly in kubernetes
this is not so much of a problem curbing
ideas again has a flat network and does
allow this sort of dynamic service
discovery but in Cloud Foundry we we
actually had to put some work in to make
sure that container to container routing
was was something that was allowable in
the system without having to go back out
through the front door and hairpin
hairpin routing the last service that
cloud foundry has built in for spring
micro services is this circuit breaker
this is what's going to allow you to do
maybe make some compensating
transactions or have a failover behavior
in the availa in the scenario where a
service is unavailable right or maybe
it's passed one-to-many one-to-many
failure calls and it's starting to slow
down maybe it hasn't crashed but the
performance is bad enough that it's
starting to infect other services and on
the system so at that point a breaker is
tripped and no more your you will no
longer get traffic routed to it so these
are all built right into Cloud Foundry
as well as things like metrics and
distributed tracing so if you're trying
to troubleshoot and figure out what's
going on in a complex web of Micra
services being able to see the call
stack is kind of helpful right out of
the box in Cloud Foundry you've got a
nice user interface that will allow you
to correlate the logs
so over here you can see the call stack
in the screenshots and then with Cloud
Foundry you are not associating in
individual containers to find out what
went wrong it a granade s-- almost all
the logs into a single stream and if you
just click on let's say 10 seconds what
was happening there it will jump you
right to the spot on the correlated logs
where that action occurred so it's going
to make troubleshooting quite a bit
easier this is based off of some work
we're doing with spring cloud sleuth and
PCF metrics so this is fully integrated
with security mechanisms as well and if
you use spring boots actuators you can
get custom metrics automatically just
display through this so this is very
nice way to do some troubleshooting last
of course you just get some basic
metrics like network container app
events this is sort of the standard
thing that you might might expect just
to see the health of the container
overall but in aggregate these are a lot
of just nice reasons to use a service
tier that's designed for spring boots
and use a user tier that's designed for
stateful services and clustered
workloads in kubernetes if you've never
tried it before and you want to get
started a pivot little container service
will be available later this year for
you to try out so for now it's just the
service here and the pivotal application
service you can try it on a public cloud
or you can try it on your workstation
there's a local local dev version that
you can you can deploy to so that is
pretty much it I wanted to say thank you
very much for the time you spent with me
today and I'll be around for a few
minutes if you want to talk a little bit
more about kubernetes Cloud Foundry and
ask me any questions ok so cool thanks a
lot I know it's the last session of the
day and I'm probably standing between
you and beers so I want to give a few
minutes back to you so that you can go
get something to eat and go have some
fun talking to your colleagues so again
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>