<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Maven v Gradle: Dawn of Project Automation by Oleg Šelajev and Baruch Sadogursky | Coder Coacher - Coaching Coders</title><meta content="Maven v Gradle: Dawn of Project Automation by Oleg Šelajev and Baruch Sadogursky - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Maven v Gradle: Dawn of Project Automation by Oleg Šelajev and Baruch Sadogursky</b></h2><h5 class="post__date">2017-04-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-ZYzPB0njpM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody.welcome we will try to
do the express version of this talk in
30 minutes last time we did it in a half
an entire half hour and a half and I ran
out of time so I'm not sure how that
will work but we will do our best so
without any ado let's get to business
and let me introduce here myself first
right yeah hey I'm barks at the Gorske
developer advocate with jay frog and EDG
borrow all over the internet pretty much
and I define myself
is that a today is the third day of
devoxx a lot of parties so it's been a
hard week for me I apologize for any
problems that that my encounter and here
with me is the great all lecture live
yep my name is Alec and I worked for 0h
around as a developer advocate and I've
also call it a virtual Jacque so you if
you haven't heard that Google if you
have it's an amazing thing
join that and then congratulating and
thanking and we're we're recommending it
to you and for actually doing that as
well right so thank you I'll start with
that as being a speaker on this
marvelous virtual Java user group is
just great okay so let's get to business
and today we're going to do kind of a
face-off or in a battle between a great
on maven and they are of course the two
most polar build tools in the Java
ecosystem out there and this is why we
selected them they have a lot of
similarities and that's why it's so fine
it's so fun to compare between them but
also a couple of different projects that
we will highlight during today's talk
your job will be of course selecting the
winner and in the end of this talk
you will just vote for either of them by
applause and whoever wins gets nothing I
guess yeah so I guess we could switch
places multiple times during this talk
because both
are pretty fluent with both of the tools
and to say honestly both of them have
their advantages and disadvantages and
good things and bad things about it
we will try to show you some of the
strong points of each one of them and
you will be the ones to judge em so yes
I guess we can start and we will start
with kind of an overview of of the
project and yes I can start maybe we can
just tell you a couple of words about
why we would care about in a sense a
build tool is something that you run
like frequently to just build your
project and combine the artifacts of
your daily work into some sort of
archive that you can distribute
somewhere more deploy to production
where you work
run your tests against that but
basically what it does it takes the
source files and crunches them and then
produces something else for you is that
in use later right and the number of
non-functional requirements for for a
build tool so first we would would like
our builds to be fast so we don't spend
time waiting for that crunching to
happen especially if you did that
multiple times today second we would
like to have the builds reproducible
because it's really not a very great
moment when we you run a built once and
it kind of works in a machine and then
you continue seed creation system runs
the build and it doesn't produce the
same artifact so consistency is always
welcome right just to limit the
complexity what else
yep so reusability reusability we would
like to our configuration for the build
tools to be reusable among different
projects or different sub parts of a
single project so when you introduce new
I don't know module or some component of
your system you would configure that
with minimal efforts and here let let's
talk a little bit about about maven in
this regard because I believe that
although I represent Gradle here I'll
start by saying couple of new words
about nice words about Nathan
and one of the revolutionary aspects of
maven when it came to to be a what it is
now and became popular was this
reusability thing right and think about
it whatever you start a new project and
I see here a lot of faces that I know
from my personal acquaintance with them
that they switch projects fairly fast
enough and and frequently enough and get
into new projects every time if the
project is built with maven you know
exactly what's going on you know how
they make out the project it structures
you know what the modules are you know
where to look for your sources you know
what to expect right so this is what do
we mean in terms of usability as well
this is our project and then you are
familiar with maven you will know
exactly what's going on right so let's
look at the code so we have a multi
module project defined it has the three
modules API war and library and there
are the internal structure of that is
that the were module depends on the
library and the lib module depends on
the API and all three are built together
and then there are somehow packaged and
what we're looking at now is what maven
calls a reactor right what does that
mean
so the reactor is the synonym for the
multi module project and maven in in
million you can build modules in Turkey
and and the reactor is the what how
maven will look at all those modules
individually and create a way of
building them independently of each
other
considering all the dependencies
considering that some modules could
depend on other modules and so it will
look at all that picture sort it into
the order in which it can build it
efficiently and then start building
module per module obviously for every
module and for the parent for the
reactor you have to specify the
configuration for the maven in a pom.xml
file which is an XML file that looks a
little bit like that just much more
yeah so afford this simple project is
like 60 lines of XML yeah that's nothing
then yeah if we're a project word there
are like five lines of Java code one
could consider this a little bit verbose
at some time at the same time if you
looked with xml's before you know that a
couple thousand lines of XML is nothing
if you have proper tooling and a little
bit of patience saying that I heard
about this new thing in XML called XML
attributes good point
alright and what is this parent tag that
we see right here so the parent tag when
you have multi multiple modules you can
specify for all of them which project is
a parent and then you will reuse part of
the configuration of that parent project
so you can specify common functionality
in common configuration for all your sub
modules in in the in the parent and make
all of them depend and say I would like
to extend from that parent project so
for example you can have properties
defined for all the projects like an
encoding over I know your Java platform
JDK version that you would like to build
over some common things like
repositories so maven is not just built
well it is a build tool but it also
manages the dependencies for you so you
can specify where from to pull the Java
files to use in in your local build in a
pom file you just specify that with oh
let me just show I would like to have a
dependency and I would like that to be
available for me at certain time of the
completion and you specify the unique
identifier of that dependency in which
version and somehow when you start the
to the maven will take care of
downloading how the internet and putting
that into the reach of your compilation
process all right so let's look how it
looks in Gradle so as I mentioned there
are a lot of similarities and for
example the builds that the directory
structure of the project looks
exactly the same something that we know
from maven like source main Java and
then a test Java and and this part and
we have again the same modules API
Libyan war so the differences the
differences are that for example you
don't have to have and project
descriptor file in every directory you
will only put them in the directories
when you actually have something to add
in the in the modules that you have
something to add so what we have instead
is a file that it's called M settings or
Grail which includes the list of all the
sub projects or sub modules of this
project and then grader will know that
it needs to build API
Leoben war even if they don't have a
Gradle script file inside and and the
API is an example of that so you see
here in the API it doesn't have Gradle
script but it is a Gradle project and
others that we might want to add
additional staff to can definitely have
this build up Gradle and here is an
example of Lib that defines a project
dependency to an API and a compiled and
and dependency to some third party stuff
now this project dependency is different
from a third party dependency because
it's actually established these inter
module dependencies a little bit like
you did in your reactor and the good
thing about it it means that its
dependency on the source level and it
does doesn't have to be an artifact in a
repository in order to consume it right
it's exactly like like the reactor does
and here's an example of the war file
and again we say here that depends on
leap now the interesting part about the
world a file is that it does not declare
that it is a war file so where it comes
from the top-level build.gradle has the
ability to imply plot to apply plug-ins
to sub modules as well so you can see
here that from the current build.gradle
we say that the word project is actually
war file right and here you have the
flexibility to decide how you prefer it
this line could definitely go into a war
builder gradle or it can be here and
then you can decide do we want to
concentrate all your configuration in
one file or you want to spread them as
maven does in build descriptors in an
image and every module what else is here
so we also define a repository for m4
dependencies and of course Gradle know
how to work with maven a format of
dependencies but also with Ivy format of
dependencies or any other custom format
of dependencies as long as you specify
the schema where the files should be
found they will and they will be found
there okay I : so I've heard Gradle is a
lot about flexibility let's see if that
project actually builds oh yeah yeah no
absolutely builds let me just make sure
that we are on the right branch my
branches here they are I need
now I am a master okay so you want to
build it let's build it
Gradle W clean build just enlarge it a
little bit let's see if it builds
exactly oh I missed an N and it still
works and that's another very nice
feature of Gradle
thank you for reminding me sometimes
those commands and the tasks names
become to build in Gradle it's enough to
provide an unambiguous set of characters
that will mean that will correspond to
write tasks and it will just work so AC
won't work because we have both clean
and compile and check and classes and
components at one and what's not C L
won't work as well but clean should work
like that hey by the way can you tell me
a little bit about this Gradle w it
seems that you're not running the grail
executable yeah so gravel W is an
interesting feature cradle W is called
Gradle wrapper that's what double it
comes from and this Gradle wrapper is a
Gradle which is building inside your
project so here you can see those two
executables for Windows and basically
for everything else and what they do is
when you run them instead of Gradle
installed on your machine
they will download Gradle for you and
put it in some caching on your operating
system and it gives you two very
important advantages first you don't
need to install any build tools before
you start working with your project you
check out your project from your source
control and you can run the build it
will install Gradle automatically and
also it's very important that you
install the right version of Gradle
automatically right so Gradle it's not a
very new tool but it's still young
especially comparing to Meghan and it
moves very fast and sometimes there are
breaking changes as in every software
that actually being developed
and this rapper guarantees that the
project for which with which this graded
version with which this project was
built will be actually used every time
right and then the maintainer of the
project when they decided it's about
time to upgrade your Eagle they will
upgrade it run it verify that everything
is good and then have a new rapper
building so there is a director you know
it's called Gradle and the great rapper
properties actually controls which
Gradle version should be used for this
particular project right and and that's
that's that's cool stuff that's cool
stuff yeah and how about how about melon
it's amazing that in Gradle has this
built-in so maven doesn't have meaning
is an older Bill tool right so Gradle
started a little bit later so they had
some lessons prepared to them to learn
so however maven ecosystem is very vast
and flexible there is a thing called
takari maven wrapper plugin which does
exactly the same thing why why would
maven even need it like no changes were
made in years yeah there are two
releases every ten years so when you
want to upgrade probably you don't need
to have the consistent version of maven
install however that is possible because
it downloads the version that you
specify but you can do a very
interesting thing typically you specify
some information for maven in the
settings file right which sits on your
machine somewhere in the home directory
dot MT and there is the settings file
which has the link to the repository
some passwords and everything like that
it's kind of cumbersome to consider that
all the time what you can do with with
the wrapper you can bake in this
information this the settings for that
into the distribution of maven and
provide a link to that and then when you
execute your wrapper you will get the
configuration for that built so let me
understand something I'm going back to
my build Gradle here I just specify a
repository that needs to be used for
dependencies in maven that's not the
case right you need to change the
repository
the one that it's nailed down to maven
which is maven central with your own
repository in your settings.xml which
are local to your user configuration and
that means that you need to do it and if
anyone else here in the groud want to
build your project they need to change
their settings in xml as well yes no yes
yes how do you like it right it's pretty
normal it's been normal it's been like
that for ages yeah that's that's however
however let's not stop on this like
particularly Robert actually solves that
yeah the takari wrapper if you haven't
used that like it's just one maven
command away from your project you just
run it and it enables it and then you
check it in and you're much better and
and this wrapper actually solves this
problem because what rubber allows you
is to create a custom maven version with
the settings that you need with the
repository that you want people to use
and then wrap it as a maven executable
and make wrapper actually use this
version of maven which has the correct
settings XML yep in Journal if you're
interested in cool nail plugins just a
shameless plug takari is the company
that provides quite a bit of interesting
plugins polyglot for maiden and a
different life cycle for maven which is
easier to configure simpler smaller
download size so if you are using Evan
so just take a look at that they
simplify wife a little bit all right
let's go forward and what I did here I
installed some dependency I added some
dependency to a library called B and and
Alfred around again and let's see what's
going on now whoa now it fails fails Oh
added the dependency and suddenly the
code fails how that happened anyone have
an idea how adding a dependency make
your code fail was an idea I have an
idea
half of the work of a build tool is to
download depend
no no I believe that someone knows
somebody knows I know Nicolette knows
transitive dependencies thank you Alex
okay you earned it I'll pay you later
so yeah transitive dependencies can fail
your existing build even without you
modifying any of your source code right
if you rely on a transitive dependency
from your package then adding another
transitive dependency can break it and
that's exactly what we what we have here
that's a wrong window sorry about that
what we have here is that in one of my a
my tests here inside Lib I have this
test right here right yep
a here in actually dependent on some
package called see when this package I
don't even have instead I have a and B
both of them bring the C package as a
transitive dependency but they bring
different versions right here I depend
on the cost here I depend on version
that has some STR version one but then
you see that came with B actually bring
me around one how can I know it I can
use something like Gradle W dependencies
and then for the correct yep Lib
dependencies
I checked dependencies for my correct
package and I can see here what happened
here is my compiled configuration and I
see here that the package named a brings
version two of dependency and a
diversion to of this sorry a brings a
dependency of version one and then B
brings also the same dependency of a
different version and it's getting
replaced so version one is getting
replaced by version two
what happened Java identifies a class in
the class in the class pass by a fully
qualified name if I if I have a class
named a string Java a long string that's
the identification of the class if I
have a dependency to two different
packages in both of them the class was
the same name exists
they cannot coexist in the class pass
one of them will be chosen and it will
be a first one in class pass which
basically means random in order to
prevent that our beutel's resolve those
dependencies they take one of the jars
but not both of them now how do we know
which jars should be chosen we do
intelligent guesses Gradle selects the
higher version by default because it
assumes that most of the software in the
world is backwards compatible and if one
of my dependencies require Lib C of
version one and the other equals leap C
of version two if I take version two
probably the code will still work for
when version one is required sometimes
it's not the case and that's not the
case what I felt with was a not
backwards compatible upper version how
do I fix that I can fix it very easily
by enforcing the right dependency so
here in my build Gradle now and again
I'm in our own window here in my builder
Gradle I will enforce the configuration
of my dependency and here you can see
this code that lets go to a presentation
mode here so here I
for all the configurations enforce a new
resolution strategy force that C will
always be from version one even if some
dependency uses version two right so
that's a very flexible now this is a
closure it means that I can write any
code here I can say always take the
dependency that starts with letter Z
never take a dependency we start with
letter C let's all make right but but
you can do that that's very flexible and
powerful dependency management that
solves those conflicts
how many is doing in sorting out those
dependencies well that this problem of
having linked paddle versions of
transitive dependencies is obviously not
unique to Gradle so I just I know I I
can also reproduce this in maven so if I
add the dependency to the library and
there is a difference though there is a
difference in this details but I can add
a dependency and if it built pools in
the different version of the library
that other dependencies also require
then there will be a conflict so I just
added here a dependency on library
called a version 1.0 and let me just
show you that this indeed fails the
built with the same with the same reason
there are classes that are there but the
words are different versions of the
classes which are not backwards of words
compatible now to analyze the situation
there is a plug-in for me man called
dependency and this may be this plug-in
can show you the tree of all the
dependencies that you you are looking at
and it shows you and it also comes with
other goals that he can utilize to
figure out stuff about your dependencies
now on a contrary to the Gradle
situation where they have an intelligent
decision that libraries are backwards
compatible and so probably it's safe to
choose the latest version if
if nothing is forced mavin behaves a
little bit differently and what it does
it prefers the version that is declared
closer to the parent reactor project so
if I have why would
how can someone even know where in your
three of transitive dependencies one of
the time dependencies is closer or more
far away from the root this is
completely mistakes remain
I agree this is this is the aspect that
doesn't it surprises me but well this is
what it is so to overcome this situation
take care of your dependencies utilize
the three dependency plugin so how do
you how do you recover from this
situation how do you force a dependency
of a certain version to be used that's a
good question
it hurts this yes so you do it like that
you just put it in your phone file yeah
and how it helps with this very strange
dependency resolution rule when you have
it in your palm file you cannot get any
closer to the root you are in the root
so this dependency will always be used
and that's exactly why the whole closer
to the root resolution strategy exists
so you can do that and be sure one
understand that where you are in the
root you are the closest to the root
elegance right and that may sound
confuse my sound confusing a little bit
but it gave this life to the whole
paradigm of the bomb pattern which is
the Bill of material where you use your
pattern pirate parent file and you
declare that as a pom file and you say I
know my dependencies and I know that the
this particular set of dependencies this
combination is sufficient and they will
work together well and you verify that
and then you put all that information
with the versions in the parent profile
and then in the modules in
side the erector project you don't
import the dependencies and you don't
depend on the particular version of the
libraries but what you just did you say
I would like to use Google's guava right
and the version of guava that you will
take will be taken from the parent home
file and you import that and then this
limitation is overcome and that is
called the bomb pattern and it is
something that is constantly used
throughout the night in this industry
for example the one spring cloud really
proud boot all of them all of them
they released any release they just say
that okay now we have a ton of projects
and we know that those versions of those
projects work together
so this is our BOM pom and you've just
inferred that and you immediately get
the combination that works for you and I
think this is very good idea so you can
do exactly the same in Gradle and it is
done what is external plug-in and there
are a couple of plugins that do exactly
that one of them is from Spring
Framework just because they needed it to
be able to it run and the other is from
our friend at Netflix enable plugins is
a great repository with tons of a Gradle
plugins and one of them is the Mabel a
dependency recommender plugin and you
can see here that it does exactly the
same the difference is that as
everything with Gradle this is much more
flexible than the maven boom mechanism
because it can take those
recommendations from multiple places
right for example it can take it from a
properties file you don't have to have a
maven bomb in order to import them and
then you say ok I don't I don't specify
the version here it should come from
recommendation and here's the list of
the providers maven bomb of course that
means that you can import spring maven
bomb or any others or properties files
or enable a dependency lock which is
another plugin from nebula that does
exactly that recommendations also map or
as usual as Greta we can just write code
that will that will do that as well like
it's something that liking from our jobs
writing our code United built let's do
some crazy stuff that's the crazy stuff
should we enforce something yeah so we
spoke about those those versions and we
spoke about that both bomb and the
recommendations are actually
recommendations but sometimes you know
there are guys that we call we love them
and and so we call them a build Nazis
right because they like to enforce
things on their development teams and I
think sometimes it makes sense it
basically means on the quality of your
bill of your engineers and how much do
you trust them if you cannot trust them
match you actually have to enforce stuff
of them right and and let's show how we
do that so without further ado since we
out of time we let's do very quickly
there is a plug-in for maven called
maven unfortunate plugin what it can do
it can impose some configuration rules
on your projects so if the rules will
not be met the project will fail to
build it will you just configure that as
any plug-in and maven you just copy
paste a bunch of over XML code from the
tutorial or Stack Overflow and then use
some like tweak tweak tweak that until
it satisfies you so the room how many
laws don't work somehow well it does
check in here I think like 25 yeah so
the things that you can require refer
enforce are like certain version of Java
only you can fail the built on certain
platforms of the operating system where
you can ban some plugins from being
applied to your build which is very
useful when you don't want random people
messing with your build system or bad
versions if we know that there are some
bad versions of dependencies we can ban
them from you you can fairly the you can
configure that to ban any sort of
behavior with a few lines of XML code so
for example here I can just say like I
will also always require Windows to
build and naturally when I build the
stuff
then it will fail can you do that in
Gradle in 25 lines I'm not sure because
I only need one so here we go
that's a groovy code take a system
property of operation system name and
then check if it contains Windows if it
doesn't fail it's great I've seen people
write GUI code sometimes it leads you
into unexpected situations can you and
then again isn't the whole shebang about
build tools was that we would like more
declarative bills yes absolutely and and
and there are problems with this code
and it's not that it is groovy but it is
that we have a custom logic in our
builds build script which is of course a
and not very appropriate a place to have
your business logic and and of course
these kind of this code should be
externalized in plugin and it definitely
can be done in Gradle so just to show
you an example of how Gradle plugin
looks we have here one that goes through
the source code and checks whether there
are some keywords that you want to
define a present or not present for this
example and that's how the code looks
like
ok we have a task we search for content
and then we just find those words and if
they are fine we issue a warning here
and if we have a flag for fail we also
will fail it and the the way we apply
this plug-in is just with one word apply
plug-in and then the name of it
that's wonderful plugins also basically
is the life of maven so you can
obviously do the same and create a
plug-in for me even as well if you want
to externalize and configure something
it almost looks like XML you can bring
an amount of code what it is is this is
this is language Oh
vise it up with some annotations you the
topmost and the one that you need to
know for creating maven plugins is the
Mojo and you specify a couple of
properties and
you basically just write the code as you
would do with unusual Java not as
suffice as groovy code but do we have
another hour because there is a lot of
code here to review we don't have
another hour but you can do that and the
application obviously the application
how could I forget I think it let me
guess 25 20 lines of XML let me check
no which here you just add a plug-in
into your build XML element and you just
do that that in the configuration over
convention over configuration wait you
just specify the configuration for
particular execution inside the multiple
executions and you configure that and it
will work and you specify would you go
and that XML connects to that piece of
java code and it works flawlessly it's
almost like I knew it is 20 lines of XML
alright so with this nice picture here
on the screen I love it that was here
it's time to vote so you just applause
for one of the tools and I think we
should start with maven of just because
you see this beauty here on the main
hopefully you'll learn a little bit
who here like this side of meinen that
we showed here excellent
all right and now let me just bring the
other code here can't see of course that
has everything I think we can declare a
tie here yeah thank you very much and
thank you guys we don't have any time
for questions but we will be around so
and if you have any bill to those
questions ping us we would have and we
have the source code for all that in
github so right here and you can see the
link</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>