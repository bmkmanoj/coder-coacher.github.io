<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Asynchronous programming in Java 8: how to use CompletableFuture by José Paumard | Coder Coacher - Coaching Coders</title><meta content="Asynchronous programming in Java 8: how to use CompletableFuture by José Paumard - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Asynchronous programming in Java 8: how to use CompletableFuture by José Paumard</b></h2><h5 class="post__date">2015-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/HdnHmbFg_hw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody welcome to this talk
after this wonderful keynote we just had
and just before lunch and the room is
still packed so I guess you are hungry
people so I'll try to go as fast as
possible so that we can go under grab a
sandwich and a cup of coffee before
continuing this or this conference so
this talk is about our synchronous API
is in Java 8 and namely completable
future the future that is complete that
is completable that is not obviously the
future of the universe more the future
inside the JVM which lies inside the PC
living expectancies maybe two or three
years so much much more modest than the
universe we just saw I want to begin by
talking about this asynchronous keyword
because it's it's some kind of buzzword
you should I don't really like buzzwords
but since this is the main subject of
the talk I think we could spend just a
few minutes to define this word let's
take a very simple example suppose we
have three tasks to execute in our JVM
and I need I want what I want of course
is to execute them as fast as possible
as efficiently as possible now there
might be some IO in them some blocking
stuff I really don't know
the first easiest way of course to
execute them is just to go for a
synchronous execution take one thread
execute the task one by one it is the
also the least efficient of course way
to do it and the second way to do it I
might think about is right I'm going
multi thread won't thread one task quite
easy and if I'm lucky enough to have at
least three calls CPU it will all
execute in parallel just as it is
written here now if I have only one call
since it in multi-threaded and that the
thread scheduler is smart enough to
detect that a task is blocking and pass
the hand to another task it might
execute that first you want then some
piece of t2 then t3 then t1 again etc
this is multi-threaded execution on only
one core is very classical I guess we
all know what it is now I
go a synchronous now that synchronous in
fact it's kind of the same as
multi-threaded on one call it just not
doesn't work the same inside there the
API but it looks like it was the same
and even if I go on a multi coil the
execution will be the same as the
previous one
most probably why because a synchronous
does not mean multi-threaded basically a
synchronous stays in the same thread now
I could compare synchronous versus
asynchronous is a synchronous any faster
where it depends on my a synchronous
engine in fact if this engine is able to
switch from one task to another it will
be indeed faster if it's not the case it
will be the same kind of performance but
I could compare synchronous
multi-threaded versus a synchronous is a
synchronous any faster than
multi-threaded when it can be because a
synchronous in is non blocking and
because if I'm in a multi-threaded model
I need to switch the context of the
threads and this I will not have to pay
for that in an Indian a synchronous the
world and there is a second aspect of it
since a synchronous takes place in the
same thread all the operations do not
need to be visible from each other
because precisely I am in same thread so
no visibility problem no atomicity
problem no synchronization problem what
could be the pattern of some a
synchronous call let us write this kind
of thing this is pure meta code this is
not Java even if it looks like Java I've
got some kind of query engine that will
talk to some kind of database or
whatever I pass a request could be
sequel could be something else and for
each element of the other result I want
to just to print printed on them out or
everything in an asynchronous world is
programmed with callbacks and the fact
is in Java 8 we have lambdas I'm lambdas
are just great object the right tool to
to build callbacks this for each method
takes what we call in the in the
functional interface where a consumer
consume
takes the value doesn't return anything
and it's really great to do a song
called back for that okay so this is
those lambdas are are really great to
make a call back when the result is
available the task will be called on all
the elements of the result and this is
what makes the thing a synchronous the
result is pushed to the callback instead
of having the result pulled from the
list or from the intermediate structure
and passed to the to the lambda
expression all right this is all very
fine but as I said it's not Java code is
just meta code how can we write this
kind of thing in Java the problem is
that up to Java 7 we do not have much
tools to program this kind of thing we
have this runnable object if since Java
want the very early days of Java now
renoble object doesn't take any
parameter does not return anything
doesn't show any exception so it's not
very nice to build systems with with Ren
ball because it's just mute and blind
since Java 5 we have the color ball
basically the color ball is some kind of
render ball but the nice thing is that
can reach on a value and it can also
throw exceptions and in Java 5 we have a
new tools also that we are going out
this is picture time
excuse me hello pleased to meet you
thank you now we need to make this
ladies work easier all right where was I
yes future no not future the universe
yes future in Java yes so basically what
I can do in Java file is I take a task
whether run a bowler Cola call a ball I
send this task to pull of threads and I
what I get back is the future object and
what can I do with the future object
well I can I've got basically one one
pattern to get the result which is the
get pattern and the thing that is not so
nice is that the get method is blocking
that is the result is not ready yet will
not
return of course it will wait for the
result to be ready to return so this
gate reader might might take a while and
during that time what I would like to do
of course is something else we want my
the computation for instance the problem
with this pattern is that this object
the result object is computing it's
repeated in the runnable or in the
callable and taken back to the thread
that generated this task through the get
method of the future so this future
object is in fact some kind of a bridge
between two threads the threads in which
the computation took place and the
recording thread and passing an object
from one task to another has to be
handled in the master thread until Java
7 I have to get this object back and to
send it back to another task if I want
to change different tasks and this is
precisely what computable future is
going to address I will not have to do
that anymore in a computable future so
we have a new tool in Java 8 so under
this precise case and to bring a
solution to chain tasks that unload both
at synchronous and multi-threaded
programming which is nice because nobody
understand a synchronous programming
nobody understand concurrent programming
so when you mix them together you really
get something absolutely impossible to
understand this is great my name is Jose
a right this is my picture by the way
this picture has been taken by this nice
lady that just came here 2 years ago
I've got some resources on the web if
you want to check that out on wrote
article for Java magazine I also have
unlike courses for a company called
Pluralsight I also have some on
Microsoft Virtual Academy Microsoft
Virtual Academy is publishing Java
courses can you imagine that right and
also on Pallas or free for one more year
ok if you have questions what why don't
we with we use Twitter there is an
application when the in the app we've
downloaded for the works this year the
problem it seems that the question are
lost one the talk is finished so if you
want your question to be to be there in
the next few days so that we can
continue to interact I think that
Twitter is
tiller probably a better solution all
right let us create another synchronous
task and let us see an example may be an
example that some of you already came
across it's an example taken from Jersey
you know the Jersey is the
implementation of jax-rs and this is a
copy pasted from from the documentation
of Jersey what is going on here I've
gotten a synchronous rest service in
fact which is programmed like that I've
got some longer operational
to be conducted and of course since I
don't want my recipes to be blocking
what I what I want to do basically is
run this long operation in a thread so
this is the proposed pattern from the
Jersey documentation create a rentable
pass discernible to a new thread and
call the start method on this new thread
it might be not that great right things
like that we are in java 8 so we could
write them like that but take an
executor service
call the executor method with a color
ball now call a board is a functional
interface so we can implement this
interface with a lambda expression just
as it is a case here which is nice now
the question is I am a fanatic of TDD
clean code and things like that I guess
we all are and I would like to unit test
this code and the problem is that what I
want to unit test is that the result of
the longer peroration has been properly
computed and passed to the resume method
the problem is that since it is wrapped
in a runnable and executed in another
thread I need to check that once this
thread has finished its work but I have
no clue when this red has finished its
work
I am a really bad situation because I
cannot do this easily it's too bad
because just to test this kind of thing
I have mugs for that I could write very
easily
some kind of mojito a test and if it
everything was run in the same thread it
wouldn't post any problem to do that
let us give one more look at the code in
orange this is the code that is executed
in the current thread the thread of my
test and in blue executed in another
thread because it is the code of the
crebbil I'm passing here maybe so
renoble
okay it's if you turned in another
thread and what I want to do is to put
some kind of callback once this runnable
has finished his execution I want to get
the result and check if my mocks have
been properly called with the proper
objects if I have mocked to chain we I
have mocked to check if the resume is
properly called with the reserved with
the proper result object it's a very
basic test we I'm pretty sure that
everybody already wrote this kind of tag
with what is tricky is that I am in an
asynchronous world so I need to check
that in the same thread or in an
industry in the blue thread that was on
the previous slide what I could do is
mark sync response for instance I could
even mug the result and if I do this
kind of thing my mock is this one sorry
if I do this kind of thing what I want
to execute after that is just verify
that result has been passed to the
resume method on the mock resync
response mock object but I need to
verify that once the run method has been
called and as finished is execution and
if I look take a look carefully at that
since I am in a multi-threaded welder I
also need to take this into account the
multi-threaded aspect of things all
right
what I'm basically doing is reading and
writing on a mock object if my mock
object is created and trained that is
written in the thread of my test and if
I check my mock in the thread of my run
ball those are not the same thread and
most probably the modification made on
my mug will not be visible from one
thread to another so in an ideal world I
want this modification to be made
visible and the simplest way of doing
that is to train and verify my mark in
the same thread
the runner ball which is tricky so my
constraint are the following I need to
verify my mark once the run method has
been executed and I need to read and
write my mark in the same thread as the
run has been executed and this is
precisely where the completable future
or the completion stage completion
stated the interface comes to the rescue
let us just take this code out of this
as in yet and just take a look at this
pattern I take an executor call the
submit method with some runnable or call
ball here it's a combo write this
pattern in the completable futureworld
will become this one I call completable
future run I think this is a static
method from this class I take my color
render ball here and pass it as a
parameter to this runasync method and
instead of calling this on the executor
I pass the executor as a parameter so
basically does the same thing but will
be put with a different pattern and the
nice thing is that this code returns an
object which is not a future as the
submit call from Java 5 but a
completable future object with a bunch
of new methods that we are going to see
and that will solve the problem on this
completable future object what I can
call is then run then run takes a run a
bowl and the completable future API and
shows me that this run a ball will be
run after the run at the run a ball
passed to the runasync method of the
previous one so we just do exactly what
I need I stick need to take care about
visibility issues and we are going to
see that later at the talk what what
what I would like to say that I could
fix visibility issues with probably
atomic variables synchronizations
volatility etc but the simplest way of
doing things is just run in the same
thread we just run all the operation in
the same thread so what do I have in
this completion stage completable future
API in fact I have two elements in this
API the first element is the completion
stage and I have an implementing class
which is complete
future now there's something quite I
think unique in the JDK is that inside
the interface itself I have a method
that returns the implementation so I
have a two completable future in the
interface that returns the completable
future which is the implementation of
the completion stage what is the
completion stage the completion stage is
fact is a model for tasks in an
asynchronous world what is the task it
is something that performs an action
that may return the value or may not
return the value that may take the
parameter or may not take any parameter
and that may trigger another tasks and
that all is also linked to an upcoming
tasks so it's really an element of a
chain of computable future what is the
completable future set they display the
model for the completion state that is
the interface
what is the completable future from a
technical point of view it's a glass
concrete class so I can just create them
quite easily that implements both future
this old interface from Java 5 and
completion stage new interface from Java
8
the completable future has a state which
is very simple the task may be rainy Nia
or may not be raining still this task
may have complete normally producing a
value or no value and all these tasks
may have complete exceptionally
producing an exception or no exception
there is special code in the completable
future to handle exceptions and we are
going today we are going to see it at
the end of this talk remember that from
future I had five methods the first one
is the cancel method just to cancel the
future that is not running I also have a
is cancelled and is down to test if my
future has been cancelled or as finished
doing its computation and I have two
other methods get and the version of get
that takes a timeout alright get is a
blocking call we already saw they saw it
in a previous example get with the
timeout is not blocking until
timeout runs out those method may throw
checked exceptions if the task does not
run or properly now in computable future
I have a first family of method method
sorry that just our future like method I
call them like that because they're just
some kind of precision added to the
existing methods from from future I've
got a joint method which is basically
the same as the get method but that does
not throw any checked exception so you
don't need to mess out with a try-catch
and stuff I have a get now method which
cancels the the completable future and
provide the value that this completable
future should return remember we are in
a multi-threaded world so I could do
that in the thread and my and treat it
could free up resources in our threader
I have a complete and obtrude value
method that will tell right if this
computable future is not complete then
you complete it with the given value an
object value even if the completed
future is complete then you take this
value and reset the value that should be
returned by this completable future and
the same for exceptional complete
exceptionally and absurd exception which
is exactly the same semantics as the
previous one
but with exception all right so those
are the easy metal methods from
completable future what I didn't say at
the beginning maybe I should have said
that before is that they are like 60 or
70 methods incomplete or future that
makes it a little difficult to to to
handle at first we are not going to see
them all but most of them and in a
summarized way let's say that it like
that how to create a complete computer
future
I have several patterns for that the the
simplest pattern is to use this
completed future the static method I
pass the value that this future should
return and it just returns me a complete
future that doesn't do anything apart
from returning this value this
computable future is completed by nature
so if I call it's done on it it will
always
returned true and I also saw already saw
the Renaissance method takes a runnable
and an executor service to run this
runnable in the past executor service
and the supplier sank method that takes
the supplier now supplier is a
functional interface from Java 8 that
doesn't take any parameter and that
returns a value the renewal doesn't
return anything ok how can I build now
completion stage change in fact I have a
set of methods on the completion stage
itself that will do some kind of
operation and return another completion
stage and this is what we are going to
do now what has to be seen is that a
completion CD is a step in a chain I
already said that it can be triggered by
your previous completion stage on which
I have called a special method that
returned this completion stage and this
the execution of this completion stage
can trigger a further completion stage
downside the chain and it can be
executed in a given executor that is I
can take an executor which is basically
put a thread pass it to a completer
completion stage or continual future and
decide to execute this task in the given
executor alright what is a task a task
has been three things a runnable
classical object doesn't take anything
doesn't return anything the consumer the
consumer takes an object but does not
return anything system.out.println is
the most obvious consumer that we can
aware that you can build it can also be
a function the function takes an object
and returns another object of possibly
of another type so this chain of
completion stage can be belong tasks
that can all be functioned that this
that can transform objects from one step
to the other over to the up to the
expectation of the result so that is
three types of methods on the completion
stage one method for each type of task 3
what kind of operation does it
support it supports four types of
operation chaining chaining is just I
have a completion completion stage then
another one then another one it's some
kind of one-to-one relationship
composing and composing it's the same
type as chaining but it doesn't work
with the same kind of function right
combined in iya what does combining
means is that I have two completion
completion stage and that will be
connected to one and this one completion
stage can wait for both results to be
available and will merge them in some
way and then call the the downside
completed stage and another type of
combination which is triggered on the
first value that is available I may have
to completion stage if the first one
generates a result this result will be
passed to the downside completion stage
and it will continue without waiting for
the other results this is useful when
you want to for instance query DNS s DNS
is are all supposed to get you the same
value but what you can do to to
accelerate your computation is to learn
the same query on let's say 10 DNS s and
just need the first result which is the
one you want fastest the fastest so I
had three tasks I have now four types of
chaining composition and stuff that
makes twelve methods right we're not
done okay in what thread sorry this is
not the right time in what thread can it
be executed if I do not pass any
executor to this to the method we are
building then it will be executed in the
same thread as the upside completion
stage and I can pass a new executive
service as a parameter to execute this
completion stage in this executor
service right and it can also be called
a synchronously without passing an
execute as a parameter in which case it
will be executed in the common for join
pool so three times four times three
that makes 36 methods just to change
completion stage together
we are not going to see them one by one
the problem with that let us just see a
few pattern to see how the names of
those methods have been created then
apply cold on the completion stage
returns a new completion stage and we'll
take a function as a parameter that will
be able to take the value from the
previous completion stage and transform
it for the downside completion stage
then run a sync apply is fine Frank is
for functions Ren is for Red Bull I
think mean that this completion stage
will be run as synchronously that is
either in the past executor
if I pass an executor as a parameter
either in a common for joint pool if I
do not pass an executor as a parameter
so then when I think this is right this
this stuff and then composites I think
this is composition composition takes a
special kind of function that takes two
T and returns the completion stage of
you there is a result wrapped in another
completed stage that was for the one one
pattern let us see some two one patterns
then combined I think combined is called
on a completion stage and takes another
completion stage as a parameter
they are both combined in the B function
that will generate a value from the two
website completion stage to the dice on
route that down side one then except
which is basically the same same thing
but instead of a B function we'll take a
big consumer a B consumer does not
generate any value and if I call the
both method on it then it will take both
operation both sorry both excuse me both
element generated from the up side and
run after both I think we'll wait for
the two website completion stage since
it is a run it takes a runnable that
doesn't take any parameter and doesn't
generate any value let us see some more
a to one pattern so apply to wither when
I have both it means that I'm waiting
for both results to be
when I have either at the end of the
method it means that I'm just waiting
for the first result to be available and
to take it into account and you can see
that on this method I take a function
and not to be function because the
function is just waiting for the first
result to be available and I also have
except either except text consumer here
as a parameter different from from the
function and the run after a sync takes
a runnable instead of alpha consumer so
applies for function except is for
consumer same name by the way as the
method in the X in the consumer
functional interface and a runner ran
for runnable okay so those are just a
big picture of all the the patterns I
have to combine and to chain completion
stages together let us go back to our
first example I am going to write now
now that I'm fluent in completable
future and can solve my problem in fact
because I have all the tools I need so
let us create a mock of the result and
the response very basic mockito patterns
ax and i'm going to create a first
runner ball that will train my mug this
mug should return response when long
operation is called on it sorry should
return result when response is called
longer parisian method and are another
ren able to do the verification verify
that result result has been passed to
the resume method of my mocked response
so the complete pattern will will become
this warner first i create a run a ball
to encapsulate both the cold and then
the verification execute a sink response
then run verify and i can just create an
executor since i want everything to be
executed in the same executor service
what i can do is just create an executor
with one thread in it and pass this
special executor as the executor service
of my essential resource object and then
use the runner the completable future
api
to run I think the Train of my mark in
this mono thread executor then run the
call and verify that we call the method
I want to to test and call the run a
bowl of the verification of the mug and
if I want to be absolutely sure that my
test will run properly because all this
of course runs a synchronously in
another thread just for instance called
the gate with the timeout method here to
be sure that after 10 seconds if the
this test has not run it will generate
an exception so this is this leads to a
very simple and very clean pattern the
only thing I had to do is to split the
method from the jersey stuff in to to
get the completable future as a result
from a public method Jersey on jax-rs
takes the result of the method and has a
tendency to to convert them into JSON
and XML or things like that if you do
that with a computer feature it might
not work very well of course let us take
the second example and it's of course
inspired from the Java concurrency in
practice excellent book written by Doug
Liman Brian gets years ago it's it it's
about reading pages getting links images
etc from those web pages so I can supply
I think this this task that is just the
reading of the page and the generation
of
a text element with the content of the
page then I apply the following function
takes the text the HTML text of the page
press the links from that page and get
the result as a list of links for
instance and then accept this method
that takes just two consumer takes the
list of links and decide to display of
those links in a given panel now since I
want to display those links in a panel I
could be in a swing application in a
JavaFX application why not in some kind
of Android application
not sure if Android is supporting lambda
expression probably not but at least in
swing and JavaFX I won't of course this
display panel to be deterred in the
proper thread that is the screen thread
so I need to pass the proper executor
service to be sure that this updating
will be executed in the proper appro
thread now the nice thing is that if I
check the executor interface it has only
one abstract method in it so in Java 8 I
can implement this interface with the
lambda expression and execute or in fact
is just this runner ball gives swing
utilities invoke later run about this is
photos for the thread swing so I can
just pass this executor as a second
parameter to my acceptor sync method
from here making sure that this panel
will be updated in the right thread and
since I'm a method reference lover I can
also write it like that leading to an
even simpler and cleaner pattern this is
great I love this kind of thing second
example last example I think events in
in CDI how does the events in CDI work
basically I get an event object from the
injection framework of CDI and I can
fire use the fire method from this event
object passing a parameter that has the
type of the parameter of this event
object and on the other hand I may have
a bunch of observed methods annotated
like that
to get the payload which in this example
is some event and how the and all this
event synchronously the events in CDI 1
the 2 up to 1.2 are synchronous that is
this observes method will be executed in
the same thread as the even fire method
now in the upcoming version CVI CDI 2.0
well what I could do if I want to go a
synchronous is just create my
completable future inside the observed
method now this is not that great to do
that because Cydia is about hiding
technicalities and complete complex
implementation details from the user so
what while doing in CDI 2.0 is provided
fire a sync method that will fire this
event as synchronously and on top server
that is also an a synchronous observer
with an observes a sync annotation on
the payload and this time this event
will be handled in another thread and
once again if you want to execute your
observers in a special thread you can
pass the executor as a parameter to the
fire sync a call this exit sorry
executing this some event in a special
thread in the swing thread if you want
to do that now the last thing is this
fire sync method returns an object which
is a completion stage what did we do
that it's because of the handling of
exceptions if you have an exception in
the current thread in this event
observer observer a pattern it will
probably do some bad things to the main
thread since the thread of the observers
is the same as the fire thread here it's
not the same so if an exception is
raised in an observer we need to get the
section this exception back to the
firing thread and while just leveraging
the completion stage to do that we have
several method to - under exception in
the completion stage once of them is the
when complete method to do that before
going to the exception one last pattern
from for completion stage I also have
two methods to create completable
futures all off and any off that takes a
bunch
completable futures all love will return
the complicit able future that completes
when all the past computable future have
complete and any of when the first of
them has complete
let us talk a little about exception
handling because it's really a key point
I think of this kind of thing so
basically a computable future can depend
on one completable future - computable
futures with the first method we saw @n
computable futures with the two last
static method we just saw what happens
if an exception is thrown is in this
chain of completion stage well let us
have a look at such a China every Blue
Square is of course a computable future
they are numbered so it's nice and
suppose that CF - one raises an
exception what happens is that all the
downside completable future we also be
in error what does it mean to be in
error
it means that if I call the is completed
exceptionally method to check if there
is an error in it it will return true
and if I call the get method it will
return an execution exception with the
cause of the exception as the root of
this exception so this is what happens
if I do that but the nice thing is
completable future can itself handle
exception properly suppose we have this
computable future pipeline an exception
raised so all the downside computable
future are in a row what I can do is
create an intermediate computable future
using for instance the exceptionally
method and the semantics of this
exceptionally method is that if there is
no exception in the in the upside
completable future the result will be
transmitted transparently to the next
computable future so everything is like
cf-30 is not here and if there is an
exception then cf-30 can handle it
properly can get this exception and can
generate a result without any exception
to the downside completion stage I can
lead window no exception retake so fun
shown in fact and this function takes a
throwable the exception and return the T
will be transmitted to the downside a
completion stage so it's something that
just can just catch the exception in an
asynchronous query
I've got other methods for that EXO
handle which can take an executor and
which has an icing version and when
complete the method I used on the on the
example in the CDI example which handles
which also has a nothing version and the
version that takes an executor so that's
seven more methods in the completion
completable future class leading to some
kind of 14 and stuff all right let us
have a look at the very last example I
would not finish the choke without
talking about stream zone it should be
already sad
in July it not to talk about stream and
let us see how we can mix those
completable future with streams it
clicks to a quite complex example sorry
about that okay we are going to create a
special completable future closing just
by calling the constructor like that so
this closing computable future doesn't
do anything but it's not complete if I
call there is complete or is
exceptionally method on it everything
will return false and I'm just creating
a stream on a basic set of strings let
us do that I have a nice callback on the
stream API which is called the own
closed callback that can trigger some
kind of operation if I call the close
method of the stream object so let us
begin by doing that calling the Union
close it takes an action and sorry
consumer no it's not the consumer it's a
gesture or container okay some kind of
renewal as a parameter and if I call the
close method on the stream it will
complete the completable future that I
call closing all right so closing the
stream will complete this computable
future and in fact I am going to use
this completable future as a trigger to
not do anything more
then trigger the operation then I can
just do my opinion I take all the
strings and I rub them one by one in
completable future I can't even do some
kind of filtering take the completable
future with the string in it get the
result to get the length and filter out
all the lengths that are greater than 20
I could do for the mapping if I wish and
I can do some kind of reduction now
remember that reduction takes two
parameters first parameter is the
identity element of the reduction
operation and second element is the
function that will do the reduction
itself so binary operator here so this
reduction would just take to complete
all future with the two strings in them
we'll call the then combine which is the
right method that works in the same
thread to call this a computable this
try to combine those two computable
future and this binary operator will for
instance concatenate those two strings
and return the result in another
computable future okay great but this
closing object which is the first
computable future that has created that
the first line of this example is a
special completable future that will be
used as the seed of this operation so in
fact the combination of all those will
be will have this closing object as the
first one and I will combine this
closing completable future which is not
complete without a computable future
which are then them completed so
basically it will create a whole chain
of computable future that doesn't do
anything is just a declaration since the
first element is not complete yet right
this returns a completable future that
that could call for instance reduce and
this is very fast to do because it
doesn't do any computation it just
create a graph of completion stage all
the way down and what happens if I want
to trigger the computation well as I
just told you what I need to do is to
close the stream I have the
have here calling closer will execute
closing dot complete all right with the
value passed as a parameter and will
trigger all the China generated by my
binary operator here which will
concatenate all the operations so in
fact all the operations of this stream
will be run as synchronous and
synchronously using this trick closing
the stream and then calling the callback
on the closing of the stream which is
great and it works because of course
this closing object is the first object
of my chain it will just cascade all the
way long now what happen if I want to
run this in parallel of course it will
work because every everything has been
done to do that but what I could want to
do is to run this in parallel in a
special pull of thread in a special
executor how can I do that well I just
need to wrap all this code into a run a
ball just like this it's a runnable that
once again just do some computation as
synchronously create a fortune pool for
joint put is an extension of the
executor create this compatible future
by calling run a sync with this nice
string computation pass the fork/join
pool as a parameter since the for join
put is also an executor it will work and
get the result computed in that precise
fortune pool all in an asynchronous way
which is really great all right so that
night thing is that we now have an API
for a synchronous computation in the JDK
it's quite a complex API I think that
most of the complexity does not come
from the concept themselves which are
quite simple but more from the
complexity of the completable future
class itself there are many many methods
in it some of them are static some of
them are non static and it's quite hard
to end to go into this discussion to
understand how it has been made there
are there is a very rich semantics with
many ways of implementing the tasks many
method which makes the
standing of this quite complex it's all
builder or nada expression which is very
nice and can lead to very readable
pattern remember the pattern on the
reading of the page with the links
forget about the pattern with the stream
it was much more more complex we have a
very fine controller and thread though I
can really decide for each task to be
run in that special thread is it an i/o
thread is it a computation thread etc if
it reminds you something from our X Java
might probably be a good idea good way
it handles chaining with a lot of
semantics one two one two one it also
handles computation and with a very
clean way of handling exception which is
very nice because we didn't had really
had that in a previous API and this is
the conclusion of this talk I thank you
for your attention and I was fast enough
so we have a little more than 6 minutes
for questions I don't know if some of
you posted questions on Twitter let me
check that since I can't see I can't see
absolutely anything in the room you can
try to raise your hand and make some
noise if you want to handle questions
all right
I guess people are telling me that they
love me thank you for that I can tell
you the number of my bank accounts if
you really want to add there's a
question in the room sorry I can see it
so just shout okay right yeah
can I go back to the stream oh sure
you really want to see that again I will
publish this slide if you check the the
ashtag I just gave I will publish the
slide on SlideShare so so if you just
take your picture forget about it
shouldn't get be joined in the filter
call no because the completed future
because here I'm building a completed
future so this future is already
completed so the get method will return
immediately sorry are the checks
exceptional there is a section section
here I'm not sure is it all right so
join okay cool join
you mean the filter call yeah yeah hmm
if you run this code basically it's
about if you in the binary operator if
you if you add a string concatenation
and run this code you several times you
will see that the swing contact
conundrum concatenation doesn't take
place always in the same order which
really shows that it is run in parallel
yes of course if you're for jump or has
one more than one thread because if it
has only one thread its parallelism
between one thread so it's not
parallelism anymore really yeah
any other questions all right can
exceptionally provide different
computable future depending on the type
of the exception yes absolutely you can
you can have a function that takes
throwable and then check the type of
exception you have in it and then decide
to return of course these types has to
have to be compatible because the
function has a certain type itself so it
cannot return something that does not
extend the declare the declared type we
have the question don't you think that
when doing a sing computation signalling
errors using exceptions is an
anti-pattern so it's an error itself you
mean but to signal this error would you
would you use exceptions or tribal well
exception either is the standard way of
dealing with errors in Java so we have
to live with it I think the nice thing
is that we do not have to live this API
has not been built on checked exception
but unchecked exception so at least it
does not appear in the in the in the
signatures of the ultimate
one of the calls but getting exception
sometimes you if you're doing some kind
of i/o you will have to deal with the
exception that you don't have the Y and
on so so you need you need to be able to
do that anyway computable future seems
to have some similarities to promises
and differs in JavaScript this is not
really a question this is this is a
comment all right you get it if you use
either method to the remaining
computable future with a get cancelled
need to check the exact API for that I
don't I don't have the right answer for
that I think yes but I'm not quite sure
if you if you call cancel on the
completable future that is already done
then then it will it will not do it will
not do anything do we have more
questions yes we have cancel does not
stop the thread it is running on
absolutely yes yes this is how executors
work in fact this is the difference
between calling new thread and passing a
rainbow yeah sorry I didn't hear you
yeah yeah yeah this is the nice thing
you don't have to handle synchronization
yourself this is the nothing alright we
have one minute left for questions so I
think it's a bit too late now I'll be
around in there in a minute in a place
so if you want to grab my hand I'd be
more than happy to have a chat with you
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>