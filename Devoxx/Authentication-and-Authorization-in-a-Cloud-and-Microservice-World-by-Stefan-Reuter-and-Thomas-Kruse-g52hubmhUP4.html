<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Authentication and Authorization in a Cloud and Microservice World by Stefan Reuter and Thomas Kruse | Coder Coacher - Coaching Coders</title><meta content="Authentication and Authorization in a Cloud and Microservice World by Stefan Reuter and Thomas Kruse - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Authentication and Authorization in a Cloud and Microservice World by Stefan Reuter and Thomas Kruse</b></h2><h5 class="post__date">2016-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/g52hubmhUP4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yeah thank you for joining us today
my name is Stephanie whiten and I've
worked as an IT architect for Deutsche
Post back until 2008 and since then been
working as an independent IT consultant
working in different projects for
different customers where authentication
and authorization was always a high
priority my basic interests are in IT
architecture so to basically figure out
where to put a certain piece of
functionality within your landscape
software development using multiple
languages mainly focused on on Java and
in recent times JavaScript go I'm doing
consulting on development practices like
scrum and DevOps actually bringing stuff
into production and running it in a
secure environment
I'm Tomas Cruz I'm working as an
independent IT consultant since the
2000s I'm a co-founder of the Java user
group in Munster and I found that the
trying development consultant agency in
Germany 2011 so just to give you a
picture or we are located in Germany
doing development consulting training
and coaching and that's where security
authentication and authorization comes
into the picture because it's always
part of projects so organization of this
talk first I will give you a short
introduction into the terminology
history of authentication and the
history of application landscape so that
you can see where the requirements for
the current technologies originates and
later on Stephan will present some
solutions for you
so what I often noticed is that
authentication and authorization are not
understood fully what is what and how
does it work
so authentication is a process of
determining whether someone or something
is who or what it is declared to be so
that you can get a grasp of the identity
of a thing or a person this is important
because otherwise someone can claim to
be a policeman and you have to pay money
for him even if he isn't in the real
world we usually use a passport to
identify ourself and the process to
checking the passport is authentication
what you often have are in the context
of authentication are users and the
credentials so in the IT world you don't
have a pass but usually but you have a
username and password
there are credentials you want to manage
users so you put them into groups to
make it easier to manage it a user can
have a role so I am a policeman in my
work time but in my free time I'm not a
policeman but have a different role so
there's our rules what you often see in
documentation is an abbreviation of the
word it's of an authorization it's a
process of giving someone permission to
do or have something so usually you
first authenticate a person and
afterwards he gets some permission to do
something that's authorization
authorization can be rather complex
because depending on the time or the
context a person or users in it can be
different what is allowed to do or not
to do it's conditions that are special
for example if you are an insurance
company you are allowed to
work with cases up to 2,000 euros so you
can't generalize it and after 2000 euros
different user must come with a
different role on permissions so roles
again
and from the roles you get permissions
the usual abbreviation for authorization
is offset the chart history so you can
see how the different technologies and
processes are built usually about 20
years ago each system has its own
authentication process so you have one
login form per system each user has a
username and password for each system
and each system has its own database or
configuration file where users stored in
the context of enterprise environments
this is not practical
so we need some other kind of store
where a lab comes in so hierarchical
structure and it's providing new search
capabilities so you can search for users
you can bind to the LDAP and check the
credentials of a user it's often used
for shared address books something like
that as well but mainly the focus in
this talk is as a storage for user datum
who knows Kerberos anyone how cool
Oh many people here ok so I don't have
to tell you much about it was invented
in the 1980s it's a ticket based and
allows something new it's single sign-on
across different applications in a
single trust only you need mutual trust
and authentication in this environment
but it provides some features that you
usually want in today's applications as
well
cameras are widely supported especially
in the Windows domain and yeah it's some
aspects of it we will see later are
still present in modern systems some
people may know radius it's a remote
authentication dialing users
is special about this is you cannot only
authenticate to it but it provides
accounting services as well so how many
mega rights did you download this is a
quite old protocol as well and it still
use in use today if you have Wi-Fi where
you want username and password to join
it or if you have bought based security
on the lamp more in the context of web
applications it's similar that's since
2005 widely used especially in the
enterprise context and some thing I
think is noteworthy here is a metadata
if you want to have to enterprises to
federates authentication systems you
need to configure much stuff where at
the endpoints and what certificates to
use and the thermal metadata provides
this so you can just exchange one
configuration file and in theory it
works and most of them practice as well
another feature is that you have the
option to have the identity provider
without any direct connection to the
service provider so the user transports
all data between both systems in both
ways it's very interesting if you have
secured domains which can't directly
connect to each other off - there's more
reasoned it provides delegated
authorization especially in the web
service context cloud context and it was
later used to provide social Hokkien
Facebook get up Google they all provide
social Lockean in the past based on laws
even it wasn't even if it wasn't
designed to do login to make a standard
of mighty connect was invented it builds
on us - and standardized social
networking capabilities so this was a
technology history now we have on the
other hand a short history of
application landscapes first there was a
mainframe you basically the
login to the application on the
mainframe itself using remote access
terminals later there was client-server
distributed systems where you have a
local area network and usually you have
segregated the different tiers to my
client-server applications then came the
Internet at first it was low bandwidth
with high latency so usually you had
special purpose hardware like a modem to
dial up to some application and more or
less it was like the mainframe just a
remote terminal the change was a World
Wide Web when applications became
accessible to regular and users using a
web browser with commodity hardware and
software and that was the that was the
foundation for the cloud as well so now
we have a landscape where many services
are running a public or private cloud
environment and have to provide elastic
scaling so if you need Salesforce or a
Google Apps work this is all running in
the cloud and you need authentication
for this you need to provide a way to
exchange user data and their claims
micro-services is something yeah like
when you want to do the cloud stuff in
your environment and benefit from all
that and especially with micro services
you have remote connections between each
service and you need a possibility to
transport all the authentication or
authorization data between these
services on behalf of a user and you
need to have stateless so you can scale
all services independently so now we are
today and want to know what can we do
then what are the requirements for
authentication and authorization in
today's environment you need to be fault
tolerant because everybody needs to
authenticate to so many systems you
can't afford any downtime you need to
scale independently
of the other applications you need to
support delegation to support micro
services and you need usually to support
some kind of Federation even if you're
inside your own organization you need to
have some way to connect to other
systems to import their users from there
or access to user data from a different
system so it would be great if there
would be some standard to integrate all
the systems even when they are running
with different languages different
platforms and frameworks and to support
multi-factor authentication because
there are so many phishing attacks today
authorization is a little bit less you
need role based access control to make
it manageable you need fine-grained
permissions like I said earlier you have
some use cases where you really have
fine-grained access controls and you
need to support independent evolution of
your micro services so there should be
no tight coupling between them just to
provide authentication authorization and
you need to have some kind of central
overview and management because it's
what you usually have a massive
requirement from your management so now
we need a solution I hope you can
provide it
so based on these requirements we can
sketch out a solution that can function
as kind of a blueprint for your general
needs for authentication and
authorization within this world of micro
services and multiple applications that
are running at scale if we start with
this then first we need a central store
for users and credentials and depending
on the scale you're going to deploy your
application this can be as easy as a no
central LDAP server like an Active
Directory if you're working already with
with Microsoft products within your
enterprise or if you scale up you would
probably go with some no SQL databases
like Cassandra or a key value store
something that scales in the same way as
your application as opposed to scale and
you will put in all your your users the
credentials of your users like passwords
of course hashed so that they are not
stored in plain text or any other
credentials that you want to manage so
this could include the the seeds for two
factor authentication devices like
time-based one-time passwords that could
be the common names of certificates that
you are using to identify whatever fits
into this goes into a central store that
is distributed and that is used to
account you users in credentials to
access this store you will use a central
authentication system so and the reason
for this is that authentication is
actually a domain on its own so if
you've heard about the main driven
design and the idea of a bounded context
sent of domain-specific languages then
you will easily find out that the domain
of authentication with all the the
different requirements is something that
you want to isolate from your
application because
if you do it on your own then you have
to implement a whole bunch of things
like a sign-up process for new users or
password policies where as a password
must have learn and specific length or
must contain special characters password
will expire all these things go into the
domain of a central authentication
system and the authentication domain
will also want to implement a change
password function so that your users can
change their password whenever they
choose to or when they are forced to by
the policy and you will be implementing
a forgot password function you will
probably want to capture if you're
noticing that users have tried to log in
with incorrect correct credentials
multiple times to make sure that there
is no prude force attacks going on and
sometimes you want to remember me
function to make it more easy for users
to come back and do not have to enter
that password all the time so all those
features and this is only a small list
of the total amount of features that you
would have to implement and they should
go into a central service that is
actually responsible for all things
regarding authentication and that you
only implement once or maybe even that
you buy off-the-shelf because of the
reuse that you can make it's nothing
that separates your company from other
companies it's just something that you
should buy if you find a product that
fits your requirements so now that we
have a central authentication system we
want the user to be able to log in so to
facilitate this most systems today are
using browser-based logins whether this
is directly from from desktop browser or
mobile device with mobile browser
most of the systems are browser-based
but your authentication system will also
have to support login from desktop
applications if you are running a java I
accept
Cashin for example or if you're running
an S AP system with the UI whatever this
is you will want to have a desktop
application be able to log into just by
providing credentials to the
authentication system the same goes for
mobile applications of your native
Android or iPhone applications you will
want to be able to authenticate
what those devices - so what is
authentication and login actually mean
it means that you provide your
credentials to this central service and
you get something in return and this
thing that you get in return should
actually be a proof of the validation
that the authentication system has done
and in modern systems that are able to
go to scale this will probably be a
token so you exchange your password and
your username and password or whatever
other credentials you have for a token
that proves that the authentication
service actually has validated your
identity and that you are actually
yourself so let's have a look at the
token some more detail and those tokens
provide a level of indirection so in
exchange for their credentials the users
receive a token that they can use and
the token is then presented to resource
providers so actually your applications
or your micro services your cloud-based
resources and instead of the credentials
so that you can gain access there are
big advantage of this is that you're
actually preventing your services or
your resource providers from having to
deal with the passwords they never see
them they only see those tokens and
those tokens usually have a very limited
lifetime so they are only valid for a
few minutes or maybe for for a few hours
but afterwards they're useless and so
it's much more secure to deal with those
tokens for your application and to
actually see the real credentials of the
user a token can be either an app hog
structure
so it's just a string with no actual
meaning in sight that you have to
resolve somewhere or it can be
structured data so it could be an XML
document for example this is what sam'l
does sam'l assertion is basically just a
token or it could be some kind of a JSON
format that is maybe base64 encoded so
that it can be transmitted more easily
but if the token actually contains
information inside examples of those
tokens include access token and the
Refresh token that you may be familiar
with from olaf 2 or it can be an open ID
connect ID token there you would use a
jot token this is actually an example of
JSON based structure that contains all
the information so a state-of the-art
token has a few requirements that i
would like to show you first of all it
is it should be stateless so that you
don't need to keep any state this is
different from your normal session ID
because if you have a session ID then
this information does not help you much
and only it only makes sense if you
actually look it up in your session
database and your memory or wherever you
store the session data a good
state-of-the-art token would be
stateless so that your application does
not have to keep any state and it's
self-contained it should also support
local validation local validation means
that just by having a look at the token
you can tell whether this token is valid
or not so whether it was issued by a
trusted authentication service or just
something the user made up by himself it
should also be lightweight that means
and it should be small in size that it
should be easy to parse so for example
the sam'l assertion would not qualify as
live right because you need a full
fledge XML parser you would need some
additional support for XML signatures
and XML encryption and
also would be difficult to implement
this in very small devices so easy to
parse would be part of their
requirements for a state of the art
token it should be short-lived so that
it's not a token that you issue once and
it's valid for like years for example on
as an L certificate that is issued for a
server that is valid for like three
years would not qualify here and I
should be so that it can be part of
every request that your scent of the
server this also resembles to their to
the small size one good example of those
tokens that are actually gaining
popularity as the jot token this is what
it looks like it's basically a base64
encoded a piece of information and if
you're looking very closely at it you
will see that there are actually two
dots inside that separate the three
parts of the jug token and this
resembles to the header the payload and
the signature of this header so actually
the header just says which algorithm is
used and that it is a job token the
payload includes all the data that you
want to include into the token this is
the subject I'm actually identifying the
idea the kind of user ID if you're using
it for users but it could be basically
everything that is that is valid
identifier then you have a name of
whatever you want to put in there there
are some reserved claims that are
defined by the specification like an
issuer or the audience or an expiration
date to make a short lift and finally
you have the signature that actually
includes a cryptographic signature of
the header and the payload to make sure
that the token has not been tampered
with and all these parts are then
encoded with base64 and put into
separated by dots and then used as a
string that can be passed around and as
you saw the job token is rather small so
you could include it in an HTTP header
for example and it wouldn't be much
larger than your usual session ID so if
you're using those tokens then the next
step would be to actually present the
token to the application and say okay I
did the validation of my identity at the
authentication provider and received
token in return and then I would present
it to my application and the application
will then be able to check the token by
checking the signature and reading the
content
this is a basic architecture that you
can use without using any standard at
all if you don't want to you can be used
just as a as a blueprint and implement
it on your own but you could also use a
standard and that's actually what we are
recommending so for example Samer or
item open ID connect both of them define
a standard for those tokens define a
standard for the process to present the
token to the application and to obtain
it in the first place so the state of
the art a thing would be of no ID
Connect because it's lightweight and it
works well with the cloud infrastructure
that we are used to deploy our
applications to so of mighty connect
actually defines a standard protocol for
the process to obtain this token for
authentication and it defines how to
validate the earth the token so what
does the application have to do after it
received the token to check that it's
actually valid and it also defines a
token format for this what it does not
include is the actual login process and
the credentials that are used so there
any implementation is free to use
whatever there the security requirements
lead you to this could be as easy as a
username and password
include two-factor authentication that
could include smart cards whatever this
is not predefined by the specification
the specifications are just says how the
flow between the authentication service
and the application is of mighty connect
is actually based on off - so a standard
that builds up on another standard that
has already been quite popular and that
was used for the social logins like
Google and github and Facebook did but
now is a standard that can be used in
the enterprise as well and it uses jot
as the token format as we saw before so
and that those tokens are self-contained
and cryptographically secured of mighty
connect also offers multiple flows Syria
it supports a set up where you are
running a browser-based application and
have a central service that is running
server-side in a secure environment
but it also supports untrusted clients
like a mobile application that is
running on the user's smartphone or an
application that is running in the
user's browser and JavaScript they also
don't have control over the execution
environment and do not trust the
execution environment both scenarios are
covered by the all-mighty connected
specification in contrast to summer
which is rather you have development of
off summer has stalled in 2005 it's a
specification that is can be considered
finished this is in contrast to oak
mighty connect which still keeps
evolving but this also means that we
have the option to actually make it
support modern flows and integrate
modern requirements which is not the
case with some so if we have a look at
the flow then the typical scenario is
that you don't go to the authentication
provider and say okay I want to login
here are my credentials give me the
token but the user it usually goes to
the application first so it's ok I want
to use this feature on this application
so they access the application and if
the user is not authenticated then the
application will redirect the user to
the central authentication server and
the central authentication server will
then provide a login form usable login
with whatever credentials the
authentication provider requires and
will return a token in exchange and
redirect the user back to the
application so then leave the browser
can present the token to the application
and the application can validate the
token and make sure that the user is
actually who it claims to be yes yes
there can be and this is basically they
actually recommend a scenario for up my
ID connect the question was if there is
a connection between the application one
and the authentication provider and so
yes usually there is if you want to
obtain additional information but it can
also be used with just a token and you
will just validate the ID token if you
go on with this and want to add
additional applications then this is
rather easy because now we can just add
additional applications and when I
correct for example an application -
this could be an application that we
develop on our own could also be an
application of a third party and this is
where it actually pays off to have
something that is based on standards
because chances are rather good that
this standard is supported by those
third-party applications and the way it
works is just similar you present a
token to this application and this token
can either be the same token or it can
be a different open depending on what
you actually want to achieve with this
so if you want to do single sign-on you
can either use the same token here as I
just said you can store this token for
example in a cookie you could use html5
local storage
and presented to those applications this
usually makes sense a few our
applications are closely related if they
are operated by the same organization
and in the same security zone or you
could say I want to keep tokens private
to an application so that the token can
only be used for one application and
that the application cannot steal the
token and use it to authenticate or
impersonate to another application and
then you would issue a separate token to
each application this of course means
that the authentication server will have
to be contacted if the user switches
between application between applications
but the user will not notice this
because the user will just be redirected
again as long as he has an active
session with the authentication provider
so maybe it will just see a short
flickering on his screen because he gets
redirected but there will be no
interaction and the benefit of this is
of course that you have increased
security as the tokens are totally bound
to an application and are only valid for
this application if you are doing single
sign-on then you also want the opposite
of this basically single sign out so
this is a bit more complicated because
you actually need this communication now
that we've talked about before and the
authentication server now it has to
notify all those applications that are
taking part within this trust armÃ©e and
invalidate those tickets so the flow
would be that the user requests a logout
at one of the applications the
application would trigger a central
logout at the a player at the
authentication service and replicate the
authentication service what then notify
all those applications and invalidate
the tokens to tell them that the session
is no longer valid
this looks a bit easier here on this
slide as it actually is because usually
your application will run on multiple
nodes and this notification has just one
HTTP call so within this application
there notification must be propagated to
all the nodes of the application so that
everybody is informed what you do is
that you request the log out and notify
those registered applications the open
ID connect specification he uses tokens
here that are in compliance with the
security event token so again there of
my t-connectors building up on
established standards for this and the
security event token as just a
specification of a jot token that
contains information about security
relevant events if you don't want to do
this and don't want to have this
back-channel communication between the
authentication provider and the
applications and you could also use a
front channel logout there's even a bit
newer in the open ID Connect
specification and the back channel
logout and it works for environments
that are fully built for the for the web
and do not use any applications because
it heavily relies on the on the browser
and actually it means that you are going
to destroy all the cookies and HTML the
local storage information in the browser
so that you don't invalidate the tickets
at the back ends but invalidate or
remove the tickets from the front end
and you can also use this if you are in
a web-based world to monitor the session
validity via an iframe that means that
you are constantly polling the
authentication the service should
actually check whether you are still
active or not
the whole scenario also works quite well
for using microservices so um if you are
if you've built your application as a
set of micro services instead of a
monolithic application then you can use
the same tokens that you obtained for
for for login and that have been
presented by the browser and pass them
on internally between your micro
services um this is a nice thing because
now you are able to not only pass on a
username or whatever you would have
would have done in the past to provide
some kind of global traceability that
you can include everything that is part
of the authentication token so this can
include roles of the user it can include
the the signature and you just use the
token and pass it on for the transport
you can use HTTP to communicate within
your micro service architecture and you
would use an HTTP header to propagate
the token or you can use messaging as
synchronous communication you know could
make it part of the payload either or
put it into the header of a message
usually if you are going with this
approach then you would have different
tokens per application and would use the
same token within this application so
you afford for this scenario you would
have two tokens one would be used by all
services of the application - and one
token would be used by the application
one without an ID connect and a central
authentication service you can also use
Federation so Federation is the idea
that you do not have multiple
applications or maybe you have but you
also have multiple user bases this could
be either internal to your organization
or it could be external user bases an
external user base in an enterprise
environment is usually kind of a partner
organization or a customer organization
that is large enough that you want to
integrate them with your system but it
could also be
the user base of say Google or Facebook
where you want to use a social login and
Google verified the identity of this
user then I will trust this and use it
for my applications too so you will have
an additional authentication server that
is operated by the other organization
and you will incorporate in your
authentication system so that your
applications do not notice whether it is
a user that is from your own user base
or from a third party that is trusted
Federation means integration of those
third-party user bases we saw those
examples of social login or enterprise
b2b enterprise b2b actually is quite a
common use case because we're from a lot
of customers that want to offer their
services to a larger customer of theirs
and they have an existing user base for
example a company who wants to sell
tickets for public transport and they
say our Kara if you want to integrate
you users then we integrate your user
base and offer them a portal where they
can order tickets for example and this
is a good use case for Federation based
on up mighty connect or samo
the Federation use case results through
a very good example where several - as
still in wide use because it's some used
by using an enterprise environment it's
available out of the box and Active
Directory and what an authentication
service support Federation based on
sam'l to whether they are themselves
sam'l - compliant servers or whether
they are almighty connect service you
can translate between them by using an
appropriate authentication service so
now we come to authorize a tional and
Thomas well show you how to integrate
this Thanks
okay now that we know who a user is on
what claims he has we still have the
challenge to authorize authorize the
actions he wants to do so usually this
is how the architecture would look like
you have the central authentication
provider having users authenticated
identified by the credentials and a user
has roads in each of your applications
you would do a mapping from the role to
the permission a user has and later on
you check what permissions are required
to perform some actions or to display
the UI so for example if you're not an
allowed to do administrative actions you
don't see any delete or edit buttons in
the UI this is all checked using the
permissions in the application this
worked well with microservices
as well you don't have one application
but many micro services they can each
check what permissions are derived from
a role and then check if the permissions
are in place for operation so the
question is what would I have in a
central place and what would I do
locally in an application or Michael
servers usually as you have seen we
would do the central authentication
because we all have all the benefits of
having this in one place it's one domain
supporting the complete system so you
don't want to distribute it and we
implement it everywhere everywhere you
will have the roles managed in some
central place and you then get the
consistent results across all your
systems and it's easier to manage as
well if you have to go through all
systems and create are the roles
manually there and was a developer that
doesn't work good but authorization has
to be done at the place an action is
performed because only that application
of
service knows what permissions are
really required to do that so wrong
mapping is something to do locally as
well and this promotes some kind of
loose coupling because otherwise each
service would have to to tell the
central place what permissions are they
have in place if a developer as a new UI
element which is related to a permission
this permission has to be managed
centrally that wouldn't scale and lead
to very tight coupling and really
strains you don't want that but the
management should be something you can
consider to do centrally so if we create
an API for each micro service which is
able to tell a central management system
which roles are there sorry which
permissions are there you can gather
them all you can push all central roles
to the micro services and you can make
some central UI where you can manage all
this so for example you have a new role
and then you can push that out to all
micro services from central management
application using an API and each micro
service then does the mapping from the
role to the permissions so what you need
in a cloud world as well is the
possibility to delegate authorization
this is important if you have some
external entities or partners where you
want to perform an action on behalf on
one of your local users and for this use
case which is usually found in b2b
environments you have some protocol to
delegate the authorization this is like
I said for software service offerings or
even an API as a service what you will
often find is off - to implement this
this is a standard protocol like we
heard earlier open my de Connect is
build this protocol
but the protocol death is really only
for authorization and this is what the
scope bosses so we have seen how to do
authentication and authorization in
general but what technologies are
available
how could you as a Java developer
benefit from this talk you can go on
with playing around with key cloak it's
an open-source offering that you can run
locally or for your enterprise it
provides authentication and as as a
software appliance the same goes for the
thing texture identity server it's built
in c-sharp and there are lot of rings as
well so you can run on premise this
central authentication server and yes
you don't have to write your own please
don't
or use tools and frameworks that support
that question you can't use it as a
service as well if you don't run all the
infrastructure for that in your company
you can use off zero you can use dome
path or on from Amazon the cognitive
this works as well so with all these
standards in place you really benefit
from the cloud and this domain as well
now you have to think about how can i
implement it in my application
there's java ee as a standard it's an
API standard yes but it's only
implemented by all the container windows
so you might consider doing another
thing what you can use which is really
working the standard way our client
certificates and this works across all
Java EE service being security of course
is very flexible and provide solutions
for or to and open Kuni up mighty
connect as well so this is what might
fit you and it's really well documented
there are other libraries as well which
you could use in your applications well
you should where you do some research
what
it's for your technology just stick most
of the authentication providers I talked
earlier about provides vendor specific
adapters so you can use some library
from them and integrate it really easy
in your application but then you get
some coupling between your application
and the provider of your authentication
service you might not want to do that
but on the other hand it can be really
easy and fast way to achieve it what you
can do as well especially if you're
thinking about IOT and machine to
machine communication is to think a
little bit outside of the box and use
client certificates this is an
interesting thing because it allows you
to offload authentication to the
infrastructure it's all well known and
understood and you can really easily
integrate that into your environment
this can be used as a substitution for
token based solutions as well but on the
island you can complement it to model a
trust relationship like we saw earlier
you usually have some application which
consists of some micro services which
don't really need to be on the same
network or a trusted environment you can
use kinds of certificates to express its
trust relationship if you run some stuff
outside of your organization and it
really fits for machine to machine
communication so if you have some IOT
stuff sensors or you might want to use
some kind of mutual authentication on
the infrastructure level to make sure
that all the sensors data is coming from
the right system and to the right system
and nowhere else what's nice about this
it doesn't have a central component so
it's between each client and server arm
as part of the infrastructure and you
don't need the authentication server
certificate rollout and management is
rather complex so you don't want to use
it for each user but more for
machine-to-machine users and what's
really sad about this is we don't have
some way to make Federation work with
this client certificates it's not like a
token you can't pass it around and have
the benefits we saw earlier so think
about it like an orthogonal layer on
this okay that's all we wanted to show
you we assume there are many questions
so it just come out yes
okay the question was it if you have
from a small IOT device and the users
authenticating to this device and the
token is short-lived how can you manage
it to work over several years that
correct great so there are several kinds
of tokens usually you have an access
token which is short-lived
and which is used to delegate access and
this is send and passed around between
all the transitive services you have a
different kind of token it's called and
refresh token or even an offline token
which has a very very much longer life
span and this token is only used between
the authentication server and the client
which is getting the token so this is
not passed around and can be considered
to be secure so this token works like
user credentials it's very long-lived
and you can use this token to get new
access token whenever you need so this
is something for the cloud as well if
you have some external service which
should be able to act on behalf of the
user even if the user is not online you
can get an access to a sorry and offline
token from the authentication provider
and use that for an indefinite playing
long lifespan does it answer the
question right yes
any more questions thank you
yes time left sir
okay um it was hard to understand here
so the question was if I have many
microservices would I have one token for
all these services or would I have
different tokens for all the services
and if so where would I store that is
that correct so they all have to sing so
if you have a trust domain where all
your micro services are living in then
you would have one two inside this
domain and use this one to you wouldn't
use a different tone for each micro
services service even if it's in the
same domain if you have some separate
applications or trust domains and you
would use different tokens for these
both domains you you wouldn't share a
micro service in different trust amounts
you would deploy this service in
multiple domains as a separate instance
yeah welcome more questions we have five
minutes left okay then thank you thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>