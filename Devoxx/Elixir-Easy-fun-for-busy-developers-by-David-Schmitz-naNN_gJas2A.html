<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Elixir - Easy fun for busy developers by David Schmitz | Coder Coacher - Coaching Coders</title><meta content="Elixir - Easy fun for busy developers by David Schmitz - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Elixir - Easy fun for busy developers by David Schmitz</b></h2><h5 class="post__date">2016-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/naNN_gJas2A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay great
licks here what a crowd you don't like
job anymore I guess okay so before we
start one question who has used elixir
before awesome great is it installed on
your Mac is it installed new Mac damn
okay good
so elixir first Java guys that's me I'm
David I'm from Dusseldorf and you can
see my amazing fighting skills I assume
I'm a better programmer than fighter I
work for a consultancy in Germany for
the Nicoya where we do basically
projects for banking industry insurance
moon rockets stuff like that what's in
it for you I only have got three goals
and that is first of all I want to whet
your appetite for Alex here I love a
league here it's the best thing since
the sandwiches at lunch sorry it's even
better then I will show you some of its
amazing features which I think are
pretty unique to to elixir and last but
not least I will try to do some live
coding actually I hate live coding it
never works it always fails but let's
hope hope dies last who thinks there's
something to be learned here that will
actually use anybody wrong so why should
you listen ever notice the fact I tend
to learn new languages all the time I
like learning new languages Kotlin
elixir or closure whatever because it's
like learning new languages natural
languages like learning Spanish if you
learn things from another company for
another
community for another culture it just
opens your eyes if you know you're
Chinese
I hope it's Chinese that's like they
compare to a window where you can look
out into new communities get new ideas
see how other people deal with problems
that said buyers beware I am the Jon
Snow of that topic you know what that
means
you know Game of Thrones here no nobody
Jon Snow knows nothing and I'm Jon Snow
just without the apps so elixir is nice
and awesome and erlang OTP is great but
the topic is so huge and I've just
started a year ago developing on that
platform so I guess I know more about
Java than elixir so be nice to me that
said this won't be a readme so there
won't be any slide where I tell you all
the functions are defined like that at
least like that
no we jump headfirst into code and I
think we'll understand
who knows that acronym yapple yeah
exactly we play this game with
JavaScript developers where we go to bed
and we get out of by the next day and
three or four frameworks come into life
and a couple of others had already died
the same is I think with programming
itself this is the Cambrian explosion of
programming languages cotton enclosure
Frigg whatever and so why should you
even bother with elixir elixir is
basically the combination of those three
what's the first symbol are there Ruby
developers here yeah you are a happy man
so are you the second is obvious is
Erlang OTP and the third one is
yeah so why is this a good thing why is
it a good thing to combine those three
so I will start with Ruby this is
basically the architectural layout of
Ruby Ruby is pure joy being a ruby
developers like watching all episodes of
Bob Ross painting his pictures it's pure
joy mattes the design of Ruby he had
just the impression of programmer
happiness that means the program should
help you and not the other way around
if you think of Scala and I like Scala
but if you accidentally write something
in the wrong way
Scala punished you you are stripped of
your clothes and you get to whip Ruby on
the other hand it tells you oh you type
this maybe you meant something other and
that's the power of Ruby Ruby was
successful in spite of his terrible
performance and that's who knows him
who's old enough yeah yeah great 80s go
that's he-man the most powerful man in
the universe he is incredibly powerful
and that's Erlang who has ever heard of
Erlang OTP okay great so everybody knows
what it is
it was developed around 86 by Ericsson
because they had some some issues
programming their switches because
switches for telecom you can't just turn
them off because there are many many
many many phone calls going over that
switch so you can't just turn it off and
update the software how to do that at
real time how to keep system stable
Erlang OTP solves those problems 95 with
the OTP open telecom platform although
today it's just called OTP because it's
not restricted to telecom everything we
want to achieve by going into micro
services by going distributed he-man he
has solved our problems he knows how to
do this and last but not least
this is the Church of closure rich
Hickey is always right yes exactly why
do I think that because closure is one
of the best design languages I've ever
seen one can easily see that the
JavaScript guys stay at ten days or
something around that and he designed
the language I think in a year or two so
really slow well-thought-out and the
elixir combines features of all those
three platforms and many more
so if ruby is so awesome and the elixir
and Erlang is so immensely powerful with
all these muscles and closures so well
thought out the most intelligent
language ever why elixir well ruby
scales but badly if you try to scale
ruby this will be a terrible time for
you and everybody who has ever done some
some rails development can easily agree
I think Erlang who if you've ever seen a
line code Erlang code if you've
developed in Ruby on Java even then
Erlang code is punishment the way it's
really the way Erlang does handle its
lists it's basically prologue only worse
so it's no fun to work with that tooling
to work in that language and closure why
should you use closure no reason if you
don't use elixir get out by a closure
book get going Joe Armstrong that's the
creator of Erlang he tried out merlin
version of elixir for a week or so and i
won't read it because you can read
yourself he's impressed so if the
creator of a language if brian guards
would post on twitter scala well that is
really good that would be a statement
haven't seen that yet
joanne strong on the other hand he think
this is he thinks this is good so why is
it accessor awesome
it's programmer focused everything and
elixir is about you it's error messages
human-readable it's not like that forgot
a semicolon no you would see in the demo
when we're waiting to egg hate that so
it's all about you they even go so far
that use evil in the Creator said if you
find a section in the documentation that
you do not understand then this is a bug
just tell that to a Java guys if I look
at a completely future and read the
Javadoc next I am crazy
basically so second of all it combines
the power of LTP you will see that later
you have no idea what you can do with
base Erlang and the alexia makes using
that really easy by using ruby features
it's a functional language so right on
to the hype but in a pragmatic way that
means at least from my perspective to do
functional programming sometimes it
feels a little bit over the top and and
bothersome not so with the licks here
everything is immutable you can't change
anything but you can rebind variables as
you will see later and that's a really
good thing once your program and the
elixir comes with a standard toolset
so once you install Eric's here you
don't run around and ask yourself maven
Gradle rake SBT what I'm going to do no
build two included package manager
included test framework included
everything is included obviously you can
do your own thing but the the stepping
stone to get started in the tools that
is really low so productivity right from
the beginning without frustration so for
me Alexia's jean-claude van damme and
it's all days not now although he is
still fit actually all the muscle all
the power but the flexibility that we
need and the great hair I have to say so
who knows what Erlang OTP actually does
only one
who's using on its film 3G anybody yeah
you're probably using Erlang learning is
still driving around about half of the
world's texting phone calls everything
and on the other hand if you say our old
infrastructure okay think about whatsapp
have you ever seen whatsapp as a service
not available I think there was only one
instance back then when they merged with
Facebook because they did some nasty
things to the tooling other than that if
you look at whatsapp always there if you
look at RabbitMQ always there darling
Erlang OTP is the language and the
virtual machine
Merlin does not run natively just like
Java as compared to JVM erling is
compiled to the so called bean that's
the Ericsson virtual machine highly
optimized for distributed computing
highly optimized for tiny processes
second of all we have those tools there
are tools like for example if you
develop micro services in Java the first
thing that comes to mind is how the heck
am I going to monitor those things how
can I look into my system Erlang OTT has
those tools right from the start
obviously there are tons of libraries
for for crypto for everything and last
but not least what's most important to
me is the set of patterns is there a set
of patterns actually in the core of Java
yet I think there's one is this ad
singleton annotation now AJ year anybody
uses that no no burning OTP with its
patterns defines patterns for
supervision for distribution for
messaging and if you approach an elixir
on Erlang developer and you tell them
well my messaging subsystem stopped
working he knows what you mean so
there's no fussing around or do you use
the supervisor implementation from that
framework or that framework it's all in
the language and Alexia takes all this
fun and games and bakes nice
big cake so easy to eat for everybody
so what succumb youth case I thought
about programming Fibonacci numbers but
then I thought that works the only issue
I have for DevOps is the food so I'm
always hungry so in this case we want to
go to a pizza parlor and the idea is I
just called a pizza parlor say here's my
money give me salami pizza and presto
we'll get the salami so I will try to do
this actually can you read this
yeah I guess so well okay the first
thing is creating new project and that's
really easy it's just this mix and I
will provide this soup because reasons
so I say mix new and we'll call this
thing pizza demo okay and as you can see
the directories get created nothing
fancy
everything that using an archetype and
then maven would also do fast but the
tiny bit basically the sugar is this
section it tells you directly
dear developer the next step should be
going to this thing run your tests and
this is what we're going to do babe a
great
so I don't know I think sublime cannot
actually scale those things oh it's
reading I think here you can see the
directory structure that is created as a
standard directory structure and there's
this config folder the library folder
the test folder and guess what the tests
go into the test folder crazy the
configuration into the config folder and
everything else goes into the library so
let's just create our pizza thingy how
would we call this let's say pizza yes
so everything has to be in a module and
it licks it it's just the fact nothing
can live outside of a module and what's
the first thing you need from a from a
pizza service it's the menu otherwise
you don't know what what you can order
so we create a menu and this is just the
syntax for creating a hashmap because
right now we are lazy map is our good
friend as you all know and we just
create a map where we say we have pizza
tunnel for example and what's the price
of it's a tunnel 10 euro 50 and salami
let's say it's cheaper that's all we can
go to the console and we can test this
directly not mix who knows what a
reptile is you're looking forward to
Java 9 here the rest of the development
world already has that elixir also so we
are now on the repple and we can do
everything here so I can create compile
arrows I can ask her to inspect certain
data types I can ask for help I can for
example if I don't know oh I nearly
forgot we have to please the demo gods
sorry
whoo great so that's all the way needed
that so we can do everything we want
basically in the repla and it's the best
way actually to get started and learn
the language okay
so we know we have created this Pizza
service with the menu who's amazed yeah
really good so what we can do is we can
store it obviously let's say we have
this thing and now a contains that I can
also do something like this that's not
so functional is it there was this a and
I can even do this boom strange but what
I also can do is same thing because that
is pattern matching if you know pattern
matching or structure decomposition from
other languages it makes you text this a
little bit further
everything is pattern matched there's no
assignment it's not just rebinding so in
this case and then this IX number 14
I tell Alexia try to check if you can
somehow match a to the string FFF and a
is FFF so no problem though if I said
that works well can't match that because
a doesn't match that this is something
you have to get your head around okay so
back to the code now we have our menu
and we want to order a pizza and we want
to order by name okay so the easy thing
to do is and I will do the easy thing
because I'm really lazy we just get the
map and we take out whatever start under
the name
and this can be for example now if you
do not find anything in that case we
would just return error let's say no
such pizza I think that's understandable
that's a common idiom basically in
Erlang and the elixir you always return
tuples where the first element either
error or okay that indicates everything
went wrong
and why that is the case I will show you
in a second and if we find something
this will be the price I guess so we can
say okey-dokey and once again we return
a hash map where we say the prices price
and we give a nice message and joy clear
I guess so let's try this out and I
don't have to restart I just recompile
it class everything that is this module
everything is there so once again pizza
service menu nice pizza service order
pizza awesome if I say salami nice and
if I say at worst we don't find that and
if you think of the pattern match that I
showed you in a few minutes ago how you
would do how we use this is by Pat
imagine you would say ok and we expect a
price and whatever
word and now that's the way you deal
with with pattern matching in index here
you say on the on the left hand side
this is the structure I expect and if it
doesn't match it fails think about how
error handling works in that case let's
say we have that pizza and that's the
idea you I will show you later we do not
code fault bags where we deal with arrow
and okay if we don't find the pizza and
we fail that's the basic idea so that's
basically our code at this point nothing
fancy so I told you about Erlang and we
didn't use any Erlang so far okay we use
darling because along is underneath but
we didn't use any any specific features
there's this this article where some
guys claim that they build a system with
nine nines availability who of you have
ever developed a system with six nines
of five six nines whoa kudos nine nice
is i don't believe the story they told
it but i don't believe it but we can do
this actually but in this case we have
to think about resilience and
reliability because of course their
system was not fault free for all this
time it failed but it was available
maybe a subsystem crashed but it got
recovered so what are the pillars first
of all we have to isolate and I think
think microservices and then everything
would follow the fall in place we have
isolated processes isolated means shared
nothing and they just communicate by
message passing the second pillar is if
we have so many processes running a
and I as an ops guy I cannot recover
them manually so there must be some
means of automatic fallback of automatic
monitoring of automatic recovery in case
of failure and last but not least the
programming model for me to be
productive must not be eg be to point
one remote interfaces because those suck
the programming model should be
independent of distribution obviously as
a developer you must be wealth
distribution because of latency and
stuff but the programming model should
not be and it needs he has two power
tools I want to show first of all the
gen server and second of all the
supervisor the problem with the way we
as a community code our services is that
we stuff everything into one heavy
process even if we say we use something
like like nettie where we can reuse the
threat it's running on in an intelligent
way nevertheless we have one giant
process with many different kinds of
computations and maybe even some shared
States somewhere lying around and the
bad thing is when something fails
everything fails and then you get called
at 9 o'clock in the evening on a Friday
night and you have to debug your code
which everybody likes Erlang OTP has
been optimized for tiny processes I have
a raspberry the old one at her house at
my house and I am easily able to run ten
thousand processes Erlang processes on
that machine without it stuttering in
the least the basic abstraction is the
generic server that's gen server I think
they ran out of letters and each process
each gen server consists of its own
mailbox its own computation its own
state completely shared nothing and the
idea is that the outside world just
sends a message to the process
asynchronously so basically if I want to
order a pizza I sent you my order and
that order up
she gets consumed synchronously that
means the message arrives gets stored on
a queue and you all know message queue I
guess today
it gets handled and then maybe we send a
reply that's the idea inside the code we
would write it like this we loop Erlang
called our mess or process with the
function loop with the current state
then our process waits for the next
incoming message handles it and maybe
sends a reply I would always send a
reply because courtesy but you must not
you need not and last of all it loops
again with the new state this is quite
good
it's the last statement that means we
are tail-recursive and that means what
any idea give exactly no stack so
there's no no real recursion going on
it's just basically a go-to statement
and go-to statements are awesome as you
all know so we move from heavyweight
processes to a world of tiny processes
and this does not add any overhead so
what we are going to do is we are moving
a animation we are moving our message
driven pizza parlor to something that
can send an order for a pizza and it
gets basically handled by the pizza
service and the reply is sent to the
consumer so let's see how we would do
this in Erlang and licks here there's
actually not much with what we have to
do we just say use gen server and then
we implement a couple of callbacks the
first callback you would usually
implement this this start link where we
actually start our process and startling
needs the module the state
and you can also provide a name that's
what I'm going to do let's call it
devoxx now let's call it pizza sauce
let's use the real example if we try
this out in a repla once again we
recompile this Pizza service and I say
Pizza service you can see it something
as has actually been done and I can look
at this I can say this is the monitoring
tool that comes with with Erlang and if
I look at you can see all the
applications that are running you can
see our Pizza demo here and there should
be a pizza service process somewhere
there that has been grated already for
us we can't do anything if I say Ghent
server for example call Pizza service
and we send it a message like paying
then exactly Peng will happen because we
can't handle that message so let's
handle that message handle call is to
call back handle call is have to
concentrate live coding sucks whenever a
message is received one of your handle
call implementation gets called and
there can be many in this gen server and
once again this is where pattern
matching comes into place let's see how
we send a message that's let's say we
send a pizza order we would say gen
server call with the message pizza and a
pizza name then this is exactly the
message that will be handled by our call
so we copy this here and now we have the
pizza name because it gets paid homage
by elixir okay and we need to reply
somehow
and we say reply message for example
awesome and we don't care about the
state right now we can try this out
directly
once again we recompile the pizza
service and we say pizza so you have to
start it again because it was killed and
now can sip it's a service awesome
there's much going on behind the scenes
and you can see this by actually tracing
the messages so elixir will tell you
that there was a message pizza tunnel
sent from one process to the other and
the other process replied with awesome
but that's not what we wanted to do we
wanted to order a pizza and we have this
other pizza down below and the usual
idea would be to say order pizza pizza
name something like this but that's also
not the way Alexia things elixir things
about transformations as we don't change
things we only transform things and
that's why they actually build this tiny
little pipe operator that's just
basically syntactic sugar what I typed
before was exactly the same but if you
think if you have multi methods like a
and B and C and D and instead of that
you write D C alphabet not my strength
if you write it like this then this
tells the story you can read it from top
to bottom you say a gets transformed
wire C gets transformed by a B gets
transformed by a so that's the basic
idea
so we order a pizza and we have a
response in that case and we can send
back just that
I recompile this send was the name I
forgot see exactly what what what
expected and if I say salami and what
was blood sauerkraut
I'm a drum there must be some sauerkraut
in here and that's all you have to do
basically nothing else bam tiny process
and if you want it you can can start
thousands of these of this this tiny
process on your single machine without
any low that you would expect brazilians
is that resilient no it is not because
our process is running and if I say for
example gen server or good friend to
Peng message it's dead it died and you
get called nine o'clock Friday evening
you can say where where is my pizza
service and the next item is gone so
obviously what we need to do we need to
go back into our code so there's this
ping message yes so we say def and the
car paying no that's not a reason that's
not good we won't do that
that's definitely the wrong way because
the paradigm of of elixir is have you
tried turning it off and on again who
watches IT Crowd so you know that you
might hurt a further the more serious
expression let it crash the idea is
really simple what happens when when for
example this monitor goes haywire and
runs amok and the colors broken I turn
it off and I turn it on if your window
shields your automatic window shields in
your in your car doesn't work you turn
the car off and you turn it back on
simple pattern
and it works if the error is transient
and you turn the thing off and on again
chances are that the error would go away
if it's a persistent error it means you
didn't test your code there are some
maybe the databases and flames who knows
then they are only persist obviously but
in general case if there's a transient
error letting it crash is totally fine
which is a great excuse to go home early
so what is the case now for us the pizza
parlor goes boom and our nice customer
is really sad and we have only to rely
on that Vox lunch and like at work in
order to keep us developers happy we
need some supervision we need a manager
watches us yeah
is there any supervisor here the team
leads somebody hmm okay so you know you
can only rely on your workers by
watching them who hard so we know down
there might be dragons down there there
might be something broken the high-risk
operation the oven for the pizza may go
up in flames so the idea is we insert a
supervisor and the idea is really easy
it's like a parent-child the supervisor
watches its children so it looks at its
sub processes in this case the pizza
parlor the oven and if that thing
explodes it just creates a new one we
are going to add it so easy that's the
way we should think about processes if
you think that a docker container that's
the way docker containers behavior if a
docker container failed you remove it of
course in extensions and Erlang had this
for 30 years so now I will show you the
extraordinary process for inserting this
into elixir we only got 25 minutes
whoo let's see if that's so we have our
chance over here so the first thing I
have to do is I have to insert the
logger so that you can actually see
anything
running so that when we start this thing
we can actually see something so and
then know the real world comes if you go
into the application you will see this
little section where the children are
defined for this supervisor and all we
have to do for this to work is we say
worker pizza service no state that's all
and if I go back you can see directly
the message EP up and running yeah saw
that and if I now say Gen server called
pizza service and you see that sometimes
I forget the parentheses doesn't matter
vaguely so I say because I was calling
Peng hmm no it's expected because it was
restarted faster than the error message
was actually locked yeah it's correct
and that's all it's not nothing more
that's the basic idea you just create
trees of supervision where you put the
risk to the bottom of the tree if you
have some business logic that doesn't
rely on external state and on files or
stuff like that no problem there but you
have stuff like reading a database
reading some external data store on the
routing s AP whatever there is in your
back yard then that's the point where
you push down the risk
write down and supervisors can supervise
other supervisors so that you have a
cascading escalation route like in your
enterprise if something goes wrong the
manager reports back to the next manager
and up the chain until the problems are
discussed the way
but this is just tiny tiny bit I would
love to do a workshop now with you for
four eight hours and share my love with
for aleksel you for example who thinks
that the way we do polymorphism in Java
is really well designed I hope nobody I
think he wanted to raise a sense if you
think that closure of closure closure
has this amazing idea of protocol is not
simply closure other languages have to
have this too but the idea is that you
can actually introduce after the fact
polymorphism in this example I define
the behavior string characters that's a
two string method just think how you
would do this for a final class in Java
you have a final class in hibernate and
you want to add a two string method in
general you would use reflection or you
would create a decorator class something
like this in elixir you can easily
extend existing classes by using
protocols then this macro system and you
list fans here okay great
Lisp is awesome there's a sentence does
that every system that gets complicated
either migrates to what Lisp or uses
Lisp so and one of the reason why list
and then closure so awesome is because
of their macro systems and if you think
of for example JavaScript JavaScript has
this somewhat - but not in a real sense
this is not code Eva this is compiled
time mark cross this is not your C++
macros what I'm doing here I'm defining
a new keyword unless and wherever I use
this macro unless this thing gets
inserted and it would argue that
although also this is a macro this is
nevertheless readable it's really
completely understandable what gets
unquoted and what gets quoted and the
meaning behind that should be obvious
even if you're just Java developers not
Alexio develop
and you have to think about that most of
Alexia has been developed using elixirs
macrosystem so that's eating your own
dog food for you here and you have this
thing just think about online games just
think about you have a first-person
shooter where each round of care or
shooting takes ten minutes how do you
upgrade such a machine now of course I
know how we upgrade this we put a public
notice on our webpage and dear friends
we will be down between 0 o'clock and 2
o'clock in the morning come back
afterwards with the elixir and erlang
you can do this zero downtime hot coat
replacement that means that you release
a new version of your application and
this callback gets called in your
process so there's this version flag and
you can migrate the state of your
process to the new version or migrate
down that's up to you you can go up you
can go down as you want actually there's
a great talk of some us guys who
maintained a poker platform and when you
play poker this is not predictably over
so this the wrong can take about 20
minutes 50 minutes up like this and they
use that to upgrade their platform
continuously without any downtime and
then there's acto and phoenix phoenix is
started as a web framework think of
rails just cool and maintainable and an
awesome experience and acto is something
like a dsl for for fetching data from a
sequel you can see an example here from
cue and korean alana this is not an
object relational mapper don't take me
wrong this is basically a DSL for for
sequel and the cool thing is that once
again you can pipe this using the pipe
operator you can say video video is also
a query because it's a database module I
pipe it tune into a video alphabetical
and then I say repo fetch everything
there's easy and composable phoenix on
the other hand
it's amazing you have to try it out to
see actually what it does it's started
as a web framework with server-side HTML
generation which is really hip these
days days I think but now they've
introduced a channel abstraction a
channel is an abstraction on top of
WebSockets and you to the fact that
Alexia has this low-level low resource
intensive process abstraction you can
fire up hundreds of thousands of these
tiny processes and if you think and
direction of mqtt over WebSockets it's
obvious this phoenix might become the
tool for delivering IOT applications I
hope that was enough but the buzzwords
in one section IOT MQTT real-time now
really Phoenix awesome platform orson
our and yuna forgot who knows what CR
DTS are conflict-free replicated data
types
this is bleeding edge computer science I
think not so bleeding edge but the Java
blue is still looking for Java
implementation no CR DT is something
that will become mainstream I guess in
the next couple of months or years and
it has been used I think and rabbit
rabbit uses it internally I think and
Phoenix the next version will use this
for their present subsystem just think
about the question how you deal with you
have a cluster and you have multi
devices and Apple iWatch a phone and
your computer and you log into the
system do you want multiple logins do
you want a single login actually want
multiple logins but you want a single
presence and that's the abstraction that
they are building around it this is
really really well done I can't explain
it right now because we only had 60
minutes left check it out read into it
because this is stuff that will come -
to our community in the next couple of
years I guess so should we all build
everything with Alexia I do know I'm a
Java guy so I have to use Java on my job
but if there's non mission-critical
parts of our system like infrastructure
like reporting like convenience tools
now I built a magnetics here and we
should lick see all the things that's
the message just go to your work next
next next week and say David told me to
delete all our Java code and we install
the exchange there we go
and you will lose your job so maybe not
oops sorry I think that it leaks
nevertheless offers much you have to go
into the language the language you don't
need books to learn the language
language teaches it to yourself you just
start working and you discover thing one
thing after another it's not like you
have to learn classes type and furans
collection framework and whatever to get
a simple example running it's just
straight out do your thing and of course
this wouldn't be a conference talk
without mentioning cloud and micro
services the micro service problem is
not there in Alexia it doesn't exist
there's no discussion around let's build
micro service because the way things are
delivered by our processes and by our
supervision trees and stuff like this
that's basically the technical challenge
of micro services not our organizational
how do I vertical eyes my team but the
technical challenges are just not there
since 1995 and you can deliver actually
your clear applications to the cloud
our last innovation day in Germany where
we go into an office for 24 hours we
just code away I built a slack pot using
Neelix here and could deploy without any
fuss on Heroku which was awesome I had
expected many many problems because
Heroku out of the box does not support a
lecture but there's the plugin available
so you can push it into the ground I
think Amazon AWS supports it Erlang
deploys too so I think if you go into a
lecture use it even use Erlang read
learn and see what Erlang does you get
new insights even if you do not use it
on your
even if you will never code one single
on helix here there are many patterns
many solutions to problems that we as a
Java community are rediscovering and
this makes me crazy there are all those
those older colleagues 50 or 60 they
have we've done that in the past and
it's true most of the problems we now
face ok on a greater and greater scale
more data on stuff vectors but
nevertheless they have been solved they
are clean patterns which makes things
easier you talk about supervision trees
you talk about distribution you talk
about messaging and they are all part of
the core of elixir so there's now no
confusion whether or not you should do
things as I said I think and I'm not I
cannot actually prove this but I think
this would be Phoenix maybe one key to
develop application for IOT with its
WebSocket abstraction and the
surrounding tooling and what's most
important to me is the community this
elixir it's like like ok if I would
deliver gram net Excel hold air would be
happy to and they're a bunch of happy
people
Josey volume the main creators as if we
was on vacation the whole year it's like
that and you can ask them questions at
any time and you will respond at any
time the same goes for for the Phoenix
community for everybody that is actually
active in elixir so there's no no
boundary there if you want to know more
I would actually just say go to the
homepage read the tutorial start
developing it's completely sufficient if
I had to actually recommend two books
I'd recommend programming elixir it's
dated it's not the most actual version
of elixir but first of all Dave Thomas
writes awesome books and second of all
there are a couple of exercises so you
couldn't get started with them you can
get started with thinking and elixir and
this other book this Erlang and anger is
an airline book it's not an elixir book
but it's about delivering highly
distributed systems to production
letting them run for years and years and
years upgrading them in real time
upgrading them while the system is
even as a Java developer there's much to
be learned in that book so that's all
from my side questions no questions this
is good dot one question the question
was if there is any interoperability
between Java and then the leaks here and
actually one week ago I would have said
not that I am aware of but surprisingly
there's there's a project that it takes
care of that I don't know if it's
production ready so you if you come to
me I can show you the name of that
project where you can actually call Java
from elixir and vice versa but that said
would I do that
I'm not sure it can be done otherwise
maybe it's more sensible to move to
messaging maybe plug a rabbitmq in
between or something like this yeah
well the question was if there is
something that we're like sure this
stuff is not suited to actually that's a
good example with the sorting algorithm
where you have an algorithm where it's
expected to sort in place but what does
it mean to be sorted in place if you put
it down
and you have to use these ten elements
lying next to each other you say I swap
two elements for example and it's just
new list those things swapped so I don't
have to modify the original
collection you know what I mean so in
this immutability is no problem in that
case is there anything that can't be
development with elixir well I guess
it's a general-purpose language it's too
incomplete so you can develop everything
with it I guess
so I can't easily answer that question
it's easier to say for example if you if
you asked me if there is there anything
I wouldn't develop trails that would be
easier to say because with rails I have
much more experience than with with
Erlang and elixir so will tell you the
highly scalable maybe not with aroung
and elixir so farm half the world's
telecommunications running on this this
stuff so it would be hard to find
something at least in my work
environment that has higher requirements
than that okay no other questions then
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>