<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JRuby 9000 by Charles Nutter | Coder Coacher - Coaching Coders</title><meta content="JRuby 9000 by Charles Nutter - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JRuby 9000 by Charles Nutter</b></h2><h5 class="post__date">2015-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1t4iu7tefi4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well I'm sure we'll have some folks
filtering in as lunch finishes up and
they get through the lines downstairs
but we'll go ahead and get started get
into some of the intro stuff right now
I'm going to talk today about jruby 9000
which is the new and fast and awesome
version of JRuby that we've continued to
work on over the years a bit about me
Charles nutter I've worked on JRuby
obviously for a long time now nine years
working on it full time at various
companies and we're very thankful to
folks like sun microsystems rest in
peace and engine yard and now Red Hat
for for funding our work I also worked
on a language called Mira which is
basically a Ruby syntax for writing Java
code it's not really a ruby runtime but
uses some of the nice surface level
features of Ruby to make job a little
nicer and there's a whole suite of
projects called jnr the Java native
runtime makes it really easy to call
down to native code integrate with
native libraries if you need to do any
of that stuff it's worth checking out
I've also been involved in a lot of
OpenJDK level stuff was one of the folks
helping the invoke dynamic jsr get
through helping make sure it was
designed well for languages like JRuby
and for future use project Panama one of
the new one of the new possibilities for
Java 10 is going to be native calls
built into the JVM so where we have
something like a pea invoke on.net we
have fi and Ruby you'll be able to do
something very similar on future
versions of Java to call down into any
native library without writing J&amp;amp;I or C
code and most recently starting to get
involved in project Valhalla which is
about value types and generic
specialization really cool stuff that'll
come along and hopefully Java 10 or so
so a quick note on 9000 where did that
come from well so when we decided to
start working on the next major version
of JRuby after Jerry 1.7 we had a
problem we had an issue Ruby itself had
a version 1.8 1.92 point 0 so it'd be a
little bit confusing for us to go
directly into a 2.0 version or 1.8
confusing because we wouldn't really
know whether it's the JRuby version of
the ruby version so we kind of just
threw this at the wall as a code name
and said let's just take pic 9000 we'll
just go with JRuby 9000 as the name of
the project and over time it actually
kind of start
the steps to stick we actually had a
version number 9,000 Jerry before a
while lots of obvious dragon ball z
references came out of this and people
thought it was kind of fun fun goofy
version number but it ended up turning
out that it was actually going to be our
ninth major version of JRuby and so
ultimately JRuby 9000 became JRuby 9 and
that's what I'm gonna be talking about
here today so first of all JRuby from
9,000 feet will not like 10,000 feet
here it's Ruby on the JVM obviously the
current version JRuby nine point X
supports Ruby 2 point to point to which
is the current version of Ruby it's the
first time we've been completely caught
up on compatibility so everything out
there that runs on regular Ruby regular
see Ruby you should be pretty confident
is going to work on JRuby as well we do
so still support our 1.7 branch which
supports older versions like ruby 1.8
and 1.9 we have a fairly
business-friendly license in the Eclipse
public license if you want something
more copyleft like we do also have GPL
and lgpl and all of our contributors
have agreed to that but probably the
coolest thing about jruby as compared to
regular Ruby is that it really
integrates well with the Java platform
you can call java libraries you get the
benefit of java threads java GC but all
of the cool stuff that the Ruby
community has and I hope to show some of
that for you today so now first of all
there are some folks in here but Ruby is
kind of an unusual customer and a usual
guest to have at a Java conference Ruby
folks have their own conferences that
they go to so I think the job committees
kind of lost track of some of these off
platform languages like Ruby not really
sure that there's people actually use in
Ruby out there so I want to talk through
just a few little details dispel some
myths about where Ruby stands these days
the Ruby community is very strong right
now there's hundreds thousands of people
working out there on individual projects
probably tens of thousands hundreds of
thousands of contributors and users of
the language I think that this vibrant
community this big community it's behind
ruby is really as important as the
library and the libraries are this is
what keeps the community going this is
what makes it possible to have 36,000
subscribers on the Ruby talk mailing
list the main mailing list rubygems.org
which is kind of like our maven central
almost 7000 libraries and in the past
six years or so six billion more than 6
billion downloads of all those libraries
that's something like 24 downloads every
second for six years this is a big
community doing a lot of cool stuff and
working really hard on making Ruby
better and there's hundreds of
conferences the reason you don't see
Ruby people here very often is because
they've got their own events to go to
they got their own conferences even if
they're using jruby you're probably
going to see him at one of the hundreds
of Ruby events lots of books out there
are lots of user groups it's an entire
world unto itself and it has a very rich
set of users one of the metrics that
folks use out there to measure this is
something called the tob language index
this is you know perhaps a little bit
questionable metrics but they use things
like job postings search indexes how
much how much search volume there is for
a given language questions on stack
overflow repositories and github things
along those lines and provide sort of an
aggregate score for the different
languages and based on the most recent
one from just this past month ruby is
probably the ninth language as far as
those metrics are concerned it had
dipped a little bit over the past couple
years and other languages jumped up into
the top into the top 10 but now back
into the top 10 up at nine and the
little double up green thingies there
indicates that it's growing pretty
quickly compared to last year the other
language is on the JVM other than Java
don't really even register on this I
think Scala was that like 28th on the
list somewhere below logo and groovy was
down below languages like scratch which
is the kids language for doing education
so the other JVM languages are great and
I think we are all friends and you know
we're good buddies but Ruby is
definitely a big deal as far as
languages go another metric here
actually measuring job postings on
indeed.com they have this search tool
you can go and check for a number of job
postings at any given time over time
relative and in a growth and shrinking
it in the community and Ruby obviously
is much higher than than any of the
other JVM languages of course save for
java java puts us all into the ground
but even rails even though it hasn't
been in the headlines and isn't the new
hotness anymore still considerably more
people out there doing rails jobs and
rails work then all of the other JVM
languages combined the last one we'll
look at here is get hut it's not a typo
this is a site that basically uses
number of github repositories and github
activity to rate different languages
based on how active they are how many
projects are being done in those
languages and by their metric Ruby is in
about sixth place and actually if you
remove CSS as being a programming
language more like fifth place so in the
top five of programming languages for
all repositories on github and then of
course I have to poke fun at my JDM
language friends and their they're here
but they're down towards the bottom you
know Scala is actually doing fairly well
on most of these metrics compared to the
rest of the JVM languages it's kind of
interesting to see that MATLAB is more
more popular than groovy and so on
haskell people actually use Haskell I
guess so that's kind of cool uh now
getting a little bit more away from
poking fun at my other JVM language
friends some actual community
contributions that have grown out of the
Ruby community as anybody here using SAS
to do style sheets CSS there's a few
folks so sass is an external DSL a
little language that grew out of the
Ruby community it's basically a DSL for
doing CSS but having better features
better syntax easier managed code 44
actually generating it so on the left
here we have a little piece of SAS code
and on the right the CSS that it
generates and we have things that we
don't you normally get in CSS like
variables like having indentation be the
way we break up certain areas rather
than having open and close braces and so
on so a different take on doing CSS
that's now grown out of the Ruby
community and is is more generally used
a cucumber is another one anybody doing
cucumber testing ok there's a few folks
so cucumber again is another external
DSL that
grew up in the Ruby community it's story
based testing rather than writing a
piece of code that exercises some some
library or unit test or an integration
test you write stories about what you
expect your application to do and you
express it in a mostly natural language
here's an example from the cucumber site
so we've gotten a scenario and we're
going to call it eating given that there
are start number of cucumbers when I eat
a certain number of those cucumbers then
I should have a certain number of
cucumbers left and then a table of
possible examples to run through to make
sure that different scenarios behave the
way they're supposed to this grew out of
the r-spec community behavior driven
development stuff but with a desire for
something you could give QA engineers
user acceptance engineers a language
that they would be able to write rather
than writing code and this is an
executable test essentially that will
exercise your code and make sure it's
working properly the last little example
I wanted to talk about is a ski doctor
ask you doctor is basically a text
processing library that turns a ski doc
format into html5 into docbook into
several other formats it's written in
Ruby it's a ruby gem but you're able to
use it on the JVM and with java projects
due to the magic of JRuby you may never
even know that you're using JRuby under
the covers and there's a quick example
of what a ski doc looks like sort of a
similar to a markdown sort of format so
now these are these are all Ruby
projects but what about the JRuby
community what does that actually look
like now the JRuby community kind of
gets folded into the Ruby community when
we measure metrics when we look for
people using us just about everybody in
the Ruby community is doing something
with JRuby but last year for Ruby comp
we actually asked people let us know if
you've got a project that you're running
on JRuby send us a logo and the response
we got was way beyond what we expected
we thought we might get a couple dozen
logos and put them on a slide and be you
know able to show that there's some
folks using it but there's there's some
serious customers here BBC News for
example all of the election results that
they publish on the web are a Jay Ruby
based application so Scottish referendum
the recent elections that were there
all of that stuff going through JRuby
visa has a number of sites running on
JRuby as well iBM has projects they ship
as part of commercial packages in the US
the bank simple square that has easy
credit card accepting so many different
companies that are doing jruby even if
you're not developing with JRuby
yourself there's a very good chance that
you've probably used it indirectly at
some point and this is just a small
sampling this was a day's worth of
gathering to find these companies and
get a list of them all right so let's
get into some real technical
nitty-gritty hopefully you're interested
and you're excited about where Ruby's
going and where Jay Ruby's going we'll
talk about Ruby and give you a little
quick tour here so here we've got an
example we've got Java on the left side
and Ruby on the right I'm just going to
walk through what the differences are
obviously the syntax is not java it's a
little different but generally there's
only a few small changes that you need
to mentally do to convert Java into Ruby
code so first of all obviously this is a
class definition here and you see up at
the top one of the differences is that
for extending a class Ruby uses a less
than sign rather than the word extends
just a simple Ruby shortcut they're
pretty easy to get used to that sort of
thing now as far as constructors go on
Java aside we always have the
constructor named the same as the class
and this can also be somewhat limiting
it's hard to create factory methods that
have different ways of creating those
unless you build another class you've
got some static methods somewhere in
Ruby the Constructors always called
initialize and when you construct it
you're basically calling new on the
class so you can have new that just does
the normal initialize you can have your
own version of new there's a factory
method that creates other other related
structures to go with it everything
being kind of object-oriented here this
is calling a method on a class that just
happens to be called new new calls
initialize and we have our object of
course you'll notice that on the Java
side we have our type declarations that
disappear on the Ruby side ruby is
100-percent dynamically typed language
and in the Ruby world this is referred
to as duck typing so the idea with duck
typing is that all you really care about
is whether a target object can respond
to some method
you're not really concerned about its
concrete type or whether it's in a
particular class hierarchy so we've got
some object and we're calling swim on it
well if it's a duck and we call swim on
a duck that's fine it walks like a duck
and quacks like quacks like a duck it
swims like a duck it's no problem now
where it gets a little scary is what if
some other object gets in there so here
we're trying to make an anchor swim we
call swim on an anchor object and that's
where people tend to get a little scared
of the whole duck typing and dynamic
typing thing anchors can't swim at
runtime we're going to get a no method
error it's going to say we don't know
how to do this behavior now as scary as
this seems it's really not a whole lot
different than typecasting in Java
casting from one type to another which
you'll often run into bad objects that
will sneak in don't implement an
interface and will cause a runtime error
for you and in the vast majority of
cases testing we all write tests of
course and testing eliminates most of
these issues for so for real production
applications it almost never happens
that you actually get no method errors
in production no more than you would get
classcastexception or null pointer
exceptions in Java which we all have run
into constantly in production
applications so generally this is rarely
an issue for Ruby applications and it's
not something that should turn you off
of trying to play with Ruby instance
variables in jail in Ruby always have an
act sigil on the front of it rather than
doing this dot value or just accessing
the value directly all instance variable
accesses have an at actually a very nice
feature because you never are confused
whether you're working with a local
variable or you're working with an
instance variable in the class it's very
clear from the code and it's actually
shorter than the long version on the
Java side this dot ruby has a very rich
support for meta programming and one of
the simpler features there is being able
to define attribute methods so on the
Left we have to manually write out get
radius say that we want to return the
radius and we have to do this a hundred
times in all of our applications and all
of our POJO objects whereas on the right
in Ruby we just say that we want an
attribute with this name in this case
it's a read-only attribute so we want an
attribute attribute attribute reader for
rate
yes and it's done the rest is all
generated for us behind the scenes
another nice shortcut and Ruby the last
expression in any method is the return
value of the method you don't need to
explicitly return for simple methods
that have only one line just let the
value fall off and that becomes the
return value the you can actually return
explicitly if you want so do an early
return but a lot of Ruby code kind of
just does its computation and then lets
the last value fall out as the return of
course ruby has closures had closures
before most of the other JVM languages
were even around now we have these as
Java 8 lambdas thanks clink goodness and
it actually integrates pretty well with
it but you can see here we're grouping
letters by a postal code so passing in a
lambda or closure reiterating all of
those letters and and sorting them by
are grouping them by that postcode down
at the bottom is some of the Java
integration magic we've got a Java
button a swing button we do actions
performed and pass it a lambda Paz at a
closure and that will actually then be
the body of the action listener
implementation done magically behind the
scenes for you by JRuby on the right
some more complicated examples we've got
an implementation of my open for a file
it opens the file passes it back out to
the closure or the block and then make
sure it's closed so a lot of that
boilerplate code that we've had to add
Java features for like try with
resources and whatnot you could have
just implemented yourself if you're
using Ruby another nice little feature
of Ruby is mixing inheritance modules
are part of the language basically a bag
of methods that you can include into
hierarchies so in this case we've got my
tree implementation it's going to
include innumerable and the only thing
it needs to do to include innumerable
and have a bunch of enumerated features
like grouping and mapping and sorting
and selecting and whatnot is to
implement each just to provide one
method that shows how to walk all the
elements in this tree we mixed an
innumerable partial implementation there
on the right and we get all those for
free so you don't have to necessarily
extend from an innumerable class or from
a list class you can just mix in those
behaviors and they'll work as if they're
part of your class hierarchy from the
beginning I mentioned metaprogramming a
little bit here's a little bit more of
an advanced example we've got a hash of
three different colors red green and
blue values we're going to iterate over
each of these colors and then define a
method for each one do the magic of Ruby
we create these methods they have the
values in place and now we've actually
generated our code rather than writing
that code by hand and a lot of the Ruby
libraries out there make great use of
this especially for example rails and
we'll talk a little bit about rails
later too almost done with a quick tour
here ruby has an open type system an
open class system so classes can be
reopened and modified later on generally
this is done to mix in a new module to
add a method like a debug method in this
case or in very rare cases to patch a
method that isn't behaving properly in
someone's library what they call monkey
patching it's a discouraged thing but
it's nice that you're able to do this
you can actually take a class make your
modifications to it and spread it across
multiple files not have one giant file
every time you're working with it and
the last little piece here Ruby is an
object-oriented language everything is
an object so of course we have class is
a class as an object and can have class
methods similar to static methods but
even numbers are objects as well and we
can call 2's to turn the value 12 into a
base 16 hexadecimal string or we can
check whether 11 is odd or even these
methods all exist on these objects and
you can call them like they're just any
other object in the system all right so
how do we get started with JRuby for
folks on Windows we generally recommend
the windows installer we have it'll put
jruby in the right places for you set up
paths and environments and give you a
little JRuby shell you can start up with
nice interactive features so you can
play with the language on other
platforms you can certainly go back to
old school tar balls many of the Linux
and BSD s have
jruby packages as those packages off and
are there may be a little bit behind but
they're usually out there or you can
just unpack your own tar ball and put
the bin directory in your path and
you're ready to go it's a complete
distribution all set to go for you if
you get a bit more into the Ruby world
route most rubyists are fans of ruby
version switchers Ruby switching tools
the most popular is ruby version manager
rvm you can go to our VM do run a little
line of bosch code and then you get a
full set of environment commands that
let you switch between jruby see Ruby
and update and do versions all on your
own without the packaging system of
whatever platform you're on it's just
installed locally in your home directory
now of course in the Java world
everything needs to be in maven so we
have all of our packages in maven and we
actually have at the top there our tar
balls are also distributed as maven
artifacts so another place that you can
go and get them if you're living in more
of a maven world but various different
forms of JRuby the base JRuby jar itself
jruby with all the Ruby standard
libraries and so on so now a lot of
people ask why don't we just have a Jay
Ruby jar why isn't it just a jar that we
distribute well it Jim ruby is really
not just a language like Ruby itself
this is an entire platform there's many
tools that come along with it gem for
installing Ruby gems are our maven
packages essentially IRB for interactive
consoles rake for doing builds all of
this stuff is in the box with JRuby and
when you unpack it you get an entire J
Ruby environment that you can run with
so having just a jar doesn't allow us to
ship the tools as nicely and certainly
doesn't allow us to support Ruby's
command line features nice interactivity
and so on I mentioned earlier that Jerry
is really good integration with Java
that should probably go without saying
since we're on the JVM but it really is
simple and clean to take Ruby code and
wrap up a Java library and call it and
script it a very simple code very clean
and actually a lot more fun than writing
it in Java usually if I want to play
with a new library I will load it up
into a ruby script or into the
interactive ruby she'll play with it
there for a while and get to know the
library inter
tively a quick example of this with
swing so we've got our imports at the
top or importing some classes from Java
jframe and J option pain we're going to
construct a frame and notice it's framed
jframe you just like a standard Ruby
constructor call jframe new you can also
use the full long package form just like
you can in Java so we created jbutton as
well and then we'll use that closure
form with add action listener to give
some behavior to the button it's going
to pop up a message dialog with some
HTML content in it the EOS here is
what's called a here doc a multi-line
string ruby has an support for a number
of different multi-line strings again
something that we've wanted to have in
Java but hasn't quite come along yet and
then we're going to basically append the
button into the frames content pane a
little bit of JRuby magic we know that
there's a get content pane so we have a
goya we have a simple content pane
attribute accessor for it we know that
it's a list like structure so we can
append to it button goes on to the
content pane default close operation
here is obviously set default close
operation we turn it into an attribute
assignment we do pack and we do
setvisible with visible equals true so a
lot of the things that you would
normally stumble over in a java program
or have to type twice as long to get our
very clean and simple in JRuby looking
at this code you wouldn't necessarily
even know that you're working with java
libraries except for the fact that
there's Java X at the top the rest of it
looks like it's normal Ruby code in
normal Ruby classes so that's the
calling java from ruby side we'll talk a
little bit more about embedding ruby
pulling ruby into an existing job
application and if a more fun example
more entertaining example here is
pregnant so my co-lead on the project
Tom manabu is a big minecrafter and he
wrote this package called plugin so any
Minecrafters here it's got to be some
around right there's a couple I'm the I
know the dev ox for kids and the Java
one for kids stuff they do a lot of
minecraft stuff too and honestly I think
it'd be nicer for them to use Ruby for a
lot of it but I'll show you in a minute
here so the structure of minecraft here
we've got
the jvm we've got minecraft in in the
form of spigot which is the pluggable
scriptable version of Minecraft
available for users to do plugins and
then plugins generally written in Java
just above that so with plugin plugin is
its own little java plugin that plugs
into Minecraft and it knows how to load
Ruby plugins and has a nice Ruby
language in Ruby DSL so the the
minecraft minecraft server loads spigot
loads plugin and then plug in goes and
grabs your Ruby code and runs it as Ruby
scripts and then for an entertaining
example here this is egg madness and
example plugging that tom has so
normally when you drop an egg you get
one chicken and maybe a couple chickens
sometimes it'll work sometimes it won't
but he's written a plug in here that
modifies the chicken egg so that every
time you throw it it creates 100
chickens and obviously this starts to
get madness very quickly as tom is fond
of saying this is a great way to destroy
your minecraft server just start
throwing a bunch of hundred egg chickens
or hundred chicken eggs around and this
is essentially all the code that's
required for that plugin certainly less
than you would have if you were going to
write the plugin in java and all you
have to do is put this in the minecraft
spigot directory with plug-in around
plugins jar and you can write plugins
like this so we include plugin plugin
the the module that sets it up as a
plug-in we set a little description and
a version number for it and then for
unable when this plugin is activated by
prague in we do for the player egg throw
event we want to modify that behavior so
for that event we want to say it's
always going to hatch we want the number
of egg hatches to be 100 every time and
we want the hatching to still be
chickens will leave that the same but
obviously we could put other types here
you could throw a chicken egg and have a
100 wolves pop out of it the embedding
side is actually not that complicated
either so this is the core code in
Prague in that loads up the Ruby stuff
up at the top here we get a ruby a JRuby
scripting container and now you can use
Java X script
but our scripting API is a little bit
more Ruby friendly a little bit less
throw the code over the wall like the
Java X stuff so we create our scripting
container up at the top we're going to
run a little Ruby script to boot things
this is loading the core of plug-in
which is essentially written all in Ruby
except for this little bootstrapper down
here on the the core brains class of
Prague in we're going to call new pass
in the spigot plug-in loader and the
path for the Minecraft installation and
then we implement the spigot plugin
methods to basically just call the Ruby
plug-in methods so java's on a naval
calls the Ruby on enable and so on with
in Prague in here is the on enable it
just walks through all the plugins that
you've got in your plug-in directory for
each one of those it tells the plug-in
manager to enable it and that's it all
you have then is a few lines of Ruby
code and you can plug in and script
pretty much every aspect of Minecraft
okay so another area that ruby has
excelled in creating a wide variety of
options as build tools i'm going to talk
through a few examples here first from
the ruby perspective and then getting
more over to the java side so rake is
the standard build tool in the Ruby
world most popular build tool for Ruby
there are a few others but this one's
kind of one out for most things rake
obviously modeled after make but it's
still mostly imperative the structure is
similar but it's just essentially a ruby
script with a little bit of dependency
logic in it it actually works great for
JRuby or Java projects as well we use
rake for parts of Jay Ruby's build
specifically running our test Suites to
make sure that JRuby is still compatible
with regular Ruby here is a very simple
rake script so we've got a task default
that's going to depend on build the
build task has a description it depends
on compile to find somewhere else in the
file and then in with within this due
end within this closure you can have any
any Ruby code you like it'll go out and
build the code it'll fetch dependencies
whatever else is necessary down at the
bottom we just basically alias the build
to jar so we can also do rake
jar have the same effect so fairly
simple a little bit more complicated
example here now within our clean task
we have regular Ruby code we have a file
list that includes certain directories
and certain files those are the ones
we're going to delete so that's our file
list down at the bottom for each of
those files are mrf default feature of
the core Ruby stuff in the rake library
RM RF those files and print them out as
we go simple Ruby code and we've got our
clean task now most of you I don't
expect they're going to immediately
start using rake to do builds we've got
our own Java ecosystem so we'll talk
through maven as the next example so
problems with maven obviously it's
terribly verbose I've asked some of the
maven folks why in the world they never
used attributes why it has to be tags
for everything it drives me nuts it's
also pretty much one hundred percent
declarative you can't really do
imperative loops or branching logic in
there unless it's wired into the maven
lifecycle very difficult to do more
imperative code as part of a maven build
it probably the most damning part is
that there's a very weak set of default
conventions there is the general layout
of your project there is how that's
supposed to be built but if you ever
need to expand on that have a larger
project structure have multiple sub
modules then it starts to get really
messy really quickly so to improve upon
this there's a new project that's coming
around and it's actually released in
maven 331 and higher called maven
polyglot so the idea behind maven
polyglot is that maybe we can address
that non imperative verbose XML
structure of a pom file by allowing you
to use whatever language you're
comfortable with and in this case we're
talking about Ruby but there's
JavaScript there's groovy there's
actually a new a maven polyglot XML form
that does use attributes to try and
reduce some of the verbosity but they
all still fit into the same model and
they all still generate the same project
structure so our jruby build actually is
entirely based on this Ruby polyglot
maven support and I wanted to walk
through a few examples of what the build
script looks like to show
why it's so much nicer than using
pom.xml so first off I can't even
couldn't even fit the whole thing on the
slide if I stretched it out but we've
got our basic mavin pom file here all
we're trying to do is set up the basics
of the project some dependencies group
ID and version number and so on now if
you put this into the maven polyglot
format it becomes a lot cleaner so this
is the ruby version the groovy version
would be similar I imagine the
JavaScript version will be similar so
I've got our demo app project we've got
whatever site it's supposed to be on
we're using some particular model
version for this here in a single line
we can define our group ID artifact ID
and version number that goes with it
this is a jar package and then we've got
a jar dependency that goes along with it
so already significantly cleaner than
upon that XML and this will just run
directly with maven 331 another example
here I yet so just doing the group our
group an artifact ID here it is
examining the JRuby stuff and now the
interesting bit here is we're actually
using a bit of Ruby code at the top to
read from a global version file rather
than having to update every palm file
when we make a change the version number
we just have a little bit of Ruby code
that runs imperative Lee before the
maven model is built and skips the right
version number for you most maven
projects will have some number of
properties built into them for various
things again those are much simpler much
cleaner in a ruby format here's our
properties mapping A to B this one's
always my favorite the long strings of
dependencies and all these extra XML
tags again boiled down to just a single
line for each one certainly a lot
cleaner and nobody wants to look at this
no one wants to look at this this is
clean it's very easy to understand it's
which library in which group and there's
the version numbers a plug-in that's
actually pulled in here and this is for
shading JRuby so we have a super jar in
uber jar with all our dependencies it
shrinks down it's still complicated
there's a lot of lot of attributes that
are being done here but it's certainly a
lot cleaner and easier to read then that
giant blob of XML that no one should
ever have to look
and again just using standard Ruby
syntax and Ruby features here so overall
the jruby build we do still have a palm
that XML for IDEs and environments that
don't recognize the maven polyglot stuff
but probably about a third as many lines
of code for our build script and about
half as many characters and that's just
less for us to maintain less less visual
noise when we do we need to make changes
to the build and it's much more
approachable for folks coming out from
outside the project so how do you use
this there is still a bit of magic XML
in there if you have a dot mvn directory
you add a dot mvn directory to your
project stick this extensions XML in
here and then say which maven extensions
you want to use in this case we're using
the polyglot Ruby extension which will
make maven then go look for a pom Darby
before it looks for a pom.xml to
generate that pom RB there's actually a
goal out there as part of the polyglot
project that will take an existing
pom.xml and produce the palm Darby's
that you saw earlier so you don't even
have to go and rewrite this all by hand
you can take any maven project convert
its maven build its pom.xml into
whatever language you're more
comfortable with and then we'll continue
to work exactly the same now I mention
this is maven 331 which is not quite
propagated out to all of the Linux
distributions and so on yet maven
wrapper is another part of this this
project work provides an MV MW sort of
like a Gradle w command that will go and
fetch maven 331 if it's not available
and then do to build from then on so you
can easily start migrating to the
polyglot stuff and get rid of the nasty
XML files you might have now speaking of
Gradle we do also have some integrated
support work for jruby projects JRuby
code in Gradle itself so we've got
plugins for doing building testing
packaging and so on running Ruby code
the idea basically being that we would
like jruby to fit in as a seamless part
of a Gradle build so how many folks are
doing maven as your primary build how
about Gradle okay so it's kind of
similar kind of similar but yes so
trying to support both of these we kind
of have stuck to maven just because
that's where we came from so the base
configuration this
plugin is available out there apply
plugin calm github JRuby Gradle base and
you'll get the plug-in that you need to
do all this stuff you can execute some
Ruby so here we have a jruby exec that
we're pulling in we have our JRuby exec
block and then specify a script to
execute some arguments to pass it and
it'll run as part of the bay the Gradle
build for a full-on project that you've
gotten Gradle we can specify Ruby
dependencies alongside Java dependencies
so here we've got some gems that are
coming from the Ruby gems source we've
got a Sinatra gem which I'll talk about
later a little micro server version 1 45
alternately you can use this colon
syntax similar to the maven polyglot
version of group ID and artifact ID and
then you can also have pre-release gems
that are out there and these are all
proxy to look like they're maven
artifacts of course you can tell it to
build your JRuby application with all of
your Ruby code and spit out a war file
or spit out a jar in this case we're
creating a jar file it's going to pull
in some of the basic default gems for
JRuby pull in our Ruby code and produce
a simple runnable executable that has
all of j ruby and the ruby code ready to
go plus any java dependencies that you
might be using i mentioned war files
here's the example for that JRuby war
here's our web int stuff and again
simple code it fits right into Gradle
you can start using JRuby as part of a
larger application very easily okay so
that's building stuff using jruby r with
JRuby in mind you can also do some
really nice testing with Ruby and this
is actually an area i recommend folks if
they want to try and get jruby into the
back door into it into a company a good
place to start would be writing tests in
Ruby so here we have our little
contrived Java class just adds hello
comma to the front of whatever string is
passed in here is our spec like I
mentioned before behavior driven
development our spec is one of the more
popular testing frameworks used in the
Ruby world we'll walk through this so
require spec helper basically pulls in
any of library dependences that we need
Java import
we've got our org JRuby dental hello
library we're working with so then we
basically we're building a specification
for this class so describe hello library
add hello and for that for this this
example that we're building let the
library value be an oeuvre new instance
of that hello library so now anytime we
see library it's going to be a hello
library instances or instance in the
system and then we specify various
specification lines here so it pre pens
hello comma to the given string it
handles null values and you build up a
whole list of specifications here that
have clear descriptions of what that
behavior is you're looking for you can
run this later too it'll run the tests
but it'll also spit out an entire
specification document that shows which
things past which things didn't and what
was supposed to happen in each of those
cases here is a polyglot maven version
of a build script that actually pulls in
r-spec the gem line there second chunk
from the bottom rubygems r-spec and we
want this to run as part of the scope
the test scope in our maven build and
then the r-spec maven plugin pulls in
the necessary bits of JRuby to run the
ruby tests against your java stuff sets
up class paths pulls in the right
libraries and you can use Ruby to do
testing as part of a standard Java build
here's a little output from that
basically as part of the same maven
build we get our r-spec running okay so
those that's interesting like not really
production stuff development time work
that you might want to do with JRuby
obviously the big win for ruby has been
web applications and specifically rails
lots of folks doing rails applications
rails is what made Ruby into a
international powerhouse so rails is
really the original full stack frame
work it provided all of MVC it provided
a database layer provided a simple
server out of the box and a bunch of
code generation so you get a get a very
quick quickly you get an application up
and running you can start making
modifications to it and start working
with it from day one it also brought in
this idea of convention
over configuration that in in general
the standard conventions the ones that
aren't defined the configuration you
don't write should be the good default
pic a good default for everything rather
than making people configure everything
every single time they make a new
application and rails has really kind of
changed the face of web development on
the JVM as well most of the web
frameworks that we use today on the JVM
are copying or the newer web frameworks
on the JVM have copied rails in some way
or another trying to duplicate this
convention over configuration the
ability to generate an entire project or
generate pieces of it and honestly rails
is still want probably the best way to
build web applications quickly if you
want to get something up and going in
production you want to be able to uh
knitter ate on it fast rails is a great
way to go so the rails way you generate
an application it gives you a full
structure in rails originated this
general structure which has been copied
by a lot of other projects we've got our
gem file I'll talk about a little bit
later specifies your dependencies we've
got our app directory with all of our
MVC stuff plus some helpers and views
and whatnot we've got our database
directory that has database scripts for
rolling forward rolling back logging
testing this is an entire application
that it generates right out of the first
command everything that you need to get
it running and essentially almost
everything you need to put it in
production is part of that first command
you execute and in fact you can just run
this directly start this application up
and have a basic welcome page and start
making your modifications right away a
little bit deeper into the structure
here we've got something called a
migration that gets generated this is
for rolling the database forward and
backward we've got the models are
generated in this case we're scaffolding
a person that we're going to be doing
all of the crud operations on so we have
a person model generated under app
models person we've got a controller
that does all of the crud operations and
actually manages that we've got some
views generated for the different pages
for viewing all of the people in the
system for showing an individual person
for editing an individual person and it
also will generate some stub tests for
you so you can have it generate all
the different pieces of a piece of a
crud operation or a model and it will
also say here's some tests here's what
you need to be writing fill in the
blanks and you can do the rest of it
yourself so I'm going to go into rails
any more than that because tomorrow Joe
Kutner friend of our friend of the
project and Heroku JVM language owner is
going to be covering rails along with
three other JVM web frameworks and kind
of walking through the structure of them
how they're similar and how they're
different and he'll do a much better
treatment of rails than I will so make
sure you get to that one tomorrow in
room seven at 1750 so I'm going to talk
a little bit more specifically about
micro frameworks micro-services since
this seems to be the big hotness now
it's actually kind of the big hotness in
Ruby several years ago there's several
different micro frameworks and a whole
bunch of little command-line servers
designed for doing little micro
frameworks and micro applications so
some background here Rack is essentially
the equivalent of servlet API it's
Ruby's version of servlet API and rather
than having a web XML you've got a
config dot are you rack up is that are
you abbreviation that starts up the
application does all the config and
boots the rest of your application for
you so you'll see that in some of the
upcoming slides the main web micro frame
are going to talk about here is Sinatra
a very tiny very small framework very
quick for getting very simple services
up so there's folks who write little
Jason endpoints using Sinatra there's
folks who will do even larger
applications in little pieces very
lightweight and very fast the request
cycle is considerably faster than a full
stack framework like rails or Grails and
you can put in only what you need is
part of your application so here is the
HelloWorld script for Sinatra we say
that we're going to use the Sinatra
library and for a get to / high on our
URL return hello world and in this case
it's just a plain string so it will come
back as plain text we have a web
application all set to go and it
literally is just this we jammin stall
Sinatra to make sure we've got the
library installed but then we can run
this script directly and it will start
up a server and be a ruby endpoint
right away easy to see how you can start
to put services together extremely
quickly with just a small amount of code
pull in the libraries you need and put
it in your config are you or your
Sinatra script I mentioned gem files
earlier a bundler is rubys equivalent of
maven dependency management you get a
gem file that lists all of the
dependencies you have what their
versions are a little bit of extra
configuration if you want different
dependencies in test versus production
or your development environment you can
actually specify which version of Ruby
or JRuby you want for your project so
it'll validate all that make sure it
pulls down the dependencies and get them
ready for you a gem file here's an
example of the gem file that's actually
generated for rails so we're saying we
want all of our gems to come from
rubygems.org you can't have other
repositories this is the standard one
essentially our maven central we're
going to use rails four point two point
four and so on on all the dependencies
that it sticks in here then get
installed if you do a bundle install
it's going to pull in rake it's going to
pull in Jason testing frameworks and so
on all this stuff basically just doing
the dependency logic that you'd see in
maven so another one then we talked
about a little server that we actually
worked on at at Red Hat as part of the
polyglot group torque box which is the
set of Ruby wrappers and utilities
around jboss or now wildfly it stuff
there is just a standard ruby gem but it
allows you to use all the same java ee
services that you expect as just another
part of your ruby application so within
your Sinatra script you can say i want
to set up a messaging endpoint i want to
set up a time job don't have to deploy
an entire war file to do it all you do
is pull in some torque box libraries
startup the server and you're ready to
go here's an example gem file where
we're pulling in the torque box web
which is just the web serving component
here we've got our Sinatra and then on
the other side the config are you that
rack file that specifies here's our get
logic for Sinatra here's how we run the
application run with torque box and
we're actually using a Java
equality web server to distribute a ruby
Sinatra app pretty cool I know of course
these going to be thrown into any
application server you can create a
Sinatra app you can create your little
micro service and then run with Warbler
another project from the JRuby family
that turns it into a plain old war file
it'll pull in your Ruby dependencies
it'll pull in JRuby itself and any Java
libraries you need and it will produce a
war file and it actually produces a wire
file that is also executable like an
executable jar so if you just want to
distribute this wire file to production
run java jar my apt waar you've gotten
out of running application with its own
built-in server maybe that's even just
torque box but very easy to get a little
service up and going writing about 10
lines of code so the combined example
that I wanted to show before we close
out here Joe who did the deploying JRuby
book is going to do the talk to Mara lon
web frameworks has a little example of
JRuby using asynchronous servlet ap is
and servlet 3.1 and this combines
Sinatra and Warbler and some maven stuff
and the servlet AP is and it's just a
handful of files and I'll walk you
through what they look like here so
here's our gem file for this application
again pulling from rubygems.org there's
some of that logic saying we want Ruby
to to to compatibility we want to use
jruby version 17 18 or higher then we
say we're going to use rack because
that's our standard servlet API we're
going to use Sinatra and then if we're
in the development environment we're
going to use Warbler to build war files
here's our config are you a little bit
larger than the other examples but we've
got our require of Sinatra we're
creating an actual Sinatra application
class here and then forget / we're going
to say that we've got two chunked
trunked response coming back to the user
we're going to set start the async logic
in the servlet request so it knows that
we're going to be doing a synchronous
responses here and then we start up our
thread that's actually going to do all
that asynchronous work and of course you
could pass this off to a thread pool or
some other worker of this is just a
simple example it's going to sleep for
10 seconds each time and then into that
asynchronous response it's going to
print
out some asynchronous information and
then tell the async that it's done with
that iteration so it can push it out to
the client and then I've down at the
bottom will complete this whole request
by doing some synchronous HTML return
and of course there's various frameworks
for doing a HTML templating and whatnot
and this is this is largely the entire
application we've got our asynchronous
application using some of the newer
servlet features but based on sinatra as
the web framework and JRuby as the
platform the palm darby for this he
actually just has a pom.xml in the
project but I threw it into the
generator and this is what came out a
very simple set of me very little for
dependencies and this is actually using
the Heroku plug in to prepare it for
deployment to Heroku so all you need is
to have this get your Heroku account
you've got your micro service up and
running in production here we bundle
install it pulls in the libraries that
we need bundle exec warble to turn it
into a war file and in this case we're
just going to run it now we have a
server up and going with our async on a
server example no deployment to a server
no additional dependencies that we have
to worry about really pretty cool that
it all comes together so nicely so
summarize a little bit here so i really
want folks to think about JRuby is not
just being Ruby its Ruby and Java we've
got the entire Java ecosystem we
leverage the JVM very well and any java
stuff that you're using or you're used
to you can pull into ruby stove root
into Ruby applications hopefully this is
shown that Ruby folks also have a lot of
really cool things Sinatra is a nice
little Ruby micro framework microservice
of course job is evolving fast too but
this all can tie together and you don't
have to choose one world or the other
you can use bits and pieces from both
and integrate them really nicely with
JRuby it's pretty easy to get this stuff
started like I showed you have a windows
installer there's Ruby installers that
will pull down JRuby for you you can
unpack it and just run binge a ruby and
you're up and going and all the
libraries are out there it's very easy
to start playing with it and it's pretty
fun and it's pretty powerful hopefully
you'll be able to play with it get get
more familiar with libraries and try out
some
Ruby scripting of Java or some of these
frameworks the final slide here these
books are out there in the wild but I
think they've gone out of print Joe is
going to be working on an updated
version of deploying jruby in the next
year we're hoping to also do an updated
version of using JRuby that includes
jruby 9000 and all of the recent
advances like Sinatra and new
performance improvements we've made and
that's all I have for now thank you very
much anybody you have questions I've got
about nine minutes for questions on this
up yes right over here
high-profile migrations from Ruby to
something else because issues
entire server
hmm
No
would you said running Ruby on the gym
p.m. until they get rid of that
right so the question is about some of
the high-profile migrations away from
Ruby that have happened over the years
obviously one of the big ones that comes
up is Twitter puppet migrated some of
their stuff over although I believe
puppet actually for the server side
stuff if they actually move to JRuby to
address some of the issues with Ruby
performance so there are a number of
people that have done that the question
though was does JRuby kind of stem some
of that bleeding of projects that leave
the Ruby community and address some of
those issues and the answer is yes it
absolutely does most of the folks that
were on that slide showing JRuby users
have come to Jay Ruby from standard Ruby
and are much happier with it now because
the performance works because they have
true concurrency in a real G a really
solid garbage collector the time frame
for a lot of those big migrations like
Twitter which was you know in 2007-2008
or so honestly at that point JRuby just
wasn't ready and they might have looked
at JRuby they might have not but at that
point we weren't where we are now to
these days JRuby itself should almost
always be faster than regular see Ruby
for simple things maybe two to three
times faster for more complex
applications five to ten times faster
than running the standard C
implementation and it does get well into
the neighborhood of the regular java web
frameworks at that point we've also got
a lot of work coming in with invoke
dynamic with JRuby 9000 we're doing some
more optimizations and probably the
biggest thing is a lot of folks migrated
away from Ruby because it can't do
concurrent threading so you want to
scale something out you need to have a
process per user essentially so Twitter
obviously is a perfect example of that
how do you scale out with thousands of
users when you can only run one thread
at a time that's the sort of things that
are driving people towards jruby they
can throw it on JRuby application take
advantage of everything the JVM has to
offer and more and more that's where
we're seeing people going groupon is a
good example of an application that they
it's largely Ruby based but couldn't
make things scale and now I understand
that they're running a lot of it on
JRuby to make up for
lost time there Yeah right here
multi-threading then you have to do
things like synchronize and the rupee
language doesn't support these features
as Java does how do you deal with that
right so how do you deal with some of
the the complexities of threading like
synchronization and thread safe data
structures and so on from a language
like Ruby that never had any of that
well there's actually a project in the
Ruby community called concurrent Ruby
it's done right now is just a library
that you can depend on but it
essentially includes all of what's in
Java util concurrent all of what you see
in something like closure there's all
implementations that are built to work
across ruby implementation so they work
in see Ruby they work in JRuby but they
provide atomic variables they provide
thread pools they provide executors all
of this stuff is being done as a
excellent project in the Ruby community
to basically build up those pieces that
are missing from Ruby's concurrency
story at the same time I'm a ruby core
committer for the standard
implementation I work with the Ruby core
folks Masahiro Matsumoto co EG the core
guys that work on Ruby and we are in
future versions of Ruby going to improve
that concurrency story add some more of
those features like volatility for
variables and final variables and so on
things that that we've come to depend on
in Java are getting into Ruby as a
language but are also available today as
a library that you can pull in so this
is the concurrency story used to be not
great jruby was the only story in town
and we had to kind of make it work but
the rest of the Ruby community is caught
up now and they're doing a lot of great
work in that area yes up here
oh yeah absolutely absolutely they're
the like the standard rake build tool
there are some plugins to do Java builds
for it as well so if you're comfortable
with rake and working in a ruby
environment it's very easy to have it
also build your Java libraries and put
them in the right places for rails but
you can also there are maven plugins and
Gradle plugins that go along with JRuby
that then also know about the Ruby side
know about the Java side pull
dependencies from both and build it as a
single application so that stuff is all
out there depending on which build tool
you use it'll vary a little bit and
there are a lot of mixed projects out
there definitely
right right so the comment is uh it may
is it a good idea to kind of write your
business logic or your core logic in
Java and then write some of the web
stuff in Ruby that's that's what we've
seen as a really good fit the
application side the front end side that
changes and is really dynamic and needs
to respond to new user requests and new
features that's a great place to do Ruby
and rails use Ruby for what it's really
good at fast iterating code easy stuff
to change make changes quickly write
your core stuff in a Java or a closure
ask Allah in the back end somewhere that
can do some of the heavy lifting that
can be used as a service behind your
rails applications I think I've heard
the term reverse mullet application it's
party in the front and business in the
back other questions don't think I see
any so we'll we'll call it there thanks
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>