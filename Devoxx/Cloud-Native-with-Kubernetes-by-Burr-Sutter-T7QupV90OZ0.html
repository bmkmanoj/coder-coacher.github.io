<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Cloud Native with Kubernetes by Burr Sutter | Coder Coacher - Coaching Coders</title><meta content="Cloud Native with Kubernetes by Burr Sutter - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Cloud Native with Kubernetes by Burr Sutter</b></h2><h5 class="post__date">2017-05-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/T7QupV90OZ0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Birgit you play kids do it thanks s okay
you guys ready to go the guys had a nice
lunch everyone's nice entired ready fall
asleep at this point and if you saw my
presentation earlier the quickie I did
you kind of saw the awesome demo at the
very end but we're going to kind of walk
through it more slowly and also cover
more topics in this particular session
since we have a few more minutes than we
did before my focus in this session is
specifically how to do cloud native
development micro-services development
in the context of kubernetes you know
we've certainly seen a lot of different
things from a lot of different players
in the market but where does that apply
and how do you bring that into the
kubernetes world so I work for Red Hat
my name is burr Sutter I'm specifically
a Java champion and I do a lot of
presentations around you know various
topics and technologies
I've actually been part of the JBoss
team from 2006 into mouse eleven years
now because red have acquired JBoss so
ten years ago eleven years ago and I
used to mostly be internally focused
mostly as a product manager working with
different engineering teams defining
requirements you know working on
usability things of that nature not
pretty much go out and talk to the world
about different technologies that we
have and in this session we're going to
focus on there's kubernetes redhead is
the second largest contributor to
kubernetes in the upstream we
specifically have another V source
project called open shift around
kubernetes that you'll see some aspects
of that also and then we have another
open source project called fabric 8 and
you're going to see some aspects of that
and so there's going to be a lot of
interesting stuff from that perspective
to just kind of get your head around
what's going on in this universe and our
entire focus is on basically making it
easier to build cloud native
applications on top of this architecture
and you're going to see some interesting
stuff I hope and so let me ask a couple
questions how many people have been
hands-on a docker at this point okay the
majority of you it looks like that
that's common for conference attendees
not as common in the regular world right
but for those who are their elite enough
and blessed enough to show up for
conferences meeting the boss let you go
or even paid for it or you paid for it
yourself and you know thank God for you
paying for it for yourself but that's
makes you guys can you kind of deal in
hands-on kubernetes at this point okay
vastly fewer people and that's good
because we're going to kind of walk
through kubernetes at a high level show
you a bunch of different commands but
more importantly show you what kind of
workloads you can run on kerbin
and do things like canary deployments
and things of that nature so it'd be
pretty fun so let's go and dive right in
I represent a team called developers
Arend comm so if you could just feel
free to go to developers or comm tried
some of our free ebooks like on vertex
micro services and one book in
particular that's particularly important
is by NCAA Nagas and works on my team
and it's dealing with the monolithic
database so by default most people who
get stuck in a microservices
architecture like how to decompose and
blow up the monolith break up the
monolith as what to do with the
monolithic database and that took your
book specifically walks through several
strategies for how to deal with that so
we find that's the number one question
on people's minds is how do I decompose
my monolith when I have a monolithic
database which most everyone does first
of all you got to kill the DBA just keep
that in mind I'm just kidding
I'm not advocating any kind of form of
balanced violence but do go check out
the Dead website
books and downloads from there now I
love this rigor quote we cannot solve
our problems with the same thinking we
used when we created them so we're
living in a brand-new world when it
comes to cloud native architecture so if
you think in terms of cloud first
architecture you do write your
applications just a little bit
differently not dramatically differently
but a little bit differently and we'll
kind of show you some aspects of that
all right I really love this concept of
the developer journey I talked about
this a lot I talked about the fact that
typically you need to be thinking about
DevOps and the reason I talk about this
because everyone thinks they can jump
immediately over to the far right and I
see this time and time again as I go out
and talk to different people who are
actually started their their micro
services journey and things of that
nature they're very much focused on you
know how do we build our micro services
right now and they don't actually have
the DevOps principles in place they
don't have the automation in place so
some of these are super critical and
we'll talk about them briefly but one
here in particular is do have some form
of self service on the man elastic
infrastructure if it takes you three
weeks to get a virtual machine inside
your organization you have a fundamental
problem okay and now I say three weeks
and some of you were gone three weeks
Wow
my organization is six weeks and so you
know and some bigger thing of what you
know I do that in three hours it should
take you like three seconds and it
should be API driven and something that
you can just get access to all the time
based on quotas assigned to your account
within the organization this is no
longer hard the technology has been out
there for years it's all
open source if that's what you want it's
you know things like OpenStack and cloud
forms and things like that are available
to you but even kubernetes can help you
with some of these problems you need to
think in terms of automation if you're
actually building servers from scratch
like with SSH and then system D or I and
you know init and scripts and bash
scripts and things like that
that's a problem you should be baking
out servers with a full script whether
it be public chef or ansible or
something like that or in our case of
kubernetes templates or carbon eighties
manifest you know you did that way also
so we're really going to focus in this
session though more around advanced
deployment techniques then the rest of
this but you know there's different
presentations we have to cover all this
ground ok so it's going to jump in here
from an IT standpoint things have
changed we used to be waterfall we kind
of moved agile now we're talking about
DevOps that's super critical to be
thinking in terms of working together
from a dev and ops standpoint we have
used to build monolithic architecture
now we're focused on interior or were
focused on interior architecture and now
we won't talk about micro services and
of course we have we used to be in the
physical server mode virtual server mode
some of us are still on physical servers
not on VMs but now containers so in this
new world of the kubernetes world many
of you raise your hands for docker you
were to experience the container magic
right if you did your first docker build
and docker run you're like wow that's
amazing now we're taking that to the
next level how do you do doctor run
docker run docker run in many cases and
that's what kubernetes offers us and of
course the datacenter has changed and
actually I remember back in the day when
we had mini Towers sitting on people's
desks and that was the data center
anybody have that you know before right
that was where we went production
deployments was on someone's desk and
then of course allude all that - nice 1u
rack-mounted servers that went into the
back you know into some nice
air-conditioned room and now we're
talking about some you know getting rid
of all that and putting it into cloud so
these things are always changing also
the core principles around how we think
of software development should be
changing right now so if you think in
terms of building continuous integration
we should be doing that all the time and
most people don't actually pass pass
Jezz humbles tests in this category you
ever seen J's home will give a
presentation and he's the fellow who
wrote the book about continuous delivery
he has to test when it comes to
continuous integration right one is the
software that goes in their trunk is
immediately deployable to production if
you check in the trunk that code we know
is good enough to go to production
immediately and that some people are
like okay my testing is solid we got
great in
automated test we know our stuff is
ready to go the next test is be more
interesting and everyone on the team
checks in the trunk daily because one
way people get a nice clean trunk is no
one's allowed to check into it right
then do you guys probably have lived
that life cycle also so if you're not
active checking in the trunk daily and
you're not doing automated builds of
that automated test of that you're
actually not doing continuous right if
you're living on the feature branch for
three weeks you're integrating every
three weeks so that concept is super
important and a lot of people have to do
a lot more work when it comes to
discipline in terms of getting their
continuous integration strategy working
but continuous integration continuous
testing then informs then you create a
continuous delivery pipeline that's like
your jenkins file and using some like
jenkins 2.0 to actually do that sort of
thing and then maybe you go into
deployment and what we want to show you
in some of these some of the topics here
is the concept of how you go rapidly
into production and that's what we
believe docker containers and kubernetes
allow you to do so it's going to show
you that now this is an image that I had
my designer build because this is how I
perceive typical software development
today you have this big amorphous blob
and a large team of people trying to
push it up the hill right you know push
it up up the hill and get over the hump
and you also have people pushing back
and people dragging it down and so the
concept of deploying rapidly is actually
super hard for large organizations right
because you hear about the unicorns that
are employing let's say multiple times a
week or multiple times a day
in this context it actually can be a lot
of work and the worst part about this is
let's say does take you nine months to
get over that hump you have more humps
to come okay that's kind of the idea and
the future we want software development
would be more like this where
everybody's in alignment it's a small
team in alignment what a nice cohesive
well-structured piece of code that's
easy to push up that hill you're going
to production is never going to be
simple right it kind of matters we're
going to show you some things make it
look super simple but it does matter for
most of our organizations especially
based on regulatory requirements and
other requirements within the
organization you know productions hard
but it doesn't have to be as hard as
what you saw in that previous image
let's get going here okay now if you're
a Java programmer which is where I come
from then Java programming in a case of
the micro-service architecture or some
form of lightweight framework is super
easy at this point drop Wizard certainly
kind of popularized this concept of the
fat jar
vertex adopted the same principle many
years ago and then we see things like
spring boot you know using that
technology now are using that concept
now and of course wealth lies form which
is part of the micro profile effort
which is another session like next door
right now but how many people here are
using drop wizard okay it's Fair Network
drop those are people excellent how many
people are using like multi swarm
anybody one gentleman there you can
raise your hand proudly it's okay and
then how many any vertex users here okay
the one sitting up front you guys know
each other I'm just kidding and how many
people are using spring food all right
so that's you know a fair percentage of
you so these are different and of course
you can do different things different
ways but these are the ones that are
super easy to get started with as an
example but running building a simple
fat jar and loading it up or running up
with Java des jahres pretty easy at this
point there's no hardship here what's
hard is now figuring how to actually
wrap the thing and for some for more
rapid deployment so in a case of micro
service and cloud native apps in general
these are the key principles to be
focused on so we you know you have to
kind of focus on the concept of
discovery managing your public API how
are you going to invoke that service
right so I got a better find it I got to
know what its API is am I going to
invoke it with HTTP or invoke with some
form of messaging architecture does it
have elasticity can it scale you know if
everyone starts pounding on it pretty
hard is it easy to scale it does that
have resilience if it actually dies does
it failover nicely or more importantly
if it gets low what happens in that
situation how do you deal with a slow
actual service that is actually part of
our chain of services being invoked
because they knew a single point of
failure in there could actually slow
down the entire entire application
pipeline of course how do you do your
deployment pipeline is it automated or
is a manual that's an important part of
it authentication you want to make sure
that the users that are invoking the top
and front end you know the edge service
maybe the API gateway layer are
authenticated all the way through the
chain of services that are being invoked
you know how are you managing that how
do you manage logging across all of it
one thing cool about kubernetes and
things like a docker if you actually
just logged a system out and knows how
to grab all that and then pull it right
into a central repository and we use
something called efk so elasticsearch
fluent D and Cabana
so those are three we like so we don't
use plk we eliminate log stash and you
Slendy but you can use whatever you
like right assist away gathering logs
monitoring do you want to better monitor
across the batch that's a lot people use
Prometheus in this kind of world that's
a common thing to see in a kubernetes
world but we also have another
technology out there called ocular and
ocular helps you do monitoring of these
components within within the fabric and
then of course tracing and tracing logic
gates figure out how did you do the
transaction flow through the system of
services did it go from A to B to C you
know skip D go to E skip F go to G and
that might be very important for you and
how something actually happened so all
these we consider to be key principles
and core principles that you want to
wrap with your micro service and one
thing that you'll want to do is ensure
that these things are set up in such a
way that you hopefully they don't
interfere too much with your business
logic and that's actually where the
problem is as of this moment right now
they do invade and pervade your business
logic and there's some things we're
working on for that category that I'll
talk about as we go ok so most people
here have done some docker and doc
reports is super awesome because it
allows you to define your stack this is
why I love docker and when I first saw
it I thought this is awesome with my
docker file I can actually say here the
core prerequisites to run my app rather
be my war file my jar file my ear file I
know exactly what my operating system
needs to be at the right patch level I
know exactly what my JVM should be at
the right patch level because oddly
enough an operating system patch or JVM
patch could break your code I've seen it
happen before right literally just a
different patch level of that 1.7 point
something of the JVM could blow up your
code and series always
backward-compatible but it's not always
true right so the JVM can blow you up
you also have to get your app server
exactly right and you have to you know
decide exactly how that app server will
be configured with your JDBC driver your
data sources your JMS queues so this is
the beauty of the docker file right it
allowed us to codify all this make it
programmatic when it used to be an email
that was sent back and forth across team
members we we used to send an email to
QA team oh here's the war file created
for you and in order to deploy it here's
an email of all the steps you need to
deploy it and some of us got really
clever we're saying okay we don't do
emails anymore that's too manual we have
a wiki page and the wiki page is never
up to date right so when the QA team
receives it they can't deploy it because
someone forgot a step in the wiki page
if you have the docker file and an
immutable image the moves from dev QA
they know exactly what they're getting
the notes
actly had to run it right at least all
these parameters are figured out for
them now in the case of a docker how do
you scale that right so let's say you do
have a Tomcat you know Postgres of wild
fly a spring whatever might be you know
you have all these components how do you
scale it across multiple nodes multiple
pieces of hardware so yes you can SSH
into every machine and docker run docker
run docker run docker run you can also
use docker swarm mode right which helps
you do that distribution also but in our
case we use kubernetes for this sort of
same thing so the idea of an communities
of course it comes from the Google team
they invited Red Hat and very early on
to the project they actually told us
about it early and so we actually said
we want to be a part of that as an
example so we actually went to one of
the greatest contributors securities
outside of Google proper but the nice
thing about it is it helps you with
scale a building managing these
components and workloads across all
these different nodes dealing with port
conflicts like in my case I'm going on
everything on 8080 on this one gene
because it's being managed by kubernetes
you got a manage multiple hosts and then
of course if something breaks how do you
fix it how do you recover from it and
there's all this capability automation
within kubernetes itself to help you
keep your containers up and healthy and
we'll show you some examples of that
okay so that's the kerbin Nettie's it
stands for helmsman and Greek so the
pilot of the ship because the image of
docker is this container ship so it's
the pilot of the container ship this
kind the idea so it's a container
Orchestrator it supports it's available
on all these different clouds right
public clouds and also in bare metal you
can run on your laptop we'll talk more
about that a second and of course you
have the ability to run it anywhere you
would like insects are pretty
straightforward now occur Benes cluster
might look something like this there's a
master but sed an API server you know
basically that's responsible for
ensuring that all the worker nodes what
used to be called minions but a worker
nodes if you will they're the guys
running to actual docker containers each
of these guys have something on them
called a cubelet right the cubelet is
think of as a daemon if you will the
basically is a little agent and it's
responsible for running the jobs that
have been asked that are supposed to run
it also does monitoring of the
containers to see if they're healthy or
not and Vic Tanner's are unhealthy it
will stop and restart them if necessary
and if other things have gone wrong in
the system it'll rebalance also so that
concept of having that master and these
different nodes means kubernetes can
manage the entire cluster
the challenge with kubernetes is always
that it's kind of hard to learn I'll
show you some aspects of that and some
ways we've actually been working to
clean that out make it easier now there
Pecor concepts when improvement IDs are
specifically the console to the pod
right so the pod is one or more
containers so that's an important aspect
of it it was never limited to a single
container you can actually pack two or
three containers in that pod very easily
and that's actually going to be
important a little bit later on
typically most people just put a single
container in a pod okay they have a
shared IP shared storage basically they
see each other on localhost essentially
that does mean that two containers in a
pod can't actually be on the same port
because they're they share the same IP
address so just keep that in mind if you
do stick two of them in there again both
of them be on 8080 but if you have two
pods right three pods they can all be on
8080 is the idea the other concept of
replication controller or replica set
and a deployment this basically manages
the specific number of pods that you
want
so you basically say I want four pods
running all the time in this cluster it
ensures that for stay running all the
time you can also ask to say I want five
now and it will ensure the scheduling of
the five across the cluster you can
didn't say no I want back at three and
it will make sure the other two are torn
down and you're back at three so it
manages is that from that perspective
you have the concept of the service and
this is where it gets pretty interesting
from us from our programming standpoint
so they've actually separated the
virtual IP that people talk to from the
pods that come and go that are highly
ephemeral all right so the pause could
be rescheduled rebuilt you know come up
central on a different IP address based
on what notice show up and of course if
one fails it gets restarted maybe
someplace else but the service is more
persistent so you interact with the
service specifically the service name
and it ensures that it routes
accordingly to the right pod and it
gives you load balancing for free at
that layer we'll show you some examples
of that you also have the concept of
labels and the labels become super
important because the service for
instance can have a selector of what
pods should be in its list of minute
load balance pods based on the label
selector and have an example of that too
okay so the concept of the pod people
probably wondering where that word comes
from it basically comes from the concept
of from a community standpoint it's a
family of whales because the symbol for
docker is a whale it's a family of
whales or dolphins some people thought
it referred to the pod people you
remember the old set
these sci-fi movie I think it was maybe
early 80s okay one more thing that
should be important to note is we have
we red hats specifically extend
kubernetes terminators is the kernel if
you will and we add some things on top
and those things on top are specifically
based on this thing called open shift
open shift org and I just highlight them
here in red so you're familiar with them
so this is where we're trying to make it
easier to use from a developer
standpoint so we had a routing layer
based on H a proxy right now the box so
by default you get load balancing across
routes and you can actually mount routes
or services very easily you also have
the concept of builds and image streams
so we assume that you want to do a build
of an image specifically a build of the
image and kubernetes and to do like a
build farm so instead of building on an
individual user desktop which could get
you some trouble right you actually
build in the cluster itself and that may
sound kind of weird but if you want to
ensure that you get the exactly the
right image baked out or more
importantly let's say a bug has been
found at some high level image layer for
instance the operating system layer
heartbleed is just happened you have
you've seen the new CVE you want to
react to it you want to rebuild that
layer well that means all 300 of your
other images have to get rebuilt also in
which case if you have a build farm to
basically say rebuild them all retouch
them all in a clustered way scales out
better so that's why we focus on that
the building in the cluster itself it
also ensures no developer can mess up I
mean because we have the exact base
image that we want so those concepts are
pretty important the concept of the
deployment which is now incriminated
proper actually came from
openshift originally so what you'll see
is we'll do innovation here at openshift
level and then contribute it back to the
upstream on the community side so that's
typically the way Red Hat works right we
work with in some form a downstream
project fine baked out an idea work with
the upstream project say would you like
it back and move that back so everything
you see in this world from a OpenShift
standpoint is also kubernetes in most
cases so you can just treat it like
kubernetes and just do cuddle cube CTL
I'll show you an example that okay of
course if a node gets killed then of
course we rebalance those containers to
available nodes so just keep that in
mind that is all magic there from your
perspective you don't worry about it now
let's kind of just show you let's see if
I can run this demo real quick just give
you a quick feel for a simple kubernetes
okay let's see if I can find it
actually let's kind of show you some
different things yeah let's try this OCD
status and cube CG I'll get pods let's
make this a little bit bigger okay let's
just have some fun with it so I'm not
keep running a local environment here
I'm basically running a virtual machine
here in VirtualBox where's my VirtualBox
right there okay I'm running this thing
called mini shift and I'm actually
running a fair bit of memory 7 7 gigs of
RAM because I'm running a lot of stuff
in this so if you're actually running a
bunch of JVMs inside the cluster this is
a single node cluster running on this
laptop
I've SSH into it over here right so
let's see if I have any memory left I
don't have a lot of free memory right
now so vac you've been using a lot of
stuff here and if I come back to my
external command line let's see docker
PS oh not connected to deter this one
should be connected there we go you can
see I'm running a ton of docker
processes and if I do docker energy I
got a ton of docker images I'd meet any
given moment this thing could go blow up
right I'm running a bunch of stuff but
I'm running a whole cloud here if you
will
and I've been doing a lot of work
against it from a developer standpoint
and it's all local so that's one thing
we really like about it but let's just
take in a simple example let's try this
okay let me go to spring initializer
here and so let's call this artifact
demo 2 and let's give it the web
dependency so let's say we built our
little spring out that way we unzip it
and there there it is okay
so let me go over here to demo - okay
there it is so maven cleaning compiled
package so it should just compile it
nicely now this is a way to just build a
simple spring in point and there we go
so let me open that up and I tend to use
visual code a lot lately we've actually
made contributions to it that actually
can do Java now as an example but let's
do this let's call as my rest endpoint
and I'll just cheat I'll copy and paste
from one that I already have working
over here just so you guys can get get a
feel for that ok so let's just do that
and we got to get in the right package
looks about right I got to give it a
right name and let's see all this thing
is going to do is just give us a rest in
point
now if I did that correctly let's see if
it still compiles all right yep
I've messed something up what I mess up
by annotation does not exist tintin
tintin tintin what did I do wrong
he's telling me I can't find spring now
that's unusual they're all is I'm in the
right directory
yeah I can't find some o rest controller
let's see here
word I have to work controller that guy
I can't find that guy how'd that happen
okay
what's that web dependency but it's
always so just okay normally I don't
have to add that did I did I not click
the button correctly when I did that
generation so web look at that
let's see here no no no I didn't put the
button all right let's try this again
well there was a problem it would help
if you actually click the button
correctly all right so let's just do
that that way I don't worry about it all
right so demo three let's look at the
code all right source in point there we
go
and my rest just to make it easy
I saw the code there and I do not let's
go back and get it to distance down all
right so if I let's go let's try it this
time this is taking too long
you guys already getting bored I know
all right may even cleaning compile
package since how you know it slide you
just mix stuff up all right there we go
compiled format this time I have that
promise with that user interface before
where I didn't click the thang directly
okay now here's we're get some more
interesting so I just have this standard
thing you know you can mouse that jar
right so if I want to run it directly
from here no problem just Java - jar run
the batch jar but that's not that
interesting let's do this see stuff
okay oh see new project my stuff okay
now watch what I'll do and now I'm going
to copy and paste this little command
also just because I don't memorize it
which is unfortunate but at some point
we will all you got to do now is add the
fabricate maven plug-in jump bond to see
here alright so the fabric gate project
while that's working is is a bunch of
different things one of which is
specifically the main plugin but also
it's a bunch of kubernetes manifest and
a bunch of tools that help you kind of
get things set up correctly okay so this
is a pretty interesting project for the
perspective of how do you make a
developer productivity happen on the
kubernetes from criminais standpoint and
if I did this correctly eight deploy
okay so you basically at that point have
generated all the docker and yamo files
needed for for kubernetes so let's go
back here and look at it here we go and
we look under target in classes meta-inf
and then in my case i'll use their group
apprecia version but there's the
kubernetes ones also so it typically in
a criminai DS world
you write the Shamel code okay you
basically like here's a good example
here's the deployment listen
a bit bigger and okay you typically
write you know there's different labels
annotations that are in here but you can
see there's replicas we want one the
labels associated with it the template
and you'll see things like the the you
know different ports that are going to
be available we opened up job Jolokia by
default that gives you the java console
so you can actually see inside the the
Java JVM and this one unfortunaly
doesn't have the the readiness probe in
it let me see if this one does then I'll
show you an example in a second but
right there okay but all this is done
for you and if I did that correctly
let's see here
go back over here we have a console that
sits on top but my stuff would see open
up and there it is and there's that
spring boot app now running inside
kubernetes so if you take one thing away
from this session it's like if you want
to try kubernetes and you want to get
started fast for maven or Gradle
perspective the fabricate maven plugins
shortcuts a lot of stuff for you and
makes a lot of assumptions for you now
if you want to go beyond that let's say
you want to specialize that you can you
can actually add yeah Mille fragments
for very specialized kubernetes features
into a fabric a directory and I will
show you an example that a second but
that will give you the rest so here
let's go find one of those examples I
got so much stuff on this machine I was
let's actually do that actually what
I'll do to save resources oh see delete
project my stuff so let's get rid of
that just remove it from the cluster
back over here
not that one you know this one okay so
like here's a good example where I want
to add a readiness probe okay so in this
case the fiber gate maven plugin
couldn't just assume what URL do you
want to be you're liveness probe or
radius probe as an example so what these
are useful for is when kubernetes
actually launches a particular container
runs it into cluster it didn't has the
coop cubelet actually interact with it
pull it talk to it
are you alive or are you not alive right
and this it's not alive but actually
starts it
so that's the liveness track there's
also a readiness check the readiness is
slightly different and the written is's
purpose is to ensure that it can be part
of the load balancer is it ready to
receive traffic so you use the two of
them and your business logic accordingly
to decide am I live or dead and if it
doesn't get a response within so many
seconds it'll seem you're dead and
restart you and then you have the
readiness probe to say are you actually
really ready to take real workload so in
the case of the readiness you would
actually do things like make sure your
database connectivity is there and sure
your caches are warmed up and ensure
that everything else is ready to rock
and then you're ready to be part of the
load balancer okay
so that's what those two guys are for
and that's really what this is a good
example where in fabricate we couldn't
make the assumption but you just add
this little bit yeah Mille again it's
typical
yamo like you would see in a kubernetes
world it's just a deployment right there
and then you deploy with it okay and
this is very similar application that
you saw earlier with spring booth but it
basically has a couple things here are
you alive are you ready and those are
the ones and then there's a prepare to
die and actually let's see don't have
that one running still okay we don't
want to run out time we got we got 20
minutes left it looks like okay we're in
good shape let's go here so this is my
live one and close some things down all
right so this that's what this guy is
right here and let's do this and it's
hard to see isn't it one other thing
I'll show you here so long directory
down and yeah let's do this
yeah to you live and running all right
let's do this
cube stew back cube tails
live and ready if you guys this is
another great tool for you guys to look
at cube tale don't blow the project live
one all right let's tube CTL get pods so
one thing you'll see also we have the OC
command line as well as cube CTL command
line cube cuddle some people say you can
kind of go back and forth basically if
it works on the cube cuddle side I'll
work on the OC side OC just adds stuff
on top like things that are unique like
a bill does a good example I have a gig
actually issue a build command right now
in this case I want to do cube tail is
actually a back
you can download and the cool thing
about it is it matches all pods with a
name so in this case I have two pods
running you can see and there and and
actually you know it's going back and
forth and lecture looking at those is
tailing those logs so in this case don't
you guys have heard cube tale before
it's a great little script in this case
you can see my readiness and liveness
probes are being called and now if I
come over here and let's kill it as an
example to do lords kill one of them
we'll call the prepare to die all right
one of us marked for death now basically
now it's going to return a negative on
that liveness probe and kubernetes will
realize it needs to be killed do you see
it says mark for death and go back over
here and you can see you can kind of see
it going through its redeployment
process right now so it's restarting it
for me so any kind of business object
where you actually can write you know is
my application okay or not okay and
we've done this historically right if we
had stood up any kind of public website
law maybe we even hired a third party
that would pull our website hit
different URLs to see if the site was up
you kind of get that for free in this
group Nettie's architecture but that's
part of the magic that's how it knows
things are okay or not okay and actually
QTL does fail once it gets disconnected
from the dying pod but you can see we
had one that was an error right it was
no longer live and it's in the process
of bringing it all back up and let's see
here okay and we'll just continue we'll
just let that go but for now let's kind
of jump back in here so I want to kind
of show you to show you another example
of this so that's live and ready okay
step two
all right so let's put that let's try
this I'm going to make it stuff up as I
go but I'm just changing the code that
basically you know gets that end point
basically on the route it actually
returns this let me do this now so may
then clean fabricate deploy so I can
redeploy it also in this case is going
to go through the build process of the
maven build produce the docker image so
you'll see a docker build and then it
will push that into the open ship side
of things right into the kubernetes
kubernetes environment we use something
here called s2i you'll see that go by
so there's our docker build pushing
damage and then it gets rolled out and
then it has to go through its deployment
process let's see if that's working
let's see here and there's going through
its deployment process now and actually
trying to start the new pods based on
the new code that I just pushed out
there and so that's all managed for you
and you can kind of just play with it
and now and then again I would recommend
you try some of this stuff with a local
mini shift or mini cube like I'm doing
here
okay so just keep all that in mind kind
of recap this real quick let's see here
in the case of a typical docker world
right you'll do your standard docker
build okay you'll do your standard
docker run if you create a pot around it
you'll just simply do cubed CTL create -
a few so you see crate - f a lot and
you'll see a bitty yamo like I have here
and this is the animal that I had
earlier okay for a very specific vertex
application so in this case I'm building
the vertex application running in a
kubernetes and that's how you get a pod
started typically there's always some
form of docker build cube cut' will
create that's the pattern use but with
the maverick on a maven fabricate plugin
you can kind of use that to automate
this step automate this process make
sense so far but with you fast all right
let's keep going okay there's some other
things I want to show you there let's
see yeah let's see what I have running
out here and I'm using OpenShift
console to kind of loudly see things
visually so I have live one okay and
actually let's do this - a OC delete
live one so OC again is just a command
line project there we go yeah okay and
you can see that one's being terminated
now all right so let's jump back over
here and rock through these few more of
these slides so you know getting a new
communities world can be relatively easy
once you understand all those animals or
something like the maze in fabric bloody
plug in I have a whole series of steps
to walk you through if you look at a
particular git repo and you can kind of
learn it from that perspective
we we talked about jazz humble already
but the concept of employment pipeline
is super-important I don't have to have
the deployment pipeline Jenkins file
demo working on this laptop but you kind
of give you guys some examples of that
you can do a Bluegreen deployment fairly
easily you basically do the automated
build on of your docker image the
immutable image that moves from
development to QA to staging your
production and then when the lands in
production if blue was the last one that
lands on green and then you just switch
the load balancer back and forth and if
things have failed it's easy to turn
that you know turn it back around this
is super easy from a kubernetes
standpoint it takes almost no effort you
kind of get this for free all you do is
switch the route or switch the service
depending on what layer you want that at
the so that's actually very nice if you
never had a Bluegreen deployment option
before it's like superpowers for you
right it's a whole new thing but one
downside to Bluegreen is it's all or
nothing all the users get the new green
or all the users get the new blue you
can go back and forth but all the users
get everything there's another option
and that's the Canary deployment where
you can just get a fraction of the users
to a specific version the concept of the
Canary as we talked about earlier came
from the canary in the coalmine so the
idea here is that you take literally a
canary a bird into the coal mine as the
bird dropped over dead you knew that you
had a problem in that coal mine you knew
that there is poisonous gases in the
coal mine so one thing that's where this
idea comes from so the idea is it's
still an immutable image bill just like
we saw earlier that you're putting in
there production it's just that it's
landing in a particular location
where you're only going to in a fraction
of traffic to it and again it's not very
hard communities so you're going to put
the canary out there if it lives you're
going to increase traffic over time okay
grow it grow it grow it and if you have
to roll it back so this allows you to
deal with a certain fraction of users
and if you want to get super
sophisticated you can actually say what
types of users now that's not a
kubernetes specific feature that some of
you would add on top but well I only
want ILS users to see this feature only
one employees of the company to see this
new version as an example let those
folks test it before we roll it out to
everybody let's say but you know that's
more sophisticated in a demo I have but
I want to show you a couple other things
in this context the concept of canary
actually I've been doing that
presentation out for a while people is
it great now we have Bluegreen
deployments canary deployments
kubernetes makes it super easy yes super
easy but they're always stateless by
default because that is the nature of
cloud native applications we always say
from a 12 factor standpoint you have to
be stateless right that was when the
rules say plus one of the common
questions I kept getting from people was
well what if I'm not stateless
I've not built stateless apps my whole
life I've only built stateful apps my
whole life as we're at a build business
application so how many business
applications have you heard of that have
no data right now state so the idea is
how do you maintain state across a
canary deployment or even a rolling
update so let's see if we can kind of
show you that and this is a demo I ran
earlier in the quickie but I will try to
walk you through it a little bit more
simply so a real key to the magic here
does rely on the readiness probe but
basically you start the new pod and when
it's ready
meaning it's connected all the other
memory needs to connect to it's actually
populated as cache then you know you're
good to go
basically it's replicated a state from
one pod that was dying to the pod that's
now living and then of course you just
want your living you're often going and
then you kill the other guy who doesn't
have to be there any longer so it's
actually a pretty simple idea takes a
little effort to figure it out took me a
while to figure it out working with the
team to make this demo run but let's see
here let's so all these examples you
know the hello boot we kind of ran for
you there but there's also the live
already that kind of showed you that one
also and then there's the concept of a
simple canary and then Infini span so
let me show you this let's see if the
simple canary or run for me real quick
let's see here
okay go back over here I've had that
guys still running right so this is so
we have two of Aloha running here and
kind of see what it looks like okay it
says Aloha one and if I go over here to
this little window here yeah let's see I
have these little scripts that help me
pull things and kind of see that the end
point is up in live all right so this is
polling it's hitting this bigger set of
pods there's two pods there one thing
that's important note because there's
two pods right you can kind of see
there's two different host names there
because all this code is doing is
returning the host name every piece of
code that you write from a Java
standpoint thinks it's on its own unique
host right it thinks its own
server so that's what it's doing is
returning the hostname which of course
is the pod name if I drill down here and
look at the pod names you can see
there's the two pod names right there
okay so there's two in the replica set
but again that service the community
services sitting on the front so it's a
load balancing for free because by
default curl doesn't care about
maintaining a session you can do that by
adding the cookies but we're not going
to do that for now let's see now let's I
go in here make a change this code right
here
yeah this one this is a vertex endpoint
this case so it actually sets up a
little differently and let's go to just
make this BRR I'm originally from Hawaii
so that's why I like a little hotter
okay but I'm just going to change the
code and if I do this correctly I can go
over here
yeah and let's see if I did this
correctly
maven clean fabric cake employees same
pattern you saw earlier and it's going
to go through the build process there
goes oh in the right place well this
one's not I didn't do that specifically
here that should be important to note I
want to show you a different way of
doing things so I confused myself so in
the readme file actually walked through
the different steps to set up a canary
purely with OSI command and just all
command line druid right when there's no
automation if you will just see every
individual step and one of the things
that I've done is I actually have that
build process set up just purely as a
command line so you basically start
build a project again let's see here get
projects I'm in the wrong project and I
see you project and simple that's why I
couldn't actually execute that command
so basically I've changed name space
change the context let's see if we can
get our build to go now
so it's actually doing the build so
there's the docker build flying by there
that went real fast and you can kind of
see we should have had a new build to
this guy and if we did things correctly
let me scale it up so this is basically
just changing the replica count if
you're familiar with kubernetes oh and I
actually have an old version that image
out there because the new image has not
rolled out yet
okay so let's see here oh you know what
I did it helps if you actually compile
the code maybe I'm cleaning compile
again this is more of a manual option
all right so let's compile the code so
with all my mistakes are making
hopefully you guys are learning
something from that right like practice
more if you're going to do a public
presentation that might be what you're
learning but the but you hopefully get a
chance to see some of what's behind the
scenes here to what you know if I forget
to actually do a compile it does not
work
hopefully I saved it this time I got the
docker image built with the write jar
file this time and there's a lot of work
okay
and again the simple example is if I
just scroll this down scale this up we
based our changing the percentage of
users on that new version and in any
given point if I decide hope things
aren't going well I need to rollback
I can so you can see we're mostly Aloha
burn now based on our percentage and you
can have really fine-grained percentages
here I'm just actually manipulating
these number of pods but actually roll
back roll them back up roll that all the
way down and basically take it right out
of production so our concept is super
powerful this allows you to do something
like test and production now because in
most cases no matter how hard we work on
the front end of our to plan pipeline we
know exactly how our developer
workstations are set up exactly how
those imagers have been created we know
everything we can possibly know
production is always a little bit
different isn't it than everything
before it right even before staging so
this allows us to actually test in
production and get a little bit of work
load out there and see if it works or
not and with something like kubernetes
and upshift on top and makes it super
simple okay all right and again all
those instructions are in that document
but let me show you one is a little bit
more interesting here and I have a I
have an elementary one and if you're
normally like to teach and teaching
takes several hours but let me kind of
just walk you walk you through this
briefly so this is I call it hello world
and finish man what this allows me to do
is add stuff and delete stuff from the
cache right basically interact with the
cache and it's all in memory hundreds
enter memory here across those pods that
you see coming and going and what it has
is kind of a clever
ready or not right so this is the
readiness probe we talked about earlier
and it basically says I am NOT ready
until I know that my cash is ready I've
joined the cluster from a memory and
memory standpoint cash is good now I'm
ready send me load so that concept is
actually fairly straightforward doesn't
take a lot of code here you can see the
ready or not and if I look at the yeah
Mille for that okay this is the
deployment llamo saw earlier you can see
there are some job options where we're
constraining the JVM one thing to watch
out for Java it tries to use all the
memory on the host and all the CPUs on
the host by default you have to kind of
say nope you only have access to this
constraints and resources because I'm
running several of you simultaneously
and you can see the ready or not right
there okay so it's going to make an HTTP
request it's going to hit this guy and
this guy's got some logic right here and
it's either gonna return a 200 ok and
the way you basically say you're not
healthy to return something beyond 400
whatever that might be so the rules
between 200 400 is good Beyond 400 is
bad it's kind the idea and it will pull
and continue for as long as it can now
using that same basic concept we have a
more advanced version of this
presentation more advanced version this
demonstration and that is specifically
around this thing called the movie store
I think is still running here ok alright
so let me show you this because this is
more like a real-world application
fell on my team named kamesh built this
just in the last couple days last couple
weeks because we want to show something
that was a little bit more advanced than
just hello world
so this is more like a real app ok let
me see if I can bring it all up here and
so right now all right
there's nothing in the shopping cart
right now for any of these guys alright
but let's add some stuff let's add some
stuff to shopping cart so this is more
like a typical real-world app so they
have now three beauty and the beast'
there notice also that is the host name
that this guy is tied to ok because
there's still a real computer back there
if you will it's is highly virtualized
it's talking to that guy if I come over
here and actually update update this one
ok go to the card you can see here that
one and you notice those are the same
servers right there the 8 RFC 9 and
let's try this one all right and add
and then oh I made it got a scale it
properly all right and those are
actually all tied to the exact same pod
let's go over here and look at it movies
and see how many pods that you have
running and I have two pods running and
the name there so this there's that
there's the 8 RF see what it's paired
this system has gone slow okay because
what happens we run too many things but
here we go alright so there's the two
pods that are in questions so my Java
code is running on both those and again
the ideas here returns its URL din okay
what's happening there the code for this
is actually relatively straightforward
though it is a full spring based
application based on spring but--would
time leaf as the the templating engine
and it's using spring sessions so these
are just regular spring sessions we're
interacting with here okay and in finis
Bandos making sure that that spring
session lives beyond a rolling update so
if i come beyond if i come over here and
go into this piece of code okay and
let's just change this to ver here and
we're to have this guy running okay OC
project Louise switch to the right
namespace and let's do a canary
deployment okay in this case we actually
have two profiles set up you'll see you
will see specifically the the deployment
yeah Mille we need specifically for the
original one and then one for the Canary
and they're only slightly different the
primary thing is that on the canary side
we actually deploy with zero replicas
and on the main one we ployed with two
replicas so that means we have a two and
zero out of the gate and if all goes
well let's look over here at our user
interface okay and if we got those guys
deployed to tail and these guys are
popular movie store all right let's see
what those looks like ok so they're up
there they're not producing much in the
way logs but let's go ahead and run that
guy see if they'll come up for me
and actually we'll go and take it up to
two so in this case it actually takes a
little bit longer to start these guys
because this is doing a real work alone
it's not hello world right it's doing
everything you saw on that user
interface in addition to maintaining all
the state across those shopping carts
and so as you add things to the cart
those things stick around so like if I
come back over here and add something
else
okay symptom don't add that to the cart
look and by default alright so there's
the two things in the cart there so you
again you can kind of see this is
actually a little bit slow in the
startup and there's a reason for that we
want to ensure that all the states being
replicated there's one coming online and
so we specifically in our deployment
descriptor have an initial delay for the
health checks at 30 seconds that gives
plenty of time for things to warm up so
by default you have an initial delay you
have a timeout and you have a period how
often do you want to check that that's
all part of kubernetes for a checking
standpoint and we're simply manipulating
those to make sure that we can get
everything in the game okay so let's see
I just killed one of these guys let's
see if our first shopping carts are okay
over here where they all go all right
and they look okay so far but here's
where it gets interesting let's see here
okay so we're still good from that
perspective let's go ahead and finish
killing it alright take it all the way
down alright so if I did an okay job
there of all this yeah all right there's
the BRR movie so again we've now rolled
out the code change for the state but
the shopping carts are saying so if I go
over here let's try that one alright BRR
movies again the two items in the
shopping cart is still there and if I go
over here so this is the last one with
the old you know the old data
there's BRR movies and you can kind of
see there's the original state so
concept of the canary rollout and being
at incrementally roll things out I
believe is a very cool feature of all
this environment and we are basically at
a time so hopefully you guys got a
chance to see that all this code is out
there
I want you guys to try it stop make a
noise and a couple things to wrap up
with all right I forgot I didn't have
time to talk about sidecars but because
the pod can contain two containers one
thing you're going to see us working on
is specifically this concept here right
here by default you got all this code
that goes that kind of goes into your
business logic for doing things like
history tracing and things of that
nature with the case of the side card
that all gets sucked out into a separate
set of logic and Envoy is the one we're
particularly interested in because the
C++ base if you're running a node.js
application you don't necessarily want
to run a whole JVM as a sidecar and it's
actually a way big sidecar but do check
out mini shifts mini cube to fabricate
maven plug-in you don't worry about
eureka and ribbon in this architecture
that you get that for free if you want
all the instructions for how to do
Bluegreen deployment Canaria deployments
things like that and micro services we
have a whole instruction set out there
for you check out those readiness probes
and this last github repo is those
specific demos I was just showing you
all right and my time is up but I'll
happily take questions down the hallway
it looks like I've managed to fill up
the whole 50 minutes or so all right
thank you so much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>