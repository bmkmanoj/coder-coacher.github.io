<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Functional patterns for scala practitionners by Clément Delafargue | Coder Coacher - Coaching Coders</title><meta content="Functional patterns for scala practitionners by Clément Delafargue - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Functional patterns for scala practitionners by Clément Delafargue</b></h2><h5 class="post__date">2016-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/iRGcbCvrtiw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone tonight I will talk to you
about how to write skala code in a
functional style I know that's the last
slot for today so please try not to doze
off and follow me I I know it's hard but
let's try it together okay before the
rest i'm working at clever cloud when I
to automation company basically you get
push code and we make it run in
production so updates auto restart 02
scalability boring things we undelete
automatically and you you can focus on
your coat we have a few customers and
one of them is debug so we're happy to
host as a CFP and most of the websites
of devack so if you have questions about
platform as a service I to automation
and if you want t-shirts and cool
stickers I come to me after the talk and
we can extension on that now I have a
shitty clicker okay i'm online so if you
have questions or remarks or if you want
to like you ask more questions
afterwards please ping me on Twitter I'm
clementi and this way we can talk on the
written medium and let other people take
part in in the discussion okay so with
that done back to business I'm so I'm
CTO at clever cloud but I consider
myself more as a functional programmer
than anything else and most of my job
except city of stuff when I still I'm
still able to to code is to codons in
Scala and j s to start who's writing
skala professionally or not at work
okay i will give a few examples in skala
i will try to explain the syntax and
stuff like that so that people not using
tskalikan can follow okay so first
pattern really interesting functional
pattern in enterprise codes it's as I
gusto mo fig prep formalism the type
signature should be enough with the type
classes it makes enough sense and unless
of course you want to generate
generalized 0mph ism but that would be a
subject for another talk most seriously
I won't talk to you about like
well-known names in functional
abstractions I won't talk about functors
of monads of stuff like that I will
click I will talk about how we are built
to implement it and all we are able to
express simple patterns in a functional
way and when you able to do that then
using these abstractions like funk
terminus it makes sense and it's easy to
pick up but today it's about
implementing those patterns and really
basic stuff okay please remember that
just examples and since our patterns
there are many ways to implement them i
will try to express them always as a sim
in the simplest way so that it fits in a
slide and it's easier to understand but
please remember that in your code base
you could as you want and there are many
variations of these patterns and it just
patterns that I happen to find useful
but skies is about letting you choose
your your style so it just me saying
that don't take it for granted okay so
first thing to know about Scala is that
it's an it's a language that was
designed to mesh object oriented
and functional programming because the
creator of the language Martina dusky
always said that object orientation is
not contradictory with FB it's a list it
says it's also Colonel so normally the
two should not interfere and you can
choose a style you want some time you
want FP style some time you want an
obese type the issue with that is that
many people find lots of documentation
about doing object oriented stuff in in
skala because it's kind of close to
javas the object model is a bit more
evolved than in java but it's close and
there is lots of documentation when you
try to go to the FP stuff however you
find that many people expect you to
already know Haskell and said oh yeah it
justice Scalla implementation of this
pattern in Haskell like nothing to see
don't worry and that that's why I gave
this talk because I spent many times
talking with customers at clever cloud
and companies i'm helping writing Skala
codes i kept on repeating these patterns
because they weren't well known in other
languages but not as well known in the
scala community ok so most of the
patterns i will i will discuss are not
really functional in nature just that
they used to get to a functional style
and they commonly used in functional
languages but some of them are available
in imperative languages like rust for
instance modern languages so first
question what is FB there are many
definitions and the most common one says
it's its programming with function the I
prefer another one which is programming
with value and in functional programming
your program is not it is not a series a
sequence of steps that you execute in
other in functional programming your
program is an expert
that you you reduce you interpret it and
by interpreting your expression then
your program is executed and one thing
that that that means is that control
flow though how your instructions are
executed in a imperative programming in
functional programming it becomes a
value you're the control flow of your
program becomes a dependency graph
between your values and that means that
in skala almost or everything almost
everything is an expression except no
not accept especially control structures
so you don't have a ternary operator in
skala you don't need it because the if
block is already an expression so the if
block is not a way to jump at arbitrary
places in your program it's a way to
construct a value and expression and
that means that it's checked by the type
system you can't have branches with
different types and then use this value
in skala your if blogs have to be
imaginary and that means also that if
block with it without an else block it's
it's a strange because you're you you
need to to express every possibility and
at the same thing with pattern matching
pattern matching is you can see it as a
switch but the switch has really
impressive taste like it says James is
James air and spaten matching in Scala
is a way to express different
possibilities and act with the
hypothesis validated by these
possibilities so pattern matching not
only allows you to split cases it also
gives you access to bound variables and
that way you are able to act on
different structures and produce a value
but remember that producing a value is
always at what matters and this kind of
reasoning it's the same in all
functional languages or when you use
functional side it goes very well with
typed functional programming because
since your program is a huge value then
you are able to let the compiler help
you with your control flow and not just
your value so that that's why type
functional programming is such a sweet
spot that by switching to expressing
everything in values you were able to
have the help of the compiler and not
just bailing out from compiler support
every time you do a four and if with
functional programming then the compiler
can check your control flow and not just
your affectations so with that in mind a
way to design programs in functional
programming high school algebraic design
it looks like the term can can be scary
but it's it's like a domain driven
design but with functional tools
basically you observed your domain you
create a model of your domain and then
you implement it and the first thing to
do is that asking yourself how can we
model data in an object-oriented style
we would have object with values and a
behavior that the idea of object
oriented programming you put behavior
and data at the same place because it
gives you encapsulation in a functional
style it's a bit different we tend to
use something called algebraic data
types which I gave a quickie yesterday
about so you've attended it or not yeah
a few loyal customers great I will go
quickly through it but an algebraic data
type allows you to represent two kinds
of values some or types some types and
product types first one product type is
about putting
different values of different types
together and constructing an aggregated
entity so basically in Java it would be
bojo in skala we have this very
interesting concept bull case class
which gives you all the boilerplate that
you you you write for foreclosures for
free so you have a right equals hash
codes to string stuff like that it's
automatically done by the compiler back
because you tell the compiler I just
want to put these values together and
have an entity representing them you
also have two poles a lightweight and
it's a bit like a real case class but
with less support and less clarity
because you can you're not able to name
anything in it so to construct it you
call the constructor and put several
values together and the elimination is a
really similar the pattern goes to the
left of the equal sign but basically
it's the same size it's the same thing
you either in one case you put values
together and in other case in the other
case from a group values you extract
them to have individual access so first
thing like to model a simple data in in
skala you should be using case classes
always if you have a class that sees
only there to handle data then it should
be ok / ready in some cases maybe but
that rule of them and it's called a
product type because it's like a
cartesian product and i can go on and on
about it because i found it very funny
but if i do that i won't have time to do
the rest of the talk so as some type is
less common construction in a language
it's also called a disjunction alka
product if you want to sound very
category theory guy and stuff like that
but sometime is like some type is okay a
simple example I think very big way to
this example of
type is that I have a value which size
our string a number and object on the
right roof also know you know it you
recognize that pattern it's adjacent
value so in JSON you have either one of
these possibilities and that that's what
some type is it just different
possibilities and you have one and only
one of it in Haskell you have direct
support in the language so you just say
it like it is and in skala you don't
have direct syntactic support for it but
the object model is sufficiently
advanced to let us encode it in a proper
way so we use something called silt
right I still try to the trade that you
can't extend from outside the file in
which it is defined so it's like a
better than just saying this classif is
final and nobody can extend it you say
only class is declared in this file can
extend it straight and then the compiler
knows that there is a limited number of
infinite number of implementation for
your trades so let's say if it's a null
it's okay subject I don't carry a value
if it's a JSON boolean I carry a value
and I say that time a JSON element and
so that's the way we declare it we
construct it and to work with them we
use pattern matching so in the same way
we said its size of this or this or this
when we deconstruct it we say if it is
then I can act with that and that way
the pattern matching really shines
because let's say you have a JSON
boolean then the variable V is defined n
is a boolean and if you like remove this
piece of code from the pattern matching
block then the variables become unbound
and your code doesn't compile anymore so
it's way more powerful than just putting
a Gordon and if
and then doing potentially unsafe
operations and another good thing with
that is that if you forget to handle the
case then the compiler will issue one in
thing you forget this case I can't go on
since it's a manual encoding we are able
to like trick a bit the model and get
some nicest if you've read one of the
definitions of one of the rfcs and
different documents trying to describe
the should show that Jason is you will
know that that in some declarations
adjacent value should only be a
top-level JSON value should only be an
object or an array you can't have just a
JSON string doesn't make sense with silt
rights I can just make my case class
extend to citrate and this way I can
share structure between two different
subtypes so it's it's really effective
when you have two different subtypes
which share a common structure then you
can just declare it instead of
duplicating everything like you would do
in high school for instance so it's a
bit more powerful because it's manual
and it's some cases it can be really
useful so on opie for strip shows like
that you would add method on classes and
let the dispatch beyond all this way
when you're working in a more functional
style with a DTS then you add pattern
match to have behavior outside from the
different alternatives and it means that
in up it's easy to add to add cases you
create a new file you implement all the
methods it's supposed to be implementing
and then when it compiles you can ship
it or ya in FB it's easier to add
functions you add a new pattern matching
block and also cases and then
it's done and that's the expression of
something called the expression problem
which which shows a divide between Opie
and FP it's a way you have extensibility
so in inst for instance in JSON we can't
expect json to be extended to new types
anytime soon so I did is make perfect
sense because you may want to add new
operations working on Jason but you
won't add a new type in JSON in other
cases it's different and that's a good
thing with Scala you can you get to
choose which side of the expression
problem you want to sit on and it can be
a different side and inside inside the
same project so that's a really good
thing with vizcarra personally I'm much
more comfortable in the adt side I find
it easier to read by separating data
from behavior but your mileage may vary
and choose your own style another
question with that is that should you
use your own algebraic data types that
you create yourself or using already
like already defines things like to pose
for instance these two these two
expressions are structurally the same I
can go back and frost between the top
pole and the case class without losing
information in the second case it's just
clear for me as a programmer that we're
handling within entity representing a
user but I could do that with a tuple
and it's the same for detention we have
either in skala letting us declare that
so my rule of thumb is that you should
always go most of the time go towards
enroll eight it is because it will be
cleaner and easier to understand and it
will avoid you silly mistakes but in
some cases like if you're metod written
the top when you deconstruct it right
away
give the value to anyone else then use a
topple a seminal example would be the
split function on list it returns a
double because you don't want to end
other special case class define just for
that at least if you're not programming
in Salem okay so this one I would I
would really like to take time to talk
about it but it would eat the rest of
the talk and anyways I talked about it
yesterday basically the idea that we
call them algebraic data types because
they behave like an algebra and
intuition you have on simple arithmetic
expressions like addition and
multiplication they are carried over to
algebraic data types so you can think of
algebraic data types like the same way
you think about solving a simple
equation and it's tremendously useful
when you're designing data types you're
trying to go back and forth between
different models trying to see if one is
better than the other thinking about
them with the algebraic properties allow
you to have a clear intuition that two
types of the same structure but my I
could talk about it for hours so I will
suppress myself and go and what's nice
is that all the like identities you know
about multiplication and addition you
can express them in terms of types and
it will give you insights about how
types BF and it's it's really
interesting if you're just curious I
recommend to do that like saying a times
1 is a what does it mean in terms of
types it's really interesting and it's
easy to do okay one concrete example
that I can take out of it that since
algebraic data types some types and
product types associative it means that
I can arbitrarily nest values
as I want it burns down that either you
have a really flat trees flattery of
types or you can have deeper trees and
for instance i use this equivalence when
I model database entities I go with a
very flat tree to be close to the
database and then I aggregate them into
more complete types for instance and I
know I can do I I know its equivalent
just because I know it's actually
associative anyway yeah I really like
this stuff so I had planned to a lot of
things ok so my lightning talk is
already on YouTube so if you're more
interested in that just go look at it
it's 15 minutes and hopefully it's cool
going back to programming with values of
course when you model addition
programming is values with values is
easy but the real difficulty is that
going to more real-world cases when the
values are not as concrete as they were
and what you do is that you put your
values inside context and you are able
to express things that were not in the
type system in values and get help from
the compiler the best example is 0 add a
really cute gif of kitten bursting a
water balloon and then going away so too
bad the option type is for when you
either have a value or you don't have it
so typically when only one thing can go
wrong then you can model it with option
that's what I mean by saying its
programming with contextualized values
the values I'm interested in we add the
context of its potential absence by
wrapping it into an option
and that's what you do in functional
programming every time you you have
context you want to add to your value
saying maybe it's not their man its
non-deterministic maybe it's a
synchronous then you wrap it in a type
adding information about this context so
in other language is option is called
maybe by the way so yeah option is
useful and its type we see when used
when we start skala so sometimes we try
to put it everywhere but keep in mind
that option should always and only be
used for a situation where only one
thing can go wrong else you're just
throwing away information and you're
throwing away structural information
about your program and its its runtime
which is a bad thing if you want to keep
track of what went wrong there is a type
called either and either has two
alternatives left and right on my katy
perry gives are not working it's it's a
shame so left the right values contain
by convention the expected value so if
everything went well then you have the
right containing the values the value
you're waiting for and if it's it's an
error then you get a left with the our
first thing and to remember and the
first error to avoid is to use an
unstructured data type to describe the
error typically using a string as an
error message you want to use an ADT to
describe the error message because when
you produce the error message you have
structure and information but what went
wrong and if you put it in a string then
you effectively throwing away this
information so using ADT to represent
errors the same way that in Java we use
type here are keys to represent
information exceptions and we just don't
throw a runtime exception maybe we
no but anyway an ISO string up something
it's a cut smile and you should try to
go back to something more structured so
you make your ID t and then you're able
to describe your instructor way and then
your code is able to work on several
kinds of error and in a very structured
way ok i'm very happy to skip those
slides because skala to point 12 was
relieved was released a few days ago
with a very very cool fix on either
which was previously not biased so you
had you had to say i'm interested in the
writer in the left and there was a pull
request merged which fixed all the
things the bad things i say about either
i'm not true anymore if you're using
Skala to point 12 so yeah you don't need
that anymore it's cool it just works in
skala to point 12 so thanks and i'm very
happy it's been five years I waited for
that so ok i will show you the problem
with either is that it's not biased i
told you that by convention the expected
value was on the right in the right
constructor and there is no map of flat
there was no map of flat map in either
up until two point 12 and you had to
project saying i'm interested in the
value on the right so you had to put
that right right right to have a proper
sequencing and there was different
quirks with return types you regularly
ended up with product with sizable with
with either and does that messed up a
bit type in Francis so there are
something called cats that X or or skala
see that
back slash forward slash and it was
basically a fixed version of either
which was biased to the right which has
proper type in Francine's and stuff like
that and since Scott upon twelve is
released with proper I so support then
the X or type in cats will be deprecated
so if you want to use it because you're
stuck on an older version then wrap it
in a type alias and it will make your
transition easier okay a problem with
our problem a specificity let's say of
either an X or is that they fail fast
it's just like exceptions when an
exception is fired then the rest of the
code doesn't execute and while it can be
interesting in many cases there are
cases which is in which it's not not
really what you want let's say you have
a huge form to fill with many fields and
you you feel it you submit it and then
you're told yeah this field is in error
so if you fix the field you submit again
and then it says that a second field is
in error because it stops at the first
error and that's a shitty way to handle
forms so in some cases what we want is
to be able to accumulate errors like try
everything in parallel and if everything
goes well give me the result and if some
things go wrong give me the errors and
there is something in the library cats
called validated which does exactly that
let's say I want to validate an email I
take a string and I product I produce a
value of type validated now
so in all my examples I did a very bad
thing I use strings for error types
don't do that but it was for the token
for brevity so either I produce a valid
value valid email or an error and it's
not just a validation it's a validation
now now stands for a non-empty list it
just guarantees you that if you have an
error case you have at least one hour
and you don't have the famous error
message saying yeah error everything is
fine with the non-empty list it gives
you the guarantee that you have at least
one error which is a cool thing and to
use it you call all your validation
functions you put them all together with
the home alone operator or the TIE
fighter operator pipe at pipe and then
if everything goes well then you're able
to construct your value and if something
wrong then you get your error and if
many things go wrong you get all zero at
the same time so in many cases it's way
better for the people using the API to
get all zero errors in one in one step
that doesn't mean that you should never
use either and always use validated in
some cases sequential validation makes
sense so don't try to have one type
representing everything you can always
have like nested types representing
different types of validations like one
type thing it's a low-level error and
then another type saying it's a user
error stuff like that so just look at
what the semantics of your error
handling are either its second shell
validation like one step is dependent as
a preview on the previous steps or you
can do parallel validation in that case
please use validated because it will be
better for everyone
okay half of my gifts of working in
that's a bit of a disappointment now
that we are able to describe values that
we are able to handle errors on return
types I want to talk about how you are
able to extend your program you make
your program grow and you make it
interact in new ways there is something
called a doc polymorphism there is
something I'm really not happy about it
the way the object oriented the
community hijacks the damn polymorphism
polymorphism if you if you talk about
polymorphism in an LP context then it's
about subtype polymorphism but really
polymorphism can have different types
and the types I'm interested in it's
called hey Doc ad hoc polymorphism and
you may know it as just function
overloading and it's it's nice because
it's really easy to use you just declare
functions with the same name but it's
not structural at all and that why it's
called a doc polymorphism and in Haskell
they wanted that but with more structure
and they came up with something type
classes which are really interesting and
really useful in Haskell and which are
really used in skala but nobody Delta
tells it or no it's better but a few
years ago everybody was using thai
places without saying type classes and
it was a bit hard to understand i will
show you a simple example with a monoid
do you know what is ammon ID ok it's a
big data abstraction it gives you
interesting properties like you are able
to combine two values in an associative
fashion which when you can split the
work do little
bit of work on different nodes and then
put it back together and you have a
neutral element saying if i combine
let's i combine a string with an empty
string i get back the original string
and left and right i first tried to to
model this that this abstraction with
scala would be to define a trade mono it
declaring an abstract methods called
combine it takes a monoid and it returns
the combination which is a humanoid and
then to use it you would extend it with
your type and then implement a combined
but there are many many issues with this
implementation the first one is that
since you're using subtyping
polymorphism you're losing information
so type signature I I put on combine it
says I take a mono it but it doesn't
tell you I should take the same type
everything that is the manner it could
be used and that's a problem since you
have to extend the trait to declare the
behavior you can't add behavior to final
classes so if you decline you behavior
you can't add it to int for instance and
it's a shame because int behaves as a
monoid and it's also hard to encode
stuff that is not that is static and not
an instance of an object how do you
think at the neutral element so our
solution with that would be to use an
external declaration you declare these
types behaves this way but you don't
declare it in the type and you don't
declare it in the behavior so for our
mono in the example that would mean that
we create a trait called mono it which
is polymorphic on the type which
implements the behavior and you say if
something if the a is a monoid then it
can produce a 0 of type A and given two
values of type a it combines them and
gives me a new value so you don't lose
information thanks to power
metric polymorphism y'all got AIDS
everywhere and it works you don't have
any problem with final types because
it's not its external so you declare the
ud class the behavior and you don't have
to extend anything and you don't lose
information allows it so for
implementation I say a string behaves as
a monoid so the neutral element is the
empty string and the concatenation or
the combination operation is string
concatenation and to use it I pass it as
a function as an extra argument let's
say I have a an array of many values and
I want to combine them oh and get a
single value then I I just say tell me
how is this type behaves as a monoid and
I I can do the work and then you can
work with strings with ends with
different any type you want of course
it's a bit tedious to always pass the
behavior so we want to automatically
ring and as we always do in skala when
we want to hide stuff under the carpets
we use implicit but that the only use of
implicit I would recommend you say
string behaves as a mono it this way you
put it in the implicit scope and then if
you want to know how string behaves as
dominate your resolve you implicit and
you get your behavior so the function
code all the way almost doesn't change
you just add an implicit but at the use
points you don't have to pass it anymore
and you rely on implicit resolution to
do the wiring for you of course it means
that you have to get only one behavior
for one given type and given behavior
because implicit resolution expects
values to do not be to not be ambiguous
so
this gives way to some signal type class
conversions and if you have two ways for
type 2 like to have a certain behavior
then you should wrap it or at least
express it in in the type system just by
doing a wrapper for instance that's why
what is done in in skala c and cats it's
a matter of discussion some people don't
feel that way some people are strongly
convinced that it is the only way and
other people should not do should not do
that but as you wish but it's always
better if you try to only have one
implementation for a given type and
given behavior it will simplify lots of
things another thing but it's more like
hardcore functional programmers saying
if you have a type class without any
lowes declaring how it should it should
behave that that type player should not
exist but keep that in mind and maybe
later google it but follow just modeling
an operation with type class is a good
thing there is a project of simulacrum
which does all the boilerplate for you
so all the instances stuff like that it
it just wraps it and it gives you a nice
syntax so if you're using type classes a
lot give a look or have a look at a
simulacrum and it may reduce a lot
boilerplate in your code and a very good
example of several easy of using type
classes with visualization if you go
through the Comets of the library
shapeless there is a comet of sadness
where am I Sabine is adding extent
sizable everywhere in the code because
spark civilization is based on this
terrible way to do salvation and some
people wanted to send shapeless
objecting spark so miles was forced to
to add this on all the library and that
the issue is not having an external
declaration then the type has 22 no but
all the behavior really has to to
implement so let's say we want to
implement theorizing something to json I
declared right thing I can transform a
value of type a into a JSON element and
for instance for a map I can sterilize
the map of string something to JSON if I
can sterilize this something to Jason so
I say provided that I'm able to
transform your values into JSON then I'm
able to transform map string the subject
into into jason and this pattern is
really important it looks advanced and
complicated but if you're using play
framework this pattern is everywhere
when sterilization is is concerned of
course JSON DB objects cry string
parameters forms everywhere so it's that
it's not told directly in the in the
documentation but this pattern is used
so you should know it if you want to
really use a nicely play and I say play
because at the framework i knows well
but any other frameworks use type class
by sterilization so just for
sterilization you should be able to
understand this as a spider and yeah if
you can read the code of the library
cats simple parts not the category
theory complicated parts but it's really
easy to read code base and if you want
to learn more about how type classes
work and how they can be used then
catches it's a code base to read ok so
next item once so we have modeled our
domain model with algebraic data types
where are modeled previously abstract
stuff like errors with values
no we know how to extend and to do
abstraction in your in our program with
type classes the next item is how you
are able to model tests and assertions
about your program and there is a very
interesting tool called property based
test which allow you to to write your
tests in a much more efficient manner
the problem with test is that they to
quote Dykstra they only show the
presents of pregnancy absence when you
write unit tests it's your
responsibility to prove that in some
cases its work so it doesn't work
whereas when you do it in the type
system then it's a proof so it's it's
okay for every value but because by
construction bad cigs can happen and for
the Middle where you can't prove your
property in the type system because it's
too complex but you want this kind of
reasoning thing I don't want to test
specific cases I want to declare
property and make sure it holds then UK
you can use something called scalar
check for instance i have three strings
and I concatenate them and I want to
know that the lengths of the lengths of
or no I want to know that the first part
of the string or the second part of the
string is is a string put in the middle
so instead of coming with strings by
yourself you tell the test framework I
run three strings three arbitrary
strings I don't really care which ones
and I just want to make sure that this
property holds and then the test
framework is able to test properties for
you so you get the kind of reasoning for
all values like you're asking the
framework for all a BNC strings please
check that this property
and it will try hundreds or thousands of
cases to make sure it helps and it's not
your responsibility anymore to provide
the test cases because if your algorithm
doesn't handle well a case because you
forgot your forgotten to handle it
properly then you want think about it
when writing your test and you want that
some something and somebody else provide
the test cases to to make sure that use
your sort of everything and you're not
skipping skipping steps so it's hard at
first to express properties but and
maybe you can't do it for everything but
try try to do to write tests in a
property-based fashion like even if
you're using a regular unit test instead
of saying the result of this function
should be literally this value try to
express it into a property like for
instance I have a program where i was
doing tree merging and instead of saying
the result of the merge should be this
exact tree which is not interesting i
was able to say if these two those two
trees are merged and i insert this tree
at this position then the result should
have the initial tree at this position
stuff like that and I don't have I don't
have literal values I just construct
properties in terms of initial values so
it's hard to do that at first but please
try to do that because it's very
efficient and even if you don't use
kayak you just use your type framework
it will just make your test easier to
maintain because it's terrible when you
change something simple and you have to
rewrite all your tests because all your
tests are based on literal values and
they check some some properties that you
don't care about so with that your test
become why
smaller and way 02 to extend okay once
you've done all that and I kid so fast
forward so don't expect it to do it in
two weeks but once you've done that the
next step you should try to do is to
separate effects from logic what I mean
by effects is that something affecting
the outside world something not being
just evaluating an expression so when
you do that your logic code instead of
doing what it's supposed to do you make
it produce a value in cutting its
decision and then you're able to test it
and then you have another part of your
card that interprets this decision and
do the actual stuff but by separating
those two pieces you are able to test
the first one it's it just function
calls so you don't have to to set up
States or god forbid the use max stuff
like that you just don't need it because
you take a decision and you encode it in
a value and then you inspect that value
that's all you also able to batch stuff
fixer stuff afterwards in fact when
doing that you are decoupling your
program and you're enabling yourself to
add modification or duplicating stuff
without changing the co logic so let's
say I have I have a piece of code that
takes user information and adds it into
the database instead of doing that you
have a function taking user information
and producing a value describing the
action you have to do or for bank
instead of directly transferring the
amount you issue a transaction saying
transfer this this amount of money from
this account to the seconds and then you
are able to replay stuff you're able to
batch transaction
you able to do what whatever you want
because you interpret your FX as you
wish so you declare actions and then the
expression we commonly use is to
interpret them at the end of the world
which means pfizer has the course or
program as far as well as a proverb all
right okay you interpret them as far as
the core of the program as you can
typically in the web application that
would mean you only do FX in their
controllers all your logic is pure you
take values your project you produce a
decision and then just before sending
like the response then you you do u FX
and you interpret your values this way
the core is able to do everything and
you don't have to worry about a if i'll
call this function will it talk to the
DB i don't know and you don't have to
think about calling function in the wide
order because it just values so that
gives you like a huge improvement in
testability because no more test setting
normal marks just checking values you
have a lot of flexibility you can badge
the duplicate you can log the effect
somewhere and you can place them back
basically what every every advantage of
event sourcing it's the same event
sourcing is doing that as the
architectural level but you can do that
at the program level and it works very
well and you can even go back in time
you can fix a bug retro actively by
replaying all the events with the fixed
codes and we please replacing the
buggers values just because you were
able to describe what you did instead of
just doing it and then if you go to
Scylla conferences people we start
talking about three minutes Freeman
Freeman that is just taking that step
further but you don't have to to use
Freeman as you can just
declare your action with case classes
and additives and it will already be a
really good improvement okay so to
finish first thing you ate it is to
model your data and please try not to
mix behavior and data case class is the
made for one liners though so case
classes like you just declare components
and you don't declare method on case
classes this way you have very very
dense and very easy to read declaration
of how your data looks like and then you
put God after that elsewhere don't use
knows or exceptions to declare errors by
putting them in values not only it's
clear for the programmer because it
appears in the type system but since its
values then your code is able to work
with them combining exceptions it's
really none it's really hard to do
because you have to do try catch and
stuff like that it's really complicated
as soon as your errors are modeled with
with data then it's just another
function you can combine them as you
want you can do what you want because it
just regular data to do abstraction type
classes are really interesting and are
really useful in scale so at least if
that the simple is the simplest way to
do it is like you're working on a web
application you have to hook up into the
stylization mechanism and you do that by
using type classes so take time using
type classes it's really easy to do
defining them it's another thing but
being able to hook up into type classes
is really important and really useful to
have proper abstractions if you can try
property based testing be advised it
takes time to get in the mindset of
testing properties instead of literal
results but when you can do that it's
really
it's a huge step for and then like and
maybe a few months is when everything is
okay try to separate logic from effects
maybe not in small projects it's not
useful but in big project I can assure
you that it will help you a lot and will
buy you mention le maintainability in
the long term so in really small project
in really small crowd projects maybe
it's not useful but in big project with
complex logic I can assure you it's a
good thing to do and once you've done
all that or while doing all that there
is a book the right book called the FP
in skala manning editions just read it
it's it's a really good read just the
first chapter is a great introduction to
functional programming so even if you
don't have time to read it in one go
just look at it from time to time the
way they describe definitions and
problem is is very interesting thanks
for your attention I know it was late
and I hope it was not too hard to follow
and yeah you can give Democrat a try
there is a coupon to extend the sir free
trial and know if you have questions I'm
all yours yeah you can upload if you
want Thanks okay three minutes left for
questions so shoot yeah
yeah so the question was about do I
suggest a framework to do property based
testing yes as this framework is called
scalar check and it will give you that
it integrates well with colitis and
everything so you can use it stand alone
but if you're already using skala tests
our integrations and mattress and stuff
like that to make it natural yeah
yeah that that is a trap with property
based testing if you if you like
replicate the algorithm in your test
then that's not really useful so what
you want to strive to do is to find
simple properties and essentially when
you have business constraints you go
from these constraints to the algorithm
and usually the algorithm is more
complex than the constraints so this
constraints are a good way to to write
your property based I think but yeah if
you're writing your algorithm in the
test and it's not useful and you should
probably you will probably better do to
to write regular tests so that's the
issue with property based estimate but
most of the time you are able to find
simple properties that are more simple
than the algorithm to to test ok ok
thanks I have stickers and t-shirts</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>