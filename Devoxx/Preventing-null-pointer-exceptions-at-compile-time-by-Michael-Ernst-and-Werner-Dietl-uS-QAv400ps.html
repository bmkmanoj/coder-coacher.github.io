<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Preventing null pointer exceptions at compile time by Michael Ernst and Werner Dietl | Coder Coacher - Coaching Coders</title><meta content="Preventing null pointer exceptions at compile time by Michael Ernst and Werner Dietl - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Preventing null pointer exceptions at compile time by Michael Ernst and Werner Dietl</b></h2><h5 class="post__date">2017-04-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/uS-QAv400ps" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello to talk about how to prevent null
pointer exceptions at compile time
I'm vanity tour from the University of
Washington what Lou and this is Michael
Ernst from the University of Washington
how many of you have written a program
that cast a nullpointerexception how
many of you have shipped a program that
cost in all contexts
isn't that something that's really
embarrassing in particular if you have
some security application and all the
client sees is a nullpointerexception or
like me last Friday when I try to call a
cab and I got a null point exception on
my mobile application now point
exceptions are very easy to run into and
very annoying for the customers and we
should do a best to try to prevent mal
point exceptions in this talk I'd talk
to you about how we can use pluggable
type checking to give you a static
guarantee that your program doesn't
contain null pointer exceptions I
introduced you to a tool called the
checker framework and we walk you
through how to apply it to your software
and we also discussed a few more
advanced topics
so the basic Java type system is really
nice and gives us certain guarantees
about the behavior of application in
particular it ensures that we never
assign a string to something that's
supposed to an integer so we have the
basic type safety guarantee that you
would expect from an object-oriented
program however we don't get enough
guarantees so let's look at this one
simple line example we have a system
that canceled a tweet line all the tests
always passed it always did what we
expected we ship it to the customer the
customer calls us and tells us there's a
nullpointerexception
does anyone know why this line of code
might cause a null point exception yeah
system that comes from my Twitter now if
you're not attached to a console system
the console is specified to be terminal
because you're running in headless mode
all of your unit tests you always manage
from the comment line you always had a
console attached and in the
implementation you just never bothered
to check whether yet actually attached
to a console it's a very simple mistake
to make and the specification for system
that console mentions days
but the type system doesn't help you to
enforce that you actually follow the
specification so what will talk to you
about this how to specify this behavior
and how to enforce it at compile time so
the first type system for this is the
goal for this is how the defense program
how to ensure that you don't have null
pointer dereferences so if you just want
to prevent your program from ever having
a nullpointerexception you need to make
sure that it never dereference is
something that's possibly null so we can
think of dividing all the data in the
world into two categories there those
that that's visible burner there are
those that are definitely non null and
there are those that might possibly be
not so here's a program Verner and I
wrote this together I wrote the library
at the top Verna wrote the client code
at the bottom we're pretty proud of this
code does anyone see any possible
problem with this code yeah sorry
oh yeah actually there's a null pointer
dereference bummer so where is the
defect I mean another way of pointing
this out is is the problem in my code or
is it Varys fault right so the answer is
it doesn't ever make sense to ask
whether programs correct unless you know
what a specification is so we need to
there are two things that might be wrong
one possibility is that I shouldn't have
written this get F operation and the
other possibility is that Vernor
shouldn't have passed null Lin and so it
depends on the specification all we need
to do is write the specification and
then we know what's going on here so one
possibility is that this routine is
supposed to take non null data in that
case we know exactly where the problem
is the problem is that null should never
been passed in the other possibility is
this routine is supposed to be able to
cope with null it's allowed to pass null
in and in that case the problem was it
was my fault for unconditionally
dereferencing this so in either case we
can see what the pro exactly what the
problem is so I want to give you a demo
of a tool that actually does this so the
first thing I'm going to do is to show
you some code that implements the tool
this is a code I wrote and it's wrong so
this we built a tool that analyzes your
entire program this is the part of the
program that analyzes array construction
operations like new int brackets and
there's a routine called visit new array
and what it does is it says it takes in
this new array a representation of the
new array expression your program it
figures out what method it's inside and
then it does some processing to a copy
information from the method on to the
actual new expression so this actually
failed
we got a bug report that it had a null
pointer exception I didn't anticipate
that do any of you see why this could
throw a null pointer exception
let's run the type checker and see
whether it can tell us where the
nullpointerexception is so what this is
doing is it's analyzing the entire
program to tell which values should be
our null possibly null and which are not
so what it's the error down here says is
that it found a possibly null element
and it expected a non null element and
that's right here in other words in
closing symbol can return null it turns
out that new int brackets doesn't have
to appear in a method it could be in a
field initializer or it could be in a
static initializer and we had overlooked
that so here's the fix that we put in if
it's not in a method then there's
nothing to be done and otherwise we just
do the rest of the processing so the
type checker is going to verify that
this is correct and in fact one thing
that's interesting is I didn't change
the faulty line of code at all the
faulty line was right here this expected
yet non-null but the system is able to
tell that because we've done this check
it's going to be non null here this is
cool we found a bug but we also have a
proof that there's no more null pointer
exceptions anywhere in this code and
that's really powerful thing to know I
wish we'd had our tool when we were
writing our tool let me show you another
example this one's in is a J unit test
and this J unit test is testing whether
then the null reference is equal to this
four character string are those two
things equal
definitely not let's see and the test
says it expects an assertion error
because those two things are not the
same let's actually just run this J unit
test I'm using JUnit 3G NAT 4.3 to run
this test and what we got was a
nullpointerexception
inside J unit JUnit crashed while I was
trying to run this test
so let's try to figure out what happened
there this is actually the source code
of JUnit 4.3 and we're going to run our
checker on this to see where that
nullpointerexception could be happening
so here's the first error that the type
checker points out it says that expected
right here might be null now if you look
at the rest of the program it's clearly
it's clear that they really intended
this to be non null and everywhere that
a value was passed it was passed as not
null so we'll write that down the type
checker will check it let's look at
another line of code here actually let
me go back to this pull the error back
up here it says oh one might possibly be
null so the code here is look looking at
an array and comparing each element of
the array so you have an expected array
in an actual array and oh one is an
element from the expected array Oh
Tuesday an element from the actual array
and the first thing that might happen is
maybe they're both themselves arrays and
you need to recurse but before you check
whether those are arrays themselves you
should check whether they're null
themselves because this would throw a
null pointer exception so the fix is to
first test whether they equal then test
if either one is null and otherwise to
fall through to do all this other work
and here is a final error in j-unit and
this is the one that we actually ran
across Jana was trying to print its
results when it fell over so this is the
format routine it takes a message and an
expected object in an actual objects
gonna tell you these two things are not
the same so one of the things that it
does is it very handily tells you the
class of each one because two things
might print the same but not be the same
that's a great thing to tell unless
those things are null so the fix is to
not print the class unless the value is
non null so if we rerun the type checker
after making all these fixes then the
type checker verifies that there's no
more proud
in j-unit that we fixed all the possible
null pointer exceptions in j-unit so
let's go back to our test and run that
this is the first piece of code that I
showed you and now the tests pass
so what we saw here was that this can
detect this tool can detect errors in
your code it can guarantee the absence
of errors and we also saw that after you
do a test it adjusts its estimate so
it's actually more clever than just
simple pattern matching any questions
about this so far everybody's good ok
great so what we saw is an application
of so-called pluggable type checking we
have the underlying java programming
language that gives us the standard
cavities that we would expect and the
add additional guarantees to that we add
this knowledge checker that enforces
that you never give offense null
pointers so we designed a type system
that implements this property and you
have to annotate your source code and a
few non this annotation specify what you
expect the behaviors and then you run an
analyst checker to enforce this behavior
and get it guarantee at compile time
that your program is now pointer free
how does type checking work usually you
get your source code you run the
compiler the compiler might give you a
go messages you have to fix these error
messages in one of two ways either you
have to add annotations to make the
compiler happy or you fix bugs in your
program hopefully they're more bugs to
fix than just annotations to make the
compiler happy once the compiler is
happy you get your executable which you
can run but you might run into runtime
exceptions you might get a null pointer
exceptions an optional type system adds
an additional loop where once the
underlying type system is happy we run
this additional checker that makes sure
that you never dereference a null
pointer you have the same kinds of
errors you have either a real problem in
your code like we saw in the example
there were three different kinds of real
problems in this code and we had to fix
them but there are also situations where
you might have to
add annotations to convince the type
checker that your program actually has
the behavior that you intended to have
the nice thing is this type check is
optional you decide whether you want to
always enforce it or only enforce it on
certain executions you get the
executable you could already start
testing and in parallel even the type
check and make sure that it's actually
now pointer fee another nice thing is
that you pick and choose what properties
you enforce we have about we have nearly
two dozens different type systems that
you can enforce and you pick and choose
which properties are important to you
and whether you want to enforce them for
your executable so the tool that we
developed for Java is called the checker
framework it's a framework that allows
you to specify pluggable type systems
for Java plugging into the normal Java
compiler
it's an annotation processor so from the
comment line you just call Java C with -
processor and any tool that knows how to
pass Java C compiler messages can pass
the checker framework compiler messages
so in particular we also provide plugins
for Eclipse IntelliJ and NetBeans that
make it very easy to run these type
checkers you just press a button and you
get the error messages in your code if
you have any other idea you just
integrate it as an annotation processor
and you get the output in your IDE we
provide instructions for how to run the
tool as part of your build system we
have instructions for ant may even
Gradle any other types of any other
build system you just integrate it as an
annotation processor finally you have a
live demo website but we have web
interface where you can enter small
examples and we run the type check in
the background so you can play around
and get a feeling for what properties be
enforced if you have a trick in all the
situation you can just plug it in and
see whether we detect that null null
nests problem and we also have a bunch
of other type systems or most of the
type systems from the checker framework
are also available on this website so
what's so great about type systems as
you already saw they can find bugs in
your program but I die fine dydt much
more compelling that these are
actually verification tools that give
you a proof of correctness in other
words you know that there are no more
bugs of that particular variety in your
code they also improve the documentation
essentially you're writing a
specification of your program and but
that specification is formally expressed
as annotations and it's checked so you
know that it's correct trying to make
your code simple enough and clear enough
that the type system can verify it
oftentimes improves the structure as
well and this could also improve static
tools for instance if you don't have to
do if you can prove there are no
possible more pointer dereferences then
the JVM doesn't actually have to do that
check and it could run faster there are
some negatives you have to write the
Domus annotations like non null or null
Abul though we have type inference tools
that'll do that before you and there can
be false positives where it says I can't
prove that this value is definitely non
null but maybe you can be for some
subtle and tricky reason so type
checking is a really attractive approach
to this as opposed to other possible
approaches because every programmer
knows how to use it every programmer is
familiar with it and it runs as part of
your compiler that means that it can run
on one routine at a time you don't have
to do a whole program analysis and you
can also annotate just part of your
program the nullus checking that we're
going to talk about today is actually
the most verbose of any of the type
systems we've built we're seeing about a
1 annotation 475 lines of code for other
types systems we won't be talking about
today the the overhead is much much
lower but one per seventy five lines of
code is still much less than the number
of changes for instance for Java
generics there are relatively few false
positives that we'll be showing you some
of those later on and in a class we
divided up the students into halves and
gave half of them as tool and half not
and then at the end we gave them all the
tool and they all said they wish they'd
had it for the entire time this this
tool is being used in here in Silicon
Valley it startups and a big established
companies on Wall Street other places
that people care about getting their
code free of null pointer exceptions
there are a lot of other choices you
might make we ran an experiment in 2008
where we compared the
the framework to to find bugs Jalen and
PMD so this table shows the result the
checker framework this is on a 4,000
line program for filesystem searching
the checker framework found nine errors
though I think the more competitive the
more compelling number is the second
column where we know it didn't miss any
now it didn't just report nine problems
it reported 13 problems four of the
problems it reported were actually false
positives the code was never wrong at
compile time but the annotation
processor couldn't the known this
checker couldn't figure that out and the
user had to write 35 annotations overall
that's essentially the specification of
the program the other tools none of them
found a single of problem Oh is there a
question yes
okay so that's a good point so findbugs
can utilize annotations at the time it
could not but now it can so it'd be good
to rerun this I'm gonna show you some
more data at the bottom where we compare
tools with and without annotations but
that is a good point find bugs as all of
these tools have surely gotten better in
the nine years since so they all PMD
didn't produce any false warnings the
others produced a few the neat thing
about these is you can just pick them up
and use them right away and that's a
really convenient thing to be able to do
so there are they're all IDE s today
we'll do this so if you give the ID yz9
years to try to catch up then we we ran
Eclipse and IntelliJ so for Eclipse it
didn't find any of these and we had too
much trouble trying to get it to to use
annotations to the results actually got
much worse for IntelliJ it didn't find
any of you wrote no annotations but if
you're willing to write annotations then
it does better so we ran its automated
inference tool we had to do that
multiple iterations and finally that
ended up with 925 annotations in the
program we then found the five of them
that were wrong and added three more
that hadn't missed and at that point it
found three of these bugs it still
missed six and it had one false warning
question so right so this is showing we
actually ran a number of experiments I
only have a few of them here so the
question is did you actually try do we
try writing annotations for Eclipse
we used IntelliJ with its nullable
default this is a bad idea don't do it
we tried writing annotations for Eclipse
but it ended up just making the code
really bad and it didn't find the bugs
we were that it didn't find the bugs so
again this is us trying to do this maybe
you would have better luck and the the
IDE integration is certainly really
slick for these it's nicer than our
plugin so I'll come back to this later
there's times when we want to use these
other tools because they're easy to get
started with and there are times when
you want to use a verification tool
because it's going to give you much
stronger Garon
t's great other questions okay so so
what does I just mentioned guarantees
what does a political type system
guarantee it gives you two different
guarantees the first one is that there
are no bugs of certain types so this
means there are no null pointer
exceptions in your code but you could
have lots of logic errors or quality
test errors or other problems in your
code the second thing it guarantees is
that all of the null inless annotations
that you wrote there thank you um are
correct so anytime you write something
that something is nullable or non null
then the system's going to verify that
that's actually true yeah that's going
to be true at runtime so there are two
caveats one is you don't have to run
these these are optional as Verner
pointed out later so if you don't run
them on particular code you don't get a
guarantee about that code you don't care
a bit of guarantee about native code you
don't get a guarantee about libraries
that you haven't run it on if you
suppress warnings then you obviously
don't get a guarantee about that but you
can just check part of your code and
that's what we recommend start with some
small part of your code that you really
care about the most important part or
the most confusing part or the part that
has the biggest problems the second
caveat is I already showed you bugs in
our system maybe our system has some
other bugs and it's missing missing some
of the errors in your program so we've
done a bunch of formalizations to prove
that the type systems are correct but
that doesn't mean that there's no bug in
our implementation our goal overall is
today people tend to use a lot of
testing and that's very practical it's
easy to do but it doesn't give you very
strong guarantees formal verification is
this beautiful dream of academics and we
subscribe to that dream we think it's
really great but it's not practical
today and our goal is to take
type-checking which is a powerful
technique and try to to achieve high
guarantees but also make it relatively
easy to use cool so we're seeing a few
applications of type systems now let's
take a different look at the syntax to
explicitly
type systems so in Java five Java added
declaration annotations so on the
declaration of a class method field you
can add meta information so you can
express that the class is deprecated
that EF getter said us you can suppress
warnings but what you couldn't express
our type system like properties you
couldn't express that you have an
undefined so an intern string and none a
list of English strings or none empty
array of English strings because we
didn't have the syntactic mechanism in
the programming language to express such
fine grained properties so Java ag8
sorry it's a Java it actually added type
use annotations which allow you to
express these properties as standard
java language regions so now you can
write you have a nominal data element
you have an intern string you have an
under list of english strings you have a
non-empty array of english strings so
you now have the syntactic mechanisms to
express these properties in normal Java
so that was one addition in Java 8 the
the synthetics can be used anywhere a
type can be used so it's not just on
declarations it's anywhere you have a
type use in your program so you can use
it in a variable declaration in a cast
in an extends class in an instance of
anywhere you have a type in your program
you can add meta information to it and
the child compiler does what it always
does with annotations it makes sure the
annotation is well-formed and then puts
it into byte code puts it into Java toc
outputs it in Java P but it doesn't
attach semantics to these annotations so
the semantics come from external tools
in particular the checker framework
defines these type use annotations for
now less and all these other type
systems and then V and force the
standard type system rules to apply to
those annotations so the compiler just
implements provides the syntax we
implement this in semantics for those
annotations one thing that we extended
in the checker framework compiler is a
backwards compatibility mode for the
longest time people were still using
Java 7 syntax but already wanted to use
type type annotations in the program so
we
extended the compiler to allow
annotations in comments which allows you
to write these annotations in the new
Java 8 locations but the source code
stays compatible with the Java 7
compiler so if you're still on Java 7
you can already start using the check
your framework you just need to put the
annotations in comments and then once
you commit to Java 8 you remove these
comments another thing that we added to
make the transition to the checker
framework easier is we have two separate
mechanisms to allow you to annotate
existing libraries we don't expect you
to annotate everything in your program
at once you start with your code and you
depend on external libraries so you need
a mechanism to specify the behavior of
this bytecode only libraries and we have
stop files when you specify the behavior
of these libraries and annotate the
charr files when you provide only the
annotation for external libraries and
you just put these child files into your
on your class path and the type checker
picks up the annotations out of it so
it's two simple mechanisms to provide
specification for external applications
and we provide the specification for a
large chunk of the JDK in particular we
have many novice annotations so the
specifications for most of the JDK is
shipped with the checker framework we
also have a few third-party libraries
but most of the focus has been on the
JDK ok
let's actually talk about type systems a
little bit because we've been talking
about how this analysis is just a type
system I want to show you what the type
system is it turns out that designing a
new type system is not as scary as some
people would have you believe I've shown
I showed the type system in the upper
right hand corner here it really just
has two types nullable is the super type
it's the top type and non-null is the
subtype it's the bottom type non-null
has fewer values the nullable does that
satisfy standard object-oriented
subtyping rules the default we use is
non null that's the opposite of Java's
default but that requires you to write
fewer annotations and it makes the
dangerous case explicit another thing
that's nice is that you write
annotations on method signatures
essentially you write method
specifications and you don't have to
write any
annotations and Method bodies those are
all automatically inferred for you
we should showed before that our system
actually unlike many type systems it can
give a different type to a variable on
every single line of the program so for
example um if you have a call to my
field hashcode well if my field has
typed nullable that's illegal that might
fail at runtime but when you're inside a
test of against my field not equal to
null the type inside the curly braces
inside the then clause is non null so
the type system knows to permit this
particular execution and you don't need
to declare a new variable or do anything
like that now it turns out that this
code does issue a type checking warning
and the reason for that is that method
one might reset my field to null you
don't know whether it does or not so in
order to what you need to do is to can
again your job is just to write
specifications it's the same things that
are already in your Java doc you just
translate them into a more concise and
more easy-to-read form in this case we
want to express that method one doesn't
affect my field and the system gives you
three different ways of expressing that
one is to say that method 1 has no side
effects at all another 1/2 is to say
that no method anywhere changes my field
from non null back to nullable and the
other is to say that method 1 gives you
a guarantee about the what the value of
my field is after it's executed let me
give you another slide about each one of
these mechanisms so for side-effects we
actually let you write three different
types of specifications side-effect free
means that doesn't modify any externally
visible state the the method is still
allowed to create objects side effect
those objects it's just that the outside
world can't see those deterministic
means if you call a routine twice with
the same arguments you get the same
result back out and pure means it's both
side-effect free and deterministic and
these one caveat I should point out is
that these side effect annotations are
currently trusted rather than checked
another feature that our system has is
lazy and is support for lazy
initialization so we have an annotation
called monotonic non-null so what that
means is this variable can be nominal
and it starts as nominal maybe it stays
sorry sorry this annotation starts as
null and it might stay null for the
entire program or it might be set to
nominal at some point but if it's ever
set to nominal it's never reset back so
you can think of this as lazy
initialization then the purpose of this
is to allow a client code to check it
once and then depend on it for all the
rest of the method and then the final
mechanism is to be able to write again
method specifications pre and post
conditions you can say this method
requires a particular field or
expression to be non null or the Tinch
it ensures that a particular expression
or field is non null after execution
completes let me actually show you a
demo of this so here is a program that
takes some calendars in iCalendar format
and outputs a textual summary of the of
your free times so this program has no
null pointer exceptions but the system
is not going to be able to tell that at
first so I want to show you how we can
actually figure that out so we run the
type checker and it's going to search
for any potential problems and it's
found five of them I'll go through them
in turn the first one is here where it
says if you look at the specification of
date/time that requires that if you set
the timezone you should set it to a non
null value you shouldn't pass in null
here but if we look at TZ one if we look
if we look at TZ one
then that starts out as as null it's not
initialized here at the very beginning
so what what I want to do is to so in
but this routine just uses tz1
so this routine which is called parse
time has a precondition it requires that
tz1
is not null so I'm just gonna write that
down the system will check that
elsewhere and then depend on it here
here's another use of tz1 again setting
a date time the problem is that this is
in the main routine it's certainly not
the case that at the beginning of the
main routine that tz1 is not null the
main routine is certainly null at the
beginning of the main routine this one
seems hard let's skip this one for right
now and the next one is also in the main
routine here the error says that tz1
might be null but there's no warning
about tz2 and that's because we have
this check right here again this is in
the main routine let's move on and that
one is to the third use is another use
of tz1 and if this is in a routine
called one day available and this also
has a precondition of tz1 being non null
your TZ ones a field it's not a
parameter so now that we've changed this
let's rerun the type system and see how
see what it's been able to deduce based
on this so the we expect that those
first the first and third errors should
be resolved they are but this is a new
area this is one that didn't show up
before at all we're making a call to one
day available that's a routine we just
analyzed we just added a precondition
and this says the precondition the
precondition that this about TZ one is
not satisfied so we have even more
errors in main than we had
for let's take a look at man here's
where TZ 1 is being used it's being used
on this line where I am now it's being
used on this line is being used below
the only place that can possibly be
setting it is process options so let's
take a look at at process options here's
the routine and if we look at it here's
the code about TZ 1 actually let me show
you T the Declaration of TZ 1 quickly
the user passes in a string which
describes a time zone it's in an Olsen
format like America slash New York then
the system converts that to it a time
zone that it's going to use everywhere
so this time zone string isn't set until
the options are processed and when that
set TZ 1 is also going to be set so
here's the code that actually does that
this call up here sets the all the
command-line arguments and then here's
where we set TZ 1 if TZ 1 if if we if
the users passed in a bad time zone one
that doesn't exist in your time zone
database then get timezone returns null
in this case the system fails out so in
other words process options always
ensures that TZ 1 is non null afterward
should people see that it doesn't
guarantee it for for TZ 2 because the
second time zone is optional this
program can print your calendar in your
time zone and someone else's time zone
if you're trying to coordinate with them
so now the type checker isn't verified
that although there's there's this field
that can be null this system is
determined that because you wrote the
specifications of how it's actually used
the system determined that those uses
are correct let's try to lie to the
system so suppose I claimed that both TZ
1 and TZ 2 are set by process options
that's not true because you can see down
here that
the setting of tz2 depends on whether
times that the second time zone was
actually provided so if we do that the
system is going to this isn't doesn't
just believe us that a routine actually
sets a particular variable it's going to
check whether that variable actually
gets set so in this case it's going to
say that that precondition is not
satisfied the tz2 precondition is not
satisfied so this is a way to do more
than just writing that things are null
or not in all but actually writing rich
preconditions that are relatively simple
to understand and and they reflect what
the program was doing all along
questions about this okay
cool so let's look at a few other more
advanced type system features that we
implemented in the checker framework one
situation that comes up frequently is
that you have a method that takes a
parameter and return some value if the
input parameter is null it also returns
now so to express this we have a so
called polymorphic qualifier pulling out
qualifier of which you can think like a
method type parameter so you depending
on what the input type is you have a
corresponding output type it makes it
easier to specify the behavior of your
program you don't need two versions one
that allows now one that doesn't allow
now so it makes it more concise to
specify your program let's look at
another tricky situation in Java so we
have this nominal field called name and
some when a program we developed events
name for simplicity we just calculate
the hash code can you think of a
situation where this might raise a
nullpointerexception let me add a few
lines this happens somewhere in the
constructor so my class is the class
that declared this field and within this
constructor we difference a non null
field it's a non null field so why does
this raise a null pointer exception a
faulting in it's a ization all fields
even the non null field start out as now
and in during the construction of the
object at some point someone hopefully
sets that non null field and then if you
try to dereference that field before the
initialization happened you will get a
null pointer exemption so we need to
handle this situation and if we want a
sound type system so we need to handle
initialization in the program and for
most programs this is very easy you only
set fields in your constructor you don't
invoke methods so but we allow you to
specify very fine-grained
what initialization patterns you have
and what methods are allowed to be
called on partially initialized objects
so we have three annotations for this
the default is that you're talking about
the fully initialized object most object
that you refer to our fully initialized
all fields have been set none now really
means that this field is
but during construction of the object
you talk about an object that is under
utilization and unlined Italy's Asian is
up to a particular constructive thing so
if you in the constructor for my class
all the super constructors already have
been called and you're currently
initializing the frame the fields for
the current class and then we have to
come and super type unknown in it
sensation where you don't know yet
whether that reference is fully
initialized or not and you use these
annotations to specify methods that
should be callable from the constructor
which is a common source for null
pointer exceptions but it's very tricky
to keep track if the overriding method
can access a particular field or not
finally one situation that we handle is
maps and how map that gets depends on
the keys in your map so here we have a
map gift that map strings - supposedly
non null integers in some way in our
code we have gifts that kept with a
particular string and then get the
integer value so we go to the primitive
type so the tricky thing here is we
don't have a guarantee that the string
pipers piping is a valid key in this map
and the specification for map that get
says if the key is not a key if the
value is not a key in the map you get
now back even though it's specified to
return on null values so for every map
axis you need to reason about whether
this particular key is actually
contained in the map and only if it is
can you assume that it's normal so you
need two properties the value type is
none now which are made explicit on this
non null integer and the argument key
needs to appear in the map so we have a
separate type system called the keifa
type system that specifies whether value
is a key in a particular map the nice
thing about it is that it's usually
inferred automatically you hardly ever
bite the key for annotation explicitly
let's have a quick look at a small
example here we have a dominators method
that takes a map from some elements to a
list of those elements and we want to
specify that the list contains keys back
into the same map so we specify this as
it's a list of khiva key for hash one
meaning this first parameter to the
method so that's the only specification
that we need we specify what the values
in this map represent and then we can
safely iterate over the map keys where
we know we iterate over the key set so
all values note are definitely contained
in this map so this access to PD
sasser's that kept note is definitely
not now and then because of the
specification we also know that the
values pet are keys in this map and can
safely diva friends the second value so
it's been a nice simple type system that
helps you guaranteed that the values you
get out of a map I actually not know
finally we developed the sound type
system so you've run into situations
where the logic for why the property
holds is too complicated for your type
system to understand so we provide many
mechanisms for how to selectively
suppress warnings on a very granular
basis the standard mechanism for
annotation processors is suppress
warnings where you can just say for this
particular type system suppress warnings
and you should use that on the smallest
possible scope so try introducing a new
local variable on which you suppress
that warning we also provide assert
statements where you can assert
mountainous facts that are too hard for
the type checker to find automatically
and we have a chapter dis describing all
the different mechanisms for how to use
these best finally we implement a few
optional checks to help you get rid of
defensive programming if you know that
particular value is not now there's no
point in you checking whether that value
is now so you already specified it you
rely on the type system enforcing that
property so we implemented a warning if
you redundantly check against null
values we also provides different checks
for initialization even of primitive
types there are fields of primitive
types
okay so I'm going to skip over this part
in the interest of time and leaving time
for questions afterward but software
failed you're really important you
wouldn't be here unless you believed
that it was important to get rid of null
pointer exceptions they can cost money
they can cost lives if you think when
you're trying to think about it type
system what you usually think about is
what is the bad thing that can happen
how can I divide all the data in the
world into two parts and what operations
should be legal and illegal and that's
exactly what we did when we were
designing the null in this checker we
thought what are the runtime exceptions
we want to prevent null pointer
exceptions what properties should always
hold that if you have a nominal
reference that should always be non null
and then you should only dereference non
null references and a lot of other type
systems that work in exactly the same
way and you can check out the checker
framework manual to see all of those
well some of those are about null
dereferences equality concurrency
different types of string
representations security and you can
always write your own too I want to
leave you with some tips for how to use
this the first thing is start small
start by type checking only a small part
of your code figure out the part of your
code that you're really worried about
where the most bugs are where the your
understanding is worst and only type
check properties that that you care
about we may ship 20 different type
checkers but that doesn't mean you
should use them all you should just use
one the pluggable type checking is
awesome because it makes the java type
system better but if your property can
be satisfied by the regular Java type
system and the regular Java compiler you
should definitely use that you shouldn't
start putting tight qualifiers in your
code the most important thing that's
come up is you should think about
writing the specification once you have
this specification then you can better
understand your code and you can verify
that specification so really think of
this as a specification think of it as
what the program is supposed to do and
about and the tool as proving that's
correct
and try to write good code don't just
randomly suppress warnings and avoid raw
types like lists you should always use
parameterize types like list of string
because if you're not willing to get the
standard Java 5 type system right then
you shouldn't be using pluggable type
systems at all don't
I want to contrast verification to bug
finding so in verification the goal is
to prove that no bug exists and in bug
finding goal is to find a few bugs but
at very low cost to the programmer in
the in verification the user has to
write the specification that's all these
at science the annotations in bug
finding the tool guesses what your code
is probably supposed to do in
verification the goal is no false
negatives if it says I can't find any
errors in your code that's because there
are definitely no errors in your code in
book funding false negatives are
acceptable in verification there can be
false positives the tool says I can't
prove this is correct but in bug finding
they use heuristics to really greatly
reduce the number of false positives so
that the user is not overwhelmed with
the number of those so the downside of
verification is you have this user
burden of writing down the specification
and the downside of bug finding is that
you're gonna miss a few bugs so these
are highly complementary techniques you
shouldn't always use one and you
shouldn't always use the other maybe
you'll use verification on a small part
of your program and then use a bug
finding tool on all the rest or use
verification for one particular property
and use bug finding for all the other
properties I think you should be
thoughtful about which to do and and use
the one that's best for your situation
so the checker framework is an open
source project you can find the the code
here on github we release every month 75
people are committed to the codebase we
close four or five issues a week and if
you write to us we'll write back to you
so what I want to leave you with is the
notion that pluggable type checking is
one particular verification tool that
might be good for you because it
prevents a null pointer exceptions and
it doesn't just find bugs it gives you a
guarantee that they're not there because
it's built on a type system it's easy to
use and it fits into your it's scalable
it fits into your development
environment already there are other
things you can do we've really focused
on the null pointer exceptions today so
what I want you to do is to get started
making your code better check out our
tool so thanks very much and we'd be
delighted to take questions as well if
you have some more them microphones in
the middle if you want to come up or we
can repeat the question either way
yeah question
okay so that's a great question so the
question is what about the optional type
doesn't that solve all of our null
pointer problems um so the the optional
type is useful in some context and I
think it's really great in the stream
interface and I think it's not very
useful in most other locations it is
more wordy is verbose it's a little bit
less efficient that's not important but
the fundamental problem is knowing
whether the data is there or not and if
you have a nullable reference you don't
know whether the data is there or not
and if you have an optional you don't
know whether the data is there or not so
that means you have to remember that you
should not be dereferencing a null and
you should not be calling get on an
optional so there are actually Brian
gets has a talk at 2:30 today I
recommend you go see it it's pretty good
it's about the optional type and he
gives seven rules for how to use it
because it's so error-prone I think
would be great for us to build the type
system to ensure that you don't make any
of those seven mistakes while you're
using optional we don't have that in the
checker framework if you want to work
with us on building that we'd be
delighted to and that will help people
to actually solve the underlying problem
instead of just transforming a
nullpointerexception
into an element not available exception
great question
yes
so we provide our own and so the
question is whether we have our own
annotations or use other annotations so
we have both so we have the checker
framework specific annotations and we
have aliases - I think 7 different now
less annotations the 3 or 5 annotations
the Android annotations the Eclipse
annotations we treat all of them with
our semantics but if you already
annotated your code with one of those we
just read them great question so the
question is if you use our annotations
there's a compile time dependence on
them and what's the license so the
license for all the annotations is the
MIT license you can do anything you want
the license for our tool itself is a GPL
because it's built on top of Java C
which is detailed so there's no
infection of any of your code when you
use our tool question
okay so this is a great question so the
question is how rich is your type system
for instance can you express if field
day is null then field B if a field day
is nominal then field B is non null or
the opposite maybe if field a is null
then field B is non null okay so the
question you starp into your question
there thank you saying you don't want to
write those things down you just want to
infer that they're true so everything
that we ever infer you can also write
down if you want so there's not really a
distinction between those the answer is
that particular property is not one that
we can express there's an infinite
number of crazy properties that you
could express the what we have done is
we've taken ones that come up in real
code and we've made sure that our tool
handles that and so if you have a real
world code that has that come and talk
with us maybe we can find a way to
actually annotate it using our current
system or maybe we'll open an issue and
work with you to support that as well
there's a limit I mean every tool has
some limitations and you know you're
gonna hit the edge of ours at some point
with some of your code
so the goal for our type system is
question so the question is do we do an
interpersonal analysis to be Anala
analyzed the source code of methods that
we invoke and eclipse apparently does
that for private methods so our goal is
to have a modular type system where you
don't depend on the implementation of
any of the libraries that you call so we
rely on interface specifications which
is good for analysis speed and
understanding by humans
so having these explicit pre and post
conditions just make sure what the
contract is and doesn't just depend on
an implementation artifact if in in some
you probably could do something like
that for private methods but you just
have the disadvantage that you depend on
him an implementation artifact instead
of making it explicit as the contract
for this method so currently for a
method in the same class or in any other
class the programmers expected to have
written the specification on the
signature good I think we're out of time
but thanks very much these great
questions were around come up and ask us
questions or try our tool and send us
some mail thanks again
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>