<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ThinkAsync in Java8 by Dmitry Aleksandrov | Coder Coacher - Coaching Coders</title><meta content="ThinkAsync in Java8 by Dmitry Aleksandrov - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>ThinkAsync in Java8 by Dmitry Aleksandrov</b></h2><h5 class="post__date">2017-05-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Kv7XSCX8EFI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">action it's called think I think in Java
8 few words about me son principle
expert developer into systems with a
more than 10 years experience Maylene
bloody job into price yes I know though
I'll come to you from from Russia from
st. Petersburg I'm a colleague of a
Bulgarian Java user group so that's
that's a long story but still I'm you
know quite involved in the in this Java
user group I'm a conference cork can
follow me on this Twitter and as you see
I'm not only you know programming I
really like flying airplanes this one I
have the owner only two pre-programmed
not fly
ok so done for today so we will try to
rethink the way that we use our
resources in our system so the main goal
is to achieve this but before doing this
let's try to understand the word
asynchronous that it is flower Oh put it
like this
whoa one one ok great so are the main
ideas so I'm going to achieve it by
understanding or trying to understand
the word is icing for this so what an
eye synchronous I think I got it from
Wikipedia so it's I just read it I'm a
computer control timing protocol in
which specific operation begins after
receiving a signal so and the same
operation as they go they're not going
the same rate or exactly the same rate
like something else so in simple words
we want just to start the task of doing
something somewhere else as it is with
please let me be notified that this
process is over and I'll try to handle
the result as it is or in terms of Java
it will be a little bit complicated
which is start a new thread do something
there and try to extract the result with
a very much effort as you know
and why should we ever do this why
because it can be fast it can be faster
and why can it be faster because it's
not going to be blocking it's going to
be non blocking and why because there
will be no gaps between the tasks so
walking is evil blowing blocking is
waiting it's doing nothing so we should
try to avoid it in all cases so and it
can be a right understanding I would do
it we have to take a little bit look
from a different perspectives how it
happened because actually not only ones
ecology several technologies made it
possible for us to have this wonderful
approach in Java 8 so let's first take a
small evolution of the multi-threading
in Java that we say so everybody from
you believe so how many everybody's
coding Java somebody not coding Java why
okay so I think that as a recording so
everybody has tried this construction so
well introduce something kind of
different thread we just make a tread
which implements runnable interface we
just implement the function run and they
start the thread the other option will
be to extend the thread okay it's
wonderful when you started but when you
try to extract the results so you know
wait for the tress to complete please
stop them to yield num and so on is
really complicated so when the examples
is good but parallel programming is hard
it's very hard so every time we try to
do something in vero we are really
disaster elite hard and to do this
better
Brian God since 10 years ago wrote this
wonderful book how many of you have read
it
how many have understood everything was
written there from the first time you're
a basic yes I still read it every year
it's not the kindest about book because
it's amazing book it's my truly beloved
book i but
I think I'm not clever enough to
understand everything from there but I
still have to implement all these things
and then my job so I have to try
different approaches so as we continue
the exploration of the API in 2004 in
Java 5 there was introduced some call to
the concurrency API which actually puts
some kind of better handling or better
understanding of what we have there and
in the end this multi-threaded world so
we have something quite called a code
executor services well which we can use
in different configurations on different
ways our resources we have had this idea
of we can't ask this part of work so
this execution at pool service executors
services and get the work out there
still it was hard but with them actually
came to future yes and what is a future
just in terms of computer science
there's no computer sciences so a future
is a primitive or creative
multi-threaded applications and you'll
be quite surprised but future as it is
is not something new it's not something
new
the first concept of future was actually
introduced in 1977 it was way before I
was born by this wonderful young man
like Henry Baker and Kyle Hewitt and
their this paper and let's actually
explore what is a future so for example
we have a function this function
produces some work so we need to do some
work in order to produce some result and
what we do we put this work inside of a
container consumer is not conceptually
uh know described in this work but
containers are now everywhere it's a new
trend so putting a word in front of a
managed container is something that
corresponds the concept and the idea of
of the future so we put it and we
observe it and we care about it this
container actually cares about
this work and you know putting the work
inside of a container as itself
it's called another think so it's called
the promise promise and future always
come together as you probably have heard
this word so putting the work inside of
a container conceptually is a promise
and it'll be quite surprising it's not
something new to it actually appeared
even earlier than the future itself so
it was 1976 well then Ian Friedman David
wise you know introduced this and you
see if Peter Hebert called please think
a little bit differently call it
eventual so just mine the cordless word
eventual comes from the event and what
are they actually main concepts of
futures so the future it observes the
work which is happening there inside of
the container and as this work is done
we may call backs so the container tells
the somebody who will handle this result
there that result is okay or it's not
okay yet and there is no very important
thing that is about the the concept of
the future that transforming result so
inside of the container itself but you
don't have to you are now allowed to
leave the container so all the
transformations of the results are going
to happen inside the container itself
and if you leave the container so you
are living recenter asynchronous world
so you just you know a break below so
consent conceptually the main idea is
that before actually getting the final
result this result should not leave the
container itself let us have a look what
is the future in Java so you probably
have seen the code like this so you get
a from this computer currency API from
2004 from 0 5 so you just get some work
submit the task and what do you have to
do you first asked is
we're done is we're done is it done yet
not it's not done yet or I just put this
get just give me the work so the API
itself is very very simplistic so we can
ask if the work is done by is done
function we can get the work and we can
even get with time out of the work but
there is one small thing that's be
currently not realized by doing this so
these two men who can't get with time
out are actually blocking so and here
we are breaking below we're not allowed
to do this because what's happening if
we take two threads and observe their
work you probably see that if we submit
to work and then get the main threat
that it pushes as call to get matter is
still waiting is blocked by waiting for
the result of the other thread so
actually we have not actually done the
work better another thread we actually
have two threads which is one is blocked
and what is working that's not good it's
not something's going to happen we want
to have something like this on the
mainframe actually you know gets or
calls to get method so the other thread
is working and here in this gap we want
to do something more more useful and
from the definition as you saw as I told
to you we don't have to wake a block so
how it is possible not to wake a dog we
had to make callbacks yes callbacks I've
made a very very simplistic enero
wrapper to help us do this it also done
with some more goodies from Java 8 like
suppliers and and consumers and so on
and so on and it's just a wrapper
between the tasks and then you know we
can use it and it's nice for example we
want to call a synchronous line
calculates a Fibonacci numbers so as you
see we get a single friends can notify
the executors we can
what I really want we get the Fibonacci
numbers forget the executors and then we
have the callback method something will
be which will be called after we get the
results done or if you have some
examples we will print the stack trace
that's okay for now you see it's quite
printable it's beautiful I would say but
well we have to make some chains of
other objects there for example you
first have to calculate the prime
numbers then you have to calculate the
Fibonacci numbers and then you have to
print for example an intersection of
them these code becomes unreadable and
undi bugaboo you see nobody have tried
doing something like this I see no
because it's ridiculous yes ah because
the real work is done actually here I'm
entertaining in red so we can't do
Prime's forget the Fibonacci's yes we
just you know here I even cheated I that
was a good idea first to make the
intersection I synchronously and then
after we've done it we have to print it
now I do it synchronously because I
don't have enough slight space to show
all the codes yes so it's it's ugly
that's it's not good way to do this so
and probably question is did they do
this somewhere else of course it's in
JavaScript and LGS so as you know as
JavaScript actually has no threads in
its language modal you cannot write
press with it's expressions so they made
this a wonderful node.js stuff which is
based on non-blocking API is an
event-driven modal and of course
everything there was callbacks somebody
who tried to use this well I didn't as
well and I thought that that was so much
cool you know but in reality after going
to productions we've got callbacks
everywhere yes yes and it was totally
unreadable and we got something which is
called called
cows yes it was you know we lost more
than 60% of our time just you know
fighting this structures and as you know
the result is is you say the word call
back to JavaScript developer right now
he will start crying
instantaneously yes this is a wonderful
phrase by Venkatasubramanian so you know
reality was not that much cool o reality
a minute production and then promises
learn library code promises kind of fix
that so instead of writing this stuff
like you know functioning lighting
functional I'll come back to functions
so on and so on with a spell library
called queue we can achieve something
very much readable so we can make chains
erasing for this call by using then
function and we can even gracefully
handle the exceptions like with this
sketch function so it was pretty nice
and this kind of I think saved the world
of this enterprise development in
JavaScript because then you just put
this prep Sarah and one actually
happened in in Java world the first
example is I know it is listenable
future by guava so they have addressed
the same issue by extending the
functionality of future by adding this
transformations inside of the container
itself so and trying to make it with
callbacks which are not talking so but
it was complicated you know to make
something really useful by the way who
always used by Cassandra some of you use
Cassandra as a database
nobody really okay well there was the
implementation of a good implementation
of the listenable future I mean so it
was really good because databases brink
latency as they brink latency is this
very good idea to return not the result
but a what a future of this result
and you know the guys from from from
central they really understood that this
will be a good option and they've used
this guava library and to make this you
see you just have to make some extra
steps by any questionable decorators to
the to the peaks of the three executors
and you then have to do this listenable
future you can add callbacks but you
know in Java 7 it was really you know
complicated because you have to write
all this you know anonymous classes to
do this although it looks creamy but
it's just a function on successful some
failure in production it was horrible
again it was hard really hard and guava
also fold the idea that futures are the
result inside of future has to be
transformed so we have introduced this
transform matters so that view did the
work inside of the container
I mean container in the in this
conceptual word container it does not
have to leave this container to be fully
asynchronous so this actually gave us a
wonderful opportunity to transform the
values so we were really close to let us
a theory of futures themselves another
option is is J deferred I believe
everybody have heard of always on the
right libraries you cannot afford to
miss so it was also mentioned there so J
deferred followed the same modal with
you know the first promise fiber like
they did in the cue library and it was
expired by different Android different
objects and it actually gave us the
opportunity to create objects and make
chains of this object by using them
function by completing by done by
gracing gracefully handling the
exceptions with fails and so on and so
on
so it's a wonderful rivalry by race Hank
actually had the honor to meet him
and this is a good option if you are not
in Java 8 worlds I believe although all
or you really enjoy doing this thing in
the style of Android different objects
so it's it's a good option wonderful
this this library is beautiful but have
you ever experienced this this situation
that are you are not allowed to use some
of the libraries in your code everybody
yes
so you reviewed introduced a library to
your code if you just cannot do this
you're not allowed how can we do this of
course I can suite we have to switch to
Java 8 yes because everything's inside
and Java 7 is end-of-life I'm just
talking to to our recalling speakers hey
Sarah instill in Java 7 how many of you
are still in Java 7
I don't know I'm not I mean now Java 7
has JVM you're running your Java 7 code
most of you running your code on Java 8
but still write everything in Java 7
using Java 7 JDK if there's nobody like
this just amazing it's wonderful be 3
years finally so and how do we do this
in the in Java 8 so it's not only by one
class I personally believe that this
class has has to had this impact of
change like the streams and the lambdas
did but it was kind of forgotten because
lambdas dreams were so cool and
everybody think them but only one single
class would represent a fully different
approach API actually made a very big
change and this is only for a class
called computable futures so what is it
so it's in Cole library since Java died
as Java 8 I was playing it with it even
before March 2014 when I compiled my own
JDK somebody have compiled their own JD
case
it's so fun really I just amazing and
how it's done so they've got this
regular future from as we have it from
Java 5 and they have extended the
interface with another interface called
completion stage I probably believe that
everybody knows that you can make
multiple inheritance of interfaces in
Java and other classes so they just put
another inheritance of interface which
is computed completion stage and
actually all the magic happens here in
this completion stage so this completion
stage allows us to make a wholly new
world of approaches that we can use in
our program so in in composition of
elements from two resolutions we can
transform inside the values we can
complete them it can make change we can
make you know flows of tasks and they
are all available in sync our operations
sorry about that so but before that let
us have a small foundation actually what
we have so because as I told you several
technologies made it possible so first
thing is lambdas in Java 7 has you seen
guava mainly so making this anonymous
Colossus was was horrible you know it
was on debuggable it was as readable now
you don't have to do this so it just is
London best references so in another
foundation which is the biggest
achievement now belief is the poor join
and since it's available from JDK 7 it's
really perfect helpful for us and for
for completable future because the
algorithm itself is really good and it's
mainly good for creating or creating new
tasks you can create it's optimized for
creating new tasks and it cares very
much for cash corruption so if we take a
look about process and have several
times several tasks in it so the idea is
that you
we have the resource we'll put
everything in one thread because you
know you put everything in one track so
the caches will be filled with the
information that used most of them and
you will really enjoy I enjoy but you
know benefit from the idea that your
data is already in the cache of this
thread of this B this processor so you
just facilitated but if you if your Q of
one thread becomes becomes full and the
other thread is doing nothing there is
something cool like work-stealing so it
just takes the tasks which are down
there in the queue and it steals the
tasks and it helps you to to do utilize
the other processes that you have so
it's wonderful and it's something I call
a good combination of technologies make
it very easy and very handy to use the
multi-threaded programming so an
algorithm decks a computable future
let's take a look at it so although the
main idea of this talk is not to observe
an API but try to I call it the thin
casing that means I want to force you to
um before getting a task ready to try to
facilitate other methods of modeling
just like down in this completable oh
but this is a synchronous approach with
computable future but still let's have a
look so computable future as I told you
is just a class it's one single class
and how can we create it so we can just
create a class just a new font with new
I don't go to nothing it's it's a it's
an empty container with nothing there is
some more some more our handy methods
like for example you can use methods
like sand fly sink or run a sink so
supportive and supply it means that it
takes some data something that supplies
you with the data and do something with
it
or just run I think it means that when
your task is ready just run somewhere
else asynchronous you know I was thread
something which does not have to return
result yes
if you see the result option here you
can pass in an executor which makes it
very powerful so you can just you know
use a justice supplier or even have your
own executor there and use it but by the
phone for a common pool is used by
default here I just wanna say it again
that's fortunate is cool it has it runs
so if you start a JVM if you have this
resource available like foreign common
pool but not only you have it all the
JVM has it so it can be polluted as I
say so many other application can use
for joint pool and this can be an issue
of results so if you don't care about
you know special conditions about
executing your stuff somewhere else you
can fascinating the kid rinse down
gracefully as you see so another option
is to complete the futures so you just
can complete it there's a there's a
kosher and complete we can complete
exceptionally and telling you ok that
something's gone wrong they'll have to
do this and you can complete it only
once and that still actually does not
exclude blocking just have this in mind
and the other option is to use the
built-in methods that accept and then
run something and it will stop the chain
of your actions just let us have a small
look at it directly so I prepared some
code for you so we get game prime
numbers so I but prefer not to use
something which is bound to internet
because unfortunately this is one of the
first conference but I have amazing
internet for speakers it's great thank
you so much but this example I use prime
number because it's latent operation so
as you can tell awaiting will come back
so it played these computable features
are perfect for latent operations so
what we do we create a comparable future
and we want to get Prime's so we just
call our method by method reference
don't get the prime numbers and as they
are calculated somewhere there in a
color for join pool we want to print
them and wants to do nothing else just
to print them and we call this term
element that except an utterance done so
we get this system odd and reference to
ops not new but print line read fine and
it's okay look we've made a small chain
of events that happen asynchronously and
if we want it let's see what's going to
happen so whoops yes I have to finish
this slide just gave me a second
yes let's run it oh nothing happened
what's wrong if we say for example set
print line with bon jour nor did she
know
no I think there was one Bongiorno like
this yes duccini
yes and running again what's going to
happen
oh where are all the primes every idea
where all prizes are you do anybody else
know it actually happening there exactly
not they're calculated but the problem
is that our program runs faster than the
calculation and as you see the supply
thing the sync means that we're doing
asynchronously that's why we need we're
starting a new thread so if we make some
waiting here like for example in red
line we will see or we just read we will
see that if we run this thing we will
have them
Bonjour rata Chino and then come our
prime numbers because they are latent
they're running a different thread and
now if I just press Enter we'll stop the
execution as you see it's wonderful so
we've just done a multi-threaded
programming without ever using word
multi thread thread here look an amazing
get it and if we have a look here in
this calculation of a prime number with
just you know prints the the threat
actually let us hear threat then current
threat that gets name you will see that
April show us that this red is a poor
joint Poole common thread brought for
one you see without even doing all this
ugly stuff with threads new thread
starting joining us so one we've just
done multi-threaded programming our code
and I thought the threading even
asynchronous because we first Club the
prime numbers and then we actually print
them this is amazing you know this is
really beautiful I really like this like
this approach multi-threaded programming
without the word threat because I
embedded multi-threaded programming and
do you remember this then action all the
transformation have to happen inside of
a container we cannot pull out the value
and put it somewhere else and then we
have this wonderful option that apply so
we can transform the values just right
inside of the in the container so I'll
just make a small demo will here's the
same stuff and here in the middle as we
come to prime numbers we can for example
I prepared a small transformation that
apply we can use that apply and
transform this calculation by using I
have a function that actually calculates
the average it takes the list of
something against the averages and if we
print it out so we first calculate the
prime numbers in our in our you know a
synchronous search thread then we
transform this value in something else
like for example getting Everidge of it
and after it's done it's uh it's printed
we don't have to care about all the
synchronizations
waiting yielding so on and so on so
that's for example for me that's magic
and I've don't really loved with this so
as I told you by net apply of that
applies Inc here is you probably saw I
use this icing so if we use that apply
without async word we're going to do it
in the same
threat if you say I think it will do in
some other threads of the executor so
wonderful as I told you just in one
single line for me it was a single line
we can make massive asynchronous
calculations and it's beautiful it's
understandable it's readable you don't
have to care about this so if we got a
little bit more people we can transform
the way the objects inside of all this
chain that we formed from the events in
smart way so there is another cool API
function called in compose so they
compose a sink and it's done for you to
avoid something like completable future
inside computable future because
computation just class you can put
computable future inside a couple
infusions it becomes strange but if for
example our calculations it works likes
just a flat bed actually
for example our calculations like this
asynchronous reading of file returns us
a future we can then windows I think
just give you this future and it will
unwrap it for us get the result
transformed in some way process the
content as it's written here return
another fusion that will accept it and
print it so by composing we can make a
good flat map of different completable
futures and we'll all go like a flow yes
we don't have to dive inside or get out
of there
it just goes for is one flow it was
beautiful or we can even combine and
reduce example we have to have several
steps that actually form the next steps
and we can then use the API medical then
can by and you can do it in single
trainers or a different thread if we
take a look at this function for example
we have first to calculate Prime's than
to calculate people are just meant to
get intersection with just futures it
will look like this you know so we get
Prime spigot for futures and we have to
intersect it
really not beautiful like this we have
to make to wait somebody has to wait for
that by with by the computer then
combine we can do this safely so all we
can don't want to make it further
processing just accept both of them and
just print something else or in
something after both and we have other
options like for example I want a first
available result it's a good example
here is the DNS for example you have
several DNS servers they say ok people
who knows that address and the Alex have
all the DNS service and they say the
first comes okay I know this address and
we don't really care what the other will
say we just use the first address so you
can either accept either method or run
after either so one is consuming
something one since front something but
if we want this to first develop a
result what happens actually to the
second result here's a good question
because the second result actually
future that has the second result is not
closed or result disappear it just you
know stands there so the handle we there
will care all this thing or you can even
get the number of dependence because one
future had can have many dependence so
you can apply to either you can even
have the option to pass many futures and
to complete all of them or any of them
with the method in these API but have a
look at the results another result
boards and types so it's a times of all
up is void we cannot predict what is the
future actually will going to be it's
going to be object integer or void or
something else so void is the only
option here or any of the other think is
option are objects so it's it's it's
it's it's hard so these functions are
rarely use I never use it in my life so
exceptions so you can handle them very
good so we can complete exceptionally or
handle something gracefully so the
exception is propagated down to all the
chain of the events that you have
so handling options here and you can use
it so for example if you have a good
value which is good you just just go
ahead or if you have a problem
so you just print it so we get to Islam
too with this function what is value and
Bonnie's exception so if we read the
filers and in previous example except I
think and compose processes that accept
the results and if something happens
somewhere in the middle we like unlike
that example that I give you with a
synchronous we have we print the handle
the the exception all the way down to
the coal we just called exceptionally
impressed entrees so as you probably
notice the API is really big it's it
mostly fits all this pattern but it has
a mold of 60 methods inside and as I
talk to one of my colleagues why don't
you use completable futures is them
because we are scared there's so many
methods inside we just you know just if
you see and we were scared it's not good
and still if you overcome this care of
it so and you can organize your work in
flows so if you do this than that then
do this or that or the failure please
recover if you start thinking in
workflows events and tasks so for
example get this this representation of
data so completely future exactly for
you you can do parallel stuff without
even thinking about being parallel
because you're organized you're working
flows and events and tasks everything
will be handled for yourself but as I
told you we have have some bad humanity
it's called the gate function because
we're still inheriting the get methods
from the future interface and it's
blocking and it's really bad but there's
an option called join so join is
something like get function but it's
does not fold you checked exception
there's a good example of how to use
this
for example we have an application which
does have some can you read it from that
is okay it's readable so will you
it's not writable okay but make it
better and bigger so there is something
like you know sending an email it's it's
artificial so threads sends an email
just in one one second he needs to to
get thread done and it's just a piece of
work and how can we do this so if we are
thinking in terms of fire-and-forget we
can do a parallel stream and send the
emails to somewhere else but we can do
it a little bit different so we can make
a computable futures of sending of this
emails you know just send this email I
said to use this work collect them in a
future result and then we actually have
to join the results unless let's see how
this may work in terms of using the
computer for futures so if you have the
result here here is printed a little bit
more so what these parallel streams you
will need about two seconds to run this
because parallel stream are used to for
a joined common pool and you cannot use
all the pools there you're not allowed
by the API in a compatible futures where
we pass all the other execution services
you see the same job keeping Sony one
second ten millions in the nine
milliseconds so have in mind you have
this wonderful instrument of you know
defining your own execution tools and do
again with streams parallel jobs here
and this runs really faster because
there you don't have a control here you
have a control and it's a perfect idea
of a firing to get principle so you just
need to send emails just you know do it
in parallel do it in computable future
fire them
it will happen somewhere there in the
background you don't have to care about
it okay so but care is still there
another option is just to look through
the value as it is but get is a his is
not a good idea so for example you have
a service which is a rest service and
you have to calculate some values and
you have to return it one of the option
will be just to make computable futures
and to calculate everything make the
intersections but then you have to
return something you still have to make
the get function at some point because
you have to return shrink and you see
that what's happening inside is that you
have something that's calculated primes
something that's calculate Fibonacci but
the main function is still waiting there
so and if you take a look of what's
actually your libraries provide you like
this is a good example that we have used
in our our code instead down full of the
path of the technologies that we use we
can even render this this result
asynchronously and it's very good
because here we return the completed
future and we get this asynchronous
response and as we print it out it all
goes synchronously so the actually the
execution of this thing comes like this
we have a lot of resources like you know
first we get catches fires the events
that are going to happen and only after
these events our talks are calculated in
a good way and they are ready only then
actually this result is printed and if
we have Luke I even have made some some
some services for you I believe the
Tommy still running so as you probably
know that the yes is here
calculation of this this is a rest
service which is fully asynchronous that
all of the chain we get from
calculations all of its part to
asynchronous response rendering you've
got this result fully I think for this
so that actually is a good plus and a
good drawback of asynchronous execution
is that you cannot make stuff
synchronous here an asynchronous there
all of the chain has to be
asynchronously done if you break the
chain
you're breaking the low of the
transformation that has to be done of
the containers so think about it you
cannot do this here like this and here
asynchronously then combine it together
if you do this you will block somewhere
and you will lose your resource so this
is a big power and still drawback so
it's very fragile so as you see this is
done fully asynchronous so we have the
instruments to do all this think
asynchronously like in rest service this
is something that we've done in our job
we have a very small micro service which
has done a very latent search and this
latest search actually gave us this this
way we save some resources by during
late answers by providing the computable
futures to them
so just remember get is evil so if you
get you have get in your code that's bad
so just few words about Java 9 then
comes this July maybe I don't know so
there are several gems in it I will just
you know scroll through them so one is
that as you see we can do some defaults
completion of our future so as one
result is calculated we can complete the
result and as it's not we had done if we
get the get method that's become not
blocking it gets the default result and
then returns you the real result when
it's calculated I personally find it not
good because there you have none you
cannot predict what will happen what
will be the predicted results so but
still this Jap is alive it's strange I
don't like it the same as you know
for a you know is done and the good
thing is here are the timeouts so you
have timeouts in your code so you get
the possibility to make a if you have a
you know operations that are really
requiring some time to be completed but
not more than something like specified
you can do timeout and stilly and then
you have the possibility to or give
result or give an error so that's a good
option the other idea is that you can
complete it on time
so please explore this job this is
interesting and just to say few words so
this actually it comes from the idea
that this way of programming of this
think of doing approach of approaching
the only the tasks that you have it
looks like very reactive so as I say
reactive once again was the new cloud so
if you do reacts in programming you're a
really you know super star yes but until
we actually serve Alice came out server
this is now feeling more people on
conferences on that talks but it's
actually not something much new as well
so it's just an observable pattern so as
you see the key word a synchronous here
and the generate here supports this way
very good really nicely so as everything
has its manifestos right there reactive
is so manifests are probably really so
this idea of a responsive elastic Riis
island message driven more alike message
driven event really fits well to Java 8
computable futures approach so you have
responsive so you have to get scale your
application the resilient you have you
handle Europe we are errors gratefully
or exceptions gratefully gracefully
elastic so responsive I mean insurance
so you can control the response so
control side megabit so it's quite
reactive and as I told you how this
approach really optimizes your
cpa uses your cash failures and so on
and so on and in reality we can see one
of these graphs the blue lines actually
is the completable future implementation
of the service that we made with it
which was fully asynchronous and we see
that during the day we can receive more
responses for for for for our job just
because you know this timing between
switching the threats and switching the
tasks there is no waiting there's no
blocking so everything happens just
right after another and there are no
possibilities for one threat to be
waiting for some money and be blocked
for something without because we are
fully asynchronous in this approach so
as you see it's really nice it's a
pretty nice the reactive tolerant we
could think it comes out of the box you
see when it comes out of the box that
means that it's tested something that
people forget it means that it work as
it should work if you use third-party
libraries something may may break and
you don't have control of it here it
comes with the JDK so it's it's tested
it's working and just handle it with
care and once again as you write the
application are there and you have some
idea of switching 4 month us to another
just by the gap and asynchronous
approach give you the possibility to
exclude this i feoh reticle II exclude
this gap from it from from from Junior
stuff and that's probably all for my
size so grants a neatly hidden down
merci beaucoup thank you very much so
for the questions I'll be available
there in the the auditory and one just
possible work out is on the right throw
some some nice examples when you use
computable futures and so please check
the links that I put in the end of the
presentations will be available inside I
guess I will publish it so thank you for
your attention I got to meet it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>