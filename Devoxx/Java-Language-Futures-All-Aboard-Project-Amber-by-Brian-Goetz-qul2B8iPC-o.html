<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java Language Futures - All Aboard Project Amber by Brian Goetz | Coder Coacher - Coaching Coders</title><meta content="Java Language Futures - All Aboard Project Amber by Brian Goetz - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java Language Futures - All Aboard Project Amber by Brian Goetz</b></h2><h5 class="post__date">2017-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qul2B8iPC-o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay welcome everybody thank you for
staying to the last session of devoxx
2017 what I'm gonna talk about today is
project amber I like doing this talk
because this is the talk where I get to
talk about what I've actually been
working on so this is a work in progress
we've been working on project amber for
about a year now
and we're getting ready to deliver the
first of the many features that we're
developing under amber so I'm gonna give
you a little bit of a whirlwind tour of
what we've been doing and where Java is
going so usual disclaimer slide I will
call out a few key words in this
disclaimer slide this is forward-looking
we are talking about what we might do
this is not a commitment if I don't
mention version numbers it's not because
I'm keeping them a secret it's because
we haven't decided yet in what version
we're gonna target some of these
features some have been targeted most of
them have not been okay so Java has been
evolving for these last 20 years but one
more you know and over these last 20
years Java has probably been declared to
be dead more times than I can count and
we've taken great pleasure at
confounding these claims over and over
again and managing to stay relevant to
the problems that people want to solve
and the hard world people want to run
run run their programs on as has these
change and so you know if you look at
the changes in the language they might
look kind of all over the map there were
some big changes like in Java 5 we did
generics which was about better data
abstraction in Java 8 we did lambdas
which was a bet behavioral abstraction
in Java 9 we did modules which was about
making configuration application
configuration more of a first-class
element to the programming model we also
did a lot of smaller changes along the
lines like guy and in the language area
for example in Java 7 we did little
things like try with resources you know
but the all of these have a common goal
when we decide to do a platform feature
or a language feature it is all with you
know the common goal of making it easier
to build and maintain rely
programs the pain points may change and
so the things that seem to be the
solution for the pain points of today
Maine may change but the story is the
same we look at what's getting in
people's way making it harder than
necessary to write the programs they
want to write we identify what could we
do to make that easier then we do that
and of course you're never done that
just makes you know another pain point
visible and we might work on that next
so the big stuff that we do gets a lot
of attention you've heard me talk about
project Valhalla in the past you know
you've heard me talk about lambda in the
past
these are big projects they take a long
time you know and it takes a long time
to figure out how what we want to do
takes a long time to do it
takes a long time to for the rest of the
ecosystem to adapt right you know change
the language and that has a ripple
effect on the libraries etc it's very
easy to get caught up in the big things
but the little things matter too and
project amber is largely about the
little things and so we call this right
sizing language ceremony they're perhaps
not the most sophisticated language
features but they're useful and
desirable because they make the things
that we do every day simpler so you
could think of them as small
improvements compared to something like
a lambda or a jigsaw but you know they
they share the same common theme
improving the everyday user experience
of people writing code so that it is
easier to write and maintain reliable
programs so you know like I said usual
disclaimer statement of direction not
necessarily you know a schedule of what
we're gonna deliver and when I say
smaller I don't necessarily mean small a
lot of these features are big or at
least they're pretty significant they're
just not the whole reinvent the whole
platform that lambda was you know on
this slide I have you know some of the
other projects that we're going that are
going on in Java at the same time
project Valhalla I've talked about here
project Panama I talked about here last
year these are still ongoing we're still
working on them you know they'll be
ready when they're ready but we also
didn't want to make people wait years
and years for for big improvements and
so we want to mix in
small improvements - now whenever I talk
about language evolution I like to trot
out these old slides and even though
they're almost you know 15 years old
there's still the right guiding
principles for thinking about how to
evolve a language so these are
principles that graham Hamilton outlined
you know as as the core design
principles of the java language and you
can think of them as readability
simplicity and transparency and in some
sense these are all even the same thing
it should be easy to look at code and
figure out exactly what's going on
because code that's readable is
maintainable if you can't understand
what the code is doing when you go to
maintain it you're going to break it and
eventually you know someone's been say
oh that code is such a mess it just
needs to be thrown out and rewritten
code that is very clear that it's
obvious exactly what's going on is code
that lives a long time and code that
lives a long time is one that we get a
better return on our coding investment
so you know the most important principle
for us really is reading code is more
important than writing code and you know
in the lifecycle of code code is read
many many more times than it's written
and you know it's as developers
sometimes it's hard to believe that
because we think of ourselves as being
in the business of writing code what do
you do for living I write code but but
that's not really all we do that's maybe
the glamorous exciting fun part of what
we do but a lot of the time we maintain
code we look at other people's code try
to figure out what it does so we can
interface our code with it so that we
can improve it and if code isn't
readable then it's not valuable so the
lens that we look at everything through
when we think about language features
and certainly we have no shortage of
features that have been suggested for
inclusion in Java the lens we look at
all of these through is does this make
it easier to read code so evolution was
always in Javas DNA was always clear
that you know we were going to continue
evolving a language but we've always
done so in a conservative way we don't
necessarily want to be the first
language on the block to have a given
feature and we still could we
we know that every language of each we
add will never be able to remove and
every language feature that the language
has interacts with every other language
feature that we might ever want to add
so we want to make sure that things pull
their weights before we put them into
the language we kind of you know this
means that we're not necessarily the
first mover and that's okay
we have the we have the luxury of
looking at experiments that go on in
other language communities and saying
yeah we like that we like that we don't
need that so you can think of that as by
a last mover advantage and as a good
example of this you know and a few years
ago java-- won james gosling was talking
about why didn't java 1.0 have generics
and it wasn't because we didn't
understand parametric polymorphism in
1995 it wasn't because we didn't think
it was useful it was because we didn't
know how to do it right we knew how to
do it wrong and we chose not to do it
that way you know if Java 1.2 had
generics it would have been something
like templates in C++ and it took a long
time to figure out maybe longer than we
like the Java way of doing generics but
I think the solution that we got was a
lot better than what we would have
gotten if we said Java one oh must have
generics can't ship otherwise so you
know sometimes it takes a while to
figure out exactly the right feature is
but that's okay we're willing to do that
so let's take a look at the features
that I'm going to talk about today these
are some of the features going on a
project amber local variable type
inference data classes pattern matching
saner serialization and others so local
variable type inference is something
that is we actually have a ship date for
the others are still when they're ready
they'll go out so let's talk about you
know the first one local variable type
inference table type inference is
something that Java has had for a long
time so we started with type inference
in Java 5 and we have expanded the use
of type inference in the language in
almost every version since then so type
inference is when the compiler can
figure out the type of the variable from
information that's already in the
program rather than making you type it
out explicitly and most of the time we
like type and Friends
because it eliminates redundancy without
undermining readability and without
undermining our commitment to strong
static typing so type inference isn't
dynamic typing you know when we infer a
type it's you know the same thing you
would have typed in yourself you know
but we just don't make you type it out
explicitly now there is a whole spectrum
of positions you could come down on you
know on how to use type inference in
your language some languages like ml use
type inference for absolutely everything
and on the one hand that's very
convenient on the other hand it means
that if you make a mistake in your
program the error message that you get
from the compiler might be a thousand
lines away in the code and that makes it
a little bit of a difficult developer
experience we prefer to keep type
inference localized to a single
statement and we prefer to keep type
inference in the implementation but not
in the API because api's need to be
stable api's are used for separate in
with separate compilation I compile
against the API that's implicit in you
know this class that in or library I'm
compiling against I don't want those
changing out from under me just because
the implementation changed so you know
and it's not clear you know I you know a
priori whether more type information in
the program is better or worse the
reality is sometimes it's better because
it gets redundant information out of the
users face sometimes it's worse because
the user has to guess at it and so it's
not a substitute for developer judgment
developers still have to use good
judgment about what information they put
in the program but it gives developers
more opportunities to choose what they
want to put in what they don't so in
Java 5 you know we have type inference
for generic method invocation this is
used so pervasively that a lot of people
don't know that you can explicitly
specify the type parameters to generic
methods so most most of the time we we
would invoke collections that empty list
like this but if you wanted to be
explicit and say I really want a empty
list of string you could specify it
explicitly as anybody never seen the
first syntax and willing to raise their
hand isn't that amazing
we've had type inference in Java for
you know more than 12 years and it's so
effective that some people have never
seen the lack of it which is really cool
that's how it's supposed to work in Java
7 we expanded this to constructor
arguments so that you can infer the type
of constructor arguments from what's on
the the assignment target and that's
nice because you don't have to say the
same thing twice in the same line and in
Java 8 when we added lambdas we gave you
the option of saying your lambdas could
be explicit or they could be implicit
and sometimes the right thing to do is
to make it explicit sometimes you have
to because that's the only source of
type of information the compiler can
find and sometimes it's just not clear
and you want to be explicit and that's
fine and most of the time it's pretty
clear from context what's going on and
you can leave it out so you know type
inference has been pretty successful in
Java and like I said you know we've been
doing it for a long time and we've
slowly expanded it over time so the next
logical place to do that is in a type of
local variables and this is something
that you've probably seen in other
languages almost every other curly brace
language has this at this point
a c-sharp C++ Scala and you know it's
perfectly reasonable to infer the type
of a local variable from the type of the
expression that you use to initialize it
and so and especially because the way
you know Java the Java syntax works was
the decision made 20 years ago we put
the type first and then the variable
name but in reality in most of the time
the variable name is a more useful more
useful thing than the type name the
variable name if you've chosen your
variables names well which we all do
right we all choose good variable names
right good hardest thing in programming
the the variable name is often more
important because it's what the what
that thing is used for in this program
rather than in all programs and so it
would be kind of nicer to move that a
little bit more front and center if we
lead the if we lead the you know that
the type names and left of the pile or
infer them not only does the code get
more concise that's great but it brings
that variable name you know front and
center to right in it right into the
users attention because they all line
you know nice and neatly now a lot of
people you know one of the I always get
the question of isn't this gonna make
Java code harder to read aren't people
gonna abused this yes of course they're
gonna abuse it right that's always what
happens we get a new feature we're not
you know quite sure what the best
practices are we discovered it by
overusing it then we discover oh we went
too far
people dial back best practices emerge
and eventually things will react will
abrade at a better place but most of the
time by getting you know this redundant
type information out of the way I think
most of the time code is more readable
with this and certainly if the overhead
of having to declare a variable is lower
people are less likely to create these
deeply nested you know seven level deep
expressions with chaining which often
they do just to avoid having to declare
a new variable name so you know this is
a little thing you know that I you know
I think it's one of the most commonly
requested features we get and I think
you know so I think it's a perfectly
reasonable fit for Java and this has
been integrated in JDK 10 so you can
download the early access builds today
and try this out yourself there's also
IDE support and IntelliJ for this ok so
what are the limitations here this is
for local variables because they're pure
implementation details it's not for
things that are part of your API it's
not for method return types it's not for
field types and that's because api's are
important they're dynamically linked we
wouldn't want the return type of a
method to subtly change because of a
change in the body of the method so
interface contracts are important it's
important to be explicit their
implementation you know where what you
know it's reasonable to have more
freedom about what you do there so it's
worth noting that this feature seems
like it's kind of a just a matter of
syntax and it seems really simple and
like why did it take so long and as
always these things are a little bit
more complicated than they look feature
like this tends to expose some of the
darker torrent corners of the Java type
system Java in fact has several
categories of nons and none
nons a notable types what's ananda
notable type nons a notable type is a
type that exists in the language type
system that the compiler can reason
about but that you can't write down
which means that it's possible for the
inferred type of expression to be a non
des notable type so what should we do in
that case so examples of non too notable
types include capture types intersection
types anonymous class types the null
type and for you know for each of these
we kind of have a couple of options of
what we could do we could say well just
ban them don't infer them and that seems
reasonable because that means that every
program with implicit types corresponds
to a program where all the types are
explicit but it means that the feature
isn't as broadly useful as we'd like it
might like to be or we could just infer
them but that might have some negative
consequences too you know when when
capture types get propagated into other
other expressions or we could try to
find a middle ground to normalize them
to a de notable type this actually
turned out to be a surprisingly hard
problem we went went around and around
quite a few times before we landed where
we did and we were actually kind of
surprised to figure out where we landed
to give you an example of where these
types pop up it's really easy to get
capture types in places where you don't
see any wild cards like if you call get
class on some objects you'd think oh I'm
just gonna get a class out of that or a
class of question no you're gonna get a
class of capture of question extends
whatever class this is so if we just
said what we're gonna ban var for nons
inaudible types we might end up in the
situation where people were confused of
like but why isn't it letting me do this
there's there's no there's no question
marks here
similarly there are you know cases in
the library is where you know you you
might think all the parameters are
specified but the type of that is also
going to have a capture in it
similarly with intersection types you
can get some even more surprising types
out of you know that pop up out of
inference so like think in your head
what you think the type of this is
alright yeah maybe object maybe
yeah you're not gonna guess its list of
question extends serializable and
comparable of question extends
serializable and comparable yeah you
guessed that one right yeah so you know
it's great on the one hand that the
compiler can hide this complexity until
you get a weird error message you know
ten lines later and you say where on
earth did that type come from and here's
another example that's even more
surprising I think you take a list that
contains a local date and a local date
time and you get a list of what you get
a list of question extends serializable
and temporal and temporal adjuster and
comparable of question extends all of
that goop so these things pop up in
surprising places and you know we
normally haven't had to deal with this
because you assign it to a list of
question or something like that and you
move on but the type the compiler picks
for you may not have been the type that
you would have picked by hand and so you
know the the moral of that story is we
can't ignore those you know those it's
not a corner case we can just you know
look past so the way where we ended up
landing was we said okay the null type
is useless that's you know stupid to
have a variable that you could only
assign null to so we'll just bat will
just won't bother inferring on that we
will allow the the weird type to flow
through on anonymous types anonymous
class types and intersection types
because it's not unsafe but capture
types end up getting normalized to a de
notable super type because if we didn't
bad things would happen so it's not you
know that this is all to say this is not
just about syntax there's this this this
exposes the dark corners of the type
system all right so let me move on to
another feature so as some of you might
have noticed you know Java has a bit of
a tendency towards boilerplate people
complain about that we listen we don't
always do anything about it but we do
listen and you know it's important to
note that like you know the taming
boilerplate can but can easily become an
end unto itself right every little bit
of a boilerplate you eliminate just
makes you think oh but I could also get
rid of that oh but I could also get
that and this can sometimes reach
diminishing returns and so the goal is
not to make Java code as concise as it
could possibly be because what we lose
in that is readability we want to make
the code as readable as it possibly can
be not all features that are about
concision are created equally they don't
all have the same costs and the same
benefits so the way we like to think
about these features is to focus on
semantics in in a way that allows the
boilerplate to take care of itself
rather than making them at that
boilerplate reduction so one of the
biggest offenders in boilerplate is
where an object state meets its behavior
those are things like an object's
constructor the core object methods
equals hash code to string and state
access methods like getters and setters
now we all know that these can be
generated off a template we all know we
can get the IDE to generate these for us
and one or two keystrokes and that's
great but that doesn't help us with
reading code it only helps us with
writing code when you get confronted
with a big class that's nothing but you
know getters and setters and equals and
hashcode that have been generated off a
template you still have to do the work
of looking at every one of those methods
and saying is there anything to see here
nope nope nothing to see nothing to see
you move along and the the verbosity of
this often tempts us to do stupid things
like oh I don't need an equals in a hash
code you know or I don't need a
two-string and you don't need a to
string until you want to debug something
that prints it out you know the
offending object and you get an
unhelpful to string method of foo
percent blah blah blah blah blah right
so we're putting developers in a
position where they're they have a set
of bad choices either you know write
this annoying boilerplate code that's
still annoying to read or cut corners
and write you know potentially buggy or
hard to debug code so you know I think
it's worth three kind of revisiting why
we write this code we've been taught for
years that good object-oriented
programming requires encapsulating
everything so we treat every class as if
you know everything we're fully
decoupled the state was decoupled from
you know from its clients the
representation is decoupled from the
interface we mediate access to state
with accessors
we all know how to do this and you know
it's perfectly easy to do and the IDE
like I said will generate it for you
but the reality is not all code has
equal need for encapsulation something
that's part of a public API needs a lot
more encapsulation than a class that's
private to a package and so you know we
would like to give developers an
opportunity to choose about where on the
cost-benefit spectrum they want to fall
in terms of how much they want to pay
for you know for this encapsulation so
when is encapsulation valuable
encapsulation is valuable when your code
is working across boundaries there are
different kinds of boundaries there are
maintenance boundaries I'm working on an
application I use your library I can't
change your library code you can't
change my application code the code are
in different maintenance domains
that's a boundary there are security
boundaries where I am mediating access
to a resource may be a native resource
then I don't want to share with you
directly I want to make sure I'm only
going to do the things that you've you
know that I'm that I think it's okay for
you to do
there's versioning boundaries and
compatibility boundaries you know if a
library separately version from you know
uh you know from a client you want to
make sure that changes to the library
don't you know that you can drop a new
jar in and not break the break the
client right so not all code is crossing
these boundaries library code like the
JDK is crossing all the boundaries has
to be written very defensively we have
to worry about all of these things but
not every not every bit of code needs
this and if you're not crossing these
boundaries the benefit of encapsulation
is lower and yet the cost is exactly the
same and so you're getting a less of a
return on all of that ceremony so the
reality is a lot of classes are just
aggregators for some amount of data
they're just wrappers for data and like
I said we know how to model data with
objects we tell the ID to generate all
the methods for us and we're done
but you can think of this modeling
overhead as being high there's a lot of
tedious code there's a lot of
error-prone code because boilerplate
means repetition repetition is a place
for bugs to hide so the less repetition
the less place for bugs to hide
and so my claim is that we're doing it
the way we're doing it because we're
writing code of the wrong level of
abstraction we're writing in terms these
very general classes because we have no
way of saying what we actually mean what
we actually mean is this class it isn't
really even an object it's just an
object like carrier for some data but we
don't have a way to say that if we could
say that it turns out that we could
generate all the boilerplate you know
mechanically and safely without the user
having to look at it so you know in a
typical class like this you know you
kind of want to write you know a point
is into X&amp;amp;Y and that's not what you end
up writing this is what you end up
writing and you've probably you know
seen other languages offer more compact
facilities for writing classes Scala
calls them case classes Kotlin calls
them data class as she sharp calls them
record classes but you want to have some
way of saying this is the state of this
class and that's all there is in this
class there's no complex behavior it's
just I'm holding my data maybe a little
bit of behavior that derives derives
directly from the from the state so we'd
like to be able to do this you you know
it kind of seems like oh how hard could
that be he actually turns out that there
are a lot of different ways to interpret
what this might mean but the you know
the basic idea that you know of what
we're we should be thinking when we see
this is a point is a carrier for this
index and this and why and that's it if
there's there's no you know the the
representation the interface they're
tightly coupled because this thing is
just a dumb data carrier so this is a
feature that is currently being actively
discussed there's a write up on it that
that's been published
there is a prototype available if you're
willing to clone a repo and build it
which isn't very hard so you know the
the URLs are their building instructions
are there so this is going on in the
open JDK project amber and when one of
the various branches okay so data
classes give us boilerplate reduction
but they're not about boilerplate
because they're they're about something
else they're about a declarative
statement of saying I'm just a carrier
for my state and the boilerplate
reduction derives from this semantic
commitment
because it allows the compiler to infer
the state-driven methods and actually
quite a bit more but of course the
Devils in the details would F would if
what if I want to add some validations
of constructor what if I want to tweak
the rules for equality a lot of these
things are doable some of them may not
be I'm not going to go into the details
right now but if you're interested you
should get involved in the discussion in
project amber but a good analogy here is
think about enum so we added enums in
Java 5 there was a well-known types a
phenom pattern that you could use before
Java 5 but it was verbose had a lot of
boilerplate and you know the the basic
trade-off of enums is I as the
programmer I'm gonna give something up
I'm gonna give up control over the
instances of my enum and seed that to
the runtime who's gonna manage them for
me in return I get all this boilerplate
for free then I don't have to write
write so that's a good trade-off right I
gave something up semantically giving
that up enable the compiler to generate
a lot of code for me then I could reason
about the game is the same for data
classes right what we're giving up is
something different we're giving up the
ability to decouple the relationship
between the API and the representation
and what you get is all of the standard
state related boilerplate comes for free
and actually a little bit more now a lot
of you are probably thinking I've seen
this before data classes are really half
of another feature algebraic data types
algebraic data types are product types
and some types data data classes are the
product type the other half is the is is
some types which is the ability to say a
shape is a circle or a rectangle and
nothing else and that enables you to
reason about exhaustive nosov have I
covered all the cases so you can think
of a some type is a discriminated Union
you're saying a shape is exactly one of
these things and there is a
well-understood way to reflect some
types in in object-oriented languages
which is a seal of classes this is a
technique that's actually been around at
least thirty years although a lot of
people think it was invented a lot more
recently so I could say
shape is a sealed interface that means
I'm gonna control who my subclasses can
be and I'm gonna say that two of the
subtype that the two subtypes of shape
are circle and rectangle the properties
of circle are a center point and a
radius the properties of a rectangle are
the lower left and upper right points
and not only have I defined what it is
to be a circle and what it is to be a
rectangle but the compiler will know
that the only thing a shape could be is
one of those two things and so you can
you know you can reason by cases and the
compiler will help you
you know verify that you've covered all
the bases so this feeds into another
pattern another feature that that you
you you you may be familiar with from
other languages which is pattern
matching so think about the switch
statement in Java the switch statement
is a generalization of the conditional
operator but it's really limited it's
limited in the types you can switch on
it's limited in what you can compare to
with case labels they have to be
constants and it's limited to statements
but not expressions and once we get
beyond what we can do with switch we
tend to reach for the visitor pattern
how many people here use visitor how
many people here love visitor yeah
nobody likes visitor because it's all
boilerplate it's kind of like the
dancing bear you know it's like the
first time you see it you think oh it's
cool that you can do this at all but you
know that the impressive thing about the
dancing bear is that the bear dances at
all not that the bear dances very well
right and so you know visitor pattern is
like an is a dancing bear so we can
rehabilitate the switch statement to
eliminate the need for that visitor
boilerplate with pattern matching so
let's motivate this a little bit here's
an example some typical code where you
have an object whose you don't know it's
static type and so you have to case off
it's dynamic type are you an integer are
you a byte are you a float are you along
etc and of course every time you ask an
instance of question the next thing you
have to do is cast and this is
repetitious repetitious code is
error-prone because it gives bugs a
place to hide it's also not that fun to
read and it's not that fun to write so
you know and then because I have to
do everything with statements you know I
I even though what I really want to do
is say assign to this formatted variable
exactly once in each of these blocks I
don't really have a way to say that in
the language and so I might end up
forgetting to make the assignment in one
of these blocks and if my test doesn't
catch that maybe I'm out of luck
so you know I have this long chain you
know if then else it's less readable and
as a bonus it's slower because I'm
turning what should have been an O of
one operation into an O of n of
operation and it's kind of like it's
kind of insulting right you know that
every time you do an instance of the
next thing you have to do is cast why do
I have to write that what else could I
possibly do and you know because it's
boilerplate II I probably cut and pasted
and maybe I forgot you know to make the
cast agree with the instance of and now
I have a latent bug that maybe my tests
don't find so you know this is what we
do because it's all we have but we can
definitely do a lot better so we would
have liked for that code to be a switch
but it couldn't be because the target
wasn't one of the blessed types the case
labels weren't constants so let's do
better let's make switch better let's
make switch work over patterns so what's
a pattern a pattern combines a test are
you one of these things with a
conditional extraction if you are one of
these things then let me pull some state
out based on that assumption and then
let me bind those things to some fresh
variables so you can think of the
existing case labels as as kind of
pattern they're constant patterns
they're saying are you equal to this
constant string foo we can generalize
this we can define a type test pattern
where the applicability test is instance
of are you an instance of this thing and
the conditional extraction is well cast
it to that type and bind it to a local
variable so we can write this case
integer X what that means is is the
thing I'm switching on an integer if so
casted to an integer and bind that
integer to this fresh local variable X
and if I rewrite the switch with that it
gets better right so all of the instance
of and cast boilerplate is gone
it's getting a little bit more easy to
read what's actually going on in this
code I can actually see my business
logic okay improvement but there's still
some repetition I'd like to get rid of
it's I've turned it into a switch great
now the language has helped helping me
you know struck you I'll use the right
control structure it's still a statement
which means I have to do this these
breaks in every case that's kind of
annoying but we're moving in the right
direction but morally what we would like
for this code to be is an expression and
there's really no reason why it can't be
an expression so you know the way to
read these is kayson's a dry means is
that is the target and integer if so
cast it to an integer bind the results I
and then I can use I in the in the
resulting you know statements and the
scope of I is limited to where it makes
sense to be limited to so okay that was
an improvement easier to see the code I
usually the logic for the code fewer
places for bugs to hide but still not
all the way there I'm still mistakes we
could have made still some repetition
we'd like to squeeze out what we would
like is for switch to be an expression
and you know the then the compiler would
enforce that we were assigning to that
target variable every time through and
in fact we can do this this is fairly
straightforward we can have switch have
both a statement form and an expression
form that have slight syntactic
differences and now the code is starting
to look like what you had in your head
when you wrote the horrible code in the
first slide right you know I know that
this thing is going to be one of these
five types so if it's this one do this
if it's this one do that if it's this
one do that and you know make sure that
I've covered all the cases and if I
haven't uncovered all the cases the
compiler will help you so this is you
know a lot less code and a lot more
readable and also faster because we can
we can generally do this in O of one
time if these are all final classes so
we also have a prototype available for
this so people who want to play with it
can go clone this repository and start
playing with it again still a work in
progress so there may be rough edges if
you runs a bugs please do
report them okay one of the things I
love about pattern matching is that it's
something that can go deeper in a number
of dimensions so the example I showed
you know so far pretty straightforward
but it can go a lot deeper than this so
one of the directions we can take this
is we can use patterns in other language
contacts so right now we have an
instance of operator X instance of type
we can extend the instance opera
instance of operator to take a pattern
on the right-hand side so here we've
called it matches I'm not sure that's
what it's eventually going to be called
but you can say if this thing matches
you know this type bind it to this
variable and then use that on the rest
of the expression and so most equals
methods that you write have pretty nasty
control-flow it's actually kind of hard
to follow them because there's all of
this well if if this is the case return
false if that's the case return true
otherwise go into this big you know
hairy short-circuited operation but use
it using a pattern we can turn the whole
thing into a single expression that's a
lot easier to read so you know that's
that's kind of a nice benefit of once
you have patterns in the language you
can use it in a lot of different places
okay so let's rack up the scoreboard so
far we generalize switch to arbitrary
target types we generalized constant
case labels to patterns we added type
test patterns we allowed switch to be an
expression as well as a statement and
we've also supported patterns in a match
expression so that's kind of nice let's
do more types of patterns are cool but
they're simple most of the time after
you do an instance of test and after you
cast it to something you're going to
extract some state from that thing and
use it so this kind of begs for
something we call deconstruction
patterns so the way a deconstruction
pattern looks like is it kind of looks
like a backwards constructor call if I
say case point VAR X VAR Y what that
means is argue a point if so cast it to
a point go get the components of the
point and bind them to the local
variables x and y right so we have in
applicability test a conditional
extraction
and binding of you know zero or more
binding variables so you can think of
this as the opposite of construction
where you know constructor takes some
state and turns into an object this
takes an object turns it into that
constituent state now this connects to
the data class feature we talked about
earlier because data classes make this
commitment that their state is coupled
to their their API and one of the things
that you get from having made that
semantics concession is that
construction becomes a mechanical
irreversible process that Nui can can
deconstruct a data class into its
constructor arguments automatically so
you know that's this is you know this is
similar to what you see in the in Scala
with case classes not only do you get a
bunch of boilerplate reduction from case
classes but you also get an extractor as
well so you know obviously you know we
want it we want to match on more than
just data classes but with data classes
you get this ability for free and that's
kind of nice so let's take a look at
what that looks like
we had our shape interface before so we
said a shape is either a circle or
rectangle and we want to compute the
area of a of a shape and we know that
means that it's going to either be a
circle or a rectangle so we have to
handle both of those cases and we can
use a deconstruction pattern to take the
shape apart we can say switch switch s
case circle VAR Center VAR radius and
what that means is are you a circle if
so cast to a circle get the center bind
it to see get the radius bind it to R I
know what the types are because I got it
from the deconstruct the signature of
the D constructor for the circle and I
can just feed that into my PI R squared
calculation and similarly with a
rectangle the deep constructor looks
different because the rectangle has
different state but it's the same game
are you a rectangle if so extract the
lower-left extract the the upper-right
and compute Delta X and Delta Y and
multiply them together and I see some
people are like smiling because they
know that I've forgotten an absolute
value in here somewhere and you'll
notice I don't have a default case
because I don't have to have one because
I told the compiler that a shape is
either a circle or a rectangle and I
started with a shape and a handle circle
when I have a rectangle and that means
there's nothing left to handle so the
compiler you know would tell me if I had
forgotten you know something in this
case I haven't so it's not gonna
pedantically remind me to say you have
to have a default case whose action is
throw some exception that says I should
never get here right isn't it annoying
to write these like exceptions for you
know a place where you think is never
you're never going to arrive in the code
let the compiler do that the compiler
will generate the default case in case
between compilation and runtime somebody
changed the definition of this this
subtype which they shouldn't have done
so a Deconstructor pattern
combines an instance of a check filled
extraction and binding to local
variables but it's just another kind of
pattern so this is kind of nice and you
know of a question that came up a couple
of times uh you know or this this week
is people look at that look look at this
area code and they say what couldn't I
just make that a virtual method and of
course you could make that a virtual
method and sometimes the absolute right
thing to do is to make that a virtual
method and sometimes the absolute wrong
thing to do is to make that a virtual
method and in fact most of the time when
we're using the visitor pattern we
shouldn't be making it a virtual method
we want our polymorphism to the ad hoc
in that case we just don't want to pay
for all the boilerplate of doing that
with visitor and with pattern matching
we don't have to so this is cool but
let's do more we can take this even
further now it wasn't obvious at first
but when I say case circle VAR c VAR r
what does VAR c and VAR r mean in this
context it kind of looks like a
declaration it's designed to look like a
declaration but it's actually not a
declaration it's pattern it's a pattern
that matches anything but when i say
when i put a pattern nested inside
another Deconstructor pattern what that
means is well do the outer pattern first
are you a circle if so cast it to a
circle extract its components and
in try to match those components to the
nested patterns in this case because VAR
c and VAR r will match anything it just
binds them to see an R but if those were
more type test patterns or deep
deconstruction patterns
it would recursively chew through them
and check the mate or check the
applicability test of all of those so
we've actually seen quite a few kinds of
patterns now constant patterns which
only match a particular value type test
patterns which only match a particular
type D construction patterns which match
a type and conditionally extracts its
State and then match that state the
other patterns and then we have this
these anything patterns like var X and
for completeness also they match
anything but I don't care what you call
it pattern and book we can nest these
actually pretty deeply so if I say case
point 0 0 what that means is match it to
point extract the x and y a point and
then match x and y to the constant 0 and
that will only match the point 0 0
I can nest a deconstruction pattern in
another pattern so I can say are you a
rectangle if so extract the components
what are those components there points
do I have a a deconstruction pattern for
point yes I do I can match those to the
lower left and upper right points and I
can have more patterns that are nested
in there and I can deconstruct something
all the way down not just to its
constituent points but to the x and y
that are buried in those points with
match anything I don't care pattern I
can say you know don't even bind any
variables for that I don't care what it
is it matches everything I'm only
interested in the lower-left you know a
point I don't need the upper right don't
bother me with it don't run any tests
for it and I can play this game
arbitrarily deeply I can say you know
are you a rectangle whose lower left is
the origin and and then bind X and Y to
the coordinates of the upper right so
this is a pretty deep feature this is
something that we can continue to extend
over many versions and that's great
because we have a more rapid delivery
model where we
deliver part of a feature now and then
more of a feature later and more of a
feature later so you will probably see
this feature rolled out in stages where
the easy stuff like type test patterns
will probably come first and then maybe
you know deconstruction patterns with
data classes will come next and maybe
arbitrary deconstruction patterns will
come after that or maybe some other
order but you know we we don't have to
make people wait forever until we've
like done the whole thing before we can
deliver any of it we can deliver it in
pieces so one last feature I want to
talk about that's related and because I
can't not talk about this you know you
have when you have trauma you have to
vent
so I'll vent a little bit about
serialization one of the things that
this offers us is a path to saner
serialization data classes make the
semantic commitment that they're just a
carrier for their data that's what
enables us to safely and mechanically
generate construction and deconstruction
code it also allows us to safely and
mechanically generate marshaling and
unmarshal encode that can go back
through the constructor on the D
serialization path which eliminates all
of the myriad security compromises of
serialization so all of this together
together gives us a path to a better
serialization model for plain data which
most of the time is what we're
serializing anyway and it also allows us
to decouple serialization from the
actual wire encoding you know the the
Java serialization wire format is both
disgusting and and big and unpleasant
you know we can we can you know we can
serialize to something else json xml
protobuf whatever you want so you know
there's a lot of depth to these features
like I said we're not going to roll out
all the pieces at once but but there's a
there's a pretty deep pipeline here okay
so summing up on my last slide why are
we doing all this well people are gonna
like these features they're more fun to
code with if you've coded languages that
has pattern matching it's hard to go
back to a language without it
so we think people will really like
programming with these features but we
also think people will write more robust
less error-prone code by eliminating
unnecessary redundancy so you know
pattern matching can eliminate almost
everything we do with visitor with code
that's just a lot easier to read and
therefore a lot less error-prone
these features are also really good fit
for the programming models that are
becoming popular in the cloud these days
which are almost all message based so
function is a service message fabrics
like Kafka actors these are all about
exchanging messages and it would be nice
for messages to be strongly typed but
easily decomposable and easily
serializable and so these are a really
good fit for the programming models that
are getting more popular today and
there's also a hidden benefit here which
is as an API designer pattern matching
gives us another way to design API is
that's often less error-prone than the
way we do it now so we think this is
something that's you know good in the
short term and good in the long term and
so that brings us to the end of my
prepared material I made a deal with the
organizers that we could stay for
question and answer if people want to
stay if you want to leave by all means
please leave
but please do so quietly so the people
who are participating in the QA can can
hear what's going on so if we have
questions okay we're gonna start here oh
hang on wait a second your question
so that so you're you're saying what
about immutability is that your question
with data classes okay so this is a
great question right we're constraining
the programming model and someone comes
along saying I've got a really good
constraint for you to impose on all Java
users how about making them immutable
well that's a great idea
immutability is great for a lot of
things not everybody would thank you for
that
if you look at what other languages have
done in this space
Scala Collins c-sharp they've all gone
down that route and none of them ended
up with immutable data classes they all
ended up with some way to make them
mutable which tells me that forcing
immutability in this fashion is not
something people are going to thank us
for on the other hand we can do half of
that we can give people a nudge towards
the mutability by saying yes they're
immutable by default if you want to make
them mutable you can you can opt in we
think that's a pretty good balance I you
know as much as I would love to make the
default immutable I think it would be a
fool's move and also we would like for
data classes to essentially be a macro
for other language features we don't
want them to be this weird bespoke
language feature on their own because
when people reach the point where they
have to refactor from data classes to
real classes now there's 37 differences
that they'd have to contend with so that
that's that's the answer we had a
question over here yeah speak up please
the relationship between data classes
and compilation units so data classes or
classes with you know so you know Java
has restrictions on how many classes
public classes you can have in a
compilation unit
this isn't necessarily a big deal for
data classes but it is a big deal for
sealed classes because when you say a
class is sealed you're saying I can only
have certain subtypes well who are those
subtypes are they members of my module
of my package of my compilation unit
it certainly is convenient to say
they're only the members of my
compilation unit because when you
compile multiple classes from one
compilation unit they can't get out of
sync for it with each other and so we
would like for sealed classes to mean it
can be extended by other things in this
compilation unit so that certainly
allows for nested classes but people
don't necessarily want they're sealed
sub types to be nested types so we what
we will likely end up doing is relax the
restrictions on multiple classes profile
not completely but enough to allow a
complete you know sealed hierarchy to be
specified in one one compilation unit is
is that that what you were asking
basically okay cool thank you any other
questions yeah over here yeah okay so
the question is why did you pick funny
names so the reality is whatever named I
picked somebody in this audience would
say why did you pick that funny name why
didn't you pick this different funny
name there's no name that's gonna
satisfy everybody
these aren't and by the way these aren't
necessarily the answers we've picked you
have to put something on the slide so
you have to pick something so that
people can see what the code looks like
maybe these are the final names maybe
they're not but ultimately it's a very
subjective choice
some people think case class is a great
name some people think it's a terrible
name and I think they're both right so
whatever we do some people will say yeah
you got it right and then all the people
who speak out out loud will say you
idiot you got it wrong
Mario
yeah so Mario points out that like well
you have this keyword so you can reuse
it and that's true and it's good to
reuse keywords when it makes sense and
it's terrible to reuse keywords when
you're just doing it to reuse the
keyword but it's not actually a very
good fit so there's you know all things
being equal yes let's not make new
keywords let's not make the the parsha
grammar any more complicated than it is
certainly you know are our friends who
write ideas would not thanked us for
adding a bunch of new conditional
keywords but sometimes the keywords we
have are not a particularly good fit
either and now you have a situation
where you have language feature that has
a terrible name because it's the same as
some name that we decided to reserve 20
years ago and that's not good either so
it's a tricky balance no question any
more questions yeah on the end there is
the goal to automatically be able to
build the switch is that your question
so in that particular case you could do
it as a switch where you say switch
other thing case all of the stuff
default false you could do it that way
you don't have to I don't I think that
would not be that would seem like
overkill to me but a perfectly fine
style choice if you want to do it that
way but that's not not necessarily what
we're thinking
ah okay so yes so the match's expression
is an expression so you can say if X
matches Fuu VAR y now the scope of y
includes the whole body of the F yeah
absolutely anybody who hasn't asked a
question yet I want to give priority to
them I thought I saw a question on the
on the end
oh yes over here I'm sorry I've only
been looking on this side of the
audience bad me great question okay so
the question is so I'm letting you a
lead the the manifest type for local
variables but not for fields or method
return types but why not for private
fields or the return type of private
methods because that information isn't
escaping the compilation unit why not
use type inference there as well and the
answer is we could do that that would be
a perfectly fine decision um it would
conflict with another goal which is that
changing the accessibility of a member
you know should be a compatible change I
shouldn't if I wanted to take a method
that's private and make it public I
should be able to do that just by
changing the modifier I shouldn't have
to also go change the form of the
declaration so that would have been a
reasonable choice it's not where we
chose to land because we thought it was
cleaner to draw the line to say locals
yes everything else no but we could have
drawn a sort of more complex line to say
locals and things that don't escape the
compilation unit would be okay that
would have been an okay choice but
instead we chose to make a simpler
division because we think it'll be
easier for people to keep in their head
any other questions on this half of the
room yes
yes okay so the question is what about
classes that weren't those data classes
how would I do
deconstruction patterns on them are you
going to like crack open my
encapsulation and reveal my fields to
everybody no of course we're not going
to do that so the the trade-off data
classes make is I'm willing to give up
some encapsulation I'm willing to say
that I'm just a carrier from my state
I'm willing to give up my state freely
you can freely deconstruct an object and
reconstruct it into another object and
get the same thing out so that's the
trade-off you make with data classes
which is a good trade-off for some
classes and a terrible trade-off for
things like say say a certificate
manager you know which wants to
encapsulate its state so if you have a
class that's not one of these data
classes but it wants to give up its
states so that it could be matched you
would have to declare a matcher the
natural would be a program member just
like a constructor it would be a
Deconstructor there will be a syntax for
it I didn't show you a picture of that
because we're not quite sure what that's
going to look like still working that
out but there will be a way to say I
have a class and I want it to be
deconstructed Bowl with this signature
and here's the code that does it and
maybe I have multiple deconstructors
maybe I've overloaded them and then the
data classes again just become kind of a
macro for a class that has this
constructor and this D constructor and
this equals etc so the the programmer is
fully under control of the encapsulation
but using data classes is an explicit
I'm giving up some control over
encapsulation it's not you know and
that's what kind of what I get mean
about it's not a feature that's just
about boilerplate it's a feature about
what kind of class is that from which I
can derive all those boilerplate
simplifications so let's take one more
question and then break okay go ahead
yeah that's that question yes okay so
the question was you know I showed
conditional decomposition using
decomposition in a switch statement or
in the body of an if if X matches you
know a pattern
what about situations where I just want
to unconditionally decompose because I
know it's gonna match and I just want to
say take this thing and explode it into
its component parts and I want to do it
in one line of code instead of you know
and put n lines of code are we already
thinking about that yes the answer to
that question is yes we are thinking
about that I don't have a committed plan
for what that's gonna look like but it
is a obvious and sensible thing to want
to do so all right well thank you very
much for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>