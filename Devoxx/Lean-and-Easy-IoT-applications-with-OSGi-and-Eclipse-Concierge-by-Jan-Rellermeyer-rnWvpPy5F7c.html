<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lean and Easy IoT applications with OSGi and Eclipse Concierge by Jan Rellermeyer | Coder Coacher - Coaching Coders</title><meta content="Lean and Easy IoT applications with OSGi and Eclipse Concierge by Jan Rellermeyer - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lean and Easy IoT applications with OSGi and Eclipse Concierge by Jan Rellermeyer</b></h2><h5 class="post__date">2017-04-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rnWvpPy5F7c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so I think I don't need a
microphone can you hear me well yeah
okay well thank you for coming for my
talk my name is Jana Gana mana and with
IBM Research in austin texas and also an
adjunct professor at the University of
Texas and today I will talk about Lena
easy IOT application with osgi and
eclipse concierge so um greetings from
well lawyers indeed how many in here of
you are aware of IOT and osgi yeah so a
few of you um I you know for me of osgi
is really the natural fit for IV and
that comes from the fact that actually
osgi was invented for things that were i
OT before you used to call them that way
right so in the old days we had these
set-top boxes on top of televisions and
they were supposed to be the gateways
for what people thought were smart homes
back then right and these devices had a
distinct problem they were running very
long running software right they were
running basically all of the time and
you need to make software updates to
them which is a very common problem of
software lifecycle management so what
was the state of the art back then in
the days well it's basically the
antithesis of agile software development
right it's the reboot button every time
you change something in your system you
have to do a full system reboot and
that's of course very unpleasant so the
entire idea of osgi initially was well
you might have different applications
running on your set-top box so most of
them are actually completely disjoint
right if you want you like them properly
and what are the dependencies between
your application components properly you
can restrict the scope of a reboot to
those components were actually affected
and the rest will just be fine it up and
running right so that was the original
motion motivation for words di and I
think these things are still true in
today's world with IOT maybe even more
so because you know the update cycles
back in the day was maybe a quarterly
update they will
coming from your provider these days
applications has to be much more agile
and time-to-market is much shorter so I
would really say that the problem of
software lifecycle management has become
more severe and not less right so um how
does osgi manage that well the unit of
modularity and always g is called a
bundle right a bundle is really not
something new in the sense that it
affects on the jar file format so no
special tools required other than
enhancing your medicine and basically
making your dependencies explicit right
so in some sense a bundle is just a jar
file with additional metadata right um
in order to run these bundles you need a
runtime environment that sits on top of
your Java Virtual Machine and this is
called a framework you can debate
whether or not that's the best way to
call it but that's the name that the
original developers use for it right so
the framework is an actively running
component which allows you to manage and
interact with your modules with your
bundles are the way you want and control
their life cycle in an explicit way um
the next thing that you have is that
these bundles implement isolation right
isolation in the sense that every bundle
by itself is just a unit of ice on their
isolation you cannot share things
arbitrarily which in a job that's a
machine normally you can write when you
load a jar file into your classpath it's
becoming globally available right so you
limit the scope of sharing to the
dependencies that you have explicitly
declared and that way you can minimize
the effect of life cycle management
event to those modules that are directly
affected now the final component in osgi
framer on the module layer is because
things can be dynamic and change over
time you should actually listen to these
change event right and almost an osgi
framework gives you an infrastructure to
subscribe for events and your
application has a transfer
them accordingly all right arm this is
my picture of a running osgi framer that
I used for many many years to explain
how sharing works in such an environment
right you are sharing an osgi is by
default package right so you want to
have multiple packages some of them
might be private which means they are
application dependent and not intended
to be API and all of them will be hidden
from the rest of the world right unless
you explicitly declare them as being
exported they will be completely in
isolation which is actually good okay at
the point where you export a package
this package is now available to the
rest of your system and other bundles
can import them which this one of you
does for package one right and they
themselves you know indeed also export
packages now whenever you have such a
relationship between export and import
package we call it a virus analysis at
runtime you will have a provider yes I'd
interrupt would you mind putting this on
no here you on the recording short thank
you just clipping in your pocket yeah
well okay so um this wire means that
there is an export and import
relationship in your system and these
wires is what we can track right in
order to minimize the impact in any
realistic system we will actually have
multiple versions of bundles running on
let this be an application server right
it's very often the case that you have
the same exact package conceptually but
different versions of it because some
components in your system might have to
bind to different revisions of the same
software logging frameworks are
notorious for that all right so another
thing that osgi has introduced is
explicit versioning for packages right
every export and import should hopefully
have a version attached to it imports
usually have ranges so you can say this
bundle here can tolerate an import of
let's say log4j in the range 2.0 until
3.0 exclusively right and that way you
have the freedom in your system to have
multiple versions which honestly in java
otherwise you cannot be
so you get name collisions but because
we have isolation our system and every
bundle is loaded through a separate
class loader this osgi framework can run
multiple systems multiple variants of a
bundle at the same time saluting ok so
so much for the module layer now if the
module layer was all that really had it
wouldn't still be a very flexible system
right because in at the end of the day
if you have a piece of software that
depends on other components just
component izing it doesn't make it more
flexible at Sur at a certain point in
time you need all of them to be present
in your system otherwise your
application will not look right because
at the end of the day Java is a language
that does late binding but at the point
where you need to bind it basic becomes
a linker level dependency right it's the
equivalent of doing dl open in good old
C programs right at the point in time
where you do it and you don't have the
dependency available you're so full of
fail all right so um volumes alone is a
good way of managing your life cycle but
it still creates tight coupling in your
system and ultimately limits the moral
arity this is why osgi has introduced
another component that is called the
service layer so you have a central
service registry in your system and
every bundle can also register services
or ask to consume services okay now the
entire idea behind the service is in the
end very simple if you have your
implementation and you have strength
away from it through an interface the
link and lever dependency will be solely
on the interface and not on the
implementation right and that is
ultimately what causes loose coupling in
your system because at the point where
previously you would you know do late
loading and fall into a hole because the
component wasn't there in this system
you might only need the interface and
that can be part of your application and
then you can dynamically look for a
provider in your system thank you don't
you don't need to be coupled to this so
services in the end cause loose coupling
in your system and osgi
even before microservices were thing was
doing that on a single Java Virtual
Machine and in the least obstructive way
that you can implement it because in the
end you can ask for osgi service pretty
much by its name or by its class but at
the point in time where you have asked
that to the service registry you will
get a Java object in return so there is
no full proxima k shun going on like in
je right there is no overhead so
consuming a service after you have
retreated from the service registry and
that was indeed motivated by the
original design domain which was
embedded systems where you cannot afford
full participation you to be overhead ok
now the same things that I said for the
module they are indeed true for the
service layer in that you need to listen
to events right and you can listen to
events so if your application for
instance supports logging as an optional
part right in the sense that it can do
fine without a logger installed it will
just don't lock and at the point where
you really need lock output you just
dynamically install a lot component
right what you would do is just listen
for this service becomes available event
and then you can retrieve the lock
service and start producing log output
dynamically that indeed is a lot more
loosely coupled and a lot more flexible
another thing that is important to point
out services help you with em to end or
n2m dependencies right there can be
multiple service providers in the system
and you just pick the best one based on
the criteria an osgi supports full ldap
string filters in order to match
whatever means the best available
provider of the service right and at the
same time you need you can have multiple
consumers of a service in your system so
on this ultimately is what makes
building osgi applications for is you
really present right there is this
whiteboard pattern in the OSGi universe
which is often used in order to decouple
event sources and event listeners I in
order to just fully appreciate it think
of a traditional public subscribe
system normally what you do is if you
are interested in consuming an event
right you have to explicitly to
subscribe to a provider right so the
sorry suit to a publisher right so that
means in the event that there is no
publisher available you have two special
case all this code right and wait for a
publisher to become available and so on
and it's also not trivial to consume for
multiple publishers right now the way
how you solve that is just creating this
middle entity here which conveniently is
just the OSGi service registry right so
in this universe on the event listener
who register itself and thereby mark its
availability and everybody who wants to
publish something or just try to look up
all the listeners that are available and
sent the events to the listeners right
and thereby you have a nice system in
which you can model this n2m
relationship very conveniently now in
the end this is not rocket science
because if you think a little bit from a
high level perspective this is exactly
what a message broker would also do for
you in the large scale write the message
broker is a mailbox component in the
middle we're basically publishers and
subscribers can individual themselves
and then the broker interconnect these
right but here you can do this within a
single java virtual machine on and
basically exploit this functionality at
the very lowest level to bright more
flexible applications so we have this
eclipse concierge project that we have
been working on for a little more than
two years i think now very actively and
initially we had this idea of you know
osgi is really a natural fit for IOT and
it's coming from this domain but many
implement implementations of osgi have
significantly grown over time simply
because osgi became tremendously popular
in you know large-scale applications
such as application servers or even your
Eclipse IDE is a pretty big application
by itself with hundreds or even more
bundles right so we wanted to see if we
could reduce the footprint of osgi up to
a level
it's really nice and pleasant to use
this on an embedded device and I
initially wrote an r3 implementation
back in the days that was still around
but we thought it was time to bring it
up to speed with the latest standards
and pretty much allow me to use the same
runtime environment that you would also
use maybe server side or in large
applications so our goals were pretty
clear right what to reach osgi core our
five compatibility which was pretty much
the latest though at that time right at
the same time we want to keep the
footprint small it small enough to work
well embedded devices and also remain
readable by that we mean the source code
right osgi is not the easiest ways to
understand and the old implementation
was actually used by quite a lot of
people in order to understand how a
framework internally because it was just
a handful of classes and you can
actually read it right at the same time
the state of the art for a very long
time was that java on embedded was
basically behind java on larger systems
by a couple of revisions right so the
best that you could get pretty much
right before we started was a Java 14
compatible virtual machine simply
because you know the CDC Foundation
provides and so on they were never
updated after Java moved on to five and
six and seven so we worked on this for a
while and I think we made good progress
with all the goals right in the end we
settled for Java five because the
compact profile was coming to our rescue
so you know we thought compact is
something that you would actually run on
let's say a raspberry pi or so not
necessary and need anymore to remain
compatible which one for but if you look
at it it still has only nine classes of
45 minute classes or so that's the
nature of Java right in terms of sites
we are at 250 kilobytes without debug
symbols and if you want debug symbols
330 kilobytes that's pretty small by the
center of those GI framework and oh
pretty much last year we achieved the
goal of being our five fully out five
core compatible
so um how can you build applications
with the concierge framework well on let
me just switch my screen real quick and
show you a little bit how that works in
practice let me see hey yeah yeah so
this is my Raspberry Pi the device that
is dangling here from the lectern right
um and if you just install concierge the
latest snapshot um you can do already a
couple of things with it so we provide a
couple of applications out of the box
and maybe the easiest one is just the
shell application right so just go into
the containers folder that you will get
use your java virtual machine um right
and then start it um the information of
which bundles you want to start is
stored in an X art file that's kind of
borrowed from the fish in case you have
ever worked with it they're just a small
text file that gives you imperative
instructions what to do one system
startup and you know after 0.008 seconds
which is pretty good on an embedded
device you get a shelf and you can
already introspect what's going on into
your system and so on right so you can
see the bundles and services okay um
let's close this down so I said pretty
much you all that you have to do is
write a little x-art file and we go a
little bit beyond what you can do with
tropical fish because we use this in
environment where changes are happening
frequently so one problem that you might
already know from your experience is you
know you build all these integration
bills and snapshots bills and whatever
right here we support variables and
white cards in order to affect these
things out and basically you
you run your startup script right so
what you see here is we have prefix some
of our bundles that we want to install
and start with this repo command and
then we can quickly switch from an
environment where we want to solve them
right from the internet to an
environment where we lock them from the
local repository right those are kind of
productivity things that make working
with especially on an embedded device a
lot more pleasant present pleasant right
the other thing is we support wild card
so you don't have to give the exact same
build number right which changes every
time that you may be run you you build
just use the white card and and will
pick up the latest version because it's
sourced bye-bye lexical sorting okay so
that's basically all that is involved in
order to get into this technology just
download it and write an Xbox script and
start your components okay now once you
build more sophisticated things so you
might want to have something better than
just a command-line interface and as
part of concierge we have implemented a
rest interface for osgi frameworks in
fact that's even the reference
implementation for the red standard um
and yes we have finally integrated this
into our built if you download one of
the latest special releases it's coming
as part of it right so what I can do now
is go back
just if you go into the full
distribution you see that there is a
bunch of scripts already provided with
it and one of them is the rest
implementation so what I can do is just
start or is it start to concierge
framework Oh memory jar and then I give
it a startup file and that would be
sampled rest okay and you know take some
tight a little longer because it's
starting a full web server and so on but
you know at this point I basically have
arrested interface to my embedded device
and now if I pull up another window I
can make rest calls to my device for
instance introspecting you know all the
bundles and yes if you saw that the
exception here it's because this thing
does not rock through to the internet so
it cannot get the schema right that is a
necessary evil in such an environment
okay so um you know this is basically
another way of interacting with your
knowledge GI framework in an IOT
environment and you know I would think
the nice thing about that is that you
can seamlessly use that in let's say
your web interface right so if you are
building an application you might want
to abstract away from bundles and you
know services and provide a view that is
more consistent with your business logic
but in the end in order to do so
successfully you need to have access to
all the bundles and services and
introspect estate right and this thing
here makes it very easy to write your
interface for your application while
having access to the low level
information all right so um let's have a
quick look of
on what other people have done with our
implementation although other people
mainly involves micrometers in these
examples this is one thing that yahan
gira from deutsche telekom has worked on
there is this it exists smart home
project a conveniently that the chair is
even here in the room right and he took
the exercise and took basically smart
home adapted it to run on concierge and
you see that he made a couple of changes
not all of them are directly related to
concierge is more of a concerted effort
to reduce the footprint right but if you
look at the different numbers between
open app to which is the full fledged
implementation of smart home and his
distribution that runs on concierge you
see that you know there are a couple of
interesting differences right the
distribution size has definitely gone
down quite a bit he also got rid of some
of the frameworks that might not
necessarily be the best idea to run on a
small and embedded device but in the end
he brought it down to a point where it
runs on compact two or compact three
which reduces the footprint of the java
runtime and in the end you know memory
footprint has gone down and also startup
time has gone down and start time might
seem trivial but at least at the point
where you be buying something and you're
doing it 20 times per hour that can
really make a difference straight um
another thing another committer of the
project team for bailin was very active
also working on the concierge framework
he works in the research lab in belgium
called I mines and and they are all in
on I OT and you know machine learning
and so on so what you see here is what
they call their internet of things of
that this is an application right you
see a view that is application specific
but it runs on the concierge framework
and it's using all the low level control
mechanism and control points into the
framework and basically what they have
is a system where you can compose your
IOT application provide reusable units
of IOT logic and then do the
orchestration and because they combine
it with the idea of
osgi remote services they can basically
seamlessly distribute components and
change the deployment if you need to so
let me see if their works where you see
here is one of their setups that is
actually an orange detection system very
very sophisticated right and it consists
of a couple of components here right
what we have here is an nvidia Jetson
that's a small embedded platform that
has a very good GPU power and that's
what you really want for machine
learning algorithm because it's a lot of
floating point number crunching right
then we have a Raspberry Pi right there
we have a robotic arm we have this
camera so the setup is that you will
place a fruit here in front of this
white screen the camera will detect the
picture the Jetson device will analyze
the picture with the machine learning
colonel and then decide whether or not
this is an orange and if it's not an
orange the robotic arm will just swipe
it away right now the nice thing and the
big enabler here is he runs concierge
both on the Jetson and the Raspberry Pi
and let's say if you did not have access
to a Jetson platform you could just move
this component out in the crowd right
and use osgi remote services and the
application would actually require
absolutely zero modifications to the
source code so by modularizing and
component izing your system you gain the
freedom of picking a deployment that
makes sense based on your systems
requirement so just for fun I can show
you how this works oh yeah and there is
this light bulb you see it's red when it
doesn't detect something and then it
will turn into either yellow or orange
which you can't really tell in the video
but look let's play this video so first
object for detection it's a lemon Go Go
okay second test object orange
except okay so you know you could see
how these applications can compose and
become larger and eventually a bit quite
sophisticated IOT application out of
individual components but yes the
ability to pick your deployment and move
components around is actually a very
strong enable in this case another use
case that then worked on he's actively
in contributing to the osgi Alliance on
embedded systems and they have this osgi
and route of all would you pronounce the
french framework which normally requires
an osgi r6 implementation but Tim
basically worked on concierge and
brought it to our six kind of compliance
in a snapshot branch so he actually uses
or root also with concierge and it's
very easy to integrate it great on route
is all about bnd tools using bnd tools
for build and deployment and you can
just specify concierge as your framework
and it will just work out of the box no
need to change anything okay so you've
seen a couple of use cases but you know
our claim to fame is trying to be lean
and performing well on small devices
which I still have to prove to you right
so in all of my talks on concierge I
have this section where I just compare
the performance of the different
frameworks and you know to have some
realistic platforms that represent
embedded systems I traditionally have my
old raspberry pi b and a bigger bone
platform right they are a little bit
different devices different arm CPUs
also the the Raspberry Pi has more
memory but then it has a large operating
system so in practice the difference is
not even that much the nice thing about
the BeagleBone is that you can actually
run a 18 compact profile on it it's
relatively easy to build one and there
is a java SE embedded version 17 that
you
also runner it whereas the PI basically
comes prepackaged with a full JVM so um
let's compare the state of the art in
osgi right now so the first candidate is
the clips equinox and that I think is
the neon are two relief that was
released in last November or so keep in
mind that this is an r6 framework so it
has more functionality than the other
frameworks all the others are our five
frameworks at least in the master branch
right the other candidate is Apache
Felix released this year just a couple
of weeks off coupla fish which is still
the r5 implementation 720 release last
fall and then concierge that's the
bleeding edge snapshot that I built last
week you already see that the footprint
of the different osgi implementations is
quite different ranging from over a
megabyte to 240 a kilobyte part of that
is you know how much additional
functionality you put into the framework
because the edge tends to be very much
on the lean end the only component that
we add as an extra is logging and that
is for a good reason because ultimately
one of the negative experiences that
people have with osgi is that after
component izing and after you introduce
isolation into your system some pieces
of software will just start to fail
right they will not run anymore because
they made certain assumptions about a
flat class path where you can just do
clasp for name and everything is visible
and so on right and that requires some
massaging of your bundles until you get
to a point where the software runs again
right so there are certain implications
of going and buying into a modular world
which will at least initially manifest
themselves into failure string so we
thought having locked framework inside
of concierge is actually a worthwhile
investment because that way you can
correlate your application level lock
output with low level systems output
synchronized is correlated it's a lot
easier to make sense out of it and it
just costs us a couple of bites so you
know that is the service that you have
as an extra other than that is just the
core and the API that it's really
required so um let's compare start of
time right that is the first experience
that you will have with an osgi
framework if you're testing out this
Express technology and you see the
startup time across the tube eaglebones
VMs and raspberry pi concierge is
consistently this fastest framer to
start up right we've optimized this path
quite a lot so lower is better right and
the black bar here is I would say the
baseline because that is the time that
the Java Virtual Machine takes until it
can print hello world right just the
smallest program that you can write so
that is the part that we could not
optimize the way even if you want all
right so we are in the order of just
let's say two times maybe three times
the JVM startup I think that's pretty
decent and again from comparison we have
a simple bundle that prints hello world
so you know you could consider the
difference between here and and the
different frameworks as being the
overhead of osgi on startup great so um
the next thing is the Conservancy screen
right the service registry is the
component that you will stress most
while your application is running if you
buy into this technology because you
have this loosely coupled system so you
will access it and retreat services and
register services and so on so we
designed the stress test and the stress
test is basically registering 10,000
services that are kind of random
generated um each segment has a random
value for the same identical key I
already told you you can use filters to
find the best matching option and those
filters match against key value pairs
that you have associated with your
service right so we have the same value
sorry the same key different values and
the range for the now use is just bites
alright so 20 and 56 no use
possible perky with 10,000 differences
you get collisions at the order of 39 to
40 identical instances per service
registry just two to increase the stress
right to make sure that the system has
to work hard in the next phase we will
just perform lookups so we'll actually
retrieve ten percent of the services
that we have registered again filters
will use bide range and then ultimately
we have to unregister all extent that
some 10,000 services again from the
service registry now if we look at the
first place where you register all the
services again you see that the
concierge service registry is
consistently the fastest across the
different devices and I would say by
quite a margin service look at um this
is maybe the operation that happens most
frequently in runtime we have this big
outlier here and this is Phoenix I'm not
exactly sure why this is the case
because you know I know the Phoenix
people pretty well and they tend to tell
me how much they optimize on their
registry well at least in our
experiments there is still a bit of a
gap I would say but yes the performance
different because of these outliers
between the other frameworks is not that
big you can still see that concierge
consistently performs the bus and then
unregister a shin arm again we perform
very well across the different devices
another thing to notice and that's kind
of curious but an experience that we had
a lot with embedded devices performance
is not necessarily consistent right so
you see that for unregister a shin or
the compact one profile is faster than
the Java and bad at seven whereas for
service lookups that's not the case so
different jvms make different trade-offs
in terms of you know in terms of let's
say G threshold and how well they
support certain by codes and that's why
we design concierge in relatively
straightforward and known
this way like the code is relatively
no-nonsense imperative multi
object-oriented as you would expect it
from a large software project simply
because those things tend to be
problematic on embedded devices not all
of them might be getting away at runtime
and actually contribute to over it so
the next thing is the resolver right the
resolver is what gets stressed most if
you install bundles into your system and
in order to test it we just generated a
thousand random bundles we can just
synthesize them and runtime and then
install them and we had a little setup
that you know we pick import or export
of up to five packages totally 50
packages and so on Christ generate
random import and export ranges and then
install all the bundles now it tends to
be turned out that this benchmark is
extremely volatile and that kind of
makes sense right because you'll be
being perfectly random with how much you
import how much you export you know it
the end result is that the the
experiments would have to be repeated a
lot of times to produce stable output so
what we do for this one is we have just
materialized one of those configurations
where you have a certain topology of
import and export right that's basically
a deck and we just reuse this across the
devices and across the framework so the
absolute values might not be very
meaningful because you could randomly
generate another topology and it would
produce different values could be
dramatically different values but it's
still comparable because this is just
materialized into a big hash and then we
reproduce the same topology which ash um
and yes the first one that we can look
at is how much time does it take to
install the 10,000 bundles it again
turns out that felix has a bit of a
performance issue here but concierge
performs consistently the best I also
had a bit of a problem running equinox
on on compact one and I'm really not
quite sure why that is but um we will
figure that out um resolving is one of
the areas I'm pretty much doing these
numbers for one
half years now that is an area that all
frameworks have improved over the last
year side so you can see there is not
really a lot of difference here except
maybe for equinox but the thing with
equinox is the first resolving attempt
will have a little bit of overhead but
then it caches very aggressively so that
is basically the value for the first
resolving attack right and yes other
than that the rest of the numbers are
pretty much within voice and then oh I
don't I didn't even provide
uninstallation I think I skipped over
that site but our installation is very
similar to what you see for the
installation all right so um hopefully I
could convince you that osgi is a really
natural thing for IOT and concierge
provides you with an optimized and lean
framework in order to write ISE
applications um if you want to test this
technology just download the latest step
shots with all the optimization arrest
interface from our home page where we
provide the nightly integration builds
or just click on our code from github
and yeah let us know what you think and
if you like to use it we would be
curious to hear about it um i will also
shamelessly plug some advertisement for
our IBM who where you can visit and
participate in interesting games and win
prices in fact i was even provided with
some t-shirts here that i can give away
after the session so with all that i
would like to thank you for your
attention and I'm happy to take your
questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>