<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Introduction to Modular Development by Mark Reinhold/Alan Bateman | Coder Coacher - Coaching Coders</title><meta content="Introduction to Modular Development by Mark Reinhold/Alan Bateman - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Introduction to Modular Development by Mark Reinhold/Alan Bateman</b></h2><h5 class="post__date">2015-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qr4O4SbzihQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon welcome to introduction
to modular development I'm mark this is
Alan just a brief word Alan's going to
do the do most of the presentation and
then we should have plenty of time for
Q&amp;amp;A but should i'm going to make clear
that this is this is the first time
we've really come out and done
full-length sessions on on the module
proposal so we really value your
questions and feedback please please
don't be shy when we get to it because
we want to we want to get this right we
don't want to we don't to make the wrong
thing into the foundation of the
platform so Alan okay this by the way is
very much an intro talk we've pitched it
very much as a gentle introduction to
modules based on where the jsr the
current design and the current da bills
are so much of what we're going to go
through today is MIT is is the same
material you'll see if you start working
through the state of the module system
document and are it over over laughs a
little bit with what Mark talked in
touch down in the the keynote this
morning as well just the modularity
landscape if you were at the prepare for
JD canine talk i had the same slide here
but i just want to repeat it here for
those that may not have seen this the
jsr and that is defining the module
system is jsr 376 that's the GSR that
mark is leading started earlier on this
year that is what is defining the the
module system for the Java platform that
is still work in progress and everything
that we're actually doing to implement
the reference implementation of that is
can essentially be considered prototype
design until until that design is is
further further along there's another
jsr that will need to be submitted for
java c 9 that's the one that will cover
would be the ESR for them that is the
umbrella am j sr for the platform so
that'll cover all the major features and
every
else going into JDK nine beyond the
module system we're doing the
implementation and particularly the
reference implementation for the module
system in OpenJDK is part of project
jigsaw project jigsaw has been running
for quite some time there was various
iterations of prototypes and prototype
designs going back a few years and it's
now currently at the point where it's
synchronized with the the current design
that's on the I am that has been
proposed there's a bunch of chips or JDK
enhancement proposals that are being
done as part of the implementation some
of these are already in line because
they're mostly about preparing the
platform for nine Jeptoo 2200 which I
mentioned earlier on is is the
modulation of the JDK that's where
you'll find the module graph Jeff 201 is
where we use is the effort to reorganize
the JDK source code as modules and the
JDK build to build it as modules so this
has all been done in jdk nine already
Jeff 220 which I spent a little bit of
time on in the prepare for JT canine
talked earlier on is all about changing
the the output of the build what the
what though the runtime structure is and
this is all preparing the platform so
that we can actually link in and not
just jdk and standard modules into the
runtime we can link in other modules and
we get in we'll have one or two little
examples today and then more more
tomorrow and some of the other talks
chip 260 is is about encapsulating the
the non-critical api's that's what a lot
of today's earlier talk was about and
Jeff to 6261 is the is the jet that is
the implementation of the module system
that augments what's being done in the
jsr and is actually well worth a read
and by the way all of these it might
look like there's a lot of bureaucracy
here with all these numbers these are
our living documents they're quite
useful as reference immaterial to be
able to especially when they're kept up
to date to see all the detail as to
what's going on in jdk 9 and all these
different efforts and chips so 261 has a
whole bunch of details I'll touch on
some of the command lines and changes to
the compiler to the java launcher today
there's a
more details that you'll actually find
it in this in 261 so this is the second
of four talks that we're doing at devoxx
the the other two talks are the that
we're doing tomorrow or the advanced
talk first thing in the morning and then
the the under the hood which is the
advanced advanced talk tomorrow tomorrow
evening so I've give reminders and
pointers to those and later in the
slides so this as I said is a really
gentle introduction so we're going to
start right at the beginning with what
is a module and then we're going to
slowly build up the the concepts for
about four for a number of slides and
then I'm going to bring you through some
of the command lines for compiling
modules for running with modules so this
is all really basic stuff and tomorrow
then we'll build on that with some of
the advanced slides and migration with
real examples one other thing about the
intro slide is we're just using very
very simple module names for now they're
not real module names and we tomorrow's
example will be using real libraries
which will actually show how we migrated
those libraries to modules and this is
done deliberately this with this way so
it's in Traverse get the concepts on the
table and then tomorrow we go through
the the more advanced topics so starting
with a module what is a module well a
module we like to think of as a
self-describing collection of code and
data the most important thing about this
slide and and for the beginning of this
talk is modules have names in this in
this slide the module is called com
fubar and we will build up on this over
the next couple of slides so the code
that is in a module if a module has code
and if it's Java code then it's
organized as packages in this module
we've got four types that I'm showing
you here then they're organized into two
packages come fubar alpha and kung-fu
bar beta in addition to into Java code
or Java classes modules might have
native code they may have resources they
may have other configuration and I'm not
going to go through all of those as part
of the intro for now we'll just think of
code as as modules as having
ode and they're all organized by package
the module description is expressed in a
module declaration the module
declaration is in is in a source file
named Java info Java by convention the
module introduction is placed in the top
level directory the couple of the of the
source directory so in this example the
we've got four types the source files
for those four types are organized by
package we've put the module info in the
top level directory of the module what's
in the module info Java source file is
module keyword and then some curly
brackets and we'll build up what's
inside that in the next couple of slides
input so it's much like module module
name and then and then will we get into
what sense what is in the module
declaration in the next couple of slides
this is very basic start within the
module declaration we may have a number
of requires clauses and this is how one
module expresses a dependency on another
module and that dependency is expressed
by with the module name in this in this
in this little naughty example we have
kung fu bar that has a dependency on
come through bars we'll assume in this
example a comp few bars is a library so
we express that dependency with the with
the requires clause and this is going to
be important at both compile time and at
runtime i'm going to start building up
this example over the next few slides so
we're now going to introduce a third
module into this which is kung fu app
this in our example is going to be our
main application and it has a dependency
on two modules kung-fu bar and java dot
sequel so there's a require clause for
both of those modules so this is very
very simple dependency Java sequel you
might wonder what that's about for now
just think about it as the module that
has the JDBC or the the Java SQL a p.i
so now we're going to start building up
a module graph so I've brought that I've
shown here the three come foo modules
that I have kung fu app depends on come
foo bar come foo bar depends on council
bears and we know we've had Java sequel
on the last slide we have it here as
well for this slide I'm bringing in
another module into the graph which is
Java base java base is the core of the
java system that is where
java.lang.object lives it's where all of
the core API is it live every module
depends on Java base whether it
expresses that dependency or not it's
it's like every it's like every class
ultimately will is it depends on
java.lang.object whether it whether
whether its source expresses that or not
so Java base is the core of the system
so I'm going to expand out the graph a
little bit more and show what Java SQL
depends on so what we're going to do is
we're going to resolve the top level
module here come thru app and then we're
going to and build up the module graph
by resolved resolving it conf web and
then all of its dependence dependencies
and the result of this is is the
transitive closure computational and and
and this module graph that I have here
java sequel which i had in the last
slide has dependencies of other modules
java xml and java logging these might
not be obvious dependencies unless you
know that the jdbc api in detail there
are XML types in the jdbc api so that is
why that dependency is there as I said
in the last slide every module has a
dependency on Java base so therefore we
see an edge in this graph from every
module to Java base when a module
depends on another module we say that it
reads that module so in this example
kung fu app depends on and reads the
java sequel module the java sequel
module has a dependency on the java xml
module and therefore reads that module
and so on
the reader readability is is is
something that will build up of over
over the next comment number number of
slides what if you used to maven are
used in the other build systems what you
have here is essentially a dependency
graph and what I want to do over the
next couple of slides is transform this
into a slightly more enhanced
readability graph because readability
relationships and in the module system
are really the basis for the reliable
configuration that mark talked about in
the in the keynote this morning so in
order to expand this a little bit i'm
just going to take a subset of this
graph and dish and with three modules
compaq which depends on java SQL which
depends in turn on java logging so i
just want to concentrate on these three
modules for for a few minutes and i'm
going to start it showing a little bit
of code as to what we might see in in
two of these modules so what we might
have in the java sequel or sorry in the
in the kung-fu app module is we may have
some code that's using some of the types
in Java sequel so if you read a module
then you can make use of the types in
that module socom few app reads the java
sequel module and is making use of types
in that module the type in this example
is java SQL driver which most people
will recognize within the java sequel
module we have some we have the driver
class and one of the public methods in
the driver class is a method that
returns a logger this method in java
sequel driver called get parent lager
that returns something called lager
which is in the which is it which is of
type java.util logging that you will see
in the java logging module so the
logging is in is in java logging and joe
and something in the the driver class in
the java sequel module has an API that
returns a logger now let's go back up to
the calm through app and we look at the
code that we have there
it has a reference to a java sequel
driver it's calling getparent lager and
then it's calling a log method on that
so what this means is is that somehow
come through app is making use of the
type in a module that it doesn't read so
how do we address that one way we could
do this is you could actually change
come through app to have a requires on
the Java logging module that will work
but it's a little bit inconvenient for
those using the driver API using
anything in Java sequel the applications
would need to remember to have a
requires on Java logging and in the last
code example where I'm using where I'm
changing some of the method in vacations
it's not obvious that I have a
dependency on this other module so the
way toward the way the module system can
help with this is using what at this
notion of implied readability in the
module declaration for java sequel it
not it not just requires java logging it
requires public java logging what this
means is that anyone that reads or
depends on the java sequel module will
now also depend on and read the java
logging module this is implied
readability so this yellow edge that I
have on the slide if we start adding
these implied readability edges to a
module graph that we had a couple of
slides ago we end up with this this is
our readability graph there's the Java
sequel module does it requires public on
Java XML it doesn't requires public and
Java logging there for anyone that reads
the Java sequel module also reads the
Java XML and java logging module so what
we have on this slide is a readability
graph so that's that's requires and and
readability I now want to introduce the
other part of
the of the solution which is
encapsulation so I want to introduce now
the record the the exports so in
addition to having requires clauses an
application as our module can also
declare the API packages that it exports
in our kung fu bar module we have it
exporting two packages come foo bar
alpha kanu Barbossa any of the other
packages that are in that module are not
exported there is they're there they're
not going to be accessible anything
outside of that module essentially what
we can do with modules is we can split a
library or a module into two parts the
part that is exported these are my
exporter packages and my internal part
that is not exported once we combine
exports with the readability in from the
previous slide we can start to reason a
bit about accessibility our kung fu app
reads come foo bar that allows it to
access the public types in the packages
exported by comm fubar it cannot access
any of the types in the non exported
packages this includes public types so
there's a pair that you have to get into
your head you've got to read the module
and the module has to export its the
packages once you've got that
readability and you have the exports
that allows you to access them the
public types in those exported packages
if confu app did not read the conf you
bar module then no types whatsoever in
Kung Fu bar are accessible to come few
app even the exported types it does not
read the module therefore it cannot
access any of the types if I go back and
introduce the read edge again that
allows code and come through app to read
the the public types
the exported packages in tomorrow's
under the hood talk we will go through a
lot more the details about and what this
means and what how this notion of public
changes with with modules but the main
thing to take from from what I've just
gone through here aside from
understanding what readability and
exports and what this means for
encapsulation is public no longer means
accessible this is a really fundamental
change to the platform for the last 20
years all public types have been
accessible now we're introducing modules
we're introducing encapsulation public
types some public types may no longer be
accessible so this is a this is a really
really fundamental change and when I say
not accept not not not accessible I'm
talking about at compile time and I'm
talking about at runtime and a runtime
I'm talking about static references and
talking about core reflection and
talking about method handles they're
just not accessible so that's the
concepts out of the way without one and
start talking a little bit about the the
platform modules and get into some of
the some of the changes to the command
line tools and how we will compile and
run with modules so the first thing I
want to get into is the platform modules
Mark showed a spaghetti diagram in the
keynote this morning you may have seen
others getting diagrams that mark has
shown over that over the last couple of
years moving the core platform to
modules has been an enormous effort
multi-year effort mostly will be D
trying to sort out some of the these
dependencies between various parts of
the libraries that have built up over
the years and this has taken a long time
to do so we've been able to over over
over over a number of years is get to
the point where the big tangle diagram
that a study showed in the keynote this
morning gets to a reasonably clean
module graph this one is particularly
clean because it's actually the
transitive reductions is you're not
seeing all the edges there but it is
nice and clean d the important thing
about this and this will come up in the
pin the the presentations tomorrow there
are no cycles
no spit packages this is this this is a
relatively clean module graph things to
point out is right down at the bottom
you see Java base that has that does not
depend on any other module that is that
that is the one module that's known to
the language known to the vm and known
to the module system all the rest of the
the modules you see there and will all
depend on on Java base one other thing
to say is this module graph here is the
standard module graph when I say
standard I'm talking about the Java Sea
modules so all of the modules in this at
least that are in orange here all start
with Java dot star so in inject 200
there's a proposal for how we name
modules and all of the standard modules
meaning those defined in the JCP has
been proposed to start with java dot
star that's their respective what the
package name might be so there may be
maybe some API is that our javax that
star in packages that the module names
have been proposed to be java dot star
so these are the standard modules there
are in addition to this a corresponding
set of GDK modules these are jdk
specific modules and i'll show you the
full list that we have in the current
prototype and the current bills with
java dash list mods so the launcher has
been extensively been updated in the
jigsaw bills with a whole bunch of new
options one of them is less mods and in
this particular usage here you can just
think of it as listing all of the
modules that are in the runtime so when
I download a jigsaw build that the JDK
build and I do a Javid list mods it
lists me all the modules that make up
that run time all the java dot star
modules that you see there they are the
standard modules we look down through
the list you'll recognize some of these
java based java logging java naming now
the naming is jndi some of these you
won't recognize maybe because just the
reason that there isn't a good name to
give some of these huge modules like
Java desktop which is which is where you
find all of the ad ability swing ap is
there there they are water exported by
that that module the JDK dot star
modules are the JDK specific modules
some of these modules do not export
anything they are just tools
some of them are service providers we're
not doing any talks on services and in
the four sessions we have but some of
these modules are purely service
provider modules there's em there's some
JDK specific API is in there in the in
the talk this morning I tritak are this
earlier today I tried to explain the
difference between the standard API is
in the JDK specific api's so there's
some supported documented Khamsin and
jdk dot star api's these are water these
are the api's that are exported by by a
number of these em gee IDK dot star
modules so this is the full list if you
try it out and there's various other so
options and on list mods that you get
more detail on the modules now I want to
move in our move on and start talking a
bit about compilation of modules and
I'll start right down at the bottom of
an inner module graph with the come
through bars module because that was a
library module in the module graph we
had a few minutes ago so this is a java
sea command there's no new fancy options
on this Java Sea command dash D is the
directory where where where the compiler
outputs to that's the destination
directory I'm giving it a bunch of
source files to compile and just like
any any compiling compiler it goes from
java java source took a class files in
the way this code is organized for this
example is the directory structure is
SRC module name and then the the source
files that is how its organized here so
i'm compiling all of this all of the
java files that are in the comm few bars
directory tree and i'm compiling them to
doc class file the important thing to
take from this is the is the module
declaration which was in module in photo
class sorry java is compiled by the
compiler along with the rest of the
source code and is compiled to dark
class files to build up the next few
examples and show additional
compilations I need you to introduce
warn other concept and that is the
module path
and the module path you can think of it
as the module equivalent of of the
classpath with a classpath you're giving
it is a usually you're giving it a
sequence of director or switch sequence
of jar files with the module path you
always giving it a sequence of
directories and in each of those
directories are modules those modules
may be exploded on the file system like
for the previous compilation where I
went from source to dark class files or
they may be packaged modules I will go
through packaging of modules in a few
slides time the way modules are located
and it's important to understand how
modules are located ripple compilation
and runtime is that if you want to
locate a module named bar Arthur come
through bar then we will look for that
module in tier 1 if it's not in there
one it will try it in der two if it
finds it there then it'll it'll no
longer look for any more in directory 3
ends and so on a module can only be in
one place what if it's in any subsequent
directories it will be just be ignored
it's not possible to have two versions
of a module in a directory it's an error
to have two versions of kombu bar that
are that are in directory one module
system said I can't deal with this
there's two of them there how do you how
do you know which one so that eliminates
some of the complexity with that you
would otherwise have are the
unpredictability that you would have so
what happens and what would I board
compile time and at runtime is when when
you're searching for a module and you're
trying to resolve its dependencies we're
going to be using a module path so that
the the compiler are the wrong time
we'll be able to 2m locate the modules
so here's the next and come Java Sea
command so I've moved up a level we've
compiled we assume with compiler kung fu
bears as we did in the previous example
now I'm going to do a compilation with a
module path I'm going to compile kung fu
bar remember each has a dependency on
other modules where is it going to find
those modules
it's going to find them on the module
path so this is like doing a Java C dash
CP with the classpath except that
modules now are found on a module path
with the dashed module path option
that's compilation I want to show
running next now the command I'm going
to use for executing my my application
will initially look a little bit
complicated we'll simplify it over a
couple of slides but this is the command
i'm using here java dash module path i'm
giving it the module path dash mne for
the main or initial module and then i'm
telling it what the main in our initial
module is and what the main class is
what happens here is that kung fu it
will try to load module comm foo app it
will resolve its dependencies we go
through that in the next couple of
slides and then it will run its main
class this initially looks a little bit
cumbersome because I'm giving it to
pieces of information rather than just
the main class as I would have done
before we get to that in a couple of
minutes the important thing to take from
this is Java launcher also has a module
path option and we've tried to keep the
Java C and Java launch our options to
work the same way so that it's it's it's
the familiar feel that the Java has
already have always had so let's go and
see what happens when we try to run the
come through app module so going back to
our module graph that we had earlier on
confo app has a dependency on three
modules there for those three modules
will need to be located kung fu bar
which we would hope is on the module
path java base and java sequel they may
not be on the module path i've specified
with the dash module path option they
should be found in the in the runtime
image something we call the system
module path so the important thing to
understand is this is that running with
java dash mne will trigger resolution it
could change it will trigger generating
that module graph it's very very simple
module graph in this case and this is
very very simple resolution
it's not it's not complicated solving or
anything like that it's simply finding
the dependencies and essentially
building up that module graph that we
had in one of the earlier slides so
we've got all of these modules that will
be located at startup if any of those
modules are missing then of course
startup will fail module missing mark
showed an example of that earlier on in
the in in the keynote and what are the
diagonal diagnose ability options that
we have our diagnostic options that we
have on the java launcher is there's an
existing X diag option on has been there
on the java launcher for many years is a
new sub option in the jigsaw bills to be
able to see a little bit more what's
going on so this this will actually
trace what happens at startup so you can
actually see it where does it locate the
modules and how is building up the
module graph I've really cut down the
the trace output here in order to fit it
into into the slide but the important
thing is when when you're trying to
locate modules and then their
dependencies and building a readability
graph things can go wrong you might get
exception so it's important to be able
to know where the the modules are being
located so this is an option that helps
to debug any of any problems that might
happen and during startup when
dependencies are being found so that's
compilation that's running in win one
simple way and I want to move on and
talk a little bit about packaging mark
touched on modular jars in the in in the
keynote this morning so on it's been a
couple of minutes on modular jars a
modular jar is just a regular jar file
except it has a module in photo class in
the top level directory of the jar file
the chart so in this example I have
compiled everything that is in module
come foo app so I start packaging
everything that is in kombu app I'm
going to package it up with the jar tool
to create a PR so if I was to look
inside of apt apt jar I see the modeling
for that class that's my compiled module
declaration and I see all of the other
files for it for the application the jar
tool has been extensively and revised
and updated with a bunch of new options
to support modules in the jigsaw build
i'm using this here and so this jar jar
command may not initially look familiar
but it's it's it's it's it's because the
jar tool now supports new style robert
and unix it also supports unique style
options and to create the the jar file
an important thing in on with this
command here is i'm setting the main
class of the module when I'm creating
and packaging the module there's other
metadata that I can add to a module when
I'm packaging it so this is a clear
distinction in this module system
between what's them what is in the
module declaration what the language
what the vm what the platform knows
about and then all of this other
metadata that may be added at packaging
time and the main class is one of these
things that can be added at packaging
time with the jar tool so this creates a
PR so important properties about about
about em and modular jars is it's part
of the the interoperability and
migration story for four modules we get
into simple into a lot more about
migration tomorrow but but an important
thing about modular jars is a library
can be a lie a jar file that works on
the classpath are it can be a module
that works on the module path as a
module so it means that you can come you
can compile something for an old version
of the platform java sea Josh release if
you haven't seen that new new option on
Java C compiler for an old platform at
the module descriptor and that allows me
to use it on the classpath with jdk
asian older like a Lenny and then I use
the library as a module with jdk nine so
that's really really useful particularly
for four important libraries that can't
move completely two modules in one
release because they want to be able to
support users on previous release
soaping
to have one jar file that can be on on
either a classpath are the module path
is really really important property so I
mentioned about the jar to being updated
and here's another option to be able to
print the module descriptor and see
what's in a jar file Dash P in this
option in the in this slide here is
short for the new version of print
module descriptor it's just a shorter
form of it some being able to look at a
jar file and being able to see what
module is in that jar file what does it
depend on and then what's its main class
another version in details all of this
can be printed out by the jar too so
this is quite useful so now let's go
back to our launch command and our Java
command and see how it works when we've
packaged on module as a modular jar it
becomes a little bit simpler Java dash M
is specifying just the module name and
no longer needing to specify the main
class this is big like java jar except
we're dealing with modules now this is a
package module it has a main class the
module system is able to to load that
module and invoke its its its its main
class which is which is good the module
path in this example has two directories
the package modules are in EM lib and I
have left some of the dependencies as
exploded modules in the mods directory
just for this example to show how a
module path can have multiple
directories so I just want to say a bit
more about modular jars and clasp being
on the clapping on the classpath as
regular jar files are being modules on
the module path by just showing some of
the the command line and options that it
might look like so here I have let us
assume that we have our baths and our
appt as modular jars I'm going to put
them on the classpath and run them with
nine run them with eight maybe whatever
compiled to and these libraries even
though they have a modular info module
in folder class in the jar files they
will still work as libraries on the
classpath the module in photo class name
is not valid and as a valid class name
so it will be ignored by the previous
releases so that is how this actually
works we run them on the module path so
assume everything is packaged and as as
my jar jar's in the a.m lib directory my
same library can be used on the module
path so I've used it on the classpath
I've used it on the module path now we
get into something a little bit more
complicated I can mix the classpath and
the module path suppose for this example
we will we will have come few bars as a
module on the module path and everything
else on the classpath my main
application my main class is in the jar
file on the classpath here it is not on
the module path how do we know that how
does the launcher know that oh they're
here is a module path and in there i can
find two thousand modules which of those
modules should be resolved java launcher
doesn't know that module system doesn't
know that so this command has an add
mods option to the launcher to say i
want to use this module in this mode on
this module path so when you're mixing
modules and class path there would be
cases where you have to have to tell the
system which modules you want resolved
this is because we're mixing light we're
mixing class path and and module Pat
together we'll have some more examples
of that and tomorrow but the important
thing is that being able to have modular
jars we're not going to force everyone
to move to modules in one go and
a lot of tomorrow's talk is about this
very topic so one final thing that I
want to spend time on is linking mark
mentioned about the linker in in in the
keynote this morning the Java ecosystem
we've always had compile run or compile
package and run this will be the first
time where we introduce an optional link
phase and a linker tool that will allow
modules to be linked together to create
a running application so it's it's akin
to the the native linker and the way it
works in the current bills is and I'll
show an example of this in a minute it
but at a high level we can like Java Sea
like Java we will give the linker the
module pad where to find modules what
modules that you would like to include
those modules their dependencies their
transitive dependencies will be linked
together to produce a runtime image so
Jeff 220 defines the the layout of the
runtime the modular runtime image and
we've already moved jdk 92 that layout
and for um what just over a year ago and
the linker tool will allow you to create
any custom a custom runtime image that
is your application or specific
libraries and their dependencies so
these will be just just the minimal
dependencies that are needed to run that
application I'll show command and in on
the next slide but and the way that
runtime image is laid out is there's a
bin directory where you have the
launchers and there's a conf directory
where there's configuration for that run
time I talked a little bit about this in
the top in the talk earlier on but as
part of cleaning up the the runtime
image and essentially blurring the
historical distinction between what we
know is the JRE in the JDK is we've
cleaned up unlocated all of the all of
the configuration files like security
part and security files and anything
else that is that that that is
meaningful to
configure the runtime have all been
moved into the one location so there's
there's there's no confusion over what
can be changed in order to customize the
runtime it's all in the one place so
there are the two important directories
in their classes and resources
associated with the modules there
they're all there they're all trans that
they're all stored in a completely new
format no longer jars no there's no
longer any jar files in the runtime
image it's it's a new format that's
optimized or is it enables a whole slew
of optimizations that we want to work on
and for things like start up for
footprint for sharing and so on so i'll
show the linker tool in one simple
command first and I'm going to create
with the linker tool in minimal runtime
image that contains one and only one
module Java base this is the minimum
module that you've heard the minimum
runtime that you can create so like Java
and Java Sea we you give to the to the
linker tool and the linker tool is
called j-link you give it a module path
where to find the modules i'm using add
mods tell us what modules to add into
the into the runtime image and then i'm
giving it the output directory where
it's going to create it this is the this
is a simple j-link command the jdk j
mods assume that's an environment
variable where you find the package
platform modules i'm going to run use
the list mods option like i did on the
java launcher in one of the first slides
you might remember i did a java list
mods in one of the early slides where we
listed out the 60 or 70 modules that are
in the regular jdk builds this runtime
image that I've created with this jail
in command is one module and one module
only like all linkers there is a whole
slew of complicated options to do fancy
things this is the simplest option this
is the simple schematic you can get what
if you try out the new jigsaw bills
you'll see some of the options in there
and how you do compression how you do
stripping and a whole bunch of other
that complicated things that you might
want to do and so this is this is the
simplest simplest one to get you down to
a minimal runtime
I'm now going to do the same kind of
similar command but I'm going to take
the console app application that i had
in the early slides so remember comfo
app had a dependency on Kung Fu bar
which had a further dependency on comm
few bars and so on and there were four
platform modules that were in that
module graph that I've showed in the
early slides so I'm asking the linker to
to link to create a runtime image with
just one module it ends up linking
increment linking in a total of seven
modules because that is the transitive
closure there's seven modules that need
to be brought together and and linked to
represent that that module graph so this
is this this is quite useful and as I
said there's a whole bunch of other
interesting options that you can use
with the linker and but not not for this
session this session was really about em
basic concepts so I want and some basic
command lines for compiling and running
packaging and and now linking so that's
all I wanted to cover in the in the
introduction and we're going to use the
rest of the time for for for questions
and I think mark is going to come up for
aquifer for questions and as I said
tomorrow we're going to have the
advanced talk so this builds on the
concepts that we've actually talked
about in this session and we spend time
on migration and so in room first thing
in the morning I think we're in here for
9 30 and then under the hood session
which will cover the science behind
modules we're going to work we're going
to present that tomorrow evening at 550
in room 5 some more information and
everything that we're working on here is
all the documents and all the material
related to that can be found on the
OpenJDK project jigsaw page that has the
links the jep's on other documents that
we have the mailing list we asked people
to send back feedback and questions is a
jigsaw dev OpenJDK java net
list and then the early access bills the
link is at the bottom of the slide so if
we've questions we have we have a
quarter of an hour left so if we've got
questions so raise your hand please if
you're near a microphone use it
otherwise I'll bring it to you you you
can also use Twitter if you tweet tweet
at the the hash jigsaw tag then i'll
look periodically and we can pick up
questions that way as well so the way
the question is going to work is Mark's
going to get a bit of exercise running
around with the microphone yeah every
time doing this stuff on yonce and
inspired weight loss plan so regarding
accessibility check is it that forced by
the JVM bytecode or is there a runtime
enforcement for those oh this is one
time enforcement's so this is both both
in the vm it's also in co reflection and
Method handles yeah but it's not invite
code so JVM itself doesn't care if I
have some other byte code generated by
another programming language or anything
this is all enforced by the vm it
doesn't matter who generates the
bytecode whether it's it's spinning the
class files dynamically or they're
generated by the compiler access checks
are always done by the vm it's enforced
for all bytecodes not just some byte
codes sorry Martin I had a question
about the module resolution you have the
module path and the system model pure
module path which one is there an order
in which it is resolved or can I put a
Jaffa daughter SQL module in mine own
classes and have that executed instead
over or linked instead of the Java SQL
from the JDK packages ok so there is
there is something I didn't talk about
today which is the system module path
which is where all the platform modules
live so you could conceptually think of
that as as appearing before your
application module path that you specify
with java dash module path so that's why
java sequel will always be found before
java dot sequel Jarrah that you might
put in in some directory but
one other thing that I didn't talk about
today is there are some limited cases
where you do need to replace our upgrade
the the system modules app servers
typically have to do it and there is a
mechanism for that too here's a question
on Twitter how do modules handle
circular dependencies they don't know
circularity in a module graph it's just
her boton so circular dependence in a
module graph is a sign of a bug right
and resolution would feel if he finds a
circular dependency hello suppose you
have some common code which you're gonna
use for instance somewhere inside JDK
but you want to keep this common code
private from interface perspective is
there any possibility to do such trick
with your model system do you want to
talk about qualified exports you want to
leave it till tomorrow and so yes there
is a mechanism in the in the in the
module system for if you if you're
creating a group of modules and you've
got some some some common code that is
exported just you can export it to just
your friends just the modules and so
there is that mechanism is called
qualified exports we touch on it in
tomorrow's presentation
can you please go back to slide 37 the
linking one yes if you look at the list
of the modules you see the at 90 behind
the JDK modules yes the edge it's 90 are
is no part of the name of the module
right okay the way the list mark okay so
because I don't see the ads behind the
custom modules right so in the in this
example these these three come through
modules when I package them I didn't
give a version string the the platform
modules do have a version string for
informational purposes this will show up
in the list mods it'll also show up in
things like stack traces and and and
some some exceptions as well for
information purposes you can also add
versions to your own classes oh here all
modules yes so that the there there's a
timely Twitter question on this topic
related to this is versioning supported
by the new modular architecture can one
module depend on male version when dot
one of logging and on another bottle
dependent on version when you wind up
for logging so versioning is something
that we've we've decided after some
painful experience not to do which might
seem wrong I was at the model system of
course it should do versioning you
should have version constraints and
version strings and numbers and all of
this other stuff and we did that in the
first jigsaw prototype and it and it
turned out to get really really
complicated so we decided not to do it
part part of the part of the observation
we made was well if you look at how this
stuff is going to be used we already
have tools like maven and Gradle and Ivy
that handle dependency management and
gingers tackle the really hard problem
of versioning if we tried to do that in
the module system as well well we might
always not get the same answer we might
do it differently you know in five years
some super amazing
new build tool might come along that
does a better job it just didn't seem
right for the model system to be in the
version selection business so versions
in the model system are that they're
sort of an op in a way an optional part
of the module name you can specify a
version version when you package a
module it can be something that your
build system provides usually it's the
build system that knows rather than your
source code which is another reason to
keep the version numbers out of the
source code and version strings will
show up as you know in diagnostic
messages and things like list mods
output but in general we're we're taking
the stance that it's up to build tools
to arrange modules on the module path in
such a way that the right things will be
found by the module system the module
system will take will take the first
module of a given name that it finds it
will refuse to deal with any duplicates
and and just give you the advice that
you should go fix your picture build
system okay sorry that there have been a
couple people here who had had their
hands up for a while yeah I'm assuming
that the result of the linker is but
from dependent so in that case is there
like a cross compilation because if you
have raspberrypi you don't want to
launch the linker on your raspberry pi
would do it on your pc right so the link
can link to other targets yes so you
could be on linux x86 and target linux
arm if so that what you need to make
sure is that your module path has the
modules for linux arm rather than 10 x
x86 so that's something that's not quite
yet enforced in the current prototype
but eventually it has to be so that you
don't mistakenly end up linking some why
linux powerpc and linux x86 and then try
and run ocean and lincoln on a linux arm
so yes there is the the result bility
since you already addressed one of the
questions that i had regarding
versioning I have a follow-up question
assuming that your your module uses two
different modules that in turn use
different versions of another module how
does this soul
the conflict it doesn't so so if today
you have a bunch of jar files on the
classpath and you have two different
versions of some artifact you're already
in a very bad situation right amount no
no module system will help you every
module system will insist that you
resolve that conflict in in some manner
if only to a photo to avoid the
inevitable classcastexception that
you'll get when when twin thing things
meet up now for really sophisticated
applications like it like an app server
or or something like that that needs to
spin up things dynamically you know
there are ways for a sophisticated
application to spin up what we call
another layer of modules in a way that
allows multiple versions of some module
to exist but we try very hard to keep
those things from ever meeting because
it just leads to very difficult to
diagnose errors yeah the specific
scenario in mind where I mean that the
error did only show up when running the
application it was an osgi module that
ended up having references to two
different versions of some 6f jar and
how did this work out for you well it
crashed but I mean the guy I was hoping
that the the crash should be caught at
compile time rather than at runtime well
certainly if you're if you're compiling
a bunch of those modules with jigsaw you
you will get you will get the error at
compile time you won't have you won't
have to wait to run time so it's maybe
maybe helpful in that regard how much
time do we have left you got seven
minutes there's a bunch of hands on the
left so you're right chef chan's on the
right we have I have a question
regarding the naming policy of the GDK
modules so I noted that there is a java
dot SQL a java dot a scalar rosette so
does it mean that the rosette is the sub
module of the java dot a scale model
and she's my functional model request
the Java duty scale data set does mean
that all the export part of Java duty
scale will be also available for my
functional model okay so there is no
notion of sub modules the reason for the
split between Java sequel and Java
sequel rosette is so that we have a
small Java sequel module that can be
used on embedded system without bringing
in all of the dependencies that the
rosette API and the footprint of the
rosette API would bring in terms of the
naming then they that the convention
that's that is used is where possible
the dominant or the topmost package name
of the the API goes into the module name
where it makes sense there's a couple of
modules where it doesn't make sense like
Java base because if i was to explode
java base and look at all the exported
api's their java i/o java.lang java net
and so on there is an obvious name there
and that's why it's called Java basis so
there's a there's a handful of modules
where that convention doesn't apply but
for the most part is the dominant
package name goes into the into the
module name in what way for currently on
the table one more observation about the
about the rosa de read the rest that
module depends on the sequel module so
have used row set you'll have to have
the sequel module around but talons
point you can eat you could but you can
use the sequel module without rowset
does the rowset module require public
sequel I think I think it does yes
probably does but that's that's easy to
check let's see fair time to quit with
Twitter here what if the same class
exists in multiple modules well then you
better hope they don't talk to each
other if they do the module system will
refuse to configure that right all right
so what is your advisement to companies
that build fairly large software
projects and today use osgi is the
advice and stick with osgi because for
example melt and supporting multiple
versions this is quite critical and
quite commonly used to I'm a bit
surprised about statements on we
supporting versioning and if you have
multiple versions you're doing something
wrong so what was the advice for larger
existing software projects that use osgi
let me add a little nuance to me to my
save a few if you have what I meant was
if you have multiple versions on the
classpath you're doing something wrong
if if you're if you're in a dynamic
system in you and you have to have
multiple versions there is a way to do
it with jigsaw it's it's not the easy
path because it didn't it's not the most
important thing to support but it's it's
it's there and it can be done as for
advice about osgi well if it's solving
your problems then keep keep using it
and you know there-there's there plenty
facilities in osgi that will never be in
the Java platform model system though
that this model system is not meant as a
replacement for osgi especially if
you're using the dynamic lifecycle
facilities and it's more complex fancier
service mechanism and some applications
have legitimate needs for that so you
know that this is a question I I
basically don't have any advice just
look at look at what your needs are I
you know if you built an application and
you're using osgi really only for the
module facilities then you could
evaluate is it worth moving to something
that's simpler and the answer to that
question is up to you in the opening you
you saw is the wiki page for the jock
hell do you think it will be a bigger
page for the module cell but who knows
there might be you know just cuz its own
Wikipedia doesn't mean it's true haha
you know and and yeah there's some
people who do just don't like this
approach and well yeah
can can there be module hell well if
there is hopefully it's on it's it's a
higher rung of health and then jar hell
maybe several several higher rungs you
know in complex software systems the
modules are a tool to bring a bit a bit
more sanity do they make it easy to
write large complex software systems
well they make it easier but I don't
think anything can make it easy there's
somebody else around here there are some
frameworks who have the multiple
implementations who can be implemented
by anyone and then defines in a
configuration file how will this work
with this system as you won't require
all the implementations that that's a
pretty advanced there's a reasonably
advanced topic and the margin of the
page doesn't know what not allow me to
fit an answer here but I encourage you
to come to the advanced in the under the
hood talks and you'll see more of the
mechanisms that allow that sort of thing
to be handled it's a couple of hands on
the side one minute 30 seconds the sign
is turned red what happens if two
modules you depend on export to sim
package will you get a warning at least
an hour it never happens that's a that
will be an error at resolution time both
compile time and run time before
anything happens the resolver runs if it
finds it comes look like like that it
gives you an error message hopefully
their message is helpful and you can go
fix the problem it's much better to get
that error a configuration time that
says is it yes it's split packages like
that are just just evil hi
you can link a run time together I
understand is it will it be possible to
link a war file together i refer to you
the specification lead for java ee 9 ah
i have no idea it certainly are in our
intent that there that there be an ee
the modules be adopted by the relevant
ee standards in the long term but that's
a long term thing you know we do talk to
a bunch of the spec leads in a regular
basis you're not so you talking while
you're talking about wire files so if
you're talking about war sorry you you
are talking I'm sorry if you're talking
about war files you are talking about
Java EE if you're talking about war
files you're not talking about you okay
I'm sorry i I'm just I can't parse your
question next question all right the
tribes of the screens turn to turn right
yes sir and black we're finished okay
conscious outside and because it
presumes is another session in here</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>