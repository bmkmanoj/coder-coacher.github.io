<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Microservices   the naked truth of the maintainability by Jakub Kubrynski | Coder Coacher - Coaching Coders</title><meta content="Microservices   the naked truth of the maintainability by Jakub Kubrynski - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Microservices   the naked truth of the maintainability by Jakub Kubrynski</b></h2><h5 class="post__date">2017-08-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/MLiHXnD323Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so as you can see I'm not at some
I'm Jacob I'm going to cover a similar
subject absent has delayed flight so
he'll we've exchanged slots to fill D
talking the second room and two hours
prove up so yeah what I'm going to cover
is to tell a little bit about what
happens when you already deployed micro
services into production so I'm going to
talk about the consequences of the
actions we are taking okay so a little
bit about me so I work on a daily basis
as a co-founder of the desk Euler
platform is a platform that allows or
bring the functionality of assessing
programming skills in an online nice
test
I'm also run a training for the Bottega
company I'm a program committee member
of this conference and I'm a proud of
the sprink cloud contract framework that
we'll cover later
you have my Twitter handle here so you
have any questions or any follow-up for
that after a presentation please tweet
me so do I know what I will be talking
about so that's the report for the SLA
very platform as you can see it runs
continuously without any outages and how
we can do that and how we achieve such a
sly that's the subject for my talk and
paraphrasing one of the polish Prime
Minister's you can tell the real
developers observing how they maintain
know how they start and I think that is
crucial to remember that the software we
are doing it's not a software the system
the difference between software and the
system is that software is something
that I implement
that I've put it into the code
repository and that's all but the system
is something that needs to run needs to
be maintainable I need to be able to
analyze what's happening inside the the
running system okay and developing
software and developing system that is
production ready sir two different kinds
of stuff and I'm going to cover those
videos in this talk but at the beginning
I want to ask you one simple question
when you think about the micro services
what is the size that you think is right
for the micro services I know that the
line of code is not the best measurement
that it's available but it's the easiest
one to to scale or size to micro
services so how many of you think that
100 lines of code is a good size for the
micro services Jason raise your hand
okay
1000 line okay 10000 line okay and
100,000 okay so the most people has
right hand on 1,000 or 10,000 and I
don't want to be a judge that will say
okay so 1000 is okay 10,000 is not okay
but let's do some simple math when we
realize that just a single average
enterprise application is around 500,000
lines of code
it's often much more it's often 1
million truly two million lines of code
but let's assume it's 500,000 so it
means that when you realize that you
want to split it into micro services
where each micro service has 1,000 lines
of code
it will be bring 500 micro services so
splitting just one and the price scale
application gives us 500 micro services
and just to show you the scale 500 micro
services is a scale the Netflix
infrastructure ok so
that has around 500 micro services and
those micro services are maintained by
1500 developers okay 1500 developers are
maintaining the 500 micro services so
can you imagine that one enterprise
application is maintained for over 1,000
developers it makes no sense so we
realize that 1000 line it's a
okay so the micro services are not micro
it's a biggest live of the micro
services to do some macro services so
the 10000 line of code it's much better
it will give us I don't know 50
applications okay but it's still too
much we'll probably be able to split it
into 20 applications and that will be
probably enough so 20,000 lines of code
50,000 lines code that's the proper size
for the micro service not this this is
volume and why it happened because we
want to keep our micro services business
oriented so we are using the bounded
context approach that is known from that
domain driven design to set the
boundaries for the micro services okay
so we don't want to keep the technical
micro service because for the technical
staff we have libraries I can include a
jar that will generate a PDF or will
export something to CSV file I don't
need to keep the up and running service
that creates the PDF file well because I
need to care about the communication I
need to care about the infrastructure I
need to care about the security about
the monitoring deploying pipelines that
set up there is a lot of overhead behind
the same single services ok so we want
to limit the number of the services we
want to also limit the number of the
communication outgoing
and happening in our system okay because
this communication brings trouble so
when I can limit the communication when
all the business processing is done in a
single application that's what is
cooling the monolith when the model is
up and running
everything works because everything's
happened in the boundary of the same JVM
okay
there is no such guarantee in a micro
services when we are communicating over
the TCP or UDP platform okay so yes we
want to keep our micro services business
oriented inside a bounded context
because that's the proper bundle for
this so why do we want to enter the
micro services why do we want to you
know split the application to micro
services an answer is autonomy I want to
be able to automatically deploy or
upgrade my application okay I don't want
to coordinate releases that are okay to
release this feature must release this
and this and this and this micro serve
no the feature is independent is closed
in a one single micro service okay so I
want to be able to deploy those services
autonomously I finish my job I don't
need to wait for any other team and just
deploying and releasing my job into the
production okay
of course I'm not able to run any
breaking changes but that's something
that we'll cover cover later okay okay
so autonomy is true and they independent
Cisco but are we sure the problems
independence is just joint probability
of independent events is equal to the
product of their probabilities okay and
why it's important it's important
because when you have free we have a
business product okay and this business
process includes free micro services so
all three micro services must be up and
running to finish this product so
imagine that each of the micro services
has the availability of 99.8 so what's
the final
SLA what's the SLA of this whole
business drop process its ninety nine
point four okay because I must multiply
all those elements and here I have just
three microservice but I'm not talking
just about the application the
applications are running on some VM
these VMs are behind some firewalls they
are using some network interfaces okay
and that's the problem because when you
realize that you have a 99.9 as ally but
he has ten components included in your
business process it means that it's not
a more 99.9 it's 99 just 99 okay it's
order of magnitude less than we expected
and when we take a look at the
availability versus downtime then 90
percent of ability is and means that we
are accepting downtime of more than two
hours per day okay 99 percent means that
we are accepting 14 minutes okay so
that's the shift from 14 minutes to over
two hours just because we need to
communicate more than one service than
before okay so in monolith if smaller it
were okay and it was 99 then we had a
down time of 14 minutes when we split
this monolith into something that is
called the distributed monolith so I
have a micro-services but I must
communicate all microservices at the
same time to be able to finish the
processing that means I'm screwed
okay so that's not the way how we want
to work with micro services because
what's important here is that that
availability is related to something
that is called a depth of our assistant
that's so the number of the services I
must communicate to finish the
protesting of some business process okay
and it's synchronous that okay so it
works as long as you need to
synchronously communicate with other
services so if you want to get better
SLA in the distributed environment you
must remember to prefer the a
synchronous communication we need to use
a synchronous communication every time
we can just be able to split this
business process into pieces okay
because then we care about SLA of the
each piece not about the whole process
that will be bring us giant troubles in
the distributed environment especially
in such distributed environments as
micro services when we have not dozen of
micro services but there are hundreds of
services that needs to be up and running
okay so remember about that because they
have seen many implementations of the
micro services that were just
distributed modeling and a slay of those
processes were like 50 percent they are
like 50 percent changes change the step
this process will finish correctly
because even the single micro services
that were done were blocking the whole
platform so that's not micro services
there is no independence between
services this is just a distributed
model it so remember to use the
synchronous communication don't use the
transaction and build the real
independent micro services stuff okay so
the next thing really important also is
the quality because it's easier to
achieve the quality of the communication
than the model it when we are
communicating invoking just Java matters
I know that the API between modules is
okay because I'm able to compile my
application so I know that when my
application has built correctly and they
have the artifact that they can deploy
the production the API is between
modules are correct right because if
there will be any issues between modules
then Java C will shout hey you cannot
involve this matter because it's
incorrect parameter okay but I don't
have such information
between my microservices they're
independent applications using
independent
build pipelines etc so how can I deal
with this one I can use the deal that's
the best solution yes or not know why
because when you decide to use the video
share details it means that you're
building something that is similar to
the canonical model and now imagine this
situation I have two services one is the
repository service and a second cease
build service okay and a build Service
is invoking the repository services and
saying hey I want to get information for
such project and a project information
project object contains an enum with the
type of this project and what is cool in
this feature is that repository doesn't
care about this project type at all but
is the share detail what happens when I
send the JSON object to the repository
with new project type that is not
present in this a gnome value in the
repository 500 okay I am NOT able to
deserialize this because there is no
such value like Gradle sorry you are not
able to process that okay but I don't
care about the repository type okay but
it's present in the shared model okay so
I have a JSON that allows me to use the
loosely coupled communication but I'm
using behind the JSON there is a shared
it your shared model what's the
difference then between the binary
communication there is no difference
okay it's not loosely coupled
communication and it's impossible to do
that without coordinated releases and I
don't want to use coordinated releases
so if you want to be able to deploy it a
bit of the
autonomic li all microservices you must
prefer the loose captain communication
so I'm reading only the fields that are
important for me okay and I ignore
anything else so I'm not using the
shared model anymore okay that's great
but that was the simple way to achieve
the quality of the communication because
you know that this model will be able to
you will be able to consume this model
you will be able to consume this request
because it's using this same object and
now I'm saying you okay so don't use
shared objects so how can I achieve the
quality of the communication so all you
can say it at yeah let's use end-to-end
test but why do I want to lean it
end-to-end test there are two problems
with end-to-end test first is that on
the station environment the station
environment is really dynamic I'm
deploying everything all the time I'm
fixing stuff I'm breaking stuff and
that's ok because that's my staging
environment that's the first second
thing we'll talk later about using
circuit breakers about handling sailors
etc so how can you be sure that in the
end to end test you're running are you
hitting the real micro service or are
you just using the circuit breaker or
the folded procedure you have no idea
okay so you don't know if the
communication is working or maybe you
are just getting information from the
cache because because caches and such
things are normal in distributed
environment so I the end-to-end best is
nothing for me in the distributed
environment so how can I verify the
communication works if the micro
services I are able to collaborate
without running end to end test so
another simple map can help if I know
that if a is equal to C and B is equal
to C then probably a is equal to B
that's something that we remember from
the primaries
okay and that's something that we use in
the distributed environment and it's
called a consumer-driven contract what
does it mean it means that I'm creating
the contract of the communication
between a and B and now I'm verifying if
a is following this contract if B is
following this contract and if both
sides of the contract are okay then
slowly a is able to talk repeat we have
created a tool that is called the spring
clouds contract marching gesture can
just long cause we're talking about this
one and that's the tool that solved this
problem so we define a contract in some
sample drew VDSL file and then we do two
things through this contract first thing
is that we generate the automatic test
for the server side so if the contract
says okay when you invoke the gets medal
on a slash calculate URL you will get
response stages 200 and you will get
such in such body and what would we do
with this contract we generate the test
that setup the server hits the server
with the get URL get request for the
slash calculate URL and check if server
responds they responded with the 200 and
such-and-such body with such-and-such
headers if yes then it means that that
server is following the contract so then
I'm generally think also the stops or
mocks for the client side and the client
is invoking but not the real server just
the top of this service with the get you
our request for the slash calculate URL
and if the client is able to eat this
response from this stop it will the same
be able to consume the response from the
normal service okay so we are checking
both sides without integrating them and
that's something that we use as a
replacement for the entrant test to
verify the communication work so it's
our version of the Java Sea so it's
distributed Java C for verifying the con
drug and it works for rest contracts
about as well it it works for queues and
for a synchronous communication so Kenny
was talking in the morning about a
spring cloud stream and of course that's
also covered by this by this spring
cloud contract stuff okay so we know
that the communication is okay so let's
go next what does it mean that we need
to design for failure it means that
there are two ways that we can go first
is something that is called the sale
sales and the second is called the safe
to fail
what's the failsafe it means that I want
to prepare my system that it won't fail
okay there won't be a sailor on the
production and that's something that
will be good but it doesn't work why
because there will always be a sailor
model is talking about that okay you
can't avoid the failure at all so you
must prepare for the Sailor okay because
if you want prepare for the Sailor there
is 100 percent that you will fail very
very badly okay in a moment that you
don't want to fail at all so what does
it mean safe to fail it means that I
know I will fail so I'm doing everything
to reduce the consequences of the sale
okay I don't want to pay for this fail
too much okay so what can I do to
prepare myself for the tailor so the
first thing is that I want to retry the
communication the first step of
preparing myself for failure is that I
know that some service can be
unavailable while because those services
are independent okay the service a can
be restarted for deployed or something
that while the service being still
working and want to communicate with the
service a so the situation when I want
to communicate with the service and the
service is not available
is normal its heavens on a daily basis
okay
I'm not able to use something that is
called a zero downtime deployment on any
service because it brings additional
costs like maintaining the database
schema it's harder when you want to
follow the zero downtime deployment
principle okay so the first thing is
retry you are trying to talk to these
guidance is not here okay to try again
in five seconds in ten seconds in 15
seconds still no action okay so what
should I do
is the service that I'm talking to it's
not available and I need to get the
response from this service what can I do
there's nothing I can do because this
service is unavailable so I need to
prepare myself for the situation when
this service is just going and I have no
idea why I have no idea when it will be
get back okay what what should I do
right now I need to prepare for the
situation and use for example the
circuit breaker so I know that nothing
happened I just need to have the fault
like what the folder is just an
emergency procedure okay imagine a
situation that I'm hitting the okay so
I'm running the e-commerce site and you
want to order something from my side and
the business process tells me that if
someone tries to order some things than
I need to check the crowd system to
check if it's not a fraud but the fraud
system is not available so what can I do
well there is a lot of things that I can
do okay but what should I do in this
moment should I process it or should I
reject this I have no idea I as a
developer it's not my responsibility to
take care about such protests I must go
and ask the business side do business
what should I do if the fraud system is
not available or it must be available
the type that's what we pay you for
okay I know but let's assume that it's
not available and you will get fired
okay but what's next what should we do
with the customer wants to get the
project
per product and it's not available okay
so then business try to think okay so it
is a new customer and then reject the
order if it's an existing customer and
the value of the order is lower than
$1,000 then accept it and if not then
say that okay it will be verified
manually etc and now the situation when
flood system is not available it's not a
problem for me anymore
because I already know what I should do
if this prod service is not available
and of course this small edge is written
in my source code so in the fallback
method I know that okay so the probe
system is not available I've tried five
times with some back of strategy and
it's not available what should I do
is it a new custom area to reject is it
a new customer no its existing customer
what's the value okay it's just the if
statement
I'm just implementing the simplified
version of the fraud system on the
client side
okay so client needs to know what me to
do when the service is not available
okay so it's the smart client endpoint
is smart that's the major difference
between the ESB architecture and the
micro services architecture and the ESB
the service bus was responsible for such
actions okay and for in micro services
work the endpoints are intelligent they
are smart they know what to do when they
are not able to communicate with
particular services so that there are
another stuff also the biggest
difference between failsafe and safe to
fail is that in sales safe I try to test
everything so I want to be sure that the
service that is going to production has
no issues okay there are no bugs inside
the service but the problem is testing
everything that is that the tests that
cover all business functionalities
are really expenses also there are a lot
of false positives like hey why the
build is not passing are the test okay
so it's the problem with test or the
problem of implementation yes sorry I
forget to fix the test
I've changed the implementation but I
forget about the test okay that's the
problem so what I'm trying to do I'm
trying to verify only the critical path
in my application okay so I'm checking
if the critical functionalities are
working and what about the other
functionalities not their critical
nothing it'll be a problem then customer
will use some I don't know issue
tracking system to tell me hey there is
a problem is such-and-such function like
okay sorry dude customer I know that
there is a problem now I need to fix it
the problem is that if I'm going to
spend like two weeks on fixing this
functionality this customer won't be
happy anymore but if I will be able to
fix this back in 30 minutes then it's
not longer an issue
but how can I fix the back in 30 minutes
it's almost impossible okay it depends
because when you decide to follow the
continuous deployment strategy
it means that I'm deploying to
production every day okay what's the
hardest thing in fixing bugs is to find
this bug in the code find a change that
we've introduced this but okay if I need
to find a bug in three thousand comet it
takes me days but how many comets did I
introduce yesterday 30 40 50 10 okay and
it's really easy to find a bug in ten
comments because usually in a service
that contains about there is just one
comet and you see okay
that's wrong I need to change it okay
I'm fixing this one I'm writing unit
tests to cover this stuff and I'm
releasing it into the production and as
we are talking about the micro services
that case I don't know 50,000 lines of
code
I'm able to build the service in a
minute okay a deaf killer we have a
deployment pipelines and from the comet
or pushed to the repository we are able
to finish deploying to the only
instances on production in 15 minutes
sometimes in 20 minutes okay so the
whole deployment pipeline with building
the application verifying contracts
deploying to the stage running
end-to-end tests on the critical path
and deploying into all instances on
production takes like 15 minutes okay
so we are able to solve acts in 20-30
minutes and that's all and thanks to
this one we can avoid testing everything
it can it and we can rely on testing
just the critical tasks and all other
stuff is just fixed as assets as
possible of course to start this way you
need to have good unit tests because
without unit tests you're just releasing
something to production and you don't
know what's the quality of the software
and we want to fix other but not fix you
know like 10 times a day okay so good
unit tests will prevent you in any
fixing too often okay now let's move to
the other stuff the performance everyone
said that micro services are awesome we
are going to the business and we are
saying inherit the business please give
us the money we'll split this monolith
into micro services and it will be
awesome it will be faster it will be
better and everything will be great
that's of course not true when you split
the Monell it into micro services it
will get much more slower why because
there will be giant communication
overhead ok serializing and
deserializing sending objects sending
jason's over the network
logging request and response it all
takes time so ok that's the problem but
let's run performance tests to be sure
that it's not bad and it's not worse
than in the model 8 but the performance
test rx
are inaccurate and they're tricky okay
there are a lot of why's that you can
fail doing the performance test okay
there there is Giants knowledge about
how to test the JVM application test the
performance because you need to remember
about warm-up you need to remember about
different branches okay
about G's about the whole JVM
infrastructure and you must take care
about the production traffic and the
production traffic is usually on
production okay there is no production
traffic on stage environment I can try
to record it but replying this one with
the proverb peaks at cetera et heart
sing so what can I do else to solve this
problem so the monitoring is the new
testing I want to monitor my application
on production instead of verifying the
performance but then I can decorate my
performance a lot right I'm deploying a
new version to production and it's 2
times slower three times slower than the
other version that's a problem but I
have a continuous delivery to the rescue
ok I'm releasing just ten comics every
day ok there is still a chance that the
ten comics will decorate the performance
a lot but just a tiny chance I can deal
with this okay so I'm verifying and
monitoring all the time on production
using tools like I don't know New Relic
up dynamics dynaTrace that will tell me
okay so today this method is taking like
three nano set three milliseconds more
than yesterday and the day before so
please take a look a disc okay
the problem is monitoring is that we
usually use statistics to describe
what's happening in our application and
when you take a look at something that
is called a scum quarter these are four
different data sets
that have exactly the same simple
descriptive statistics so the mean of X
is the same in all four ideas sample
variance okay correlation linear
regression mean of Y it's the same of
all that for all four data sets but if
we consider that it's for example the
response time versus the number of users
there is a giant difference between
those charts okay so statistic is lying
to us all the time so thinking about the
average response time makes slowly no
sense okay it won't bring us closer to
creating something that's maintainable
so what can we do we can use percentile
what is it present at the p90 tells us
that the 90% of the requests for example
are finishing in third time p99 tells us
that the 99% of samples are following
some requirements okay but there are a
lot of percent icing which produce a
personalized should I care about 395 399
maybe 99.5 okay which person value is
important for us and the funny thing is
that when you consider that you have 10
you you need to make 10 requests to be
able to render the page so p90 says that
in the worst case there is 100 percent
chance that this page will load load
slower than we expected
why because I'm just taking care about
p90 - about the 90% of all requests okay
and the problem is that usually in my
application it's not that just it's not
just that all requests are following the
same time there is usually one slow
request for the page so I'm loading the
page I'm hitting 10 requests and one is
loading the giant amount of data from
some dictionary services and it takes
like 30 seconds to complete and I'm
saying that 90% of the requests must
finish in one second okay so nine
requests are finishing in one second but
the last is taking 30 seconds okay so
that's the problem with p95 I have like
50% chance in the worst case that my
page will load slower than I expect and
what's the problem the problem is that
even if you think about the p99
then I have more than one page load for
the whole session so it means that for
p99 when I just try to get 99% of my
requests to stick the following rules
then for 10 pages per session and 10
requests per page it means that in worst
case I will have 100 percent frustrated
users which is not good for our business
okay so in practice we need to monitor
and we need to take care about the P
ninety nine point nine or 99.95 that's
the stuff that you want to verify does
the stuff that you want to take care
about okay so I'm taking care about
mostly 100 percent of my requests and to
be honest it's really hard it's
extremely hard to take her about the
percentile ninety nine ninety five
because their garbage collection issue
issues caches natural glutton some some
communication problems okay and what's
even more complicated is when you want
to give the business there's a lie of
the pin 99.95
then you must monitor something else
because you need to check what's just
around the corner maybe there is a
hockey stick around the corner okay and
just increasing the load of the
application for few percent
will dig relate the performance three
times that's possible because we are
hitting the wall and we must also
remember about that okay the another
thing that I want to cover is something
that's called automation why because
there is a issue that comes with the
scale of the microservices when you have
ten servers on production or 20 servers
on production it's pretty easy to
upgrade the JVM on all servers you just
need to SSH to the server and do some
actions to update the job okay but what
happens when you have the hundreds of
servers are you going to SSH to all
servers of course not
so we must automate the stuff I need to
have some robot okay or demos that will
be able to do this stuff for me the hard
thing is that when you have hundreds of
servers and each server is maintained in
the other way there is no way to
automate this so the first thing I must
remember is the approach is called the
convention over configuration what does
it mean I don't want to configure
anything I want to have strong
conventions what does it mean for
example it means that if you have a
service that is called
the Builder okay what are the
conventions over you okay so the
artifact ID for this server is also a
builder the name of the jar is a builder
dot jar it lives in a target slash
builder dot jar okay the name of the
service in the service discovery is a
builder the name of the user that it
runs on production is a builder okay the
localizations of log is slash USR slash
bin der slash log slash service dot
block or something and it I'm bringing
the strong convention and then I can
change the project and I know how they
are created how they are designed
because everything is run by convention
do you want to find a VM that the
service runs on
no problem it will be for example
builder one builder tubular free that's
the convention what's the name of the
load balancer for this platform okay so
it's load balancer - builder one or
something like this okay that's the
convention I don't need to configure it
when I'm provisioning the virtual
machine I don't need to say if this
virtual machine must use load balancer
or not is there a load balancer with
proper name yes to use it it's created
for you okay
that's the convention over configuration
that's something that allows you to keep
even the giant infrastructure using just
filters view people and good script okay
because there is no configuration you
are building the configuration at
runtime using the convention okay and
what does it mean that I must automate
anything it means that everything is a
code okay what does it mean Python is a
code when you have a lot of jobs on
Jenkins then you don't want to say okay
so I need to add one profile to the
build job ok I will just open 10,000
jobs and click on them no you want okay
the jenkees jobs must be created from
someplace this place is a pipeline the
cosign for example using job DSL for
Jenkins when I can generate all the jobs
automatically if you need to add a
profile to the deployment jobs then you
add it in one place you recreate all the
jobs and you are done
ok what is also cool in this should I
back up my Jenkins or not anymore I
don't need to back up my Jenkins because
I'm able to recreate the whole Jenkins
instance with all jobs in few minutes
because Jenkins is not longer a master
of my jobs the master of my jobs job DSL
that leads in some key to repository on
some
server okay so the only thing I need to
back up is my git repository the same
applies to infrastructure okay when I'm
able to set up a virtual machine when
I'm able to set up load balancer network
interfaces drives etc which is extremely
easy when you use the cloud so we for
example are using the aedra cloud and we
are using the Java SDK provided by
Microsoft to create and provision the
infrastructure so do I need to back up
an infrastructure no because I'm able to
recreate the whole display platform in
one hour I will just need to execute one
command and this one command will create
everything for me okay what's with the
configuration of those of those virtual
machines so I'm using ansible an answer
is taking care about bringing this suit
or machine into the correct State what's
the correct state it means that the Java
is installed here in the proper version
that there are packages and dependencies
in the proper versions are proper user
super propyl group configuration for log
back configuration of the services
etcetera etcetera monitoring is setup
etc okay and then do I need to back up
this virtual machine no because it is a
virtual machine exploded and just go I'm
able to create it in like five minutes
okay so it means no backup at all I just
need to backup my data not consideration
no infrastructure no nothing there is
also no way to introduce manual changes
so I have great outage of my whole
infrastructure I know why someone has
installed this dependency why someone
has updated such dependency because how
can you update for example docker on
production you need to change the
repository with the configuration
pipeline okay so with the ANSI playbook
and you say ok so now please install
docker in version I don't know 112
instead of 111
and I'm committing it in some context
and if something breaks down you know
okay
so Jacob why did you did you change this
version okay because I know who made
this change because everything is
version and auditable because I'm using
it the same applies to the configuration
okay
other configuration as a code I have
everything as a code to be honest okay
so all my application properties all
configuration passwords etc lives in the
repository I know why someone has
changed the flock why did you change the
garbage collector configuration when and
how etc everything is in the code and
that means I'm able to analyze all
changes in my service okay and thanks to
this approach it's really easy to
maintain the software okay because
everything is there is nothing that will
go okay there is no knowledge that will
go I know how to build this service
because this information is taught in
the repository I can throw it on Viki
okay the wiki page but how can you be
sure that it's it's up to date and I
know that my Jenkins jobs are up to date
because I'm using them all the time to
build the software how do you know that
the application properties or the
password stored somewhere are up-to-date
I know because I'm creating and setting
up my system based on this configuration
so it needs to be up-to-date because
otherwise my production service won't
work ok
so that's the way I'm the fourth thing
that everything is up-to-date because
I'm sending up my service based on that
I can of course describe hey if you want
to setup your service free please be
sure to create such user such groups
such direct restructured setter ok I can
write that but if someone say ok we need
another user but forget to put it on the
weak page then I'm screwed
and if you forget to put
it into the acid flavors then you're
screwed because it's not working on
production there is no other way to
introduce anything to the production
than going through this code okay and I
hope that this knowledge will be enough
to don't read this book in few years
because few years ago everyone was
talking that the micro services are cool
the solution for every issue on the
planet okay
people won't be hungry anymore because
we have Micro Services and that's of
course not true
micro services are the most complicated
I architecture that I ever used but
there of course if giant potential and
when you want to follow these principles
I describe then you will be successful
in living with micro services on a
production not just in using micro
services on your laptop as some simple
tutorial okay thank you very much do you
have any questions ok if there will be
any questions I will be here for a few
minutes to please don't be afraid thank
you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>