<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Deep Dive into JUnit 5 by Sam Brannen | Coder Coacher - Coaching Coders</title><meta content="Deep Dive into JUnit 5 by Sam Brannen - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Deep Dive into JUnit 5 by Sam Brannen</b></h2><h5 class="post__date">2017-03-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CYEzf_C9e4s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so we're talking about Jada five deep
dive into Jana five my name is Sam
Brennan so I'm a spring and Java
consultant at a company called Swift
line here in in Zurich and I've been a
Java developer for over 17 years so
quite a long time in that area in terms
of spring I've been a cork emitter for
spring since 2007 and actually my
original work there was rewriting the
testing framework based on on J and at 4
and testing G so all the annotation
driven stuff gets you've done in the
integration testing with spring and I
still maintain that so that's actually
how I got pulled into the the J unit
side here obviously I'm a speaker
conferences I'm also a trainer and coach
and the reason I'm really stuck here to
talk today is that I've been a cork
emitter for ju5 since last well since
October 2015
so very quickly just about our company
here in in Zurich we specialize in
spring spring portfolio obviously uh
Jana Dan and testing right but also Java
EE in general sorry for architecture
code reviews and that kind of stuff if
you need some assistance feel free to
contact us you'll find us here in Zurich
and on line so the agenda today we're
gonna start off talking about impetus
for change why we even have a new
version of Jane it then we'll look at
Jane at five in detail as much as we can
over the course of an hour and I'll
briefly talk about some of the the sport
in spring five four jaded five and then
if we have time be here for questions
and answers and if I if not you can find
me outside and we can talk later on so
first up Joe fans don't know if I can
see anything
so who tests right everybody it's all
right good who uses Janet yep
anyone use something like test in G few
people so most people Jane there's
anyone that thinks J Unit four is is
perfect as is no reason to change
there's anyone who's everyone wished for
J and afford to be more extensible maybe
or something like that
few people okay
another curiosity who's on a Java eight
already good good okay so most people
here it's nice to see so first up my new
version of Jana Jana for was released a
decade ago over a decade ago and a lot
has changed since then specifically
testing needs have have matured right
people don't just write small unit tests
people started writing the integration
test system integration tests all sorts
of things like that
and so our expectations of what a
testing framework can do those have
grown over the years right so I tell
people J unit is actually a horrible
name
simply because the word gaint unit is
baked into it and obviously originally
it was about unit testing but now we do
a lot more things right you know in
memory databases Epson to P servers FTP
servers all this kind of stuff so we do
full-blown integration testing with
genja but the name stays the same but
yeah it does more than just unit testing
another thing about Jana for was the the
kind of the architecture and the
modularity there was in fact just one
one module so you could kind of call it
a big bald mud right there's just the J
unit jar the one thing and that made it
difficult for the Jana team to change
things and also for people to analyze or
work on smaller parts another topic was
test discovery and execution so those
are tightly coupled and in Gen 4 with
the concept of runners and it's harder
to add in different support or have any
kind of extensibility due to the
architecture of JUnit 4 and
extensibility that's an area of my
expertise right so I wrote the
integration with JUnit 3/8 in spring and
also with J and 4 and I've done it in
Jaina 5 now as well and in J and afford
them lots of room for improvement there
I mean we'll talk about the runners and
and rules but it wasn't easy to always
combine different third-party libraries
like maybe like a mojito and and
parameterize runner and spring and stuff
like that
and let's not forget Java 8 right so J
unit 4 is still based on on Java 5 so
not taking advantage of any features
from 6 7 or 8 and especially with 8 you
know things like default methods and
interfaces and functional interfaces
lambda expressions
stuff like that so who's actually who
knows there's a runner API in jt4 yeah
and how many people have used something
like the parametrize runner yeah maybe
the the spring runner a few people from
Aikido runner or something like that
okay so you realize that you're not
forced which I afford just use a core
jenefor functionality there's this this
runner API it's it's very powerful in
fact it can do anything but that's
because it's responsible for doing
everything and the biggest drawback if
your honors is that you can't combine
them you can only have one now have seen
some teams who came up with some kind of
composite runner where they tried to get
to work at the same time but it really
wasn't baked in or supported by the
framework itself so one very common
example you see online people asking
questions over the years I want to use
parameterize tests but I want to use the
spring runner and how do I do it Nance
has always been no you couldn't do it
with runners just just wasn't possible
so then a few years in Jana 14 came up
with rules and you can read the title of
a few different ways there's kind of a
pun built into that right so you could
say Jana four rules like it's awesome or
you could say rules are meant to be
broken or Janet four rules are meant to
be broken and I would say in some ways
they they always work so in Jana 4/7 the
team introduced a method rule that you
could configure with a truehl annotation
and in 49 introduced a test rule trying
to improve on the method rule that you
could use at a class level and at the
method level but then they realized that
in the day deprecated the original one
and then they realize well okay people
actually still need that and the problem
is they didn't think about the big
picture and coming up with a generic
solution from the start so there's kind
of like three ways to have extensions
and Jana for these are great for for
simple use cases right so like a
temporary folder or a timeout or
something like that and you can even
combine them you can create like a chain
of them if you want but a single rule
can't be used for both method level and
class level callbacks so case in point
the spring class rule and spring method
rule that I got implemented in Springs
testing framework it was impossible
unfortunately to have one rule right we
had one runner that you could use but
when you want to use rules you said well
because of the architecture Jana for you
have to have
and that just makes it kind of annoying
for the for the users so basically copy
and paste to get that working the other
thing is the zero support for instance
level callbacks so instance level would
be support for things like dependency
injection either from like mojito
injecting a mock or something like
spring or juice injecting a bean into
your tests right so there's no
supporting that in jenefor with rules um
you had to kind of fake it and that's
what I did with Springs rule testing
support so in came Jayne at lambda
called lambda just because of lambda
expressions kind of like the next
generation we had a crowdfunding
campaign that was initiated by Johanna
slink and Mark Phillip and in Germany
back in 2015 later joined by two other
Germans Matias medicine Stephan Bechtold
and yours truly here the only non German
on the team but everyone speaks German
so it's it seems to be overrun by
Germans or german-speaking people and we
have a new member since about uh three
weeks and the core team is a commander
and he's also German so I don't know
it's just I think Germans like to test
or at least they like to participate in
and help with j-unit so that that
campaign ran from July through October
2015 we raised almost three to four
thousand euros from seven hundred seven
for individuals and lots of companies
and for companies also dunno donated six
weeks of developer times this was a
super boost we had lots of productivity
in the prototyping phase and and the
alpha phase and as you can imagine after
the funds died out production kind of
dropped off a bit but if your names on
here as an individual they're lucky I
let people in Switzerland you see some
Swiss companies listed up here as well
if you contributed then thank you very
much much appreciated helped us to get
off the ground and get running so we had
a kickoff meeting back in October 2015
with the core developers again some of
them supported by the by their companies
and we also had some other members of
the community so we had Oliver Gierke
from from pivotal you might know him
from spring data spring JPA he just
became a Java champion I think last week
we had a guy there for American Express
and another thing we did is we invited
developers from tooling support right so
we invited somebody from from great
so I'm from Eclipse someone from
IntelliJ and they came and gave us their
input right because if J Mina works well
is a framework but it's not working in
any of the tools if it's not supported
there then no one's going to adopt it
right so from the start we wanted to
make sure that we were on the right
track so that the tools could also
support it so that brings us to Jane at
5:00 after that kickoff the roadmap we
developed a prototype from October to
December 2015
then we worked on an alpha basically
rewriting a lot of stuff from our
learnings in the prototype released that
in February 2016 then we had our first
real milestone back in July last year
followed quickly with some bug fixes
with m2 and then we put out m3 last
November we're currently working on on
m4 that's a couple of weeks to maybe a
month away something like that and then
we hope to have another milestone to
follow that then release candidate and
then we hope to actually hopefully be
able to release sometime this year
tentatively scheduled for the third
quarter this year depending on on
resources and bug reports and stuff like
that
there are however people that are
already using it that's always nice some
people even use it in production they
trust it enough and we used a unit 5 to
test JUnit 5 so it's it's definitely
getting a battle-tested already Junior
five in a nutshell what is it it's
modular or at least we like to think
it's modular you'll see an in diagram in
a bit that we at least have several
modules it's extensible does one of the
main focuses for me personally that's
one of the reasons that I was bicycling
ready to the team because of my
experience with spring spring station
support is very modular and extensible
we can have 30 part extensions to that
and so I've taken some of my learnings
from there and helped kind of guide the
extension model for 4j into five modern
at least we'd like to think it's modern
very least it uses java 8 and we do make
use of streams and and lambda
expressions internally we also allow
lander expressions and streams to be
used in in testing as well another thing
we say is that it's a forward and
backward compatible at the same time
might sound a bit strange so let me try
and explain that so um one of the things
we realized the right is that there are
t people out there
using JUnit three sometimes you're right
definitely you know millions people
using JUnit 4 and we want people to be
able to use Jana four and Jada five at
the same time but we know that the
tooling support um isn't gonna be on
board immediately
so people gonna be able to want to run
Jana five tests on Jana for and then
once the total support goes to Jane and
five they're gonna want to be able to
still run the data for tests but on on J
and five so these are some issues we had
to deal with to come up with some
forward and backwards compatibility so
basically um we have what's called the
Jana platform and it supports already
out of the box running Jane at 3/8 Jane
of four and Jane of five tests at the
same time and new new testing frameworks
can be run with the Jane it for
infrastructure so you can do that now in
your IDE for example if it doesn't
support Jane of five and the way you do
that we have a run and we've written for
Jane four and you say I run with Jane a
platform and it allows you to run stuff
like Jane and Jupiter and the new
testing framework or some other
framework that's based on on the new
infrastructure in Jane at five so what
is Jane of five first we started off
calling all of it Jane of five but then
we realized that's probably not the best
way to go
and after some long debates and input
from lots of people in the community we
came up with a way to split it all up
and for starters we have a new core
platform that we call the Jane platform
that's going to be released his version
1.0 and that's the foundation for
launching any kind of testing framework
on the JVM so not even limited to the
Jane at testing framework so there's
already some frameworks out there
written in scala and groovy and Cortland
for example that are building on the
same base platform that the ju5
programming model builds on as well so
that has at its core on launcher and
test engine api's we have a console
launcher so you can run it from the
command line a Gradle plug-in and maven
sure prior
surefire provider that we've written
talk more about that a bit more later on
so the new programming model is not
called Jane at 5 on its own it's
actually called Jane and Jupiter and the
reason is we didn't want to tie it to a
number like with JUnit 4 because we
don't know the next release might be a
version 6 but it might be still the same
programming model and to make sense to
have a name something like like Jupiter
and Jupiter happens to be the fifth
planet from the Sun in case your
about that and it starts with J and EU
there you so that is the new programming
model and the new extension model for J
unit 5 then we have what we call Jane
advantage I originally proposed legacy
but that didn't go over too well so I
ended up going with with vintage so
everything before J and at 5 we call
vintage and that's support for Jane at 3
and Jane at 4 for running them on this
new platform so this launch API in case
you in the details it's used by the IDE
s and build tools to actually launch the
framework and it's a central API for
discovering and executing tests via one
or more engines so the engines are kind
of like what runners were back in June
or four and to tell it what to run
there's a request object you can build
up with a builder API you can select
things like you can select classes you
can select packages to scan for classes
and so we have class path scanning like
you might have seen from from spring for
example with its components gaining
filters so you can filter based on like
tags like include these tests X through
these test stuff like that and the
feedback has provided via a listener API
if you're familiar with spring there's
also a test execution listener API in
spring but it's quite different from
this one so and don't get confused if
you're importing those they're in your
IDE yep and there's this console
launcher again for running from the
command line and recently we added some
nice cool ASCII art tree output with
colors and stuff like that so it looks
pretty pretty cool in pretty modern if
you run it that way test engine API
again kind of like the runner from
before but more generic so a test and is
responsible for two things for
discovering tests like finding them in
the class path seeing if it has the
annotations at sports and then also
later on for executing them but these
are in in different phases and that's
for a particular program model so like
the one for Jane and Jupiter just
supports the J and Jupiter tests and the
other one for the vintage stuff it
understands the J and for tests and that
means you could have chained to five
tests Jim Jupiter and Jane two for all
running in the same test week you can
even have stuff from Kotlin spec or spec
see another framework as well all the
stuff for any at the same time and have
all the test results
aggregated together so these things are
registered using Java standard service
logger mechanism just add the right
stuff
to your own to your jar you know get
picked up automatically and as mentioned
yet we have the Jupiter test engine and
and the visit vintage test engine
out-of-the-box from us and you can
implement your own so this is kind of
the big picture we see we have on the
platform in the middle right so that's
all the the core features there and then
building on that we have individual
testing frameworks the ones from the
Jaina team are of course the the vintage
engine we have there and the new jupiter
engine and then you can also have some
kind of third-party libraries
implementing their own engine as I
mentioned there's one called spec C out
there that's listed up on the upper
right it already uses as well so the IDs
and build tools rely on the platform
they don't even have to know about which
engines are present which is quite nice
right so the idea is that new testing
frameworks can come along right to the
API is at the platform and then have the
IDE s and build tools automatically
support them without knowing about these
new programming models and new testing
frameworks so if you're writing an old
test you program against a vintage stuff
new tests Jupiter and then other
frameworks and behind the scenes this is
what I meant by it being modular right
so in the past again junior for was just
the one jar well you see quite a few
jars and modules here so within the the
platform itself we have these engine API
and launcher api's and then we have the
platform runner we have the support for
maven and in Gradle down there as well
and then you see at the top part so for
Jupiter the even the API and
implementation are separated so the API
is what you program against as a
developer it has the annotations in it
that you need in the extensions but the
actual implementation of how things are
run is implements and in an engine and
that makes possible to support stuff
like like J and for quite easily so the
jana for jar stays the same you keep
programming against that and then we
have this jane of vintage engine here
within this yellow box that knows how to
discover those tests and run them so
that's the big picture in terms of ideal
ids and build tools and an adoption
IntelliJ was the first
so since IntelliJ 2016 - they have
official support for various milestones
of
jana 5j and jupiter works quite nicely
the clips also has beta support since
4.7 m3 but since we are releasing 5 . o
GA for Jana after 4 7 goes out they have
informed us that the official support
won't go in until 4 8 but you can't
actually try it out with some of the
milestones 4 4 7 and that also works
quite nicely
NetBeans I honestly have no idea
Gradle so again we came up with our own
interim solution for that we have a
plug-in it's not the best in the world
because none of us are great experts and
none of us had ever written a great
extension or plug-in before but you can
use it people use it and we use it in
our own build and the ideas that
eventually that'll get on taken over by
the Gradle team there's some issues
already in the Gradle issue tracker to
track that and deal with that later and
if I wanna know how to use it it's a
doctrine in the user guide we also have
some example projects terms of maven we
also have a provider for that but that
has recently in the past couple of weeks
I actually already been taken over and
by the maven surefire team so we're
happy to see that support going to the
official maven surefire team hopefully
they'll take it in to new heights so
moving on to Jupiter the extension model
we have an extension interface it's just
a marker interface and all the extension
API is are defined in this one package
so when you start importing we started
with our origin and just like Jane to
forth but everything in Jupiter isn't a
Jupiter sub package and again it's more
modular and hopefully I easier to find
stuff just be wary of what you're
importing in your IDs one of the great
things about the extension model is that
you can implement as many of these
extension API s as you want in one
particular one so if you look at Springs
for example it implements about ten of
these extension API s and one thing so
you can combine and match as you need
and again that wasn't really possible to
do something like that with Jana 4 in
June before we had the at run with to
select a runner and then J and Jupiter
we have an ad extend with annotation
that allows you to select one or more
extensions and you can combine multiple
the same time right so you're not
limited to just one
you can find that on an interface on a
class or at the meta level if the
extension can be only applied at the
methyl Oh for example also one thing
about being on Java 8 right so we can
have default methods in in interfaces
and we can have basically test
interfaces with test methods in them
already implemented with extensions
already configured and stuff like that
so new possibilities with Java 8 there
and you can also put extend with on on a
meta annotation so who who knows what
meta annotations are one person okay so
in Java there's no such thing as
inheritance within annotations so if you
want to have something like inheritance
you annotate the Declaration of an
annotation with another annotation and
the one on top is called a meta
annotation so you can come up with your
own custom annotations we'll see that
later on this is the feature widely
known in Springfield from overthought
and we added this in Jana Jupiter
support so this is a term my colleague
coined indentation art actually it's
implemented like this in the in the code
if you look in the code base that turned
off formatting and indented all the
stuff so we could see at all works in RM
but we have several callbacks so several
api's for lifecycle management of your
tests so we have before all which is
like before class jana for and then
nested inside that we have the instance
level before each and then after each
and we have another level more
fine-grained immediately before and
immediately after a test methods
executed that's their before test
execution callback and the after text
execution callback another feature you
might have seen in some frameworks some
kind of conditional execution some of
these ideas are barred from from spring
and spring boot with conditional beans
and stuff like that or maybe you know
about profiles with spring so uh
jada for has the add ignore annotation
right and when I went to implement this
support in j25 I decided that we need to
make it generic so that everyone else in
the world can benefit from this and come
up with their own ways to enable or
disable tests so we've done that at the
container level which would be a test
class and at the test level which would
be a test method so you have
fine-grained support and you can
implement your own conditional test
execution for these instance level thing
again something like the Mojito
extension uses where the spring
extension uses to perform dependency
injection you can do that with a test
instance post-processor and we have
another feature for parameter resolvers
so in jane before you couldn't have any
parameters in your methods test methods
but with Jana Jupiter you can have
parameters in your test methods you can
even have parameters in your constructor
and third-party api's can contain into
that they can hook into that and they
can provide the values that are injected
into your methods and stuff like that
and we'll see that in action later on so
that's also borrowed from spring if
you're familiar with spring MVC and like
request mapping methods that take
various parameter arguments the last one
is for handling exceptions there's a
dedicated API just for that so you can
either a swallow to inspect the
exception or log one etc turns of the
programming model everything is in the
new or jaded jupiter api package so
that's again what you're going to
program against when you're writing your
tests that's where all the annotations
and meta annotations are assertions and
assumptions support for custom display
names which we didn't have and jane it
for but you might have seen it something
like the spock framework visibility so
things don't have to be public anymore
we remove that rule in Jana Jupiter so
your test methods and classes no longer
have to be public tagging is a new
feature so there was kind of categories
an experiment of each and Jane report we
have official official support for for
tags in Jane and Jupiter so you can tag
methods or classes and then when you
have the test engine started up you can
say include these tags or exclude these
tags stuff like that talked about the
conditional test execution Panisse
injection write and land expressions I
mentioned you can use those in certain
places and insertions and dynamic tests
and as well these interface default
method supports again you can pre
implement some of your tests in an
interface and then implement that
interface from different classes then
kind of you know inherit this default
behavior and you can also do that for
things like your before each methods and
stuff as well the nested test classes
that's something brand new there are
some custom runners out there in Jane
for that allowed you to do that
it's basically way to have
classes nested inside another test class
just for basic structural reasons and
dynamic test so that's a easy way to use
lambda expressions and in streams and
stuff like that to on-the-fly generate
tests that you don't know about in
advance so maybe have a data set and you
want to generate some tests on the fly
and they get run like like normal tests
there but they're little lambda
expressions so they're somewhat
comparable to parametrize tests they're
not quite the same they're a bit more
dynamic in that sense
turns out annotations we have an at test
annotation I know you're probably all
surprised we couldn't come up with a
better name so we stuck with that but
again it's in a different package we
also have a test factory that's for
dynamic tests and if you're including
your own test engine there's also a
testable annotation you would want to
look into so instead of before class and
after class like in JUnit 4 we have
before all and after all because we have
a different abstraction there about
containers and then instead of before
and after we have before each and after
each so there's map one to one if you
want to configure a custom display name
you just use the at display name
annotation at tag for tags and at
disabled is the new version of add
ignore and again the reason is because
we have this support for conditions and
conditions are either enabled or
disabled that's why I'd ignore maps on
to disabled and add nested for tested
classes so assertions we debated should
we have our own assertion library but
there's already gubins out there and
then we decided to implement a very
basic set this is in org Jaina duper API
assertions class so not the assert class
anymore but assertions limited set of
course sessions you get your basic stuff
like assert equals in a certain on all
the ones you're familiar with from from
JUnit 4 but we also have things like
assert throws so if you have an expected
exception anywhere I have this little
blue lambda that means you're allowed to
use lambda expressions there or method
references so you can assert that a bit
of code throws an exception and you can
get back that exception and then perform
assertions on that right like the cause
or the message and stuff like that so
it's a bit cleaner than some of the ways
you had to do it in Jaina for for time
outs instead of having that the rule or
annotation like in JUnit for
we also do that with something like we
call an assertion timeout or assert
timeout printful II so the first one
just runs the code in the same thread
and it's not going to print really kill
the the code if it runs too long but you
could alternately use assert to timeout
parentally that'll start it a new thread
and both both of these take lambda
expressions for the bit of code you want
to run and make sure doesn't run too
long assert all very cool feature
actually it's similar to the notion of
soft assertions if you're familiar with
the sergej so they're probably times
where you've written a test and you had
maybe five or six assertions and you
change some code and you're in the test
and the first one failed and you went
and changed stuff and then you ran your
test again and then the second search
and failed and right you kind of got
annoyed going back and forth it would be
nice that we all know all all six are
going to fail or which ones aren't so
with assert all you can provide each of
the individual assertions kind of in a
group of assertions as lambda
expressions and J and it will execute
all of them and track all the exceptions
and then throw them all wrapped in one
one exception that's pretty cool
one thing that's different so you'll
notice pretty pretty immediately if you
have a message for a failure that now
comes at the end of the list so it's now
like expected actual and then the
message and another thing we support is
lambda expressions for the message so
you can have your failure messages
lazily evaluated so you want your test
to run as fast as possible on but when
they fail maybe you want to provide a
lot of context you know building up a
large string maybe lots of information
but you don't want those strings to be
concatenated and built when your tests
are successful so you can just have a
supplier string implemented as a lambda
expression to have that easily evaluated
and of course if you need more power
don't blame us you're free to go use
another assertion framework so something
like is r.j. hamcrest etc those also
work perfectly well with Jane Chu pure
just like with Jana 4 so now we'll see
if I can live code up here
while standing and if the demo gods are
with me so we'll see
so I'm not using the beta version of
Eclipse so I don't have the built-in
support to run a test on its own so I'm
going to cheat and use the jaina for
integration I'm gonna say run with
j-unit platform and this allows me to
run Jane and Jupiter tests with the Jana
for infrastructure on on an older
version of an IDE so in here we can
start off by saying tests don't pick the
one from or gain it right that's Jane
you four if we want to pick the chain of
Jupiter one and that's probably not
horribly exciting but the thing we see
here is this doesn't have to be public
so just let's the type and if we run it
it should hopefully work just fine
and what we're seeing here won't be
quite the same in in IntelliJ or in
future versions of Jana but um when we
run the tests like this with the Jana
for infrastructure we actually see the
engines listed first so the vintage
engine is there that just weren't any
tests discovered the j-unit jupiter
engine is there and it found my test
class and my test method and that works
as expected so nothing too shocked in
there start equals if we pull those from
the hopefully this is from the right
package right yes the janet duprey api
assertions cert equals four nothing
exciting here two times to run that I
should still pass and what I was saying
about the messages is they now come at
the end and you can optionally implement
that as a land expression my
very very complex failure message so the
point here is that if this ends up being
something robust and dynamic and taking
a long time to build
if the assertion passes then Jana
doesn't even try to evaluate it but
otherwise it would lazily evaluate it so
that runs fine and now if I say three
then it should evaluate my lambda
expression and then build up the string
so that's kind of a nice feature there
what else do I want to show assert all
yeah that's a nice one so let's say we
have this one and the one that didn't
fail and put the failing one first right
so the old use case is right you run it
and the first one failed but we didn't
get to the second one we do want to know
if they all work and the way we can do
that we can say assert all and then that
expects executables and these are just
lambda expressions so you can say like
that points are something points to
another one I'm copying pasting here
so you have a comma-separated list of
lambda expressions and you want to
assert all of them
no is that big enough can people see
that okay so this is what I was saying
hope that isn't reforming everything if
I run this now it will tell you here in
multiple failures this one expected
forward was six and if I had additional
failure in there and run the test again
we'll see that it actually this it's
kind of zoom in on that
yeah right so you see it collects all
the exceptions there and you can view
each of them in the results that's quite
a quite a nice feature saves you time
for going back and forth when you're
asserting in multiple things with any
given test method right and assert
throws let's try that one out insert
those this is a again lambda expression
so expected type I'll just say one-time
exception in our class that's what I
expect it to throw and my executable is
going to be some code that I have my
service layer for example that throws an
exception
oops
boom
so what's going on here I don't like
that seems happier no no semicolon okay
so there we have again this would
probably some some method in your your
service layer even can I extract that
why do you doesn't like me
forget it okay so if I run that let's
fix this let's uh so speeding there's
two and two right so that passes and if
you wanted to get a hold of that you
could assign that to a variable
exception right and then you could even
you know it's cert something else assert
equals and you could say expected to say
boom right and you could say exception
dot get message right so then you have
the ability to to test and performance
oceans on the exception afterwards and
assert timeout similar to this right a
similar structure you pass in a lambda
expression for some code that you want
to execute within a given time out okay
what happened there
good okay so the display name we get
that later assumptions we also have
support for that that's something you
might have seen in Jana for so they're
times on when you want to say I want to
assume this is true before I continue
for example to abort the test mid-flight
maybe you're only want to run that test
on the CI server or maybe you only want
to run particular tests when you're
running on on Windows or maybe only on
Mac something like that right so we have
this assumed true and assumed faults
like there's in Jane two for but we also
support boolean suppliers and suppliers
of strings so you can use land
expressions and method references for
that on J and Jupiter and there's
another one that's kind of like um
sophisticated if block you could say
assuming that
some condition is true then execute this
this little block of code provided via
lambda expression so I will skip that
for this take your time we have one nice
thing in the reference manual we have
lots of lots of demos and all those
demos actually come from real code so we
build the reference manual of the user
guide for J and Jupiter based on all
these examples and that's in a
documentation project so any of the
stuff you want to check them out
the surgeon's demo you can go look at
the code yourself and it all it all runs
so assuming true and I was saying
there's this like assuming that we're on
the CI server then perform this code and
otherwise don't so it's kind of like an
advanced if statement and then perform
some additional assertions if you wish
to are we doing in time okay how much
okay so test names by default based on
Java syntax but you can use that display
name to have something dynamic so I
should be able to show that really
quickly display name and right so you
can have something more events like that
and we see that it will actually get
displayed here and then in the test
results as well um you could also pick
an emoji if I can copy and paste that
will see yes and who thinks this will
show up it doesn't show up in IntelliJ
but in Eclipse we get a nice little og
in the test so that's always everyone's
favorite feature and now we have to move
on for the sake of time a bit quickly so
dependency injection this one the places
where these two inch model meets the
program model using these parameters
Alvers api's you can implement your own
and more they like you something fun
like mosquito mosquito mojito or spring
and not just for test methods but also
for constructors or your before each
methods and stuff like that so use cases
implement in
than something like the URL to the
server a port number something like that
data source or even an application
context in in spring test info that's a
way to have a kind of reporting or be
able to interact with reporting from
your tests so you can have a test info
object injected straight into your test
method there was Oliver in the
background that does that and I can
probably do with that very quickly so
with the method test info and get access
to it I'm not gonna do anything too
exciting here I'm just going to print it
out just to see that it's working so I
should have something in the console red
and we see this is the test info so we
get the name right whether or not there
any tag configured for that on the test
method test class this kind of stuff so
you can access things about the current
tests programmatically via the test info
where you could implement something like
that on your own as well
tagging used to declare at tag on a test
interface class or method like this at
tag fast and then you could some say
when you start only run the fast tests
only one this load test smoke test stuff
like that another option is to have a
custom tag where you declare a tag as a
meta annotation right so here we have
this custom annotation we've written
called fast annotated itself with tag
fast then we can just use this at fast
annotation and we can even go one step
further having a custom composed
annotation and we just what you there is
we can do what we did before have that
tag fast but we can also combine that
with other annotations from Jane and
also from spring that works very nicely
so now we have this fast test annotation
and we can just declare that so people
are already doing that in some of their
projects with stuff like integration
test smoke tests things like that
conditional test execution again another
place where the extension model meets
the program model with those API zat
disabled is actually an implementation
of this if you want to see how that
works you can check out the source code
for disabled condition and you can
deactivate them all if you want via a
system property so you can say basically
all the tests that are currently
annotated with that disabled because I
want to see if they're still broken
right something like that
default methods so I mentioned we
support those and this introduces a new
concept that I like to call um test
interfaces or you might consider it to
be something like a testing trait if you
remember that from other languages
things are supported there before each
and after each test tests factory for
dynamic tests tags extensions these
kinds of things you can implement those
in your test interfaces and we have an
example and the user guide so I'm not
going to spend time on that I just
encourage you to check that out in the
user guide nested test classes again
this is a way to have a logical
hierarchical grouping of test classes
other than is allowed for you or
supported for you with um package
structures in Java and they have shared
initialization and state so the outer
instances you can access obviously on
that information since it's an inner
class and you just declare add nested on
the the inner classes inside your top
level and you can have multiple levels
of nested tests so you can combine these
with test interfaces as well I'm opening
up some some new possibilities so we
have this testing a stack example in the
user guide and I might be able to find
that one really quickly testing your
stack demo if I run this it does not
work because yeah so right that don't
have the beta support in Eclipse here
but I can fake that by doing something
like this has to be public because Jane
your four requires that and now if I run
it we should see something quite
different you've never maybe seen before
so using custom display names and we see
we have nested tests within nested tests
class here so a cool feature you might
find useful
some people from BDD or they like that
kind of stuff
dynamic tests so for that I'm stead of
having a regular test method you have a
dynamic test or one or more that are
registered at runtime as lambda
expressions like by returning a stream
or collection of these and you annotate
one of these methods with at test
Factory so again this is somewhat
analogous to parameterize tests except
that you are actually generating the the
code on your own and that's for a demo I
will also take the one that we already
have and just show some examples of what
that might look like so one in this
failing that's fine it was expected the
current ID support doesn't understand
that in dynamic stuff so the show-up is
unrooted in the future they won't
here we see lots of dynamic tests that
were just generated on the fly and the
way that looks in the code as you say
something like like this you say you
returned our collection of dynamic tests
and then you can create like a list on
your own dynamic tests providing the
names and then providing the code that
you want to execute and so you could
create this list for example from your
own custom data set from some data
provider that you have on your own
what's missing
the dynamic tests don't get the full
support for life cycle callbacks that
regular test methods do and we're
looking to see if we can fix that or
make that better official support for
parameterize tests isn't there yet but
it's in a branch right now and should be
coming out in milestone for scenario
tests something is someone - what you'd
have in intestine G where you can have
multiple steps that depend on each other
but we're considering adding that into
the core as well and also things like
parallel execution we don't have support
for that yet even though was in June of
four so we're gonna looking at ways to
do that now I'm running out of time I'm
just gonna fly through this stuff right
here and if you need you have any
questions at the end just just come ask
me so again spring has support for Jane
and Jupiter since five dat Oh M one and
M five is coming out today I believe
that already supports all of the core
integration testing support from from
spring and an in addition also supports
dependency injection into your tests
into the Constructors in the methods
using Springs annotations like at Auto
wire dat qualifier etc and you can also
use spell expressions for
test execution it does work with spring
for three and my custom project here
spring test j25 if you want to play
around with that on spring for three
before upgrading to spring five oh and
the way that would look there's a spring
extension for that you just say attics
in with spring extension we have some
simpler convenience annotations at
Spring Jane and config which combines
things like at context configuration
plus the registration of the spring
extension and something similar for the
web support in spring really cool things
really powerful this at enabled infinite
it's disabled if so I said at disabled
as in Jane and Jupiter but we have these
two in spring that allow you to access
beans and your application context to
decide if you want to run or to execute
a little spell expression to access
maybe the date or the time or the the
server name or stuff like that so you
can do really cool dynamic stuff just
write an annotation to say disable these
tests or or don't know we'll skip that
for now an able on Mac I might be able
to show that one really quickly
they're not here
yes okay so this is what I say we have
this at enabled if annotation and you
can provide it a spell expression you
can access things like system properties
and you can basically say check if it's
on a Mac you could do something similar
for for Windows and stuff like that and
that's the power of using J and Jupiter
plus spring support kind of combined so
it kind of opens up new opportunities
and we'll see where the community goes
what's what you all come up with that
you can do there dynamically
spring boot also works quite nicely with
on j25 with some custom configure I have
an example project online called spring
events where I combine spring boot
window for their spring boot test
annotation there are configuration for
the mock MVC testing web apps of spring
and the new spring extension I combine
it like that into one annotation and
then I can just basically use that so I
can have a test like this this actually
works
much less code much less configuration
and you would seen in the past so again
taking spring 5 spring boot and and Jana
Jupiter one annotation to say I want all
that you can auto wire in the mahkum you
see created by spring boot into your
test method and then just use it locally
have custom display names all sorts of
stuff so I'll switch to new features
coming to play together and in closing
check out Jana that org slash Jane at 5
we have what we think quite nice user
guide working on it all the time but
lots of documentation there lots of
examples Java Doc's online as well you
can find us on on github two projects
right for the main code is 3:00 to 5:00
for some of these sample projects change
of 5 samples and if you have questions
please ask them on Stack Overflow with
the Jane at 5:00 tag and spring
references just started spring that i/o
and you can find all that stuff as well
is there any time left
one minute is there a question that
takes less than a minute I don't know I
don't see it
doesn't appear so ok well then thanks
for your time hope you enjoy it
find the answer as you're going out you
can use the voting machine to leave your
feedback thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>