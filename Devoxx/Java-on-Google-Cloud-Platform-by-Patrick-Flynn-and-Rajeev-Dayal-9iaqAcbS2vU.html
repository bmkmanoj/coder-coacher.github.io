<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java on Google Cloud Platform by Patrick Flynn and Rajeev Dayal | Coder Coacher - Coaching Coders</title><meta content="Java on Google Cloud Platform by Patrick Flynn and Rajeev Dayal - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java on Google Cloud Platform by Patrick Flynn and Rajeev Dayal</b></h2><h5 class="post__date">2016-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9iaqAcbS2vU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody welcome to the Java and
Google cloud platform Talk
my name is Patrick Flynn I'm the tech
lead on for the Java tools team on
Google cloud platform so you know all
your tooling needs for build tools maven
great all IntelliJ eclipse it says wait
I also forgot that then yeah I've been
working at Google for around nine years
now I've only been on tools for the last
two before that I worked in ads Java
server infrastructure and before that I
sort of suffered in the wilderness
working on supply chain management Java
backends okay um hey everyone I'm Burt
Eve Dayal I'm an engineering manager
here at Google and I manage the Java
tools and the Java Runtime to the cloud
SDK teams I used to be the tech leader
of the Google web toolkit or quit that
is now called and a Google plugin for
Eclipse and before that I used to work
on you know a company called auditor
comm was doing web front-end work
actually at dealing with the joy of Ajax
here's some stuff you may not know about
the cooling cloud so moving this talk
today is going to be focused on a demo
around how to deploy Java Google
container engine and then how you should
debug a scaled service across multiple
instances and but we thought we thought
we'd kind of like go through memory lane
explain to you how we got here you
probably know some of those but the
Google journey is kind of different
because Google isn't in some way it was
very isolated from the external
community and I think so the first thing
is the first Google server I don't know
if any of you guys know does anybody
know what the first Google server was
made out of anyone
parts of it were that is partly true
that is partially correct you get
partial credit for that answer the rest
was made out of Legos up dude
yeah okay so that's a really cool server
I've built the lot of servers I've never
built a Lego server and that is really
the first Google server but it was at
Stanford before they were actually
serving like commercial traffic and
Google has a general love of Legos
there's just Legos all over the offices
this is probably why yeah we iterated on
the Legos server and eventually Google
kind of became a commercial company but
it was always known as a scrappy company
well at least internally the the the
motto was always started to do more with
less and we're kind of notorious with
the data center space that we rented for
kind of cramming in as much equipment as
possible so like the next server was
actually built in part with cork board
and so that was an actual Google server
rack we didn't even have cases for the
computers they thought they figured out
they could put it more into this space
by not having cases and just separating
them with cork board I don't think it's
very safe yeah it seems like a fire
hazard yeah yeah I wouldn't think it was
a fire hazard
I wouldn't recommend a strategy anymore
I guess it worked for a while any case
we've iterated on that design and today
we have less scrappy datacenters I'd say
I didn't mean crappy I said scrappy yes
it's a big difference you know we design
and build and own our own data centers
all of everything that we offer is
provided on premises that we control we
have a child floor now all the wires are
nicely hidden and this vast improvement
over the cork boards yeah yeah and
actually this is a picture of one of the
latest data centers and pretty sure it
was the one that was built up
in Scandinavia I think it's kind of
beautiful it it looks like a computer
chip but blown up like by a million or
something like that yeah and one of the
cool things about these data centers is
that they they are actually like pretty
much carbon neutral they don't they
don't use carbon electricity they use
heiko yes that was a I think it was a
couple years ago we achieved that but
yeah that was a really big
accomplishment actually to be carbon
neutral for our data centers yeah but
since yesterday we don't really care
about that yeah yeah we're going pure
coal for our data centers next thing
Center is gonna be pure cocoa yeah you
heard it here first
yeah coal power co powder I like it
alright so moving on from coal you know
what given that you have a data center
what do you do with this data center
right you have a lot of computers a lot
of things happening how do you actually
run software effectively on on a date in
a data center right and this is where
Bohr comes into play actually and this
beautiful picture Borg was or cube was
drawn by Patrick wait before you before
you worked at Google how did you manage
all your jobs on your backends well
let's see I mean it was a lot of bash
scripts efficiently right uh bash
scripts reppin logs and then copying
them to random place when you set up the
server's yourself you know yeah yeah
yeah yeah exactly
tedious it was extremely tedious
actually yeah yeah so it
so with Borg and and what Borg is it's
really a it's a way to run internally a
way to orchestrate containers across a
bunch of physical machines now the idea
of running compute workloads a bunch
across a cluster of cookies not new to
Google I mean that was its initial claim
to fame with search it was really
running like pretty much really good
software on very mediocre hardware right
things will evolve since then and now
what we've got is we have this system
called Borg and it allows us to
basically orchestrate container
workloads internally so contain it like
using containers though it's come in
vogue in the past three years for good
reason
Google's been doing it for many years
actually like internally we doing it for
many many years and actually Google
engineers contributed to see groups and
push that into the Linux kernel which is
sort of a basis of containerization on
Linux I'd also like to point out that a
Google engineer drew that picture of the
Borg cube yeah that was that that was
you that was you as me that should be
the new logo yeah we have lawyers and
stuff we have to be kind of careful when
we put into slides
yeah I mean paramount Star Trek so we
ready yeah so I mean the only the only
other thing I'd say about about more is
just relating this to kubernetes right
kubernetes which I mean it's talked
about quite a bit is really you can
think of it as almost like the
externalization of borg in fact many of
the borg engineers actually were
contributors to kubernetes and so we've
it's almost it's not quite Borg v2 but
it's actually an improved version of
Borg that's just open source right to
work a story containers a similar
fashion and you know we probably the cat
out of the bag here but you know what do
we run like what do we run actually on
you know on Borg like what we do on
these data centers I don't know I don't
know why don't we flick over there and
see okay Java Java beans or Java we run
a lot of job we do we've run a long run
java java we've been running for a while
and in fact we actually run a heck of a
lot of java like a lot it's a lot of
beans there's actually a prize if you
can tell us how many beans are in this
picture at the end of the talk or if you
told us how many lines of code that's a
mortgage we have in the Google source
repo that are Java any guesses that's
for a number out there more than a
hundred thousand anyone a billion no no
we're lower than that I wish you can say
yes I think but no we're lower than we
have more lines of code than that but
not of Java code I think this is the
first time we've ever like released this
to the public but we have around 230
million lines of Java code in one google
source repo
yeah so we're you know that
a lot of Java code and you know Google
as the company's been deeply invested in
Java it's actually one of the four major
languages that we use at Google and you
know a bunch of the work you all have
actually seen externally so guava GWT
juice dagger basil is the open source
version of our build system which is
actually written in Java so there's a
lot of work that we've actually done on
Java over the years and you know what
we're trying to do what we've been doing
the past couple of years is actually
taking the experience and expertise we
have with Java as a company actually
focusing it on the Google cloud platform
how do we bring this this knowledge and
expertise to the external world to make
it easy to build develop and run
workloads on Google's cloud platform
Java workloads a Google file platform so
you know just just just to say like okay
so how do you run a Java workload on
Google's cloud platform I mean many
folks may not actually know that right
and there's a few services that we offer
to do this
so there's App Engine maybe some of you
have heard of App Engine it was released
in 2008 and it it first supported Python
Java I believe was released in 2009 and
this is kind of this was the birth of
platform-as-a-service I mean it there
really wasn't the term before then
actually it's sort of like this is kind
of our first foray into into having
cloud computing right so that you could
give us code and we would run it this is
the first thing we actually did and App
Engine is interesting because you just
think about the code right you don't
worry about machines you don't worry
about that Network the operating system
you don't worry about scaling actually
you just give us the code and you know
we run it and we scale it right and the
types of apps and services you can
actually run on here are you know java
servlets right
just typical java old cell java web app
and actually in the beta we're actually
putting out App Engine flexible
environment which is in beta right now
and you can actually run containerized
workloads on App Engine as well yeah one
thing that we should probably mention is
I mean you've probably all heard of App
Engine but what's not well-known is that
there are a lot of very successful
companies that have scaled enormous leap
with App Engine right I think one
example is snapchat which
is now really very very very high
traffic and they are running on Java a
bunch and standard yeah the group they
basically grew up on App Engine and
they're they're still on App Engine so
another another service that you can
actually run on is called container
engine or well actually kubernetes but
then hosted kubernetes Google hosted
kubernetes is known as container engine
and here you obviously think in terms of
like a container right so you don't
really worry about the machines and
whatnot you don't really worry much
about the network setup you know you
worry about the OS your dependencies
there but you think in terms of the
container and you know you can kind of
run anything right any job app or
servers gonna be containerized can be
run there and then finally I mean
another another you know sort of a more
fundamental piece here is a compute
engine and here you're getting a virtual
machine right and the virtual you can
get a virtual machine you can actually
select from a bunch of different OS
images like Debian Ubuntu you know SUSE
all those red hat you can actually you
can also even get a Windows machine if
you want to you can custom size it so as
a feature that we have so you can
actually pick the exact number of like
cores you want for your workload and you
can install what you want on it and
there this is obviously very flexible
right you could just do what you wanted
to machine the custom sizing I think is
unique in the industry you know a lot of
typically you have to pick like if you
need eight cores you're gonna get like
42 gigs of ram with it or something like
that and you can have to pay with that
RIM even if you don't need it on Google
cloud platform you can actually
customize exactly how much RAM and how
many scores you need and only pay for
that yes yes exactly exactly
so yeah these are the these are kind of
like how you would run workloads one
thing I'd point out just on this slide I
didn't really draw it but just going
from the top to the bottom here you're
really going down this sort of what we
call the compute continuum right from
like platform as a service to container
as a service to infrastructure as a
service and the higher up you go it's
sort of like the less you have to the
higher up the less you have to worry
about less you have to do but you have
less flexibility the lower down you go
you have more flexibility but you need
to manage more yourself right and you
want to give the ability for people to
operate at all levels of this continuum
it really depends on what you're trying
to do alright so yeah it's a bit of
stalling like what do we actually do
right like what do we actually do here
so you know what we're doing on Java for
gos cloud platforms broadly divided into
three categories right there's tools
there's libraries and there's runtimes
so on the tooling front we're building
support into Eclipse and IntelliJ for
you know for basically initially working
with App Engine right so that's getting
started locally running and debugging
and deployment to App Engine right we're
also doing work or have done work to
debug live production workloads and
that's actually some of the work that
Patrick's going to show you soon we're
also doing build tool plug-ins for maven
and Gradle and these are helping you
package and deploy your application to
App Engine this is really this is where
we've been spending our efforts now and
you know as we move on we're gonna move
on to more of the features around
kubernetes in the future in the coming
year um another important area is
actually building idiomatic client
libraries if you want to use google
cloud api's so all these api is here
like storage datastore bigquery pub/sub
these are all their REST API so you can
always like you know hit it with HTTP
right but that's kind of ugly if you're
trying to a job application right to use
these things so previously for some of
these services we auto-generated a a
bunch of Java code right so that you
could call these api's but the giant was
it was kind of ugly it was not idiomatic
it would work it was in Java but it was
it was pretty ugly so we put a lot of
time and effort into building idiomatic
Java client libraries to use these api's
and actually an interesting thing is
their support for you know for these aps
using G RPC G RPC is if for those that
don't know is the open sourcing of one
of our internal RPC protocols actually
so we open sourced it and you know it's
it's highly performant it it actually
relies on HDB too so you actually get a
lot of benefits performance benefits by
using G RPC and the third thing area
that we're working is is basically the
runtimes area so what are these the run
times are based docker images for Java
workloads that are that we actively
support and maintain so we have an image
for the open
kay the openjdk plus jd9 and what we do
is we you know we maintain them we patch
them we make sure they're performant and
we actually make sure that if you're
running a workload on them you get a
bunch of the diagnostic features of
Google's cloud platform out-of-the-box
one of them is called the cloud debugger
which Patrick is going to go into soon
and yeah we actually are working as well
we will start working on a runtime for
Tomcat oh and yeah one last thing I
mentioned that it's all open source and
we have links at the end of the
presentation so you can go check it out
all right but you know that putting us
back to Patrick like how can all these
how can all these tools and all the work
we're doing actually help you as a
developer so how many of you in the
audience are Java back-end developers
that's a lot of you what a surprise how
many of you have ever experienced a bug
in your servers that you could not
reproduce locally that's a pretty common
scenario it's kind of a like you lose
your hair over that kind of thing right
and yes yes weird you guys that ever
happened to you they you know before you
worked at Google you had kind of a
head-scratcher that you can fix and then
you had to go through some kind of
painful ordeal to do it yes
yeah yes many a time one at one company
I worked at in particular it was a you
know we had a web front-end in Java and
you know it got it got decently high
traffic I mean it's about 16 million
like hits a day so not Google scale
traffic but you know relatively I guess
really high traffic and yeah I mean but
others knew deployment and JVM czar just
kind of crashing right they were just
they were just crashing and it wasn't it
was sort of unclear why as a memory
problem and then we realized okay
there's some there was some issue with
our caching logic right because we
weren't using like Apaches J cache or
anything like that we actually like how
to roam caching which is probably a
mistake but we did and yeah so we
basically had to log and say well you
know what where is the how full is a
cache like what's the hit rate and then
we added these logs but guess what you
have to do you have to deploy your app
again so that you're logging all that
information and
there wasn't magic services to do any
aggregation of this so to write like
some pretty terrible scripts that would
ssh into all these machines and like
grab the logs and if the log was like a
gig then you know there would be
problems and then i would grab he's
grabbed and I'm pretty bad at grab so we
would do all these things right and then
you know when you dig in a bit more and
find out more information and guess what
you have to add more logging because you
just need more details and you deploy
again so the whole it was like a
two-week this cycle is crazy yes two
weeks took two week and that was a while
back yeah I had kind of a similar story
but we used Windows and that kind of
made it ten times slower ten times we're
paying for four weeks
sorry windows developers it's a lot
better now I know so one of the cool
things about coming into Google a is
that you have this incredible
infrastructure right hardware
infrastructure you're running at massive
scale but then what happens when you
have a hundred thousand jobs running on
that cluster and you start getting some
kind of threading related bug that you
just cannot reproduce right you need
some way of getting diet not Diagnostics
information about what's going on in
your java jobs so I think that's cut the
demo right yep okay so the first thing
I'm gonna do is create a kubernetes
cluster so if you look at this command
so kubernetes open source you can run
kubernetes
anywhere you like but Google cloud
platform has a managed kubernetes
service that we provide for you G cloud
is a CLI for the Google cloud platform
so we have a container sub command which
has kind of groups together all the
container related commands what i'm
doing here i'm calling G cloud
containers create deployment the buggy
is the name of the deployment and then
I'm passing this is actually important
if the cloud debugger you don't actually
need it otherwise the
cloudy bugger oh I'll scope to give so
that the user agent has it to be able to
talk to our cloudy bugging service oh
wait oh no okay let me well it's not
really running base yeah okay so I'm
going to delete this cluster that takes
a little while so the the infrastructure
in to run a kubernetes cluster is kind
of significant right there's networking
in virtual machines so these commands
take a while and they're gonna spin up
the master or spin up all the notes that
you've that you want and yeah so let me
actually just go to the sample code that
I'm gonna show you this is a really
simple example I just want something
that people could grab right away if you
can have a simple threatening example
that you think of email it to me okay so
what this what this service actually
does is it exposes an endpoint that
returns that returns the browser that
you're using right so if you look
through here we check the user agent
contains Milot but Zilla which is
Firefox looks awesome for it we return
Firefox if its Explorer named Joseph
rank cetera you get the idea and see we
go through so the next thing that's
actually super interesting is the docker
file right
okay how many of you have used docker
before so you're familiar with docker
files there's nothing really crazy going
on in here one thing to note is that I'm
just using the open JDK 8 image that is
not curated by others it's not managed
by us we've got no code in there which
is why I'm configuring the agent
manually in here just wanted to show you
you can use whatever you want to use the
cloud debugger in fact you can run the
cloud debugger off of Google cloud
platform but you would have to speak to
our cloud debugger service through an
API so what I'm doing here
I'm gonna highlight there's this Rundle
you get we're downloading the Java
debugger agent exploding it and then if
you look at the entry point down at the
bottom we specify the agent path to
where we installed the cloud you birth
debugger agent and then also what's
pretty important here is can I get to
the you got the service name at least
yeah so the the cloudy bugger runs on as
many instances of any kind of service
that you want right but we don't know if
your App Engine and Google Nettie's
something else right we need a model
that we can use to identify this service
so I mean there are various ways that
you can do this but in this case what
we're doing is we're passing in the
service name and the version of the job
that we're running to the agent so that
when it reports to the circuit to the
server the server knows can identify it
so that we can actually set the big
points that we want to see how Billy is
doing okay all right so it's gonna take
a while
actually I mean we we could talk a
little bit about just like the cloud
debugger like the cloud debugger itself
and and what it is I mean maybe from the
name it may be it's obvious it's like
debug things in the cloud but what it's
really like what the product really is
is it's it's what's called like a
post-mortem debugger so the idea with if
you're like running a workload the idea
is to be able to set a basically sent
like a watch point
right it's I mean it's kind of like a
break point but you're not actually
breaking execution right you're actually
just stopping there and it's sampling
and taking for any time that is hit a
samples being taken and that you can
actually look at later right so that's
basically what services and it's useful
for production debugging because you
don't want to stop execution it's it's
kind of the miracle that you are looking
for when you had that impossible to
reproduce but because you've got a
thousand instances right you don't know
where it's gonna happen you can't like
connect your debugger because even if
you did know what instance was gonna get
hit you would be actually stopping
production traffic the user experience
should be right so let me just kind of
show you how we configured this app I've
got a bunch of properties here like I
specified the service name based off the
artifact ID our DCP project ID and one
thing that I did basically has a means
of injecting the service inversion into
the doc files I just used the maven
resources plug-in to filter it and to
our target directory so I'm sure you're
all familiar with that plugin
she used maven and and then we use the
Spotify docker maven plug-in which is a
maven plugin that helps you do dock
related active things like build and
publish docker images pretty cool so
what I've done here like you can see is
that I've added the docker directory
which is my filtered target directory of
the docker file I have the target path
and then I include the final jar that I
think that I've got one thing that I did
that I thought was convenient is I bound
the install phase of maven to the build
from the docks modified docker goal
because because why not write your your
you're building a binary and you're
putting it into your memory foam might
as well build the docker image and put
it into the docker
local blocker repo finally this part is
important for so it's talked a little
bit about source context right it's not
enough I mean it can be useful to just
not have source context and run the
debugger agent and see the values but
like you kind of want to know what
version of your code is running in
production
so that we can actually tie that to your
source so what we do is we have a goal
in our App Engine plugin which will
generate source context files for you
which are it's just a file format that
we created to capture the for now I
think it's only get repos yeah get repo
and then the the commit hash yeah
exactly and what we do is then we
package that into your application when
we deploy it final kind of a neat thing
that I did is I so we have this this
docker sub command of g-cloud which kind
of wraps it and provides the context of
g-cloud credentials and stuff like that
and we also have I don't know if you
know a Google container registry where
you can pry publish your your private
containers that you don't want to share
with docker hub for instance and you
know it's obviously the forms really
well and what I did is I found that to
the deploy phase of our application so
so our our cluster has come up it's got
three nouns what I'm gonna do is I'm
just going to remind I'm gonna may even
deploy so another interesting thing that
we do is we do a lot of caching of like
container dependencies and we even have
like Google cache of maven central so
that you can configure your projects to
build really quickly if they're building
a cloud platform as you see I pushed and
deployed GCR and 14 seconds okay so
after the bill what we're gonna do is we
are going to run the app so actually
we're gonna actually maybe what I'll do
first is show you the app running
locally so you have an idea of what this
application does there's a play button
sir
as you can see just a standard spring
boot up right ah this is strange
what's going on that's chrome is it yeah
yeah if something is wrong with our
service how are you gonna fix it get an
ID yeah all right well first let's
deploy the app to that we've build this
boy at the production we will do is coop
CTL run the deployment name point to the
image that we just built it's running on
port 8080 and that was that fast
it's kind of amazing how fast kubernetes
brings up services it's like literally
order of seconds by time that all the
containers are up and then what we have
is so the other thing that we need to do
is once it's up so kubernetes is not a
platform as a service right when we
bring up jobs in our cluster we don't
necessarily have an endpoint that's
public on the internet that people think
can go through so community does offer a
means of of actually doing that so what
I'm going to do is expose the deployment
through a load balancer okay that was
fast to you so if I see service yeah so
provisioning the external IP takes a
little time
right but the service is up so we can
actually connect our cloud debugger
right now if you want to small so what
I'm doing here
let me go man there we go if you see
down here we've got this run run
configuration it's a stack driver
debugger like what I can do is connect
to it so you can see that I've selected
the project Java tools dev ox a lot of
select your latest deployment which is
mmm-hmm the service aim and the version
that we provided right now we can attach
to it zoom back out I know what happened
earlier okay so now we were actually
connected let's actually see how we're
doing provisioning that external IP got
it
see this is an older one so the IP isn't
correct this is external IP run it and
it's working is running on GCP and let
me actually scale this up so I'm gonna
so that's now creating three replicas of
phosphorus how many was it to start with
one I believe okay okay so that means we
now have three instances running at the
same time and we want to debug this
right so what are we gonna do we go and
have a controller so we know that
display name doesn't return Chrome so
that's that that line probably isn't
gonna get executed we know overturns
Firefox we might as well just took this
snapshot here as you can see there's a
little check mark that just confirms
that the service has acknowledged that
this is a valid breakpoint in the system
and we have to do over here
it's just refresh and you can see let me
zoom in that's gone I hope some of you
guys saw that so basically if I know if
you can actually change the font on this
part of the UI but so if you see how do
you I guess that's not too bad right um
basically you see the stack right if we
go back what happened here thank you a
lot
really okay okay so you can see that
we've returned we're done right nothing
blocked
but it looks like I hit a breakpoint
right and I can see the state was
Michelle I can go and like dig into the
request see the user agent hold on the
user agent is Mozilla that doesn't make
any sense it's chrome it's Chrome's
lying why does it do that
maybe all same was it yeah so yeah if
you you if you deal with browsers you
know about this stuff right so I mean
that's pretty cool right
that's I mean it's fantastic but
typically if this is a really hard to
reproduce bug right your workflow isn't
gonna be like I'm gonna kick up my legs
and wait until somebody actually
triggers a spot right yeah if it's over
like a bunch of machines and it doesn't
happen all the time yeah yeah who knows
how long you'll wait exactly so what I'm
gonna do here is so another thing to
know is that these snapshots for the
code they're called snapshots once
they're collected they we certainly
don't want to capture all the snapshots
right when that code gets triggered so
what we do is we pretty much invalidate
it once we've got one sample I think
we're working on sort of being able to
specify how many samples you want to
collect but for now it's just one so
once once that's been collected you have
to reset it if you want to get another
one right so let's reset it and then
what I'm gonna do is I'm gonna stop and
go back to work so here if you look over
here let me zoom in right it's asking
you if you want to continue listening so
I guess we do really we want to notified
when this happens right so we can
continue back out and now I'm gonna go
back to work I'm gonna do some feature
development right let's make this more
polite hello mister or missus and you're
using verbose right I'm like maybe I
spent a week like just changing it's
just working on features moving on with
my life right because I can't reproduce
this thing and apparently it's not being
hit in production anymore and now right
this dreaded bug happens again look at
this and we'd get notified about this
this bug happening in our natural
workflow and we can say I want to
continue and look at this we've we've
detected that the version of the source
that you're on is not the version of the
sources in production right now and we
will automatically stash your changes
and and match what's in production out
here you see like my changes are gone
right if I go here I can see what was
captured another really neat thing that
you can do is like do this here trackpad
there we go conditional breakpoints
actually work so if you want you could
say like quest that gets session maybe
you have something someone your logs
which session is related to you can
filter out all the requests coming in
even if you don't have any code that
does that and only capture the snapshots
related to one specific session idea
there's actually also permission
permission control or access and
management control so you can actually
if you want to restrict who has the
ability to do this right because
obviously if you're if you're peeking in
a state like this there's a lot of
possibly sensitive information right so
you can limit access to who can actually
do that was a requirement for us to use
this in production and ok
actually the so uh the the logging my
old logging tirade of the problems is
there something something related to
this we can that helps out yeah so let
me just so I'm gonna stop listening and
now it tells me hey you're done I can
understand jizz and we're back to where
we were before and now let's go to
logging um this is kind of a similar use
case really right yep what do you think
it was like a good scenario for this
over just over just putting just putting
straight up as Dennis maybe you just
want to collect stats yeah possibly
maybe if you can
madhawk statistics collection also if
you're feeding your logs into bigquery
right yeah so what Google has another
product called dynamic logging which is
basically like you should have put a
logging statement in your app but you
forgot but it's because you know you
found this property issue maybe it's a
bug maybe it's some sad that you need to
collect right but you don't have the
logging statement you need well you can
actually create a dynamic logging
statement first let me bring you over to
our logs viewer right so this is this is
our actual app I've got the old logs so
if you go over here this is the latest
run right and I think that so it's debug
right there you go so we've got this
beta command which lets you specify a
file in line right and actually add a
logging statement into your running app
and when you when you do that I mean
I'll do that it looks like authority
maybe change the so you it's done right
you can actually use you know I think
it's odd you know probably you know oh
gee I'll pass to get to data of State in
your running app and when you do that
and you hit your endpoint back the logs
viewer yeah there you go it actually
updates all of your instances to print
out this logging statement and it was
it's showing both little times because
we've set this log point of time so
that's that's a cool feature that will
add to the IDE doesn't exist yet would
be the Ovilla overlay dynamic logs for a
given session lock points on to your
source code right so right now if you
look in your IDE it doesn't you can't
see where they are but we do have enough
information to actually do that
correlation yeah that's what I was going
to say so this is sort of these are
features that we've had internally for a
long time
really our ambition is to integrate that
into your workflow in your IDE so
everything we're doing with trace so we
have a tracing suite of profiling with
logging and one I like that should be
with your code okay I think that's it
for the demo cool thanks Patrick let me
just over here oh wait I did forget one
thing that you don't I'll just mention
it I'm just saying all right when you if
you do ever play with this
if you create a kubernetes cluster and
like scale it up to like ten nodes or
something like that please don't forget
to delete it when you're done because
you're paying for those cores and that
can kind of add up well expect
especially if you expose an external IP
yeah so what do we just see Patrick
showed us a lot a lot of cool stuff
right so just to summarize kubernetes is
pretty powerful and container and it's
pretty quick so it wasn't too hard to
you know looking back at that picture of
that datacenter to say like hey I just
want to spin up a you know a cluster of
multiple VMs really and then I want to
take a package of software and you know
go run it you go distribute it and then
I'm gonna put that behind a single IP
address I think ray was saying you can
do it two thousand notes right now yeah
yeah so it's a pretty powerful system
when you think of how how easy that was
to really do it and yeah going back to
that was a standard spring boot
application right and there was nothing
special about it there's no special
libraries it just worked and it was
working on Google container engine but
and I'm not loggin worked as well yeah
exactly but you could have actually been
running that that was really running on
crew Burt it could have been running
anywhere honestly you've been running on
AWS you could be running it on premise
there was there was nothing special
about that needing to run on Google
container engine and you know with just
a bit of you know configuration which
which Patrick showed you with the
debugger age and everything you you
could debug right you're able to debug
without without stopping without
stopping threads and you know the
interesting thing about this is you can
actually use this on like again like
this is not even specific to Google I
clearly have to go
like it's Google service that's the
cloud debugger service but the workload
can run anywhere can run even you could
have even done that locally right if you
wanted to now so if you were beating a
dead horse for them yeah we are yeah and
yeah but like clearly as integrated
strain of the ID IDE and we're actually
doing and we're actually building this
into eclipse as well we recently
released the cloud tools for Eclipse 4
which has app engine support and we're
working to bring in the cloud debugger
that is one thing that I did forget I
was going to show you that we like we
have a good hub site for the intelligent
plug-in if you want to install it we're
in the JetBrains repository right and we
offer more than just cloud debugger it's
gonna be sort of everything that we we
have to offer for now it's cloud source
repository integration so you can check
out and import sources into Google Cloud
suite both we provide repos but with
your projects for free and App Engine
deployment right App Engine project
generation we're kind of actually in the
process of transitioning the JetBrains
provided App Engine tolling over to our
plugin some of you guys might have
installed it in Lotus already and yeah
now we're doing this in four clips um
just one thing want to mention here
about Google cloud platform
infrastructure we're we're adding more
basically points of presence right into
it to I think I think ones coming in
Finland ones coming in Frankfurt there's
some new ones I gotta add in Tokyo and
Singapore so what this means for you
honestly is like if you're running you
know you know basically this is this is
just a faster way to get on Google's
network if you're running workloads
there so this is just this is good stuff
and you know just closing you're like
we're to find us here's the Google Group
if you have any questions just slack
channel here's all our github repos
there everything's open source so please
take a look and we'll leave that up here
if anyone wants to like take a picture
of something and she's gonna say one of
the big reasons we came is because we
really want to get to know the users you
know okay we've been kind of working
internally for a long time but we
haven't spent as much time as we should
talking to our external users so if
you're interested if you want to
contribute
to hear from you our github repos our
slack channel groups are all good farms
for course just email me directly
cool thanks a lot open for questions
sure
okay so the question was what is the
performance hit on debugging especially
if you have high traffic Patrick you
want to feel this negligible is what I'm
told and I believe it because we use it
internally for high traffic websites so
yeah they it's pretty mature it's been
used for a firkin sort of amount of time
now internally what what it does is like
you saw for instance that you have
conditional breakpoints which means you
can do some code execution right
the agent is pretty smart uses
heuristics and things to make sure that
anything that you do executes doesn't
take too long if it does it'll actually
not work it'll basically come back to
you and say that it's not going to use
this snapshot any other questions
looking it's hard to see all of you here
in the theater sure yeah the question
was can you do method breakpoints no not
yet
right yet I don't think I could be wrong
but the last I checked it was impossible
so you can't do exception breakpoints
either and and you know worth mentioning
it also works for for Python and is it
just Python in Java
no I think I think it also works for go
yeah that's right go as well so you can
run go and I believe it also works for a
node yeah so they just put up our
communication details if you want to get
in touch with us and that's it thanks
everybody thanks for your time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>