<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Robots for the Kids in All of Us by Nikhil Nanivadekar | Coder Coacher - Coaching Coders</title><meta content="Robots for the Kids in All of Us by Nikhil Nanivadekar - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Robots for the Kids in All of Us by Nikhil Nanivadekar</b></h2><h5 class="post__date">2017-04-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nlRhL892hXw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you everyone for coming for a
session I'm Nicole and his luck will be
introducing ourselves and playing with
robots as well as figuring out you know
what we did to solve a simple yet
complex problem of pot finding by my
introduction I'm Nick alone on America I
work at Goldman Sachs in Salt Lake City
I'm a vice president there i joined
goldman in 2012 my academic background
is I'm a robotics engineer have a
master's in mechanical engineering from
University of Utah and I build robots as
a passion and one of my mentors is
sitting out in the audience who actually
helped me build my first robot after
joining Goldman and we look at the Java
one a couple of years ago when it was a
big hit and from there na nan onwards
though the whole aspect of presenting a
talk about robots started I'll let Luke
introduced himself and he'll take it
over sure so my name is Luke torjussen
i'm vice president goldman sachs i'm
based in New York office my background
was computer science not actually touch
robots until very recently when Nikhil
asked me to join him on this talk so
pretty excited to show how much I be
able to learn in a short space of time
as well so we've got a quick video we're
going to show you we're then going to
talk through using Java as well as ev3
program app so ev3 is one of the types
of brick you can get on those lego
mindstorms that so you can see at the
front there the heels i'm going to talk
through Dykstra and the a-star algorithm
as well and then how he ended up
implementing that on one of those lego
mindstorms where you actually got some
hardware constraints or some resource
constraints there and then we actually
have an interactive demo we can talk
about the compact profiles at the end
but i think the interactive demo is a
bit more fun so let's just jump across
to this quick video this is a video from
this is actually from a Clips con last
year so last year eclipse conned
in Reston Virginia we had these robots
doing it's not moving on the screen
there we go okay so this robot is
actually solving the classic towers of
Hanoi problem if you if you will
remember that problem you have three
ideally have three sticks when three
rings of different sizes you need to
move the three rings from the far right
right in this case the bottom of the
swing up to the ring on the other end
but you can never put a bigger ring on
top of a smaller one so the way that
this robot is actually working is it has
the pulley which is just a piece of
thread which is moving up and down an
electromagnet so we're actually engaging
the magnet and disengaging the magnet
when we want to release those rings so
actually worked quite nicely on the
carpet you sometimes have some traction
problems but this one worked quite
nicely I can leave you to watch another
minute of it or we can just get on so
let's jump back into the slides here oh
it actually keeps playing does it okay
ok
okay so that was our quick quick video
show you what what you can do I'm also
going to do another quick demo for you
after you live coding it it's only about
15 lines of code actually did this for
the very first time yesterday actually
on Sunday we were at their box for kids
and actually had the kids building an
elevator which is pretty pretty fun
hopefully you enjoy as much as the kids
did quickly talking through the ev3 app
though so ev3 as I mentioned is the
brick it comes with a programmer app so
you can click and drag some components
which is great if you're not a
programmer especially for the kids going
to get moving the robots around it has
ability to plug in various sensors as
well as you know different movements
pick up drop something as soon as you
want to start dealing with state or
trying to predict where you might need
to go based on some complex algorithm
this starts to fall down so although
it's great for kids getting started do
you want you any more advanced you
really need to jump into the code so
what you can do is there is a java build
call a house and so what this really
does is it's as collection of libraries
you deploy on there with a arm JVM
runtime onto the brick and allows you to
control the motor the sensors and
everything else but your code looks like
javi just have another library you're
making use of also one thing to point
out is that that better motor control
this is in the ev3 app you can kind of
jump forward tange important but you
can't do that inching forward just a
little bit further to make sure I reach
my object which you can get that very
very fine-tuned controller using lay
house so I kind of mentioned this the
first half of this slide but once you've
built your Java app what you need to do
is you need to get obviously your
produced application onto the brick so
what you do for that is you tower you
Jared up you SSH and copy the jar into a
standard location and then you can
actually control it from the elf
screen on there luckily Eclipse IDE has
a plug-in so you click one button it
does all the magic for you so that's
what we will make use of today so before
we do that Aang actually going to just
jump in and do some live coding so we
can see the elevator on this table in
front of us it is connected here there's
a small man sitting and sitting or lying
down in the elevator he fell over all
we're going to do is make the motor
that's attached go up and go back down
on the push of a button so as an
elevator works it just it only has two
levels so what we're going to do then
the first thing we need to do is we need
to get hold of the motor conveniently
there is a function called motor sorry a
classical motor with a constant called a
and I'm going to assign oh my goodness I
got a sign if I stand here in code oh
yes I can see much better now pulley
motor so here's my pulley motor I'm then
going to say I'm going to do this in a
loop because I might want to make it go
up and down the number of times and just
I'm going to just set up a quick loop
I'm going to ask for the press of a
button how to do that all there's a
button class and there is wait for any
event which returns back an int and that
int is the ID of the button that's
pressed so but impressed and I say if
button pressed is button and then
there's a number of constant so you have
up down left right etc so and say if
it's up an ID on the button here it up
i'm going to say Who I am mr.
parenthesis of the end zone
so that's here i'm going to say pulley
motor got rotate and after doing some
calibration it's about two and a half
turns so it's 900 degrees to turn it I
will do LF button pressed equals button
down
pulley motor rotate minus nine hundred
and then just because I'd like to be
able to stop the program at some point
I'm going to add one last one last thing
here to just say a break so if i push
any other button break okay so you can
see it's a pretty trivial amount of code
and if I hit as I if I right click just
as you would in any other IntelliJ sorry
eclipse project there's a instead run as
a job application there's one I cv3
program so I'm going to hit that well
that's now going to do is going to start
jarring up and deploying it so on the
screen here you can't see from that may
be the photographer here can see it
saying wait a second and now it's ready
so obviously the elevator is at the
bottom right now if i push up up goes
the elevator and if i push down no it's
tough to what do they do oh just do them
else if yes don't explain it do you get
the idea so buggy code is the cause of
the issue here not the not the robot
itself pre rehearsed yeah I'll say if I
hit the enter button break and I'll go
again run it
okay so it's going to do the deploy
again
okay so down we go up we go and then we
go again make sense and if I hit the
middle button which is enter it now goes
back to the default LCD screen there so
that's very simple quick live demo of
how you can code up the Lego Mindstorms
obviously the elevator is quite a simple
problem nikhil is now going to talk
through something slightly more complex
he's going to talk about pathfinding i
don't have to speak in my first book
thanks look one of the things which i
wanted to quickly mention about the
elevators is on sunday while devoxx for
kids was going the kids actually built
tell you it isn't programmed they wrote
a similar program we made it slightly
easier because they were kids but they
did do something similar so it's
interesting to see that hey you don't
need to be an adult to play with robots
you ok you can be a kid or you can be
another this like age no bar kind of
thing alright so going back in the more
complicated stuff like that was very
straightforward but being a robotics
engineer one of the things which they
taught me was motion motion planning or
pathfinding and one of the foundations
of motion planning is d Dijkstra
algorithm and to quickly give you a
brief of about what exactly Dijkstra's
algorithm is is it's it's the least cost
path its algorithm which will give you
the least cost path what that means is
consider that you want to find path from
point A to point B and this is a nice
Jeff which is available on Wikipedia and
eat the the thing about Dykstra is its
knowledge based algorithm what that
means is you need to know beforehand how
your entire map looks like how your
entire graph looks like you need to know
beforehand which point connects to which
other point all right you also need to
know beforehand how how much cost you
have to pay to go from one point to the
other point all right now times like
ours is a simple problem
we want to go from point A to point B
and there are like each of the
connections has a cost and Dykstra being
a knowledgebase algorithm what that
means is you can actually now
investigate each and every node which
you do because for you to find what is
the least caught you these costs you
have to actually investigate each and
every node so you can see that from a or
Oh point one you can go to point two
point three point six but it the way
that Jeff works is it keeps on
eliminating as and how it looks at the
node and it keeps on updating the cost
that it is taking for it to go to that
node and at the end of it the minimizing
function is the cost and you get the
final cost all right any questions so
far a star is an extension of the
Dijkstra's algorithm wear Dykstra is the
function of the minimizing function is
the cost a star you want to extend it by
adding a heuristic to it and you want to
use that heuristic to basically direct
the path towards the target okay and it
and the heuristic can be anything it can
be distance it can be time like the way
I like to explain it to anyone has
consider Google Maps or any other gps
for that matter like you you get
generally three options one is the
shortest part 1 is the ecological path 1
is the fastest part now depending on
which path you want to choose like if
you want to go fastest then time becomes
a heuristic because you want to minimize
the time here we are talking all about
minimization all right if it is shortest
then you don't care about the time you
get about the distance if it is
ecological then generally it is about
hey how many traffic lights are there
how long will your speed be constant is
it going to be like a high-speed freeway
or it's going to be like you know five
miles per hour or something like that so
the heuristic depend and finding the
heuristic is art more than a science and
just to quickly explain what the cost
functions means if you see Dykstra your
function is C of n where n is the north
to visit and see a see you want to
minimize FN
similarly a star is FN of CN plus hn
where h is the heuristic but any
questions so far so now going back to
why we're here here to explain how we
got these tiny Lego Mindstorms to
actually solve a simple problem for
human but more complex for a machine of
solving a maze and I mean when we were
kids we used to solve amis as one of the
exercises to go from the start to go to
the end and but when you are dealing
with a system like robots it becomes
slightly more difficult because you have
to program you're the brains of that
robot right what humans get
instinctively the robots don't
necessarily get okay now going back to
Dykstra though again it's a knowledge
based algorithm so you need to have the
whole graph in memory the second thing
is you need to have the weight or the
cost that it takes to go from point 1 to
point 2 and this is an arbitrary like
this was for experimental purposes so
the cost that i have taken is in order
to go in the x-direction takes 1 1 unit
or one cost you have to pay to traverse
one point if you are traveling in the y
direction and again it's absolute
distance we don't want to you know work
with the negatives and all those things
and whenever you are moving in y
direction it's twice the absolute
distance right and the maze that we were
trying to solve this so the star is a
stock the checkered flag is the end
point and as you can see there are two
options one is you can go to the right
or you can go to the left and depending
on which one is cheaper the algorithm
will find it so the few things which to
note about the graph is we it was
easiest to actually get the RGB date out
in order to process the whole graph
instead of getting the whole adjacency
matrix we use red color as traversable
and blue color as obstacle and the
reason why these colors were chosen as
it just looks better in the presentation
because
having a full whoa in the whole slide of
dark blue color it's slightly daunting
to the ice we use that data to form an
adjacency matrix of x and y coordinates
what that means is well does anybody
know what an adjacency matrix is so what
an ad agency yeah pretty much yep
exactly so but in a matrix you actually
end up so consider that if you if you
load up the whole graph it will end up
showing that point one can connect to 0
point two three and four for example all
right then point2 can connect to point
one three and six all right but and
that's pretty much is called as
adjacency matrix we use the adjacency
matrix and the color data to get the
nodes okay and what that means is we'll
see in the next slide so before we do
anything we got to store it on the
memory and we use a mutable object int
map for it that's a different map than a
jdk map so like Luke mentioned before
leave us is another Java Runtime so you
can load up your third-party libraries
and eclipse collections which was
migrated to the eclipse foundation
couple of years ago it actually has
primitive collections so a knob and
object in map has the key to be the
object which is our point and int is the
primitive int instead of an integer that
ends up saving quite a lot of memory and
what we do is we keep on creating this
whole map of cross like the whole the
whole means that you saw now that gets
loaded up in a map as ok oh point 0 0
has a color of one ok we're
one is blue and red is 256 and if the
color and if the color next to it is red
then you can traverse in it and if the
color next to it is blue it's an
obstacle and you never have again the
rule of Dijkstra's you have to
investigate each and every node so you
will have to investigate the obstacle as
well so that's why in this you will see
that you always in the first checking if
you are inbred or you're into because if
you are in blue you need not investigate
you can never go through obstacles right
so that's the whole idea and from there
on we end up getting the list of
successors what that means is we find in
negative x negative Y in the negative x
negative Y positive x and positive y
direction is it reversible if it's
reversible we added to a set of of
successors which will end up
investigating in the next step I want to
take a pause he or does anybody have any
questions okay so the question for the
video I'll just repeat the question the
question was what are the constraints in
terms of memory so the ev3 brick has 64
mb of ram and when I load up the JVM
that takes up about 12 mb and this whole
graph is comprised of 14,000 plus points
and constructing the adjacency matrix
and all of those things I also the third
party libraries etc etc I am left with
roundabout to megs of memory which I can
use as a buffer any other questions let
me kill maybe you could talk about what
happens when you run it with the JD hey
collections versus eclipse collection
yeah are you going to come up like you
and then for Dykstra you want to
minimize the cost that it takes so for
you to minimize anything you first need
to know something great and you end up
finding out the cost by a simple
function and the whole idea is its X
cost plus y cost but the next step
is so this this step is where you
actually want to prioritize which nodes
you want to visit first because once you
have gotten the cost you actually want
to know should I be investigating this
first or is there another path which I
can investigate first and find out all
right and we you end up since i was
using eclipse collections you can
actually end up using the eclipse
collections api which has a min by on it
so you can find for the the cost because
if you if you do over text cos map get
you get the cost to visit that vertex
and you can find the minimum that it's
going to take to visit any vertex by
just calling them in back i think we can
skip this oh do you wanna go back yeah
sorry so the vertex like at the end of
it you end up getting a big map with
because that it takes to visit each
vertex from the vertex where it was
before and this is going to be the most
important map well that that the whole
software that the whole program
construct and why is it important
because when you're starting at Point E
and then you're going to point B alright
that time when you're trying to visit
each and every one of the points in
between you have to make sure to find
out what where did I come from okay and
in order to get to where did I come from
you always need to come from the point
where it was the least to get there okay
sorry that was a bit convoluted I
understand but it becomes an interesting
problem to figure out where okay if you
have three points or let's say let's
assume you have four points you have
when you're going from point 1 to point
to it cause one unit if you are going
from point 1 2.3 it cost two units and
if you are going from point 1 to point
for let's say it costs three unit right
now you know and later on in the whole
graph everything ends up you know
mapping and all of these three points
actually
to the ending point which is pointy
right right now your least cost path is
going to be 0 point 1 to point 2 to be
okay assuming that from those points to
the end point is the same cause but you
need to know that that's the least cost
that node node 2 was the note from which
you have to travel and for that you have
to create a back point amount I I call
it a back point of map because that map
tells you from where you have arrived
and where you need to go to okay and we
end up using that to actually find out
the whole path again I'm I'm giving
another shout-out to eclipse collections
because we are using the Eclipse
collection stack where it is last in
first out now instead of first in first
out like it is for the JDK stack and
this this behavior becomes important
because now what you can actually do is
you start at the you start at the start
of your you started the stopping point
of view means and then you keep on
seeing okay where do I need to be where
do I need to be where do I need to be if
I was using a jdk stack but or a list
but now it's easier to always go from
the end how many of us have always
solved them is at least I used to solve
the maze by going from the end to the
start because that's quicker to solve so
now that you have solved everything you
and you know what is your end point you
can pick up your end point and you can
see okay in order for me to get to the
end point I need to go to n minus 1 n
minus 2 and in the previous slide we
already constructed the back point to
map and with this stack implementation
that Eclipse collections are you will
end up putting all of them on a stack
and now you have this nice list or now
you have a nice stack of actually
vertices which will help you travel from
the starting point to the end point yeah
no it cannot yeah so well I'm going to
repeat the question how does it
translate to the physical world does the
robot first explore the me or the maze
is already loaded on the robot so dykes
Dykstra x-ray the knowledge base
algorithm what that means the whole
means has to be loaded on the robot
first if it has to explore the means and
then figure out the path then we are
working with on a different type of
algorithm like a slam algorithm where as
and how it is traveling it goes on
figuring out he can i travel here can i
not travel and at that time that's
basically you'll first go to an
investigative run and then you'll figure
out what was the least cut costs versus
a knowledge base algorithm means you
already have all the information
beforehand okay so this is the path that
it generates as i had mentioned before
it has two options going to the right or
going to the left it chooses to go to
write because it's cheaper and i wanted
previously i mentioned a star so i
wanted to show a star as well and you
can see it's the exact same path okay
but if you look at the heuristic up
there the heuristic is X of n point
minus X of point2 again consider the
heuristic is an art so I just wanted to
put put these slides out to show how a
small change of a heuristic actually can
change the path because in the next
slide you'll see that instead of Y
point2 i actually have X point2 and that
causes the whole shift because if you
will see what I'm saying is I'm trying
to minimize my heuristic as well right
so out here it's trying to favor going
more in the y direction and in the X
direction again at the end of the day it
has to travel that much but it just
depends which side it will favor more ok
any questions okay next one so going to
the last part of the presentation and
then we'll move off to demos and if you
want to chat we can chat after
session so the whole path was comprised
of 226 nodes and again those modes are
considered like consider them to be
respectful so basically there were two
twenty six pixels through which the
robot had to move now when you're trying
to move through to 26 notes you are
going to stop to 25 times right because
you go there then you figure out oh I
need to go to point the next point I
need to go to the next point I need to
go to the next point so you need to make
sure that it how will you achieve this
motion without pausing to 25 types we
just flatten the path and when I say
flat and what I mean is you try to have
again going back to the concept of
Dykstra being a knowledge based
algorithm once you have the whole graph
in memory you can get the path in memory
now what now that you have the path in
memory you can actually keep on seeing
if the next point is traversable or not
and not only that you can also see if
the next point is in the same heading or
not and when I say in the same heading
what that means is if if it needs to
keep on going straight it needn't stop
that it actually need not even travel
till there okay if it needs to turn left
then it can just go there and to the
left so for that we don't only look at
the next point but we look at the next
to the next point all right and what
that means is hey if Matt if let's say i
am going from point a to b to c if a and
B are in the same herring and b and c
are in the same heading you can just go
for me to see if you are going from A to
B to C but see is a different heading I
need to know while i'm at a that hey i
have to go to be stopped and then turn
that make sense yeah
so the question was why do I only check
three points in advance why not all the
points in advance I do check all the
points in advance I mentioned 3 because
3 are the minimum that you need to check
maximum so if the third point is also in
the same heading just keep on pushing it
on the stack ok I'm going to escape
performance but go directly to the
interactive demo we we have demos on for
the robots where you can actually
control them why Twitter and Luke will
and Luke will explain while I pull up to
the program and started up so what we
have here are through these mindstorms
set up as shooters so as you can see in
here they have a small rack of small
small ball that they're going to shoot
we've got a bowl in the middle list
because we couldn't find a gong and what
we're going to ask you guys to do is
tweet with these hashtags Nikhil is
going to spin up a small application on
his laptop it's going to pull the
Twitter API s every 15 seconds for
tweets with these hashtags and the
directions so this is nikhil just doing
a quick test it missed the gunk yeah so
as you can see that was a query quick
test run but you also start tweeting and
we'll see what I see what chaos ensues
so the way it's going to work is if a
few of you tweet forwards and a few of
you tweet backwards it might just move
forward and backwards it's going to
choose the top occurrences of the
instructions it received so if everybody
asks it to sound the gong it will sound
the gong
if everybody asks it to move left it
will move left so I'm also going to
start tweeting there so I think one of
them is labeled Nikhil ev3 in one of
those enables Luke ev3 if you can just
your target and of course please tag
their box us in there as well if you
were really creative with our names so
the interesting thing about actually
using the Twitter API is like and again
we did that at javaone as well and it
was it's slightly a different problem to
solve because let's say you have like
five people tweeting five different
things it's going to be chaotic and you
don't know how the robots are going to
behave and you cannot see fun like
making it do stuff over and over again
look at jumeirah aim at you now yes
please refrain from aiming the the
shooters at the audience please
audiences control yes
I want to keep on making its own right
bullet I can I can I think this one's
look out look out done there we go again
to action huh yes it does keep
didn't see you guys see them tweet
nothing happened
terrific tells you toward the center
suite we are trying to him say they've
been through
obviously we can give you there's Mike
back on Thea of human leave you to keep
playing with that if you wish but I
think we're also free to answer any
questions you might have about it's all
and thank you for coming so the question
was about memory utilization a gentleman
out here had an issue along back when
they were using Lee hose that the memory
wasn't cleared so I did observe that so
my very first implementation used JDK
and normal hash maps has set all the GCF
collections which are available what
used to happen is the whole algorithm
will be solved and after that the robot
would just die because the memory was
not getting garbage collector like sorry
the objects were not getting gob is
collected but when the reason why I
moved to eclipse collections was I ended
up having that that to megs of memory
buffer I think it was sufficient enough
for the program to keep on running over
and over again and if you see in the
implementation I'll end up pushing it to
github if you see in the implementation
I'm actually not creating new objects i
keep on reusing the exact same objects
so with that sort of implementation
since the memory the references should
get reused and I'm not creating oh
someone really hits a rope they're
making them fall or and over again ok
but so I to go back to the to go back to
the answer that I went through about
fifteen iterations so that I can keep on
solving the Dijkstra's algorithm at
least five times without having to
restart the robot and with jdk it would
do one or a couple of times and then
after that it would just freeze so it
was a broken GC I I think that problem
still exists which you mentioned yes
yeah so I try to get the Raspberry Pi
working such that and I was talking to
Steve chin who according to me is a
Raspberry Pi exploit where instead of me
spinning up a server on my laptop it
could spin it up on a pie and then I
need not have all the all the cables
dangling around to my laptop but I was
unsuccessful or not and I will keep on
working at it more and i'll be speaking
on the same topic at kids greeting them
developer summit hopefully by then i
should have it working any other
questions because this this was the end
of the talk i'm happy to talk about
robots for rest of the day you should
stay behind am i sorry old habit the the
question was how how does it connect
with my working me working at goldman
sachs so if you look at any problem it's
not not that different than any problem
that we solve a Coleman we end up
writing code which which which satisfies
our business business requirements and
the code is complicated all right and
the again going back to
I Eclipse collections was even made
because before ecliptic elections was
migrated to the Eclipse Foundation it
was gorgeous collections which got open
source in 2012 and before that it was
called caramel internally and the
development actually started from 2004
and along with that we open sourced
another framework last last year it is
called as real adamo it's our own domain
specific language where it's at an ORM I
won't say it's a DSL it's an over m and
it's different than JP or is different
and hibernate now both of these
frameworks came into existence because
our we had that business need we needed
to make like for Eclipse collections to
be born we were dealing with 100 gb jvms
back in 2004 and the creator of Eclipse
collections is actually in the audience
so you guys can talk to him afterwards
as well as we are giving a talk tomorrow
on collections compare where we are
going to compare different collection
frameworks and there you will see how we
end up using the memory constraints like
how we are playing with the boundaries
of the existing ecosystem going back to
how does it you know conform with the
work at Goldman Sachs it it was a
problem which we with which I found
while I was you know playing around and
there was a creative way to solve it and
I solved it that's what exactly we do at
Goldman Sachs but instead of solving it
on a 64mb JVM we solve it at a at a
higher memory JVM and the problem out
here was downscaling out there you're
you're writing the spoke code for
business applications and up there you
will be you know upscaling so does that
answer your question ok any other
questions all right thank you very much
for spending this morning with us and I
hope you did a good job please rate our
talk and have a good day box us</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>