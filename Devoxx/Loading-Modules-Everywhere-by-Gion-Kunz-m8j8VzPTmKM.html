<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Loading Modules Everywhere! by Gion Kunz | Coder Coacher - Coaching Coders</title><meta content="Loading Modules Everywhere! by Gion Kunz - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Loading Modules Everywhere! by Gion Kunz</b></h2><h5 class="post__date">2017-03-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/m8j8VzPTmKM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everybody to my talk this talk
is about loading modules everywhere it's
the topic and why I think system Jas is
the way to go today so my name is John
Kuntz I'm a front-end developer working
for or even we are a startup company
started two years ago and some of our
business is developing front end for
medium to large enterprises and we kind
of help them to ramp up on modern front
entrance and tools so what is all this
module hype all about right so we know
modules for quite some time but what is
this really all about in JavaScript wise
what do our modules so I think we need
to go back in history a little bit in
code structure in history when we were
writing our front-end application and
JavaScript so let's say we go back
10,000 BC and this is probably how we
were writing JavaScript applications
back then right the one huge file all
our functions and variables inside of
this file the whole state in one file
and our application was not really
structured very well we had reissues
maintaining our applications so it's
probably a bad idea right to write Java
skirt like this so this rage face
expresses that was a very bad idea if we
go further in time maybe 5,000 BC it
looked like this Amy so we thought yeah
we need to structure our JavaScript
right so let's create individual files
for each individual piece in our
application and then we are loading all
these files in the browser seems to be a
good idea but however it's not really
right because we are having a huge
connection overhead like this and it is
really not performing
then we also have the order of inclusion
which is kind of dictating the
dependencies and all this which is not
really a good idea so rageful its face
for this approach as well okay so now we
moved quite a bit on let's say the
medieval of module loading or more
structuring our applications and we came
up with these kind of approaches right
so we're creating namespaces in
JavaScript on the window object and then
we fragment these names namespaces so we
have sub namespaces and we're adding our
modules to these namespaces on the go
and then we can have individual files
that are responsible for one single
namespace and then in the end we are
just concatenating all these files
together and we have a nice structured
application but in the browser we just
have one javascript files which was
actually the start of something that I
don't need to put a rage face on here
right now right so this is quite a good
approach already and then moving on
let's say 2000ad we even invented soft
like this so this is the revealing
module pattern so that we can even have
information hiding inside of JavaScript
modules using closures using function
close closures so you have a kind of a
private area in our module and then we
have a public interface to that module
so this is already nice structuring but
let's move on and now we are in the
present so their current the previous
approaches there were something like
modules there were a little bit module
like but they're not we're not real
modules so what do we have today today
we have real modules right and this is
really amazing so now we have real
modules and I'm going to show you some
of them now but first let's just quickly
check how can we use modules to
structure our JavaScript applications
so this is a simple example of a es
module of an acumen script module so
it's the es6 standard for defining a
module format and here we are have just
two modules module a and a module be in
module BB we do a named export we export
a function called to stuff and then in
module a B import this function do stuff
we do a named import and then we are
executing the function and like this we
can really structure our whole
JavaScript application really nicely so
there are few anti-patterns i would like
to i would like to talk about so how
many of you are java developers here mmm
ad okay seventy seventy eighty percent
okay so i really think there are a lot
of anti-patterns in java really because
Java I like Chavo I have a job or
background as well but Java is really
you only have classes right you have
nothing else than classes so you don't
have a structural tool to bundle some
functions or some variables into another
container than a class so you need to
use classes to create something like
this like a utility class that contains
static methods right but actually it's a
complete anti-pattern why would I use a
container that is there for inheritance
to store some static functions right the
functions could exist on their own they
don't need a class so this is just for
structuring because you don't have
anything else in each other I consider
it very bad actually because classes are
there for inheritance if you look at
modules the same code as we saw with the
class is actually represented here as a
module we're just exporting these two
functions because that's the element we
are concerned about in this module
another anti-pattern i think is a
singleton who have you have developed
their own singleton classes everybody
right we've we've all done it but
actually it's really an anti-pattern why
should we use a singleton
she has something like a module because
the module is only instantiated once and
also that it's cached so it is already a
singleton so the same code that you see
here like a counter singleton can easily
be implemented as simple as this we have
a module with the local variable count
and then we export two functions to
increment account and want to read the
count and that's our thing because the
module is only instantiated once okay
let's look at the different module
formats very quickly that we currently
have we have AMD and AMD is probably the
oldest module format it was getting
really popular with requirejs and if you
look at the code it's actually quite
cumbersome to define these modules right
okay it's not that much code but imagine
you have a lot more code than a lot more
modules it's quite some boilerplate and
also you can see that you need to define
the fracture factory function then you
need to return whatever you want to
export in the imports or in the define
dependencies you need to really create
an array with the name of the
dependencies and then you can get these
in let's say injects it into your
factory function so it's quite
cumbersome and this is definitely a
contra point2 to AMD so you have a quite
aware BOS former to define modules also
they can't really handle cyclic
dependencies I mean required traders
came around with it a little bit with
dynamic requires but still the module
format AMD is not really made for
handling cyclic dependencies which is a
bit of a pain definitely a pro is that
it's a kind of a inversion of control
right when you define a new module it's
not executed immediately it's put into a
registry and the registry is then
resolved on when all the dependencies
are results of that module the factory
will be executed so it's kind of an
inversion of control which is really
nice for for a module loader
ok let's look at common J's I think
common shares modules you all know from
noches right so if you have done some
noches development you were using this
syntax of saying require something or
export something right module dot
exports or just exports and then you say
required to to import something so you
can see it's quite a simple formats
right you have these two things require
module exports it's really simple so
that's definitely on the pro side it's a
very simple format however the problem
is with common areas is that it is
designed for synchronous operation right
when you require something it needs to
be there immediately right so there is
even not an inversion of control because
when you say require it will just get
into the other file immediately and then
kind of executing this other file if you
have other requires there it will also
get into these files and execute it on
the go right and whoever is first to low
the module this will be the let's say
the responsible a code that caches or or
puts that other module into the cache
and then going forward it will be also
cashed but this whole flow of
immediately executing this dependency
tree is not really ideal for a lot of
situations and to in order to solve some
some problems so let's look at the loss
of t3 module formats which is esm and
this is the ECMO script 6 module format
I'm definitely most excited about this
module format because it just supports
so many different things and it's really
really clean and it's standardized which
is always great so here we have a named
import we import do something from the
module B and we execute the function
it's really clean there is syntax
support so we don't need to use an API
it's really syntax that we can use we
have t fold exports named exports
bindings right so if we update something
in the module internals the other
modules that depending on it will be
immediately
Italy updated because exports are always
bindings right this is really cool about
es6 it's great for static analysis right
because of the syntax you can easily
analyze it and they now support the
specification now is onboarding this
dynamic imports which was something
missing but now they're getting there
and there is also three shaking so what
the heck is tree shaking I didn't know
so I thought okay I gonna take my dog
and go into the woods because I live
very close to the woods and I did some
tree shaking and really nothing happened
except that my dog was looking at me and
he thought I'm really really crazy human
so my dog is I think he's pretty smart
so I said thought okay let's I gonna
explain to my dog what tree shaking is
really all about so tree shaking is
really simple actually if you think
about it because the es6 module format
is so it so easily statically analyzable
we can easily eliminate all code that is
not used in our runtime so if we look at
this example we have our main module
here importing only a from the const
module so if that is our entire
application we can easily analyze this
code and say that we don't need B and C
right so the final product that goes
into the runtime of the browser doesn't
contain B and C right we can eliminate
any dad code automatically and that's
what tree shaking is all about alright
so now how do we go from module from
these module formats into the browser so
actually there are quite a lot of bond
leurs or loaders for the browser right
so there are two basic approaches one
approaches a bundler which is taking all
the modules and putting them into one
single file which is then being put into
the browser that's
bundler right and then you have loaders
they are loading modules on the goal
asynchronously within the browser right
and in the beginning you could say or
some time back you could say that this
is a bundler this is a loader right but
now they things have changed a little
bit because loaders have recognized that
bundling is a really great thing and
bonzers have recognized that loading is
a really great thing so they came
together a little bit except for some
exceptions like roll up chairs for
example is really only made for creating
bundles that's the only purpose of roll
up Chase it's only for esm so you can
only bundle up es6 modules or ES and
model modules and it's also supporting
three shaking on the other hand we have
a pure loader which is the es module
loader for example and the es module
loader is currently under specification
right so there is a specification that
is now being created for that so it's
always hard to compare these bonzers and
and I get asked a lot should i use
browserify or web pack or what should i
use and it's hard to compare them and
you need to tell all the details about
things so I think it's it for me it's
easiest if I compare it with these
pokemons actually because on the
left-hand side you have required to
switch yeah it's a little bit neglected
now I think because the project is quite
old rides and it was purely built as a
loader than their words are chairs to
optimize and bundle up your application
but the module format support is maybe
not the latest and they're really not
they're not able to keep up with the
latest module trends I would say so it's
a little bit poor guy here a little bit
neglected and web pack is like a big
monster that supports everything right
you started and it's it comes with a def
server so you have a def server you have
web pack and its intention initially was
really to create one single text
also why it's called webpack right with
all your resources and that was the main
idea and then later on you could use
like text extract plugin to get stuff
out of that pack of course chunking was
there from the beginning but still yeah
it's a big for me it's two monolithic I
don't like monolithic tools on the other
hand we have browserify which for my
taste is a little bit too modular and
for all my browserify project my
configuration files were really like
growing like huge because i needed to
load need to use so many different
loaders and plugins and stuff and then
we have system JS and actually i
couldn't find a better image than a
burning unicorn to represent system
chess because you can just do so many
things in such a simplistic way and that
is what i really want to show you today
so coming back we start with the y es
module loader specification so this
specification currently it is worked on
but i think it's there for the last four
or even more years so it's there for a
long time and actually guy bedford who
is one of the people really working on
system choice i mean he's the AC creator
of system chairs and all this this whole
ecosystem he was observing this
specification from the beginning on and
the specification is really all about
this so the ultimate goal is that within
our HTML we can just write a script type
module and then SRC and the URL to a
module and then the browser will be able
to load this file and he knows that this
is es6 modules so we he loaded as a
module that's really the ultimate goal
where we want to get and the cool thing
is that guy bedford as i told you before
he created a polyfill for that right so
he created a polyfill for that
specification the es module loader
specification that you can just load
into your browser like this so he
we are getting it locally we have stored
these two files we load the bubble
transpiler and then we are also loading
the poly fill the es modulo de policy
and after that you can write something
like script type module and the source
and this is really great because now we
can load these modules in the browser
and if you look at the code that we load
here we loading module eight or chess
right so if you go to module a Dolce as
you can see we can use es6 imports right
import message from module B and below
we have multi be where we export a
constant message and this is already
working in the browser like this so
that's really nice and we can also take
a look at browser support today because
that's kind of surprising because h15
has full support for typescript type
module when you enable it in the flags
and even more surprisingly Safari 10-1
has support without even a flag so it's
already integrated in the latest WebKit
right which is really cool in WebKit you
can already do that without the polyfill
say script type module this is just
quite recently I think maybe a month ago
or not even they added this feature to
WebKit which is fantastic so now since
we have a module loader specification
and we also have a polyfill why do we
need system j SN because then we can
load modules already in the browser so
the problem is not the tool itself but
our our environment right because we
have so many different module formats
and if we use the the web at the library
we have am PM Bauer we have github you
have so many locations where all these
packages can be located right and then
maybe this libraries using that module
format and another libraries using a
different module format right and so
this is really the problem so that we
need to be able to handle all these
different cases
so sister Jaya's was created exactly for
this purpose it's building on on top of
the es module loader but it's ads on
some features like at loading different
module types and also supporting
different cases like do they export
default export in the main entry file
and things like this right so this is
really a great a great start because we
are building on the specification but we
are adding more stuff to that so it's a
universal dynamic module loader that
loads es6 modules AMD common shares and
global scripts in the browser and no
chairs that's also very important you
can run system chairs from no chairs or
you can run it in the browser and that's
really a cool thing because in the
browser you can use it to load modules
directly and in noche as you can for
example use it as a build tool because
then you can instead of loading these
modules and passing them into the
browser on time you can bundle them up
into one single file and then distribute
this file right so as this ensures is
universal we have the opportunity to
load it in the browser or to have it in
no chairs which is really really great
all right so let's see how we can load
the common shares es5 module inside of
system chairs so we are adding system
chairs as a dependency here we added
from a CDN directly we load it in the
browser and then down in our body here
we are using systems import to import
our main entry module so this is all
happening in the browser so we say
system dot import module eight and then
let's look at module eight or chase we
have almost the same example as before
about this time with required chairs
right so we say require module bjs get
the message property out there and then
put it into our body and this is really
all it needs so this already runs
perfectly fine we have modules support
in the browser by just using this simple
script which is great I mean imagine all
the tooling work we do today like 50
sent of my time sometimes as the
front-end developer goes into tooling
right while working on a project this is
horrible I mean tools are great but I
don't want to spend fifty percent on
tooling right so using simple tools like
this which are universal makes it really
really great to develop fast so this is
a good use case for this we're using NPM
CDN so this is a CDN that hosts all the
NPM packages that are available really
everything so we could do a little trick
and use system chairs to configure a
pass like we do here we configure vikas
while cart path npm colon and then we
say this should point to NPM CDN where
all the NPM packages are located we
configure also bubble transpiler and
then we import our main dulces modules
so let's look at our main DOJ's module
what we're doing here so now what we can
do is we can directly import the merge
function from the load ash module that
is hosted on NPM CDN directly in our
code right this is easily possible with
six inches because it fetches all these
modules asynchronously be the HTTP
requests we're also fetching chase
markup and then we are merging two
objects in this example using the merge
function from lodash we are formatting
this object into formatted highlighted
jason HTML markup and put it into our
HTML right it's really simple but we
already did quite a lot of stuff with
only a few lines of code which is really
really great all right one more thing
from systems a/s system chance comes
with some kind of extensibility so we
can have so-called loader plugins where
we actually hook into the hooks that are
defined by the es module loader
specification these are these four hopes
that are provided in the loader
specification resolve is responsible to
resolve a module name so if i say
require a or import from a then this a
is getting passed to the
dolls and resolve needs to tell okay a
is probably a dot J s in the current
folder for example so it needs to be
resolved to a day to a URI and then
stretch takes this resolved address and
fetches the content of the file the text
content let's say translate is then
there if you want to translate something
so if you are running a transpiler or a
preprocessor you have the chance to
translate the source file and produce
kind of an output file or content and
then instantiate finally is there to
take that source that was probably
translated and create a JavaScript
object out of it right so it evaluates
the source code and exports or generates
a module object so this is the purpose
of the instantiate hook so if you look
at a simple plug-in we can implement
easily this is a text plugin with this
text plugin we can load text files or
strings text in text in any kind of
files using this text plugin as
javascript modules so here we say import
content from content of HTML ! text is
so system chairs will just recognize the
! and it will assume that text searches
is the plug-in that we want to use the
low the plug-in that we want to use to
load this text file and in the
implementation of text ojs of the loader
plugin we are implementing tool hooks
the first one is the fetch hook so we
are using the fetch API to fetch the
text content of this of this of the
files that is loaded and then in the
translate hook what we need to do we
need to make from this text from this
string we need to make a JavaScript
module from that so what we are doing
here is we say we are constructing a
common shares module default export by
saying module dot exports equals quote
and then we put our string that we have
just loaded from the file content and
then we close the string again so like
this we can
create a simple text loader plugin and
then after that we can load templates or
CSS files directly as modules into
javascript all right there is still more
so this is we have the es6 module loader
polly field and we have system chance
that handles the complexity of modules
of different module formats of this
whole environment we are in currently
with all this diversification and
fragmentation in the in the module
section so sit and chairs can handle all
this however if you are using 20
libraries and you need to maintain all
the configuration in system shares on
your own it's going to be quite a lot of
effort right you need to check each
module eyes it common chase or or esm
does it export default or not what is
the entry module and you need to
configure all this in systems yes so
there is another tool also by guy
bedford called che SPM so it's a
JavaScript package manager and it's a
note tool that allows you it's kind of a
broker between all the packages in the
web as a library if you like and insist
on chairs and what it does it just
downloads these packages and generate
system chairs configuration for all
these packages which is great because
then we don't need to manage it on our
own and we can also download packages
from the internet instead of just
relying on NPM CDN as we saw before for
example so this is a great addition all
right so I think it's time for a little
demo so what I want to show is I felt a
small application actually it's a it's a
video game so i spilt a video game using
typescript because i wanted to really
explore typescript to its kind of
borders and also system chairs and and
JSP em so i think creating games is
always a good use case because yeah it
involves a lot of design patterns and
you need to you know create a lot of
complex patterns to
old stuff to defer stuff and all this
and rendering so it's a really simple
tile-based game where you can actually
collect coins and you also have physics
so I can jump around but also the tiles
support different physics environment so
this is like an eye style right so I can
slide on this ice and there is also like
water so I'm kind of floating here in
this water it's hard to get out
sometimes also here is like a slime
block so I'm really stuck in this slime
this is like sometimes it's also hard to
get out of that when I can collect these
these coins however you know there is
something missing about that it's not
really nice to play yet so I thought
yeah what's going to be the natural next
step for this game so maybe to load
patterns to load graphics right so I
have implemented this using system
shares because I wanted to test if i can
easily load these tile-based graphics
using system chairs so I came up with
this Universal graphics loader plugin
which is using a little utility function
that I've created a load binary data
which is working on node and in the
browser to load an array buffer from a
file URL right so like this you can load
the array buffer of value right URI so
the binary data and now insist on traeh
since its universal we can always check
or we currently in a builder phase right
so is this running on noches and we are
building this whole thing because then
we need to do something different in
this case our our graphics loader is
actually a data URI loader that will
actually in the browser directly use the
address that we are importing so if we
are importing pest dot PNG then this
address will gets into the image source
and we receive this image source from
the module export however when we are
bundling a javascript one bundle we need
to do something else because we cannot
put the PNG directly into this bundle
right
so they're what we are doing is we
create base64 well actually a whole data
URI which contains the base64 and put
this into our bundle right so we kind of
distinguish between the two processes
are we in the browser because then we
can shortcut we can load the files
directly or are we in noches and we are
building with system builder and then we
need to create text which gets into the
JavaScript bundle so that's what we're
doing here and then in the translate
hook which is responsible for creating
the source code for the module we are
creating an image and now we are just
using the data URI text that we are
created in the fetch and put it into the
image source here and this is then
created as a common shares module export
finally we have to instantiate hook and
the instantiate hook is only there in
the browser because the bundle doesn't
need to instantiate it just needs to
create the text representation of the
translated module and this needs to get
into the bundle however instantiation is
part of the browser game right so this
is only browser not builder so here we
can just take the shortcut and say that
our image we are exporting is having the
real address of our import all right so
let's look at our game how this looks
like so now we are loading these tiles
using our data URI loaders or our
universal graphics loaders and it
already looks a lot more like a game
right it has some graphic styles slime
is even animated here and there is the
water and it almost looks complete
however I think there is still one thing
one important thing missing and that is
actually this satisfaction that when you
get a coin right because i think it's
not that it disappears it's more this
audio sound that you get when you walk
over these coins right this is really i
would say more than fifty percent of the
satisfaction playing super mario right
so let's look into that and how we could
do that easily with system chairs so now
for this we are creating a loader that
will return the array buffer of an mp3
right so we're loading an mp3 from
either locally when we are running on no
chairs and building the bundle or we are
loading it directly in the browser right
when we are running in the browser so
here we have a little bit a different
shortcut when we are in the browser here
we are directly putting this binary data
we get from our load binary data
function into a so-called metadata of
the module this is available in system
chairs so we can put the metadata or we
can add information to the metadata and
later on in the in the hook process we
can extract this metadata again so here
we're taking this shortcut for the
Builder part in the translate again we
are putting together a module exports
that is decoding base64 again and in the
if you're not in the Builder we don't
care about the translation because we
can take we're taking the shortcut and
now we are in the instantiate hook again
and here we are only in the browser
again so there we are now just
extracting what we have previously put
into the metadata so the whole binary
data object and get the ray buffer from
there so now let's look how that looks
like or better how that sounds like and
i hope the audio is a little bit ok
because i'm recording it with a
microphone here so now you really have
the satisfaction of collecting coins and
since we've done this with the Web Audio
API it's really cool I don't know if you
can hear it but it sounds like Super
Mario is a little bit in a cave right
now there is some after hall some kind
of this is a convolution effect from the
Web Audio API so I've used this to
create tile-based audio environment so
when you are on a regular tile you have
a case based out of your environment but
now if you jump into the water you're
kind of soaked under and this is all
done with mp3s and impulse responses and
using the Web Audio API so I can get out
again or Mario sometimes is even a DJ so
he's just not sure he should swim or
dive he starts to DJ a little bit with
the equalizer if you like so yeah that's
pretty cool so we've implemented all
this or I've implemented all this with
with the loader plugins and this is
really cool and it shows the flexibility
that we have using these loaders I can
run my application in the browser all
files get loaded individually and then I
can use builder as long as I built my
loaders universally they will transpile
into one bundle and then it works out
really nice do we still have time ok
cool so now actually what I would like
to show you is a small demonstration of
using the JSP em tool just that you see
how this building process works how this
builder builder process works this is
actually pretty pretty simple to use
here we have the whole typescript
project that I was talking about so I i
wanted to do everything on my own also
the physics and and rendering it's not
the most performant one but it's a lot
of fun to do this and it's a good test
drive for any language and things like
this because you're using a lot of edge
cases so now if you look at that project
we have
here our main entry file or first maybe
this configuration file generated by JSP
em so everything you see in here nothing
special is just system chairs
configuration the jspn config file is
system chairs configuration as I said
before JSP m is just the broker that
generates configuration for system
chairs and here you can see all the
mappings that are used for building and
also for running this thing in the
browser so it creates a lot of mappings
this is an NPM this is in github and all
these kind of mappings so our main entry
module here is made of TS and it may not
PS we are actually importing a CSS file
using the CSS important that is also a
let's say a core plugin that was created
by guy Bedford and it's loading the CSSS
text and then it's exporting something
that will add a link element into the
head and encoding the whole CSS in there
right so that we can have CSS embedded
in our HTML directly so maybe this is
not always a good approach but for a
game that I want to have it really
self-contained it's really nice to do it
like this then we import our main engine
and we are adding some basic mark up
here to the HTML body or to the body
element and we start our engine and this
basically starts the whole game so if we
are now moving to the console and we are
using JSP M build we can say that it
should also minify and now we need to
provide the path to the main module to
the entry module right which is SRC main
and now we are letting its build so that
takes a moment it will grab all the
files resolve all everything linking
everything together and then creating
one single file for us and in there is
everything is embedded right the pngs
the mp3's all is embedded in that
javascript so now i am is done so what i
will do now to prove you
the whole game is in here it's quite
large so wet storm is giving me a
warning here I will just copy this code
and I will go to a blank chase pin it
doesn't even have HTML right and I'm
just pasting this into chase pin let's
see what happens take some time it's one
megabyte or anymore ok it's there ah yes
nice our game now runs NJ in NJ a spin
right so we have already had it there
cool so this is really cool that you can
run applications in the browser directly
load everything separately you're
developing quite fast if you change the
file only this file causes a reloader
people you can use life reload or
something like this and then you load
your applications again from individual
resources however if you want to have a
production build at the moment without
hep-2 maybe in the future this is
changing but at the moment it's still a
good idea to bundle as much together as
you can so using system builder is a
really nice thing here and chase p.m.
alright that's almost the end here I use
this time here i have also before we go
into the question to advertise two of
our workshops that we are planning
upcoming in march so on the 17 and 24
i'm going to do two angular workshops
the 17th is a beginner's workshop and
24th is an advanced workshop so if you
are looking for a workshop in zurich
about angular 2 please come to our
workshop it's definitely going to be
great and especially for fox days we
have a discount called Fox and if you
register with this discount code you get
ten percent off from the from the
workshop price alright thanks a lot
questions how do you chase working looks
like Christian dangler chase are there
any struggles or not at all no and there
are no troubles because system chase
works with bubble and typescript
transpiler right so you can easily use
bubble transpiler and then j ethics
translation is another issue and you can
easily use it as a loader for react to
it angularjs they have even I mean
angular 2 they even started to use
system chase as their main transpiler
they have even for the router for
example they have used system chairs to
compile sorry to load different routes
right so they have even a hard-coded
dependency somewhere in the core code I
was working in this area a little bit on
the on the source code on angular and I
saw that there so I think they're really
compatible with systems yes really
nicely yeah i'm also using systems a/s
with with angular 2 a lot actually it's
our preferred loader and bond leur so we
use it in a lot of angular projects yeah
also all their examples on plonker they
use systems a/s to start the application
so yeah yes any other questions
oh I know this guy hey little one do you
know in what direction the younger team
is moving with the Eli yes they do I
really don't know the CLI is a little
bit different project right and I'm not
quite sure where they're where they're
heading to their i have actually no idea
and i would also not recommend to use
system chairs when you use the CLI
actually because the CLI is already
there to provide you a full-blown
solution to develop angular stuff right
so i wouldn't really recommend to use
system chasing combination maybe if you
develop angular an angular application
and you want to build it up your offer
your tooling a little bit modular then
system jess is a really nice candidate
but if you decide to use the CLI to
build up your application it's probably
not the right choice and yeah sorry i
don't know about the strategic direction
there with the CLI sorry i couldn't
answer
alright thank you and have a nice take</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>