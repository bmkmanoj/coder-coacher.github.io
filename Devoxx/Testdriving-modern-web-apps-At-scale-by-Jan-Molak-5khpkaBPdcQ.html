<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Test-driving modern web apps. At scale. by Jan Molak | Coder Coacher - Coaching Coders</title><meta content="Test-driving modern web apps. At scale. by Jan Molak - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Test-driving modern web apps. At scale. by Jan Molak</b></h2><h5 class="post__date">2017-05-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5khpkaBPdcQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">forget it make it do it makes it
hello welcome dear Lord that's a lot of
you cool alright so today we will be
talking about test driving and testing
modern web applications and how we can
do this at scale so can just do me a
quick favor can everyone who can hear me
raise your hand
awesome so now I know two things about
you first of all you can hear me
secondly I can ask you questions
it's perfect alright so automation as we
know robots are slowly taking over we've
even taken over DevOps and devoxx a
conference set up may ask the first
question how many of you have unique or
integration tests on your projects
alright well that's pretty much everyone
brilliant and how many of you have
so-called end-to-end tests alright so
keep your hands up keep your hands up if
you're perfectly happy with how quickly
those tests run how good feedback they
give you and how easily you can act on
this feedback also we've got one person
left lovely
so it turns out that we're automating
pretty much every single aspect of our
software delivery process so we've
automated the deployments we've
automated the infrastructure
provisioning but one thing that we
actually are pretty bad at is testing so
the good news is that well you're not
alone the bad news is is that we're only
together and that we actually majority
but firstly this allowed me to introduce
myself
so my name is yang Malik I'm a
continuous delivery consultant
what it basically means that I work with
companies and teams around the world and
I help them enabled continue to get rid
of their projects what this usually
means is that well it's not only about
scripting Jenkins as many of us and I
think it's actually about addressing
every single aspect of the software
process that makes your software
testable and the playable in the first
place which was recovered TDD BDD and
other practices in this space so as part
of my work I also write some open-source
products so some of you might probably
associate me with your bill moyers being
read perhaps or maybe my recent projects
are in tjs acceptance testing library so
I'll get a little bit more about this
library today as well so let's start
with talking a little bit about the
problem with testing and how we approach
it on on other projects I'm guessing
that now we can we all work on some sort
of agile team I suppose
all right I'm not going to admit that
they work and waterfall team now right
okay so it turns out that the recent
research from captain Eric brought to
light some interesting findings so
despite the continued adoption of agile
methodologies 10 challenges with quality
and testing in agile projects are
increasing as an interesting finding why
is that right we do TDD then what why is
that always happening now another report
from Gartner what they found is that 12
testing cannot keep pace with demand for
faster delivery and why is that well
this is a direct and manual testing and
inability to scale the technology and
process okay so what's testing do they
actually talk about
so what I would like to talk about today
is the acceptance testing aspect of our
software delivery algorithm you are with
with acceptance testing that are the
concept of the process and so on so
basically the reason why we do
acceptance testing is that we want to
make sure that the software you deliver
actually meets the requirements so we
deliver the right thing so while TDD is
brilliant when it comes to building the
thing right the acceptance testing is
actually what helps us build the thing
that addresses a really business problem
and this is often neglected so to look
at this problem involving bit more
detail let's look at how this typically
works on agile team so I guess we all
have some some product owners and some
developers and testers on our teams the
tester assessment so as a product owner
what I mean by Follette almost someone
in a business function my team so I
analyst I product on the and so on
so now the way this typically works is
that the product owner come ask comes up
with a bunch of requirements to address
a business need those are typically
phrased as user stories
now all those user stories in order to
follow the investor principle especially
the T so now being testable they need to
have some sort of acceptance criteria on
them so can you please raise your head
if you actually have acceptance criteria
on your stories all right that's great
that's most of us and are there any more
specific then it should work or that
should have tests okay both sir tonight
is nice so that's that's the first issue
so right what we have is nice is that
now the user story with 30 vague
acceptance criteria get to the documents
print so developer works on those on
those stories they build some somewhere
bottom system we also write and you need
an integration test to make sure that
whatever the internet it is is correct
or as it works the way they want it to
work and then the whole thing lands on
the testers desk where the tester
typically right right automated
acceptance tests to make sure that
whatever the developer build actually
meet the criteria well they also need to
somehow report the findings to the
product owner this usually works now
either by the reef readiness reports in
larger organizations or just an email in
small companies and also raise a bunch
of bug reports as well now in theory
this whole process should happen within
one sprint okay so does this resemble
what you guys typically face on your
products okay does this whole process
ever happen moving one sprint okay so we
got like two nodes in the audience
three sorry alright so what often
happens is that the implement
application runs on testers desk around
45 minutes before the end of the Sprint
and that's when they start the work so
the poor guys are trying to figure out
and somehow reconcile whatever they go
through for the rows required right some
automated tests using a selenium
webdriver whatever and then certainly
bug reports saying that you know
everything is broken just not do it
again and this thing typically happens
in a separate sprint like a testing
sprint do you guys have testing Sprint's
on your team's okay
so now that the trouble here is that if
we test our software after the surface
already built if there is the bulk of
the testing happens one software is
build it usually takes time right so we
have to surf as well we need a software
to be present in the first place so we
can't record drive the software with
this sort of acceptance tests so the
reason why this whole process tends to
be slow and why we tend to have those no
acceptance testing sprints etc in my
opinion is caused by several
misconceptions so first of all
acceptance tests have to be end-to-end
so many teams conflates the concept of
an acceptance test UI test or a customer
sizing test and they all think that this
is all the same thing or those are
actually orthogonal characteristics so
if you think about it the end-to-end
test requires the system to be built in
the first place so I Mia Michaels like
to use the calculator example so for if
you imagine they're all school
calculator right it we could have some
sort of now business-to-business sort of
implementation somewhere inside it if
you have a user interface in a formula
keypad and so on if we not try to test
every single of mathematical operation
using the user interface on a system
that's already built well it's going to
take some time and the problems that we
find will be with the description of
those problems will be a little broad so
let's say we can't add on this
calculator but what part of the target
is broken and this problem is caused by
the second misconceptions that the
acceptance tests have to run through the
GUI because that's what the user would
do have you ever heard this taken before
okay so he's interesting fact the GUI is
not the only interface of your system
so let me introduce you to the journey
planner example that I would like us to
focus on today so a journey planner
is an online system and because you
probably have used before as well that
helps commuters optimize the route from
one point to another so let's say that
we have a user story like that so
finding the fastest route right so as a
commuter I like to know the fastest will
between two stations so that I get to my
destination as quickly as possible so
fairly common user story now let's look
at the implementation of such story and
just a quick disclaimer I'm not
affiliated with a Transport for London I
just happen to be using it everyday so
this journey planner could have some
sort of a web UI right so to implement
this story we would need to implement
some sort of business logic on the
server side I suppose we need to build
some sub user interface to present this
website to a user but there are also
other users of our system
there could be third parties who want to
integrate with our service through a
REST API for instance we might have
mobile apps that provide the same
functionality to the user well obviously
this sort of journey planner should
probably also allow people to buy
tickets well this means that our app now
got some enterprise integration and what
about the notifications right so that's
yet another interface of our system and
we had couple of talks about the Sirian
Alexa so this natural UI another
interface or system so now if we
actually wanted to interpret a to
exercise our system as a user would and
run through every single scenario
through every single interface what
would we not end up with
quite large tests with right and that's
another finding from that Gardener
report that now while we actually want
to deliver faster and more complex
applications that the test matrix grows
many times faster because the number of
delivery charges grow as well
but now you already know one thing but
coupling our acceptance tests to the
implementation on a specific interface
and running them against a folio sample
system makes them slow and fragile quite
often so if we actually try to write
those tests when the system is built and
during the development sprint if we try
to exercise the system so every single
year I through every single edge case
and so on we'll end up with a test suite
that takes a long time then I've
actually heard of situations where I
have to develop deliver process was set
up in a way that you had a development
sprint then the test automation sprint
and then a manual testing sprint where
the manual testers will just rerun the
automated tests until they finally pass
and then yet another UNT sprint and so
on so what this means is that a
developer would only learn about the bug
in their code a couple of weeks after
they've already committed the code to
the repository and well first of all
this affects the feedback right I mean
if someone tells me about the bad guy
community four weeks ago I'll have to
again no dig through the code figure out
what I was supposed to do know how how I
altered and so on and there the whole
analysis process will take a long time
and I'll discuss at the delivery speed
as well because you don't know if the
system is working until you actually go
through all those testing Sprint's so
now what could be a solution this
problem
as many of you have seen this picture
before if you have please raise your
hands let's see that works again all
right so it's about half of you so years
ago my conch in his book succeeding with
agile proposed a concept he called the
test pyramid so what he basically said
is now in essence is that on any
software project that uses test
automation the majority of your tests
should be a unit test you should have
some service tests and the UI tests only
form the minority of the whole whole
testing group now while the concept is
sound in principle there's a couple of
troubles here so first of all unit tests
and urs they serve different purpose
they serve different audience right so
another thing is that this test pyramid
has we then copied by number of
different people different authors and
there's no added some more layers to it
they even came up with some some some
percentages so we can actually run some
stats and it'll code and now find out
your unity should 70% and maybe your
service test should be 20% and device
should be 10 and then take loads of
conversation so you should actually be
no 20 maybe 25 now are you it's not very
six is fine but the whole conversation
is in the point so in my view instead of
focusing on the test pyramid and
focusing on there's no quantitative
metric of know how many tests we should
actually have in our code base perhaps
we should think about what purpose they
serve what they do what do we need them
for why we just know following the cargo
call that you know when we write all
those UI tests do we actually need them
are useful
so but I like to think about it is
presently here at this no ultimately
testing quadrant the today's loads of
models I know as we all know all models
are wrong but I know some of them might
be useful so hopefully this one will be
so the way I like to think about it is
that the automated tests have two types
of audience in general they are either
useful for the development team or they
useful for their for the business now
please note that I'm not calling those
tests now developer tests or business
tests because this cause another problem
if we call some personal business tests
we might come to a conclusion that it's
the business who should write them and
many things have actually seen
situations where developers just now
want to know business arise and said
well that's right right all those tests
engulfing and just on tell us one is
ready that makes some sense right so
that you get a cucumber and gherkin our
collaboration tools and we're not
supposed to force business people to
write those tests for us and it's our
job as developers but those business
tests ludo those the test folder for the
business audience have a very
interesting purpose so first of all they
tell them if the project actually does
what it's supposed to do and if we have
those tests if the quality of feedback
is right and they get this feedback
promptly then one thing we can avoid the
status updates meetings and loads of
reports being sent back and forward you
can probably tell that I'm doing a lot
of work for the banks right but trouble
with the acceptance test that runs
really why is that they're slow and
expensive they're expensive to write
they're expensive to maintain and the
feedback they give us is fairly broad so
we don't know precisely where the
failure is should they fail so in our
journey planner example if we didn't
find the right connection between two
stations is the problem is the UI is the
remove the service layer is the problem
of the domain logically the test timeout
or did we just now miss the element of
Sun screen so we learnt that something's
wrong but we won't know exactly what
that is in terms of the unit tests on
the other hand we've got no fast
feedback so that's a sprite
they fix right they ship to maintain
most of the time and so when they sail
we know precisely what happened so we've
got a bug in this particular class on
this magical line and that's useful the
trouble of those tests though is that
they won't tell you that this bug on
this line in this class assess this
particular business feature so with a
feedback from unit tests is completely
useless to the business and we can try
to throw the business at you all know
we've got 95% called coverage yeah
awesome does this feature work or
doesn't okay what is your code coverage
before and that's quite a common
conversation so over the last couple of
users trying to figure out how we can
actually move those acceptance tests a
little bit further down from there no
slow and expensive part of the quadrant
to the fast and cheap one so that they
actually give the business the people
they need and then they then they don't
take hours of days to run
which brings us to part two breaking the
domaine gap now what do I mean by that
so let's look again at this user story
we talked about in the beginning so
finding the fastest fastest route to a
destination so from the business point
of view when they give us a sort of
story now they just assume that it's
going to work the same for any delivery
channel that our application has writing
deserves the same functionality so so
why should it take longer no what should
be more difficult to implement through
different channels so now what we
typically do as developers for integrals
of the features we extract the common
functionality right we'll be sure it as
as packages between those those projects
we try to reuse as much as we can but
what about the tests
can you raise your hand if you have
separate tests for separate delivery
channels so separate tests for the UI
separate tests for the rest API is
separate tests for the mobile apps I'll
write the kind of all right so now the
trouble is that no very often in the
situation I told you about before when
the tester gets to write the test at the
very last minute let us write script as
quickly as they can and ultimate as
quickly as they can using forever the
river channels ready at that particular
point in time what it usually means is
that those scripts will be full of
directional webdriver calls or rest
assured calls etc and all those tests
will be expressed using the vocabulary
from the implementation domain so our
tests will talk about now entering
values into fields clicking buttons
selecting values values from dropdowns
they'll talk about now sending Jason to
specific endpoint no response status and
so on they talk about tabs they talk
about swipes once until they won't talk
about is actual business functionality
at their testing so very often we find a
substance to waste our note even when
the tests fail we don't know exactly
what which features are affected so then
the tester has to go through its test
results figure out what's what was
affected and this analysis against it
takes time so they need to then
summarize it somehow and then again it
takes time and then they send us a
summary for the business developers but
again this really takes hours in our
days so in my view this problem is
caused by a domain gap so what we're
going to do is we're trying to jump
straight from a user story to an
implementation of the test
okay let's let's look what we could do
about this in practice just anyone of
you work with BDD we behavior driven
development
okay okay I really like to have the guy
who has the fastest test is the guy who
works ability as brilliant whatever all
that so in in BDD we often write hour or
so to speak acceptance criteria for user
story in the form of scenarios so
they're not really acceptance criteria
what they are they are examples there
are examples to demonstrate certain
business rules that user story should
enable so in this case we can have a
scenario where Connie looks for the next
train so if she wants to leave Canary
Wharf at five o'clock then should be
told about train at 5:01 now there's a
couple of interesting things about using
examples expressed in this form as part
of all the very deliberate process so
first of all there's another
misconception that no cucumber is a
testing tool it isn't it's a
collaboration tool that helps us build
this so-called ubiquitous language
letting out from the domain driven
design domain so what we can do as part
of coming up with those examples
together know as developers testers and
and your business eyes or flat owners we
can actually build common understanding
of what is that we trying to achieve so
for example here we have a person coming
who wants to find a train and when we
write the scenario down we can actually
ask ourselves a question well okay so
she wants to get to from Cairo to
Waterloo at five o'clock and she should
be told about the train at 5:01 so first
of all do we only have one line in can
you or or no trains going to directions
right so we can update our understanding
that all the trains going
directions secondly if it's ready five
o'clock should should be actually told
about the train at 501 doesn't make
sense
we'll give enough time to buy the ticket
to find the Train and so on all that
make some sense or server right so
perhaps should be told about a sub mode
trains may be 503 509 etcetera so even
at the state of having this conversation
we already managed to build a better
understanding of what is that is needed
now if we just jump straight away to to
internet in the feature or give me the
next train will be the product that's
completely useless to the customer but
now's the next question how do we
actually go about automating this
scenario because we all want the things
that there's cucumber gives us is that
we can turn those specifications into
addressable specifications into
delectable examples so what often
happens here is we try to again jump the
domain gap we try to scrape those steps
to interact directly with specific
delivery channel so we'll see a step
like once the soil from can I go to
water room open the web site enter the
value inter field click on a button
swipe and so on so what we do what we
typically do is we again couple our
scenario to a specific delivery channel
and we end up in exactly the same
situation as we said before so although
using cucumber here helps us a bit we
can still myself
so what do we do when we have a complex
problem in software engineering I mean
as we all know any problem in software
engineering can be solved by introducing
a new layer of abstraction of course
except for the problem of too many
layers of abstraction but let's talk a
little bit about what we could introduce
between our scenario and our Gleevec
channel the external interface of our
system now to go here
I'll let tell you a little bit more
about scenario decomposition so the
technique I'd like to demonstrate is
placed on a user-centered design
technique that's called
hierarchical task analysis and a
technique that's being developed in the
late 60s imagine that to train people in
complex processes in the petroleum and
pharmaceutical industries but we can use
it in as part of our BDD process as well
and we can use it to build this this
better abstraction on top of our
external interface of the system so how
do we do it if I remember this one step
from the scenario I'll just show you
before so Connie wants to travel from
Canary Wharf to Waterloo at five o'clock
now one thing to note here is that I'm
not using this phrase when I want to
travel from one station to another
adopting to use the persona here Connie
there are several reasons for that or
first of all this allows us to be a
little bit more empathetic about the
customer so research has found that when
we start using personas in our scenarios
we actually associate ourselves better
with the customers we are we understand
how they use the system a bit better
because otherwise if
everything from our point of view well
then we make a certain number of
assumptions stay away so first of all
well we are there sitting in a nice warm
office we're using a large screen
monitor we've got a fast computer and so
on if we start using personas Connie and
Connie could be a businesswoman on a
girl she could be using our system on a
mobile device and over a crappy
connection so this helps us to think a
little bit more from our customers
perspective okay so let's say Connie so
in this technique we first need to have
an actor
so in our case that's Connie Connie has
certain goal she wants to plan plan a
journey now in order to plan her journey
she will need to perform a number of
tasks so so you need to go to our
journey planner she need to choose the
origin
she needs to choose the destination to
the time of the culture and confirm her
selection now you will see that task
status no two original truth destination
they're not tied to any specific
implementation right she could do this
as well on her mobile device
or she could even do this through direct
api's if now reading haters and so on
it's basically business flow that we're
expressing here now each of those tasks
could be further broken down into other
tasks and specific interactions with the
system so for instance to choose in the
region it means to enter the Canary
Wharf into the origin field pick the
first suggestion to pick the first
direction means to press the arrow down
press Enter
etc now
and interesting thing about this
approach is that it's not just a you
know sticking outs game because each of
those tasks could be as well represented
in code so if you have a goal of the
planet journey we can have a class an
object that actually performs this
specific set of tasks we could use the
language that we captured in the
scenario we could represent it in our
code and we can do the exact same thing
with with every single one of those
tasks so if I'm going to say choose
origin
well then I have a very class and to the
region of Canary Wharf and this will
give me the task of a3 performs this
task what this allows me to do is to
create a number of small building blocks
that can be then reused very easily it's
a small library that we can then share
as code across teams across products so
if I have a team that say develops a
little widget on the website they could
just create a bunch of tasks to interact
through this widget making sure that
scold I don't have to write them again
and if you think of large systems like
an e-commerce website you're typically
has a number of teams working on the
system so in an e-commerce example we
have probably some sort of a search team
we have some some product catalog team
we'll have some some basket management
teams and check out team and so on but
we then need to have some scenarios that
go through the whole system so instead
of having a separate testing team that
your responsibility is to either size
again we could just reuse the task class
we've already created so that's one way
of scaling this this thing up this just
may work good old code reuse you know
it's not rocket science and we've been
doing this in software development for
ages we can apply to testing as well
now another benefit of introducing such
abstraction
is that well we could change the
implementation of our goal so perhaps
instead of going through the UI we could
make our planet journey tasks go through
a REST API so one of the problems with
large-scale acceptance tests especially
on on workflow based systems that no
insurance or world transportation
industries is that those system are
typically work for systems so in order
to verify a certain thing as system we
have to go through all the steps of the
workflow and obviously the longer the
form is the longer the tests us etc so
one of the benefits here is that we
could have some tasks that now bring the
system to a desired state using a faster
delivery channel like a REST API and
then perform the test using the UI so
that's another way of speeding this
stuff up
of course we need to have some sanity
tags that as the whole flow but it won't
have to be all of them and there's
another interesting thing that we can do
here
well perhaps instead of going through
the external interface of the system we
could just talk directly to the
application layer so if you think about
it if you use something like the
hexagonal architecture or poles and
adapters the your test could just become
another adapter for the system so
instead of going to the external
interface we just send events direct to
the system and this makes it blazing
fast because we don't have to start up
the server deploy the application wait
for the page to load you can just use
toad in memory
so the things I told you about actually
part of something a little bit larger so
Oakland scope of use my culture myself
would be working on something we called
the screenplay pattern so it's a way of
structuring your automated acceptance
tests that help them become a bit more
scalable a bit more maintainable so
let's walk through this process together
so as you already know we start with an
actor this actor can be derived from
from a persona that no our UX colleagues
came up with in order to interact with
the system we give the actor some
abilities those abilities could be to
browse the web using a web browser they
could be to interact with the rest api
using some rest client through the
domain api and so on so basically what
we give the actor is a client to a
specific interface so we decouple the
connection interface from the actual
task
now an actor can perform tasks so the
way this works is the active has a
simple method attention because I would
I'll try to perform a certain sequence
of operations and we can give them a
list of tasks such as a note on a
journey the actor can also verify the
state of the system so the verification
is yet another task they all follow the
same interface and I show it this
interface in the moment now what is the
task so a task is basically an object
that comprises the task interface which
basically means that a task will have a
performance method that we sees an actor
so each task will only have the four
months it receives the actor and then
inside the performers you call utter
attempts to and you pass it on
so you basics train those tasks together
and it's just because the whole
exercises becomes a nice icing list
processing degree now we can have some
some static methods on the on the tasks
to critten eyes DSL like I will choose
origin off but the main meat is in the
performers method another important
thing here is that each task in this
particular implementation and the
implementation I'm showing you now is
the strength ejs implementation of this
pattern so this code is in typescript
and another important thing here is that
two three methods so each task can be
described using a human readable
sentence and I'll show you the reason
for it in just a second but first let's
focus another thing instead of writing
those tasks like this instead of writing
the whole classes because this dis
pattern is and very very common in code
bases in general 72 years we can also
have a shortcut there is shorthand
notation for a task
that's it so this shorthand notation
will where we use the task where a
sucker in my talk we just create another
tasks with a specific description in a
specific list of other tasks or
interactions in the system and this
makes it very very easy to quickly model
those tasks that we have so that's the
screenplay pattern as a whole so as you
know with actors actors perform tasks
they also have abilities that enable
those interactions with the system under
test they can ask questions about the
system and this all creates a nice and
quite decoupled model of interacting
with your application what it also
allows you to do is you could have
interactions that interact with specific
delivery channels can have interactions
interacting with your application layer
or domain layer it's up to you I mean
whatever task you create that has the
performance method on it
it's just going to be executed
so what I think might help us get
British domain guide so get from the
examples to the actual implementation is
something like the screenplay button
it's something like lecturing addressed
implemented and it also helps us to
share the code easily it helps us to to
the model this stuff know very quickly
and as we go along in the project as we
build those little libraries of
interactions with our system we can very
easily start to reuse those right so we
don't have to scrape the test every
single time that we get a new feature
but now let me tell you a bit more about
this two string method focus on the
tasks area what was the purpose of that
so each test suite each exercise
ancestor it has to work on different
levels of communication so at the very
high level I think ten thousand feet
level we need to know the release
readiness of the product is this thing
and a work in production can we release
it are all the features complete which
features are incomplete which business
capabilities are affected if the feature
is not working a bit lower we got
capabilities and features so which
scenario affects which feature which
particular set effects which scenario
and so on and the reason why we could
annotate those steps wheels to three
methods it's so that we can create those
reports automatically so that we don't
actually have to go to different tests
for different interfaces then analyze
the results compile them together put
them in some some Excel spreadsheet we
can actually have it done automatically
under test so this works on the release
ordnance level on the capabilities level
on the sitter's level and on a scenario
level and if you want if you go through
the web channel I mean each that can
take a screenshot folder as well so you
get this living documentation of the
system click much for free as you build
it
now if you start doing this as you are
actually developing a feature then you
get tested as fast to run that verify
the domain logic you have to be helped
to ensure that the domain logics
implemented in one place are then across
the whole stack and you can get those
reports that you cannot present the
business even before there is any UI
which means the whole cycle much much
faster this also helps to build the
understanding of how the feature works
are supposed to work it helps to improve
the communication between the developers
and the testers because now the testers
see know what started actually tested
what features are verified and if they
want to come up with with some some edge
cases well that we can help them write
those edge cases on the application
level or the rest api level rather than
go through the UI every single time so
what I found works pretty well as an
improvement to the process I showed you
earlier there is doing a couple of
things so instead of writing that
certain stats in the format of no it
should have unit tests now it should
work and so on we can actually apply
some VV principles we can come up with
examples and rules to demonstrate how
the user story is supposed to work we
can work on this together so in the BDD
we've got this three amigos meeting well
three is basically any number between
three and seven and this will include
could involve the product owner the
developers the testers the registrar's
and so on where we actually define those
those examples and the rules and how
they should work in the system now when
we have those specifications we can
start automating them as we do the
application we don't have to go through
the UI we can go through the application
layer so again if we're using something
like a Mexican or onion architecture it
just becomes a yet another adapter to
one of the poles of your application is
exposing we can start building this
living documentation as we go so we
don't have it all left until the very
last minute and then this frees up the
testers actually do some more meaningful
work they can talk some experts testing
on usability testing on
Foreman testing capacity testing and so
on rather than just on clicking buttons
on a website and what I found is that
they do this this sort of process
results in fewer bugs and better
software that's better aligned before it
was new in the first place so yeah so
that's just a little summary so then we
don't have to resize the UI they don't
have to exercise the application full
stack we don't have to have application
deployed to an application our
acceptance tests we can report
consistently across the stack and the
nice thing about 22 years is that you
can eat if your application is in
JavaScript if it's a single-player
application where your domain models are
in JavaScript then you can interact with
those models using this framework if
you're if your logic is in Java then you
can use Sankey BDD that don't focus on
smart world and you can use that now
those two libraries work together so you
can use them both on one project and it
has generate the compatible reports so
we can use the right for the right tool
for the right part of the system what
else about is that no using process
using the BDD process helps us focus
more on how a given story should work
what is the purpose of it what is this
business goal what is trying to
accomplish and very often just by having
this conversation we can get rid of
quite a few features that have no value
or purpose and obviously they're the
best code to maintain is the one we
never write there was no purpose you can
just get rid of it right it's great to
do it now before we start working on it
so if you'd like to play with the
library if you'd like to try this
approach I want you to go to certain tjs
or there's a tutorial you can have play
around
and I would like to also show you how
this works in practice because I'm so
far is the only beam slides right and we
developers actually prefer code access
myself right okay let's see how that
works
come
all right
so if the internet works I should be
able to run the scenario so that's the
scenario shown earlier where Connie
tries to find a neck strain so 73's
works as an extension of the protractor
framework which allows you to first of
all test all your angular applications
out of the box but you can also test any
other known angular application so here
we've got the Transport for London which
is no longer app assuming no let's see
how that works the progress bar is
spinning so we can use and we can test
any web app we're using the function
ideas currently no prize as a fit of the
box we could test rest ideas as well
this would probably require us to come
up with some custom ability that we get
adapter now we can test the application
layer all right
so the internet works cool
and what their working test awesome so
this testing works in two phases so that
the test run produces intermediate Jason
reports so it doesn't create the HTML
nothing I gotta just now creates the
absolute meme of a force needed to
produce this test in the second pass
this also allows you to do several
things so first of all you can run those
tests on different machines in your
testing cluster and then there's a break
the Jason produce the report you can run
tests through using 70 degrees so for
the front X or the node applications you
can use DD to run the test for the
background for your days and reports
aggregate them produce the report so
this is for some interesting workflows
as you can see this particular run
resulted a test execution report that
tells me about the features so I got the
journey planner that tells me about the
scenario that were executed subcon looks
for a train that other information from
the cucumber files so the user story
details that can show me all the the
steps that were performed or the tasks I
can then go into those steps I can see
any associated screenshots should I
choose to have any
and this works for any interface of your
system that's in myself because it's the
same pattern now if I might scenario
fail because I was all good and nice
when it's working right so let's let's
break it a little bit
advantage of using those actors that
they can have several actors in one
scenario so for example here I'm saying
that I'm given there are some trains
leaving Canary Wharf at this particular
times I can have some administrator
actor that goes to the system sits at
the test data for the following steps
second is Elliott as well
- bus
and the good stuff
so even of a failing test will see
straight away which features are
effective we can then dive in the
specific scenario we can check out the
specific step and any assertion errors
that are typically useful in this case
we saw in the report as well so here I
see that now the 1659 was not one of
those I was expecting so this is all
nicely integrated together and all this
code you'll be able to find on the
github page of the project so if you go
to github and Frankie KS look it up or
you can find on the website it will all
be there for you to play with cool right
well thanks so much for a time thanks
for joining me here today I hope I
didn't bore you to death and I hope this
might be useful if you have any
questions at some time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>