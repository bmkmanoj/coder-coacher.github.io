<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java Libraries You Can’t Afford to Miss by Andres Almiray | Coder Coacher - Coaching Coders</title><meta content="Java Libraries You Can’t Afford to Miss by Andres Almiray - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Java Libraries You Can’t Afford to Miss by Andres Almiray</b></h2><h5 class="post__date">2017-03-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/GJW8s34_9eY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">how's everybody feeling today are you
guys excited about box day szerik second
edition yes you had coffee yes ready to
keep learning excellent alright so by
the title you know I'm going to discuss
a few Java related projects but I have a
challenge for you so here is the
challenge is how could you write any
application that consumes a REST API now
I I decided to choose a specifically a
REST API because many of us have to deal
with the rest in one way of another I
know that is also now a good number of
people dealing with the binary protocols
and some other different communication
mechanisms but rest is still with us so
we're going to use it because it's kind
of like the basis and of course we had
to do with Java we the way that we need
to do this we have to create components
that are reusable
they are highly testable and in such a
way that also we don't have to write
that much amount of code you might have
some of these how you could this right
we like to think we like to engineer our
stuff ok so without any further ado
these are the libraries that we going to
see today if the clicker works you might
recognize some of those already we're
going to see some libraries for creating
the production code are we gonna see
also some libraries for testing the code
because it's not enough to just write
code and then put it out in the open we
also need to test it right display map
this thing actually doesn't work all the
libraries are going to see today and all
the projects are open source you can use
them as is you can use them right away
and you can put them to work on your
daily projects without any problem at
all
also the most of the libraries if not
all of them we have used them before in
our customer project so we have plenty
of good experience of when things
actually work and when things actually
break this is part of the reason why I
will recommend you to have a look at
these libraries
and my goal for today is that by the end
of the 48 minutes are left
you'll feel like this and you feel like
these when working with your code all
right okay so my name is Sandra Samurai
I work for this company called canoe we
are one of the sponsors of these
beautiful and excellent conference I
come from Mexico and I'm also a member
of the groobie development team and
co-creator of unco founder of the
Griffin framework jawan rockstar Java
champion yada yada means I cannot know a
few things about Java and I want to
share my experiences with you I also
would like to have if possible a very
interactive experience with you so at
any time if you have any questions
please let me know
hopefully we also we have time at the
end of the session if you have more
questions and I'll be here for the rest
of the conference just grab me by the
hole and then we can continue the
discussion is that okay for you guys all
right okay
so let's go back again to the challenge
again remember we want to build a
java-based an application that consumes
a rest-based API I'm here to do it in a
way that is fun that is concise that
it's a small enough and that is highly
testable now I'm also going to add a new
bit to this challenge is that how many
people here still develop applications
for the desktop swing or Java fix just a
few hands well the application that I'm
going to showcase today it's built on
top of Java FEX
just for demonstration purposes but
everything else are you going to see you
can put it to work on the web on the
server on the cloud on mobile it does
matter
the libraries is to work on those
environments okay so for the REST API I
chose to use the github API just because
it's well-documented many people have to
use gif hold in one way of another if
you go to that URL the that's version 3
of the API then you can learn everything
that is in there out there to learn
about this API it's very well documented
because it's so big we're only going to
deal with acquiring repositories for a
party
user or organization actually we're
gonna use organization so here is if you
go to that URL you see the description
what is the payload that you need to
send to that API and what kind of
payload do you get as a result and based
on that we're going to consume that
information so if we issue a get call to
that URL which is parameterised
we can get up JSON payload with all the
information and this information
actually depend on the size or how many
repositories are there for that
organization maybe paginate it and the
pagination mechanism in github api which
is also described there uses HTTP
headers to figure out if we need to go
to the next URL or the previous really
this is the last of the face of whatnot
so with somehow we need to understand I
mean the application needs to understand
how to deal with headers and consume the
next URL all right so when we issue a
get call like this one we get a JSON
payload like this one
actually I just shortened it because you
get like 40 different properties
associated with our repository for our
purposes we only care about four of them
and you get all these in in a big JSON a
right what else we're going to need I
guess that in this time and age it will
be very very hard for people to come up
with a new solution a new project where
they don't use any form of the pennies
injection it doesn't matter which tool
with library which frame were use
there's bound to be some dependency
injection of course we need require an
HTTP client and some kind of rest
capabilities on top of that one we need
to figure out how to do JSON mapping
from a JSON payload into a Java object
very likely that we're going to deal
with pojos means getters and setters and
that means there are more morkul we want
to remove that boilerplate code and
finally because i said we are going to
show or use desktop application you have
to deal with concurrency because for
those that raise your hand when you say
I still do or do it that's the
programming you know there's one rule
that we should not break everything that
is UI related painting on the screen or
accessing properties to the widget must
happen inside specific thread UI thread
everything that is not UI related like
we're in the database or issue in a
network all should happen outside the UI
thread and because this is easy to break
this thread at this rule there are so
many bad swing applications out there
because nobody cares about ready but we
are going to care about reading all
right you can get the code that I'm
going to show today from this URL
don't worry the slides will also be
available to you everything there is
open source under GPL you can read the
curl you can study code you can take the
code you can use it if you want to so
let me show you the application in
question and I'm gonna run there I
actually have five different versions
and you can run it directly from once
you clone the repository if you use
Gradle just use the grail wrapper and
then you get it let's see if we can get
a little bit bigger
looks yeah perfect so if I give it a
name of a repository there's that nice
thing about Java effects binding a
whatnot I can tell that when this button
is enabled or not very easily if I love
this if I click here it's going to load
the first page and then followed in the
the other pages in case they are and I
get the number of how many repositories
but notice that also once information
starts to streaming if I got Network
come on I did test this before let's see
yes
no worries because this is this goes a
part of the demo if when you need to
test this thing and you don't have
network access to the real deal you need
to still find a way to test this thing
right let's give you another trial and
if it doesn't work anymore there we go
you see that and I was too fast and we
got 245 repositories there are many
things that we can do with this an
application but that is enough so that's
basically it
okay so the first thing is are we going
to go with the penance injection and
does anybody know what is the name or
what is the number of the jsr that
standardizes dependency injection in the
JVM yeah right
yes at 3:30 it's a very small j-stars
only six classes actually most of them
are interfaces so what do we do with
pennies injection well you define your
API in many different ways
say I prefer to do interfaces first so
let's say we define an interfaces like
this I put that thing in red because
we're gonna see it in just a moment what
that thing is but we need to create an
instance of this interface or actually
create an implementation of this
interface and injected in some component
you know pretty much this already use
add inject one of those annotations come
from jsr 330 and then what needs to
happen is that the type that you are
injecting and the type that has that
requires the inject ease must be handled
by the dependency injection container
right so in this case what I want to
showcase is juice Google juice why
because Google juice is the reference
implementation of jsr 330 juice gives
you the capability to define bindings in
a programmatic API a primitive way here
I had if I need three bindings one is a
source class to a target class the
second one is to the source of the
target class are exactly the same
Atmaram that every one that is a lazy
binding sub provider in terms of a
spring there is a factory being the bean
is only created but the moment that I
actually need to to access it and there
are two other more kind of bindings that
you can have in juice one that is really
good is binding to a constant value
which actually make use of that in the
source code if you
look at the repository why because
during production
I want to bind to the URL of the real
github API but during testing I want to
buy in the URL to a testing value so the
reasons to use juice is because it's the
reference implementation of OJ sr3 30 it
gives you it's kind of a smallish
dependency framework is extensible you
can listen to changes or when an
instance has been created by the
dependency injection you can react to
the lifecycle the one thing that I don't
like it perceived specifically about
juice is that if you are expecting an
injected type to react to an annotation
for example past construct or pre
destroy juice doesn't give you this out
of the box but you can get it if you add
an additional extension to juice this
call actually don't recall what is the
name but it's in the repository so you
just put it in the class pad and they
boom now if you annotate a class with
past construct and pre destroy then
those lifecycle methods will be invoked
at the right time for you if you happen
to use juice then you get another bonus
Java library which is called voila
Google guava guava was created many
years ago out of frustration of missing
bits in the standard Java library and it
gives you new collections it gives you
functional capabilities and there are
not found in JDK 7 or prior whoo how
many people are using dedicated already
some hands kind of have for you good if
you haven't migrated to JDK 8 please do
so quickly because ready k9 supposed to
come out this year and then migration
would take much much longer it's very
cool and it's actually if you don't move
for the syntax then just move for the
JVM features which are making runs of
applications much faster anyway so if
you for some reason can't migrate to JDK
8 still and you want to use functional
programming and golgotha is a nice
option for you but if you do not use
juice it's probably that you have
encountered spring and I know that
spring has a huge portfolio projects and
for now I'm only going to concentrate in
one project Allah
the first one Spring Framework or this
is the component this is a library that
will give you the pendency injection but
it will also give you capabilities to
write better tests it gives you
capabilities for having better
internationalization I don't know if you
know but the default message format
coming from the JDK is not thread safe
but the one provided by the Spring
Framework or s so if you have to deal
with internal sation often then have a
look at this one you also have access to
serialization creating J mix clients
with the spring core is so so easy it
should not be allowed it's really just a
couple lines and that's it just exposing
also JMX beans the JDBC template and
validation what not this this is really
cool and then of course once you get
into the spring you might want to try
other projects from the spring portfolio
next one is reducing boilerplate code
now most people are aware of the Java
beans conventions well how do you write
a well-behaved project
do you have to have a constructor with
parameters no you have to have getters
and setters for each property there you
want to mutate yeah and you have to have
a proper implementation on equals and
hashcode how many ways are there to
implement it equals and hashcode so many
different ways what is the correct way
that's kind of hard right if you follow
just blocks effective Java there is a
good algorithm there so we have to take
care of these constraints wouldn't be
better if we had some tool that can
generate all these things yes of course
the IDE the IDE can generate source code
using macros and templates but the
problem that I see with this is that
once the IDE has generated the source
code you are the ones that had to
maintain that source code it's okay to
rename a property the ID will help you
it's okay to add a new property yes the
idea will have to regenerate all those
methods what happens when you need to
remove sorry to remove a property it's a
little more of elaborate things that you
have to do on your side so worry if
instead of generating source code you
were to generate by code would it be
better
if we keep our source code is small and
concise I'm have the compiler do the
heavy lifting instead of us or the IDE
that's precisely what project Lombok is
practical Umbach hooks into the compiler
process and will generate the right byte
code for you the only thing that you
need to do is apply a set of annotations
to your source code so what we're seeing
here is that Java object the pojo that
is going to represent a repository
that's mapped to the JSON output coming
from the repository query so here we
have two actually two libraries one is
Lombok and the other is jackson which is
one we're going to use for the mapping
so what Lombok does in this case the add
data annotation it says when you put
this in a class for every property live
fine or actually feel I'm going to
generate a pair of Gators and setters if
you make it the final profil then I'm
only going to generate a getter and if
it's final then I have to initialize
that it's in that constructor and it's
going to generate the constructor in the
right order it will also generate an
equal sign hash code implementation for
you and it also will generate that to a
string implementation for you you can
tweak all these values you can put a
protected access or visibility modifier
instead of private you can have a fluid
interface design for the Gators and the
setters if you want to actually the
setters that gives you many options and
it can subjection remember that the JSON
payload will return like a pot load of
properties we only care about for if we
annotate our class with that annotation
JSON ignore properties ignore unknown
then it doesn't matter if the JSON
payload has 40 properties if I only have
four that I'm interested in those fours
then Jackson is going to map only those
fours and also the other thing that it
looks a little bit weird right there
when we got this annotation etcetera
that's Lombok when we get another thing
that says ampersand only score the score
and they're on a Jackson annotation
jason property full name what we say in
his Lombok generate a getter and a
setter and that annotation JSON property
you're going to put it on the setter
itself
saying is that the Jason property is map
you seen a snake kill it snake case
convention but our java property uses
camel case conversion these will do the
right thing for you there's nothing else
that you need to code now the bloomberg
is also happy here's another version who
likes to use the builder pattern to have
immutable objects but being able to
create objects as you go
that's the builder pattern for mostly
here is you don't need to create a width
same thing with something and then just
applied the Builder annotation the most
easiest way is to Anna static method you
can change the needle man method you can
put it on some other method and these
will create the builder for you
automatically it creates a new class for
you actually and all the by code in
order for to use Lombok you must have
here's another example when you can have
inheritance the base class has nothing
and the child class has annotated with
that data and also says i'm going to
call the equals and hashcode of in my
superclass on my own hash code and my
own equals and that's basically it
that's one way that you can configure
this now Lombok is very powerful hooks
into the apt processor tool which was
released in jdk six so if you use
angelica six of upwards there's no
problem you must use or you must apply a
plug-in in your IDE of choice if it's
IntelliJ or eclipse or NetBeans I think
that means doesn't require one but both
IntelliJ and eclipse will require an
additional plug-in because the new
methods added by the code they had to be
visible for you at source time or
development time in order for you to
call those things right so that's the
whole thing for the plug-in is very easy
to install much more our problem and
Lombok is extensible but i wouldn't
recommend you as a regular developer you
don't need to extend Lombok because many
of their notation so many much of the
behavior that you need is already
provided by Lombok in order to generate
well-behaved it pojos the builder values
is Nikki true I'm not so sure if it also
has a notation for add immutable for
generating really immutable classes but
we can give it a try and and one in very
important thing do not forget to enable
the annotation processing tool in your
IDE if you do not then no bytecode is
going to be generated if you are using
maven or Gradle technically you don't
need to use the apt processor plug-in
you just use it in case that you want to
help your ID with the generated source
code I should know not generate source
code generated by code how are we doing
so far so good
ok I tend to speak very fast when I get
excited and trust me this gets me very
excited because I do I used most of
these libraries every single day on my
daily work so when we're dealing with
behavior sometimes we want to monitor
the state of our application and the
easiest way to monitor where we're going
is by logging and I have to say it
already
there is no good logging framework for
java there is none but all of the other
options that you have access to SL f4j
is perhaps the one that gives you the
best options because actually i selected
because is is widely used in the open
source community but because of two
features one is that if you consume an
API that relies on Apache Commons login
or Java util login or your log4j or
something else you can funnel all those
calls into a single API DSL for the API
so you only need one single file to
configure the login levels for
everything else and the second thing is
that you have variable arguments for the
login methods because I you probably
have seen this when you do lockinfo and
then pass message if the info level is
not enabled then well the lock doesn't
come out right but you pay the price to
create a string if that string happens
to be an expensive one it's not just a
simple stream but concatenation and
whatnot you have to sprinkle the curl
with guards like if log info is enabled
then log info but if you have variable
arguments then simply say login for the
format of the message and then the
arguments and if the info is now
the evil level is not enabled then no
worries nothing happened new versions I
think that SL f4j and there is another
one log4j log4j - besides whatever
arguments they also support lambdas
message suppliers like J unit 5 also so
you don't pay the price of creating the
message either if the level that you're
targeting has not been enabled in
configuration alright now we're getting
into the subject property how do we do
HTTP in Java most of you I suppose are
familiar with apache httpclient it's
been there for ages those HTTP client
support HTTP - we should care about HTTP
- now especially because JDK 9 will not
come in with a baked in HTTP - client
it's been rolled out of that release I
don't know why but HDB - is the future
so we have to think about that and how
many ways are there to deal with rest
considering that if you read the paper
or the description of how rest should
behave there's only one way so how many
ways can we do this thing just one way
why do we have to implement it very
differently for every single project so
I will propose to use ok HTTP it's a
small and fast HTTP client created by
the people from the square the right
server for Java desktop and Java Android
well answer is no Java depend how you
ask
so it's tiny the memory footprint is a
small so if it works on a mobile space
you should work on the desktop and
certainly you can work on the way on the
server so this is basically how you do
you create an instance of this thing is
configurable I guess we only create a
simple HTTP client then you create a
request object you can define headers
you can define an attributes cookies or
whatnot you can also define interceptors
if you want to enrich the request and
the response then issue the call you get
a response object you can query for the
status message you can query for many
things and of course you can query for
the
once you get the body you can transform
that using the right transform and
depending on the content type right easy
as that so I have found occasions to be
to be very very fast very tiny and very
extensible next how do we add Java on
top of HTTP because it's one thing is to
say yes let's go into issue a network
call and then I had to deal with the
headers and then do the transformation
of XML or JSON myself now it would be
better if we had a Java API on top of
that complexity but again how many times
can we implement the way that rest
behaves so that we can map it to a Java
class there's only a handful of them and
we don't need to do it ourselves if we
let retrofit do the work for us
so what retrofit allows you to do is you
define your rest api your client you
seen an interface like this one so we
take we will just say remember we're
just going to query the repository so
the first method says here is a
parameter that's the name of the
repository and as a result I get
something is a call that is a type of
retrofit that tell me that would tell me
what is the response are many other
things that are out maybe interested
again low-level HTTP things and I get a
list of repository objects out of that
nice and if the headers contain a link
to the next URL I can grab that URL and
issue the second net method when say
repositories and I pack and paste on URL
and also get a list of repositories so
with these two methods I can do the
pagination ok but what else this is only
giving me the access to the parameters
and the types what you do is that you
create our Java language life proxy
based on the retrofit builder the
retrofit builder takes the URL or takes
on configuration one of them is a URL
where you're going to point this thing
to then some configurations like
factories in this case we'll use in the
jackson factory so that we can transform
json up payloads into java objects using
the repository class we saw before
and then we build that thing then create
a proxy based on the github API
interface which is the one from the
previous slide you see that and now that
we had that object we can simply call
methods on that thing and under the
covers there goes an HTTP requires
passing everything and when it comes
back if the response is successful then
it will transform the body automatically
into a list of repository objects and
boom we have only to deal with Java
objects all the arrests and all the HTTP
complexity is completely hidden and
managed by a retrofit it's quite
accessible and under the covers retrofit
uses ok HTTP so you can use HTTP 2 as
well how do we handle multi-threaded
code because you remember that if we are
building a job effects application
everything that is UI must happen inside
the UI thread
anything that is none happens outside so
issuing a call like the repositories on
a github API must be done in a
background thread and once the results
are ready then we have to get those
results back into the UI because we
display them on a list or while the
results are being computed we have
intermediate results we want to push
them into the UI as well right so we
have at least two threads that need to
coordinate one another how do we do this
well if we take an inspiration from the
JavaScript community they came up with a
solution a few years ago which actually
was born many many years before in the
swing worker which was inspired by some
other people before that so what I'm
saying is that the concept of promises
is not new it's just a new name so here
is Jennifer is a library that allows you
to do exactly that
jQuery like promises in Java and that
goes back to the rumor that read site
that we saw earlier on that promise
object so we're seeing here is that when
we issue a call like that repositories
with a name we get back an object that
is able to handle whenever a result
comes in that result will be a
collection of repositories
if there is an exception or an error
then the second type is what we're going
to receive jennifer allows you to catch
any kind of type not just trouble not
just exception and if there happened to
be intermediate results while you're
doing the computation on the background
thread then the third type is what
you're going to publish in this case I'm
not publishing anything but there's
another version of this API when I
published a repository so every time
that I read something in the background
and there's a repository it will get
pushed out to Matt with me into the UI
just like we didn't seem working in the
previous days so there are two ways that
we can actually do things that we need
to do for working with a promise one is
how do we create the promise of check
itself within that background task and
the second is how do we consume here is
the case on how we create the promise
and the background task there's a new
type out there called deferred manager
from J defer this is basically an
abstraction on top of executor service
that gives you many benefits one of them
is to schedule a background task that
thing inside the land expression is our
background task so what do you think is
doing is issue in the network all and if
it's successful then returns that list
of objects nothing notice that we simply
say response that body
why because I will call object returns a
list of our collection or repositories
just like that if not then we simply
draw an exception that runs and
background and when that is ready we
consume that thing in this way say for
example this a controller component that
we have a some series of configuration
settings for example if you want to
limit the amount of repositories you
want to query then we can specify in
that way we issued a call to the promise
that returns a collection of
repositories may throw something and in
this case the third type says repository
so this one due cares about intermediate
results and notice what we do with the
promise the progress colbus says
whenever a repository comes in I'm going
to invoke that method that is a method
reference okay so I'm going to add that
thing to ah
a list good if by any chance the whole
thing fails then I'm going to handle
that use another metal reference simply
print out to this to the pre to the
system error
but regardless if it was a failure or if
the whole thing succeeded I always want
to do the following thing which is just
trigger I changed a state of a change of
state so that in the case that you saw
the early the application the bottom for
load was disabled when I knew this thing
was running and when this thing finished
the bottom for load was again enabled
and if there is a failure well of course
the bottom for running again has to be
enabled right that's the whole reason
why we use Elvis Jade affair then gives
you the concept of promises inspired by
jQuery the last release was made two
weeks ago release one to five and it's
Java if friendly as you see as you saw
you can use expressions for creating the
the background task and also for the
callbacks for dorm progress and
everything else it's pretty good there
is one key better promises and this in
this case and the background task is for
they are only used for or useful for
one-shot executions you can doing some
interesting things are read their
response for the first query then figure
out you have more information in the
headers and continue on right but there
is no way this is a one this a lot of
nothing either you finished with the
task or you don't there is no way that
you can is three mean results okay but
for that we had to look at reactive
programming which is not other thing the
reactive programming is basically event
processing property chain listener a
property chain event again desktop but
with different classes and a little bit
of different name so it's basically the
same idea you just processing events in
app perhaps up in an infinite amount of
sources of events so here is our X Java
is probably the most well known other is
not the only one but it's very easy to
get started so what we're going to do
instead of getting a promise
out of our service code we're gonna get
an object type observable if you use in
Eric's Java to then you're going to get
probably a flowable what's the
difference that a floral gives you
access to back pressure what does back
pressure mean in a producer is creating
too much data much much faster than the
client can consume it the neckline is
going to get bogged down so what the
client can say is tell some information
to the server to wait a little bit or
buffer out results so that when the
client is finished with a current
workload then it can continue with the
next one so that's basically back
pressure and only the flow of account
type will give you this or server ball
no longer and the rest of that is that
we just enhance and continue adding more
behavior on top of that observables so
what we saying is that we'll have a
default timeout of 10 min seconds if we
don't get any answers within 10 seconds
then we were just gonna fail and when we
subscribe we're gonna change that state
and when we finish it doesn't matter if
it's again success or failure we're
gonna change the state again when we
subscribe on that means that's the
background thread that we're going to
use because otherwise going to use the
same thread that you subscribe on that
will be bad because that wouldn't that
won't be a background thread when we
subscribe any object that gets
intermediate internet intermediate
result is going to be added to that list
and it happens to be an error in this
case we're just simply going to blow up
with a sprint stack trace and then boom
we just subscribe that means now we have
a channel we're listening to this
channel events and whenever they
occurred we're going to see the
repositories being pushed into that list
can we use retrofit and Eric's Java
together yes we can there is an
extension for that and what you have to
do is besides an inner dependency you
had to modify your API so instead of
returning an object of type call then
you get actually an observable of our
response there's retrofit of the list or
collection of Reap
satori-san notice that the parameters
for the other things do look exactly the
same the only thing that we need to
change is their return type if we are
not doing pagination then this is all
that we need to do but because we had to
do pagination I'm going to show you what
can we do to resolve that the other
thing that we have to do for the Builder
for the for the retrofit proxy is that
we had to add one more factory besides
telling it that it needs to use Jackson
to do the processing within JSON and
Java now we are the RX job adapter so
that it knows that it can work with
observable objects not just plain values
so doing pagination can be done in this
way there there may be other ways
basically what we're saying is that and
this is this code is actually again also
in the repository we issue the first
call using a lambda and then we
concatenate that with the results coming
from the second one so we're going to
use the second one
notice that it takes an argument links
and from that we're going to strike the
URL so how do we actually deal with this
what happens is that the first call is
gonna give you some list of repositories
I'm gonna put that in observable think
about several as a flow of repositories
only there's not list of repositories
there but for every page we're gonna get
a second or a third list of repositories
is there a way that we can concatenate
up or flatten the list of repositories
into a single thing that's exactly what
the flat mat operator is doing for us so
for every page that would process we are
going to concatenate the list into the
previous went through previous one so at
the end we see that we only consume an
observable off repository not observable
of list of repository that's basically
it notice that the code will eventually
inspect the headers and the link class
which is a very basic class that knows
how to read the headers if he finds the
next link then it's going to use it from
the previous lambda and go and go on
until recursively we can find everything
alright so rx Java is quite useful there
are plenty of documentation and examples
out there that you can
from and that info Q just put out an
online magazine that you can get for
free on this particular topic I should
have read an article on how you can test
our X Java if you are interested into
this one okay we are almost done with
production coding almost getting ready
to get into the testing code one final
thing is so far the examples I have
shown say that if you had got an
exception I simply print out the stack
trace right what if instead of doing
that we pop up a dialog saying up there
is an error and you can fix it by this
and this and what not is possible the
controller class if we want to be
purists the controller does should not
have anything to do with you IRL if you
follow the MVC pattern so how does he
create the dialog which is you can we
have some way to have the computed
controller component communicate with a
buchen ponents so that the controller
doesn't know the view directly and
vice-versa for this we're going to use
an a bamboos and the one that I suggest
is ambassador which is quite good if you
use in guava there is also another of
embossing guava but this one is it has
really has been bash market to be much
faster and if that were not the case
which luckily it is it still provides a
good much better API that the event
balls are you finding in guava so this
is how we define publisher so it's the
same controller class that we saw before
and instead of just printing the stack
trace notice that we simply say publish
an event and actually will same publish
a sync which means post it I don't care
you can also say publish and that will
wait for other consumers to finish
consuming the event and then you
continue in this case simply say just
publish and somebody hopefully will
handle the event you can send any kind
of object in this case I decided to
create a travel event which is a class
that I created you seen Lombok how do
you consume this well you have any class
that provides a method
annotated with the F handler annotation
the name of the method can be anything
you
and the important thing is the type of
the argument notice in this case is a
troll levin type so when this class note
is the using post construct and pre
destroyed gets registered with the
eventbus once it has been created by the
abeyance injection container then
whenever an event happens this event
handler is going to be invoked now in
this case you don't see the code but in
the repository you will see there's
enough code for this to create a java
effects dialogue and i didn't show the
example but we'll see just a moment in
testing so now you know how to produce
events how to consume events and Basle
is quite good there is one cave at the
the author doesn't work so often in the
code these days so if you find a bug
just be be careful because the fix might
not come out as fast as you may expect
these being said ambassador is quite
good and be to be put into production
actually i can we have a couple of
customers that were using this thing we
haven't found any problems at all so now
that we have said this let's move into
testing and we got less than 10 minutes
for this one so we'll see well how many
of you were at sans Brandon Jade unit 5
talk an hour ago or so okay so you know
that you can parameterize a J unit for
any T a JUnit test there are some ways
to do this engine unified but if you are
stuck again with J uniform there is one
particular problem with parameter as
engaging default test cases you can only
parameterize the same method this if you
have multiple methods parameterize in
the same test case they had to have the
same number of arguments and the same
type of arguments there's no way that
you can have different types so that
means that you have to have different
types and different cardinality you have
to have multiple test cases well if you
happen to use J unit params then it's a
matter of using the right annotations
and now you can go back to a single test
case when you have all the relevant
scenarios back in the same thing and
then you go you can supply the arguments
directly in the annotation
you can give it the name of a method
that supplies the values or you can even
give it the name of or the actually the
class name of the data provider if you
will it's quite good unfortunately you
have to use a custom runner so if you're
running another test a test case with
another particular runner this might not
work for you but I will have found this
to be a good replacement from J you need
for a standard parameterization the next
one is do any of you guys do TDD hands
only so we know that we have to test our
classes in isolation for that our
collaborators have to be as clean as
possible for this reason people advocate
use of marking all of the many things
that you can see out there to do marking
I will recommend you to have a look at
mojito it's probably the best library
that you can find out there and all the
many things that mojito can do it will
allow you to mock final classes
something that other mocking libraries
will not allow you just in case that you
happen to have a final class that need
to be tested in some way here what we
have here is the sample controller and
the sample model real classes but the
sample service is the mock collaborator
and then in doing the expectations block
you thing these are really like a DSL
for defining our expectations when we
say that method gets invoked with such
argument whatever bad value input is
notice that we also using j-unit to
parameterize that method then we return
certain output in the when block this is
where we exercise our stimuli so they
controller and then we verify that the
controller did the right thing and then
our mock also was invoked in this case
only once and if we pass that argument
then it should be fine if he were
invoked once but the argument was
different then this test will fail
mojito gives you support for this kind
of testing so it stops which means I'm
gonna give you a can result whatever
whenever you ask me for something this
is what you get
a Mach is a much stricter one because
it's not only that you call me but you
call me in there right amount of times
and you also call me in the right order
and you can have a spice spice are real
objects for which there is a partial
implementation using a stopping or
mocking if you happen to be using Jade
unit and Jews and you want to use mojito
then just apply mojito like that or use
Jupiter
sounds cool now what this project does
is it brings you Jews and Google I mean
Jade you need a mojito you can inject
bad objects into or instances into your
test case so that's one thing that it
gives you but the second thing is that
if you do not provide a binding for a
particular type then it's going to be
mocked automatically using mojito for
you so what this test is doing is pretty
much similar to the other one that is
not parameterised by the way because
again custom runner what this test is
saying is that I didn't provide a
binding for the service so that service
is going to be automatically mock for me
I can specify the specifications just
like we did before I know that the test
code is pretty much the same now the the
advantage is that the the mocking is
done automatically by the dependency
injection container so if you happen to
need that called mock collaborator more
than once in two places is going to be
the same mock is going to be safe next
if you're feeling adventurous and you
want to test out other jvm languages I
will suggest you to have a look at
groovy and if you do then you can access
to spark a spark gives you
parameterization and mocking
capabilities much like mojito and the
other projects that we saw before do you
see something weird about this code
besides that is groovy code what about
the method name the method name is a
string if you didn't know the JVM allows
you to have any type of characters in
the method name Java the language is the
word that doesn't well groovy gives you
back that capability what does it mean I
can actually have a multi-line
string as the method name so I can be
very expressive of what I want to say
with this method that's one of many
things that I can do with a spark we
have an automatic mock right there in
the middle we're mocking the service and
notice the parameterization we actually
use in a list of values that left ship
operator we got operator overloading
groovy yay we are just giving the amount
that's just one of many ways when we can
parameterize a particular test okay next
one we know we're dealing with
concurrency how do you test concurrency
what you know for a fact that you have a
background task and you need to wait
until the background test is finished
what do we do usually thread the slip
catch interrupted session hopefully we
give it the right amount of time out and
if we give it too much the test is going
to be very slow right what if we had
another way to test this what if we had
conditions that can wait at most certain
time out that's exactly what our tality
does so you can give it a condition
using lambdas on hankers matches on
something else so that if in this case
the method that we call in the
observable when we call controller all
right there if we wait more than two
seconds the test is going to fail if we
didn't get the result in this time the
get state method if it's not equal to
that value that means that is taking too
long
so failure but if it does then we
continue and we do the right assertions
this will be much much better than doing
thread asleep and hopefully that we got
the right amount of time out and finally
I said something about network would it
be okay for us to ping the github
service every time that we run a test
case like an integration test case or a
functional test case do we expect our
service to be always ready when we're
going to test something sometimes we can
sometimes we we shouldn't so why did we
were able to run a fake server setup the
the upper paid constraints in their
requests so if that request is match
they will current reply with a specific
response this is exactly why were mock
allows to
it will create a fake HTTP server when
we specify us with the final
specifications with that particular
request if we get a get call with such
URL that we going to response without
status with such headers and with that
content notice that we're using again
Jackson somewhere their repositories
Jason actually calls Jackson to encode
the list of objects as Jason and if we
get the other URL that's the next page
then we going to return with something
else right I can show you those tests
actually in action and I just do a clean
here and I'm going to run this now hands
on the keyword there are some unit tests
happen there one of them fails that's
okay and then we see that that's another
library called test effects testing
they're real application and this is
possible because we caught a fake server
running thanks to wire mark so I can
pull down the network and the test will
still continue to work and that's
basically what I have for you right now
for warm-up there are other libraries
out there there are other testing
libraries out there that I couldn't
cover in 50 minutes and just so you know
well this application doesn't cover
persistence doesn't cover more different
sets of communications and protocols but
at least have a look at these libraries
you probably have used some of them I'll
look at the others you might be able to
have better tests or better designs
using dependency injection or not for
that thank you very much you have any
questions I'll be happy to take them on
the hall because the next speaker is
coming up thank you very much for your
time
any questions alright I guess</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>