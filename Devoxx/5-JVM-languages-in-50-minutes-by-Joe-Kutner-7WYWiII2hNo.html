<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>5 JVM languages in 50 minutes by Joe Kutner | Coder Coacher - Coaching Coders</title><meta content="5 JVM languages in 50 minutes by Joe Kutner - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>5 JVM languages in 50 minutes by Joe Kutner</b></h2><h5 class="post__date">2017-04-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7WYWiII2hNo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so this will be a crash course on five
jvm languages in 50 minutes if I can
squeeze them all in but first I'm going
to talk about natural language so
hopefully everybody speaks English
because that will be helpful in this
talk so in English we have we use gender
when we're referring to an object that
has a gender right if it's a if it's a
man we say he if they're ones that we
say she but in Finnish and there is no
gender even if you're referring to a man
or a woman you're still going to use the
same pronoun and it turns out that this
difference in in the in the use of the
language affects the way people think
about their own gender so children who
speak grow up speaking Finnish tend to
become aware of their own gender later
in life than children who speak English
or especially who speak Hebrew where
they have a gender for just about every
object you refer to so the point of that
is the the language that you speak
changes the way you think another
example is in how we refer to the future
and the past so in English we have
different verb forms for the different
points in time we are referencing but in
a language like Chinese which is
referred to as a futureless language the
same verb form is used no matter what
point in time you're referring to so
literally they would say it is raining
tomorrow and again this affects the way
speakers of futureless languages think
so
speaker people who speak these
futureless languages tend to be better
at preparing for the future the idea is
that if the future is the same as the
now it's harder to procrastinate so
futureless language speakers tend to
have better health they tend to save
money better and they're more likely to
wear a condom so it's the the point is
that natural languages change the way we
think and there's actually a name for
this it's called the Saviour Whorf
hypothesis if you saw the movie arrival
it's mentioned very briefly in there but
I have a hypothesis that the programming
language
choose change the way we think about the
problems we're trying to solve so given
two given the same problem in trying to
solve it in two different languages you
will come up with two different
solutions and one might be better than
the other so today I'm going to talk
about five jvm languages that can change
the way you think but first I'd like to
talk about myself I'm Joe Kutner I go by
code finger on IRC and Twitter and all
the web places I have worked with or hi
have built and maintained production
applications in four of these languages
all of them except Kotlin the one I have
the most experience with is JRuby I
wrote two books on deploying G would be
applications but today I work at Heroku
where I am the JVM or Java languages
owner so I'm responsible for making sure
that all these languages work on our
platform as a service and that our
customers who are using them have a good
experience so my day-to-day work is
basically helping people with their
problems related to Java and these other
languages each of the technologies I
talked about today can be installed with
SDK man if you're on a bash based system
so this is very easy if you are on Mac
but also works on bash for Windows if
you're using Windows 10 SDK man is a
tool for managing different versions of
software tools at the command line it
can be used to install Java as well as
all of the languages we'll talk about
today so if you see a command that
you're not familiar with it means I
installed it with SDK men the first
language I want to talk about is groovy
and for each of the languages that I
discuss I'm going to make an analogy to
a character in films or in movies groovy
is like James Bond it is a little
adventurous it's very good at getting
things done but in order to get things
done it occasionally has to break the
rules so it's you know sort of doing the
wrong thing for the right reasons though
it's also a little sexy and
sophisticated so James Bond wears a suit
while he's getting things done Groovy's
sophistication is that you can actually
write Java code in a groovy script and
it is valid syntax so the groovy syntax
is a super
of the Java syntax but groovy is also
just groovy it's dynamic it's very fun
to use
it's object-oriented it's dynamically
typed and it's strongly typed so that
puts it in this kind of interesting
quadrant in programming language
taxonomy where it's not as loosey-goosey
is something like JavaScript but it's
not as rigid as the Java language so
let's take a look at some example groovy
code this is valid groovy code it also
happens to be valid Java code if we were
to put this into a example groovy script
and run it we would get a result but we
would not have to compile it because
groovy is an interpreted language
it can't be statically compiled but the
examples we'll look at are interpreted
so in this example we just have a a
class with a main method and inside of
that main method we're iterating over
some integers adding them up and
printing the result but while this is
valid groovy it's not idiomatic groovy
if we want to make this more groovy
esque we would the first thing we would
do is remove the semicolons those are
optional in groovy then we would we
could remove the class and the main
method that's boilerplate that's not
required in groovy we can also clean up
that for loop we can use the in keyword
to iterate over a range of integers that
we create using the dot dot notation we
can also get rid of the system dot out
before our print line that print line
method is globally available we can also
get rid of the parentheses around the
argument store method so again with
groovy the idea is to remove as much of
the boilerplate as much of the
characters that we don't need as we're
building up our applications so this now
looks more like true groovy code but
it's also kind of a useless example
let's say we want to parameterize this
so we can reuse this method we would
look we would put it into a method I'll
call it gasify because Carl Gauss is
known for like this algorithm for adding
these things up we could have created
the method with a public void like we do
in Java but instead here I'm using the
DEF keyword which defines a dynamically
typed method so dynamically typed means
that I do not have to specify the return
type of this method nor do i specify the
type of the arguments that are being
passed in so in this case I'm passing in
a which is an initial value and R which
represents my range but the runtime
itself doesn't care what the type of
those objects is so what that means is
that is valid for me to pass in things
other than integers I can pass in
strings for example which can also be we
can also create ranges from from a
string or from characters but if I were
to run it as it is now I would actually
get a groovy cast exception because in
the first line of my method I'm setting
the initial value to a temporary integer
variable but I can fix that by instead
of defining the type of my some variable
using the DEF keyword to define a
dynamically typed variable and when I do
this I can invoke the method with any
type of object the groovy runtime
doesn't care as long as it responds to
the methods that that it needs to in the
in the body of my method the so the use
of the for loop and the temporary some
variable is still very Java like in its
nature to be even more groovy like we
would use the the inject method on the
range class so range is a collection and
all these collections have this method
inject which takes the values in the
collection and reduces it to a single
value and does that by accepting an
initial value which is a and then an
anonymous function which performs some
operation on every one of the values in
the collection carrying over the
previous result so in this example the
anonymous function is represented by the
curly braces we have two arguments to
that anonymous function sum and I and
then the arrow notation indicates the
beginning of the body of that of that
function so if you don't completely
understand that that's okay we're going
to come back to this type of pattern
again in some other languages
now our groovy is a great language to
use for building web applications and
there are frameworks like spring boot
and and Grails that groovy works with
very well but I think a framework that
best exemplifies the strengths of groovy
is rat-pack so rat pack is a micro
framework a very light framework for
building high-performance HTTP web
applications and web servers the idea is
it gets out of the way and lets you
write your code and provides facilities
for things like asynchronous and
non-blocking i/o so we can install rat
pack with sdk man or we can stall
lazybones with sdk man and we can use
lazybones to create a template rat pack
application I'll call this dev ox that
template application will be Gradle
based Gradle as the build tool and now
get analogous to maven but it uses the
groovy language instead of XML to define
your project structure so you can see we
have a build dot Gradle which is a
groovy script defining our project and
then a rat pack groovy which is sort of
the entry point to our application that
default rat pack groovy script looks
like this it makes a few import
statements like we would in a java java
application we import a static method
called the rat pack and then we invoke
that rat pack method and pass it what is
technically an anonymous function
represented by the curly braces and then
inside of that we call other functions
or other methods and pass them these
anonymous functions and that's that's
mechanically what we're doing but in
reality what this is created is a
domain-specific language in which we can
declaratively describe the rat pack
application we're building out so in
this example we create the rat pack
application we're binding a module to
our application that allows us to do
some markup template stuff we define a
list of handlers in this case I'd have
just the one get handler that responds
to all HTTP GET requests for the
application and then it renders this
indexed GT PL file which is the groovy
template language this is another
domain-specific language this is the
index dot GTL file this is a
domain-specific language for building up
HTML using groovy code so again we're
nesting the the methods that correlate
to the HTML tags inside of each other in
the same way we were with our
declarative groovy script many people
like this because it allows you to use
the groovy syntactic sugar as you're
building up your HTML personally I'm
just
the fan of it I'm okay writing HTML so
that's a great example of how groovy can
be used for domain-specific languages
but it's also used for more powerful
capabilities like non-blocking i/o so in
this example I'm creating another
handler for my application I want to get
all of the dogs that are in my database
and it turns out there's a lot of dogs
in my database so this operation could
take a long time this select star from
dogs could take minutes or more so when
a get request is sent to my slash dogs
path I don't want that thread of
execution to block while the database is
doing its work I want to free it up so
that my my web server can go and go off
and handle more requests while the date
of Walt's waiting for the database
so what groovy or what rat pack provides
for us is this blocking class and it's
get method and we can pass an anonymous
function to the get method and inside of
that anonymous function do some work
that is blocking and that the blocking
class will go and execute that anonymous
function on another thread and then when
it completes it'll execute another
function this the one that we pass to
the then method where it will render the
result of that database query so in this
way we get all the benefits of
asynchronous programming but we don't
have to or but we still get the
guarantees that we that we want with an
imperative language where we're having
one thing execute after another all
right so the strengths of groovy are
that it's lightweight it's very easy to
use it's very quick to get things done
it's dynamically typed it's object
oriented it has a flat learning curve
which means that if you know Java your
transition to to groovy can be very
linear you can start by writing just
pure Java code and ease your way into
the syntactic sugar of groovy it also
has great Java Interop so if you're
using groovy you can continue to use all
the languages or all the libraries that
you're used to and enjoy in Java the
weaknesses of groovy are that it's
dynamically typed so this is both a
strength and a weakness depending on
your perspective and it's also
interpreted depending on how you use it
of course it can also be statically
compiled but
you know it's something to consider when
you're when you're choosing it now if
you like the syntactic sugar of groovy
but you are not a fan of this dynamic
typing that brings us to Scala
which is a bit like the board so Scala
has gone around the programming universe
and it's assimilating all of these
different programming paradigms into a
single hybrid language Scala is both
functional object-oriented it's also
statically typed and has type inference
so it's this combination of things that
we don't think of fitting together
normally so to demonstrate Scala I'll
use the Scala repple which is a read
eval print loop when we run the scala
command we get this scala prompt where
we can write Scala code and have it
executed immediately so to demonstrate
this type inference that I referred to
if we create a new variable in Scala we
use the VAR keyword we create a variable
I of type integer but we could also
define that variable without specifying
its type and assign it of value
but unlike groovy in which the type is
dynamic and we don't care the runtime
still retains a type for this variable
so if I attempted to reassign this
variable as a string I would get a type
mismatch error because it is not a
string however I could reassign it
another integer value that would be
valid and it's valid because this
integer or this variable is mutable I
could also make the variable immutable
using the Val keyword and this creates a
variable similar to a final using the
final keyword in Java and if I were to
reassign an integer to this variable I
would get a reassignment error so Scala
has a number of facilities for making
your your classes and and objects
immutable it also has a great deal of
syntactic sugar for example we can
create ranges using this notation of 1
to 100 but the syntactic sugar in this
example is not actually the 2 or the 2
keyword 2 is actually a method and the
syntactic sugar is that in Scala the dot
and parens notation for invoking a
method
is optional so this allows us to do some
very powerful things with operator
overloading because if you're calling
Plus or star or some other thing that
would typically be an operator it's
really just a method call it also has
this underscore notation which we can
use in our anonymous functions so if we
wanted to do a similar operation as we
saw with the Gao safai method and in
groovy we would call fold left which is
analogous to the inject method we passed
an initial value and then in our
anonymous function that's going to be
executed against every one of the
elements in our collection we would call
underscore plus underscore these
underscores reference the arguments
passed into this function so this line
of code is identical to the one below it
in which some and V are explicitly
spelled out as parameters but as long as
we reference them in the right order we
can shorten it to this underscore
underscore notation this can be very
confusing especially when reading other
people's code but it's also very
powerful
so most people aren't using the scala
wrap all day today they're putting scala
into dot scala files and structuring
things into classes and compiling them
with SBT which is a build tool like
maven but for scala so this is just a
simple example of a class the class
itself has arguments so to speak in this
case we have a name and a surname as
sort of arguments to the class and Scala
will define constructors and methods for
like sort of like getters and setters
for these properties so Scala can be
used to create web applications there
are a great deal of web frameworks that
are that are useful with Scala but I'm
sort of not interested in making a
compelling argument for using Scala for
web applications I think groovy and some
other languages are better suited to
that I do think Scala is a great fit for
big data specifically with Apache spark
so Apache spark is sort of like the new
MapReduce you have a master node and
then it distributes some work off to a
number of slaves which do their work
compute some result and then return a
value or something back to the master
which roles everything up so I have a
great example
of a complete spark application that
estimates the value of pi' and you can
just clone this and run docker compose
which will set stand-up the whole master
slave architecture of Scala and estimate
the value of pi but inside of that
example is really a single class which
is actually a singleton class which we
can define with the object keyword in
Scala it has a main method and inside of
this main method for the job we're
creating a spark context so every spark
application has a spark context in the
same way that like a web application
would have a request context we call SC
parallel wise so this algorithm for
estimating PI is sort of like throwing
darts at a dartboard and then just
seeing which ones are closest to the
circle so paralyze is going to split up
the different sections of our circle and
send them off to the different slaves
and our in our in our system then each
of those slaves is going to perform some
calculations so this is the anonymous
function that we're passing into our
peril wise and then finally the result
will come back and we'll call reduce and
again use this underscore plus
underscore notation to come up with an
estimate of Pi all right so the
strengths of groovy or I'm sorry of
Scala are that it is functional has
great support for concurrency and has
great facilities for immutability it
also has static typing which you know is
preferable for some people the
weaknesses of Scala is that it has a
steep learning curve so all this
syntactic sugar all of these different
paradigms make it difficult to learn
Scala it also lacks orthogonality so
orthogonality is a characteristic of a
programming language in which it uses
very few constructs to do lots of
different things
Scala can do lots of different things
but also has lots of different
constructs so therefore it lacks
orthogonality static typing can also be
seen as a weakness based on their
perspective I also find two weaknesses
to be mutability so while Scala has
these facilities for immutability you
also have the ability to shoot yourself
in the foot at times and I also find
that Scala has poor Java Interop so if
you go to a talk on Scala
you will be told that that Scala has
great Java and drop you can call Java
libraries and whatnot
but by comparison to languages like Ruby
were and and JRuby as we'll see where
it's very seamless very often when
you're dealing with Scala and Java
libraries you have to for example
convert maps and lists into Java maps
and lists and then when you get values
back you have to convert them back into
your your Scala equivalence so you end
up with a lot of glue code and there's
even a class in the Scala standard
library called Java conversions which
kind of facilitates all this so if you
like the functional nature of Scala but
you're not interested in or you dislike
the lack of orthogonality closure is
another language to look at so closure
is a bit like Yoda when we first see
Yoda in Empire Strikes Back we're like
this guy is kind of odd we don't
understand that he's even important and
that's I think very similar with closure
it's it's full of wisdom like right
Yodas like this kung fu master right and
and closure has this sort of elegance
and beauty to it but it's also
unassuming closure
well Yoda is also very old closure is
not old but it's an implementation of
Lisp which is pretty much considered the
second oldest still in use programming
language behind Fortran and Yoda also
has this funny way of talking you know
understand me later you will and closure
is similar in that it uses prefix
notation so when we're doing something
like adding up numbers we don't say four
plus two we say plus four too and the
reason for that is that everything in
closure is a function even the plus
operation so plus is really a function
and we're passing arguments to it so the
processing this sort of a different way
of saying things can be can be
challenging at times so closure is
purely functional everything as a
function and it also is very strongly
immutable you actually have to go out of
your way to mutate things so we'll play
around with closure using another repple
another read eval print loop and we'll
run that repple using line again so you
don't actually install closure nobody
installs closure it's more of like a
library that that is
fold into an application and we pull
that in the easiest way to pull that in
is with line again which you can install
with sdk man so when we run line ripple
we'll get this user prompt which is our
repple prompt and we can start writing
closure code and have it evaluated so we
can run 4 plus 4 plus 2 or make other
function calls and pass them as
arguments into our other function calls
again nesting these parentheses which is
sort of the signature of a lisp or of
closure while everything is a function
in closure under the hood we're still
dealing with objects so if we call the
class function what we're really doing
is asking the number 42 what its classes
and we would find that it's a long or a
string aside aside from the functions in
closure there are a few special forms
just a few things that are not functions
and those include the if special form
but even when we use these special forms
we're still using them in the same way
as if they are a function so this if
special form takes a conditional which
will evaluate to either true or false
and then it takes another function call
which it will evaluate if the condition
that's passed to it is is satisfied so
this is sort of unlike you might see in
a method call in Java or something else
where you would expect this print line
to be executed no matter what happens in
the if special form but the special form
is special because it's lazily going to
evaluate that print line call if one is
not or if that conditional is not true
we'll never see the yes printed out we
can also pass in a second function call
which will be evaluated if the if the
conditional return is false
so because everything in closure is a
function and we're not going to
typically deal with classes we have to
have a way in which to structure our
data in which we sort of contain it and
pass it around
and that's why closure has great support
for collections and other types of data
structures so we can create range we can
create a range with the range function
we can also create lists with the list
function and we can also assign these
data structures as variables using the
DEF special
form so this is one of the other special
forms so if we were to call this list
numbs we could then use the first
function to get the first value of it we
could use cons to add a value to the
front of it so cons is interesting
because it stands for construct and
that's important because as I said
everything in closure is immutable so
when we're adding a value to the front
of a list we're not actually mutating
the list we're constructing a new list
so we can check and see that num still
remains the same again everything being
immutable in closure we can also create
maps sort of like hash maps and Java and
then we can define those as a variable
the map itself is a function as well as
the data structure so we can call the
person variable as if it were a function
pass it an argument and get a result
back in this case the the name for the
for that key but the key word here this
was sort of like a symbol is also a
function and we can pass it our variable
and get a result so again everything in
closure is a function all right so well
well unlike Scala in closure
you really do use the repple on a
day-to-day basis most closure shops
where people are building and using
closure on the day to day to day basis
they're doing what's called repple
driven development and that is where you
you have your code your closure code and
dot clj files but you're sort of
iterating on it and working with it by
executing it continuously in this in
this rebel so it's very similar I think
to test-driven development and where
you're running your tests constantly but
in this case you're actually executing
these small functions that you're
building up and that's made possible
because everything is a function they
don't have side effects and because
things are immutable so here's an
example of creating a clj file that's
going to gousa phi again it's going to
add up a bunch of numbers and print out
the result but in functional languages
things like for loops are kind of app or
looping is not really something that is
seen as a good thing or is used in in
functional languages recursion is
favored so this is a recursive example
of adding up these number
and if we wanted to execute this we
would load our file into the repple and
then we would run calcify and pass it a
range now this function would work for
very small ranges but as soon as our
range starts to get up to the hundreds
certainly the thousands we're going to
get a stack overflow error because each
time we were cursed into this function
or creating a new stack frame which
incurs you know more memory and
eventually we run out so many functional
languages can optimize that it's called
like tail call optimization and sort of
flatten it out so that we're not
creating new stack frames but
unfortunately a closure can't do that
due to limitations in the JVM so it adds
a couple more special forms that allow
it to have this sort of recursive nature
nature without creating the stack frames
and even though we don't want loops in
functional languages this special form
is called loop so this is a sort of a
reboot of that previous function but
using the loop special form loop defines
sort of a point in which we can recurse
to within our function so the loop
special form takes four in this case
four arguments they're actually two
arguments with default values so val is
our first argument the default value is
a subset is our second argument and its
default value is our so inside this loop
we're checking if the subset is empty if
it is empty we're going to return the
default value and if it's not we're
going to recur which is another special
form that will send us back to the
beginning of the loop but with a
different set of arguments in this case
we're going to add up the the first
value and then pass on the rest of the
range as a subset and again just load
this file into the repple and run it so
closure is used to build many types of
applications including web applications
but in all cases we're not going to use
frameworks so frameworks in closure or
the word framework it's kind of like a
dirty word too if something is purely
functional it should be possible to use
everything as a library and that's
because everything is a function they
don't have side effects and we have this
strong immutability
that said you need a way to conveniently
build up an application so there are
sort of non frameworks that pull
together a number of different libraries
and using a number of conventions set it
up in a way that just works very well
but it's not a framework don't call it a
framework you'll get in trouble so we
can use a line again to create a new
Luminous oh I should say luminous is my
favorite of these sort of non frameworks
we can use line again to create a new
luminous application line again knows
where to find that template and it will
generate a new line again project so
again line again is similar to maven
except that instead of XML to define
your project structure it uses closure
so we have a project clj file which is
analogous to our pom.xml luminous also
spits out a docker file proc file and a
bunch of other things that you need for
typical applications the resulting
template is sort of a fully functioning
application we can open it up in a
browser after we run line run and use it
it'll connect to a database when we
started up we'll also see that it's
starting an N repple on a particular
port this n repple or network repple is
a service that we can connect our repple
in an IDE or an Emacs or something so
that we can connect to this process and
and execute things in the repple in a
sort of live fashion and this is how
most closure developers are doing there
there repli'd Riven development so if we
look inside this luminous application we
have a WebGL J file which is sort of
like again like the entry point like we
saw with ret rat-pack
defines the sort of layout of our
Luminess application we have a number of
routes that handle get requests and
those are just mapped to functions which
will then return some results so if we
were to load this file into our repple
that's connected to our RN repple we
could call each of these homepage or
about page functions and we would get
back a map that includes our status code
and our HTML so most closure developers
are taking applications like this
breaking things down into smaller
functions and then running those
functions in the repple loading up their
changes in and and just constantly
iterating
so the strengths of closure are that it
is functional purely functional it's
highly orthogonal has strong support for
immutability and for concurrency its
weaknesses are also that it's functional
and it has a very steep learning curve
so as you've seen it's very different
from what you're used to in Java or even
another jvm languages like groovy makes
it difficult to learn it's a little
difficult to read and it's it's not very
accessible so these are challenges for
shops that are trying to adopt closure
as a language of choice I think this is
kind of exemplified by a great xkcd
comic this guy is reading a book on Lisp
and he falls asleep and he has this
dream where he sees the universe exposed
in all of its patterns and meta patterns
like you know these sort of pure
functions that have no side effects and
he thinks to himself this must be the
language from which the gods wrought the
universe but God says no well it's
ostensibly yes but we really just hacked
it together with Perl and there's some
truth to this in that closure and these
lips are so elegant and beautiful
they're highly orthogonal but the end of
the day you just need to get stuff done
sometimes and I think there's no better
language for just getting stuff done
rapidly writing code than Ruby and its
counterpart JRuby which is Ruby for the
JVM JRuby is like Mary Poppins it's just
kind of shows up from outside of the
Java ecosystem and it brings in a
spoonful of syntactic sugar that lets
you just very rapidly build applications
and and enjoy writing code JRuby is like
I said it's coming from outside of the
JVM ecosystem so this is the one tool in
which we can't use SDK man to install
you can either go to juvie org to
install JRuby if you're already kind of
familiar with the Ruby ecosystem you can
use our VM or tools like that these are
Ruby tools for managing Ruby runtimes
what they also manage to you Ruby the
Ruby syntax is almost identical to the
groovy syntax in many ways and that's
not a coincidence like they rhyme for a
reason I think the groovy language is
inspired by by room
itself so if we're to have our gasify
method we would use the DEF keyword to
define a method it's dynamically typed
so we don't have to specify the return
type or the argument types we also have
an inject method and so on the only
difference I can see here is the the
syntax for creating that anonymous
function or what's called a closure ruby
has this do and then pipes notation for
the arguments and then the body of the
of the method so we would load this or
put this code into an example about our
V file and then run it with the Ruby
interpreter if you're using most tools
to install JRuby you're still going to
run the Ruby command even though you're
using JRuby one of the real powers of
Ruby is its ability to do meta
programming that is code that writes
code so to demonstrate this if if you
want to build a class or a class that
has methods for Roman numerals and you
want to be able to handle every method
call that is a Roman numeral that would
be a difficult challenge to statically
code there's many many combinations
maybe infinite combinations of Roman
numerals but in Ruby if a method on a
class doesn't exist
it actually takes the name of the method
that's called and passes it to another
method called method missing so in this
method missing which you can override
you can sort of inspect the name of the
method it was called and then apply some
logic based on it so in this case I'm
taking that name of the method splitting
it out into the different Roman numerals
and then doing some math and in that way
I can handle any any Roman numeral call
this mechanism is used in the framework
Ruby on Rails to make a to make classes
that essentially have no code so active
record which is a part of Rails which
I'll talk about in a second allows you
to extend the class give it a name and
then it can have all kinds of behavior
without literally without writing any
code it's not atypical to see an actual
class and of in a real application that
looks like this active record
dynamically defines the methods and the
properties and the behaviors of this
class based on
convention so it looks at what is in the
database and derives it from the schema
Ruby also has a mechanism called
modules which solve many of the same
problems as X aspect oriented
programming where you can take
cross-cutting concerns or these concerns
that that cut across all the different
classes and you can apply them into your
into your classes without disrupting the
inheritance hierarchy so the best
example this is logging every one of
your classes is going to do some kind of
logging but you don't necessarily want
to have everything inherit from a base
logging class the more sort of canonical
example is the duck methods where you
want a person to quack or you want if
this comes from the the term duck typing
where a an object in a dynamic language
and object how do you know if it's a
duck it's a duck if it quacks so if we
want a person to fit the duck sort of
expectations we can include this module
and allow it to quack so as I mentioned
Ruby on Rails is the most popular ruby
framework I don't have time to go too
deeply into it but it's also the
probably the best documented of the
frameworks I've talked about today you
can once you have JRuby installed you
can gem install rails run rails new and
create a complete application
so this rails is really designed to do
so many things for you that you don't
have to write a lot of code it generates
models controllers views if you're doing
a REST API you can generate the JSON for
you
does database migrations WebSockets
asset pipelines and this is really best
exemplified by the rails generate
command in which you can run rails
generate scaffold scaffold give it the
name of a resource which will generate a
model object and all these other things
without having to write any code all
right so the strengths of Ruby are that
it's lightweight and dynamically typed
just like Ruby it's still
object-oriented has a good typing system
it's easy to learn probably the easiest
to learn of the languages we've seen and
it has good Interop with the Java API
so when you're invoking methods on a
Java library that is very seamless but
on the weaknesses side it's not great in
integrating with Java dependencies so as
I said it comes from outside of the Java
ecosystem so if you want to include like
a maven dependency in your JRuby
application that can be challenging its
weaknesses are also that it's
interpreted and dynamically typed so the
interpreted part does incur some kind of
performance hits although most people
will argue that it's negligible all
right the next language we'll talk about
the last language to talk about is
Kotlin which is a bit like harry potter
it's sort of the new kid on the block
has a lot of potential but right now it
still kind of needs her my own Ian to do
anything of consequence so Colin is
object-oriented it's compiled and it's
heavily influenced by its predecessors
so as we learn about Colin we're gonna
see a lot of syntax and features that
you can point to and say ah that comes
from Scala or that comes from groovy so
we'll look at some simple Kotlin code so
this is again doing our iterating over
integers and adding them up we have a
for loop that looks a lot like groovy we
have the N keyword and dot dot notation
but we're defining a function with the
fun keyword our our argument types use
this colon followed by the type which is
similar to scala so if we wanted to run
this we would sdk install Kotlin oh I
didn't show that I'll show that in a
minute
so here's an example of a Kotlin class
again a little bit like scala where
we're passing these sort of properties
into our class definition it can
automatically create constructors and
getters and setters but we can also
statically create our own constructors
one of the most interesting things about
Kotlin to me is the it's null safety so
by default an object or a variable
cannot be set to the value of null this
would actually result in a compile time
error so if we were to put this code
into example Katy and then run Kotlin C
we would get an error because we're
setting it to null we can optionally
make things nullable using the question
mark at the end of our type which will
then allow us to to make that work
now this essentially prevents many of
the most common errors in Java programs
that being null pointer exceptions okay
so each of the languages that I've
talked about today again can be
installed with SDK man actually Java
itself can be installed vesti came in if
you're not using a bash system if using
Windows 10 this works really well on
bash for Windows 2 if you want to learn
more about each of these languages these
are some resources there's groovy
Cohen's so Cohen's are these little
short examples in most cases you can do
them on the web and they'll just walk
you through some of the syntactic and
and other features of the language
closure Ruby and Kotlin all have Cohens
for Scala I'm not aware of like a Cohens
type thing but Scala Center has a great
number of resources as well so again my
name is Joe Kutner work at Heroku and
thank you for coming
questions well so I definitely like my
favorite is Ruby but that's more based
on my personal history I mean like
though I actually enjoy your writing
closure code more than anything but I
very rarely use closure day-to-day and I
think that's I think that's a result of
its accessibility it's hard to get other
people to write closure code
yeah it's so yeah I was intentionally
short on it because I feel it's sort of
yet to be determined more and more so
just at this conference I've talked to
more and more people that are using
Collin for Android development and I
think that is probably one of the
emerging strengths so Collin was created
by Jeff Raines and of course they're
using it to build their IDE and so I
think it fits very well into
applications that are heavily sort of UI
based write that as a good support for
asynchronous features and things like
that that's my take but I think it's yet
to be determined so closure script uses
the closure syntax but it transpires to
JavaScript and so it gives you all these
same expectations that you would have
when you're writing closure for the JVM
but at the end of the day it's a
completely different implementation the
the main advantage of closure script is
this sort of isomorphic thing that the
the node.js people are always trying to
get where you have the same code on the
on the client side is on the server-side
I don't know if that's a pipe dream or
if it's really something that's possible
but I do think that using closure script
with closure backends is a good path
towards AB yeah let's say it again expel
it no I haven't I haven't even heard of
it so this is a GBM language okay yeah
there's so there's there's many more
emerging jvm languages I wanted to focus
on ones that were a little bit more
proved out like I said four of these
I've used in production I know that
they're solid and production ready but
yeah I keep seeing new ones extent is
one what's that okay well that's it
that's interesting
uh-huh yeah okay so that yeah that's a
that's a great another option to look at
another one that I think is interesting
is freaky which is sort of like a
Haskell type of language but again needs
more more proofing out all right well
thank you for coming we don't have our
Roku booth anymore but I'll be hanging
around if you want to chat about Roku or
JVM languages</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>