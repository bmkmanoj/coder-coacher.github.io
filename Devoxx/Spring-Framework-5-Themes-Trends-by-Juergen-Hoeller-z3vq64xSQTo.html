<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Spring Framework 5 Themes &amp; Trends by Juergen Hoeller | Coder Coacher - Coaching Coders</title><meta content="Spring Framework 5 Themes &amp; Trends by Juergen Hoeller - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Spring Framework 5 Themes &amp; Trends by Juergen Hoeller</b></h2><h5 class="post__date">2017-03-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/z3vq64xSQTo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so now we go on with our next talk
which is on Spring Fling from five six
and trends by a gook and holder yeah
testing G yeah G audio works great well
Eric quick turnover from the previous
session I hope you don't mind
welcome from my sites the the purpose of
this talk is a bit more strategic than
than some of the other spring talks you
might have seen elsewhere
I've made this talk themes and trends
spring from expire scenes and trends
because we are in the process of
releasing spring from across the dough
we are now at milestone five we are
assumed to to enter the release
candidates face in in April and the
springs are mcfife Ernie's like any
major spring release is very much driven
by well certain themes and trends so
spring doesn't zip in on the island it
never did right spring is very much in a
framework establishing itself really
stepped it constantly reestablishing
itself
in the wider ecosystem out there in the
industry out there and picking up
industry trends at well an ideal time
idea at a good enough time the
motivation in Springs number five is of
course to pick up latest generation of
the JDK the latest generation of several
other specifications in the Java
ecosystem and general industry trends I
would argue reactive programming and
functional composition styles so before
we dive into the actual themes let's
quickly recap the state of the art very
first thing this is what we are right
now spring from explode to three is our
production release already out for well
almost on a soon-to-be a year basically
we started the release candidate phase a
year ago and this jelly June last year
for the three basically is evolving into
the same role that spring from a three
to two head for several years it's going
to have an extended maintenance life
it's the last for the next feature
release that won't be afforded for
actually we weren't even sure whether
there are the would be for the three we
decided on the for the three rather late
and this already brings us to today's
topic for the three is intentionally a
kind of pairing with iPhoto to some
degree for the tree is a sort of early
back board of features which otherwise
would only have ended up in faster
though the idea is that we brought those
things not only forward to 2016 and they
are already available
we are not so not just timing wise we
brought them forward we also brought
them into the spring Cermak for system
requirements anything that we did in for
the three in particularly refinements
too near to the annotation based
component model you can essentially run
on on wealth to the K six seven eight on
even a servitude advice container if you
insist the motivation to do so seems to
have turned out well because we always
very numbers driven we evaluate the
download statistics on maven central
this is the past year the spring cool
downloads from maven central the spring
core after sex as a reference point for
typical Spring Framework usage another
bad trends I'm not sure where that trend
is going actually emails like thirty
proof but the I'm not sure where that
rice comes from we are likely with any
statistics only taking the indications
as they come we actually don't know how
they come about right but with a freeze
of really important release what we're
not seeing here is that in Kerala to the
spring for McFaul the free release we
did a spring boot one to four as spring
boot one looks five picking up the
latest spring from ik for the three
releases
corresponding spring cloud releases
spring is the front of the Spring
Framework is the foundation for an
entire ecosystem and the indications for
spring frame with usage translate very
much to the ecosystem and that driven by
the ecosystem by by spring good usage in
particular these days
so in all applicable brevity just a few
isolated spots this is a general
component class in spring shouldn't
shouldn't look out of the ordinary but
the comment is out also wise constructor
is a hint at four to three as of spring
so marks for the three you don't have to
declare a constructor as Auto wired if
there is only one which is clearly
designed for dependency injection
purposes so that's a nice refinement in
general it's actually particularly nice
is a class otherwise doesn't have any
annotations on it so here we can see
other imitations but in a class just
doing dependency injection a little
delegate components being registered
with the container it's quite nice to
design them even in the annotation based
model in general to design them without
the need for annotations for
documentation purposes for self
description purposes I nevertheless
recommend to annotate is actually but
this is one of the refinements we get in
photo three on a related note in just
indicating where we take refinements to
a configuration class like this didn't
actually work like this very specific
one this'll actually work pre for the
three this configuration class defining
a tree method actually has a constructor
of its own a custom constructor
a constructor asking for dependency
injection storing the data cells in the
fields and picking it up from the admin
method again just didn't actually works
because
configuration classes are subclass at
runtime through the dilip and it took
special effort on our end to make the
key overriding work here that to
recreate a subclass variant of that
constructor so this is a refinement that
really makes sense from a consistency
perspectives anything you can do to
regular component class in the spring
component model you should be able to
apply to a configuration class because
configuration classes are just rather
the component classes with a special
purpose otherwise they have the same
kind of lifecycle the same kind of
injection management as any other
component type in the spring container
and of course along with the previous
refinements you can have a custom
constructor accepting other references
and you do not even have to annotate it
you can annotate it with adulter wires
but you don't have to like with a
regular component classes for the three
another refinement this is already all I
mean to to show from for the 3ds there's
a lot more just just really those two
areas this is a spring MVC controller of
the more traditional kind like for the
two level in for the three we introduced
variants of the mapping annotations
called get math mapping post map input
mapping patch mapping delete mapping as
an alternative to request mapping so if
you compare those directly you see the
brevity there is a little bit of
sweetness in there to be found in there
in Java in Java 5 sanitation design if
an annotation only accepts the single
attribute you can declare it such that
the attributes names value and you don't
have to name the attribute here so
there's no need to say like value or
path equals books idea this is pretty
primary benefit of baking the HTTP
method into the actual name of the
annotation so that the typical
specification of attributes is reduced
to just a toss you can still add confuse
and produces courses but in simple
straightforward cases there is a really
nice short cutting and actually
readability improvement coming here this
is a fine example but what or what we
call composite line notation a general
Springs iMac for theme you can build
custom annotation meta annotated with
standard spring annotations expressing
your particular needs in a type of iran
essentially get mapping and post mapping
in code i just compose a plantation
you can build such shortcut annotations
yourself no problem whatsoever we just
decided to ship them out of the box
based on the very same generic mechanism
decided to ship them out of the box
because this has been a common
requirement and it's actually nicely
aligned with other endpoint annotations
in spring like for the stomp protocol on
a WebSocket channel we have message
mapping and subscribe mapping
annotations particularly purpose mapping
limitations we have equivalents here now
in spring embassy so this is a 4:3
introduction the you getting you get the
point right the for the three feature
set here could has been the five the
door in quite a few perspectives in
other projects maybe it would only have
materialized in a new major revision but
we decided to sneak them into full of
three because they are very
straightforward from a technical
perspective and they are really nice
refinements to a central Springs iMac
for theme which is the annotation based
component model and composable
annotations in particular now in
springtime at 5:00 we're taking a
different perspective spring Cermak 5 is
a not only an opportunity to raise the
baseline to like Java 8 plus and
essentially to a Java EE 7 oriented
baseline like requiring server 3 that
one JP 8 to that one and Co this is a
particularly important part of course of
what we are doing we're cleaning up the
codebase we can use 3d ki8 Java 8 API
and Java 8 language features inside our
production code base for the first time
I mean this is great right but for right
not necessarily for application
development because for application
development we've already supported your
efforts to use gdka and Java 8 API types
we've already supported everything from
functional interfaces
down to the Java the time types to
optional signatures to completely future
signatures we were already reacting to
your use of Java 8 features we just
could not use it in
anything but if you're a Java 8 user
you've already been able to do almost
everything that we typically want to
enable on on spring/summer for the 3 so
5 is really more of an internal two
decade upgrade an important foundation
for the years to come for us it does
have the benefit that we can expose
certain Java 8 API types in our studied
interfaces aesthetic interface
signatures now we can have methods on
for example generic application context
accepting suppliers Java util function
suppliers a JDK 8 introduced type we
couldn't do this before we could only
reflectively support such GDK types so
so much for the based on operators
there's more
we have changing with 5 support but the
the focus of Swing sum of 5 is very much
driven by infrastructure themes and this
is already forward looking at its JDK 9
it's the evolving service for those
specification actually more importantly
its requirement for HTTP 2 it's a new
language is we're embracing as an
alternative language for application
development and spring in the form of
coupling spring stomach for had a strong
focus on not only on Java 8 in
application code but also on groovy and
an equally first-class treatment you can
expect so coughing here in spring formal
class and it's about the functional and
reactive themes that I've been hinting
at before so a few just a few little
further insights into the main themes
let's start with Cherokee 9 JD King 9 is
coming up very soon now I mean let's
hope it's actually happening at the end
of July there are no guarantees in the
software space and there are no
guarantees with Cherokee 9 in particular
if you follow this the evolution of its
world map but let's assume it's
happening at the end of July it's
already in the ramp down phase so we
have a very stable
environment - to test against we've
already been tracking gdk9 for one and a
half years so in Spring Framework land
even Spring Framework for the three is
entirely compatible with JD King 9 - the
best possible degree at this point
there's just very minor glitches in
third-party libraries but we're even
testing those in integration so gdk9 in
general is always about the module
system about cigarette so let's let me
invert this bring the most important
part first JDK 9 is not just about the
module system JDK 9 has a lot of
goodness a lot of refinements both in
the runtime infrastructure and to some
degree also for from the development
experience perspective there are worse
embracing let's upgrade to ADT 9 let's
plan our upgrades of Cherokee 9 holding
on to dedicated forever is not an option
the easiest upgrade path is on the top
password take an existing Java 8 base
that spring application move it to JDK 9
just started there don't even recompile
it let's compile it with target 1/8 and
run it on to ADT 9 and you're going to
get quite some quite nice transparent
benefits you can benefit from the
compact string story presentation at
runtime from the garbage collection
improvements from the simplified stack
setup for web applications you can use
JCL if you want you can use the
collection factory methods if you're
upgrading to the Java 9 source code
level all of those things work very
nicely with existing
modern frameworks and libraries the
latest versions ideally without having
to even touch the module system much at
all
stay on the class bus and the upgrade is
truly smooth for the purposes of jigsaw
the way that we are approaching this is
we want to enable applications to opt
into the module system so you may choose
to use jigsaw you may choose to deploy
your stack at your deployment
Arrangements on the module tasks instead
of the class
contradiction I'm bringing our standard
Spring Framework charts from even
central on to the module path is already
supported that even works with for the
three the idea is that on the module
path they are being treated as what GDP
nine calls automatic module so each of
the jar files kind of turned into a
module the module name derives from the
Chavez name based on some conventions
making those modules those Spring
Framework charts
well accessible from the module system
perspective so in an application you can
implement a module you can add a module
descriptor this is a module in Vaghela
file that in the injector will be
compiled by the Cherokee non compiler to
a class files to be included in your in
your application chars and iSpring
Freimuth modules like the spring JDBC
module can be referred to through in any
convention implementing implemented in
automatic modules it's basically the jar
name without the version and with God as
a separator so just by convention
without the framework actually shipping
module descriptors itself it is usable
in a cheeks or based application
arrangement and this is the only thing
that really matters we want to enable
application projects to embrace
chicks'll if they choose to do so so
currently we're trying to have this
balanced perspective usability on the
class but first on jd9 usability on the
module path if applications choose to
use it this comes at a price this is
where the top of its own right so let's
wrap it up here but jigsaw isn't is
isn't as smooth and upgrade as as the
class path of course on cherokee 9 you
have to live with its limited exposure
its visibility its enforced visibility
restrictions between module boundaries
all of those things may be worth
embracing or maybe not in your
particular scenario this is up to you to
decide all right
i well so much for jigsaw as the
cherokee 9 story on our end is as
complete as you currently wanted to have
we're going to release the current plan
spring/summer crafted Oh rc1 in April
already with a ga timeframe of around
June so ahead of JDK 9 at least a month
of maybe to a head of 289 the
arrangement is tested against the latest
JDK 9 candidates are bills so we are
confident that by the time JDK 9 goes
out you can keep using the Springer
latest springtime explosions and just
switch your JDK to JDK 9 and all will be
good
out of the box so we're trying to be
forward compatible with Cherokee 9 a
little bit ahead of it of JDK 9 o GT
canines on JDK GA release its own
general availability alright
so much for 4089 4 start HTTP 2 again
let's not dive too deep into the into it
but HTTP 2 is probably the most
important industry initiatives that we
we have that we currently have in this
in this infrastructure ecosystem it's
the first revision of the HTTP
specification in about 20 years we
really need to get our act together and
embrace it so with all the all the
benefits I mean they're listed here as
there are so many efficiency benefits in
HTTP 2 that even if you're not actually
restructuring your HTTP interaction
logic or your resource arrangement if
you're just transparently upgrading like
with Cherokee language take an existing
web application reconfigure the server
container to use HTTP to make sure that
the process and everything else around
you is also HTTP 2 capable and they are
going to be transparent benefits in the
usage of your application in the in
efficient access to your application
inefficient use of server resources in
your server systems without having even
to touch your applications code when
doesn't get better than that right
the browsers and many other HTTP HTTP
stakeholders already did the job we are
lagging behind a little in the server
container space and this is a somewhat
of a bit of a typical Java syndrome
everybody's waiting for a new
specification revision to do the job
right for us there is no need to wait
for service for the dough I mean
certainly for the dough it's great it's
great that they require HTTP to finally
it's great that they even support HTTP
to pushes probably the least important
that you'd be to feature but anyway
right the a it's great that they are
doing this that they're going there but
service photo is is not expected before
July only as of very recently it's even
targeting July now previously it was
targeting q4 this year so favorite photo
though is fine as an effort but it's not
actually necessary because HTTP to
doesn't leak through the silvered API
much at all
the only API feature in save it for that
is a should be two related is the push
builder if you're not using HTTP two
pushes favorite three that one is all
you'll ever need
I mean of course one favorite four is
out once tomcat nine goes ga by all
means consider an upgrade to it but for
the time being consider using the latest
Pompey rated 5jd 9.4 and little wanted
for they all did their job already there
are ways of setting them up with an HTTP
two ready protocol stack even on JDK 8
it's not as smooth as it should be but
it is entirely possible right now it's
going to be significantly better on g89
I mean all likelihood also on actually
k8 update
following some of the Cherokee 9ga with
a similar protocol stack upgrade
energetic eight update something that
let's not wait for circuit four and in
particular not for service for
containers let's make the best possible
use of the latest generation of web
containers that we already have and
embrace hb2 as soon as possible this is
essentially also what we are doing in
well at Spring Framework level in
particular F spring boot
we support the latest generation Tomcat
8 size jt9 for we always do even ahead
of their release in order to enable you
to embrace in this case HTTP 2 in a
reasonable time frame and once serve it
for additions of those containers routes
the upgrade is going to be very smooth
fresh installations are going to be
easier nothing wrong with that but no
need to wait for this necessarily
alright hb2 has a little bit more to it
HTTP 2 enabled clients but let's let's
summarize this as it's all already
available in one form or the other
ok HTTP other libraries out there so
everything else basically is already in
place nothing prevents us from setting
up HTTP 2 systems right now let's move
on to a different topic right for the
functional perspective functional in in
our terms is a just general change of
perspectives and attempt to revisit the
setup of a typical spring application
from a more functional perspective now
what this function will really mean well
let's refer back to the state-of-the-art
I'd spring is generally perceived these
days as an adaptation based framework
with a strong comprehensive annotation
based component model this is of course
entirely an entirely valid perspective
but spring itself the framework itself
the core framework in particular is not
actually annotation based for well for
for many years now ever since its
inception we considered metadata formats
as something on top of the core
container at we were carefully avoiding
any ties to XML initially we're
carefully avoiding any court size for
annotations in recent years the Co
container is very very flexible it can
be instructed and sourcing metadata from
from different sources and
actually combine them mixing and
matching the the benefits of this
particular architecture in our coke
container really show through in spring
five now because from dysfunctional
perspectives we intend to provide
facilities and refinements conveniences
all over the framework allowing you to
set up an entire spring based
application without the user limitation
but with the use of functional features
and functional holistic elements in
particular for Java 8 and also cost them
for the coughing language this is of
course intended as an alternative the
annotation based model is not going away
which is revisiting the cookie our Co
container and our core ap is from a
different perspective in order to
challenge them a little and to provide a
common foundation for for both models
it's also not for the same kinds of
projects necessarily I mean the
annotation based model with its
decentralized pickup of components from
the class class may be through class of
scanning or through some central
registration points this is all fine in
particular for larger applications for
more focused types of setups
microservices
even if I'm trying to avoid the term but
for for a a little deployment unit with
just a couple of services that need to
be combined the functional style is
actually pretty convenient or pretty
compelling action so anyway let me just
hint that the this usage model a generic
application context setup is currently
the most flexible point already to
combine metadata from different sources
you could start with an annotation
configure application context then
combine these things mixing and matching
between the annotation well that the
functional world this is a design goal
here but let's let's see what this means
if you just want to register a couple of
components referring to each other you
could use the new registering facilities
with the supplier callback the supplier
call tech is not just a convenience it's
actually a very deep in the core
container
we're in order to create a new instance
of the given beam we're going to call
the supplier that you're giving to us
and you're not even seeing the suppliers
directly here because they're specified
as lambda expressions and so those are
of course our Java 8 lambda expressions
where for every bar instance that is the
container needs to create think about
scoped beams right the prototyping it's
going to call this given supplier here
and the supplier says ok and I'm about
to create a bar instance here I need
another beam to inject into my bar
constructor and in the most programmatic
way possible it can just grab that beams
from the context use programmatic lookup
facilities to obtain other being
there are plenty already on the bean
factory interface that are going to be
even more in the near future more
variants of programmatic lookups in this
kind of arrangement there is no extra
metadata there are no annotations either
just in most of those cases so it's
except for this case where there's
technically reflection when calling the
default constructor those cases below
even completely even completely avoiding
reflection there's no reflection
involved in these setups here as made
more complex you go there's going to be
some reflection like in in dynamic
proxies in one form or the other but not
for the actual core container
responsibilities managing the lifecycle
of freshly constructed instances so what
we can see here below is a actually a
variant with two colleagues you can
customize the outdoor LED the outcome of
this registration the beam Devon
definition that the container will
receive underneath the covers so if you
want to set some flags programmatically
the easiest way to do it is to specify
inline beam definition customizers again
you're not actually seeing the callbacks
we're using Java is lambda expressions
to receive the callback to to express
the body of the callback basically you
get a beam definition customizer
set
in it at qualifiers to whatever you need
to do to get the decide outcome this is
actually a little trick that I'm adding
here if you want to avoid reflection
completely you can pass in a supplier
that refers back to the constructor of
your beam the actual runtime dispatching
doesn't use reflection then but it uses
a Java 8 method reference which is a
straightforward invoke dynamic dispatch
to the constructor no no technically
completely free of any reflection so
this is basically what we're doing in in
Java 8 style making good use of Java
util function interfaces like the
supplier here but in particular of Java
8 language features lambda expressions
method references even for beam
definition setup now in koplan this is
even nicer even more concise in the
coupling language there are a couple of
specific benefits baked into the
language even into the callback model
where basically a cotton-based lambda
expression we can evaluate it a little
bit more clearly we know what its
outcome return type is we have
additional reflection facilities
available at runtime while making use of
those in order to improve the
conciseness of the cause we don't need
to repeat the beam type so there are a
couple of nice benefits even in the what
we call the Chavez style usage of
coupling basically a style that is
reasonably close to traditional Java
files
whereas what we're seeing here is a
variant with the inline type
declarations where what we call the
Gradle style usage if you've ever looked
at the community our Gradle the it's
exactly equivalents right just a little
shorter still and it's kind of an inline
which is the bean calls against the the
scope of the year
the variable in scope here so these
variants essentially the same right
we're talking about the same fundamental
mechanisms that Co contain the level
using each other 8th language features
in hopefully nice enough way and in this
case using coupling language features in
a nice enough ways technically we
actually shipping cotton extension so in
the spring time like five chars
you're looking to them you'll find a
couple of key key files we ship cotton
extension declarations that the copying
compiler picks up and the cotton
compiler basically sees over additional
overloaded methods on some course spring
API types that you can nicely use here
so we don't have to have those methods
in the core API we can add them through
it the cotton extension model for use in
coupling based application components
understood by the coupling compiler it's
a really nice model so it's actually
quite a pleasure to integrate with an
additional language on the JVM with such
clean extension facilities alright
there's more to this but just hinting it
while we're going we're going to revisit
this in just a moment because functional
registration is also top it for web
endpoints web endpoints right let's go
reactive in spring formal sighs we are
introducing a completely new web stack
in parallel to the traditional spring
servers website and we're going to
explore this in just a bit this new web
stack takes a very different perspective
it's entirely composed of reactive
processing arrangement so as a stack
that is from the ground up from ideally
from the ground up from basis or level
up to the web containers and back down
entirely reactive in its streaming
directions no blocking operations
against any i/o streams ideally of
course no blocking operations at all
highly efficient use of not only the i/o
resources the
I owe spec on the hardware that you're
running on but also of course off the
CPU and off the threading resources so
it's essentially about efficient use of
our given hardware facilities under high
load for a credential a very high number
of clients keeping up certain qualities
even in rather extreme load scenarios or
in maybe maybe even typical but high
load scenarios right directive manifests
though nicely hints at those qualities
erected Manifesto is well it's
essentially just a couple of qualities
right that we're trying to achieve
responsiveness even under high load
predictable behavior I would argue at
predictable behavior under high load I
resiliency in the sense of being able to
fail over being able to handle
situations where a certain client kind
of trigo operations that make that block
on Darren's not preventing other clients
from getting a regular response for very
simple requests are basically equal
treatment for a newly incoming requests
even in high load scenarios a highly
tuned servlet container stack highly
tuned service that can be good enough
for many scenarios there's no doubt
about this
but in particular on the high load under
more extreme scenarios it's not going to
deliver the predictability that you
might want to achieve at that level the
server container model fundamentally
makes assumptions right it's for any
given incoming request you own a thread
for processing this request and you're
not letting go of the thread typically
until you are done with producing the
entire response for that request if in
the meantime you need to wait for a
separate data store while you block
creds so there's a threading model
usually a server endpoint a servlet
endpoint a thread pool with quite a
number of threads inside which is the
maximum number of requests you're going
to handle in
these this problem kind of disappears in
the reactive processing architecture
because there is an event loop
dispatching certain steps for the steps
of processing a request as we are able
to process them
there is no owning of a threat there and
there is no scalability limit in in
terms of the threat to size either a low
number of threats is potentially able to
handle a very high essentially unbounded
number of clients the underlying
architecture in the technical stack is
called reactive strings and we've
actually heard about this in a luncheon
for today the erect strings is a a set
of four types of interfaces essentially
available on reactive string stood org
so this is an industry collaboration
effort between several players in this
space including people actually we run
an open-source project called project
reactor currently interactive three
generation which is a Java eight based
reactors composition library reckless
kernel basically entirely reactive
string space and back pressure enabled
from the ground up react extremes models
and interaction pattern between the
publisher and the subscriber with a key
feature being defect pressure
essentially flow control between a
publisher and potentially potentially as
low subscriber you don't want to a
publisher to keep publishing if if the
subscriber is not even able to keep up
processing it right if you don't need
the data store driver to keep sending a
large document to you if the networking
stack doesn't allow you to push that
data fast enough back to the client you
only needed to process it whenever you
are able to write to the actual HTTP
response we don't want to but to have a
buffer scrolling to large here we don't
want to waste processing time either and
in particular we don't want to block the
whole non blocking scheme is very
essential to the reactive streams
arrangement this is the underlying
architecture you do not typically
work at that level you work with a
composition library or with frameworks
built on composition on reactive
composition libraries on reactive
higher-level reactive libraries and
reactor is essentially an alternative to
our Java so if you know rx Java think
about reactor as a kind of specialized
version of our Java tightened up Java 8
based red string space version R of rx
Java the the stack arrangement and we're
going to see a bit of source code in
just a bit the stack arrangement
actually has reactor rather low it's an
essential part of our spring based stack
down here in the core reactive HTTP
extractions the interesting part here is
now our approach towards the web
framework problem right how how do we
build and ship a web framework on top of
a reactive strings architecture well
first of all we need an underlying HTTP
foundation an HTTP server and HTTP
runtime capable of reactive HTTP
processing it turns out that there are
quite a few options out there
Plunkett's and checking it for example a
commonly known as circuit containers but
in terms of their underlying HTTP
architecture they actually perfectly
suitable perfectly capable reactive
foundations right reactive HTTP stacks
at the lowest level our Spring five
reactive web stack hazard esters
underneath the covers for several HTTP
servers or the facilities of several
HTTP containers we have direct support
for transit and Chetty direct support in
the sense of using some server through
that one aging guy all facilities just
because we can at that level just
because they're good enough but also
directly integrating with the data
buffer models for it for example because
the efficient use of data buffers is
very essential to a reactant strings
performance so direct support for Tomcat
direct support for jetty which you also
could be using as a servlet container
but you're using it as a as a reactive
web foundation here
the use of Nettie is of course very
essential on our m-net years is kind of
the reference model for a modern
extremely sophisticated extremely
capable networking stack and we support
Nettie we embrace Nettie actually in two
ways you can even use the reactionary
and the rx Neddie HTTP stack on top as a
choice between the two and we also
support undersell amber tells the HTTP
contained underneath while slide we're
actually not supporting it at the
service level an turtle has a core
distribution where there is no servlet
support and we operate directly against
the underlying rbirtle facilities all of
those options provide the qualities that
we need to have a reactive HTTP stack on
top and the web framework that we
provide actually has a new name only
only for a few days officially announced
it's called spring web clocks this is
essentially what spring weaponise years
for the service that think about those
as two aligned but distinct web
frameworks with distinct qualities
spring embassy remains spring web
embassy remains as the Soviet API based
framework that you may already be using
that you may in want to keep using maybe
on servlet for with all the integration
points all the servlet based SP is
everything else that you possibly need
right it doesn't really change taking
keeps a little recess but there are some
common code reuse and some alignment
done but in the brand's picture it
essentially remains a straightforward
very backwards compatible upgrade path
for server based decks
typically consumed at the programming
model level through the annotation based
model controllers request mappings or
the get metrics and post mappings now
this is the typical actually not the
only but the typical way of using the
service set we have a variant of this
for the web slack stack as well for the
reactive spec you can use a similar
endpoint modeling we're going to see
this in just a moment a similar endpoint
model on the reactive spec annotation
based components designed to work on the
reactive sex this is not an abstraction
just a similarly structured similarly
designed component model we're going to
see this in just a bit
alternatively there's also a functional
way of interacting with the reactive
website that's best explained in a in a
piece of source code so look at let's
look at this controller it's essentially
statistically a spring style controller
very obviously if you look more closely
you see that the signatures are not
quite traditional spring MVC signatures
we're reusing the same structural
arrangement we have the controller
notation we have the same mapping
annotations the same path variable
annotations you could also use request
header and cookie value and all those
other notation so it's reusing basically
the the HTTP modeling that spring MVC
provides but it's running on the
reactive second in a reactive stack such
handler methods such mapping methods are
not triggered in order to fully process
a request like in reserve effect they
are actually called in order to return a
processing pipeline for the given
request so they're not meant to actually
produce the response the framework
expects a record streams publisher back
which is able to produce the response
once actually called once actually a
subscriber registers and asks for the
corresponding data to be produced so
let's assume there's a reactive
repository underneath we actually have
spring data kay we have a dedicated
project providing our repository model
for reactive data store drivers a
reactive datastore driver in an ideal
world delivers already a compatible
outcome called find by ID the reactive
driver says here is a reactive stream
publisher that's capable of retrieving
the object that you asked for once we
actually want you're actually able to
consume it reactive strings publishers
are usually not used directly we are
tend to use already in the industry out
there reactive API type which are
reactive publishers so what we see as a
mono in the flash
technically if implementing the reactive
strings published interface but those
are reactor types reactor api types
modeling the outcome at a bit of a
higher level and allowing composition of
different processing pipelines this is
essentially from an RH Java perspective
as Lux is an observable and mono is
basically single and completable
combined so I quite literally you can
actually declare our Chavez observables
here and arch have a single here if you
happen to have a dataflow driver or a
repository implementation returning
Irish arts Java publishes to you just
pass them through to the framework to
the web framework our web framework in
spring five naturally understand arch
Java types both rxjava one and our Java
2 types we internally use reactor and we
tend to recommend the use of reactor
types in application components as well
because they are just tightened up with
a smaller surface we're in reactor
there's only flux representing a stream
also a whole sequence of objects
basically a list of users read just been
a in a reactor fashion and normal
represents a single or non a little bit
like Java util optional again as a
reactive processing pipeline which can
be used for composition it has Maps let
map and further operations on it just
like in our extra
there's actually very close alignment
between the reactor types and the RX
Java two types
that's not coincidental there's actually
a very strong relationship with the RH
Java team the arch Java to maintain a
David Connor is a Committee on reactor
and I'm quoting David if you're on Java
8 and building server-side applications
use reactor three and the large travel
to because reactor three is designed for
those purposes a small and we're focused
and easier to grasp to some degree
library less extensive in its API
surface whereas arch Java has to appeal
to very different stakeholders has
run on android has a bit of legacy needs
to have compatible types for the RX
JavaOne types and the parallel bed
pressure enabled hierarchy so if you're
wondering why our java 2 has both
observable and flowable the best
explanation is the historical
perspective
whereas reactor has the benefit of late
birth essentially it came at a time when
Java 8 was already an ideal foundation
and it was able to learn lessons from
from arcs Java already in terms of the
operators the compositional operators
there is a strong alignment so most of
the operators have the same name and the
same style between our Java 2 and
reactor this is very very intentional
and actually to some degree
David fork or the work between David and
our reactor lives as a Malini alright so
this is basically in an ideal world you
just reach down a layer already get a
reactive type and pass it through of
course you can also use the flux and
mono API directly to build any kind of
composition chain of processing
pipelines and return it from here let's
let's stay at the programming model
level for a moment and at the same times
here slightly different composition
style so this is the annotation based
variants mapping mappings on methods
handler methods but the handler methods
form processor requests the return of
processing pipeline for the given
request it slightly actually quite
different arrangement right through the
router functions that are hinted at
before in this model we have the same
underlying web architecture the same
steps but instead of using annotations
or using the earth controller model we
approach things from a different
perspective we build router functions
and handler functions a what we named a
rather here is essentially just a
composed router function where we say
like for this an incoming request for
this predicate delegate to this handler
function for this other predicate
delegate to the other handler function
so you can of course imagine a dozen
such mappings in this case using Java 8
method reference
to dispatch to specific delegate method
set and what we see down here is a
sketch for those delegate methods on a
delegate class let's assume the
repository has been injected here or
given here in some form the delegate
methods do not use the annotation base
model right not a flexible signature
model from annotations they are actually
bound to the handler function interface
so this syntax use generate a java 8
method reference which means the handler
function interface accepted here needs
to be mirrored in this signature handler
function has has a request coming in and
use supposed to build a processing
pipeline for the response and return it
so if it's slightly lower level but just
slightly than the annotation based model
but you can actually see what's
happening here at this is you're being
called back to answer in this case with
a model of server response a building
instruction for a server response
you can't declare an argument of with a
path variable here so you have to take
the request and programmatically ask for
the path variable there are several ways
of doing this but essentially here
they're taking the path variable
building a processing pipeline we're
saying take this variable convert it to
a long and passed it to defined by ID
methods of this repository here and then
we're building the server response
there's a builder API on the server
response we are passing in this
publisher here so there is processing
pass on this model into the server
response and saying here's a basically a
couple of instructions for the server
responder in general and please take the
body from this processing pattern that I
have here for simpler scenarios where
there are no incoming parameters right
like find all method you reach down to
the repository you get flux or
servable back and you build a zero
response using the tilde API passing
this disk stream of users in as the body
to expose these methods execute very
quickly the whole point is that they are
being called from a an event look
quickly building the pipeline returning
them to the event loop and leaving it up
to the runtime system to the random
processing architecture to reduce the
subscribers and
West the next element to process
whenever the runtime is ready for it you
never block you just build the
processing pipeline leave it up to the
runtime to call it back at the right
time this is of course very very
different from a traditional server
processing architecture such a
repository will have to be using a
reactive data set rather and there are
quite a few of them out there for Mongo
for Couchbase if you're trying to use
traditional transactions against
relational databases you're out of luck
in this particular arrangement such
operations can be integrated into such
an architecture but only in the form of
worker pools not triggers here from a
handler method it's a little bit like in
UI programming right in swing UI
programming or any other you are
programming if you're triggering a
blocking operation here you're basically
blocking the rendering thread as I can
in UI architecture you should not be
doing this right so these are really
meant to build processing pipelines if
there's any more extensive work to be
done that can't be expressed in a
reactive processing pipeline consider
delegation to a worker thread and
building a a monomer of flux from the
outcome offers worker thread in a
separate worker thread pool let's say at
once more at the programming model level
actually a very trivial refactoring
between those two variants which is
using a different Java style it is the
exact same API we just choose to not
have a delegate we choose to inline the
handler functions as lambda expressions
so we build a router function we're
saying this predicate here here's the
handler function request comes in let's
do the server response for it and if the
operation is the pipeline the pipeline
arrangement pipeline building is simple
enough you can just use a lambda
expression to nest it basically it's ok
it's perfectly okay for two routes right
it may be okay four or five or six but
at some point this is probably the nice
arrangement right where you separate the
routing information with the whole
series of delegates that do the actual
processing it's up to you the API
arrangement allows for for both styles
of
all right this is basically
stylistically what we're doing you can
see that the functional nature actually
really really shines through here I'd
really really mean it for the endpoint
model because as an alternative we have
the annotation base variant so choosing
between the two there was a rather
rather different arrangements but it's
basically expressing the same the same
random characteristics interacting with
the same runtime stack
it's your choice would you prefer to use
here because of course also has some
more complex building coding here study
the underlying facilities are all the
same even mixing and matching is
entirely possible here the spring boot
supports for directed web status is also
giving an easy entry to these to these
models in particular to the annotation
based dispatcher on a on your choice of
reactive stack underneath so to wrap up
and already wrapping up also this blue
tent what we're delivering in spring
summer Christ at all with that the RC
one planned for April if well what what
does we talking about today
plus a lot of other things that I didn't
have the time to talk about right
everything I talked about today is
actually already in five of the empires
you know released a couple of days ago
so dedicate baselining even early
support the JDK nine and the service for
API so you can even already in check
service for push builders if you really
need the feature we have the functional
story at least in its initial
information and the reactive web
endpoint models plus the underlying
reactive HTTP infrastructure plus the
reactive HD reacted codec abstraction
that we have underneath so a lot of
foundational facilities underneath all
of this is going to come your way in
spring sandbox five two though of course
in parallel to the servlet stack right
remember spring web Emma C spring web
flux
coevolving nicely aligned but available
as separate options in a spring form
applied for those side by side there's
more coming
we have more ideas that we can't roll
into this timeline we see Springs and
mcfife the dough as the beginning of a
generation of the framework that the
Feist of X generation they're going to
be 5.15 the two releases completing
these dis vision these these trends
adding further variance for the
functional style support certainly for
the capabilities to directed web
architecture further exploration of what
we can do on JT ki9 and so forth so see
it as the beginning but a production
level beginning of a new generation of
the framework I've already hinted at
spring day decay since a repository
interaction is a central problem of
course are free to use anything right
that you choose to expose there it can
call directly against any data store
driver that allows you to build a
reactive processing pipeline from it and
fortunately there are already many
initiatives out there and most of them
in the latest incarnation are reactive
stream space so can very nicely be
adapted into our Java - or into reactor
at the same time we have a new revision
of our spring data portfolio spring data
and next spring data release string
named K has a strong reactive repository
model a strong focus on a reactive
repository model without of the Box
support for Mongo Cassandra for for
Redis are in all likelihood for for
cowfish depending on the availability of
the underlying drivers this is a problem
we cannot solve on our own and we're
completely aware of this we're trying to
interactive motivates other stakeholders
in the industry to do their part to ship
reactive stream space drivers that we
can nicely integrate into a spring based
reactive web stack so to some degree
we'll have to wait for those assets to
to happen first but we can of course
also add a little motivation by sharing
our road map and suggesting that it
would be really nice if things happened
in time and spring food - the dough is
going to wrap this up spring food - the
dough has already snapshots if you're
going to start to spring the soil and
you
using the spring wet reactive starter
you currently get a spring boot to the
dough snapshot with the latest spring
from across to the milestone this is a
fine start to experiments but of course
we really need to enter the milestone
phase so along with the spring semuc 5 0
RC 1 release there will be a spring boot
to the dough m1 release the actual
release candidates space will happen
later this year GA is expected for more
towards the q4 timeframe November
timeframe this year boot to the dough of
course builds on springtime excites
builds on spring data k builds on new
versions of spring security in spring
integration with reactive supporting
those as well and it also provides
dependency management now a central
feature input to the dough in the i/o
platform
dependency management also for reactive
web stacks which is not an entirely
trivial topic at the moment but there
are still some some some time where we
hope that a couple of currently Pizza
releases actually ship in production
form so that we can pick them up for our
dependency management all right this is
basically the T story be a strategic
perspective on what's happening in in
spring land in 2017 we typically already
have a plan beyond but first of all
let's we are we are very committed to
delivering spring from back 5 0 and
spring boot to the dough and then we're
going to take it from there essentially
the time for feedback is ideal now right
if you're going to try the reactive web
start if you're going to experiment with
the reactive web stack or with the
functional features or if you're trying
to run on chicks or on 39 give it a try
now things are gonna find enough shape
to be tried and we can still incorporate
the feedback within the head of the
release candidate phase but even
afterwards we're very willing to
consider real life pls the grill our
requirements and kind of feed them into
at least the spring some explicit one
plan this is an an evolving framework it
evolves with the industry with the
ecosystem it's an offering for you to
adopt
basically to opt into this evolution not
just taking spring comic five to go but
also looking forward to or what's
happening afterwards what's enabled by
Springs I'm excited though for years to
come
alright thanks for your attention if
there are any questions I'm happy to
take them</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>