<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Much Robots  Very Java  So IoT by Marcus Hirt, Miro Wengner | Coder Coacher - Coaching Coders</title><meta content="Much Robots  Very Java  So IoT by Marcus Hirt, Miro Wengner - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Much Robots  Very Java  So IoT by Marcus Hirt, Miro Wengner</b></h2><h5 class="post__date">2017-11-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PZza1EJJWA4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so we're gonna get started so hi
everyone
and my name is Marcus and this is Miro
and we are not representing our account
company stay this is very much like
things we do for fun so just so we don't
and we're gonna be talking about robots
in Java and how you can quickly get
going
building robotic stuff with with Java
using something called dropper for Jane
which is an easy-to-use framework for
quickly getting started writing Java for
custom hardware it is a pure Java
framework so there are no dependencies
on other stuff and you can use as little
or as much of it as you want to so if
you are just interested in having Java
abstractions for common hardware then
you can just use that part without
buying into anything else so this is all
open source and and funnily enough we
have on Dukes Choice Award this year so
that was great so this is typically what
what a robot would look like you would
have the hardware dependent parts in
this case we support Raspberry Pi and
Legos today and then we have the core
abstractions of the framework in drop
for J core and then we have units which
bring together these these core parts
and the hardware abstraction and then
you have your robots sitting on top and
if you want to you can use the HTTP
module to be able to communicate with
with your robot over HTTP so everything
called Rover for J - HW for hardware is
containing these very simple to use java
app structures for for common hardware
and these you can use without having any
dependency on anything else so here's an
example if you have so Adafruit is a
very common popular place for people to
buy buy hardware from and they have an
LCD and this is how you would
instantiate the LCD and and change the
background color of it to teal and then
set the text in this case it has two
lines so it would say hello world
J so I should mention that this talk is
actually a boils down version of a
full-size full time to one talk so we'll
see
see how this goes I might be starting
talking faster at some point anyway so
this is the way you would would use the
system you would have a robo context
which is basically your robot it
contains all the little Robo units that
you have defined and these Robo units
would be sending messages to each other
over Robo references and you can use
annotations to select how these are
being sent these messages and this is
all plain old Java then we have the
hardware specific units and these are
prepackaged configurable units that you
can use on the higher level of framework
so there is going to be an Adafruit unit
that you can send messages to for
example so you typically configure these
using XML but you can programmatically
configure them as well threading wise
the Robo unit can decide how it wants
messages sent to it so you have a system
scheduler that is normally used for
sending messages if you haven't said
anything else then there is a work one
if you feel that your unit is going to
do a lot of processing then there is a
blocked one if you feel that you're
going to do blocking i/o or anything
else that is going to hold your thread
so typically in the rest of your pipe
case there's going to be this number of
threads in each pore by default so your
typical project is you add the units for
the hardware that you have a new
configuration and then you add your own
units for doing the controlling behavior
yeah the class with the main method we
initialize all of this in in a robot
builder and then you run the main method
and that's it so here's the full example
we have a little LCD example and this
one contains the declaration in row row
buffer dated XML with three units I will
talk about those in bit then we build
this context we start it we get a
reference to the LCD just to send the
first initial message
for it to show and then we wait you know
for for for passing enter so that we can
easily just shut this down over the
command line if you want him so this is
the XML and at the top there you can see
that we have this LCD unit and from the
package declaration here we can see that
that is a prepackaged thing from Robo 4j
nothing that we've done anything with we
just configured it same thing with the
buttons if you use the Adafruit LCD
shield you would know that you know it
has the LCD and buttons built in to the
same shield and in Robo Fuji those are
two separately configured units so that
you can use them independently and then
we have the controller which basically
says you know what we want to do and in
this case won't run demos so the
controller just takes a message looks to
see if there is a demo running if there
isn't any demo running we will process
the message and otherwise we will ignore
it because we don't want to interrupt it
running demo that would be bad and then
some initialization we can skip that and
then the actual message processing what
we do here is if somebody presses down
move to the next demo we press up move
to the previous demo select run a demo
if there is a button that we don't
recognize we just say that on the on the
display so I have a demo this is the
simplest demo you could possibly do yet
as Java one this was the one people
applauded to the most because hey you
know LCDs so colors colors so you can
see the text here but I'm going to
change the backlight you might see that
the colors so yeah this is like the
smallest demo we we could could could
come up with so job are controlling
hardware so let's see now me we'll talk
about HTTP communication so it's a lot
of fun to working with harder especially
but it's failing but it's also more fun
we've been thinking
what about to talk to the unit directly
so we developed the HTTP socket module
for this and what it does when
you simply add to your river forge a
context HTTP server unit and a CB client
you and although you're a buffer system
to talk outside and receiving the
messages so as a marker dimension that
we are using a strong title language so
you need to define the codecs that your
message will be from the by scene
properly translated and send into our
internal paths and process so for making
this simple we created three types of
annotation the first one is a sheep
producer which slightly enforce you -
encoding to implement encoding and
decoding part at the same time if you
would like to split and let the rebel
forge a system knows where those classes
is you can use the rest - annotation to
implement the HDP deck your decoder and
encoder so rebel 4j will understand and
then talk to the outside world by risk
style and receiving graduation type of
messages the simply adding the HTP
server unit inside of your context and
initiating you will get the row before j
system cap able to answer your cat
requests with this get request you get
all information which Connie of the unit
you decided to plug into your system and
which kind of state they are in if you
would like to talk to you any of your
units you properly configure you use the
URI / unit / unit ID this unit ID is
completely unique for the row buffer J
context so you that means you cannot
have two free for just a one unit ID
because otherwise there before J will
not understand what you want from him
how it looks here is a simple herbivore
J system initiated and you are
requesting on a port what kind of unit
stay do have so he had the two units
there is a small joke the AGP server is
stopped that means that such kind of
rest
cannot even process but it's a
presentation right so it's not real but
it cannot happen
there isn't one more thing it's a UID
you get with your reckless in a header
and this is completely unique inside of
our network but we'll maybe touch it
later but here is no time for this here
how it looks the communication with your
units
you are simply URI accessing the
controller which is a unit ID you have
in your contacts and if your message is
properly processed you have to HTTP code
back 202 if it is if you are accessing
something but it's not configure inside
your context you get 404 and if you are
trying to do some some action or
whatever but it's not even implement
that you get a form under one then you
get it also more HTTP codes but you can
take a look on the on the code here is
our simple streaming image training demo
it's a client here is the Robo forge a
context here you see it's a
pre-configured lien unit one is a client
and one is an image controller which is
wrapping the Raspberry Pi Hardware it's
configurable according to raspberry pi
documentation so you can simply add and
start sending images but isn't it more
interesting on this team oh yes that we
have the server side which is the
endpoint and this is a Java f/x
application which is simply also using
Robo 4j and simply showing us the images
what is what is happening so by this
demo we would like to show this are very
very simple to connect the rebel 4j with
other technology and started to use it
let's go back little bit in the
beginning of the row before Jeff because
at the beginning we choose the Lego
hardware to develop the entire framework
and let go harder provide as some basic
standard some good sometimes we can rely
on and we can move further as a marker
set before we have the hardware package
which is then can be used completely
unknown which is of wrapping the
hardware
drivers we have written and her before
je units which in this case are Lego
they are providing some basic basic
algorithms come basic behavior you can
do up to this hardware here is a robo
forge a context for example we do have
here it's a simple one why it is simple
it doesn't look like this but all what
do you have here
you simply add and use only configure
you don't you know I'm writing any lines
of code only to cut controller for
example weapon and the platform platform
you simply add into your above forge a
context and use say which kind of motor
does what that's all very very simple
and let right now we can take a look on
the demo we have here maybe you you see
it I am having right now in my hand
it's a gamepad from Logitech which is
not really common the Raspberry Pi
hardware and I'm having a Lego and it
works with rube 4j all together and I
haven't done anything and Marcus is
controlling this robot by using our Java
FX joystick at the same time so this is
amazing and right now we can little bit
move to more advanced example we do have
here and I will give my word back to
Marcus right and so so last year at
JavaOne I I presented an autonomous
robotic vehicle called coffee because
you know he's laser rangefinder eyes
looks a little bit like wall-e and he's
running Java so it's gotta be named
coffee and he's a 3d printed thing that
is using make block for them Lumina
profiles he's using things like well
lots of hardware from Pololu and
Adafruit old wire together in in well
there is coffee so the 3d printing
technology today is kind of slow but
it's very exciting because you can get
exactly what you want to and this was
the first thing that I
you printed it takes about 20 hours to
print the thing on the top left there so
so it's not a speedy manufacturing thing
but you know you you can define
precisely what you want so it's kind of
cool and here's coffee at JavaOne 2016
running in autonomous mode on the show
floor and you can see the laser
rangefinder going back and forth
collecting information you'll notice
maybe you won't notice it's kind of its
kind of small over there but I'm he's
going to dynamically change how much he
scans and and he's going to dynamically
change his speed when he starts running
into trouble and after a while there is
he's actually going to understand that
that's not a good place to be so it's
gonna start plotting out there a new way
and go off so this configuration slide
is meant to be soothing not discouraging
it's it's actually if you look at the
package names if you can't see the
package names up there they are all
chrome Robo 4j blah blah blah it's just
pre-configured stuff that I've added to
the configuration of the robot so this
is you know just state clearly saying
that I have one of these in here and
then the actual logic is done by things
over here like the mission controller
and scan processor so you know
off-the-shelf components that are that
are all easily configurable so um to
build your own coffee you can go to
Thingiverse as I said coffee was the
first thing that I built for for 3d
printing so the direction of certain
components might be wrong you might have
to realign them etc but but but you know
you can print your own coffee if you
want it and you can also look into the
repository at github to find the source
for coffee full disclosure is not fully
ported into Robo 4j I haven't ported all
my sources there yet
but but I will
right then there are some some exciting
tools Robo Fuji this is I'm gonna do to
do a little bit of demo here so when I
designed coffee I needed to design
things like algorithms for feature
extraction and algorithms for right for
for for finding good paths it's a dram
so what I did was I let a coffee run off
in a very very very simple
I'll just obstacle avoidance thing
around in my apartment and I captured
all the sensor data using flight
recorder because hey if you want to
record lots of data without having
timing problems you know flight recorder
might work so that's what I did and then
I developed the algorithms for for
feature extraction and this little thing
up in the corner is actually not the
buggy that's where I have my cutting
boards and that's how my kitchen looks
so so it's supposed to be like that and
yeah and then you know algorithms for
finding good good good ways to move
about so that's one of the things we
have and another nice tool is to mention
that we have to support for JFR inside
yeah that's kind of this is all using
flight recorder recording stuff into
flight recorder and then we shall I sing
them using a little plugin for Mission
Control now this plug-in is for
mosquitos 5.56 and oh it's out with nine
and I'll port this eventually at some
point about but you know hey so that's
you know if you have your own projects
and you need to do something like this I
can highly recommend I recommend this it
works very well save me a lot of time
because you can imagine what happens if
you have a robot and you put in a
breakpoint you have this real-time
system that is continuously feeding at
other parts with data bad things will
happen that's actually one of the fun
parts with robotics you will see or your
your your actual machines run around an
interactive interact with physical
reality in various ways and when you
have bugs that becomes very apparent it
is a lot of fun
anyways so
here is another tool because of course
you want to use magnetometers and I
really wanted to build the job effects
app in using JavaFX 3d so here we have
here we have when you have a
magnetometer you have soft and hard iron
effects that you need to compensate for
you might have an additive magnetic
field that need to compensate for you
might have different you know metals in
the neighborhood you usually have and
then you need to take this what should
be a perfect spare and you need to find
a way to map it this ellipsoid back to
the sphere and and this is what this
does so this is just simulated data I'll
show you real data later but
unfortunately my machine here is too
weak to render that quickly so I have
the simulated data anyway so then you
just take your bias vector and transform
matrix and put it into two into Robo 4j
and then then you have have a
magnetometer that works better for you
so I'll show you what it looks like if
you have real data it's not ready but it
does look like the Death Star and that's
because I had the magnetometer in
harness for one of the axis and that's
why it looks like the Death Star wasn't
intentional but you know in retrospect
is cool anyway so that's real data and
it looks to flows much smoother on my my
my station your computer at home so I
guess okay so okay okay so let's Freddie
pop we are apparently in a very good
time so we maybe have a answer yeah we
never did it before
so let's worry about the row before J
should be the very simple way how to
access the hardware through the java it
it shouldn't stress you so you should
take a hardware you have at home and
simply plug it to use our before
spill it up and run it and it should
allows you really quickly to do build
something but does make a sense for you
and we just started with this what it
started it's like a 1 and 1/2 years ago
we started working on rubber forge a
project
apparently mark is working with the
hardware a little bit longer than I do
some years and I just started to working
with hardware but in a one and half year
we may deliver it on the market right
now github with something works which is
able to control the hardware which
really allows you to use the Java for
such kind of purposes you don't have to
limit yourself only on hardware so you
can build up some server and units so
you can use it embed independently so
and during this time I had baby twins
so yeah has it really been full speed
yes and I'm getting a baby so yeah but
we have a smaller robots also we can but
you cannot turn a little bit yeah we can
turn them down so so we hope that it's
helped someone that make you interested
in IOT work because they are a lot of
session how to do the IOT but there are
very few session how to handle the
hardware using a java so that's probably
the reason why we won the prize please
give us a feedback how you like it that
in a future it allows us me and Marcus
to present some stuff which is not
really directly related to to our work
Charlie daily job but it's making a lot
of fun and we learn you can learn a lot
of lot from using the hardware which can
you then apply on your job like putting
up the servers and configuring your
market services turbo forte are
basically representing to some agents
every unit agent system just working so
here you can reach us on our website
so before J dot IO and we have also
Twitter icon markers have their here
and I have to add Mirage Miko so you can
shoot us when you have a questions only
you need to help with your hardware or
you would like to participate on
honorable forge a development yeah you
are all will come and thank you very
much yeah thank you thank you very much
for being here and right now we have a
time for a question answer also we have
some other demos here that's yeah did
you think we would have time mm to show
so so if you want to come up later and
see see other demos we can show you
maybe I can run the camera with the
gluon implementation we have some some
other silly time yes for sure
any questions so the quick so the
question was how do I know what to XML
values to put into these and the answer
to that is you don't well it's it's it's
typed configuration I can show you but
the actual values are defined in the
units so you need to look at the unit
complement I need to look at the units
but let's take some example here some
may be the city example no but there is
also a type of dimensional type integer
we superstring double float and then we
try to write a Java doc so so under the
config element is what we will get to
the unit and you will check me to check
the unit or imitation to see what what
things you can configure on it okay
any other questions yeah yes yes no well
that all depends
okay so the thing is so the question was
you have support for for SP or PI and
and Legos but but what about our Dino
platforms and
and first of all the arduino platform
has very very little memory precious
little memory I wouldn't be able to fit
one scan laser I mean Martino usually
depends on which one but ok yeah so so
so no but you could probably if you have
things connected to the Arduino over i2c
you might be able to gain things from
the implementation code for those that
was hardware abstractions maybe no I'm
I'm experienced I have a Arduino at home
so I use the Robo for J and I'm
communicating with adreno using pi for J
so this is when I would like what I
would like to check some motor then I
have a C code and I have a mood to write
a program in C code yes yes so one thing
about programming with Java for using
Java to to to develop for hardware is
that whenever you want to emit time
sensitive things like pwm signals for
example you usually better off trying to
offload that to ship that is dedicated
for that so so there are good chips that
have built-in timers and are dedicated
for for for emitting PWM signals and
that's usually how you do it that said I
am using an Arduino Nano for 4 for
parsing or or or getting PWM signals you
know to my Robo 4G environment so so
sometimes just in one case so far I've
had to sort of build something special
outside of my environment and have a
little bit of C code to to to know do
whatever I need to do in this case
decode PWM signals but yeah it works
better than you think to to do things
like scanning I mean they you have a
garbage collected language yes running
you know a garbage collects the runtime
that runs on a pre-emptive operating
system and you have all the timing
sensitive stuff all over the place and
it's it works fairly well and that's I
think that is kind of cool
right next question
yes go ahead thank you thank you right
yes right yes yeah yes yes right so the
question was since your he said you have
a Java pure Java solution and you need
to interface with hardware so how does
that work and and of course it works by
us having to have abstractions Java
abstractions so we are relying on on on
hardware libraries on the different
platforms so in the case of raspberry pi
we're using PI for Jay to interface with
the hardware and we have support for
various kinds of hardware some of them
can be controlled over selected GPIO
channels so so in the raspberry pi for
example there is hardware PWM 4-4-2 GPIO
pins I think and and so so so you know
that there is going to be support for
that in the in the hardware abstractions
there's going to be support for
different I to see Cobham I to see
components so that's where our
abstractions are and there is a thin
layer to work against the hardware for
for for doing communication of GPIO i2c
accessing the serial USB SVM but if you
want to do things on that level you can
do that directly using PI for J you know
if you just want to have access to the
USB port but if you want to have access
to say the serial port and and you don't
want to necessarily write the decoding
of the of the GPS information and just
want the nice job interface for
accessing the GPS just plug it that's
you know when this comes handy okay so
here is
for example how the camera works I don't
know you cannot see it's kind of door oh
it's dark so if there is a light there
is a fully stand-alone application
running with hardware and using do there
yeah yeah it's somehow works yeah this
so you can you can use and play with the
common hardware you can cannot come back
to Raspberry Pi it will work so you
think okay yeah
so we're running out of time so it was a
good thing that we were so fast yeah we
had a few questions
cool thank you thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>