<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Are You Listening? by Paul Anderson/Gail Anderson/Geertjan Wielenga | Coder Coacher - Coaching Coders</title><meta content="Are You Listening? by Paul Anderson/Gail Anderson/Geertjan Wielenga - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Are You Listening? by Paul Anderson/Gail Anderson/Geertjan Wielenga</b></h2><h5 class="post__date">2015-11-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2Y6kAI6cu64" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay okay we'd like to welcome everybody
to our session are you listening
affects binding techniques for rich
client UIs
my name is Paul Anderson this is Gayle
Anderson and we are with the Anderson
software group and over to the left is
helped unveil Anja from NetBeans so who
are we
Gail and I are Java developers and while
we're not writing a lot of our own code
we're putting together courses and
teaching other Java developers a lot of
tips and techniques that are useful we
have courses in Java 8 and Java FX and
our company is based in the US we are
also the authors of the textbook Java FX
rich client programming on the NetBeans
platform I'm the author of two live
lesson videos from Pearson Education one
on Java effects programming and one on
Java reflection and he often is the
author of beginning NetBeans IDE and we
will have we brought our books along
here so we're going to be giving those
away at the end of this talk - the most
interesting question that you've people
come up with so you can be thinking of
that as we go along all right now what's
our game plan what's our agenda for
today
ok we've got a couple of neat demo
programs to show you the first one is
going to be a standalone java FX program
that will teach you a lot of techniques
in java effects that will help you
design you is more efficiently and more
effectively we'll go through the demo
program at the beginning Gale will
demonstrate it and I'll walk you through
it
and there'll be a lot of simple things
in the UI that you'll see but I think
that you'll be interested to see how
we're doing these techniques and
particularly when we come back and go
through the code and show you
JavaFX properties for your model data
the listening and binding techniques
that we're using how you use observable
lists and Java effects to manage your
data and also the program is all written
in Java 8 so you'll get a chance to see
a lot of techniques with lambdas and
streams and when fact we'll show you how
to use Java FX binding with streams in
Java 8 at that point we'll turn it over
to Helen and he will be talking about
the NetBeans IDE and the
beans platform and the NetBeans platform
is a swing based framework so will it'll
come back to me and then Gale and I will
show you our second demo program which
will be a port of the standalone java
effects program to the NetBeans platform
and then you get a chance to see how to
integrate Java FEX and swing together at
the end of the session we'll wrap
everything up we'll tell you where you
can get the source code you'll
downloadable from our website so you and
you'll probably want to look at our
programs to see to learn a little bit
more about these techniques and then we
will have question and answers at the
end with to book giveaways as I said and
I'm planning on having about five
minutes or so for questions from from
the audience but you're also welcome to
use the hashtag on Twitter JavaFX
binding and you can also post some
questions up there and if we don't have
time to get to those will will Ansel
that them later okay so let's get
started
gales gonna switch over to NetBeans now
and we're gonna bring up our first demo
program and we already have it open so
all she has to do is run it okay now
what you're looking at here is a BP
monitor application where B P stands for
blood pressure and one could imagine a
program like this being a part of a
larger medical application or it could
be a standalone desktop program that
helps a person determine their blood
pressure data over a range of dates if
you went to Johan Voss's JavaFX on
mobile talk yesterday you could easily
see that we could port this program over
to mobile which we plan on doing in the
future
now the UI that you're looking at here
was created with gluons scene builder
tool and that's a tool that allows you
to drag and drop JavaFX components to a
screen and then you can manipulate all
those and then the scene builder tool
from gluon creates F XML code not Java
code but F XML code that helps you
reduce the number of Java the Java of
instructions that you have to to use and
you can and then we implemented a
controller class in Java to configure
those components as I said we'll go
through the the demo program here and
then we'll show you all the techniques
in the actual code now on the UI it's
divided up into four sections on the top
left you can see some controls that will
give you a blood pressure reading and
including dates and times and then
underneath that we have a Java effects
table view that shows you a range of
blood pressure readings that are sorted
okay by date and time and also filtered
right over a range of dates and we'll be
showing you how we're doing those
sorting and filtering in Java effects
later on on the right side of UI we're
visualizing the data for the user by
using JavaFX charts okay we have some
buttons at the top that will show you
and then we have a line chart in the
middle and this is well the components
of a blood pressure reading which is
systolic let's you see in the table a
systolic reading and then a diastolic
reading and a pulse reading and then we
have colors for those the red line for
the systolic the orange for the for the
systolic and then the green for the for
the pulse underneath the line chart we
have a bar chart that puts out summary
statistics okay so let's interact with
the UI now and start showing you some of
the things that you can do with this and
how we're going to do this in java
effects okay so the first thing gail is
going to do is show you some mouse
movements if she puts the mouse over any
of the lines you can see that we are
putting a drop where she's able to see
the numbers of representing the values
that are there and this is very easy to
do in java FEX to be able to pop those
numbers up and is a good experience for
the user
she can also go down below and put the
mouse over any of the bars in the bar
chart and those represent on the left
the maximum values for each one of the
three series the middle represents the
averages of those reading of that of
those three readings and on the right
the minimum values okay let's go back up
now and start clicking on some buttons
and
this will change the range and when she
does that you'll see the charts
immediately react and and and and
display new ranges of data this is all
very easy to do in Java effects when you
organize it all with observable lists
and the binding techniques that we're
going to show you she can go to the last
button to get the last range she can go
to the first button and Gale can also go
up to the date picker and pick a new
starting date and once again the charts
and the table immediately react with
each one of those things that she does
ok now let's go in and select a reading
and several things happen here in the UI
first of all we put some drop shadows on
on the reading that's very easy to do in
Java effects we also select the table
the row in the table so the user knows
about that and then we populate the
controls up above with the blood
pressure reading Gale can also go into
the table and she can select any reading
from the table or she can go back over
to the line chart and and access any of
those blood pressure readings though
notice that the delete button is also
enabled and and then if she clicks
anywhere in the background in the line
chart then all of those effects go away
okay so let's select a reading now and
change one of the blood pressure
readings so she selects that one and
then she'll go over to the left and
she'll put in a larger number and notice
that the Update button was immediately
naval dweud it'd that now when she
clicks on the Update button you'll see
the charts immediately react as well as
the table being updated in fact if she
goes over to the line chart there you'll
see the new number at the top there and
you'll see the new maximum for that
reading down below and then the new
number that she put in over in the row
and the table view
now let's show you how to delete a blood
pressure reading we already have one
that's selected and the delete button is
activated as well so when gale clicks on
that delete button oh what happened oh
okay
what happens is it all goes away right
yeah yeah that's strange okay so when
you click on the okay button there for
the confirmation dialog then what
happens is that the the reading was
deleted and when that happens the table
automatically it's deleted for that and
it's automatically resore 'td and andrey
filtered if it has to now let's go in
and create a new blood pressure reading
and so Galle will go up first of all and
select a date that's going to be in the
same range that's in the table and then
she'll populate these text fields with
the blood pressure reading and notice as
soon as she puts in something in the
pulse field you'll see of the add button
enabled and then if she back spaces on
any of that you'll see the Add button
disabled this is one line of code in
Java FEX with a bind and we'll be
showing you that very soon yeah so the
same thing is going to happen now when
yeah it wants to move the window over
which doesn't happen on a real desktop
again a confirmation dialog and then
when she clicks it now the thing that
you didn't see was I want you to look up
above the bar chart the number of
readings is constantly being updated to
the correct number that you're that
you're seeing at all times we also have
that in one buying statement as well so
as you add readings delete readings or
so forth them you know that that title
is always being updated in just one line
of code
okay so let's terminate the application
now and before we go back to the notes
one
Gayle's going to bring up the FX ml code
just so you can look at that remember I
mentioned that when we designed the UI
we use the scene builder tool right to
drag and drop the components and then
that tool with generates F XML code and
this is what you're looking at right now
this saves you a lot of time when you're
coding because you don't have to
instantiate controls and call setters to
configure them because the F XML layout
will all do that for you you can also go
into the F XML and edit your
self and it's a very very nice way to
design you eyes like this okay let's go
back to the notes and start looking at
some code okay so the first thing that
we want to talk about our Java FEX
properties and why you want to use them
in your model data so we'll begin by
telling you you know ask you know what
does the JavaFX property and why would
you want to use it a property and Java
FEX wraps your data in so that it's
observable which means that registered
listeners can be notified when a
property updates this is a very powerful
concept in Java FEX because when you
have a property you can attach a
listener to it and you can also call
these binding methods that we're going
to show you in a little bit JavaFX
supports properties for the reader
readable and writeable also properties
that are read-only and also properties
that are immutable and cannot be changed
okay gales going to go back into the
code now and we're going to show you the
properties that we're using in this in
this demo program okay
okay there we have four properties
actually five but I'll show you these
these four first what you see here we
have an object property which is generic
and by the way we're using the Java
eight local date and time class for the
dates and times that you see in the
program and then we have three integer
properties for that that handle the
systolic diastolic and pulse data for
for the blood pressure reading down
below in the constructor you can see
that we're newing the simple object
property and simple integer property
we're passing the object that the
properties belong to and there we're
using static strings which is a nice
part of the property constructor because
then we can use those static strings to
populate the table view within with the
cell factories that we're using we have
another property - that's called okay to
add and you'll remember from the demo
program that you know there are times
when you can add a property if nothing
else is selected so we maintain that
property ourselves
now if gale Scrolls
just really quickly on this rest of this
file you'll see the familiar getters and
setters that you all know and notice
that they're calling get and set to get
the wrapped values back or or to change
them but the other thing you want to
notice is that there are these new
things and Java effects beans called
property getters and these are you need
to have because those are what you'll be
calling to a catch listeners and to do
binding expressions okay yep and I
wanted to add that
JavaFX properties have naming
conventions just like the traditional
javabeans property and the naming
conventions you see here with the
property getters being the name of the
property with the word property appended
to it so it's important to use these
naming conventions because a lot of the
tools assume that and other people using
your code will want to see those same
naming conventions okay so let's go back
to the notes and look at the next topic
on the agenda okay now this is really
what most of the talk is about is to
show you how to use listeners and
binding techniques with these properties
that we have to find alright let's start
with listeners okay so what's a listener
a listener is something you can attach
to a property so that you can monitor
changes when that property gets updated
you can add a listener or remove
listeners dynamically in your program
and a listener will be notified when
when a property that it's attached to
updates or changes at some point there
are two there are several listeners that
you can use in JavaFX we'll show you
these two right now the invalidation
listener which is where you get a
callback when a value becomes invalid
and a change listener which you get a
different kind of callback when a value
updates that gives you access to the old
or previous value before the update in
addition to the new one and this can be
quite handy in in certain situations as
you'll see okay let's go back to the
code now and let's show you some
examples of these two listeners that we
have in our demo program
I could I can say it one thing if you
don't are familiar with the validation
listeners and validation listener is a
functional interface that observes
properties for invalidations and you can
implement a invalidation listener with
either an anonymous class or a lambda
expression right because in java 8 and
the validation listener is a functional
interface and we'll be using lambdas of
course throughout this talk ok alright
so there's two invalidation listeners
that we have in our program and this is
the first one that you see this one is
added to the controls that you saw in
the top left of the UI and this listener
enables the update button if the delete
button is also enabled when any of the
controls value or text property changes
right those were the text fields and the
spinner and the combo box and those
things when a reading is selected the
attached invalidation listener is what
makes the update button enabled as soon
as the user interacts with any of those
controls note that we're yeah so the
other invalidation listener that we have
below is added to the start date and
this one
Rhian voc's that filtered list that I
talked about when the start date becomes
invalid and this happens when the user
selects a date with either the date
picker or any of the range buttons that
we showed you and remember that the
table view shows the blood pressure data
in the new range and these changes as
you'll see will automatically propagate
to both the line chart and the bar chart
now let's show you the change listener
that we have in the program now a change
listener is also a generic functional
interface and it observes properties for
changes but a change listener the
difference in a change listener and an
invalidation listener is change
listeners give you access to the old
value as well as the new value here is
the example of our change listener in
the demo program the listener is added
to the table views selected index
property which changes whenever the user
selects a different row in the table
remember that when the user does this
either by selecting a reading in the
table view or the line chart we have to
remove the drop shadows and that means
that well need to know what the previous
reading was right so that's why we're
using a change listener here and inside
the lambda that you see here the old
value is used to remove the drop shadows
in the line chart and those are the
calls to set effect null that you're
seeing there okay let's go back to the
notes now and talk about what's really
interesting in Java effects and that is
the number of different binding
strategies that you have available to
you okay here they all are this is a
very rich concept in Java FEX if you've
done a lot of swing programming with you
eyes you know you're you have to work
pretty hard for all this and in Java
effects there's a lot of really nice
techniques that are available to you
that you can use so here are the four
binding strategies that I'm going to go
over and we'll we'll be talking about
those the each one separately and the
first one that I'm going to talk about
is uni-directional
and then we'll show you how we're using
that in the code and then we'll show you
the examples of each one of these other
ones okay let's go back into the code
now and show you an example of
unidirectional binding so what's a
unidirectional bind this creates a
dependency between a source property and
a target property when the depend
dependent property changes then the
target property updates now you need
directional binding is a one directional
binding and calling a setter on a
property that you have bound it actually
generates a runtime error you can still
call setters on a property that's bound
but you have to unbind it first also an
implicit setter is done by the system
the first time you call bind to sync the
values for both the source and the
target properties so the Laurel or
they're always in sync ok gales got the
example up for unidirectional binding
recall that with the buttons that were
up above the line chart allowed you to
move a forward in the data of range
dates or back and we had for an X button
and a previous button so when you look
at the to bind statements up there those
two statements are keeping those two but
in sync at all times specifically the
disabled property of the next button is
bound to the disabled property of the
last button and we do the same thing
with the previous and first button so
this keeps the state of those buttons
the same in all cases and in all
scenarios with just two lines of code
okay let's go back to the notes now and
talk about bind bi-directional which is
the second strategy that you have in
Java FEX this creates a dependency
between one property and another in both
directions
remember unidirectional binding was only
one direction here you can have a
binding in both ways and with
bi-directional binding you can call set
it always succeeds with either property
now in our in our demo program we didn't
have an application or a requirement for
bi-directional binding but I gave I put
up a little simple example so you could
get the idea and the idea is is that you
have a label on your form and you have a
beam in your model and you want to
always have the states of this label and
the beam always be the same so you set
up a buying directional binding between
you buying the text property of the
label and the UI to the word property
and a being and the behavior is is that
if the text property updates on the lis
on the UI then the model word property
updates and if someone calls a setter in
the model to change the word property
then the label will automatically change
and this is all done with one line of
code to keep everything in sync between
your model and your view and this makes
the UI designs much easier to implement
okay so now let's talk about fluent API
binding the the Java FX designers
realize that that they could help out a
lot of UI designers by giving you
libraries that are very very complete
and can allow you to do binding
expressions without having to do it
yourself
so the fluent API is a large library of
instance methods that you can chain
together with the Builder pattern that
means you can call them with dots you
know from left to right and they're all
the names of these methods are very
eatable so you'll be surprised on how
the clarity of your code will look when
you start using the fluent API binding
libraries the categories are separated
out into these so you have expressions
that handle boolean bindings number
bindings of course string bindings and
more general object bindings as well
okay let's go back into the demo program
now and show you a really cool way that
we're handling the add button remember
where I showed you that when Gail put in
the the text field values and and
backspace through one of them the add
button was being enabled or disabled and
I said we were doing this in one
statement and there it is right at the
top there so the disable property the
add button is bound to a binding
expression that uses the fluent API dot
is empty dot or and dot not methods so
what this is specifically doing is its
disabling the Add button if the text
properties of any of the three blood
pressure readings text fields are empty
okay the add button is also disabled if
it's not okay to add and I remember I
told you we had a separate property that
said whether it was okay to add or not
okay to add for example you can't add in
our program if a reading is already
selected and that's why we have the the
dot not there on that but that binding
expression handles all the scenarios for
whether the add button is enabled or
disabled and we're using the fluent API
and Java effects to do that
now the fluent API if you go back to the
notes that the fluent API is not the
only mecha
there's also a rather in even larger
library of factory method bindings that
you can use this is a library of static
methods that is invoked with the
bindings class where at least one
argument to each one of these methods
must be an observable type just like the
fluent API
there are several binding categories in
fact more here that you have they have
categories for binding expressions for
arithmetic so you can actually do
multiplies and divides and and
arithmetic numerics
relational and logical and of course
strings and then on some really neat
factory method bindings called
creational x' that I'll be showing you
in a minute
that allow you to create bindings on the
fly and then also factory method
bindings that work with observable lists
and and values okay let's go back into
the demo and show you some factory
method binding techniques okay all right
now remember above the bar chart I told
you that at all times the number of
readings that you're seeing which can be
is not always the same number depending
on on how many readings a person put
into the data for the blood pressure
we're updating that all at all times no
matter how the UI is being interacted
with with this binding statement and the
stat chart is the bar chart and we're
binding the title property here to a
factory binding expression and
specifically we're using the binding
Slotkin cap method here to create a
string binding to update the title
property in the bar chart we're also
using the binding dot size method which
returns the length as a numeric
expression for the systolic series and
then we need to convert that to a string
using the fluent API as string method
and what this does is it makes the
current number of readings in the line
chart always appear correctly above the
bar chart and I don't know if you've
noticed but what I've actually done here
is I've used I've shown you an example
that combines the static factory method
bindings with the fluent API so you can
actually put that all in one expression
like I'm doing here okay the last
binding strategy if we go back to the
notes is called custom binding and this
of course is where you just have to do
it your own way
right you know you've got something
complicated to do it's a it's a lower
level technique that is called it's a
direct extension method where you
specifically specify the dependencies
and then you override a callback method
where you can do an
thing I mean you might have to go update
a database or do something complicated
right and so you typically use custom
binding because there's nothing in the
bindings class or the fluent API
libraries that's appropriate and also
you know the custom binding can often be
more flexible and in some cases can give
you better performance as well all right
we'll go back in the notes once again
here and show you where we're using
custom binding and then I'm going to
show you another way with lambdas to be
able to replace the custom binding
technique with anonymous classes with a
creational binding using with lambdas
okay now you might have noticed that we
have the what's commented out here is
actually the custom binding technique so
I'll go through that first and then
we'll show you that it can be done with
a creational binding as well okay so the
custom binding is implemented with an
anonymous inner class so that means that
you select a binding abstract type from
a list of binding classes and then you
bind the dependencies in the superclass
so that if any of those update then you
get a callback for the result in the
compute value method that you see here
so it's a little verbose to work with
because you know you you have to create
the binding first and then you have to
override the method and notice that the
super dot bind up there is is listing
the dependencies for those properties
that are changing and then you get the
call back to the compute value and then
what we're doing here is where we have
the logic in here which determines how
to disable the first button in the UI
now what's interesting is if you is that
instead of doing this with an anonymous
class in java 8 we have lambdas so you
could do exactly the same thing and if
you scroll up a little bit they can see
that so what we did here was this is
actually the code in the end the UI
that's performing this operation we
don't have time to comment this out and
show you that it both works then you can
try that yourself but up above is the
java 8 way of doing this which doesn't
require an anonymous
and is a bit more concise okay so what
you see here is you see a bind call with
the bindings dot create boolean binding
okay that's the creational binding that
is in the factory binding library that I
mentioned and then you use a lambda
right where the code inside the lambda
is exactly the same code that you see
down below that you saw down below in
the compute value and and that's it
right so you know you've with custom
binding you know you still have the
ability to create callbacks and use
anonymous classes but you also now have
the option in Java a to use the
creational x' and also the lambdas as
we're doing here and I'd like to add
that it may not always be possible to
convert a custom binding to one of these
lambdas because what's in the compute
value for a custom binding can be
anything you want as long as you return
the proper type but you made for example
you may just want to have a print line
in there or you may want as Paul said ax
do something more complicated like make
a call to a database or something like
that yeah okay let's go back to the
notes now and talk about something else
in Java effects that that will really
help you with your UIs and this is
managing your data with observable lists
okay now JavaFX has a observable list
class but it also has a sorted list and
filtered list and we're using all three
of these in our UI all right now an
observable list holds your data and
notifies the listeners of any changes in
Java effects you can typically create
these for arrays lists or maps and you
use the static method a static method in
the FX collections class to do this now
the other ones that are interesting the
witch which we were able to use in in
our demo application is the concept of a
sorted list and a sorted list is a
generic read-only collection that wraps
an observable list and keeps its content
sorted with a comparator that you can
specify any attempts by you
to modify sorted list say with ads or
deletes will generate a runtime error
but the sorted list can change
internally whenever it resorts or when
it's wrapped list changes now I
mentioned that the table view was
filtering the range of datas at all
times when you're interacting with the
UI so we're using a filtered list in
Java effects to handle that this is also
a generic read-only collection wrapping
an observable list but it filters its
contents with a predicate and if you
know about filtering in in Java 8 you
know that a predicate is a condition
that can be true or false so
specifically if the predicate for the
filtered list is true then the data in
the wrapped list is included in the
filtered list for you otherwise it's not
and remember you don't have to write any
of this code it's doing all this for you
right and that's the point and that's
why it's why it's cool now again any
attempts by you to modify a filtered
list with adds or deletes it's going to
generate runtime errors however the
filtered list can obviously change
internally
whenever the predicate is applied or
whenever the Rapala changes okay let's
go into our demo program now and show
you how we're using observable lists
okay the first one at the top is the
backing list this is created with an FX
collection a dot observable ArrayList a
method call and this holds the blood
pressure data that you saw underneath it
is the sorted backing list that's
created with a sorted list constructor
and wraps the backing list above it the
lambda expression in the constructor
defines your compare function or our
compare function that sorts the data in
the blood pressure data now the filtered
list is created with a filtered list
constructor and wraps the sorted backing
list that's right above it once again
we're using a lambda in the constructor
to define the predicate for the filter
now you'll note that the predicate is
initially false which means that the
filtered list will be empty however as
the program runs and the user interacts
with the UI the filtered list will get
populated according to the selected date
range
or by redefining the predicate now when
data is added to the backing list the
sorted list keeps the data in the
correct order all for us we don't have
to worry about that at all
and also the filtered list will apply
automatically apply the predicate to the
new data to see if it's within range or
not now the line chart also has three
observable lists and this is created by
again the same static method that we
created the other ones with the first
list that you see here is the systolic
readings the second list the diastolic
and the third is the pulse data and here
each list is and is a JavaFX XY chart
data type with a date string on the
x-axis and a reading number on the Y for
the y-axis okay so now let's move and
stay in the code but now we want to show
you that we're using sorted lists for
the line chart as well and here gales
bringing those up right now there they
are
okay now the line chart has three sorted
lists that are all created again by
sorted list constructors the first
argument in the sorted list constructor
is the observable list for the blood
pressure reading that you're looking at
and the second argument is a lambda
expression that defines the compare
function to sort the dates in the blood
pressure reading note that we're using
the same custom comparator here for each
one of the sorted list and specifically
what this comparator does is it converts
the string representation to local date
and time objects to do the comparisons
and then this way the line chart keeps
its display data sorted by date at all
times and when data is created and added
to the line charts wrapped lists the
sorted list keeps the data in the
correct order at all times
okay now let's go back to the notes and
talk about how you can wire these
observable lists to your controls and
JavaFX
and these are the interactions that
we're showing you here
okay now recall that the backing list in
our program holds the blood pressure
data that
be added removed or updated now the
sordid backing list wraps the backing
list and resource with a date comparator
and then the filtered list wraps the
sorted backing list and uses a predicate
to determine the date ranges now what
you want to look at here is the call to
set items with the table view control
that's the BP table right and the
filtered list argument makes the blood
pressure data sorted and filtered in the
table at all times
the table view will automatically update
anytime the filtered list changes once
this items property is set now likewise
the sorted list for each one of the
charts wraps the observable lists with
data for each line chart series and we
use a custom comparator there like we
said for the resorting now the call to
the set see the calls specifically here
to you yeah where was that oh you know
that it's where were yeah the set data
that's where it is the set data right
there that one is going to make the XY
charts sorted to the line chart at all
times and just like the table view
control the line chart will update
automatically when any of the sorted
lists change once this data property is
set for each series okay let's go into
the notes now and show you another
listener that you can use with
observable lists and this one is called
a list change listener now what's a list
change listener this is a generic
functional interface that notifies you
when a changes are made to an observable
list and it uses a nested class that
will report updates removals additions
and permutations anytime that happens to
your list and typically what you do is
you iterate through this list with a
call to dot next and then you can get
the change and update your own specific
methods to determine what to do okay
gills brought up the list change
listener now in our demo program this
listener is added to the filtered list
that I talked about and keeps the line
chart synchronized with the table view
data you can see that we have a while
here and we're going through and if the
change was removed then we removed the
blood pressure reading from the chart
and if it was added then we call a
method to to add it you might want to
know that this listener can be called
with one change or multiple changes but
this is the technique that you use to
process that okay let's go back to the
notes and show you one more important
topic with observable lists and this is
something that isn't discussed a lot out
there but it's really important it's a
notion of extractors where an extractor
in JavaFX is a named property that lists
for changes on that property and
extractors can help notify you when the
name property updates in an observable
list now updates are different from
additions and removals this is why
extractors are here because without an
extractor to find a list change listener
will not trigger or notify you when
anything is updated in the observable
list and if you need that then you
should use an extractor and you can
implement an extractor with either an
anonymous class or a lambda now in the
example that we're showing here is
defining an extractor with a date
property and that means that if any of
the date property values change the
extractor will call the list change
listener and it will update the trigger
and this will cause a resort or Reef
filter depending on what happens with
the date property now when you use
extractors you can then call the was
updated method in your list change
listener and and then you can that will
make the sorted list resort and the
filtered list Reef filter now you should
be aware with some experience that we
have that extractors can sometimes add
additional overhead for your list
updates and it may be more efficient in
some cases to remove and add elements
instead of tracking them all the time
with extractors now in our program
because the filtered list prop has to
propagate to the line chart data we
decided not to use extractors so we
instead do
perform updates with removes and adds
and so we don't need to use an extractor
to keep the sorted list and the filtered
list properly sorted and filtered
however you might want to remember to
use an extractor and consider one if you
need to make your lists current when
you're applying any updates okay now the
last technique that we'll show you in
our first program is how you can do
binding with streams in Java 8 so Galle
will go back to the program one last
time here this first demo program and
we'll show you you know a really cool
method that we've used here that we're
able to once this will give you an
example with streams to see the binding
techniques again because we used we
several of these here in different ways
okay now this is a method called setup
chart bindings that's called three times
recall that a blood pressure reading has
those three series right and what we
have to do is we have to update the bar
chart
well statistics from what you see up in
the line chart ok so that's what we're
doing here there are two arguments for
parameters for this set-up chart
bindings method one is called the source
list and the other is a target list and
both of those are observable lists so
what we have to do is we have to do
three things here we have to calculate
the maximum value for the three series
we have to in each one of those we have
to do the average and we have to do the
minimums so what we decided to do here
was we wanted to show you that we could
use different binding techniques for
each one of those three actually we're
using a listener on the third one okay
so let's look at the first bind the this
uses custom binding to determine the
maximum the dependency is the source
list and the compute value callback map
that determines the maximum value so
what we do is we call dot stream on the
target on the source list and then we
use the map to int method to extract the
chart Y value from the stream and then
we can just call the max method in the
library to return the maximum and this
comes back as a Java eight optional and
B and because the source list is empty
or else method that you can call on the
optional that will give you a default
value and in this case a one now the
second bind has to calculate the average
and here we decided to use one of those
creational bindings with the lambda
again so you get to see that one this
one will be a create double binding or
as before we did a create boolean
binding in the lambda expression we're
calling we're doing the stream again on
the source list and then we call map to
int to extract the y-values from the
stream and once again there's a method
that will compute the average for you
returning it as an optional and again
we're going to do the or else method to
return a default of one if the source
list is empty okay the last one is
calculating the minimums here we decided
gee we don't even have to use binding we
can use an invalidation listener so we
use the same stream technique here to
map the y-values determine the optional
minimum and return one as a default and
I just wanted to add that this only this
technique while any of these techniques
here only work to reflect updates if you
use an extractor for the Y value
property that's one way you can do it or
how we do it is when we do an update we
actually do a removal and an add so you
have to do one of those techniques to
get this binding to work for simple
updates you don't have to worry on add
and removals that will always go through
but if you but we also want to have new
averages new minimum maximum Zhaan
updates and so you either have to use an
extractor or you have to do add and
remove for an update okay so we're done
with the first demo program do you want
to close that one out or yeah so gales
going to close that program now and then
we'll go back to the notes and talk
about the last topic here which is
JavaFX and swing integration
and she's gonna bring up this second
demo program for you now yeah and then
go back to the notes okay so we'll go
back to the notes now and let's talk
about JavaFX and swing okay
so next slide all right now if you have
to make JavaFX work with your legacy
swing code what's the plan you know
what's the reasonable approach here well
there's a really nice swing component
called jfx panel that you can use it
allows you to easily easily embed JavaFX
content in any of your swing based
applications and the reason why this
this is so nice is because if any input
or focus events occur the JavaFX panel
will automatically forward them to the
JavaFX scene graph and then you can
receive them on the JavaFX side on the
JavaFX application thread creating a
JavaFX jfx panel is trivial you just
instantiate it and as soon as you do
that starts up the JavaFX application
thread and here we just have a simple
example of adding a jfx panel component
to the middle of a swing container say
with a border layout now there are some
thread issues that you need to be aware
of when you're using Java effects and
swing together they're both separate UI
toolkits and they both have their own
threads most of you are familiar that
with the fact that you must call swing
utilities dot invoke later to on the EDT
to update any swing control so very it's
very easy to do if you just understand
the basic concepts and that is that if
you have to update a swing component
from the JavaFX thread then you need to
do that on the EDT and since we're in
java 8 now you can very easily do this
with a call to the static invoke later
method and swing utilities and then just
use a lambda to call your swing method
now you might have to go the other way
which is to update a Java effects
control from from the swing side of your
program and here you must do that on the
separate JavaFX apple
and threat and fortunately you know the
UI the JavaFX designers gave us a
complimentary way of doing that it's
just a different method a static method
called run later in the platform class
and you use a lambda once again to call
the JavaFX method which will be updated
on the application thread okay at this
point now I'm gonna turn it over to
Hareton and he's going to talk about
NetBeans IDE and the NetBeans platform
so one thing you could do when you're
creating a swing applications and
together with JavaFX is to use the
NetBeans platform as your basis you
would not be the first there is in fact
a very long list of applications that
you can see online from NATO north of
Grumman US Navy many other organizations
in the logistics defense aerospace type
fields all kinds of industries really
and you see at the top is a different
categories that you can take a look at
what people are doing and with the
NetBeans platform in the financial
sector and banks for example using the
nippies platform as the basis of their
back office application software and you
can also see on this page that there are
two kinds of applications there's that
I'm right with a key and those are
marked with an envelope and the ones
that are marked with an envelope are the
ones that are open source so you can
actually take a look at some open source
applications and learn from those for
example there's this integrated breeding
field book application created in Mexico
there is an application called agora
sense created in the netherlands very
interesting application for managing
farms so there's a whole range of
different applications that have been
created in this way what these
applications have in common is that they
make use of the services provided by the
NetBeans platform which typically in the
first place is a Windows system so
docking framework detachable windows
tool bar menu bar and these all come
with it and can be used depending on
your needs so this is what the
an application that you've seen looks
like on the NetBeans platform it looks
exactly as I did before except that we
have now a window system unless clearly
so you can float the windows out of the
frame and they will continue to work
exactly as I did before but until you
see it you see the other charts change
diddly and the other windows too right
everything continues to be synchronized
despite the fact that this is now undock
from the frame so these kinds of
services are standard part of the
NetBeans platform and I think it's a
benefit in the context of job FX as well
yeah great so what you guys want to do
probably if is to when you download the
code you know you want to see the
difference between these the design of
these two programs right because the
first demo program was a standalone java
FX application and now we've made this
even a more interesting UI because we've
integrated into the NetBeans platform
which not only has you know window
management like like john said but it
also has lookup services and a lot of
other things as well so yeah so do we
need to show them anything else in the
program Pete yeah so yeah that's right
so this is an important thing that we
wanted to tell you and that is is that
in our experience with working with Java
effects in the NetBeans platform and
we've done a number of different Java FX
applications with the swing based
framework we discovered that this is
really a great way to go for the design
and you could you take this approach
with other frameworks as well recall
that a window in the NetBeans platform
it's called a top component so what you
can do is use this arrangement to
separate the JavaFX code from the top
component swing code and what
specifically is the top component will
instantiate the JFX panel and invoke the
F XML loader and then the F XML loader
will read in the F XML build the JavaFX
scene graph and instantiate the Java FX
controller class then the top component
will invoke controller public methods to
manipulate the scene graph and this the
squiggly line that we
have in between the top component and
the job effects controller represents
the fact that you must do that on the
JavaFX application thread and that way
the controller code does not directly
invoke any methods in the top component
we found that that this is a really nice
way to integrate Java effects into into
the NetBeans platform applications and
to make everything work correctly so
let's go back to the program again and
did you want to talk a lot to talk a
little bit about the organization right
so gail's is going to take a couple
minutes to talk about how this program
is organized since it's done it's
designed differently than the standalone
program okay the one of the other nice
things the NetBeans platform provides
for you is that allows you to break up
your huge monolithic program into
separate modules that you can maintain
separately and that's exactly what we
did with our blood pressure reading
monitor program so we broke it at one
single program we broke up into six
modules two of them provide services
that other the other modules use one is
a private implementation module that no
one else really accesses but does all
the work and the other one is a model
module that has both our BP data module
class and any management in which the
other modules can access the data and
then the other four modules are the
separate windows that each have been
broken up into separate modules and so
go back to the
so each of these four windows are
separate modules and we can interact
with them before and everything's the
same and then yeah and we yeah you know
sometimes people say well you know
JavaFX is cool but maybe it's just about
spinning circles right well we couldn't
resist the temptation to have in in in
our code here of spinning graph this is
actually super easy to do because you
know animation techniques and rotates
like this can be applied to any node in
the JavaFX scene graph right so all we
did here was apply a rotate transition
to the parent node of all the scene
graph that represents the line chart and
it all is just easy to do of course this
has no redeeming value whatsoever but it
is kind of cool to look at right we
couldn't resist doing it but but that's
it okay so let's go back to the notes
now and we're we're gonna wrap things up
here is what we what we did today we did
quite a bit we talked about the
importance of using properties in Java
effects and we showed you how to use
listeners and binding techniques and we
went through the binding strategies to
show you that there's a lot of cool
things that you can do to make it easier
for you to design your UIs and not have
to write as much boilerplate code we
also talked about observable list sorted
lists and filtered lists which are also
in our demo program and we're using
those in interesting ways that you that
you might want to want to look out and
we also talked about extractors which we
we did ended up not needing in the
program but we still felt that we should
tell you about because they're important
too and then we showed you how easy it
is to do this in Java 8 with lambdas and
also specifically how to use binding
techniques with listeners and when in
streams in Java 8 we also took the the
demo program that was standalone and
Java FEX re-implemented in the NetBeans
platform to show you how to integrate
swing and Java effects together you
learned about jfx panel and the thread
issues and a little bit about how the
NetBeans platform can even make your UIs
on the desk
more appealing okay want to thank
everybody for coming here are our email
and Twitter handles if you want to
contact us with any questions you can go
to our website ASG teach comm and you'll
see the DevOps logo and things on our
site there and then you'll be able to
click there and download a zip file
right now the zip file says Java 1 2015
so don't don't don't think that's the
wrong one if it's there because we we
gave a talk that was similar a longer
talk when we were at Java one but it's
the same code and the zip file is all
there for you though that'll be the two
programs that we went through today and
you know you can you can do that so
we're right on the money here at 5
minutes left so I think we'll take some
questions now and I don't know if we
have any I can't see too well I don't
know if we have any microphones but yeah
but if you can yell out that would be
great and again you know we're looking
for some interesting questions because
we have some books to give away here so
questions you guys don't get books if
you don't ask yeah
to use annotations for binding I I think
you have to ask mark Reinhold that or
somebody Jonathon Giles somebody at
Oracle on the job epics site we're just
you know community people using it yeah
you know you might be able to do your
own annotation processing as as that but
we haven't we haven't heard of any of
that specifically but Jonathan Giles at
Oracle would be the person to contact
about that to see if that's on their
list or or if other people have
requested that another question it's
it's done on the job FX application
threat well it's done on the thread that
it's in so if that's a good question if
you're using binding you need to make
and any of the elements that are in the
bind statement refer to notes on the
scene graph then you must make sure your
binding occurs in the job FX application
thread so yeah that is it that is an
issue you can't use a binding with a
background task that would provide
problems there was another question
there was another question yes
okay that's a good question okay I the
fluent API is a smaller set of library
expressions than the binding in my job
in my JavaFX video I show people how to
equivalently do certain things like you
can do you can use the fluent API and
here's how you can use the bindings
class and you can do it either way but
the question the correct answer your
question is there are more binding
libraries in the bindings class so you
can especially with the creational x'
that I showed you you know there's no
way to do that in the fluent API so the
bindings class is larger and you can do
more things with that but I but I would
say that the fluent API is easier to use
and easier to read because can you see
that if you nest the bindings calls that
they would they would be nested out in
and out right with calls that are with
with parameters that are parts of other
ones or as the fluent API reads
left-to-right with the Builder pattern
right so I kind of recommend to people
to try and use the fluent API as much as
you can but there are definitely more
binding expressions available in the
bindings library yes it's already it's
already is partly and the the browser
inside NetBeans is the Java FX webview
so so the answer is where it makes sense
NetBeans will use a Java FX and that's
one place where it makes sense but I
don't see us rewriting the entire
NetBeans user interface to use
everything that Java FX has just on the
unknown Allen as-needed basis okay we
have time up for one more question yes
instead of instead of the F XML ya
Matisse there's a couple of different
plugins that you can install that do the
same thing so it's not the it's not in
native Matisse GUI builder but it's it's
a couple of plugins that provide that
exact same functionality so given how
many different things we want to work on
you know you you know and you look at
the fact that there are at least two
plugins that already provide their own
builder it's not going to be a very high
priority I think well and also a scene
builder which we didn't show you but we
use to build this application is a drag
and drop but it's standalone but you can
from the NetBeans IDE you can double
click on your F XML and scene builder
comes up so even though it's not
directly integrated into NetBeans they
did this so it can be used from any of
the IDE s and in its it is gluon
supports it and it's very good yeah and
there's and it's actually a couple of
plugins that provide integration of
scene builder directly internet being so
that's an external tool does not open up
but it's it happens with their NetBeans
so that's that's basically that the
support provided by the community for
that and we really do recommend the
concept of using F XML because it helps
you separate the view from your logic
controller model and controller class
okay so it looks like time is up
I like I like the question about the
fluent API and the binds class so if you
come on down we'll give you an
autographed copy of our book and I like
the question about the batiste Kiwi
builder and scene builder and so on you
can win the NetBeans IDE beginning book
ok so thanks a lot for coming and have
fun with java FEX</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>