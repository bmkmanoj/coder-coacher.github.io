<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What Haskell taught us when we were not looking! by Eric Torreborre | Coder Coacher - Coaching Coders</title><meta content="What Haskell taught us when we were not looking! by Eric Torreborre - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What Haskell taught us when we were not looking! by Eric Torreborre</b></h2><h5 class="post__date">2018-03-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aNL3137C74c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so hi everyone very happy to be
here my name is Eric I'm working for
silento silento is an online fashion
store where you can buy all sorts of
clothes shoes and all but what you might
not know about that under is that it's
also a huge tech company so we have like
two thousand engineers and we are even
recruiting more we are producing lots
and lots of software not only for the
website but also for all the warehouses
the data science lots of things that are
really interesting so if you're
interested in knowing more about that
ando please come and see me after the
talk I would be very glad to explain but
before I start I would like to know what
are you doing your daily programming and
especially what is your main programming
language so can you just raise your hand
if you are using one of those
programming language as you like your
main programming language it's like
almost everyone right so who is using
like a very obscure programming language
that is not here like a Pierre or
something what are using PHP oh okay so
then that brings me to my next question
so who is using a statically typed
language that's yeah probably majority
so dynamically typed who doesn't even
know what it is okay good okay so
probably your most of you are in the
statically typed camp so this is
actually what I'm using nowadays I'm
using Haskell and Haskell is quite
different from many of the languages
that were on the previous slide and
quite interesting but I didn't start
with Haskell I mean it was not I didn't
get an elimination one morning woke up
and say oh I should use Haskell I had a
very long journey to come to it and this
was my first programming project
professionally so this thing here is a
PBX where you can install in companies
in cinemas to connect all sorts of
phones and this is a pretty complicated
beast right the software for this thing
is
kated it's actually so complicated that
there's even a software to configure
what should go inside the box in the
first place so a customer says I want
100,000 out of 1,000 phones with those
functionalities and there's a software
just to configure that what should we
put in that box and that was the project
that was on it was a C++ project with
something that was incredible it had as
its main methods with the main logic for
configuring that thing was a 2,000 lines
methods uninterrupted with just a bunch
of comments and I had to use object
orientation and all my own skills of
French limited engineer to refactor all
that thing and that was a great project
I really loved it it was really for me
the way to test this whole thing because
I was reconvince that oo was the thing
was the way to go when you think about
oh you think about modeling the world by
finding some entities finding how they
communicate together and you have this
thing about inheritance where it's so
obvious that something is another thing
and they have this parent-child
relationship that's the great thing I
was very strong believer in oh I was
even more also a believer of UML like oh
I know this the soft software is is
complex so one way to tackle this
complexity is to use oo and I can
encapsulation and also put some images
on top of it we did some diagrams
otherwise we cannot understand what's
going on so I tried really hard in that
project to use UML to reverse engineer
the code to keep the code in sync with
the UML diagrams it was like really
crazy times but you know what I was
actually successful so I finished this
project we were able to refactor this
crazy method define nice object
abstractions and eventually were able to
evolve that software again because it
was reblocked and as a young engineer I
was I was thrilled I thought I have the
universal tool to help me to solve all
the problems in the world but then the
doubts started I had other projects with
Java and it's like evil cousin which was
just getting started and I started
different projects
and I must say that my success rate went
from 100% to more like 50% and I mean
there are many reasons for this there's
some of them you could say this the
language or the technology was not
really mature some of them were just due
to project management's and agile all
the agile methodologies were just
getting started at the time but when you
have such a success rate that is quite
low frankly after a few years I started
looking at other things and I tried to
come back to like the roots of my work
which is like okay I do I even program
what does that mean to program so I
started looking at other things and at
that time ruby was was a thing and that
already expanded my mind a lot Wow
you can do all these things with Ruby
you can create yourselves have very
compact expressions you can iterate on
collections using map and filter and
collect stuff that's that's great I was
really amazed and because I was mostly
working on a JVM there was groovy at the
same time and groovy was like giving me
the same kind of capabilities and for me
it was I'm amazed wow all the things I
can do now this power at my fingertips
that feel free great except for one
thing that was really important to me
the types so I had a groovy project I
developed that thing I was more or less
happy with it and I came back to it 6
months later I could not understand one
thing it was really frustrating so after
a while something else crossed my path
it was Cala that was great like the
types the JVM of this expressiveness and
many of the things that I didn't know
about and mostly about functional
programming so I took this very long
journey of learning the concepts trying
them out sometimes failing sometimes
succeeding doing some open source with
it sharing it with other people and I've
been very happy with Scala for a long
time
except that Scala is not Haskell and
when you want to do functional
programming really Haskell is a better
choice so today I want to show you that
after
during this journey I kind of reflected
to this journey and I realized that
Haskell which is the language that has
been around forever like 28 years it's
not as if it was born yesterday I kind
of realized that it's many of the
concepts you find in Haskell are
actually influencing other programming
languages because the Java I knew when I
started is not the Java there is now and
you can see all the evolutions of Java
kind of driven by what you can find in
Haskell so what is so particular about
Haskell so this is Michael snowman is a
very famous Haskell developer presenting
about Haskell and this is what he lists
as the main characteristics of Haskell
so it's functional language statically
typed has garbage collections okay
nothing new here but there are two very
important characteristics in that list
and that Mickey makes it a very specific
language so first of all it's a lazy
language which is pretty and natural
most of the languages when they have to
evaluate a function they start by
evaluating the arguments to the function
and then they evaluate the function has
strict evaluation Haskell people decided
that it would not do they would not use
this and it was just not because they
would like to do things differently is
that because when you have a language
that's lazy there are some patterns of
coding that are just nice so you can you
can very high you can have very easily
infinite lists it's not a problem you
have one dot dot you don't specify and
it's an infinite list and you don't
really care because it's just evaluated
when you will need it and there are
there are very useful patterns that you
can do with this but another reason why
they wanted this language to be lazy is
that because they said that help them
keep the language pure and they wanted
Haskell to be a language that was purely
based on functions just program with
functions to me that's the simplest
definition of what is functional
programming and a function is something
that takes an input does something with
it returns an output and there are rules
you cannot check the state of the world
outside of the inputs the only thing you
can exam
are your inputs and you are not allowed
to modify anything else but you can the
other thing you can do is return your
output it's quite a simple idea actually
right but it turns out that if you try
to program with just this simple idea
there are all sorts of consequences that
unfold and and that let the people doing
a house call to invent some of the
mechanisms they were not thinking about
when they started like how do you even
do a Oh
which is all about reading state from
the world and writing to the world right
so they had to invent some techniques
and that was very fruitful in that sense
so what does that mean programming with
functions for other languages all the
ones I've listed before what do they
have functions are they using functions
in any shape or form very now a days you
see some some some article saying hey by
the way you can use functions in Java so
Haskell people for them it's it's just
yeah what the deal I know it's nice and
the article goes on listing all the
advantages of using functions in Java no
side effects very easy to test very easy
to move around
no concurrency issues I mean it's like
the best thing you can have so I mean in
any Java project if you find one of
those please extract it put it somewhere
it's just the perfect candidate for a
piece of reusable software it's so nice
but in a wave functions were having
presenting in Java and object
orientation for quite a while I mean if
you look at a book like the design
patterns book many of the patterns
already described some sort of functions
some ways of taking functions moving
them around and so on with the command
pattern the action template method and
even in the JDK you find things that
look like functions already like
comparator interface or a callable
interface or file filter all those
things are like example of functions but
what was really missing from Java and
that Haskell has had forever because
it's a functional language is functions
really as first-class entity something
that is really generic just from A to B
that's encoded in the types
and that you can move around that you
can use as a parameter to something else
and that that opens all sorts of
possibilities and one thing that opens
in particular is nice
streaming libraries so a much better
collection library where you can have
oops that went too fast where you can
have Matt filter distinct all those
operators to act on a collection of
element it's much nicer to write this
code than to have to iterate over a
collection of elements to have some
variables to keep some state and so on
you can write some code that's much more
concise much more testable easier to
read and maintain but again for Haskell
people what it's not very new right I
mean even the syntax is is a lot better
and cleaner to do that thing which is
quite nice and also in Java there are
some pitfalls so I took from the same
cheat sheet about how to use streams oh
there are pitfalls be careful you have
mutability oh yes and in Haskell you
don't have mutability
but you can see that Java people didn't
know about immutability issues so it's
you will find very frequently articles I
mean there was a talk about immutability
write about be careful with mutation
there was a full talk about that how to
use immutable java objects and even
someone like Josh blush in his book
about effective Java said whoa don't
mutate your data unless you have some
very good reason to do so because if you
mutate your data I will have problems
with threads or concurrency in general
you might put some mutable data as a key
to a hash map that's very bad who did
that already yeah that's very bad ah
okay bad bugs
so we discover something that Haskell
people have known for forever again that
well immutable data structures they are
pretty cool so what that means is that
progressively in the JVM worlds and
elsewhere people are kind of
rediscovering all the advantages of
having pure functions on one hand and
immutable that down on the other end
and where the the parodying for
programming is more like you create some
data you transform it and you consume it
you put it somewhere else
it's like having a huge function doing
something and that function can be
composed of smaller functions and many
of the business apps many of the apps
are our services that we that we create
can be more as crammed into this
parroting right and for functional
programmers that's just the way they see
the world they don't see the world as
objects communicating with each other
that's that's how they see the world so
we need to talk about data again this is
not so much of a big news for on the
Java platform in a way because data in
its simplest form existed for quite a
while so you have things like pojos well
yeah it's just a bunch of films right or
details data transfer objects where it's
not really an object is more like again
a set of fields that you need to
transfer from one place to another or
value objects but the thing is to
manipulate this data efficiently to
declare it with the least ceremony
possible you have to have some of the
things that already again exists in
Haskell and that have been imported in
other languages so in Scala you have
something called a case class and its
companion object it's a way to very
easily declare some some bare data with
fields and each field as a type and you
get for free methods like equal hash
code to string the kind of thing that
you would need generally need an IDE to
generate this comes for free you don't
have to do anything and also in scala
you can put many of them in the same
file you don't have to put one in each
file so it's very convenient to create
this this these data classes this
support for just pure data is so useful
that now you find it in caffeine so
there are data classes in Kirkland and
people doing closure will say well no
big deal because we've been using maps
and list forever it's not a problem for
them is just like they're universal
objects they already have it and I was
quite surprised when I prepare this talk
to read
this blog blog post like last month
Brian guts is proposing data classes for
Java so I think this is again a
testament that Haskell with this way of
seeing the world is slowly transpiring
through other languages and people see
an advantage is an advantage of creating
data and just having if some facility
for just dealing with this concept just
pure data again Haskell is really
language that design designed to do this
so this is how you declare that's
boolean data type in Haskell you need a
bit more ceremony even in a language
like Scala to do the same thing so but
still it's good that you can do it now
an interesting parts you have functions
on one hand you have data on the other
end and it opens again a new world new
possibilities that you might not even
think about and especially one thing
which is pattern matching this is Steve
Yeager and he wrote a blog post a few
years ago where I learned about pattern
matching never run about that before so
in his blog post he was describing how
they had this internal Amazon contest
for coding and coding challenges and he
said Wow the Haskell guys Wow they did
something great in just one line they
were able to take in a list of lists
just the elements that were important to
solve the problem extract them give them
a name and then write the condition
based on those named problem solved
whereas in Java you will have to open
several if-then-else check if you're
respecting the boundaries of your list
and things like that
and it will be a lot more tedious to
write this kind of code so something
like pattern matching has been from the
beginning in Haskell because you have
data you want ways to extract it and now
it's coming to other languages so you
have it in Swift so you have it in
c-sharp and guess what it's coming to
Java it's coming to a Java near you
great so you will have data classes you
will have pattern matching there might
still be a reason why people are not
we do this from the beginning is that as
a language implementer pattern-matching
is still something that is hard to get
right look at the scallop bug tracker if
you want for pattern matching matching
bugs you will see lots of them it's hard
to get right it's hard to make it
performant and so on so lots of research
needs to get into this thing to me to
get it right even in Haskell it's only
until some very recent Haskell versions
that they were able to have a more
complete way of pattern match all the
different types of data that you can
create with Haskell
so this is kind of complicated but as
you can see this is something that's
coming from functional programming
that's slowly arriving in mainstream
languages not for any reason just
because that is really really useful and
really really expressive so what does
that mean 400 in general for the way we
program so this is a classical object
right and this is what I learned about
all when I started so an object has some
hidden state some identity and all of
this is encapsulated with nicely defined
methods and the behavior of a given
method can change based on what's inside
the internal States but you don't get to
see what's inside it and that that's
what an object that's what an object is
and it can communicate with other
objects but now we are talking about
more and more putting all of this apart
putting the functions on one hand and
make them pure putting the data on the
other end and make it in YouTube all wow
that's that's very different way of
seeing the world so in a way what we are
doing when we do this we are moving away
from all it's it's a different way of
seeing the world and I think there's a
fundamental reason for it is that Oh
especially with mutation like that is
super hard to get right because if you
picture all those objects talking to
each other
composing their state with each other
you get a communitary or explosion of
states what can happen I don't know
because it depends on so many hidden
variables it's very hard to predict most
of the behavior of that system is going
to be
somewhat emergent right it's like colony
of ants you know how each of one is
programmed you don't know what's going
to happen with the full colony necessary
so I think we're kind of moving from
this kind of program we don't want this
anymore
and there's another domain where we are
probably also moving from this kind of
domain and for me it's kind of
interesting because when I was solved oh
and how people were setting Oh like in
the 80s was for you eyes and you eyes
were like the perfect candidate for you
have all these widgets they have their
own internal state they communicate with
other widgets there are can be part of a
hierarchy of widgets where they have
some common properties about having a
border or having some buttons and stuff
like that it was like the perfect
candidate for for using oh right
but maybe 20 or 25 years later people
are coming back from this idea thinking
oh maybe it's not such a good thing
because of what I said it's very
complicated in terms of state
management's it becomes really
complicated and people in Haskell I've
been wondering about that for quite some
time and came up with some very simple
concepts about modeling the behaviors of
something as a continuous function of
time modeling what what is an event
something that happens at discrete
moments in time and finding some ways to
compose those things to get more
elaborate behaviors and it turns out
that this is just extracted from the
documentation of one of the libraries to
do functional programming reactive
programming in Haskell and with the
right combinators well you can
definitely describe what happens to a
data structure that is representing your
UI and and this is all composable and it
has nice properties you can reason about
it you can know you know what what
what's happening with it and you
possibly went to other talks in this
conference telling you about react and
telling you exactly what those things
how we how we extract the state from the
functions just to make the damn UI that
are so complex a lot more manageable so
in a way
this might just be the last nail in all
scoffing I'm not predicting that Oh
we'll die tomorrow because we have such
a huge inertia in everything we are
doing it might take one maybe two or
three more generations I don't know but
I really get the feeling that we have
the strong influence of functional
programming moving us away from Oh
slowly but surely to go where well to go
to a world of smart functions acting
just on them data and I think that's
quite nice so the the first part was
really about how Haskell and functional
programming languages in general make us
see the world differently as functions
taking that dealing with that extracting
it's describing behaviors things like
that but one very big characteristic of
Haskell is that it has a very good and
very elaborate type system and I want to
give you some examples of that today as
Java or C sharp developers you are used
to use a type system but maybe you don't
realize that there are types beyond
types there are other types that could
make your life easier that you never
even thought about so let's have a look
at that but before we go to the
complicated types I want to show you
what you can do just with the simple
types because it's very nice this guy is
Yaron Minsky this is not a haskell
developers or camel developer but he
coined this phrase that's really great
is we should make illegal states and
representable and that's a great way to
get correctness in our software so if
you have no way with your software to
build a state that's illegal if there's
no concrete way with your API with
whatever to build that you're done
there's no bug it's it's like correct by
construction so how can we do this just
with the tools are presented just data
and types well one way is to create
specific data types
just for a given usage let's see an
example
let's say you say I want I want the list
where that list should never be empty
empty for some business reason whatever
I know I have some identifiers in that
that thing can never be empty so it's
and that's important because if I
extract an element I want to make sure
there's always one that can never fail
in production I take the head of the
list there should always be one in
Haskell is very simple you create a
datatype for it and what does that data
type says it says I'm to create an
element value of that type you need at
least one element the first a and then
you can have a list of other elements
and that that that list can be empty is
another problem but you will always have
at least one element in your in your
data type it is correct by construction
and then you provide functions to act on
this data type and you cannot provide
any kind of functions so you can you can
provide map because map is going to
transform each element in that non-empty
list that's fine but what is the
operation for example that you cannot
provide on this collection filter yeah
filter is super dangerous
or at least you cannot think that filter
is going to return non-empty list so
then you have to say in the type of
filter that it has to return the list
because possibly you're filtering
everything out right and then your
software will exactly tell you that the
compiler will tell you exactly what it
is you can push this logic to any to
some complicated business logic so I did
a full presentation on that subject a
few years ago where I was showing how I
needed to synchronize files between as
free buckets a Hadoop cluster and some
ec2 machines and there were some
scenarios that were just not possible
because for as much you cannot run a
computation on s3 buckets so I had to
eliminate those scenario and I wish I
showed how you could encode this in some
types and because data types are very
cheap to create in SCARA
they are very cheap to create in Haskell
you don't think twice about creating
them you just create data types that are
appropriate to your situation and then
the compiler will force you to pattern
match everything
so the
Perea will tell you oh you forgot about
that case that combination it can happen
what did you do in that case and then
you say okay in this case is okay I can
I can proceed to the next step or this
case is just not okay I need to stop
here and tell my user that what he's
trying to accomplish just cannot exist
does not does not make any sense so
that's a very easy way a nice way with
simple things to make all software a lot
more reliable but we can do more who
knows this guy how many people but maybe
the other ones you know him by his
secret identity is super lamda man so
this is Philip water and he is known to
go to conferences and change his outfit
and be very spectacular about it so
Philip is one of the creators of Haskell
and I think he has he has had a very
strong influence on a language like Java
just because it was one of the persons
designing generics for Java so has
someone coming from Haskell having well
form types everywhere I think when
Philip saw that in Java you had lists of
objects it was like no we cannot let the
world happen like this I need to do
something that's my mission
so it teamed up with Gilad bracha and
martino turski to propose something and
it turns out that to add generics to
Java you need a bit of research it's not
entirely obvious one thing that makes it
a bit hard is that you have subtyping in
Java something that you don't have in
Haskell and that's that's an important
point I'll come back to that and because
you have subtyping in in Java you have
all these phenomenons that you have to
tell your user about oh is this thing
covariant or contravariant so for
example okay a list of oranges is
probably a list of fruit that's fine
that should work
not the other way around but there are
some situations where the relationship
is kind of inverted so if you are doing
testing for example and you have matters
too much values and if I have a match or
for an orange
I cannot match any fruit with that thing
on the other hand if I match our four
fruits
I can
probably try on try it on my orange and
Wow subtyping make things so complicated
it's hard
so one thing you discover when you come
from a language like Haskell where you
don't have the typing and when you try
to to do stuff in languages having
subtyping is that something that you
think as a nicety subtyping oh it's a is
a relationship there's everywhere is a
relationship they are useful they are
nice down good way to model the world
they actually make your life a lot more
difficult one place where they make your
life more difficult is with type
inference so in Haskell you have very
good type inference it's very rare that
when you write an expression you have to
specify what's the type of that
expression what's the type of some part
of your expression that makes it also a
very productive language because you
don't have to type that much and you can
transform your expressions and you know
that the types will just follow Java
when it was created and proposed to the
world people say wow that's a great
language but also really we discovered
after a while it's also very verbose
language you have to hold the hand of
the compiler and tell him eh this type
is this and if you don't put all the
types at the right place the compiler
would not know what you're talking about
and it should be about you so the
diamond proposal is a way to reduce this
gap between a language like Haskell and
a language like Java okay with the
diamond proposal later we were able to
say a bit less that was good and then we
are going to have in in Java local
variable type inference even better even
less thing that you have to specify and
it turns out that it's possible to
improve the compiler so that those small
and mundane types you don't have to use
them anymore it's to write them anymore
so that's great but unfortunately what
you will not get is super type inference
I mean I extracted the paper which is
not very old like last year people are
still researching was the best way to
have subtyping polymorphism and type
inference
this is still not it's still a difficult
program right so something that you
think is nice subtyping turns out to be
causing problems in lots of different
areas and I think what Haskell is
showing us is that it's completely
possible to write very generic programs
with lots of reusability without
subtyping and that might be surprising
but it works it is possible and it is
possible in particular because in
Haskell you have a great capability for
abstraction I'm going to give you one or
two examples and we're going to see how
this plays with the type system now I
see articles like this mano 8 for Java
developers what is the mano it and even
the other M word the Monad for Java
developers let's do a quick poll who
knows what a monad is okay so awareness
is growing right that's good maybe now
it's a lot more familiar it's familiar
because we hear more and more about it
now there are libraries in Java where
you can just use those concepts
functional Java waiver there are books
about it that's good if you use color
it's you will we will hear even more
about it I mean you go to conferences
and the world monad is pronounced in
almost every talk it's hard to escape
and functional programming in Scala is
even so good that people created two
libraries for it one was not enough
that's great too right let's do it even
in a language like Catalan all those
concepts are also arriving in cutting
not because it's fancy because they are
super useful because people for some
reason like cut plane but if they come
from from Scala they will really miss
those those concepts they really make
their life easier so let's have a look
at something that is directly imported
from Haskell that help us represent
those concepts in other languages like
Scala like Java and this thing is called
a type class I must say that first time
I saw the word type class I didn't know
what they were talking about is the
classes so it's not a class it's not a
present
of an old class it's a way to classify
types it's a way to say some types have
some properties and some other types
they have other properties let's take an
example so this is the mono e-type class
and this says I had four for a type A I
can do things I can have an element
that's always going to be the empty
element and this type a if it's has an
instance for this type class mono it I
can always ask for the empty element or
this type a allow me to take two values
of that type and smash them together
append them to produce a new one so if I
say it like this it's very abstract and
you might wonder what is it talking
about what does that mean well a very
simple example is int so the type int
you can provide an empty element that's
0 and you can provide an append
operation that's plus but there are many
many other types where you can describe
those those two operations so you can
describe this for Strings so you can
concatenate two strings you can this use
this type for lists you can concatenate
two lists you can use this for maps
that's hey that now it starts being
useful right when you want to
concatenate Maps you have a very
standard way to to concatenate maps and
once you have this abstraction where it
doesn't really depend on the type that's
going to implement this abstraction you
can describe some very generic functions
like Sun so you take a list of elements
and you don't Raquel what they are it's
not your problem the only thing you know
is that they have a monolith instance
and that's the only thing you need to
know and then you can specify how all
the things can be added together and you
can use it on a list of doubles for some
computations you can use it on a list of
strings that are separated by neurons
for example to do some display you can
use it in many different contexts so
this sum operation becomes like a super
swiss knife you can use it in many
different contexts that's great but in
Haskell we can go even one step further
in those using those type class and
which you can Jerry not do with
languages not having
such sophisticated type system you can
use higher candy types the name is
terrible I mean it takes some time to
understand what is a higher candy type
I'm using types it's difficult so let me
try to give you a hint about what it is
you have list of A's which is the case
where you have a collection of ace you
have a type that's optional a that's the
case where you can have an A or maybe
you have nothing you have a type which
is future of a which is you will have an
A but sometimes in the future another
type is either of a you might have an A
or you might just have an error it's a
big stop stop here no more computations
all those types they share some kind of
similar shape right there are more or
less some kind of M of a right and it
turns out that for all those types you
can implement a very useful operation
which is flat map where you take an M of
a you apply a function from A to M of B
and you end up with an M of B and with
this you can flatten list of elements
you can flatten some options and map and
flatten some options you can do
asynchronous programming with futures it
is such a useful operation to have it's
one operation takes some time to think
in your mind once you know it you can
use it everywhere
this is great and in particular this
will avoid this kind of problem so this
this happened today on my on my reading
list people fighting over the meaning of
array dot prototype that flattened
conflicting with the previous JavaScript
library that had the same method doing
something else so people because they
are reinventing the wheel all the time
just not taking the time to learn what
is the monads and just putting the right
name on top of it you are bound to have
those kinds of conflicts you are bound
to invent new names to work around the
fact that you fail to identify the right
abstraction when it was needed because
actually this abstraction is everywhere
monads you can find them in many
different contexts and you have the same
issue
Swift for example so Swift they have
three times the flatmap operation that
should actually be defined just once
with very specific type signature and
because it's defined three times there's
different semantics attached to it and
it makes things complicated so it's very
nice to have a language where you can
define type classes for those kinds of
types the types like M that take all the
types as parameters so like lists that
take an int and produce a list of int
that are like type constructors and this
those types are the types that we call
higher and kadek caning types and they
are in Haskell I mean they are you can
use them very easily in Haskell and they
are so useful again that when people
want to do type classes because they
want to do functional programming in
Kathleen well they propose to evolve the
cut-in compiler to include higher cannae
types they are super useful and I was
actually very surprised to realize that
even in Java
people actually already did it so there
is some kind of encoding of higher Conny
types that you can do in java using
annotation processors it looks crazy to
me I would rather use color than
resorting to this but well some people
they did really want to use Java but
they really want to use functional
programming so what do you do you do
this kind of thing that's just amazing
that you can do it
so in Java you're exposed in mainstream
programming languages with subtypes
generics but I really encourage you to
have a look at all the other types that
you can find in a language like Haskell
and are probably too come near to you so
higher kadhi types but you will find
that there are rank end types ooh what
does that mean I was when I was
programming in Scala thought the same
what does that mean and then I realized
oh my god that's exactly what I need so
this is how you learn those things as
you need them you realize oh that's the
thing or maybe you can just go to
haskell directly and you will learn it
from the source but there are exist
central types there are dependent types
and dependent types are even even more
so interesting that there's there are
languages based on that that are even
better than Haskell just to learn about
them and Idris is one of them so this is
it Reese is a Haskell like language
where you can actually have functions
returning types you can have functions
on types that's what what makes them
dependent and with this you can make
write some code that's where again
correctness by construction happens in
your code because you have the right
tools to do it so that's very cool so
we've seen that the Haskell inference is
definitely in the functional programming
use functions and data is definitely in
the type system how to make x type
systems better so that we can get more
abstraction things that can be reused
over and over again I want to show you
now that there's also great inference in
terms of libraries there are many
libraries about Haskell that in Haskell
that people don't know about but that
are just great and I want today to tell
you more about some of those libraries I
cannot do all of them all the ones that
like I don't have enough time to talk
about them so of course they are just
the basic functional programming
libraries where you have all the mono
eat the monads all the other
abstractions like traverse folder ball
what else semigroup I don't know many
others that are just useful for for
applicative very useful for for
day-to-day programming but there are
other libraries one of them is really
interesting and it's also very very mind
mind-boggling
just learning this library will take you
probably a huge amount of time because
you will have to learn many concepts but
it's actually quite useful it's just not
for the fun of learning because as soon
as you say oh we have immutable data
well you generally also have immutable
nested data data inside data inside data
inside data and if all of this is
immutable I mean as a programmer you
come up in to work one morning and you
say oh I want to modify that small field
here how do I even do this it's
immutable you have to reconstruct the
full store
her and so on that's super tedious right
so lenses are a solution to that problem
lenses are a way to describe those
transformations so that they are very
short very reducible very composable so
you have a lens one part of your
structure that you can compose with the
lens to another part of your structure
to make a bigger lens and it's very nice
to learn about that and for example
lenses has been already ported to Scala
almost worked word I mean you have to
adapt it to a different language but
there's a library in Scala called Monaco
doing the exact same thing because it's
just so useful you can do things like
modifying all the all the leaves in your
tree for example something that's
tedious to write with lenses it's just
easy it's called a traversal just do it
very useful for Jason right so there are
there are lots of applications where
this library and any library that you
can derive out of this is going to be
useful another one is quick check so
quick check is a testing library so who
is doing property based testing here not
a lot okay so I can see this is still
not a concept that has sorry that has
really come into mainstream so the idea
with property based testing is that
instead of writing test one by one with
by inventing some values and then
running a function checking the results
you will start by describing generators
for your data ways to randomly generate
data that you are going to use right and
there's lots of support in the library
to do this elegantly in a very
composable fashion and so on and once
you have this you discard properties you
describe something where you say for
anything you give me as an input data I
want my property to be true and quick
check is the library that's going to
execute those properties and by default
it's executing that property a hundred
times and sometimes and you can crank it
up to him 1,000 times if you want 10,000
times
I personally solved a bug which was
horrible to be three weeks to solve in
Java by getting some help for from Scala
check by running something 34,000 times
until I was able to find a way to
reproduce the issue so a quick check is
a very inspiring library
streaming libraries also very
interesting streaming is a difficult
problem Haskell has many different take
on what it means to stream data I really
you to have a look at it and in general
everything that has to do to with
concurrency and something called
software transactional memory I've never
been comfortable right using strategies
in Java I can tell you I'm a lot more
comfortable doing concurrent programming
in Haskell
it feels a lot safer to me a lot more
understandable okay but not everything
is rosy in the Haskell world there are
some issues and you need to be prepared
to this if you want to have a look for
example I think modules are lacking a
way to good way to in a way to describe
interfaces and hide do some kind of
software components I think a language
like SML or camel has a lot more
abstractions to do this I think this is
really missing from Haskell garbage
collection there's ton of work that has
been done with garbage collection in
Java there are even more improvements
coming up to the next version of Java
improving the latency and so on the
story here for Haskell's still needs to
be improved in some places so I think
Haskell can really learn from that you
see it's not a one-way Avenue just
hostile teaching others how to do how to
deal with life I think it can
incorporate more records the situation
is very embarrassing in Haskell so
records are like just data types but
with names for the fields and it turns
out that by default you have two
different break records and the names
will just conflict if they have the same
name it's it's just annoying there are
many ways around that I find none of
them is very satisfactory so I would
really wish that Haskell we just do
something namespacing like we like we
have in and solve the problem once and
for all
and finally IDs so unfortunately the ID
situation is not so good in Haskell if
he wants good programming experience you
will have to assemble different things
and maybe tweak them and maybe some of
them will break from time to time and
you will get nothing that's really close
to
you have in IntelliJ in Java where the
flow feels very very natural to do to do
many things so I hope have demonstrated
today that Haskell has a language as
like a reservoir of ideas has been very
influential to many other ecosystems and
it's probably going to do so I really
encourage you to have a look at the real
thing just take some time just try to
learn just write small programs make
mistakes spend some time just not
understanding what what's happening but
try to give you the go and you will not
regret it and that's it you have
questions yes yep ok so how do you do io
essentially monads have been invented
exactly for this so in Haskell you don't
like print line like that you return a
value that's going to describe how to
print the line this you return an IO of
unit in that case and this is still
functional because you don't do anything
just return a program that will have to
be executed and eventually your whole
application is an IO value that has some
audio effects and the runtime is taking
care of unpacking all those actions and
executing them so that's the trick that
people found on how to do i you the
second question is how to get started
there is a fabulous book called Haskell
for all no hassle for one is the name of
a blog I think that is called the
Haskell book you can you can have a look
at it we had reading groups in my
company just taking the book doing all
the exercises one by one trying to learn
from that start a reading group of the
book and that would be great in terms of
environments
the plug-ins for PS code are not too bad
I think they could be better I would
still recommend to use stack as your
building tool but maybe later you might
want to move to next there are still
some debates around what you should use
as a building tool IntelliJ there are
two plugins for IntelliJ you can also
start with that if you're comfortable
with IntelliJ because you will stay more
or less in the same environment I think
those those will be good starting points
in half shop so unfortunately yeah I've
never been a f-sharp user just know that
it's kind of a variant of ml for for
c-sharp I know that they pioneered some
interesting ideas like what is it called
the type the thing when you can you can
have your types like being modeled out
of Wikipedia and then help me here I
don't remember the name you don't know
okay
okay some some very cool things they can
do by basically created creating all
types at compile time that are being
checked but that come from
representation in the database for
example so that there are some very
interesting ideas here but I don't know
about the experience I would love I mean
if I had to do C sharp projects I would
probably try to do some my job first
before doing anything else yeah
any other questions okay so I'm
available after if you want to ask
anything thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>