<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Project Jigsaw: Under the Hood by Mark Reinhold/Alan Bateman | Coder Coacher - Coaching Coders</title><meta content="Project Jigsaw: Under the Hood by Mark Reinhold/Alan Bateman - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Project Jigsaw: Under the Hood by Mark Reinhold/Alan Bateman</b></h2><h5 class="post__date">2015-11-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UKC0uC7QUkI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good evening good afternoon good evening
no it's good it is evening now isn't it
what what times on em IM this talk is
project jigsaw under the hood my name is
Mark Reinhold I work on Java hi and I am
in the wrong end of this deck excuse me
dude alright it's always disturbing when
it says end of show on your first slide
so um quick show of hands I'm just
curious has anybody tried the JDK 9
early access built Oh excellent very
good has anybody tried the JDK 9 with
jigsaw early access builds excellent ok
who attended prepare for jdk nine
yesterday who attended intro to modular
development who attended advanced
modular development alright we're ready
to rock and roll we're going to do some
some module science we're going to
science the out of out of modules ok
first I'd like to do a quick review of
the modularity landscape because they're
they're kind of lots of moving parts
here first the Java platform module
system is being defined in the JCP for
java SE 9 the expert group for that
started its discussions back in February
of this year second the java SE 9
platform itself will be defined in the
JCP although that particular jsr has not
yet been filed this jsr will own the
modularization of the java SE api that
is the allocation of java SE packages
like drop it at lying and drop it up
sequel into specific modules third
project jigsaw is an open JDK project to
implement the java platform module
system that's Jeff 261 it includes
support for modules in Java C Java doc
and the Java launcher and so forth
project jigsaw also splits the JDK in
remember the jdk is the reference
implementation of the java SE platform
specification there are three jets for
that 200 201 and 260 these modules will
be an input to the java SE 9 platform
jsr when it modular eise's the java SE
api project jigsaw also replaces RTR and
tools jar with new runtime image and
directory layout that's Jeff 220 this
will help modularity in the long term
but it's not directly related to the
module system it's an implementation
change specific to the JDK with all
these jsr s and jets you might be
wondering what this talk is about when
you use JDK 9 and the features
implemented in project jigsaw you are
subject to the rules of the java
platform module system that's what's
under the hood so to speak so really
this talk is about the java platform
module system this talk has three parts
the first part explains how the module
system works with the language and
virtual machine to offer certain
guarantees the second part is about
migrating to modules the third part is
really under the hood what the module
system is fundamentally capable of
beyond what you can express in the java
programming language i'd like to set
some expectations for this talk the
style is quite different than the style
of a talk about say lambdas lambdas are
about the shape of programs in the small
individual for loops turning into method
calls with lambda arguments and then
growing into something that uses streams
perhaps you can reshape a program to use
lambdas without anyone noticing modules
are about about the shape of programs in
the large we deal with classes and
packages and get bigger from there if
you reshape a module it's quite likely
that other people will notice so this
talk is less about the code you can
write then the kind of systems you can
set up also because modules affect all
phases of development compiling testing
packaging deploying and running they're
much more connected to the tools
ecosystem than a feature like lambdas
which really only needs IDE support
tools like maven
Radel and Ivy don't support modules yet
but that's okay the jsr is still in
progress everything will be alright in
the end so if it's not all right it's
not yet the end part one accessibility
and readability everyone knows the
hierarchy of accessibility in the Java
language and virtual machine it's simple
to understand easy to use well maybe not
the protected part and strongly enforced
by the compiler in vm however it has a
big weakness the only way to share code
between packages is with public but then
you're sharing with everyone it's not
surprising therefore the package
friendship in one form or another has
been requested many times over the years
one goal of the module system is strong
and capsulation to allow a component to
declare which of its public types are
accessible to other components and which
are not the lines in italic are the
levels of accessibility connected with
the module system reading upwards from
the bottom you can arrange for types to
be accessible only within their module
or accessible within their module and to
other specific modules or accessible to
all modules as usual migration drives a
lot of our thinking we want to make it
easy to place an existing package into a
module and immediately give that package
the benefit of strong encapsulation we
don't want each and every public type to
be in a package to have to opt-in to
strong encapsulation so public types in
a package are not accessible outside the
module by default that is public on a
type declaration no longer means that
everyone can access the type this is a a
fairly big change now what happens if
someone tries to access a public type
that's not accessible here's an example
from glassfish it doesn't start on jdk
nine because the vm throws an illegal
access error the error message is
that's rather small class content
enterprise security provider policy
wrapper in module unnamed module cannot
access class send out security provider
policy file in module dropping out base
don't worry about what an unnamed module
means yet we'll get to that the point is
that the policy file class is declared
public but since it's a jdk internal api
it is now accessible only within the
java dot base module sorry glassfish but
you'd need to find an intern an
alternative to this internal api in java
SE nine modules are first class program
components like classes and interfaces
here's the declaration of the java dot
sequel module that contains JDBC it's in
a file excuse me it's in a file named
moduli info java in the directory named
after the module the compiler treats it
like getting up there java file and
translates it into a module info class
file which you can put in a jar file in
the normal way we call the result a
modular jar the package hire e hierarchy
exists in the same directory source /
gravitas equal so the module declaration
is outside of all the packages in the
module it's the job of the module
declaration to say whether a package is
strongly encapsulated or not it's really
easy to get strong encapsulation just
don't mention the package in the module
declaration to allow other modules to
access the package or more specifically
to access the public types of the
package add an exports clause you can
export to all other modules or you can
say exports to a specific module or list
of modules to give access only to your
friends at compile time Java Sea
prevents code outside of the java dot
sequel module from accessing types in
any packages except for those listed you
get the same compile time error as when
you try to access a package private type
from outside its package in Java 8 at
runtime the vm throws an illegal access
error like you saw with glassfish let's
dive into the vm more do
traditionally accessibility in the Java
platform is about who is doing the
access and what is the public protected
private flag on the target class at
runtime the vm uses the class loader of
the accessing class to find and load the
target class and then the vm checks the
flag on the target class because the vm
relies on class loaders people can
create loaders that only know how to
find and load classes of certain
packages loaders can in a way isolate
one package from another now in the top
picture here the class PC is trying to
access class QD the loader for PC knows
to delegate to another loader for any
class in package cues such as QD only
when that other loader has loaded QD can
the vm check its flags to determine if
PC can access it in the bottom picture
the loader for PC has no idea where to
find package queue so no access to QD is
possible from PC technically this is not
a failure of accessibility because the
vm never gets to check the access flags
of QD instead it's a failure of
visibility QD is invisible to PC still
the effect is quite powerful if the
class loader of the accessing class
cannot find and load the target class
then it doesn't matter if the target
class is public it's effectively
encapsulated whoever sets of the class
loader sets up the encapsulation
encapsulation based on class loaders
however is not strong encapsulation it
relies on packages being carefully
apportioned into different loaders but
that isn't how the JDK works most code
in the JDK is loaded by the bootstrap
loader while code on the classpath is
loaded by the application loader
spitting up lots of loaders for all this
code would be a compatibility nightmare
in any case there's no actual isolation
anyway you can circumvent class loaders
by getting hold of references to
java.lang.class objects once you have a
class
direct class loaders are irrelevant and
it's impossible to stop references to
class objects from being passed around
strong and capsulation is about being
able to prevent access even if the
accessing class and the target class are
in the same class loader and even if
someone is using query flexion to
manipulate class objects let's assume
that different modules are somehow
mapped to the same class loader can
class PC and module X access class QD
and module why another goal of the
module system is reliable configuration
to replace the brittle error-prone
classpath mechanism with a means for
program components to declare explicit
dependences upon one another so in order
for PC to access UD not only does module
y need to export package q but module X
needs explicitly to depend on module why
the formal name for depends on is
readability readability underpins
accessibility in the Java language and
virtual machine the accessing class PC
must be in a module that reads the
module of the target class why and the
module containing the target class why
must export its package q to at least
the module of the accessing class X you
can see that accessibility is a two-way
street X reads y and y exports package q
2 X and probably too many others note
that accessibility is independent of
class loaders just like before the
module system this is important for two
reasons first it means accessibility
works at compile time where there aren't
any class loaders second it means you
can reason about accessibility based
only on requires and exports clauses in
module declarations there's no need to
worry about the class loaders that might
or might not be in existence at runtime
in fact accessibility is pretty
straightforward a package is either
exported or it isn't but on readability
there is more to say when you depend on
a module you depend on a
hopefully coherent collection of
packages that it exports in some sense
those packages are the interface of the
module inside the module hundreds more
packages may sit encapsulated waiting to
help implement the interface more than
that when you depend on a module you
implicitly depend on all the modules it
depends on for example if you depend on
the Java activation module with its 35
classes then you also depend on the Java
desktop module with its 5580 three
classes if the watchword for JDK 8 was
functional then for JT k9 it's
transitive you should think in terms of
the transitive set of modules needed by
your application the indirect
dependencies can also be k can be as
important as the direct dependencies
let's see how readability handles this
I'll use an example of readability from
the graph of java SE modules the java
dot sequel module that holds JDBC
requires the java dot logging module
that exports the package Java util dot
logging everyone's favorite logging API
this lets code in the java dot sequel
module access the public types of Java
util logging such as logger you can see
that some code in the JDBC driver
manager class is newing an instance of
longer what if the api of the java dot
sequel module rather than the
implementation wants to use the logger
type for example the JDBC driver
interface has this method getparent
logger in it that returns a logger let's
look at this through the eyes of an
application module that uses JDBC called
Maya in order to use the driver method
that returns the logger the Maya module
not only needs to read the java dot
sequel module but also the java dot
logging module which exports the longer
interface it would be a pain if the
developer of my app had to remember to
say requires java dot logging when using
the API of java dot sequel well there's
good news the job at sequel module can
take on the responsibility of
remembering this for all of its clients
look at the Java that's equal module now
it says requires public dropping out
logging the word public here means that
any module that reads the java at sequel
module also reads the drop about logic
logging module for free no extra work
required the my up module doesn't have
to bother with requires java doubt
logging because it reads java logging
thanks to java dot sequel this is called
implied readability and it's very
powerful it's powerful because it lets a
module be refactored without breaking
its consumers for example suppose that
JDBC has a java dot sequel time package
that we'd like to ship as a separate
module this new module is at the bottom
right the java dot sequel module can say
requires public java dot sequels a time
so that my app which explicitly reads
java dot sequel implicitly reads
javadocs equal time it goes further we
could refactor the java dot sequel time
module by extracting a java dot the
sequel not date module the job sequel
that time module would say requires
public dropped on sequel to update so
that anyone who reads java dot sequel
time also reads drop it up sequel date
for free the Myatt module would be
completely unaware that any of this is
happening in essence the readability
model supports downward decomposition
any module you read can be decomposed
into new modules and readability of the
new modules can be recovered with a
requires public clause in the old module
you can see that the definition of reads
is actually recursive a module X reads
another module y by requiring it
directly or by reading some third module
q there's the recursion where q says
requires public wide and now that x
reads YY can say requires public z and x
will then read z now be careful once
people require your module explicitly
you can refactor it as much as you like
but you cannot delete it there's no way
for a module to stand in for another
module by taking its name as an alias if
someone requires x and that
is deleted then the module system will
not start core reflection everything so
far has been about accessibility in the
Java language and virtual machine where
the axis in class PC in the target class
QD were known statically accessibility
extends to dynamic class references that
you manipulate with the core reflection
API that is java dot lang but reflect in
this example c is a reference to some
class object the reference is dynamic we
can't control which object is referred
to by c at runtime maybe it's a class
object that represents a private class
of a nun exported package of an
unreadable module that is a class object
representing an inaccessible class
similarly we cannot control what ms
refers to it might be some of the
private methods of some inaccessible
class however we want to preserve strong
and capsulation even when core
reflection is used to access types and
their members the only opportunity to do
this is when an operation is performed
on a java.lang.reflect.method.invoke and
get and set on these classes perform the
same pair of checks the same two things
that the compiler does and the BM do
does the caller read the target module
and does the target module support the
export the relevant package to the
caller module even then set accessible
respects strong encapsulation suppose
you have a
java.lang.reflect.method.invoke will
fail it can't manipulate the
accessibility of anything in a non
exported package just like the get and
set method that methods on a
java.lang.reflect.method.invoke aller
module read the target module and does
the target module export the prolific to
the caller module if that all checks out
then the
private field can be made accessible via
set accessible true an advanced topic in
queer reflection is proxies java.lang
reflected off as a way to get an object
whose class implements various
interfaces the classes methods delegate
to an invocation handler that you supply
the class itself is meant to be secret
an implementation detail of the proxy
class in jdk 9 the proxy class strongly
encapsulate the secret class by
declaring it in a nun expert of a
freshly created module this means the
proxy object must be invoked through
interfaces which is as it should be the
proxy class can even cope with some of
the interfaces being in unexploited
packages behind the scenes the proxy
class tweaks the module declarations to
export the interfaces packages to the
fresh module so that's accessibility and
readability the summarize accessibility
used to be a simple check for public or
same package in java SE 9 accessibility
strongly encapsulate smaj l internals
accessibility relies upon readability
which can be direct or implied and
accessibility is enforced by the
compiler the virtual machine and core
reflection parts two different kinds of
modules everything so far has been about
named modules modules explicitly
declared with a name in a module info
Java file what about jar files on the
clasp at that don't have a module in
photo class file they seem to be in some
weird world of their own to keep the
model of accessibility and readability
consistent we've introduced the concept
of the unnamed module all class is not
in named modules are implicitly in the
unnamed module it's as if everything on
the classpath is in one big special
module because it's a module we can ask
the two usual questions what does it
read and what does it export what it
reads is very simple every named module
all of them
as if by magic for free this means
anything exported by a named module can
be accessed by the unnamed module you
can turn a jar file into a named module
by adding module in that class to it but
the jar on the module path where modules
are found and the jars left on your
classpath will not realize that anything
happened that's a huge help for
migration the next question is about
what the unnamed module exports before
that though we should ask who reads the
unnamed module remember a goal of the
module system is reliable configuration
we believe very strongly that named
modules should not read the unnamed
module out of the box it would make a
mockery of reliable configuration to
make modules depend on the arbitrary
content of the classpath so you can't
write requires unnamed or requires
classpath or something like that and a
module declaration there are no reads
edges going out to the unnamed module of
course this is a huge hindrance for
migration because any jar files any jar
file you den a jar you turn into a
module cannot access the jars that are
left on the classpath in the unnamed
module the answer is the concept of
automatic modules you can take a jar say
guava jar and move it from the class
path to the module path this turns the
jar into an automatic module that's all
you have to do you don't need to change
the jar in any way an automatic module
is a named module declared implicitly
rather than explicitly its name is
derived from the jar file name in an
obvious way placing guava dejar in the
module path gives us an automatic module
called guava as before whenever you see
a module you should ask what does it
read what does it export the automatic
module guava reads everything in the JDK
image and the unnamed module it's as if
it says requires unnamed now the
hindrance to migration is gone you can
turn a jar into an automatic module and
it can still access the jars that are
left on the classpath we asked earlier
what the unnamed module
exports the answer is all of its
packages in j units are in glassfish
Gerard R and hibernate are precisely to
help the code in the automatic modules
which read the unnamed module because an
automatic module is a real named module
another named module can require it the
drop of FX core module says requires
guava so there is a reason to from it to
the guava module what does an automatic
module like guava export that's easy all
of its packages so JavaFX core can
access all of the public guava types
dropping FX core could even say requires
public guava to transmit its dependency
on guava up to its own consumers so that
anyone who reads JavaFX core will also
read guava for free so by moving a jar
from the classpath to the module path
you get an automatic module that lets
you start building your own graph of
named modules it is not necessary to
wait for every jar on the classpath to
be modularized by thereby all their
different maintained errs before you
start developing modules that require
them by the way what happens with a
second automatic module hibernate
automatic modules read each other and
all modules in the JDK image and the
unnamed module so guava reads hibernate
hibernate reads guava and they both read
all the modules in the jdk image and the
unnamed module in some sense they read
as much as they did when they were mayor
jar files on the classpath again the
goal is for you to take groups of jar
files from the classpath move them to
the module path require them from your
own modules and have everything just
work so there are three kinds of modules
we have explicit named modules such as
Java dot sequel automatic named modules
such as guava in this example the
unnamed module also known as the
classpath and we get lots of readability
for free to help with migration part 3
loaders and layers
I said before that strong encapsulation
is independent of class voters there are
no changes in the Java dot lining the
classloader API due to the module system
class loading does not change in some
sense the module system exists
underneath the VMS class learning
architecture not on top of it the module
system works with whatever loaders
already exist it doesn't create its own
weird and wonderful set of loaders so JD
canine has the same three built-in
loaders as JDK 8 the bootstrap extension
and application loaders some
implementation details of these loaders
have changed but that shouldn't matter
to most programs most modules that
you've seen like Javed Abbas and
covenants equal and Java logging half
their classes defined by the bootstrap
loader a few modules like Java korba
have their classes defined by the
extension loader a handful of modules
related to tools have their classes
defined by the application loader it's
important for security that java SE
modules be moved out of the bootstrap
loader if possible modules in the
bootstrap loader run with all
permissions which is not ideal from a
security perspective they can only be D
privilege that is run with fewer
permissions if they're not in the
bootstrap loader we've spent a lot of
time and effort on moving modules out of
the bootstrap loader so they can be deep
privileged frankly for a module as big
as Java korba 1833 classes and 31
exported packages that's no small
accomplishment the deep privilege itself
will continue throughout jdk 9 and jdk
10 while the module system doesn't
create loaders itself it is responsible
for associating loaders with modules to
help manage this the module system
introduces the concept of players a
layer is a family of class loaders that
together serve to load classes for a
graph of modules out of the box JTA 9
defines
boot layer consisting up the three
familiar loaders it's the boot layer
that associates the Java base and java
dot sequel and drop about logging
modules with the bootstrap loader java
Corbett with the extension loader and so
forth the boot layer is the only layer
that most people will ever have to think
about or indeed not think about but
there's a lot more to say about layers a
layer is created from two things a graph
of modules and a function that maps
modules to loaders here's the graph from
resolving the JDK DJ link module which
contains the J link tool for building
runtime JDK images and here is a lambda
expression mapping modules to the
bootstrap loader and the application
loader creating a layer informs the
module system about the classes that
will exist in the program and the
modules they'll come from the model
system passes this information to the vm
so that when classes are eventually
loaded the vm knows which modular class
belongs to and what mod what that module
reads and exports it's like the vm has a
shadow copy of the module graph that it
uses when checking accessibility between
classes because of fundamental
constraints on how class loading works
the module system must enforce certain
constraints both on the module graph and
on the mapping from modules two loaders
let's talk about the graph first this is
the graph of java SE modules what do you
notice about it anybody know loops
exactly there are no cycles in this
graph this is fundamental to the java
platform module system cycles would
bring an entirely new dimension of
complexity it's taken over half a decade
to detangle the tens of thousands of
classes in the JDK to the a cyclic and
relatively sane state you see here we do
not wish that pain upon anyone else
java application architecture is the
best book about modularity that i have
ever read in a section titled cyclic
dependencies of the death knell it says
excessive dependencies are bad but
cyclic dependencies are especially bad
the book goes on to say generally
speaking cycles are always bad however
some cycles are worse than others cycles
among classes are tolerable assuming
they don't cause cycles among the
packages or modules containing them
cycles among packages may also be
tolerable assuming they don't cause
cycles among the modules containing them
module relationships must never be
cyclic so that's clear enough let's turn
to another requirement on module graphs
a module may read at most one module
that exports a package called P if a
module could read more than one module
that exports p in which module would P
be accessed there's no answer the system
is just broken so we defend against this
only module graphs which obey this
constraint and have no cycles can be
turned into a layer let's turn to
constraints on the mapping from modules
to loaders remember the mapping is an
essential part of layer along with the
module graph there's only one constraint
it's due to a fundable limp fundamental
limit on class loader loading a class
loader can only create one class called
see if multiple modules in the graph
have a class called C then those modules
must be mapped to different loaders more
broadly we say that if multiple modules
have the same package then whether or
not they export at those modules must be
mapped to different loaders there's a
secondary constraint that's not
practical to check because it concerns
how loaders behave at runtime it's that
the loaders must delegate to each other
in accordance with the read the edges of
the module graph that is loader
delegation must respect module
readability the reason is obvious if
module X reads module why
then in order for excess classes in one
loader to access wise classes in another
loader X's loader must delegate to wise
loader there are no reads cycles in the
model graph so you might expect there
would never be delegation cycles between
loaders regardless of how modules are
mapped to loaders unfortunately this is
not the case you can get delegation
cycles if the map for modules two
loaders is bad oh is it all illustrate
this with an example from the JDK itself
in jdk 8 the four org w3c dom packages
you see here were present in arctic jar
and defined by the application class
loader however it turned out the jacks p
the JCP standard which in which includes
w3c technologies never actually included
these four packages their presence in
the JDK was unofficial what should we do
with them in jdk 9 it turns out that
Jack's P doesn't want to include them so
the obvious answer is delete them
however plenty of there are lots of XML
libraries outside the JDK which assumed
these packages are always present in the
application class loader rather than
make every library ship its own copy we
decided to ship them in its own in their
own module called JDK XML DOM this is a
jdk specific module not an SE standard
module you get this module if you
require it explicitly in the jdk module
graph there's jdk XML Dom near the
bottom in the boot layer we planned to
map the JDK XML Dom module to the
extension loader since it has no need to
be in the bootstrap loader this looks
good jdk dot XML de pomme requires java
XML and the extension loader will
delegate the bootstrap loader four types
exported by the java xml module great
unfortunately someone added a jdk dot
plug-in module that required JDK xml web
dom and they mapped the JDK plug-in
module to the bootstrap loader oops
there's no cycle in the reeds edges but
for class loading to work there would
have to be a cycle in the delegation
edges that's bad sooner or later a
delegate
cycle would become an infinite loop but
set that aside and consider this the
bootstrap loader never delegates so in
fact this mapping of modules two loaders
is just wrong given the reeds edge from
JD k dot plugin to jdk xml dom
fortunately we caught this in time one
possible fix was to rewrite jdk plugin
to not depend on these dawn packages so
the reeds edge from jdk dot XML or tom
will go away this fix might sound
unlikely but it's surprisingly common to
clean up parts of the jdk and discover
that you can cut many such dependences
another possible fix was to move JDK xml
dom up to the bootstrap loader well
that's not great the solution we
actually chose was to move data k type
plugin down to the extension loader it's
not trivial but it's the right answer
for the long term so going back to
loaders respecting readability there
should be no delegation cycles between
loaders just as there are no read cycles
in the whips in the module graph another
aspect of loaders respecting readability
concerns split packages who knows about
split packages ok so you've you've
experienced the pain a split package is
when multiple loaders define classes for
the same package sorry little you I
trouble here remember that a module can
read at most one other module that
exports p that's baked into the
definition of a well-formed module graph
if X reads y which exports p then x
cannot also be z which exports p if the
loaders respect readability then the
loader for module axe will delegate to
exactly one loader four types of p this
means no split packages which is a very
good thing unfortunately there are
libraries out there which include types
from packages belonging to java SE this
means a split package which
traditionally leads to class cast
exceptions if a library like this
becomes a named module then the module
system would detect that the module
exports the same package as a job
IC module the module graph would not be
well-formed and the boot layer would not
be created sorry oh great updates
available that's not what I wanted there
we go
but if the library is in the unnamed
module then the module system doesn't
detect the split package this is because
we don't scan every jar on the classpath
let's start up the results in this case
can be rather surprising so I'd like to
present two scenarios to you one
scenario is a drawer file on the clasp
at that contains non-standard types in
the Java annotation package in jdk 9
these types will be ignored because the
java SE module graph already has a model
that exports the Java Java annotation
package any code on the class path which
relies on non-standard types will get a
no class Steph found error because Java
SE doesn't have them this error sounds
bad but it means we avoid a split
package as soon as it would become
dangerous it's much better than the
program running with two distinct
versions of Java annotation because that
can generate errors at almost any point
in the program's lifetime and that these
kinds of errors are famously hard to
diagnose let's go through the scenario
in detail many years ago jsr 305
proposed annotation types to help with
bug detection the famous ones are Java X
annotation gullible and Java Act X
annotation non-null guava supports them
despite the fact that jsr 305 to this
day has not been finished the java x dot
annotation package is actually owned by
jsr 250 common annotations for the java
platform there's a module dedicated to
j's are 250 called java annotations
common it exports the java x annotation
package so guava jar comes along on the
classpath expecting to find the nullable
type thanks to jsr 305 jar than unnamed
module contains the java x an Edition
package but the module system doesn't
notice this when the boot layer is set
up instead the unnamed module the
unnamed author reads the job x dot
annotations common module with which
exports the true Java annotation package
and there's no nullable type in that
package guava gets a no class 2 founder
what's the solution for guava users one
option is to
v4 jsr 250 to include nullable and non
null types in the official job x
annotation package another is to lobby
for guava to include nullable and non
null types in its own package notice
that these are really governance issues
not technical issues and that's a common
thing we see when migrating to modules
here's a similar scenario but this time
with a better outcome for many years
Jack speed did not include the Dom
element traversal API from the w3c in
concrete terms Jack's p included the org
w3c dom package but not the interface
element traversal in that package the
Apache Xerxes XML parser wanted to
implement the Dom element traversal
specs so they included that interface in
Xerxes jar in jdk 9 when though w3c dom
package is exported by the job xml
module so the same package the package
in the unnamed module is ignored Xerxes
will get a no class that found error
just like guava this story has a happy
ending Jack's be agreed to include the
Dom element element traversal API in
Java SE 9 in concrete terms we added the
element reversal interface to the org
w3c Tom package in the Java XML module
it's as if jsr 250 agreed to add
nullable and non melz to their java dot
java x dot annotation package now
everyone who reads the Java dot XML
module including Xerxes jar and the
unnamed module can access the element
traversal interface the Xerxes version
is ignored but that's ok because the
interface in Java XML has all the right
members at this point we've covered
everything about the module graph and
the class loaders that could go into a
layer let's see what we can do with the
later as their name suggests layers can
be layered when a graph of modules is
resolved it's actually resolved against
a parent layer that then when the graph
helps to create a new layer the new
layer picks up the parent this allows a
set of models to have dangling
references of a sort
requires clauses to modules that the
module system will find an apparent
layer on the left resolution has set up
not only a reads edge between modules in
one layer but also a Rijo reads edge
between modules and different layers
constructing a tree of layers in this
fashion is the job of a framework such
as an app server or a test harness
layers give frameworks tremendous
freedom to organize modules at runtime
without upsetting the frameworks
traditional uses of class loaders it's
like the invoke dynamic instruction from
Java SE 7 a way for framework authors to
interact with the vm to reify
information about the overall shape of
the program if that sounds a bit
abstract let's look at one scenario
where layers help out layers are how the
module system supports multiple versions
of a module here an app server has
created two layers the Hoodoo player and
the JavaScript later each layer has two
class loaders and each loader has each
layer has the boot layer as its parent
so it's modules can read the java-based
module the Hadoop layer reifies a module
graph with guava version 11 and Jackson
version 1 while the JavaScript layer
reifies a module graph with guava
version 18 and Jackson version tube each
module graph is well-formed and mapped
to loaders in a sensible way but the
modules in the Hadoop layer are not
aware of the modules in the JavaScript
layer and vice versa but again please
note this is all thanks to the app
server creating the layers the Java
command-line tool that you use to launch
programs does not create layers like
this it simply Maps modules on the
module path to the application loader in
the blue layer given the complexity of
this topic that takeaway is is this just
as modules wrap up coherent sets of
packages and interact with the VMS
accessibility mechanism layers wrap up
coherent sets of modules and interact
with the class loader visibility
mechanism it will be up to framework
framework authors to make use of layers
layers in the next 20 years just as they
made use of class loaders in the past 20
years
so that was a deep dive into loaders and
layers summary modules do a better job
of encapsulation than class loaders but
class loaders are still necessary after
all we have to have a way to load
classes layers control the relationship
between modules and class loaders and
finally assuming class loaders respect
the module graph the system is safe by
construction there are never any cycles
or split packages zooming out here are
the three key points modules are
strongly encapsulated by the compiler
the virtual machine and core reflection
unnamed and automatic modules help with
migration and the resulting system is
safe by construction I'll say it again
there are never any cycles or split
packages in essence the module system is
a seat belt it's not a jetpack there's a
long road ahead the module system is
conceptually simple but in jdk nine its
associated with changes that probably
won't break your code but might break
code upon which you depend we've tried
to support migration as far as possible
but it takes only one unmaintained
library using a jdk internal type to
prevent a migration to jdk nine if that
library can't migrate the neither can
anything on top of it in this regard
modules are unusual they suffer from a
tragedy of the Commons whereas most big
features like generics or lambdas let
people opt-in at their own pace without
needing to wait for others we've now
come full circle we started yesterday
with a talk on prepare for jdk nine and
here at the end of under the hood i'm
talking about how to prepare for jdk
nine what can you do well try jdk nine
with jigsaw as many of you have here's
the URL for the download you can run the
jdubs tool which we've discussed in
previous sessions on your code and on
class paths of your applications
discover uses of internal api's and
eliminate them as
deprecated ur might say with extreme
prejudice and finally you can subscribe
to the jigsaw dev list on OpenJDK to
report problems and share solutions I
work for Oracle thank you very much so
we have 14 minutes left for questions
Alan has kindly offered to run the
microphone around so please raise your
hand or you could ask a question on
Twitter bye why don't you just tweet at
me I'm Reinhold ok I just wanted to ask
if you tested against Java cysts and
other libraries that actually manipulate
bytecode the runtime and inject classes
into class loaders and can eat you in
can we can even create classes in other
packages so you don't have access to the
actual file when when you load the class
it's by an array of bytes and it loads
it into the bite the classloader without
any checks on split packages and that
kind of thing your heir to this hour ok
so and most of these tools like Java
sister based on java.lang instrument and
that has already been updated in the
jigsaw bills to to work correctly with
modules there will be work that'll have
to be done and it's not in the bills yet
to be able to add some additional
support that agents will need but i
would think that most of the agents that
you have that are there now should
actually work try to try them out if you
run into any problems reported on the
jigsaw dev list excuse me where the
network is apparently down so I'm
switching to do
sencillo could you please explain one
thing for instance if you have some
module with two packages one is API and
another one is SBI in a Piazza with some
interface I a which is backed by some SP
a info for instance will it be able from
another model to somehow with static
method of interface get this
implementation up and running I'm sorry
that was a complex example well I mean
the simple thing I have exported
interface and hidden implementation is
it possible to be used with module
system yes of course yes yes exactly yes
you can have an implementation class you
put it in a package in your module that
is not exported mm-hmm the other code in
your module can access it the code
outside of your module cannot exactly
except perhaps through an interface okay
then my question is if I'm using
reflection will on runtime will get the
claws I will receive no the class of
interface but the class of
implementation right which is hidden and
zaza well we end up with situation when
I normally can call some public method
of this service provider but I cannot do
so with reflection I know you can you
can still do sorry you can i think i can
because well if i will receive the class
type of implementation not the interface
but implementation is hidden that's true
in that case by reflection you will you
will not be able to invoke the method if
you were not using reflection and you at
you and
an otherwise inaccessible accessible
method by an interface implemented by
that class then that would work just
fine but from reflection it will not
work so is it normal situations and I
mean you're breaking one of the icing
quite a common approach in programming
it was simply adopted Remy once once
answers we also have limited time so I'd
rather not I think we're give all on a
particular one particular question yes
it's a no more situation it's exactly
like if you have a class which is not
public which implement an interface by
reflection it will not work with our end
up for sardines yeah yeah hi so we have
Java class loaders and sub very long
time so then next thing obviously would
would be full in my perspective to have
dynamic loading of modules so I start a
GRE that is I know a couple of megabytes
and then i say i want java-based to be
downloaded from a repo or something and
then i want to kill something in the
virtual machine stays alive and use osgi
yeah but I mean not not for not for the
platform modules themselves but wait
what you're asking for is is something
far more sophisticated complex and
difficult to get right than what we're
trying to do do you plan to do it in oh
wait we are we actually we actually did
something somewhat like this a few years
ago if anybody here but remember the
java colonel feature that was an attempt
to dynamically download the jdk in
little bits and pieces as your program
used them and it it was extremely
difficult to make it work well um i had
a question about build systems and it
seems like use of you
it's you give dependencies in the module
system but like maven has also
dependency management do you think
you're going to need a whole new build
system to really make this work oh no
hopefully not are so so our hope and
expectation and we've already had good
conversations with a couple of the maven
committers is that maven will be
enhanced it doesn't need a rewrite or
anything but enhanced to to support
module that's one of the main reasons
that we chose to stick with the jar file
format despite all its drawbacks all the
tools understand it and if the
difference between a jar and a true
module is the presence of one more file
in the zip format that makes life a lot
easier for the tools ecosystem to adopt
so no we're not we do not expect new
build tools to be necessary it doesn't
mean you couldn't write one but like for
automatic modules you give the name of
the jar file and that's the module name
well no I an automatic module is defined
by taking its drier file and putting it
on the module path okay it the name of
the module is derived from the artifact
name and and don't worry if there are
version numbers we leave them out of it
that would be stupid to include them not
getting many questions on Twitter but
that's okay other questions in the room
I think in one of the last sessions I
don't remember which one it was you
mentioned that resources are never
exported so that's kind of unexpected
because I mean what you export our
packages and not classes and on the
other end I can imagine that this is a
problem for projects which have lots of
mapping files for I 18 or spring
configuration files or whatever can you
explain the reasoning behind this
decision sure so modules you know as
conceived they are they are their
program components for the language and
the virtual machine if you look at the
language in vm specs there is no concept
of resources
resources are are something at at a
higher level they're there they're
defined essentially by class loaders
there is there but sorry via the
reflection API you can get at a modules
resources so if you've got code that
relies on the ability to go poke into a
module and read you know meta and /
hibernate XML or whatever that can that
can still be done but there there's no
notion in in the mountain in a module
declaration of saying you know export
resource you know fufu / bar dot txt or
something like that there there said
there were some nasty nasty
compatibility issues also around the way
the class loaders handle handle
resources and so there are some slightly
incompatible changes as as code goes
from from from outside of a module is
migrated in into a module some of the
class loader get resource api's we will
will work differently but they kind of
have to in order for the overall design
to be consistent could you maybe shortly
another I tell me and cells look up with
provides and use works together with
layers how does service lookup work with
layers shorter a short answer is it's
it's kind of it's it's pretty much in
the obvious ways you start in the lair
you're in and you look for service
providers and then you then you move up
so a a provider in in in the layer in
which you try it try to load the service
will override you will appear first
before a provider later on Allen has
worked on this maybe wants to elaborate
more yeah there's an update to the
service loader API that actually has a
load method that takes a layer so to
actually be able to in the slide that
Mark had the layer of layers it's quite
obvious how it'll actually
how the lookup actually works and how
you can iterate over over over over
service implementations that may be in
multiple layers okay a couple questions
on Twitter automatic modules read each
other this creates cyclic dependencies
very good why is this not a problem well
it's it is a little bit of a problem but
it's it's it's it's worth accepting it's
worth accepting this in order to make
migration easier the cycles introduced
by automatic modules are not are not
introduced by the resolution algorithms
so the way automatic modules work is
resolution happens first we build a
clean acyclic module graph then we
looked around to see if there are any
automatic modules on the module path and
then those things are added to the graph
and you know as you noticed in the
diagram there there are plenty of cycles
so it yeah it is a little bit of a
problem but it's a problem worth having
because automatic modules make migration
so much easier when a module exposes
another module it needs to export public
the module well no it needs to requires
public the module isn't it possible to
do this automatically at compile time
well you could do it automatically at
compile time but that's probably that's
putting a pretty big burden on the
compiler and could lead to some
surprising results but we we are are
thinking about having the compiler give
you warnings if if you're compiling a
module and it exports a package and a
type in that package references a type
in it that's in some other module but as
but is but your model does not require
public that particular module so that
you're basically causing pain for your
users we thinking of having a warning
for that case at least the good point
the compiler would warn you you could
choose to ignore it but the compiler
would warn you do you think that the
osgi world will involve spectacularly
benefiting from the modules from the
Java code
spectacularly who knows I so you know we
we obviously we talked to people who
work on osgi Peter Queens is in the
expert group for the jsr you know we are
our intent is to make osgi interoperate
at least to some degree with the java
platform module system and it may prove
out that osgi itself can take advantage
of some of the strong encapsulation
benefits this sorry the strong
encapsulation mechanisms that we're
baking into the virtual machine but you
know that's more for for people who work
on osgi to to work out we've got time
for one more question as long as it's
short I don't even know where Ellen is
how will you implement plug-in
mechanisms where you don't know the
package at compile time and try to
instantiate classes or info public or
even private methods so we put I think
what you're asking about is is a
framework type thing that loads things
dynamically yeah layers are generally
the right answer so if you're
implementing a plug-in you with it you
for every brick every plugin you load
you would create a layer for it would
have you know one class loader or maybe
a few that would load your particular
plugin and relate the plugins modules to
all the modules that you already have
did I answer your question i'm not sure
exactly ok well the sign is telling me
the time's up so perhaps we can take it
out in the hallway thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>