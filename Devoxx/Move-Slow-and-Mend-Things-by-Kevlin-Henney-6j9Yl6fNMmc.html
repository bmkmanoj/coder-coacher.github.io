<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Move Slow and Mend Things by Kevlin Henney | Coder Coacher - Coaching Coders</title><meta content="Move Slow and Mend Things by Kevlin Henney - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Move Slow and Mend Things by Kevlin Henney</b></h2><h5 class="post__date">2018-03-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6j9Yl6fNMmc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">right good morning okay
so I wanna take a slight journey to
explore this alternative view move
slower men things always move fast and
break things is very much a sort of an
old engineering adage and it was
popularized in recent years by Facebook
but it's not their adage but they've
made it kind of popular and and I think
that perhaps we get a little bit
obsessed by a few things so some of the
things we get obsessed by is there's
kind of sense of haste and trying to get
things done really really quickly
without necessarily caring about what
we're doing and so this is actually
something that happened a few months ago
I was talking to one guy you know I
can't get this code working you said did
you check it before integrator yes I
checked it in the interpreter did it
work there no and this was a pattern of
his in other words there's the kind of
it somewhere there is a deep faith a
deep optimism within every developer
otherwise you wouldn't keep developing
it's just like well you know what it
didn't work on my machine you know that
one it's the opposite of it well it
worked on my machine well it didn't work
on my machine so there is entirely the
possibility that it will work in the
production environment so let's try that
there's you know against all
probabilities there is this optimism and
you have to be an optimist to be a
developer okay you can't be a realist
because you wouldn't do it and and part
of this comes down to this kind of this
obsession that we have with speed you're
always talking about speed I want to
about speed of performance I mean I
really wish people would pay a little
more attention to the performance of
various applications and bits of
software I'm always impressed that how
slow software can run given how fast
Hardware can that's what software is for
it's for slowing the hardware
okay that that's why that's what we do
but we have this obsession with speed
it's in our language all over the place
and I don't think I really appreciated
that until until the early 90s actually
when people started talking about rapid
application development so this is a pre
agile thing it's very much based on
prototyping rapid application
development
unfortunately cuz their focus was so
much on being rapid being fast that you
ended up with rapid application
development people just produce crap at
high speed and you know that hasn't
really changed to a great extent and
people use was like productivity and so
on these are all language this is all
the language of speed or velocity and
actually in the agile space we often
find people talking an awful lot about
velocity was the the sprint velocity was
the team velocity and actually what is
interesting is I really wish that people
would talk about velocity because
velocity and speed and not the same
thing in casual language they may be but
velocity is a vector quantity okay
velocity deals with the idea that there
is not simply magnitude which is speed
but there is direction as well and
that's the problem is a lot of teams
when they're talking about velocity are
actually talking about speed we're going
we're going really fast you know we're
we're burning down that we're burning
down the backlog we are setting fire to
the story points we are just running
through over the high speed yeah but
you're going in the wrong direction yeah
I know if what we're doing it really
fast and and that's the problem is that
what you have is this idea that a sense
of direction what do we mean by
direction in something as abstract as
software development well are we doing
good things with the code or are we just
produce are we just running up technical
debt as we burn down the backlog are we
actually addressing what the customer
and do we really understand the customer
because when you start using the term
the customer for me that's a watchword
that's a that's a sign that you don't
understand the customer because there's
no such thing as the customer
there's a company that wants something
and they are not a person they're a set
of people so although we use humanizing
language like the customer only in a few
cases do we ever deal with one
individual who actually is the person
who wants the software who uses the
software and everything
normally the customer is basically a
corporate entity of some kind there are
end users there are people who sign off
budgets there are there's a very complex
thing basically organizations are made
of people it's kind of like a socially
acceptable form of Soylent Green and
that's the that's the third problem
because what are you actually doing
because somebody may say we want this
but it turns out what the end user the
end users need is something else
so velocities heading in the right
direction and sometimes you have to find
your way and kind of feel your way there
so we end up with this problem of
focusing on speed as just the magnitude
and we we reduce it to a very simple
one-dimensional thing whether we are
looking at things in progress on a
Kanban chart whether we are counting
story points it's a it's a naive view
and unfortunately we end up optimizing
for the wrong measure so there's this
question of displacement and time that's
what we end up with displacement and
time how far have we traveled in what
time and there is a problem here that
depending on how we choose to measure it
here's a fairly typical kind of idea of
what a burned-down may look so so here
I'm gonna change s to mean from the
regular physics representation of
distance I'm gonna make s is gonna mean
something really technical I'm gonna
make it mean stuff okay this is software
functionality this is stuff these are s
is for stories it's whatever it is that
you're measuring this stuff in it's in
scenarios and whatever and it kind of
idealized burndown chart is yeah this is
what we're doing you know this is we're
heading towards the next release or this
is the end of the sprint we're burning
through it and it all looks beautiful
and they kind of ask a question you know
what are we moving s in coming I know
what to measure timing I've got lots of
choices for me
in time but what do I measure s in and
so let's just switch this around a
little bit because there is a problem
with looking at this burning down
sometimes you need to focus on building
up what is it that you have actually
created not so much what have we got
left to do that's can be helpful but
what have we actually created and then
we start looking again how are we
measuring what we've created and so as I
said time is time that's not a problem
what are you measuring a sin well here's
the curious thing when you talk to most
people
what are they measuring the work that
they have done in how are they measuring
their software how are they measuring
their velocity or speed well most of the
way they do it is they take their
estimates well they take the time that
they have spent and and this is a bit of
a problem because if I estimate
something of three days and then I'm
done then what I've done here is I'm
actually measuring if the amount of work
is measured in time then what we're
doing is we're measuring time versus
time which is actually not the same as
measuring how much software have we
produced how much functionality have we
produced and time against time is a
measure of utilization okay that's how
much time am I actually spending working
on software versus how much time am I
having lunch or being stuck in meetings
or whatever so time versus time is
actually not a very useful measure but a
lot of teams are measuring it and
there's another thing that it might
measure quality of estimation how good
are your estimates yeah again that's not
actually productivity that's not
actually how much software that is
useful for somebody have we developed
how much good how good is our code no
what we've ended up doing is measuring
utilization and quality of estimation
which is entirely not what people wanted
so there's a kind of a pseudoscience in
a lot of project management and
unfortunately is permeated even the
agile space which also adopts some
pseudo scientific language so if we
actually want to figure out how we're
gonna go in the right direct
I'm gonna borrow Boyd's doodle-loop
and Boyd was he's a US Air Force pilot
who basically sort of categorized this
thing which we find was then used to
reach her to Train Air Force pilots but
also we found it creeping into business
in other walks of life there's a very
simple idea of observe gather
information let's have a look at what's
going on understand where you're at
orient yourself okay
develop a plan for action carry out the
plan now one of the most important
things I think is fascinating here is
that when we normally think of fighter
pilots and and fighter craft apart from
the ridiculous price tag that such
technology has we normally think of
speed and yet notice how much of this
loop is not about being fast most of
this loop is about slowing you down
because it turns out you need to do the
right thing rather than the wrong thing
at great speed and there's this
orientation idea now I'm going to rotate
this round a little bit just to realign
it so we're going to decide act observe
orient and that actually maps nicely
onto something else that has permeated
business speak the lean space the agile
space plan do study act sometimes it's
called check its plan-do-check-act PDCA
I prefer the word study the original
Deming shuart formulation because it
sounds slow check is you know is that
okay yeah checked study sounds like it's
gonna take time yeah and I notice with
my kids because my older ones doing
exams this year and it's a case of you
know have you studied have you checked
your answers that doesn't take very long
but have you studied the subject that's
slow and this is important we need to
use the language that suggests that we
need to slow down a little bit it turns
out that this kind of thinking about
what you're doing is really important
and this whole thinking thing is
something that eludes many developers so
what we've got here is what we call an
empirical cycle
I've got a hypothesis I'm gonna do
something then I'm going to observe what
I've got and then I'm gonna figure out
what I'm gonna do next this is the very
basis of Engineering now it happens that
this year is the 20th anniversary of
anniversary half a century ago of the
software engineering conference the NATO
software engineering conference in
Garmisch which is a widely misunderstood
a conference it was not actually the
origin of the term software engineering
the term software engineering as far as
we can make out dates to Margaret
Hamilton she was responsible for leading
a team that developed much of the
software for the Apollo space program
and she used the term software
engineering to try and show the
parallels with other forms of
engineering hardware engineering and so
on and this term was kind of current in
the 60s mid 60's but they thought ok
let's let's have a look at this let's
actually explore what do we mean by this
stuff now a lot of people have gone on
to say well this conference you know it
set us down the path of plan driven
development it sent us down the path of
waterfall development and all kinds of
stuff I recently reread it I recently
reread the proceedings and what I found
was there was a diversity of thinking
there there is definitely not the kind
of the plan driven simplistic notion and
there's a lot of really interesting
quotes and the one relevant directly
here from Andy Kinsler's the design
process is an iterative one so this is
how you thought about design in 1968
something happened in the 1970s which
we've only just got back in the 21st
century the design process is an
iterative one in other words you're
going to plan do study out you're going
to converge on the right thing you're
going to start out saying we think this
is a hypothesis and we've ended up with
this fake language of commitment we're
going to commit to doing this
our architecture is a commitment this is
the architecture architecture is a
hypothesis your codebase is a hypothesis
this is how we believe that it should be
the running software that's a hypothesis
I wonder if the customer likes it does
this actually solve a problem does it
even work
that's a kind of an interesting
hypothesis should we test it no no we're
just gonna believe in it
now I think we should test it so there's
a one of my favorite authors Neil Gaiman
he has this lovely piece of advice and
this is for the creative arts and this
is exactly true of software as well this
is software as a creative art as well as
being an engineering form you have to
finish things that's what you learned
from you learn by finishing things if
somebody says we have a year to do this
no you don't you have lots of months you
have lots of weeks finish something
always be finishing always find yourself
at a point where you've finished it and
then stop this is the bit people find
hard because it's the opposite of
velocities or is the opposite of speed
stop look at what you built and go well
that went well we should do more of this
well that didn't go well what you mean
using yet another JavaScript framework
that was invented over the weekend by
somebody yeah
yeah no no I think it's gonna be the
best yeah but we're already using 20
different JavaScript frameworks you know
it's that's not the thing to optimize
for how many JavaScript frameworks did
you use and discard through the process
how many mocking frameworks are you
using oh I think we might be near 23
yeah no that is not the thing to
optimize for so there's this whole idea
of like pause have a look and go you
know that's working out really well
that's not working out so well
should we change things no no let's just
keep going really fast in the wrong
direction this is what you do it also
involves reacting to the situation it's
really funny that refactoring as a term
it's it's taken so long to be understood
and misunderstood the idea that design
is not a design is a process of
formulating a hypothesis doing something
and then looking back and then acting on
that and we lacked a name for the bit
that comes after and so people say
there's design and refactoring no
refactoring is continuous design it's
the looking at the thing ago you know
what we can change that we understand
more the term dates back turns dates
back about 30 years to Bill Opdyke and
just for those of you are interested
there's a new edition of refactoring
there's gonna be coming out at some
point martin martin fowler's working on
it
ah it's gonna be a JavaScript so I don't
know how you feel about that I know how
I feel about that
but but here's the thing when people
talk about refactoring they'd only think
about code and when we talk about
technical debt we normally talk about
code when we talk about the things that
you care for and when we talk about
development principles we talk about the
code and the problem is we have a very
narrow view of the code if you're a Java
programmer you're thinking this my Java
okay if you maybe think a little bit
more you know so I better try view other
things so we got some Kotlin in our code
base yeah we're cool
you're still thinking is the Kotlin it's
the java roots or whatever oh yeah is
there such a thing as a 100% you
remember a few years ago we got very
excited about 100% Java as an idea
everyone 100% Java system I ever looked
her had loads of XML it was not 100%
Java it was like American coffee he was
just diluted okay it was just you know
it's like what is this extra crap now I
don't want a liter of homeopathic water
with a trace of caffeine in it and that
was what most enterprise systems were
they're kind of like yeah we got some
Java glued together with loads of XML
but we're going to focus on the Java as
being the source of our concerns our
quality and our refactoring it's like no
we're talking about everything we're
talking about the tests when you
refactor and revisit we talk about the
tests we're talking about the scripts we
talk about all of these things the
configuration these are all language
these are all program you know your
configuration is part of your program
not something else see example that
later there's another way of looking at
this as well quite literally let's look
at let's look at code from a different
point of view let's look at the the idea
that what you're looking at is codified
knowledge now there are many different
ways that people try to reason about
code and I think that's very helpful
because it's a very abstract concept
what do we mean by it is it is it is it
an engineering plan is it a formal
specification is it an instruction to
the machine is it a mathematical
construct at some level or other many of
these have a truth
and some are more useful than others I
want to give you the idea that what
you're doing when you work on a code
base is you're codifying knowledge it's
a representation of your learning what
you're doing is individually or more
likely collectively you are trying to
learn how do we build the system you are
learning about the technical decisions
you are learning about the domain in
which you're working and that domain may
change as indeed may the technology it's
a constant state of learning so it's
codified knowledge it's a representation
effectively it's kind of a it's a
Wikipedia this is how we believe the
system should be built so therefore we
can say that software development itself
is a process of knowledge acquisition
yeah I'm just going to make another
point here knowledge acquisition is a
brilliant phrase use it when you are
talking to your managers so tell us
about your development practices in your
development process well we use a
knowledge acquisition model for our
process this is pretty good knowledge
acquisition is just a fancy way of
saying learning that is what you are
doing you are learning and it is an
ongoing process this is the main thing
about software development is that most
of what you are creating has not been
created before this is a really key idea
because you know what we do if somebody
says we need a system that does exactly
what that system over there does we give
them that system over there it's a it's
a solved problem in software you know if
my son says one of my son says hey you
know dad I found this really good app I
don't sit there and go oh we're going to
have to make it bit by bit I download it
in other words manufacturing is a solved
problem in software if you want copies
of the same thing then you you you get
the same thing that's it we're done
whereas in the real world to create a
second to create another instance of
something requires logistical work it
requires the movement of materials we
don't have to do that in software if you
go to a restaurant and you say and they
say well what would you like I want to
have what she's having they don't go
over to her
table and stealer that's rude they have
to go through a logistical process they
go to the kitchen they have an order
these things take time materials and
effort they try and produce an identical
thing in software this is a solved
problem we solved it in the 1950s okay
software development is not
manufacturing it never was it never is
it is all about the question of what are
we trying to build and how shall we
build it and these questions if you're
trying to build something new even if
somebody says hey look that's the
show-up system that dartnet system we
want to rebuild that in jail in a JVM
environment they're not asking for the
same thing they're asking for something
different because if it were the same
thing we just copy it they're asking for
something different if people say we
want that but slightly different they're
not asking for the same thing so
software development is all about the
not the creation of identical artifacts
it is about the creation of
differentiation which means that
somebody's asking for something that
they may not have thought of or you may
not be aware of so it's always something
new you are always learning
so if earning is the main backbone of
this then that means how do we do this
we communicate communication is really
important code is a form of
communication I'm still you know code is
a form of communication standing by the
coffee machine is a form of
communication it's still an open
question as to whether or not slack is a
form of communication who's definitely
formed something but we're not sure yet
we'll get back to you but it also tells
you your architecture and everything
it's about social negotiation why do we
care about coding standards why we care
about coding guidelines why do we care
about how the architectural this is how
we do things in this system mostly it's
social negotiation it's not for
individual benefit primarily it's for
social negotiation it's so that it turns
out that you can live with your
colleagues this is it's kind of like
this very simple idea we do this we do
this like this it makes it easier yeah
we choose this language we choose these
conventions or in this part of the
system we use these frameworks and these
languages in this part we use different
languages and conventions but there's an
idea it's social negotiation which means
again that's in flux
but it also means that what your
architecture is it's not smelly a
technical construct it's a model of
participation it shows you as a building
architecture would how people are going
to live together and work together now
all of this gives this idea I was asked
this question in an interview for Jax
London last year the biggest advantage
of water I was asked what are the
biggest advantages autonomously working
teams and I said well the biggest
advantage is risk reduction through
increased group intelligence that's what
you're trying to do you're trying to be
smarter collectively now it turns out
the intelligence is a very slippery
concept and people keep worrying about
artificial intelligence these days we're
not even sure what natural intelligence
is but it turns out there are ways to
increase and decrease natural
intelligence and this observation we see
in a number of cases there's little
correlation between a group's collective
intelligence and the IQs of its
individual members a friend of mine ran
a company a few years ago and he got
some really smart people and it was not
good okay they were all really clever
but it was a little bit like the England
Football team they re all really skilled
individually they're all really well
paid individually they can't play as a
team at all
I think 2016 England was beaten 2-1 by
Iceland so you know Iceland I think most
of their you know most of the Icelandic
team were kind of you know they they did
football in their spare time Iceland has
app I live in Bristol Iceland's
population is smaller than Bristol we
have two football teams in Bristol what
what was the big secret to Iceland's
skill well they played as a team their
collective skill that's what matters a
bunch of individuals you know what and
so there is this interesting question of
just having smart people and if you and
this is this problem that we often end
up with again in our quest for speed
let's get more smart people or let's get
people with these particular skills it
turns out the team playing is very
abstract skill being able to
work with other people or hell it's
really difficult and the interesting
thing about this research if a group
includes more women its collective
intelligence Rises ok I'm going I'm
looking out at you and I could say
collectively you could be smarter okay
but there's a point here it goes back to
the diversity this classic idea if
you're all thinking the same
then you're not thinking if you end up
with a team that has got the same
demographic background the same kinds of
degrees the same kinds of ethnic
background the same kinds of education
the same kinds of age all of this stuff
it's just like yeah this is not actually
gonna be that helpful what you need is I
don't mean you should get complete
psychos on your team because that will
certainly change the intellectual
diversity of your team but I'm saying
that the idea that everybody should
think the same way and have the same
background they're all drawing from the
same source
so James Surowiecki in 2003 published
this book the wisdom of crowds why the
many are smarter than the few now that
we do have this problem he there is this
idea how do you get people to be
collectively smart because we also
recognize that people can be
collectively stupid I'm from the UK we
know this we have a big experiment
that's ongoing
it's one of the is the largest
experiment in social stupidity the world
has ever seen
watch closely people will be writing
papers about this for decades to come
so how do you get a group of people to
act rather than dumber how do you get
them to act smarter and there's this
four conditions these four conditions
that James aruki outlined the four
conditions that characterized why's
crowds diversity of opinion okay we've
already covered that one independence
you are able to think separately you're
in a position where you can draw your
own conclusions and importantly
decentralization you are drawing from
different sources you're not all using
the same things you're not all thinking
the same way you haven't all had the
same educational background read all the
same books and so on there's this idea
and you're not and you're a bug this
idea of being able to think
independently in other words this is
also a question about
is the role of leadership versus
management this idea of being able to
have people just try stuff out
experiment oh that sounds like it's slow
well yeah because the goal here is not
to move fast the goal here is to move in
the right direction and this idea is
that what you're trying to do is try to
explore the space and exploration means
you don't travel necessarily in a
straight line even though you're over
you know you can explore over here you
can explore over there let's try that
yeah let's try that and then if that
works out that's brilliant and if it
doesn't well that's cool we know but
there's another thing aggregation
aggregation means we need to bring it
all together having people going off in
different directions is really that's
not going to help you ultimately you
need to bring them back together how do
you bring people back together
that's your software architecture that's
your that's your socializing however you
socialize this is all of the stuff your
architecture is a model of participation
it tries to help people bring bring them
back together again so what else goes
with speed in the obsession that we have
when people talk about speed often
they're saying well we need to go faster
why but we're bigger and people end up
using the word scale at some point we
just scale what we're doing we need to
scale our development now there's an
interesting thing and I know this
because my older son does CrossFit and
there is terminology in CrossFit if you
have a different level of fitness and
you're trying to do a particular workout
if you have a different level of fitness
which is a polite way of saying less
fitness than some of the other people
then what you do is you scale the
practice but the use of the word scale
in CrossFit means you scale down because
when people say we need to scale our
development there is an open question
that we forget to ask next time you hear
that phrase somebody says we need to
scale a development always ask them up
or down because there is this assumption
the word scale means up and it's
CrossFit that reminded me it's like no
they're scaling down as well perhaps you
are moving in the wrong direction it is
entirely possible you are correct the
scale is a question but not the way you
think it is so
oh yeah I got this nice picture it turns
out that if you are trying to actually
transport goods oil stuff like that
those are quite useful if you're trying
to go on a fishing trip I'm gonna go
with these guys here it turns out that
the thing on the left oh yeah I know but
it's gonna be a big fishing yeah that's
not gonna work and so this idea there's
that there's this idea this pervasive
myth that our and Kelly friend of mine
pointed out in beyond projects a talk
where he focused on this idea it's
software development does not have
economies of scale we are so used to the
idea of the economics of scale the idea
that if I if I well its we see this very
much if you buy glasses if you buy wine
by the glass it'll be more expensive per
volume than buying it by the bottle okay
the economies of scale buy bottles if
you're gonna drink that much okay and so
we have this idea of like well maybe we
will get but scaling let's let's add
more people we get economies of scale
now you get economies to scale with
manufacturing but it turns out that
software development is not
manufacturing we have the opposite
diseconomies of scale because what
you're trying to do is collectively
collaborate you're trying to get
people's intelligence working together
it turns out that the more people you
have the harder that gets it's not that
it's impossible it's just that you need
to keep that in mind
doubling the number of people does not
have you know have your problems it
quadruples them so it's a simple thought
experiment we can run through this so
here is the time taken for one person to
complete some software development and
by that I mean everything if we're
talking about dealing with deployment
that's them system testing that's them
gathering the quirements that's them
okay all of the stuff the code
everything that's the time taking for
one person okay so then we say division
of labor the economics of scaling let's
get to people on this now let's get
three what about four four HUP four
times faster brilliant and then now do
you ever remember I remember at school
one of the most amazing things at school
was
when we learned electronics my younger
sons just started learning electronics
when we learn electronics at school we
had idealized wires
I remember the diagrams is like don't
worry about the resistance of the wires
imagine it's zero that's pretty cool
you know you're a teenager and you're
already dealing with superconducting
materials that's pretty cool
disappointingly what we actually used in
the lab was resistive so it turns out
that this is like super conducting wires
this is an idealization just to keep
things simple what happens when you get
people organized in a group well they
need to sometimes they need to wait for
each other which leads to this P is the
portion you can do in parallel basically
where now this is a byproduct of the
process as well as the architecture who
needs to wait on who if we have highly
specialized roles well I'm waiting on
the B a systems test is waiting on
somebody else that person is waiting you
know all we're all waiting on the DBA
and if you overly specialized you
introduce weight states you reduce the
parallelism you have handoffs we
actually know this because this is
called Amdahl's law we normally apply
two processes but again this also helps
me highlight that this is an
idealization okay I'm just this is a
simple thought experiment developers are
not that easily characterized just
quickly read the commit strip comics and
you'll understand but we're not done yet
you can see the space to the right oh
that's much more like it you know how
many bracket levels can we get okay it
turns out that if you're going to cut we
haven't even talked about the proper
coordination question you need to talk
to other people in the worst case that's
gonna be quadratic and this is actually
dictated by your architecture your
architecture and your development
process these are all going to influence
who needs to talk to whom does everybody
need to talk to everybody else are we
always permanently in meetings there's
this idea all communication is good yeah
up to a point because you can easily
debunk that I did if we don't
communicate that's clearly a problem so
then we fall into this very simple idea
of like well some communication is a
good idea
more can
education is better 100 percent
communication is obviously the best with
permanently in meetings and nobody is
writing any code not bad there's no bugs
so clearly it does not follow a straight
line and different and there will be
some kind of communication overhead
typical you know whatever so we have
this so what what's the curve look like
it looks like this what we end up with
is this problem of well the benefit
here's the intrusive intrude a bit if
you have zero people there's no bugs as
well it takes infinite time to develop
as you start adding people I think start
speeding up things start getting better
then you reach not small point and then
you start adding more people and it
starts slowing down most consultancies
seem to operate over here and then we
end up with very poor experience and we
sort of say you know what that project
that we had last year with twenty people
that didn't work out quite so well we
should put thirty on for this one now
that you're heading in the wrong
direction obviously it isn't smooth
that's why we can't tell it very easily
it's an idealization but nonetheless
there is this this case there are far
too many examples in the published
literature and also personal experience
where I've seen people being added we
have the classic idea that adding more
people to a late project makes it later
that's Brookes law but there's this
simple idea that actually how do you
make it late in the first place this is
a magnificent technique for doing that
let's add more people it turns out that
beyond a particular point the number of
people the cost and all the rest of
development had nothing to do with the
functionality now one of my favorite
examples comes from this one a few years
ago as part of the security theater in
the US the TSA had this idea they
commissioned an application commissioned
an application the Gaza airports a new
weapon they'd heads down there with
tablets and they'd randomly direct
travelers so this is a complete waste of
a human being okay he's standing there
with a tablet and it points left alright
and you tap the screen so randomly
shuffles the queue okay
they spent nearly 50,000 US dollars
developing this and another quarter of a
million dollars deploy
and one of my favorite things is a guy
who did this on who recreated this in
Android in less than 10 minutes on a
YouTube video and quite frankly he was
just messing about you know if he'd
really wanted to he could have done it
in five minutes
okay are you looking at that going war
and yeah just for a bit of fun I decided
one day I thought I wonder if you can do
it even eat et there's an Android out
nice so I wonder if you can just do this
in in HTML so yeah okay right okay so
that's a randomized are left arm right
arrow there you go let's do that onload
and click there's a script a little bit
of styling and because we keep referred
to the body I feel I'm going to make it
complete and you know and you end up
with you know something that you can
actually put in a single slide and so so
so I showed this to my kids and they
said and they said so dad that's worth
$50,000 is it us apparently it is yeah
and my children don't yet understand
they said dad why are you giving it away
for free
so no no this is already a dead thing
now the key point here is this is a this
is something I started saying in the the
late 20th century and Sebastian here
meter picked it up a few years ago did
this lovely graphic of it typing is not
the bottleneck and software development
we often have this obsession of trying
to we get it with code generation people
are obsessed with the idea that typing
is the problem and it's not it's not the
problem typing is is not the bit that we
struggle with and code generation
sometimes solves the right problem but
in so many cases it compensates for poor
frameworks and weak abstractions and
problems that we should be able to solve
in different ways so let's go back to
this kind of core question of move fast
and break things is this a good thing or
a bad thing so I was asked this question
and as with many binary options it's a
false choice it's a context specific
thing
when you apply when a play with an
appropriate context it can be considered
a good thing an invitation to experiment
we've talked about experimentation
freely the idea of mufasa lately
let's try things out that's a good thing
yeah because we can't know everything in
advance and software development is a
learning exercise and you need an active
approach to exploration hypothesis
formulation and so on an invitation
expect freely and without restraint to
discover new ways of working and
thinking to break out of an overly
comfortable or stuck place brilliant the
problem is on the other hand when
applied outside the appropriate context
it can undermine people and their work
it can come across as irresponsible
arrogant and lacking in self-awareness
and this is a bad thing moving fast and
breaking things your customer probably
won't appreciate that in the production
environment okay but also there are it
goes way beyond this very simple idea of
things so let's let's go back to the
popularizes of this recent popular
eise's phrase Facebook and let's do a
little bit of time travel here see for
whatever reason I decided I give
Facebook some feedback on something your
feedback will be used to improve
Facebook not that I've noticed
thanks for taking the time the time
timed 31st of December 1969 that's an
impressive piece of time travel there I
didn't think Facebook was that old I
mean I wasn't doing an awful lot around
then but you know at least I existed
Mark Zuckerberg certainly didn't what
happened well we've got a negative
number oh okay this is a 32-bit Oh is
this time T we've got a nutter we've got
to wrap around this is a simple bug hmm
now how simple can you make bugs well
it's got to the point I collect these
bugs people I used to collect these bugs
I used to take photographs of
screenshots and stuff like that people I
I don't need to bother any more people
now send them to me my Twitter stream
people just sort of say hey looks and I
retweet here we go
and what this is the important thing
what we see we say is is that people are
what happens when a software system
breaks what it does is it loses all its
encapsulation it doesn't
so what your experience was this is an
app this is a webpage suddenly when the
whole thing breaks you see how it's
built it fractures along its fault lines
so here we go this is the underlying
address model of something sort of
logistics company in Canada and there we
go it's PSP HP so yeah okay we can see
that and it's actually got to the point
where I retweet so often that somebody
decided to call them a Kevin Henny so
this is the inception moment last year
at tagline said arriving Bologna I saw a
Kevin Henny screen so I'm now an
adjective and something did ask me how
does it so so how does it feel to be
associated with failure keV loom you
know have your name is yeah mixed and
and this has now got to some ridiculous
proportions a year and a half ago I was
at agile in the city conference in
Bristol and the organiser John Clapham
said quick Kevin come downstairs there's
there's a Kevin Henny screen and I want
to take a picture of you in it and then
you can retweet it and I was also agile
in the city just this last November
where we decided to do this and I use
that slide in dev turnit II in Riga in
December and yeah so we're now getting
this kind of inception kind of thing
going now this is all good fun but
sometimes these failures can be a little
more costly scaparelli probe it was due
to land on mars October 2016 actually it
did just slightly faster than they
planned and yeah they little bits and
pieces a little error it was a software
the IMU went went about its business
calculating the land as rotation rate
for some reason and it turns out that
there was a value that incremented but
never got reset oops the IMU calculator
the saturation Maxim period that persist
for one second longer than would
normally be experienced at this stage
when this was sent the crafts navigation
system calculated a negative altitude
and the ones below ground at which point
it's a you know which point all kinds of
hell broke loose so the actual anomaly I
love
I love space travel they use such great
euphemisms it's like we talked about it
as a crash a disaster it's an anomaly
feel free to use that in your
development environment and they worked
out that what happened is that they this
had accumulated and the craft had
calculated that it flipped over but that
nobody would ever check the idea that it
should be over 90 degrees or in fact 169
degrees of remember correctly and it
turns out the cosine of 169 degrees is
negative and you know and therefore the
craft decides okay
lose the backshell drop the parachute do
all the rest of it the only problem is
you nearly 4k above the ground and it's
well you can actually see the crash site
from orbit
they have photographs now what is the
key thing here the key thing here is
slow down now this is we understand this
we it turns out that we know how to
solve this it turns out that testing is
kind of useful this is a very
interesting study done on a bunch of
distributed systems their observations
almost all the catastrophic failures are
result of incorrect handling of non
fatal errors we can actually model these
we can capture these seventy-seven
percent of them could be reproduced
using unit tests that doesn't mean that
you can find them all in advance but it
does mean that you can nail them down
afterwards and say yeah this is unit
testable we can do something about this
which kind of leads me to sort of a
conclusion this is a book I edited a few
years ago we're now me and O'Reilly are
now kicking off we're going to be
working on 97 things every Java
programmer should know in the future and
there was a lovely observation in it
from Neil for testing is the engineering
rigor of software development that's
kind of where we're going and when you
talk to a lot of people what they
complain about is testing that slows me
down but if you've been listening
carefully the one thing you may have
picked up is that testing is all about
slowing us down that is the whole point
the idea if we go back to software
engineering another quote from this
report a software test system can best
be designed if the testing is interlaced
with the designing instead of being used
after the design so this is 1968 wisdom
testing should be all the way through
the development okay should not is not a
thing too
done at the end or forgotten about or
even the most popular option outsource
it to the customer it's a thing that is
part of the development and if people
complain that it slows them down then
that's a really good thing because what
it'll do is it'll it'll let you focus
more on the velocity and not the speed
so whilst this does have some value in
particular contexts this is the real
message and ultimately the driver of the
software development is you and that's
what this is all about thank you very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>