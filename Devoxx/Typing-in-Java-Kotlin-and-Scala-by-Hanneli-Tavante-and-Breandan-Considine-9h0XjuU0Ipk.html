<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Typing in Java, Kotlin and Scala by Hanneli Tavante and Breandan Considine | Coder Coacher - Coaching Coders</title><meta content="Typing in Java, Kotlin and Scala by Hanneli Tavante and Breandan Considine - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Typing in Java, Kotlin and Scala by Hanneli Tavante and Breandan Considine</b></h2><h5 class="post__date">2017-04-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9h0XjuU0Ipk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so how was the keynote sessions were you
there hmm a little a little bias we know
welcome to deaf Fox
my name is Hannah Lee and this is
Brendon and we are going to be talking a
little bit about types in culling Java
and Scala so quick disclaimers before we
actually get into the presentation we
will select a single example and we are
gonna be working on the same same
example over and over again so sorry
about that is gonna be repetitive but we
are going to implement the same idea
following different strategies this is
not a language war we are going to try
to select cool features from Java
culling and Scala and we are going to be
talking about them and comparing them so
the goal here is discussing some
architectural examples and not really
getting into a real project that being
said there might be a little bias I
think I'm I'm a little partial to one of
these languages but well we'll leave
leave it up to you you'll get the full
full scope of all of what we're looking
at so a few days ago or a few weeks ago
we started exploring this idea of
different languages that were interested
in and i'm i've recently been using
Kotlin a lot and we were we were
thinking about how we could apply these
ideas to different domains and just as
an example one example might be Android
and mobile so you have UI frameworks in
lots of different languages for example
if you have a vertical and a horizontal
layout these are very common things to
have inside of a framework that you're
using so we're just using this as a toy
example and we're thinking about well
how can help might be able to do this in
different languages to make it as fluent
as
kind of natural as possible so sort of a
very classic example in Java is to use
inheritance where you have a concrete
superclass a layout class and you're
extending that with two different
subclasses
vertical and horizontal layout and the
superclass might be an abstract class
you might have able instantiate that but
you have this idea that whatever is in
the superclass you're in your inheriting
these concrete methods and you're able
to access them from these subclasses
this is sort of very classic opie
inheritance there are some benefits and
disadvantages to this very often when we
do this we're introducing a very tight
coupling between this superclass that we
we have this idea that it's it's a super
type of these other things we were
implementing so there's this coupling
problem that if we change one of
something in the superclass we're going
to get we're gonna have to change a lot
of things maybe in a subclasses and this
is this is not always the very desirable
another issue is that very often people
will extend the superclass to just gain
access to those those convenience
methods so if if you have something
that's not exactly related but you want
to be able to perform certain methods
and have access to certain properties
inside that superclass then you might
just extend it without thinking about
the consequences later on so this is
this is one kind of one way to just to
solve it so what's it what's another way
that you could model this domain so what
what would you do there is a hint on
this cream we know that inheritance
could work but how can we make this
design better hi good morning
please talk to me I know it's basic
stuff but
you can make an interface thank you we
had coffee earlier today so we could
come up with an interface and actually
create concrete classes vertical and
horizontal that actually implements this
interface and we could get some benefits
by adopting this design we can lose the
COPO between the classes because the
main idea of an interface is actually
asking the object if it has or if
doesn't have a certain skill set in
other words the idea of an interface is
about asking the object if it
understands a certain protocol a certain
contract right does it make sense so we
could come up with a name and refactor
because keeping the idea of layout is
not real a skill set you're really
talking about the orientation protocol
so just a quick refactor here we are
switching from interface layouts you
actually interface orientation and then
we keep the two concrete classes
implementing orientation all right oh
happy it's time to add some methods to
our demo classes so let's think about
rotate you probably have a mobile device
and sometimes you're trying to play a
game and then you switch to a different
layout right to do a certain set of
activities so what happens when you
rotate well if you rotate horizontally
out you you were expected to get
vertically out right and vice versa if
you rotate a vertically out your expect
that you have a horizontal layout how
can we implement this methods and where
should we implement them based on the
set of classes that we have so we have
this where would you implement that
sometimes when you don't know what you
do you just get the classes that are
actually going to be affected by the
method and just implements the method on
that something like that right so you
have horizontal and then if you rotate
you end up with a verdict
and you have a vertical and rotate them
you end up with a horizontal what else
could you do it looks a little bit
repetitive here what else could you do
please put an interface yes great
so that could enforce that those classes
vertical and horizontal needs to satisfy
a conference right you're forcing people
try to implement forte
but domain question for you
does rotate actually it's meant to be a
thing of orientation or if it's a matter
of layout being rotated when you
actually rotate what what you actually
change its the layout so if you think in
terms of you don't do to rotate like
other things other than like orientation
it's right you might yeah so if you
think in terms of layout we could come
up with a better solution to actually
rotate a Leo so we talked about
inheritance we talked about interfaces
what else do you have in mind for
approaching the same problem composition
that's good we didn't cover that thank
you
we could also think about something like
that a layout that has a generic
parameter T right doesn't make sense a
layout for Tico in a layered horizontal
and that's a very different approach so
what could we have here we could come up
with a class of Aliotti and come up with
two concrete classes vertical and
horizontal and then they would be
combined together there is no a high
Erich involved here they're like
communicating to each other what's wrong
or what's missing here
it's also missing that but why because
you need to restrict the domain of
layout having a layout of string
wouldn't make much sense right
maybe I don't know we never know but in
terms of mobile development you want to
restrict the domain to vertical or
horizontal so how do you do that in Java
you like you said you can you can maybe
you can add a parent of these two types
right so for example if you had these
two and you want to parameterize this as
part of a type of layout then what we
could do is say that these both like we
did before they extend this interface
and we're going to use this as a type
parameter and so we're seeing here in
Java very simply that it has to be
either a vertical or horizontal or an
orientation it has to be of type
orientation so this is this is setting
up a bound on our type we have to give
it the type we could just give the type
but then we could pass anything to that
we could say this is a type of string
and it might make sense so we want to
bound this by orientation it has to this
is an upper bound of this type but the
question is how do we implement this
this this generic layout if we have if
we define this in our superclass inside
of this orientation then we're going to
have to say well we're returning
orientation where there's no way to say
either we return a horizontal or we
return a vertical depending on which one
we are right now so there's this idea of
State and typically this is maybe done
inside of a runtime method so you might
be able to do like some if else then
check sort of thing but what we also
want to do is we want we want to say
well can we restrict this something like
this we want to have a layout horizontal
and then pass at this and then when we
rotate this we want to get a vertical
layout so to kind
address one of the inconvenience that
Brendon was talking about is that
imagine that we that we instantiate a
layered horizontal
passing horizontal as a parameter T and
then we call the method rotate right the
type that's gonna be returned is
orientation G we really want that not
really we want a layout vertical that's
much more meaningful for us so what's
gonna happen when we call rotate we need
to cast right we need this explicit
casting so is there any way to avoid
that turns out yes it is so what we
would like to bake this kind of safety
into our type system and in Java this is
this is a little bit difficult to do but
I was I was exploring a way to do this
in Kotlin and in the same way that we
have an orientation and some some things
that that that interface these are going
to be types in Kotlin and it looks very
similar to Java just go back one thing
so it looks very similar to Java you
have these these functions and you're
overriding this rotate and inside of our
layout class we're going to have a type
and don't worry about what out means
right now we'll explain that later we'll
gloss over that right now but this is
going to be of type orientation again
super tight this is basically the same
thing as t extends orientation and this
is going to accept a t as part of the
constructor right so if we have this
then we also have this this nice feature
called extensions in Kotlin and
extensions allow us to add members to a
class or or an object or some some type
outside of the definition of that class
so for example let's say this is in a
library somewhere you could define this
extension in your code the scope would
be inside of a package or inst wherever
you define the scope to be here we're
saying the scope is inside this package
by default and then now we're able to
when we call this lay out what we can
say is so these just notice two things
here I want to point out that they're
the same name and they accept no
parameters right and they're defined on
layout so in Java the the signature
would be the same we would not be able
to put this inside the class but in
Kotlin what we can do is define this on
a generic class of type of a concrete
type so this rotate that returns
vertical will only be available on a
layout of type horizontal and likewise
this other rotate that returns
horizontal will only be available on
types of layout verticals so when we
rotate them it will return the opposite
thing and when we compile this or when
we need to use this annotation called
JVM name when we compile this to make
this Interop with java because we need
to give it a special name but if we're
just using Kotlin we're safe so this is
how we use it we can say we can create a
horizontal layout and we can omit the
type parameters here because Kotlin does
inference for us so we'll just say this
is a horizontal and a vertical and then
once we rotate that we can we'll add the
type parameters below just to make this
very explicit but you don't need those
that V is a layout vertical and we're
assigning horizontal that rotate and
this will compile is the same thing with
horizontal if you rotate a vertical
you'll get a layout of type horizontal
and so this this this allows us to
really to bake this into our type system
which is a nice thing to have so if you
accidentally rotate a horizontal and
assign it to horizontal you won't be
able to do that it'll it'll fail with a
compiler error if you can't rotate or
twice it's the identity right but if you
do the identity and assign it to a
different type then it does not compile
so the things on the bottom do not
compile so I am a big Scalla fan I've
been learning Scala for a while and the
way I would implement such thing in
Scala would probably be something like
that I would come up with a trait called
orientation
and then again keeping the same design
of having vertical and horizontal as
concrete classes that actually implement
this trait and then come up with an
abstract class that receiver receives a
parameter of tea and the tea needs to be
any child of rain tation or orientation
itself which means we are going to have
vertical horizontal or orientation and
then one thing that I probably would
think about doing is creating a concrete
vertical layout class that extends
layout vertical unboxing this idea of
vertical layout and I would do the same
thing for horizontal layout but of
course extending layout horizontal
unfortunately they give didn't work but
it isn't funny one you might be
wondering why do you have so many
classes that's so annoying well it turns
out that it's not too many classes I'm
just trying to express a different idea
so when you have orientation either for
inheritance or interfaces you have work
on horizontal actually in a in a
creating some sort of hierarchy when you
come up with the layout you box this
hierarchy into something else
and by creating layout vertical and
layout horizontal you're actually
extending this idea of a box but with
different responsibilities so that's why
I would go into such approach however if
we get tight to this previous code here
where we have this layout receiving a
type T something interesting is going to
happen it probably makes sense in terms
of domain assigning the type of layout
orientation and actually instantiating
horizontally horizontal layout correct
because horizontal is a subtype of
orientation so it probably would make
sense
assigning layout of orientation would be
totally valid if we wanted to instance
eight a child of it but it turns out
that Scully is gonna give you an error
so the compiler is gonna be unhappy
why does it happen so turns out that
telling this color compiler that T is
going to be a subclass of orientation
orientation itself it's not enough we
need to tell the compiler that layout
horizontal is a subtype of layout
orientation we need to give this extra
information to the compiler otherwise
the compiler will not know what to do
because they're not telling this so we
need to add the plus sign here and
that's what we call covariance it's a
beautiful name lots of people like tell
you about covariance and things like
that
but that's the idea of covariance so so
that we would you say that the the outer
the container sort of the the type it
matches the the hierarchy of the
contained type yeah Soho it follows the
same relationship the same way that
horizontal is a child of her in tation
layout horizontal is going to be a child
of layout orientation we are following
the same idea for both the box and the
inner elements another function that we
could think about implementing would be
a rerender function sometimes lots of
games needed to rerender your screen or
things like that and you actually want
to keep the same layout but I just want
to render parts of your screen so if we
try to implement this method called
rerender passing Aliotti what's gonna
happen we should be able to do that any
guesses yeah you've got someone someone
who we got an interesting error here
like covariant type occurs and
contravariant position it's interesting
because look look at the number four
cells like 2170 with like the same
question like sack overflow has a bunch
of like market
duplicate its I don't think it's a very
intuitive error when you're like trying
to learn the language and you get this
random error and you think like why
contravariant I don't get it
so imagine for a brief moment I hope
that this color people don't throw rocks
on me haha but imagine that you could
use such thing like imagine that it
could do something like that
which you can't but imagine it you could
the problem here is that you could
easily come up with a lei orientation
and instead say that with horizontal
layout we just saw that's possible
because of covariance right so we are
applying the behavior of the inner
elements to the box elements but for the
same reason for due to polymorphism
reasons we could totally pass a new
vertical in here it's we would be
allowed to do so and that doesn't make
any sense for rerender so that's why we
need this inner this inner parameters to
be contravariant so this thing would be
totally wrong and our code will be
broken so that's why you need the
arguments to be contravariant so one
interesting thing that we noticed by
writing code in Scala and Kotlin is that
those languages kind of bring force us
to think about concepts that we usually
didn't think in Java contravariance
covariance and generics itself so that
was a very interesting approach yeah and
in I think I'm a little partial to to
this this language but I I think that if
if we if we can have if we can have this
this sort of baked into our language as
well so we want to have to be thinking
about what variants our types are then
what we'd like to do is have this
explicit in Java you have to remember
this mamani
ECS producer extends consumer peace
because something like that I forget
what it is but it's not obvious to me
like why this is all you need to do this
so in Kotlin we have these words in and
out so let's go back to our example and
it seems to me like this is a little bit
more intuitive than this plus and minus
in Scala but it's the same thing
basically right so we have our
orientation and this is the the
interface that we're implementing
just like before and we have these these
two things that that provide
orientations horizontal or vertical and
here we notice we're using this object
instead of a class so it turns out that
if we're creating classes all over the
place this isn't very efficient we'll
just use object object is the Kotlin
version of a singleton so you can say
object and there's only one object so
you can just reference it without
without any is this thing pretty much
the same thing for us color yeah so here
we'll go over out so here we have an add
an out parameter and what this means is
this will only occur in the out position
so we can only return T's we can never
accept T's as a parameter so what does
that look like when we go on and call it
well if we have a builder of out T and
this T is generic layouts we have a
builder of generic layouts we can return
T out so this is only going to occur in
the return position so this function
build will return with the same type as
as what whatever its parameter is so
this will this is this is fairly
straightforward
similarly if we want to render this we
can only accept T's and T's can be
layouts here we don't mention that but
we're only going to allow this in the
imposition so if we had a T in a return
position in this function then this
would not compile so let's see how this
this works semantically when we want to
want to call this so for the covariance
example we have a horizontal builder
that is a builder of horizontal layouts
this is a particular type of the generic
builder and the second parameter here we
have a layout builder which is a generic
layout builder it will know how to build
all kinds of layouts like vertical
layouts and any other kinds of layouts
so here this is so this is a function
and it's not really important but if
you're trying to demonstrate something
with types it's useful to use this type
of method because you don't have to
instantiate a whole bunch of stuff so
you have it all in the parameter you say
if someone's passed me this okay I'll
deal with it so we have a builder here
and we can put a horizontal builder into
a generic layout builder because even
though it's a horizontal builder it's a
specific type it will conform to this
contract it will allow us to build
layouts even though it's just a specific
type of layout
it follows it's it's a subtype of that
so layout horizontal is a sub type of
layout orientation and a builder of
layout orientation is a super type of
horizontal builder so they follow the
same relationship however if we try to
assign a generic layout builder to
inside we try to assign it to this this
this thing that's wrapping it inside of
a horizontal layout builder then this
this creates an error because where
we're returning T's and this needs to
return horizontal layouts not generic
layouts it needs to be a specific thing
which generically a builder doesn't know
how to return horizontal layouts so it
follows the same relationship so any
questions about that if we go to the
contravariance example the opposite is
true so this is this is some just the
you think about when we're accepting T's
so if we have a generic layer renderer
this will know how to deal with
horizontal layouts so we can box this
inside of a horizontal layout builder
and if we receive horizontal layouts all
the time then we know how to deal with
since we're a generic layout builder
likewise if we try to do the opposite if
we have horizontal render boxed inside
of a generic renderer excuse me then
we'll be able to to to handle generic
layouts we won't be able to handle
generic layouts because we're a
horizontal render right so this this
will not work
the second example will fail to compile
so one thing that we had to deal with
for all these examples we were building
was type erasure
so the change that the language is built
on the top of JVM are going to lose the
T parameter so our interesting layout
class receiving a generic parameter is
going to become this creepy class layout
so that's that's one of the effects of
typewriter and sometimes it could be a
little bit inconvenient depending on how
you want to represent your classes for
example imagine our layout classes it
could make it could be really meaningful
if we could keep vertical and horizontal
I was really surprised with kata Ling
actually with the extension functions
there yeah it turns out they're pretty
handy I I don't
so it turns out that these are these are
not actually defined inside of the class
they're just defined outside and they'll
remain outside and they're statically
resolved so in the same way anything
that you can do with generics you can do
without generics you just have to add a
lot of casting and instance of checks so
it just makes it a little simpler to
deal with if you're able to do a little
bit better types but you still need to
handle of the type erasure
so for Schoen coating we realized that
there are some strategies to try to work
around the the type erasure itself so
first color for example we have qu a
popular libraries called type tags and
shapeless which can be pretty handy by
keeping the type fields for you and
cutting we saw that extension functions
can be helpful as well
I think you've mentioned that there are
brief height generics and cut wings
right and this will only work for inline
methods so I don't know what the what
the strategy is for for type Tigers in
shapeless they may sort of memorize
these and instantiate create like hold
at instances of these types so they'll
the they might be able to add some
overhead to to their performance so
there might be a performance hit there
and function in Kotlin for example this
is all sort of figured out by the
compiler so you don't have to worry
whether this is going to have a
performance impact and it's very limited
form of generics verified generics so
that's that's one way to access the T if
you have Janet rarefied generics inside
of the method usually you lose the TU Q
you can't access that as a concrete type
but with verified generics you can use
the T inside of your method well we've
seen some other strategies that it can
actually is reflection to get an
information and instantiate the class
again as a fields or some people
recommended us why don't you store
manually store T in a field so you can
see lots of code and github that
actually performs it's a strategy but
again those are workarounds to handle
with the type erasure and from the JVM
so why is this important well besides
thinking about the domain how you were
going to represent your problem with you
know boxes and higher occurs hierarchy
and things like that we at least for me
I started focusing on problems or on
concepts that I wasn't familiar with or
I wasn't used
you pay attention when I was writing
code in Java for example when I was
learning Scala I was really surprised
because for me using the upper bounds
and lower bounds from Scala or
covariance and contravariance the plus
and the minus symbol symbol made me made
like things easier for me to you know
understand and handle with yeah III I
had the same experience
so I coming from the Java background you
you're constantly taught these Opie
patterns and in school you know you read
effective Java and this idea that you
know you have interfaces and and the
hierarchies for classes and things have
to fit into this sort of strict
hierarchy so you had you have this this
hammer and everything starts to look
like a nail where everything has to fit
into this this super type subtype
relationship ER class subclass
relationship and it doesn't always fit
the domain model so we started to see a
lot of different frameworks start to use
these these these ideas from from dsls
where you have some some language that
you're embedding inside of another
language and if you use types
effectively type type systems like
scholars and Java's you can build sort
of ID agnostic generic frameworks that
if you implement if your tools implement
these these type checking semantics then
you'll be able to write encode a lot of
the rules that you have in documentation
about frameworks into your type system
so that when you press the period and
you open the parentheses you'll get a
type that exactly fits that shape that's
supposed to go into this function so
that's some something that I'm
particularly interested in with DSL as
influen interfaces and maybe if I'm
lucky I'll get to show some cool
examples in cotton if she lets me you're
gonna have like 10 minutes so if you
have any questions were yeah another
thing that we could handle better was
understanding the goods and the bad
parts of this languages because we can
pretty much interchange Java with Scala
and Java with culling
so you can really get the the down signs
of each language and put them to work
well together so that's one of the
benefits that we got from here so here
are some of the references for you so
here is a the shapeless that I mentioned
one of the strategies to work around the
type erasure in in Java we added a few
interesting blog post here this is one
of my favorites
generalized types without a PhD I like
the way the author exposes some of the
concepts like covariance contravariance
and so on he actually has a I think it's
a series of posts without a PhD so like
lambda calculus without a PhD and things
like that so that's I totally recommend
this blog post this is the type type
library do you want to mention your
example think also um so there there's a
some great documentation in Kotlin and
it explains a lot of the covariance and
contravariance stuff specifically with
respect to to generics and wild cards so
Kaitlin doesn't have these wild card
generics do you have in Java and it uses
a slightly different more restricted
form of generics but it's still
available you can use implement a lot of
the same things
and we have all our examples in a github
repo so your those will be available to
check out in this presentation
afterwards and I guess we'll open it up
to questions and some examples if we
have some time any questions
Mike I'm just wondering if you have
looked at the reified generics coming in
project Valhalla for Java and how that
will benefit by cogeneration in those
languages yep so I know a lot of people
the question was whether the the ray of
light generics in Java 10 or beyond I
don't know what it's targeted for would
would maybe affect these these other
language that are built on top of the
JVM and as
I understand it that you can you can
implement ray of high generics on the
JVM
yourself if you want maybe they could
leverage that that that from from the
this added functionality so maybe like
in Java eight they added like this
invoked dynamic instruction in the JVM
so maybe there will be specific
instructions that these other languages
will be able to leverage if that has to
do with compiling language like the Java
language down to bytecode then maybe
that's all implemented in some some
compiler tricks to get that to work on
the existing bytecode I don't I'm not
sure in okay so then if that's true then
maybe these languages will be open to
extending implementing these these new
instructions it's it's a question that I
guess you'd have to ask the community
and I assume it would have enormous
benefits people who are writing
libraries like collections I know that
there's a lot of sort of hacks that they
do to get access to you know memorizing
these types and things like that so that
they have access to them later and if
you if you talk to many people who've
built a collections framework there's
some great sessions here about that
they'll tell you that rarefied generics
would be great to have so I certainly
hope that maybe see a little bit of the
project itself they didn't decide about
the final syntax for for it we were at a
focus I guess and we saw an interesting
presentation about that so the syntax is
not defined but I really think it's
gonna help all the language in the top
of JVM because one of the major
complaints of you know the people
developing languages for the JVM they
say sometimes we feel limited but what
we can do and in Scala for example they
fall back to a different compiler
outside of JVM so I guess it's going to
bring more languages to the toughest
leaving because the chief Ham has a
wonderful architecture that could
benefit a bunch of other languages that
just don't jump into because they are
trades to get tight to some of the
limitations so the more they expand a
set of features they can bring more
languages to it any other questions
yet more of a thought than a question
about refight generics there is this
prevalent idea that original is a
mistake that refined is better and
others and I'd like to dispel that in
the sense that erasure is a very much
superior approach to this than refight
generics erasure is what allowed all
these languages on top of the JVM that
we're using today the fact that for
example dotnet has verified generics was
the main reason why Scala dotnet was
abandoned because they couldn't port the
type system of Java Scala to the refight
and/or dotnet types so there also a lot
of other advantages to a rager
one of them being that it keeps you
honest in the sense that's once the
compiler has validated your code and has
been able to prove properties about your
types then all these types go away and
you're not allowed to do reflection or
things like that which will actually
second-guess the compiler and will lead
to a more fragile code so it's a very
very large general discussion entirely
too much about erasure is here for a
reason and it's actually a very very
good way
graphite is kind of planned there
they're thinking about it but it will
always be on top of everything is never
gonna replace erasure and I hope it
doesn't because that's why we have such
a beautiful ecosystem yeah I know I know
a lot of the our language architects
would would it's kind of a holy war but
I know that the languages the stewards
of Java are very reluctant to add this
feature for many years
whether that's changed or not I'm not
sure but no type system is perfect even
Java right now
has a type system that's I mean it's
turning the politte you can run
arbitrary programs on the type system
itself and it's difficult to prove a lot
of the semantics about it if if it you
know it may or may not halt or it may
produce incorrect output so so that's
kind of as an aside but I think it would
be interesting to
explore how that would apply to to Java
maybe in the future and like we said we
didn't criticize high pressure because
accessing the project Mahalo page it's
written it's not meant to you know
interfere on that and we totally
understand the point but sometimes
depending on what you're doing
sometimes you why don't you get rid of
that or just work around it for a reason
and the question is can we come up with
more efficient workarounds that we have
to write less code for that particular
case that we want to keep the type that
could be a question and that's
completely valid to ask not about
removing the feature of the language but
can we make it better when you have a
side case I guess that's the better
question to address was there another
question from that side or do we yep
obviously our experience with Kotlin I
was wondering if you had started in Java
mhm yes when did you move to using
Carlin hmm
so interestingly enough I didn't use
Kotlin it was for many years my I worked
at a two companies that both used Kotlin
and I it wasn't until I left the
JetBrains I worked for JetBrains for two
years and after that I started exploring
this this language and it's pretty cool
so it's it's easy for a Java developer
to to kind of get into the syntax and
you don't have to migrate everything so
you can just migrate you know parts of
your your your library your code and
it'll work interrupts with Java very
smoothly so I find it sort of very
natural extension to Java you get a lot
of benefits of more succinct functional
programming if you're writing libraries
and dsls like this you can do you fully
typesafe DSL so you have a lot of these
things that are in text files but what
if you were able to embed this in your
language it looks pretty much like
another language there's not a whole lot
of braces in here you don't have to even
weaving with Java 8 you get a bunch of
extra braces so it's not there's a
little bit of extra ceremony if you're
doing these sort of things and it's
really designed around Java developers
so whereas Scala might be have a little
steeper learning curve III did enjoy
writing Scala I've been doing a little
bit and it does implement some pretty
advanced concepts in type theory that
that are useful to have but maybe not as
practical or as easy to understand
someone is reading it so when you made
the move to Kotlin what did you find is
your biggest barrier I'd say so in in in
Java yeah it's a good question the so
probably this this idea that you have to
kind of manage these null these nulls in
in Java when you're working with Java
and where to intercept or what we're did
to make sure this is not null so in
Kotlin we have this this idea called
null sate null safety
we're mccann it can't be null unless
there's a null question mark afterwards
so we have all these annotations the
question is like where do we enforce
this if you're working with it's a lot
Java library that produces nulls that
was a little bit tricky for me but it's
it's easy to you know to get used to
that and it provides a lot of benefits
as well and I guess also this this idea
I'm not really a functional programmer
so getting into the swing of things with
streams and and map filter reduce as
well as this DSL idea where you have
these lambda functions with implicit
receivers which is just kind of a little
complex but it's it's easy to get your
head around once once you've done it a
few times</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>