<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>6 years of Gradle at LinkedIn by Szczepan Faber | Coder Coacher - Coaching Coders</title><meta content="6 years of Gradle at LinkedIn by Szczepan Faber - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>6 years of Gradle at LinkedIn by Szczepan Faber</b></h2><h5 class="post__date">2017-04-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XnilWruJ6WU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright guys hungry for knowledge I hope
largest coming six years of graded
linkedin in 2011 I got a call from my
boss Hans doctor he's the CEO of Gradle
and he's the founder of Gradle and he
tells me hey step on you wrote something
about linking on your blog can you
change that please and I was good skirt
linkedin was the one of the critical
clients for Gradle at the time and I was
dead like the consultant for LinkedIn
and I look at my blog and there it is on
my about page it says linkedin is quite
useless not a great idea like be nice on
your blog because you might in some time
in the future we can sell things for the
you know themes that develop those
software product or even be a part of
that team so that's actually what works
for me it's funny that the director that
called my boss at the time he's kind of
now my boss so interesting and thank you
very much for coming I will talk about
various ambitions that LinkedIn had with
Gradle and we've build automation and
how we have fulfilled those ambitions
back in 2011 linkedin was really
critical client because of those
ambitions because of the use cases that
were driving like various important
features in Gradle and how we can solve
them I'm Stefan Faber i come from poland
my name is awesome for living in u.s.
i've never had to spell it ever yet by
the way how many of you is mojito okay
how many of you don't use mojito because
you use something else cool oh okay cool
cool you should you should go to my
other talking two hours about mochiko v2
maybe i can change your mind my team at
linkedin deals with development tools
examples to that we provide to our
engineers is linking specific
intelligence so that IntelliJ
understands the developer workflow a
linkedin and mix engineer something more
productive also we do reviewed code
review to continuous integrations many
more and Gradle as well my team is
around 30 like total tool team at
LinkedIn tools for engineers
like a big thing at LinkedIn around 300
and total engineering to 13 thousand as
my team is hiring so you can work in my
team is pretty awesome you can work with
me and I work with myself all the
diamonds pretty good experience in
pretty cool and we started with Gradle
at linking around 2011 and one of the
use cases that were driving the adoption
of Gradle and trying out Gradle was how
we were doing software at linking at the
time so the codebase was pretty much
monolithic so all software components
everything in singled by giant repo and
it was the development was slow it
wasn't scaling were everywhere we had
problems with Lisa's releases were not
frequent enough they were stressful
rolling back things was hard testing
things was hard how many of you is a
mono repo now this is mallory park
adventure no no money okay some of you
okay cool and what happens is we did
this project called inversion which
attempted to address that situation and
introduce some quality and consistency
in the development so that we can have
past releases fast iteration and
essentially be productive and Gradle was
brought in to Lincoln around that time
we're looking for some ways to address
certain use cases that we had we use and
to build that money repo like anybody
uses aunt should move on don't use I
give a hug later on the community around
and we chose Gradle because they're like
it was flexible it had a nice Gradle
plug-in API also we liked the parallel
building that was coming also the
incremental incremental pneus and built
avoidance avoiding doing unnecessary
things during the build was critical for
us because we wanted to have fast
experience for engineers and incremental
builds and Gradle is really like
cross-cutting it's really part of the
platform everybody can take advantage of
that however the most important feature
that we were looking at was various
api's and promised that greater will be
really good with dependency management
that was important for us because we had
this mono repo and we were thinking that
we need to have separate code bases
individual versioning of software
components and that brings us to the
world of dependency management
versioning conflicts and all that joyful
things and we so Gradle as something
that can help us and at the time greater
was even pre one point all which was
troublesome it was hard to sell Gradle
outside of linking inside link tonight
this is pre 1.0 and there's something
magical about one point over like if you
have a software project I go for one
point of early unit tropical you're
going to get more adoption you don't
have to wait until your tool is perfect
this is what we have done within the
Gradle team I was a part of the Gradle
core team at the time when I was working
when i started with there were like four
of us so great it was really tiny like
two engineers including myself and we
had those self-imposed constraints that
you know Gradle has to shape with the
Gradle demon super stable working on
windows and everything and turn on by
default and guess what like the demon
was turned on by default in Gradle just
last year so it took like many many
years and those constraints that we had
and kind of we were thinking that one
you release one point all once in your
lifetime you've got to be perfect I
don't think was good and my guidance is
like prefer momentum over perfection and
one of my favorite outdoors Peter
Bragman I got a couple of quotes from
him I read like the way he talks about
perfectionism really resonates with me
and I value way more like small
incremental imperfect stats and can I
that give you the glimpse of perfection
sometimes I kept the perfection in your
vision but that don't slow down so that
was one point though and finally we had
one point on let's get back to Mona
versus multi repo so I took that in the
early times before the project in
version we had mono replayed linkedin so
what do you think what is the current
strategy or architecture linking when it
comes to repositories multi it's
actually none of them like we don't have
mono nor a bow tie maybe we have both
can it depends how you see it the way we
do it is like we
made it so that the mono versus multi is
an implementation detail I want to own
and zoom into that a little bit one of
the issues with the mono reporter we had
and I'll tell also some of the good
things about mon repos like bear with me
is that like all the software components
and that like giant blob of code are
like builds at the same time which means
that if I have to revert one single
change in one of the component I had
like over everything I sort of build
inversion that whole thing together and
that was not really working for us it
was hard to like test things in
isolation deploy in isolation so we saw
that let's try to do something different
go to separate code bases and do some
individual versioning what we've done is
we introduced a concept of a
multi-product at linking and multi
priority linkedin it's a bad name by the
way I don't like this name it's like a
code base consider it a code base and
it's it's really it makes the mono
versus multi sort of an implementation
detail because some of the multi
products are very simple and they are
they are built on top of a single git
repo however some other motive products
have code base that resides in multiple
repositories and sometimes even like
different repositories different SCM
systems like most of the coding geet but
some of the coding subversion or most of
the code in LinkedIn proprietary git
repo and some of the code open source at
github so like this is all possible
because we have that layer of
abstraction on top of the durable type
I'm oh no and repositories and we
believe in separate code bases but not
necessarily separate repository that's
an implementation detail we even have
multi products that are that basically
the code bases doesn't I product is part
of some like big repo part of some food
some big money repo so that's also
possible like in our case but then if we
have separate code bases and we start to
build the code separately we have the
problem with versioning and with
conflicts and I'm getting to how great
it will help help us and in this like
very simple dependency graph we have
three software components with some the
fees and when those software components
are part of one codebase like there's
just no problem they just use some
classes or something some from from some
components so that easy now it's getting
interesting when we do individual
versioning when when the B a B and C are
part of separate code bases in their
bills and version separately what's
happening is that I can have multiple
versions of B 1 and 2 and that's okay I
can have you many many versions which is
not good but generally like things like
that happen and what's next is like what
if we spice up this dependency graphic
we have component V that suddenly picks
up and see and it's getting this version
conflicts or hide like that transitively
we are picking up different versions of
be and that you know can break the world
so that's that problem that we are
facing so let me get into the details
and then Gradle and Gradle I promise you
so some process of this individual
versioning of software components and
kind of going to separate code bases is
that we can have incremental gradual
rollout this means that if I have a
change I can slowly roll it out and have
you know some mythic risk mitigation
strategy or I might even not have
somebody pick up the newer version
because he does not need it also with
it's also important for certain kinds of
changes that we do I'm a big fan of like
compatibility like like just the world
of software would be so much nicer if
like things were compatible it's so much
easier I don't like this kind of radical
approach that frequent deprecation kind
of frequent like removal of the per
cadet college like I understand that
from time to time you got it remove some
api's that are blocking your impediments
to your development but like in general
like being compatible nice so better
like it helps everybody and sometimes
you do those incompatible changes
purposefully and you know that you got
it like break the API you should do the
major version release at the time so we
do that but if we have like separate
code bases and separate versioning I can
I don't have to roll out that income
audible change to everybody at the same
time I can do it gradually or even I can
say hey there are some like legacy
applications out there low importance to
the organization like they will not pick
up this newer version ever they're going
to stay on all the version that's okay
if I have a single code base I kind of
have to consider all their usages right
if I'm making I'm changing the behavior
I have to update all the clients and if
I have million clients and giant repost
kind of making it harder another pro I
see is the fact that I can have some
independent dependencies and I'm going
to give you a specific example if I have
a like a big repository and let's say I
use J units for testing i probably have
one version of j.e for all my tests and
if I need to bump the version of that
janeet I have to update all the tests
and if my mana repo is giant I have to
update 1 million tests if I have
separate code bases and you know one
multi-product can use Jamie for another
Genie 5 another test Angie and even I
might have some legacy code that uses to
generate three but it's fine like things
work I don't have this I don't have to
do this heroic effort in like upgrading
everybody if I want to bomb to the
penance so like separating code bases
and like independent dependencies it's
useful at times so i got those are the
things separate independent version it
also comes with some comes like and
those are like baked baked problems like
version conflicts when you have complex
dependency graph and you have some
transitive issue that keeps you in
production at runtime that's what for
some reason not called during testing
and you investigate and it's like 10
level deep into the dependency graph
that's kind of hard you have multiple
versions in use sometimes stale versions
in use because like you know this
version works for me I don't need to
update ever and then at some point all
there is the boxes that we need to have
but now we have to we have three years
of versions that we need to update and
like nothing works and we are like in
alert mode like critical problem so like
those are the problems that are coming
when we start versioning individually
and I I like I much rather the separate
code bases I think it
more flexibility and also I think that
you can't get away from versioning and
librarian cultic stopped because even if
you have mono repo locally in your
organization you're going to be
consuming start from the outside world
and this is not one hora por I this is
like you're going to have to face the
versioning issues however like many
companies are very successful with Ma
nori bori book tons of great tools
around that to make it useful and
successful and productive and it's also
possible right linking chose a different
path we wanted to separate code bases
individual new version inc some other
companies like Google Facebook succeed
with mono repo good for them um how does
great will fit into that picture of like
the world of the penalty we have
excellent API is in Gradle to manage the
dependency resolution and like more aps
will be coming I hope so let's let's
look at some of them the way we do
dependency versioning at LinkedIn is we
all the software components that are
developed tested and published from a
single like code base single will vary
by product they have the same version
they also share the same group ID
coordinate this makes it easy for us to
identify that this software components
come from this larger component and we
can make certain decisions about the
version conflict resolution and let me
show you an example so this is some
dependency graphs that we see here and
so far so good pretty interesting what
happens if our components see brings be
library which is different than being
cool and different than bapi totally
different jars but version two point of
these libraries and instant this
situation in like you know for Gradle
maven or IV dependency management it's
not a problem it's not considered get
conflict potentially it isn't
accomplished potentially things work but
you can see something tricky going on
here like be library be ample and dapi
they all come from the same code base
from from this multi-product be and they
are only guaranteed to work correctly
together if there
on the single version because they were
developed tested and published together
within the single version however in
this case on the classpath might have
different versions of sub components of
this larger component be on the same
softness it's kind of tricky and maybe
in that case is okay but we're fb
library actually depends on vapi 2.0 and
now this is flagged as a version
conflict for greater than a van and it
will be resolved to one of the versions
but we have this issue that if we
resolve to two point oh so the API is a
single component 2 point 0 at the graph
of maybe be imposed no longer works
because it's not compatible with 2.0 if
we resolve to 1.5 the library probably
does not work because he started he
starts to consume the API at 1.5 so it's
it's getting tricky now at Lincoln we
actually saw that use case because we
have to consider what I product and
because we have Gradle that has nice
dependency resolution api's so as
linking what we do is every code base
every multi-product has this JSON file
that contains your dependencies your
first level dependencies it's it's sort
of platform agnostic which means that we
have product spec for all technology
stocks like you know it's a Java project
or you know iOS or c plus stuff whatever
JavaScript we have a consistent and
standard way of declaring dependencies
and what we can do here and we use
Gradle for that is we can enable
consistent versioning so in this
particular case I'm declaring dependency
on like for libraries from the Pegasus
multi-product or code base and at the
version 8 17 this means that during the
benefit resolution for my code base
whatever whichever subcomponent i'm
building within the code base like all
the components of Pegasus multi-product
will always have that version if i'm
picking up some other libraries from
Pegasus 20-degree Gradle will guarantee
as version 8.1 point 7 actually not
Gradle it's linked in Gradle dragons
using Gradle api's will guarantee this
inconsistency for us we also have single
source of truth for dependencies so we
look at product spring and this is the
version that is used and we also need to
take care for downgrade violation and I
want to tell you what that downgrade
violation is because of LinkedIn in the
product spec the version that is the
cloud there is a source of truth what's
happening is that this new type of like
a the Clark the version 1.5 of B
component which means that during the
conflict resolution we will actually
resolve that version 2 1.5 not to two
point O by default Gradle will just pick
the latest right as linking we will be
picking up the room that it be Clark in
the product back and this this is
problematic for this case right because
what's happening is that be library
would be at version 1.5 and we don't
know if components see actually works
correctly when be libraries downgraded
to version 1.5 so this down grid is a
problem in the way how we do
dependencies of linking so what we do we
fail to build earlier saying hey you
know you're downgrading effectively one
of your transitive dependencies fix it
so what's the fix for that with the
proper fix for that we can what we do is
basically the product owners of a has to
bump the version of B to two point oh
maybe higher and they resolve that
complete this way so that was the vert
the dependence of validation rules and
certain things we do with conflict
resolution we also leverage dependency
rules from Gradle to tweak the
dependency resolution and what it means
is that there are some known versions of
various libraries that are not working
correctly for us and we can basically
automatically during the pendency met
dependency resolution replace them with
the correct versions i want to show you
some example from our code how we done
that and this is not showing the api of
Gradle at all it's just showing you that
sort of a data structure that we use to
declare some of those rules so you can
see that for all the neti versions
starting with three point and we're
actually replacing this 396 final and
it's
nice convenient way for us to like roll
out certain tweaks and improvements of
the penetrator solution to all the teams
at LinkedIn because all the things that
Lincoln are using the grade of bargains
so we can kind of influence the
dependency resolution like across the
board it's kind of nice another
interesting aspect of working with
separate code bases and in the world
with dependencies is that it's kind of
hard to make changes in code changes
that span multiple code bases right with
the big single code base it's easier
it's night because you can like you have
a some method that is used in 1,000,000
places you just rename it and going to
be renamed you can commit that are
chemically it's kind of nice provided
that your project loads to ide correctly
than that you know that could work for
you however and then you go to separate
code bases now and you want to rename a
method now like that's problematic
because as soon as you rename you
publish a new version of your library
with renamed methods and like you know
your consumers cannot really easily
consume that version because they will
have to update their code or you have
some runtime incompatibilities it's
getting problematic so how we have
addressed at LinkedIn we actually
sponsored the development of a greater
composite feature in Gradle late last
year and we have rolled it out of
linking in the form of like Gradle
player Gradle plus some feature that we
added to to the link to our LinkedIn
IntelliJ plugin so for example at
linking what you can do is when you are
checking out a multi-product from source
control we have actually like it like
separate like check out window in our
plug-in we can specify which code bases
you want to work with you can actually
select multiple code bases multiple
multi-product and it's going to check it
out into a single IntelliJ window so you
can do like crossref code base we
factoring some stuff so that's pretty
nice that's that's that's one of the
things that we are trying to do to make
it easy to work with those separate code
bases in 2017 like we observe
of that majority of the majority of the
project and technologists acts as
linking are built with Gradle which is
kind of nice this is not something we've
been observing like at the early days in
2011 it was like experimenting and
prototyping and then it gives us very
interesting like it helps engineering to
scale if we have consistent layer of
tools that are built on top of like
similar technology dreidel is
responsible for various things for
typical JVM stocks it's doing all the
work or the heavy lifting for some of
them for some of the technologies packs
like JavaScript or Python we actually
delegate from Gradle to some Native
tools so greater is like an uber build
tool or an Orchestrator play and Gradle
is coming I was just talking with will
surgeon from from light band I just
before this presentation so it's coming
so play framework the web framework that
is used at LinkedIn and right now play
framework needs else BTW to perform
built in s bit isn't fantastic tool I
don't know if you have pleasure of
working with us BTW and we are trying to
make our play applications be developed
and tested and built with Gradle and
it's it's a new thing for the play
community essential you could play
community for years with google's SBT
but now as play framework is
transitioning from like usually it was a
tool associated with skyler community
but now it's transitioning to be an open
for everybody for java developers and
you can write java with black promotes
easily we won't also use the Gradle tool
for that this gives us a consistent
tooling for everything now what's
happening is that we have to maintain
some of our infrastructure and
dependency resolution in the form of lb
keep lagging if we converge in Gradle
that helps it's like it come come on
build platform we can reuse how we do
dependency resolution across all the
technology starting tonight it has
scaled my team for sure off is killing
in your engineer and linking us well at
scale
oh this is one interesting thing so we
don't like mon repos alone olives yeah
we don't like it about in 2015 like all
the great linkedin Gradle plugins we're
in their own little minori prodigy so
when a team had some niche requirements
or use case for doing anything with
project automation they would create
Gradle plug-in and that big giant
collection of all the plugins and I was
very problematic for us because like if
some engineer wanted to change his
little plugin that is used by a handful
of teams he had to really you know make
that change in our entire code base we
have to publish a new version so like
roll it like all our great new plugins
to like everybody like we didn't want to
do that and so basically we busted that
monolith in two separate code bases
separate grade of plugins and we created
Gradle platform api is linking what it
means is that if you had a need to do
something custom with your automation or
bringing a new technology stack and you
leverage Gradle to link and linking to
link what's happening is that you can
use that API we have documentation for
it we have strategies for distributing
your plugins at LinkedIn or flares it's
a nice it it really allows to scale it
offers the flexibility right we don't
have we don't have to maintain those
plugins people team can just create them
and maintaining themselves it's kind of
nice it was the key feature key aspect
of you know that of my happiness in two
thousand see ya we don't have to
maintain all that stuff and I want to
talk also about some other dependents
engineering tools and I'm with it you
how am i doing at the time oh nice
dependence engineering tools those are
not really connected to Gradle that much
some of them are loosely connected the
Gradle but they're very relevant to the
world of dependencies of LinkedIn kind
of how we manage like versioning and
separate code bases so when i connect go
one by one and talk about them said
linking we have a concept of downstream
dependency testing so if you are making
a change in your multi-product your code
base and you're committing the change we
automatically trigger bills of all the
code bases that depend on your code base
all that multi-product that depend on
your multi-product and you're going to
get a signal if you broke compatibility
and one of your clients sales you're
going to get a signal from our
continuous integration infrastructure
it's also super easy to trigger that
kind of validation from your local you
just issue and command line command line
operation and what we're doing is like
you can we look at what you have changed
in your workspace we send that beef to
the lower like CI cloud then we build
your code with that change and then we
build like other code as linking that
depends on your code and will tell you
if you're broken from somebody someone
of your client this is nice we have rich
metadata that is attached two versions
so when you're publishing a new version
of your component you can at some point
in the future like deprecated that
version or even like end-of-life it and
like if you know that some version of
your code Hesburgh we can actually like
I will take down and kind of make that
information persistent in the
organization and like what's happening
is like all the other code that depends
on that version will stop building and
tell you hey you're depending on the bad
version you got it like update to a
newer one or it'll get warnings like you
know that you're depending on the
version that will be deprecated in you
know two months from now can you upgrade
and you know this is the migration guide
this is what you need to do we also
supports wild card versions like dynamic
versions and you probably know dynamic
versions dynamic dependency resolution
from like you know in greatly have this
plus sign to get the light essence in
other those systems you have something
similar as linking we have a concept of
a wild card version so in the product
spec file that I showed you earlier you
could declare versions with the wild
card and that wild card actually
understands that version metadata so
it's like a version that end of light or
deprecated it's not going to be picking
it up so it's kind of like one layer
like it's smarter than like standard
dynamic versions that you have it stay
with it with Gradle we also had system
called push my upgrade the system is
useful when you need to
roll out your change your version to
your kolkata customer so there's an
automated service that will basically
check out each of your clients change
the version run the build and if they
build a successful automatically apply
automatically push that change and you
can like easily roll out your version
and like this is one of the things like
we needed to implement in order to like
make this work in separate code bases
with separate versioning kind of useful
like before when we had everything in
like a single code base like you don't
have to push your upgrade at all because
you make the change and you have to
change all that code that's that is
using that code so you get it for free
if you have separate code bases multi
reboard not you gotta have you know
tools or like processes around like you
know consuming diversions pushing your
upgrades and stuff like that we also we
also have various continuous delivery
services and tools if you create the new
moons are protected Lincoln will get
automatically like all the CI builds and
deployment and everything and what is
interesting about how we do continue
delivery is that basically every change
you make in your software results in a
new version and that's not the typical
way things are done in the software
industry I would say typically let's say
a team uses gate and they basically
start one change in another you know one
developer does this some other developer
introduces another feature and at some
point they decide to release you know
some maybe once a month maybe once a
week maybe there's some automation that
releases every day I don't know but
generally you every day you you create a
new version of your software or a
library or something after a couple of
changes with others to your branch this
is not how we do it at linking and
linking if there is a any change to your
coat indeed it and that change passes
the build you're going to get a new
version that you know people can consume
and this is also this is also how we do
it in mojito and I don't know if you are
the four because there's a community is
divided whether it's a good idea or bad
idea lab oketo too many versions like
don't do and you know release months a
year nicely polished version was like
beautiful things and but this allows us
to scale mohit open source project
because we have sophisticated automation
around like you know validation that you
know we can break things and when the
bill passes we merge a pull request in
makita and the bill passes a new version
gets released we get automated release
no documentation and everything in new
version lands in maven central and
people are scared I updated I will get
to just yesterday and now there's a new
version now what you know so I want a
notch community and the linking we do
that two more like continuous delivery
mode like you should you should not have
unreleased changes on your master this
is like liability and this is waste
stuff should get out stuff should be
high quality and reviewed and you know
once it's the lands on your on your
development branch it should get
released and pushed and we at Lincoln
have tools for that one of the last
things I want to mention that seems we
started working with Gradle we partnered
with Gradle incorporated a sponsoring
certain features in open source and it's
kind of nice because the linking
sponsors features that then you can use
if you use greater and like other
companies do that too and partner with
greater link was successful for us the
last sure that we did last year was
computed build the previous feature that
we worked with Gradle ain't was playin
Gradle so being able to display
applications with Gradle and play on
Gradle products thing going on my my
team is like full speed on this project
and we should have production use of
playing Gradle within like few weeks we
should for quarter one that should be
good and that's it guys I think I have
nice time to take any questions you
might have no question all right
a great question the question was
whether every change goes to production
I should have done that thank you no not
every change goes to production but
every change publishes new version and
now it sort of depends on the kind of
your application let's say you have you
work in the Java library so when you're
in production when you're a Java library
well you're in production if you have
any clients that builds his code with
your new version of your thing right so
you make your change to your Java
library the build passes like this code
review there are other parts of the work
so that I don't mention but the bill
passes and the new version is available
for everybody as soon as somebody picks
up that new version if you have that
production use and it kind of depends
because you might have clients that are
on the wild card version which means
that as soon as you publish and there
are like some other builds cranking and
that link thing we have tens of
thousands bills every every day like
it's like we have five thousands of
those code bases multi-product so it's
like pretty large scale when it comes to
applications then you have some you you
don't want to like publish new version
like every seconds right so for example
for linkedin site we publish every three
times a day but of course there are like
many many changes during the day because
many engineers are working on it and
also there are changes in many layers
right in front and in the nuclear and
stuff so really so the question so that
the short answer is not every version
immediately is in production but it's
available for production and it really
depends on the context and what kind of
movie product it is when it's really in
production hope this answers your
question
yeah you gotta have automated tests that
will tell you we've gone teeth at your
stuff works like we don't do like manual
testing at all I think not like zero
ever we used to like many many years ago
but not now like we do we have some like
exploratory testing we have you have you
know Connery releases you have like
better version of the app that goes out
to Lincoln employees so we have ways of
like mitigating risk and kind of
figuring things out but we don't have we
don't have manual testing process that
is like a part of the release workflow
or at least okay they're like many many
applications out there at LinkedIn and
I'm you know I'm not an expert in like
entire portfolio of like to submit their
applications are linking provides but
they're like the main ones I was
connected with let's say the linking
site there's no like a manual process
with someone actually body didn't say
yet let's ship it and the other question
we use Gradle and we are very happy with
Gradle but like you know there is there
is a steep learning curve and especially
when you want to extend Gradle and you
like really sophisticated style you
suddenly find yourself that you need to
browse Gradle code base internally to
figure out how things work so I guess it
depends on like no really like you have
the documentation on greater yeah that's
that's everybody knows like dsl API and
this and that in general there's the
documentation or Gradle is very decent
but because that tool is pretty
complicated tries very ambitious and
what it wants to do like there are so
many API there so many like incubating
api's that are not yet that was
documented that you know if you are like
also ambitious user and you want to do
really cool stuff with Gradle you're
going to end up going deeper than the
javadocs right even to the code and
stuff yeah I mean it I mean it's going
to get better especially as greater its
opening to coupling it's now already
possible to create your build of Gradle
file scripts in cocaine which
automatically gives you much better like
syntax highlighting and intellisense and
like support in ID when you're like
working on your script but yeah but it's
coming it's you know it's slowly getting
there now if you're interested in
joining some of the efforts that I
briefly talked about like the mochi to
release tools where we want to like Nagy
the community to be more continuous
delivery to push the Java libraries in
the world to like release more
frequently rather than just stacking
changes and then you know I don't want
the release there's just too many
changes you know it's gonna hurt us and
I don't want to create release notes
because it's just too much work right so
like hit me up on Twitter or something
like we can we can chop another question
yeah that's a great question what about
like service dependencies in like the
bar you things I mentioned about like
dependencies i would say that service
dependencies have to some degree yes but
services have their own ways of like
let's say validating the api and stuff
like that so there's a i'm trying to
find like what's the with the good
answer here i would say that if you have
a multiple rocket linking that is a sir
that is an application that depends on
some service right you are going to
declare a dependency to the API of the
service and now it kind of depends what
kind of technology package we're talking
here we have some like official ways of
like you know or like building
dependencies between services and kind
of depending on the media where and
stuff like that the technology there is
restless also open source where you have
some ways of violating that you are like
compatible with the API that you're
consuming and you have ways of
generating that the client code that
talks to that API but generally you
would have the dependence you would have
those explicit dependencies to your to
the services layer and that dependency
will enable some of the features that we
have a LinkedIn like you know the
dependence of testing mechanism and
certain other things
yes that's exactly how it works yeah
yes it is supported with services you
have even more features because what we
have with Ridley is that when you are
producing a service and an API you can
validate your compatibility without
actually like in your code because we
you have ways of like that detecting
that you made the change in that is
compatible or not compatible so you have
even better ways with Java we don't have
those tools right with Java it can now
you know you gotta know when you're
making breaking change or not although
there are open source tools in Java that
offer that insight it will tell you how
you're making incompatible change or
doom you're making good change but we
don't have that yet I would love to
implement that but like in general yes
like if you have service to service
dependence in that kind of stuff it also
participate in that machinery another
question ok thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>