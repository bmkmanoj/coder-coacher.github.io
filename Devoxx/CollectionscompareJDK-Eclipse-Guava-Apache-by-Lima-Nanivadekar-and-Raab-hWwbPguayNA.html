<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Collections.compare(JDK, Eclipse, Guava, Apache...); by Lima, Nanivadekar and Raab | Coder Coacher - Coaching Coders</title><meta content="Collections.compare(JDK, Eclipse, Guava, Apache...); by Lima, Nanivadekar and Raab - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Collections.compare(JDK, Eclipse, Guava, Apache...); by Lima, Nanivadekar and Raab</b></h2><h5 class="post__date">2017-04-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hWwbPguayNA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello guys thank you very much for
coming for our collections compare talk
I'm gonna you a very good job showing
you how many different collections
compared to each other so first a brief
introduction of us first don't okay I'm
Donald robb
so I'll start off saying you know a
little about Who I am
first and foremost on the husband and
father and I'll talk a little bit about
what I do I'm also a managing director
at BNY Mellon Bank in New Jersey some of
the things that I've done I am the
creator of eclipses collections how many
people have heard of eclipse collections
yeah yes it's also a member of the three
jsr 3:35 expert group which was
responsible for the great work that
wound up in java 8 in terms of lambdas
and the streams API another neat things
like you know default methods it was a
great honor working on that I've been a
presenter at JavaOne a few times I think
like three times
also the clips come I've also done a
talk at the jvm language summit and also
at the the great day media developers
summit this is however my first time at
that box so we're excited to be here
today with all of you so with that yeah
so I'm Leo Lima my full name is actually
too complicated so I'm Leo Lima and I'm
a computer engineer I've been doing the
software development for 12 years
already
only in Java mostly in Java and that's
why I know now I'm from Brazil but now I
live in Austin Texas and I'm responsible
for the technology and our cooperation
every to come and part of that
responsibility is understanding the
technology and we saw that the iMac -
echoing yeah you guys know it's ok ok
so part of that technology overview we
saw jobbies missing something for IOT
development that's our main core focus
on my company and we got together with
some other - especially it's foreigner
college in mahi to develop the jsr 363
units of measurement and that's radio
final jsr and we are presenting this as
well tonight so that's another area of
my interest another is collection so
that's
that's why I'm here and I'm
representative for my company at the JCP
Executive Committee as well hi I'm
Nicola Marnier liqueur
I'm actually a mechanical engineer it
was in 2012 when I joined Goldman Sachs
I wrote my first line of Java code and
it has been a great journey ever since
and working in the collections framework
actually exposed me to different aspects
of the whole Java programming language
and how to write code in general so my
background academic background is I'm a
mechanical engineer with specialization
in robotics and control I'm a I'm a vice
president at Goldman Sachs I'm at I'm
originally from India I came in Salt
Lake City in 2010 and I've been there
ever since and this is my first day box
as well and I'm excited to be here
yeah sure this is about collections
compare and you cannot start with
collections with all talking about the
Java YouTube collections and Java to
collections has been there for around
and for you know almost 20 years now
since JDK 1 or 2 in 98 and it's a very
basic but very critical set of
interfaces and implementations and
algorithms for working with collections
so when we think about collections we
think about a sad out answer
now I'm on you now I'm on so when you're
thinking about collections when you say
collections is in a bunch of objects and
this bunch of objects on the JDK can be
either a map which is an object point
into another object or a collection
which can then be a lace the set key you
attack but these are the main two topics
for four interfaces and then JDK
provides basic implementations for these
interfaces such as every list is a basic
implementation of the list interface
hash that is a basic implementation of
the sat interface so it's been this way
and then we're gonna see how the
framework evolved but and we have the
basic or have concurrent versions we
have different algorithms that for
sorting for shuffling for written for
doing like data manipulation as
add/remove reverse order and blah and
this basically stuff that you do with
collections and if you don't know and
there is a very good tutorial on the
java oracle web page for both the simple
version so it guides you through all the
interfaces and all the operations that
are included and we cannot include all
this in in this talk but the concurrent
versions as well and a quick look at how
the collections framework evolved and
since its inception it started with a
very basic set of operations as I said
before for many years it was just that
and then on Java 5 with generics there's
a lot of work done there to make your
collections framework more robust and
easier to work with with less casting
and doing more readable code so also the
for loop was enhanced so it was easier
to work with our collections and in the
new interfaces for calling for
concurrent operations as well so then I
think it was a very good overhaul of the
collections framework on 2006 with Java
C 6 we got some new operations and you
have a seven last thing but with Java 8
with lambdas and strings we got a bunch
of new stuff on the interfaces so
everyone is kind of going back and we
we're evaluating and learning again from
I am learning
just migrated to Java eight and a lot of
new stuff available so very exciting and
I'm telling you all these good things
about the Java collections and one can
under why we need something else sure
why do we need something that's not Java
YouTube collections and and that
perspective is when you're working with
code you kind of see new patterns
evolving on your code like I'm always
doing like a collection against a
collection so I do a for a and then a
for B inside a for a loop so that is
like a Cartesian product and that's
something that shows on and chosen on
your production code and you kind of
think there might be something else this
is a recurrent operation so this could
be inside the JDK as well another change
would be yeah on GDK you didn't have
like the concept of a bag or a map or
that has multiple values instead of just
one object pointing to another object so
there are some types that you end up
creating yourself or then you look
around and as you can see hey this is
not just me having this problem other
people have this problem so that's why
we're considering for other collections
framework on alphabetical order here no
no trying to sell in one Apache Commons
collection has been around for a while
as well eclipse collections which is
formally GS collection yes migrated
their code to eclipse Google guava has a
kitchen sink
apap I use slash framework for swatch
library for for for utilities and they
have a collections some collection
classes inside of them as well and Java
slang is a functional library to help
the functional stuff like Scala but
without having to learn how the language
from Scala and again the on the on the
presentation you have links for their
user guide or documentation okay so it's
right easy to get started with this
libraries as well a quick view and so
they kind of evolved together with with
the framework so Java when Java 2 was
around there was something for new
object so Java collections Apache
collections was born and then what I
want to point out on this slide is when
Java 8 was a fall was launched and
all these libraries went back and rework
today or implementations to use all
these new API and method references and
all this new stuff on JDK 8 so these
libraries are there for a while and this
they are they're gonna continue there
for a while that's why we chose this for
there might be others these are the
chosen four for our talk so now I'm
gonna hand over to thank you to did a
comparison between and explain a little
bit of how we did what we did so Leo
explained all the collections framework
that we are going to consider today so
Apache a than the Squa there is eclipse
collections there is java slang and the
good old jdk collections so in order to
sort of get all of them on a common
ground we decided to have we decided to
have our a domain and we wanted to have
a domain which we people could easily
relate to or rather it was much more
easier for us to explain so we decided
to have a deck of cards a deck of cards
has as everybody knows 52 cards each
card has a rank and a suit and we end up
using enum sets for that also if you see
the way the the parameters of deck of
cards or the member variables are it's
an immutable sorted set for cards and if
you want to have a cards by suit its
it's immutable sorted said multimap and
I'll quickly go over what exactly you
know each of these mean so the problem
statement was we wanted to create a deck
of cards where all the cards like I
mentioned before are going to be in a
sorted so immutable sorted set yeah
again there are some libraries where
it's the immutable part is not present
at that time we are using the
unmodifiable libraries like java slang
where they are by default immutable so
we are just using that also we wanted to
group by the cards in an immutable
sorted set multi map what a multi map
means is you have a key and a collection
of values instead of just a key and a
value now and eclipse collections guava
as well as up eclipsed collections guava
they actually have a multi map
implementation some of them do some of
them tone and we have accordingly made
the changes the second thing is we
wanted to get the number of cards and
for that we use a data structure called
as a bag or a mighty set it's nothing
but a map with the object and the count
with it and the last but not the least
one of our problems was we wanted to
deal five five hands so what that means
is we wanted to have an immutable list
of five sets of five cards it's sort of
a handful to speak but it was
interesting to solve it yes a
parenthesis here on this is like we
imagined but you can see the operations
is something you do on your domain so on
my domain for doing geographical
positioning of IOT nodes I do Cartesian
projects to connect these points
together I want to group them for
carrier I want to count how many guys
are in a given node as a gateway for how
many nodes we have done so I don't want
to explain my domain here but with this
is simple domain we can replicate all
these operations and all these code
examples to your own domain so I think
it's very useful and also all of this
code is available on github at the end
of the slide deck we have put out the
link and you know in case our
implementation is incorrect or it can be
improved we are open for feedback and
the same talk will be presented next
month at great Indian developer summit
and if you guys end up giving us some
feedback yeah we are happy to
accommodate that's the thing that there
is well what you'll see is there's a lot
more code in the repo than we have in
the slides just because we have a
limited time but there are like
different implementations we made
different decisions like we said what if
we use the mutable lists instead of
immutable sorted sets right and how does
that impact things so we we do we are
going to go through a few performance
benchmarks we are using jmh Java micro
benchmark harness it's the open JDK
product which is there although all the
measures are consistently reported as
operations per second so to make it easy
higher the better we we ran them on my
Intel i7 four core machine and with 51
of iterations and 30 measurement
iterations across two
folks yeah if there are any changes
which we need to do on the jm8 side feel
free to give us feedback and we will try
to accommodate ya that's also on the
github repo and we didn't do memory
reparations because the domain is so
small the operations would not have
memory per impact but you can always
evolve this to your domain and had your
member impact on your code as well yeah
so going to the first problem of
creating a deck of cards
we already went through what exactly the
the problem is we want to create a deck
of cards where all the cards are stored
in an immutable sorted set and all the
all the cards by sutas sword in an
immutable sorted set multi-man so if you
look at the performance you would see
that for the whole deck of cards apache
is a winner JDK is coming close second
and we will see in the implementation
why exactly they behave this way so what
you just saw me do is actually we also
have a deck of presenters up here so I
just shuffled the deck yeah so first
thing we're gonna talk about in terms of
the deck of cards and you know help you
to translate in terms of what this means
in terms of performance later first
thing we're gonna talk about is what
types did we have available to use right
so using JDK and recall that we wanted
to have the the deck of cards as an
immutable sorted set right so we don't
have a mutable interfaces in the JDK but
you see what we did was we used a sorted
set interface from the JDK and for the
grouped cards where it's you know
grouped by by suit we used a map of suit
sorted set of card underneath this we
had to make the decision because we
don't have a mutable interface you know
types we actually decided we have to
simulate immutability we actually wrap
the underlying sorted set as well as the
map ultimately a known modifiable map
and you'll see that you know later in
the code when we moved to Apache Commons
all we see is like Apache Commons does
not have its own sorted set so we had to
actually use the JDK interface here for
the sorted set but Apache Commons does
have a multi map type they call it multi
valued map and there's both the multi
valued set map and a multi valued list
map they do not have a multi valued map
though
or sorted sets and we'll talk a little
bit about you know what the impact of
that later for eclipses collections
there is actually a type and you'll see
like the types that are in blue if
they're blue their interfaces if they're
red their implementation and you'll see
for like eclipse license we actually
have there is an immutable sorted set
interface and there is an immutable sort
of set multi map interface as well we
moved to guava guava actually has an
immutable sorted set type what you see
though is it actually is a concrete
class I'm sorry it's actually I believe
an abstract class but it is a class on
an interface
there is also an immutable set multi map
there is no type for immutable sorted
set multi map however what you can do
though is actually store immutable
sorted sets in the immutable set multi
map but you've got a higher type through
them and finally in Java slang what
you'll see is we have two interfaces for
Java slang there's sorted set and map
and actually looks very similar to the
JDK implementation except for these are
completely different interfaces these
are actually immutable interfaces
provided by java slang okay so next
we're going to show is the the sorted
set you know Cartesian product and what
we have here this is actually a bit of
common code as we were iterating through
this particular use case what we found
was that we were writing the same code
over and over again if you look at the
bottom the code we were writing is this
pattern called Cartesian product now
there is no Cartesian product
implementation that we found useful in
any libraries there is actually believe
one in guava one in in eclipse
collections but we wanted though is to
take something that would actually
return ultimately a stream of cards and
what we do here surfer Cartesian product
we have flat map followed by map and
we're applying a function to actually
you know in the the calling code for
this where we're calling you know inside
stream cards we call card Cartesian
product passing an enum set of rank enum
set of suit pass in a constructor
reference for card and this gives us
back a stream of cards but it's up to me
Cartesian product is flat map and map
together so looking at the performance
you can see that guava blazes through
everyone else and there are reasons
behind that and we are going to go
through the code and Don will end up
explaining why and the lying it actually
ends up
having the best and all the other ones
are consistently the same now I want to
sort of put in a disclaimer out here
like one if you end up running these
damage tests on a different machine the
the performance can change obviously
also the second thing is they are have
they're doing two hundred thousand two
hundred and three thousand or one
hundred twenty seven like these are very
high number of operations per second and
this is a very small enough domain so
they I would consider all of them to be
coming closely but Gua WA is double so
it's blazing true alright okay so we're
gonna look at JDK first and what we
highlight here is just a section of code
in the constructor that actually handles
Cartesian product and when we zoom in
what we see this is the actual code we
have for JDK for creating you know
implement or calling creditor products
so we get the stream of cards that
effectively is doing the the flat map
map we've now got a stream and what we
have to do is collect that into some
type and recall for JDK what we want is
to come back with a sorted set that's
unmodifiable so we use as collectors
collecting in them we do collectors do
collection tree set we get back a tree
set we wrap that in a non-modifiable
sorted set and now we've got inside our
a pointer the reference for cards
we now have effectively an immutable
sorted set we look at patchy commons
it's identical they do not have their
own sorted set this code is no different
we then move to eclipse collections and
if we zoom in on the code for this we'll
see something slightly different so here
we actually call stream cards on card
and we convert it to an array and we're
using a special thing I don't know if
folks have seen this before and you can
correct me if I get this wrong it's it's
under work it's an array constructor
reference right so it's called okay good
now it's interesting in the syntax this
to array actually passes the int so it
knows the size right so we actually get
back an array of 52 cards here and
there's actually a factory class called
sorted sets we can get the immutable
version of it and basically construct
the sorted set the immutable sorted set
directly here for guava what we do
zooming in we actually take the stream
cards and they have a collector on
they're immutable sorted set class you
can call the middle sort of set two
immutable sorted set give it a
comparator
natural order and now we've gotten back
our immutable sorted set for guava for
Java slang similarly they have a
collector on their tree set class so and
we zoom in you see like we do the stream
cards who you call collect on stream and
we pass in tree set that collector this
gives us back the sorted set type which
is immutable in Java slang so going to
the second part of the problem where we
want to group the cards by the suit in
an immutable sorted set multi map now
this is sort of a very important
distinction we want to group them into a
multi map which is not only immutable
but the values have to be sorted and
that ends up if we look at the
performance of it that actually ends up
showing that Apache is is the clear
winner out there and we will like again
Eclipse collections guava java slang and
jdk they they are around about there
however if we look at the implementation
we will actually realize there is a
reason why apache is actually blazing
through rest of them whereas all the
others are sort of hovering out there
and putting it through okay so now
looking in the context so this is the
group by part of the code for JDK and if
we zoom in what we want once again is we
want an immutable sorted set multi map
so we simulate that in the JDK by using
unmodifiable map and then within the map
itself the sorted sets are wrapped in
unmodifiable sorted set so we do you
know card stream collect we do
collectors grouping by we then map each
element we're gonna use identity for
each element and then we want the
collection that comes back to be a tree
set wrapped you know when the modifiable
sorted set and then that whole thing
wrapped in a non-modifiable map so at
this point the whole thing is
effectively immutable for apache what we
did was we're actually using their multi
map the set so is that valued map when
this is interesting what nikhil was
talking about before apache is kind of
faster because they don't actually have
a sorted set multi map so they're
getting the benefit of not having to
have a sorted data structure they're
just using a hash data structure right
we believe in our theories but that's
actually what's contributing to the
performance here so the group but you
know by cost is law less they do not
have an immutable Balti map but what you
can do is that in their map multi map
utils class you can actually ask it to
wrap your multi map as a non-modifiable
multivalued map effectively making it
immutable with the clips collections
when we zoom in
since we're iterating over cards cards
as an immutable sorted set Eclipse
collections provides covariant return
types before it's different protocols
that return collection types so for
group by return a multi map an immutable
sorted set will return back an immutable
sorted set multi map so this is you know
we have to do nothing else here we just
do cards group I get you know suit with
guava and we find is that we have to
actually create an immutable set mult
multi met builder and this is where like
I doing a little bit of Stack Overflow
research of trying to figure out how do
I create an immutable sorted set multi
map and it turns out you can on your
builder you call order values by and
pass a comparator and this has the
effect of in your multi map they wind up
being immutable sorted sets so we
iterate over the cards we call put on
the Builder and then ultimately in call
builder build which now we've got our
immutableset multi map for java slang
similar to eclipse collections you have
a nice I guess fluent API directly on
the collections themselves you call this
deck cards group by this returns you
effectively since everything is default
immutable in Java slang
you get back a map of the the suit to
the sorted set now it's interesting and
I haven't quite figured this out it
would be interesting to talk to the
creator of them javis line there is a
multi map type in Java slang but multi
map is not what gets returned out of
group buys so I found that a little bit
surprising like but it does return map
of a suit sort of to a sorted set so to
summarize we we just went through
creating a deck of cards and the deck of
cards is comprised of a Cartesian
product and a group pad now if you want
to put all like both the images together
on the right hand side which is the
Cartesian product and the blue bar we
will end up getting the deck of cards
you will see all the frameworks are
round about the same alright the app a
chance of winning very highly in
in the group by but it is it is not that
performant in Cartesian product but at
the end of the day it is performing very
well in the holistic view of things
yips collections and guava they're
coming in around about the same thing
JDK JDK are are you know good old friend
it's it's always out there with you know
a consistent performance and again you
have to look at the cumulative value and
then what we did was with with the
breakdown now it really depends on what
sort of operations you want to do on
each of these data structures to figure
out also again your mileage may vary
about this yeah the interesting thing to
understand as well as like with both
Apache and JDK you're not coming back
with immutable data structures they're
unmodifiable wrappers around mutable
data structures they're effectively
immutable because you won't be able to
change them but you know that actually
is a trade-off in terms of the
interfaces you're getting and then the
performance impact so now like I
mentioned before we are going to the
second part of it like we have finally
created the deck of cards now we know
that there are 52 cards in a deck out of
which there are four suits and thirteen
banks right now if we want to get at any
point of time the number of cards for by
suit or by by rank then we want a data
structure which will help us get that
count effectively so while trying to get
the count by suit you can see in terms
of performance we it in in terms of
performance you can see that Eclipse
collections it has its own bag
implementation so that ends up actually
perform being the most performant now
guava also has a multiset similarly
Apache also has a multiset if you look
at JDK JDK is actually implemented as a
map and account and if you look at it
the the previous slide showed counts by
suit and you got only four suits whereas
this this slide shows counts by rank
where you have 13 ranks so I mean the
performance is not that different but at
the same time it is different and that's
because of the number of operations and
number of elements that you are working
on okay so the car
for jtk to actually support cow by it
looks like this so we have these two
methods counts counts by suit counts by
rank what we do is we take the cards we
create you know create a stream we
actually do collectors grouping by
collectors counting so you've probably
seen code like this before this will
return a map of a suit too long which is
effectively the suits in their counts
for comps by rank similarly we do
grouping by now get ranked and then
accounting we get back a map of ranked
along with the patchy collections this
is interesting discovery Apache
collections actually has two bag types
or two multi set types basically two
types that are very similar right
there's a bag and there's a multi set
and I consider them the same thing so I
showed here is you can actually create
either of them depending on which one
you want so here that we're doing a
stream we do we mapped now I get suit
and actually collect it into the bag
because the bag actually internally
keeps track of accounts similarly for
accounts by rank we're now creating a
hash multi set and returns multi set for
clips collections what we do is we use
the api's that are directly on the
collection stuff using as lazy and then
we can use collections collect method
collect the suit to bag or collect the
rank to bag and this comes back with a
bag tub for guava we use the hash multi
set type in guava which has the
interface multi set so we're just
streaming you know either
mapping to get suit mapping to get rank
and then actually collecting out the
hash multi set in a collector java slang
was interesting java slang does not have
a bag or multi set type that i could
find but what you can do is actually use
streams with java slang and there is
actually collect method directly on the
types themselves underneath this so
actually create the stream for you but
here we passing the group same grouping
by you know counting collector that we
used excuse me for the for the jdk and
what's interesting is because we wrote
this code in the same class as it's in
the deck of cards class code java slang
java slang recall has its own map type
called map and here we're actually
returning the Java util map so we
actually have to in this code specify
the path because now we have
to map types in the same class so going
to our last but not the least case where
which was sort of you know a mouthful to
say it's you want to return a cards as
an immutable list which has five sets of
five cuts so what that means is if let's
say you're playing a game you just want
to you have five players each player
gets five cuts okay that's that's it and
this is where you are actually using the
multi map that you created in the very
first the create deck deck of cards
problem statement statement that we have
and we are trying to use that to get out
to to deal the cards to each of these
players and if you look at how the
usages go it again really depends on it
again really depends on how you're going
to deal hands so Eclipse collections had
its own immutable sortedset multi map
similarly guava had their own immutable
they had immutableset multi map but you
are storing it as a sort it said and
then the the way you're creating the way
you're getting these collections and
putting them in this immutable sorted
said actually ends up impacting the
performance and we'll look at the code
yes so we wanted to do for each thing is
we once again we want to return an
immutable list of set of five cards each
what we do for each deck of cards will
create some range we could have done
this with a for loop we decided to use
in stream range for the JDK so we go
from zero to five we actually then do a
map to obj map to object call the deal
method with shuffled most shuffled is it
and I like the I call it deck so
shuffled is a deck of cards effectively
right I'm just a DEQ Yui version of deck
what's interesting what we wanted to do
is have something that was stacked like
right now we didn't want to use the data
case stack I think the the preference
these days actually use array deck index
so we use the deck and we're actually
inside of deal will actually pop five
cards off that stack and then return
that as a set and then we once again we
want the whole thing that comes back to
being a globe list so in the
select method here we do it to a list
but then wrap it as an a modifiable list
there's no difference whatsoever where
the Apache Commons recall they do not
have their own sort of set so the code
here is identical they also use the raid
back Apache Commons does have an array
stacked class I think it was from a very
early version but what they've done is
they deprecated it and in the Javadoc it
actually says use a raid back instead so
if that's what we use with the clips
collections there is a type of into
interval similar to in range and there's
a method one too and you specify and
this is an inclusive range so it's one
two five here int interval is an is a
immutable int list and because we have
covariant methods available like we call
collect this actually returns an
immutable list anyways so we just do
collect we pass in and what you see here
is up top it's the type that we're
shuffling is a mutable stack so Eclipse
collections has an immutable stack I'm
sorry has a mutable and immutable stack
in this case we're using mutable stack
it's useful what we want to do is pop
five cards I don't have the code here
but if you look in the deal hand you
would see that there is a special method
on mutable stack which takes an int it's
popped with an int so you can pop off n
number of things at a time
that's not needing to write the loop to
do pop pop pop pop pop okay so guava the
only difference here it's you know also
using an array deck it's just what it's
collecting into so there is a collector
available on the middle list you just
doing me to blow stuff two immutable
list and you've got your collector to
collect into and this was the most
interesting discovery I think we made on
dealing hands so Java slang has a stack
class it is an amitabh astac though
which is interesting when you have an
immutable stack question is well if it's
immutable how do you don't change it so
how do we deal with pop now it's
interesting when you pop something off
at a me double stack you have to get two
things back you have to get back to the
stack and the thing popped off right and
then you have to keep what you're
getting is new stacks and every time and
you keep popping elements off and your
ultimate gonna you know just be reducing
down to some some new stack so it's a
little bit harder to deal with the code
in terms of doing this because you've
got once again you've got to keep
returning them in the new stack and
there you get back as a tuple two of the
set of cards and
the stack again which you can then keep
moving stuff off of so okay fun stuff
it's a little it's that it's how it's
visible okay good
so what we did after going through all
this good once again there's a lot of
code out in collections compared and
it's something that I found really
interesting looking at like we've looked
at a whole bunch of features right we've
looked at immutability we've looked at
like bag we've looked at multi map we've
used streams we've used you know sets
we've used a lot of different types we
did Cartesian product which had
components of flat map and map we did
group by we created bags which otherwise
would have been grouping by counting so
a lot of interesting things came out of
this very very simple domain but there
are a lot more other things that we
didn't cover right and there are a lot
of things in these frameworks so what I
tried to do is lay out a set of features
in a table here and then compare across
these frameworks which ones have
available so there's four states that
you have it's either yes green checkmark
no red check X or there's the yeah kind
of which is the green check mark in the
little box or not really which is the
orange X in the box so we looked across
all the frameworks for these features
and you see like there's the different
types like list set map do we have
replacements for those we have multi
sets bags multi maps by map stacks trees
or tries tables additional types
do you support primitive collections or
you have immutable collections do you
have a fluent API what types of
iteration strategies do you have do you
have lazy cereal eager parallel and then
what we try to do is like group some
rankings for each of these feature types
like how the frameworks kind of you know
compare to each other known so this is
out there you want to take a take a look
and obviously when you're selecting a
collections framework if you've got what
you need in the JDK awesome use it right
and then if you need a specific feature
like if you need a table wow it has a
great table it's the only thing that has
a table out there maybe you want to use
guava right if you need a whole set of
comprehensive things
you want to use something like eclipses
collections if you have so many possible
needs that you can never imagine maybe
you want to use Apache because it's got
like a huge pile of you know
functionality we don't even cover in
here right so you know a lot of things
can go into your selection matrix for a
framework yeah and not only I'm going to
rephrase here not only the available
features but also how those are regions
early if it's a fluent API it's a
totally different with when you're using
eclipse collections you just go with the
dot dot dot dot with really care you
have to do all these static methods or
the four methods on the interfaces so so
that's I think it's a good way of seeing
what your style of code and then does
this match what I need as well as I'm
coding so I that was also something that
I didn't expect so many different
choices of words choices of how to you
laid out the code and all that and that
shows on the other previous slides as
well once once you have written your
core try to profile it or write
benchmarks for it because you will be
amazed at the things that we found out
so for for example Eclipse collections
the way the immutable sorted set is
created is very different than the way
guava creates they're immutable sorted
set at the end of the day both of them
are actually array backed
because once you want to store something
in for an immutable sort it said you can
actually just Park it in an array
because you're not going to change that
array however the way both of them
arrived to it it's very different and
the reason why they arrived to it is
very different as well so again your
mileage may vary make sure you test your
code and profile it yeah don't take our
benchmark that these are kind of useless
from your application perspective right
but it did help us learn like Achillas
saying we discovered like for in Eclipse
collections when a mutable sort of set
is created we actually create a tree set
and then just dump it into an array and
guava does something slightly more
intelligent like they just take they
build up an array and then the sort they
write and then that's what they keep
right so they actually never create a
tree set out of it now there are
downside impacts they're both at the end
just arrays so they're very memory
efficient but then you know then there's
the Devlin well what does it contains
check against it
right because you know for instance like
Eclipse questions use a binary search
I'm not sure if guava fennan maybe it's
linear maybe they use binary search as
well right so it's like you might get
different trade-offs for like memory and
performance
oops this is the project so it's out in
github doing this exercise of doing this
talk for myself was extremely powerful
right it was like sitting down you know
as a creator of a collections framework
using other people's collections
frameworks is kind of interesting right
you discover like oh you know that's
clever or oh I hadn't thought of doing
that or Wow look at these performance
things once we start measuring like that
they're they're doing some some
interesting work right and I think it's
healthy in terms of the overall
ecosystem of collections for people to
learn from each other right and kind of
you know come up with a hopefully
variety of things that help you all and
us all but have to build applications
with these things to get the best you
know features you know of possible right
so we put this out there we hope that
people will take a look at it and you
know we'll probably be using it maybe
you know other talks of other
explorations right the nice thing is
with this project you have all five
frameworks available in it when you
check it out right so you can easily you
know experiment with any of them yep and
that's kind of concludes what we had to
tell you guys if you guys have any
questions we are happy to take them you
can also tweet at us yeah I think you do
mind coming over to my yeah I want
apologies to since it was our first time
using some of these frameworks if you
know better how to use for Amex I would
love to know because yeah you know it's
very helpful to learn these things to
how interoperable are these frameworks
with each other in the case where I have
to use one class from one and one from
another that's a great question so I
think all of the frameworks provide good
interoperability in some way shape or
form with the JDK and you got to see
some of that through the API were there
differences so for instance the
immutable collections in guava I think
at the end they're just JDK types like
either set or map right so you get
immediate like
cooperation there right where if you use
JDK as a common point you know of
interaction then you could interact
across these different frameworks
together right
all of the frameworks have started and I
think this is where when Leo showed the
slide were like Java eight came out and
there's like a flurry of activity and
releases and collections framework so
like now able to use lambdas and method
references and default methods and all
this cool stuff right and streams as
well like with streams being available
we get streams in Eclipse collections
for free because we our mutable
interfaces extend the JDK interfaces
right so we gets you streams we get to
also then interrupt with JDK types there
are other places though were there's
less great Interop but they're still
interrupts so Java slang I found was
that their interfaces do not implement
the JDK interfaces so they have their
own sorted set they have their own map
but what they do is they provide methods
to translate into JDK types right now
that can be at a cost potentially
similarly like in the immutable
collections in Eclipse collections the
types do not extend the JDK type so an
immutable list is not a list but the
implementations implement both immutable
lists and lists so the implementations
are compatible and you can actually
easily there's a method API to convert
from an immutable list to lists if you
need to work with a library for instance
that takes JDK collection so it's say
like the JDK types are the big uniter in
terms of the Interop right because it's
been around for 20 years so many
libraries use the basic types like list
set and map it behooves a collections
developer to provide interrupts with
these things because other libraries are
going to be using them along with the
dancer
it's I think it was constructing the I
think it's on now
constructing the cards where the group I
operation the Apache metrics were like
double of kind of the other frameworks
and I think you mentioned you attributed
that to Apache not supporting a sorted
set or an immutable sorted set yes
Apache doesn't have an immutable x' well
doesn't have a mutable any kind of
immutable set but so one thing is they
only have to wrap as unmodifiable so
they're just using they're actually just
using a hash set they're not even using
a tree set and I think what you know
which my theory here is that tree set
winds up being you know slower than that
then hash set to actually create right
so yeah I think my theory is that that's
where the performance benefits but here
we are talking about a set valued map so
that's a multi map where we are talking
about the value collection which is
sorted they don't have one like that
they have the value collection which is
just a salsa so they might have like
again they don't have a like they might
have a sorted set but they don't have a
sorted set mult map so yeah I think I
get I think it makes sense like the
difference my I guess the question would
be like is it really a fair comparison
to like present those things it's a
great question so in some ways this
isn't apples to apples right because in
the middle three you've got immutable
collections right and there's a cost to
using those and you get let's say in it
I've been a promises in an immutable API
whereas on the outer bounds you've got
mutable interfaces with unmodifiable
collections wrapping them but that can
actually be a decision that goes into
like how you want to tune your app if
you care about the API maybe you want to
use immutable collections but if you
care maybe in some cases maybe
unmodifiable collections are actually a
better performance option for you right
because when I have a new Moodle
collection I know I always have to
create a copy to put stuff in there
unless as well with Java slang I may be
using persistent collections and
building up you know stuff over
in a longer period but like yeah at some
point you we got to make sure that no
one else has a copy of this thing and it
can't be modified right so it's a
trade-off of like the safety of the
interface or implementation versus you
know the performance right yep I think
so my next question I guess you focus a
lot on like immutable collections
mutable maps mutable sets did you
consider doing like the mutable aspects
like yeah we started writing those so
there's some code out there because I
was curious like you know how does let's
say eclipse collections on the mutable
side compared to other things so we
actually have examples up there but what
we wanted to show here is like this is
where we started I said let's let's keep
things immutable and sortedset and multi
out and just see how it works out right
but then yeah you then this is one of
those things you can determine based on
performance profiles maybe you want to
use a different type right so yeah it's
like it I guess I mean depending on the
use case it's probably pretty common to
do the mutable yeah it also looked at
it's like there's the there's
interesting thing which is if you look
at create deck of cards that's a startup
cost right mm-hmm whereas let's say the
count by and the dealing is more a
continual cost right so it's like could
be a trade-off to in terms of the types
you use you know in the startup cost and
what you care about before it's there
versus the performance of things maybe
I'm gonna call over and over and over
again right because you know cliff
collections was performing better on the
dealing right how's it thank you for
yeah thank you thank you yeah please
come on in
yes I was wondering um I know we had a
lot of focus on performance but I was
just wondering and if you guys could
give a subjective kind of a opinion
which led to the most elegant code in
your opinion I would I would ask the
question back to you what you wanted you
liked best
that was the this was the most succinct
right yeah that's pretty nice I like
that but then if you look at the other
operation and then for jobs Lange he's
they often yeah I didn't like deal hands
they're like a immutable stack meet me
yeah for example so job as Lang has a
very simple group by operation sorry
let me so for example this is job slang
very simple very easy to read and if you
look at the other you have is lying
operations for dealing it's awful my
compare about elegance and all that so I
think that that's what I meant about a
sigh of API on how you're right of API
and all that I like to use JDK because
it's been there forever
and I use all their libraries and that's
what I provoking him because he is the
guy to who date Eclipse collection which
is a replacement for everything on JDK
but uh so yesterday we had the Eclipse
collection Cara which was showing all
what is available and the way the the
fluent API is designed like I think it's
very nice so and Apache Commons is more
like an add-on to the JDK dand a
replacement to the JDK so again it will
use mostly the JDK types I was pretty
happy with the Eclipse collections code
as well yeah so that's the lakes is very
small and but my main point is this for
example looks awful because he's all
collectors collectors collectors
collections collection doing a
modifiable thing that didn't work well
there right because because we have a
lot of static method calls right it's a
lot of stuff to accumulate right and
that's where like having additional
types is useful for you right it's like
the cost is then in the framework I mean
if some framework develop I had to come
up with these types for you and the cost
is then removed from your code as a
developer right yeah so I think I think
it's a matter of taste like we were
discussing
curly braces when we're developing
school like I like Egyptians I oh they
don't so so that's where we said okay
that's one aspect of code that you have
to avail with as well and I think we did
a good job showing you all available
possible ways of doing this and again in
the code there in the repo there's a lot
of other things that you can take a look
and see hey they suits more my style and
new hopefully to help you choose one for
your also if there's any other domain
which you would like to see because this
this project can go on expanding rate it
it's out there it's all on github and
hey you if there's one more framework
that you would like to put and if
there's another domain for a specific
case like for example we were writing
performance tests for filter and
transform right but the performance
tests are out there but it sort of
Denzel well with the presentation also
there are other implementations with
like instead of our immutable sort it
said we have lists you know in in sort
of immutables we have unmodified books
like all of those things so again to
answer your question it depends yeah and
so uh my opinion for example I liked
their Pasha collections because it's
like the JDK so it's I kind of think the
Masai mate mindset these guys work a lot
with a couple collections so they're
gonna say Eclipse collections otherwise
they would that differently so I guess
that's that's that's subject answer to
your subjective question I think we are
yeah thank you everyone for attending
your precious one hour with us and
attending have a happy day box thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>