<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ask the JDK Architects with Mark Reinhold, Alex Buckley, Alan Bateman, Brian Goetz and Stuart Marks | Coder Coacher - Coaching Coders</title><meta content="Ask the JDK Architects with Mark Reinhold, Alex Buckley, Alan Bateman, Brian Goetz and Stuart Marks - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ask the JDK Architects with Mark Reinhold, Alex Buckley, Alan Bateman, Brian Goetz and Stuart Marks</b></h2><h5 class="post__date">2017-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/FdkPHShh628" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon welcome to another
edition 2017 at devoxx belgium have
asked the jdk architects this is the
shortest presentation of the week don't
believe a word that we say right not
necessarily an order yet like I said
don't believe a word we say and this is
QA there are there's a microphone over
there or no there's a microphone there I
don't see one over there
it would be best if you you would use
the microphone that way the recording
will make sense and we don't have to
repeat your question if we repeat your
questionable we will almost certainly
distort it and that would be bad way bad
for you not bad for it bad for us or
just just a moment just a moment just a
moment just a moment or you can ask
questions by tweeting this hashtag but
first we will each introduce ourselves
starting with Alan Alan Bateman Brian
yes Stuart marks I work with Alan
Bateman on the jdk court libraries and
my alter-ego is dr. Debra cater well
actually you are doc deprecate - your
alter-ego Stuart marks my name is Alex
Buckley I work on the Java language and
VM specs and my name is mark Reynold but
you knew that all right who would like
to ask the first question
no questions okay
yeah their microphone in the back please
for well halfway up it's the first
session after lunch an opportunity for
exercise reverse reverse The Price is
Right you walk towards the back so there
are many new projects going on to
improved JDK under very nice code names
my favorite that I haven't heard much
about lately is a project Sumatra which
would make it possible to well make use
of the power of GPUs and other Android
generous architectures from within Java
I know there are some external
frameworks but I was wondering what is
the state of Medusa's in that in Java
itself so project Sumatra was jointly
funded by Oracle and AMD originally and
after about two or three years it kind
of fizzled out the the results that we
were seeing in terms of performance were
not very compelling and the resources
that were involved in it kind of went
and worked on other things and so it's
been dormant for quite quite a while but
the logical follow-on to project Sumatra
is project metropolis which is the an
umbrella project for a wide range of
Java on Java technologies replacing
various components of the JVM with
components that are written in Java and
sort of the biggest component of that is
looking at the growl compiler developed
by Oracle labs as a possible replacement
for the C 2 compiler and growl has a
fairly nice story for generating
generating GPU code so it looks like the
most promising path to getting you know
automated vectorization and automated
GPU targeting in Java would be through
that
secondarily you if you look at the
recording of the the Intel keynote of
Java 1 this year the there's some
demonstrations of some work of
vectorization that's being done in the
compiler back-end you know in the jdk
targeting the AVX instruction set so
it's not just GPUs but also the vector
vector instructions that are available
in modern 64-bit CPUs as well any it was
always a known fair question but any
idea of what the timetable is to the
roadmap base tool to expect that in
sometime between now and the heat death
of the universe thank you that was very
useful no seriously thank you question
about project amber I don't matching is
super cool I'm wondering though in the
example you showed about different
shapes aren't you kind of forcing people
to stop using object-oriented
programming what's your pain so this is
a great question so I'm glad you asked
that
so object-oriented heritance gives us a
form of declaration sight polymorphism
which is to say that when you're
designing your class hierarchy you can
specify a polymorphic implementation of
an operation like the shape area one
that I gave that's a good tool to have
in your toolbox but that is not
necessarily the only sensible way to use
polymorphism pattern matching
complements this by giving you used site
polymorphism or ad hoc polymorphism
where you can say here's an operation
that operates on an ad hoc collection of
target maybe they're related by a type
hierarchy like shape maybe they're not
the operation I'm performing is not
necessarily one that's so important that
it belongs in the type hierarchy and so
it makes more sense to implement it in
an ad hoc polymorphic way and there are
situations where that's absolutely the
right answer so if you think about the
kind of things that we do with the
visitor pattern today where you have you
know the classic example from the Gang
of Four book is the data structure your
groveling over is a document in a word
processor and you have some operation
like count the words or change
all the bold words to italic or
something like that some of those make
sense to put in the hierarchy of your
node classes and you know they they
belong in the domain and so you would
use inheritance for that some of them
like count the number of occurrences of
the string 42 obviously would be a
stupid thing to put in your hierarchy
you'd have like 16,000 methods and so
you don't want to use probably
inheritance to define those things so
pattern matching complements the
polymorphism that we get with
inheritance and lets you as the
programmer choose between is this a
sensible thing to do as part of my
object hierarchy or is this a sensible
thing to do is the use site and having
both tools you have a better chance of
picking the right one
cool thanks one more it's the same
subject using the VAR instead of the
variable type declaration it's easy for
the computer to interpret it but for the
user you're kind of missing some
information at a glance it's actually
could be the other way around there's a
lot of work for the computer to do that
as well including some difficult choices
that the computer has to make that we
try to our best to hide from you but
ignoring that when we design language
features you know everyone says they
want less boilerplate but that's not
really what they what they want what
what we want is for code to be more
readable so is it leading the type
information or including the manifest
type information which is more readable
and the answer is it depends on the code
so there are times when the type
information is just in the way it's just
a bus to Tory and by removing it you can
see what's going on more clearly and
there are times when the type
information is very helpful especially
when you've chosen rotten variable names
like XY and Z and you take that type
information away and you've lost you
know you've lost something so again it's
one of those things where developers
have to use their judgment as to what
constitutes more clear readable
maintainable code we think that this is
a tool that's reasonable to have in the
toolbox will it be misused absolutely no
question it will not be misused is that
a reason to say no one should ever get
to program this way because some bozo
might ruin it for the rest of us that
seemed a little mean so it's you know I
think good developers will use this tool
effectively and write better code bad
developers will use it poorly and write
worse code but it's not like buying
insurance against bad code is very easy
to do anyway so on balance it seems like
an improvement so as a complement to
that so Brian of course said it's going
to be misused there's no question about
that but the flip side of that is
whenever there's a new language feature
it takes time for developers to learn
how to use it effectively and so one of
the things that we've been discussing
internally is developing a style guide
for this right so and you see some of
this in the surveys and the write-ups
that Brian has has put out but sort of
you can imagine a whole bunch of rules
that emerge about this but I think the
overarching overarching rule is use the
VAR construct when it makes the code
clearer and more concise and you're not
losing essential information it's it's a
little too easy for somebody to say
don't use var because it doesn't have
the type information well if you've
chosen the right variable names if the
initializer makes it clear then you
don't need you don't necessarily need
the explicit type there and that depends
on the context and so I think developing
some style rules about that around how
to use this new construct effectively is
something that we're keeping an eye on
and we might when I put out some
articles about that at some point it's
quite interesting that in a lambda
expression you can omit the type of the
lambda parameters and no one's very
worried about that and yet that's a
place where obviously it's it's more
compact you typically have multiple
variables and it's you don't have as
much base as you do when declaring
locals so obviously you want to Li it as
much as possible but that puts then the
focus on what are the parameter names
for this lambda and then no one then you
get into the body of the lambda and no
one is worried that you didn't have an
explicit type for the lambda parameter
so I think a lot of that in practice
will carry over to local variables
declared with var because
bear in mind it's just local variables
it's not fields it's not formal
parameters of methods so the next
question is going to be can I use var
for lambda formal parameters the answer
is yes right
one more thing I want to add to it is is
it's very easy to imagine I have some
code now if I change it to use this
feature it will look worse if I put var
here but you we don't always realize the
way we distort code to fit into the
language as we have it so I see a lot of
code where people have crammed
everything into one either chained
expression or deeply nested expression
because apparently they didn't want to
have to declare a variable by lowering
the ceremony of declaring a variable
there's a chance that people will
actually separate these things that are
logically separate things into their own
variable with an assignment and make the
code more clear so I think there's a
degree to which people are distorting
their code today as a workaround for the
verbosity of having to declare not not
only the variable but the type and
sometimes the types are fairly long to
write out and if they don't have to do
that they may actually write better
structured simpler code have we
exhausted this one it's a very very rich
topic so there's a question from Twitter
I'd like to to take why too big heap GCS
both shenandoah and and Zed GC so for
those of you don't know red red and some
engineers from Red Hat have been working
in the open JDK community for a while
now on garbage collector designed for
large heaps and low latency it's called
called Shenandoah recently some
engineers from Oracle announced the
intention to well we've proposed to
create a new project in open JDK for a a
similar garbage collector but but a
different garbage collector which you
know for reasons not up to us were
developed internally at you know that
this PC was developed internally at
Oracle for for a while and it's you know
it's not mature either but it's but it's
coming along and as part of the general
move towards open sourcing all of the
commercial
features in the Oracle JDK Wells fgc is
one of those components and so that's
why this proposal was made at this time
this is this is just about source code
and projects at this point right neither
of these GCS is in the JDK mainline
maybe one of them maybe both of them
ultimately will be in the JDK mainline
it's up to everybody working in the open
JDK community to figure out what makes
sense maybe they maybe each GC has maybe
maybe there's there's there's enough
difference between the problem spaces
that the GC is addressed that it doesn't
make sense to have them both maybe
there's some way to unify them to get
the best of each and have everybody with
this expertise in the open JDK community
work on just one garbage collector the
winds up in the mainline we don't know
yet okay it's it's just a proposal for a
project well we'll have to see what
happens please yeah so I have the owner
to be the first one to ask question on
JDK versions yeah
Aleksey would like to add something okay
special guest Alexis Avila hey I'm
actually the guy who develops turn on
door among other things and none of you
guys develop CGC so it's easy so you
might think it is problematic to have
two proposals on the table but the thing
you don't realize without studying the
GC code like that is that most of the
parts that are interesting for users are
not the GC algorithm itself but rather
the runtime improvements that come with
it because runtime has to do many things
like weak reference processing that it
has to do concurrently for concurrent GC
to work and all this language specific
stuff so having two proposals basically
means that you have twice as many people
working on these shared parts so as Mark
says whether or not one GC is
overwhelmingly better than the other
it's the open question and what will we
do to when a time will come
the site which GC goes in or whether
both DC's are going in by that time we
will also solve lots of problems and we
will merge some of the good solutions
from both GCSE so everybody in this room
will totally win thanks Alex like
anybody else are ok that's good so I've
got a question concerning JDK versions
part of the current statement is that
vertical version will increment what
every feature release and are any
worried the impact that might have on
all the particle processing libraries
that are literally instrumental to all
the frameworks we we users are building
upon a little bit but this this this
this is a big change you know not just
for those of us who work on the JDK but
people who maintain things built on top
of it especially things like bytecode
libraries that are you know that
sometimes get to get fairly intimate I
need to know what the class file version
is but the way I look at this is all the
reasons that say that it makes sense to
increment the first numeral of the
version number going from 9 to 10 to 11
to 12 and so forth all of those are the
reasons that let's say that makes sense
to do that on a time time-bound basis
same thing applies to the class file
version number all of the same reasoning
applies so if you if you accept one then
I think you have to accept the other I
understand you know we understand it it
will be tricky at least at first for
tools and libraries that are sensitive
the class file version to adjust to this
at a quick pace and maybe in some cases
at least they can find more flexible
ways of doing that rather than baking in
specific version numbers but a sort of
philosophical point about all this and
and something but I think colored colors
the way that many of us think about it
is doing a major you know doing a major
release as we have every two to three
years with a schedule that can adjust is
really painful and doing these big
big releases it really is really painful
a lot of that pain you know the there's
this generic truism about about a
painful process if a process is painful
do it more often and you'll figure
you'll be forced to figure out how to
make it less painful and I suspect that
applies in this case too one other thing
to say as well is this is that that the
most popular by code library out there
is Azzam today and the committer is on
azemar actually working on all of these
projects that are actually changing the
byte code so you can be confident that
the day that a new version goes out
there will be the same day you would
hope the version of Azzam that actually
supports that yes there will be a stack
of other tools and plugins that will
we'll need to possibly update their
dependencies but the most popular by
coda library which should actually be
supporting the version on the date ships
here is a small anecdote that echos
Mark's point about doing something
faster to get the most out of it
I remember vividly after Java SE 7 went
final so se7 was the release that had
invoked dynamic dynamic byte code in it
and a whole bunch of new class file
stuff there was a new class file version
51 for se7 great a couple of years later
I got an email and it was someone saying
that a well-known tool that I shall not
name was being tripped up by one of the
new constant pool new kinds of constant
pool entry and I thought huh but but we
added that two years ago it was
perfectly well specified it was clearly
documented but that tool hadn't yet
gained support for version 51 class
files two years hence for some people
there is no amount of slowdown that's
enough for some tools there is no amount
of waiting and hang on and I'm not ready
yet that's enough so at some point
whether it's every there's a release
every week month six months year you
have to you have to accept the future
and quit complaining that what that
what's in this class file I don't
understand well it was it's two years
old already
rent a villa in the red I can add to
that ranch in that I saw a bug report
yesterday where someone was complaining
about a bytecode library that was having
trouble with constant pull tag 18
invokedynamic so they were the only
reason they were seeing it now is
because it was the first time that they
actually used it with code that was
compiled for what's with the the new
string concatenated a with lambda but
yes you're exactly right years on
they're still finding problems ten years
okay next question about type inference
about the choice of the VAR keyword
there because like C++ and D have Auto
and JavaScript as far but a very
different meaning and we're not supposed
to use that anymore anyway and so and a
groovy has death which also has a
different meaning but it's used in the
same type context so I was wondering
what the choice was so you're wondering
on what basis we made the choice right
well we know we put worth more on the
wall we threw darts and wherever it
landed that was good oh how we all make
over there you know the reality is in
some sense these decisions don't matter
right and you know that doesn't mean
that we don't spend any time with them
in fact we spend a lot of time thinking
about them but I pick var people say why
didn't you say def if you pick death
people say why didn't you pick var we
you know while we solicited some input
through some user surveys we had over
2500 sponses to a SurveyMonkey survey we
put out where we ask the same questions
in like several different ways to try to
elicit people's emotional reactions to
various options we looked at the data we
looked at our anecdotal evidence from
focus groups and we said this is the one
that feels most in the spirit of what
Java developers are going to expect and
it's a subjective choice I suspect that
like I said if we had gone a different
way we would have gone all the same
questions of why didn't you do it the
other way it's just
you know you make the best decision you
can you with the information you have we
gathered quite a lot of information we
made a decision was the Democratic vote
it wasn't a democratic vote but it
wasn't an arbitrary I like this best
either it was we asked people what they
thought we listened to their answers we
thought about it ourselves we asked each
other what do you think and eventually
we came to this seems like a pretty good
answer
thank you hi running Java inside
container still feels a bit more bulky
their native processes and things
improve but I would like to know what is
ahead for us sorry when we're seeing
containers you mean like docker
containers so especially in regard to
resources usage and making resource
users transparent to the outside world
like Cuba needs and resource limits and
so on right so there's there's some good
work going on in this one of the eight
updates and in 9 both have XX options
that you can actually turn on to pick up
the the the the the resources and
memories available when you're running
in sea groups and bobland debt has
another jet which there are some of the
changes actually are going in review at
the moment to go into I guess 10 and
that will really improve this as well so
you go to the hospitalist you'll
actually see a big long discussion
that's going on over the last couple of
weeks trying to refine that so that the
the right information about the
container environment can be used to
actually to Desai's memory okay and
trade pools okay anything really
exciting oh this is good enough the best
thing you can do on JDK 9 other than the
xx lags - does it set the CPE number of
CPUs CPU is the first thing you should
do after you download JDK 9 is run
j-link
and build yourself an image which is
the Java based module and you will find
that any docker image you then make is
radically smaller than the one you were
getting from JDK eight radically smaller
yes so that that that will save you on
docker image size it's not as though
it's going to start up ten times faster
or anything there are a couple of
projects going on on the startup side
though right so you know so so container
friendliness has a lot of aspects as
Allen pointed out there's respecting the
the global limits then with the you know
that you know docker tries to set its
points it out there's there's container
size on the startup side there's a
couple of projects going on which is
where open sourcing apps EDS and also in
nine there's a sort of technology
preview of ahead of time compilation
both of which are startup and sharing
plays and so if you're running you know
either starting the same container over
and over again or running that many
copies of the same container on the same
machine they can share more data across
VMs and therefore use less memory so
there's a quite a few initiatives going
on to make java more container friendly
all going on sort of at their own rates
I I think it is a very good idea to have
a six months long release to move
forward faster that's great
but my question is ideally if you could
remove just one feature from the
language because it doesn't play well
with the rest because it slow you down
which one will be protected
I hate protected with a passion it is so
much more complicated than all not just
all of the other access control
modifiers because you said in the
language you were very specific about in
the language not in the platform in the
language protected it has impact at
compile time at verification time at
runtime and obviously obviously there is
a particular kind of scenario where it
is useful which is very heavily oriented
towards subclassing but we all remember
the effect of java recommend
to prefer what does a glommer a ssin is
that the word over inheritance
application delegation waiver
inheritance which mean composition yeah
over inheritance and so protected is no
inheritance that's the best thing ever
and I'm gonna I'm gonna have a little
hierarchy and you can access that a bit
but not that bit and you have to go
through the right receiver really look
up the rules for protected it's awful
that's my answer
this is one of Alex's regular regular
rancis as maintainer of the the language
and virtual machine specification sees
use entitled to rant about things that
make is lifer so so I wanted to mention
something that we've already started
work on removing which is I will bend
your question a little bit so it's not
officially part of the language but it
is part of the platform and that feature
is finalization and so in jdk 9 we
deprecated finalization it is not
deprecated for removal yet we expect
that there's going to be a long
transition period before we can actually
remove it but we started work on that
and so if you if you follow the jdk
mailing list you'll find a bunch of
change that's where people are
discussing removal of finalization from
various key classes in the core
libraries and so i think that's one of
the steps we need to go through we need
to do a lot more assessment about how
many applications and third-party
libraries using finalization but the we
don't have a full roadmap for this yet
but what we want to do eventually is get
to the point where we can actually turn
off finalization because we were you
know we you know we had some discussion
about GC here before that is if we had
some if we had a GC person on the panel
they would be ranting about finalization
and the the official word from lexi here
in front row says it totally sucks
and that's his well considered technical
evaluation I think I think most most GC
engineers would agree with that it
finalization just complicates everything
just like Brian and I have complained
about serialization just complicates
everything finalization is the is the
thing that were you know I mean we've
already started work on on taking that
out but it's going to take a while
yeah let's do finalization first we'll
get to weak references later
speaking of serialization yes or stole
my thunder here but serialization has
got to be the worst mistake we ever made
and it is a source of security bugs it
makes it much harder to evolve the
libraries because sometimes you have to
worry about not perturbing their serial
form as well as their external API and
their behavior and it's something that
makes every language feature harder
develop so like when we did lambda and
Java 8 the the number of hours we spent
trying to figure out how to make lambdas
interact with serialization was well
into the hundreds and the best that we
were able to do is something that didn't
like always completely suck so it was a
tremendous uh you know it took a
tremendous amount of time and effort to
get a mediocre result and it has
interacted with virtually every feature
we've ever done Oh serialization stop my
list I even wrote the chip to remove us
is the mark will remember stated dated
April 1st 2012 or something then you
withdrew it will bring up and we will
resurrect this someday
so the question on Twitter I'd like to
take actually from from goon arts in
which release will the default behavior
for the deep reflection switch also
known as permit illegal access change so
for those of you don't don't know what
the switch is about in in jdk 9 well all
up in the implementations of Java SE 9
we chose to allow a certain amount of
deep reflection into platform internals
at least platform and journals that
existed back in 8 in order to make it
easier to migrate existing code to 9 a
plan over some period of time is to
tighten that up so right now you will
you know at a high level the the
description is is you will get a warning
on the first illegal access to some JDK
internal
API and the warning will tell you how to
get more warnings about all the rest if
you want but that's all that will happen
in some future release we will turn the
knob one notch and then you will get a
warning every time it happens and then
some release after that we will turn the
knob another notch and you won't get a
warning it just won't work because fine
and finally we will have strong
encapsulation of all of the JDK
internals so it's an interesting
question and one that we grapple with
Alan and I were talking about this again
just this morning how quickly should we
ramp that up should we should return
turn the knob in 10:00 in March should
we wait until September 4:11 should we
wait until you know 3:00 LTS releases
from now it's it's a it's a tough it's a
tough call but I think in principle we
we reserve the right to to take away
something that's been deprecated for
removal in the very next release the
very next feature release even if it's
only you know even though it's only six
months away but it's also critical that
we apply judgment to removing things and
in this case I think I think the right
answer you based on what we've seen in
terms of people encountering these
warnings people who are still you know
catching up people who may actively
maintain libraries you know dealing
dealing with these warnings and and
moving their code forward along with the
platform or since right now is changing
that default in September probably makes
sense so you would get a warning on on
every such incursion and then we'll see
how it goes and maybe we turn off all
illegal access a year after that maybe
we turn it off six months after that a
lot of it's going to depend on the data
that's available and a related point is
if you maintain a library or tool or
framework that's using some old JDK
internal API and to get away from that
you need some new standard API we can't
provide it for you unless you tell us so
you know please come to the appropriate
open JDK mailing list and let us know if
there's you know
some straightforward method or a class
or two that would that would make it
possible for you to move away from using
an internal API and we'll look into
providing it or maybe help you provide
it yourself there are about a hundred
and fifty people in this room and I
would like to do a quick straw poll if I
mean who here has downloaded and run JDK
nine basically basically all the hands
okay who when running JDK nine has seen
the illegal reflective access warning
that we're talking about some hands not
definitely not a majority well now
people running nine out maybe a quarter
and when you saw my friends the illegal
access warning and you saw the bit that
said please report this to the author of
the class that's doing it please put
your hand up if you actually reported
something for hands yes they should get
like a queer game Rises you something
thank you
there's talking to your self count yes
thank you a question in the old days of
Java 7 when we wanted to reference a
method we had to use strings and
reflection and Java eight gave us relief
from all these problems but there's one
spot left where we cannot use method
method references and that's if we want
to use it in an annotation is it planned
to fix that yes thanks so the the
enabling factor that out that we needed
to get to before we were able to do that
because we knew from the outset that
that's something that people wanted to
do with method references is being able
to represent them in the constant pool
so monied but if you read very carefully
in the java language spec and project
yourself forward into the JVM spec you
will see that all the things that you
can put in an ante
can be represented natively in the class
file constant pool and we did not have a
suitable native representation for a
method reference in the constant pool
until now so we have a Jeff that is
currently chugging along very nicely
called constant dynamic which allows
more flexible range of things to be put
in the constant pool so that it was an
essential enabling technology in order
to get to where you want to go then
there's a bunch of additional work
there's the JVM spec work for how do we
represent this in class file that's a
matter of specification there is some
work in the language spec and in the
compiler to enable it so but most of
that is the proverbial simple matter of
engineering the hard part was how do we
represent these things and from a
language evolution perspective we think
it makes sense for the things for which
the language gives a linguistic literal
form to be things that are they almost
overlap perfectly with a set of things
that you would put in an annotation so
method references is the constant method
references static method references
constructor references and unbound
instance method references are the
sensible candidates for doing they're
bound bound references and lambdas would
not happen okay question on Twitter that
I think would be useful to answer and
should be fairly quick can you tell
something about the expected timeline
for open sourcing the commercial JDK
features so there there are several of
them and the timelines vary it depends
on on the feature you're talking about
so the principal ones are application
class data sharing which Brian mentioned
earlier that's actually slated for 10:00
the subjet for that will be proposed to
target pretty soon and hopefully
hopefully targeted pretty soon we have a
Java flight recorder and Java Mission
Control those I don't think arguing well
I'm pretty certain are not going to make
ten we would like those to be done
within the next year and people at
Oracle are working on them actively the
fourth big one is there's a garbage
collector which we just discussed
there's a project proposal open open for
that when if and when that project is
created then the source code will be
there
activity will ensue there are a number
of other differences between
openjdk builds and Oracle JDK builds in
terms of features of the remaining
features are all tend to be really small
potatoes and most of them are pretty
obscure and art are what is likely to
happen to some of them is we will decide
these are so obscure they don't belong
in either kind of JDK we're just gonna
get rid of it because it's maybe some
old legacy thing that was done for some
you know son product 15 years ago and
just doesn't matter anymore in some
cases there are there are things that
we're pretty sure no one cares about and
it's code that we cannot open source so
we'd have to write it all from scratch
for example SNMP support how many people
care about SNMP apparently it was a good
idea 10 years ago but it hasn't one okay
but it hasn't caught on and we've got
this body of code that we just don't
have the rights to open source so you
know if somebody wants to invest in
doing it over again in the open well
sure but you know I don't think Oracle's
gonna do that so that's that's the
answer the answer there please hi can
you please tell me how you test the new
version of JDK like how do you verify it
works exactly as you designed you have
like a set of old Java programs in the
world and amongst our weapons there are
many many ways what are the principal
ways is we publish early access builds
and ask you all to help and if you've
done that thank you very much please
keep doing it it is immensely helpful
but there are lots of other ways in
which we test what we do mark just
inverted this and that's exactly what I
was going to say oh sorry does a lot of
testing actually goes on every if you if
you follow anything that goes on an open
JDK you'll actually see that all bug
fixes all features are all jep's they're
all coming with tests and just if you
fix a bug then it comes with a test
there's a huge pool a body of Chester in
open JDK they're actually run all the
time they run continuously after each
and then there's lots of water testing
that goes on as well and on the Biddle's
themselves in terms of big applications
yes it's it's wonderful to get as much
help as possible with the early access
fields actually defined issues because a
lot of the times when issues and
regressions show up there in strange and
conditions that are very very people
won't have thought of originally and so
any amount of testing that that people
can actually help it's a great way to
get involved in open JDK so the problem
or a little bit more structure on you
know the kinds of testing that Alan is
talking about so we have a number of
distinct kinds of tests we have the
performance tests that jck tests that
are produced as part of the
specification reference implementation
and conformance test suite through the
JCP when we make a new version of the
platform specification there are a set
of conformance tests that that you have
to pass in order to be called java so
there's certainly those we have what we
call quality tests those include the
regression tests that people file with
bugs as well as tests that we write as
part of development and the many but not
all of those are available in the open
in the same repository as the code we
have what are called big apps tests
where we run a variety of large
applications just to make sure that
nothing has gone wrong we have some
stress tests some of which run for weeks
or even months for testing things like
you know does the GC leak memory over
you know long periods of times and
things like that so we you know we have
performance tests geared at identifying
performance regressions so there's quite
a few separate test suites each aimed at
sort of a different aspect of quality
conformance etc a follow-up question
from from Heinz on commercial features
well will they be available for Java 8
once they are open sourced well the
source code will be available if you
would like to backport them date have
fun questions up there please all right
so I have a question about notations as
well it's a bit hard to explain so it'll
give you some background imagine real
library like J unit or spring and you
want to use notability annotation
yeah but you don't want to force you
users to have those available at compile
time as well right so you want to make
it an optional dependency the thing is
that works fine you don't get a compile
error or even a warning for an
annotation but as soon as that
annotation uses an enum constant you
will get some annoying warnings by the
Java compiler is that actually a feature
or a bark or why is that
so annotations are statically typed
checked so I don't entirely understand
what you say when you say that you can
compile without the annotation type
itself right if you write out foo one
first you the filling station I have
more available so I'm not gonna be rude
a detailed question where the answer is
annotations are statically typed checked
I don't know how much more we can go
into that there is no optionality when a
Java compiler checks both the annotation
and the elements of the annotation yeah
may I explain that in a bit more detail
so we don't have a lot of time left
maybe it's better to take this note
there were like five people behind you
all right
if you wish to ask a question please go
up to the microphone or or or you can
try Twitter but people at the
microphones generally have priority
unless something really good shows up on
Twitter all right I'll look at Twitter
then when will drop and make the
semicolon optional the answer from the
panel is never accept in array
initializes the master
that's commas sorry Pullman's commas you
can't omit the comma semicolons are
already optional jay chou that's true
speaking of jay chou with jay shell
being able to run instructions from
files it is now possible to use java as
a scripting language bad practice or are
you planning to work on making that a
more viable solution i think JJ show was
not intended to be a scripting language
and there there are we've we've kicked
some ideas around for a more viable
solution that would that would amount to
essentially defining lightweight
compilation units that allow you to
write things at the top level of a of a
source file without having to
necessarily to embed it in a class or an
interface anymore yeah III think it's
fair to say that you know you can use J
shell that way we sort of view that as a
bit of an abuse that was one of the
things that we when we were designing J
shell we explicitly considered is this
requirement and we decided no this is a
separate feature
I know people wanted I know it seems
almost the same but all the design
decisions in J shell were made in favor
of providing a good interactive
experience and those are not the same
decisions we would have made if we were
providing a shebang runner for Java so
if that works for you great but just be
aware that that's not really what it was
designed to do and if it turns out not
to work as well as you thought don't be
surprised but we are thinking about
you know other ways to get to the same
place as Mark alluded to both at the
language level and at the tooling level
yeah boxing Willa David disappear as a
generics of primitive types and when
before the heat death of the universe so
boxing as a language feature will
certainly never go away we're not going
to be deprecating java.lang integer but
it may be possible in some future
version of Java to be able to terrify
over primitives or value types without
boxing and this is the subject of
project Valhalla
You've so you've probably seen us talk
about this here in the past this is a
relatively large project it's fairly
deep and invasive into the guts of the
VM to allow both user definable value
types which are unboxed aggregates and
to extend the generic type system so
that you can genera fie over such
aggregates without forcing boxing so
this is definitely something that we
care a lot about we're working towards
it it's a long road to get there so it's
gonna be a while but it's certainly you
know something we're investing in know
if you have a question please go to the
microphone we're not going to repeat
anyway great job with Java 9
what's next is it going to be a big
change like Java 9 was in the future or
just a lot of small stuff you guys
relaxed or where you can attack on
another big problem well in the other or
and the other question is what is each
of yous pet peeve with Java 9 that you'd
like to change well so it's right after
DevOps where we're all going on a
three-month vacation it'd be nice sorry
what was the first part of your question
it was you Java 9 was a really big
change right did foresee in the future
another huge big change ever is that
there will never be another release as
big as Java 9 but a related point that
I'd like to reinforce I mentioned this
at the keynote yesterday is with the
more frequent releases the intent is
that the overall rate of innovation will
chain will stay the same
so if you look at Java three years from
now the relative Delta could be about
the same as from eight to nine hopefully
not as disruptive but in terms of the
agglomeration of new features the the
main point about the six-month cadence
is the rate of opportunities to deliver
innovation increases and so then that's
why there will there will never be
something as as big as nine and that
doesn't mean that we can't deliver a
feature as big as jigsaw or lambda or
features that would have been released
drivers in past versions we can work on
big things like we just talked about
Valhalla that's a very big thing but
it's not something that's gonna be the
release driver for release it's
something we're gonna work on and we're
gonna work on it for a long time and
we're gonna break it into smaller pieces
and when it's ready the pieces can be
delivered but there won't be releases
that contain as much change right in in
fact looking looking back at jigsaw
jigsaw went into nine in three or four
you know big steps you know the the the
the each one of those steps could have
been in a separate six-month feature
release without you know with just a bit
more work so it it can increase the
overhead a little bit but we don't think
by too much we have a minute and 30
seconds left
quick quick comment on that so so kind
of the counterpoint to what Brian said
about big features taking several years
and going into the release when they're
ready with the more frequent releases
that's an opportunity to deliver our
smaller features much more frequently
and so in JDK 8 and 9 we put some small
features in but then those had to wait
you know sometimes a couple years before
people could use them because the whole
release had to go out and so I'm I think
one of the things that we're looking at
in the core libraries is just adding
small bits of API functionality here and
there that people are asking for that
will make people's lives incremental
better and then that can go right into
the next release this is gonna be super
quick since he asked about what is a pet
peeve of JDK 9 we won't have time to do
one each but I will give you one it is
the fact that the Java beans
API is still in the Java desktop module
we simply couldn't bring ourselves to
force it out into its own module so if
you're using any of the Java beans API
as you need all of desktop sorry we
actually we in an earlier jigsaw design
we had a way of pulling it out but it
made the model system incredibly brittle
and complicated so it was one of those
difficult trade-offs we take one more we
can take one more you know it's quite
quick it's about a syntactic sugar that
I don't know if I'm the only one would
like to have it in Java is the safe
navigation operator too we want to do
Aidid be that different of not the
eldest operator and I would like to see
if it's foreseen and if not what are the
reason behind it's not on our radar it's
not because we think it's an outright
stupid feature but every time we look at
the list of features that we could work
on there are always more promising and
worthwhile things to work on so it just
never makes the top of the list and I
suspect it won't it's also something
that is tired it's a string that's tied
to a bigger rock which is with you
people say oh I just want the Elvis
operator but really what they want is
optional types in the type system and
that's a much bigger and invasive fit
more invasive thing and then they say
well I really just want optional types
but really what they want is for all the
libraries to be retrofitted to use
optional types properly so when you pull
on that spring what looks like a tiny
simple syntax only feature becomes a
hundred-man year re-engineer the JDK
projects well there's also the the
nearby rock that some people want of
well you should just get rid of null
which is an interesting Rock yeah
all right with that time is up thank you
very much thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>