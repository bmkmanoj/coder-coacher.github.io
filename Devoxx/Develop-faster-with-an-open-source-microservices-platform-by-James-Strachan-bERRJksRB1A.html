<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Develop faster with an open source microservices platform by James Strachan | Coder Coacher - Coaching Coders</title><meta content="Develop faster with an open source microservices platform by James Strachan - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Develop faster with an open source microservices platform by James Strachan</b></h2><h5 class="post__date">2016-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bERRJksRB1A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright hello everybody welcome to my
talk thanks for staying so late in the
day and coming and seen this talk we've
got lots of interesting things to talk
about so let me get right into it so
software is eating the world and pretty
much all the biggest companies in the
world of software companies now if you
go through almost every business it's
now a software business even if you
don't realize it yet so selling books
and Raziel hotels
Airbnb transportation uber even car
manufacturers spend a lot of their time
writing software these days self-driving
cars anti-lock brakes navigation systems
management systems you go through almost
every industry these days and
everything's had a software now which
the software developers these awesome is
totally awesome I remember a couple of
decades ago being worried we might run
out of things to write like it felt like
things were getting too simple and we
might not need so many programmers it's
actually exploding now right with Big
Data artificial intelligence the web
mobile Internet of Things social media
and we just need more and more software
all the time which is awesome for us in
the room right that's really really good
but the challenge is for a lot of
businesses and kind of like this court
it is not necessary to change survival
is not mandatory in other words
increasingly businesses have been
disrupted by new startups particularly
who have figured out how to do software
well how to deliver software value
quickly and how to solve real to give
really good user experiences quickly a
lot of companies have never really quite
figured out how to do software very well
right a lot of industries are quite a
lot of companies can be a little bit
kind of slow right and so all of us
really now need to really try and speed
up up our game to avoid being uber eyes
right so I hope today's talking will
show you how you could all go really
really fast right and deliver business
value well now software is really hard
it's really easy to write software but
it's really hard to write software that
delivers real business value right any
programmer can sit there with a compiler
and a keyboard and
write something the poem is it might not
be the right thing your business needs
to add real business value right and one
of the worst things you can do in that
is ask your users what they want
remember when the iPhone came out
everybody wanted a flip-down hardware
keyboard will wanted styluses we wanted
memory card plugins and all this kind of
stuff and then Apple came out with just
this flat touchscreen thing and we all
kind of went oh that's nice
so really customers don't really know
what they want but they do know what
they don't want and when they see
something they like they they like it so
the only real way of doing software well
these days is just iterating quickly
right don't sit in your ivory tower for
a year writing requirements
documentation and then spend a year
writing something and then six months
delivering it get something out the door
as quickly as you can in front of users
and get them playing with it trying it
with it using it increasing now to
develop software well we need to do
experiment based and they be testing and
get feedback right so the best way we've
figured out to write software you live a
real business value is through these
various continuous improvement cycles so
continuous integration I think a lot of
people been doing confusing integration
for a while how many people use
continuous integration today okay that's
tough that's a that's a good number
that's half the room say so that's one
way of continuously integrating a code
to check we haven't broken it yet I will
keep building nd it's still working it
still working that's good that's happy
then we can move on to continuous
delivery of continuously moving that
software from development to testing to
staging to production then less
continuous operations and then
continuous Management and feedback so we
have lots of these virtuous feedback
cycles where we're continuously doing
everything more and more more and we're
getting continuous feedback so we're
getting better all the time right so
this is a way that we can all keep
iterating quickly and get better at
developing testings releasing staging
and ultimately running and managing our
software now the ideal way of doing this
kind of continuous improvement these
days that we've figured out is
continuous delivery of containerized
micro services so you've probably heard
quite a lot about docker already so
micro services
time so you've probably heard
microservices more than once this week
for me really micro-services is just a
technique to go fast right
so unless two real parts to it one of
its technical so pretty much every
system I've ever seen like if you ask
someone if you join a new team and you
say what's the system they'll draw on a
white board lots of rectangles and
they'll land them all with with crazy
interesting sometimes comical names and
they'll say this is the system is all
these boxes and if you're building a
monolith you release everything on the
board together so you all agree when
you're gonna release and you all check
everything's ok and then you all release
everything together relates depending on
the size of your monolith it can take
possibly weeks or months to do our
release right it gets complicated you
often have large teams there's lots of
discussions and meetings and planning
and it's complicated right the
micro-services version of that is every
rectangle is its own release stream so
each rectangle gets released
independently of all the others which
means it can go faster because you're
not waiting you're not saying well I'll
release when that other teams don't his
bit and when that thing's ready I'll
release with that thing each rectangle
releases independently so each rectangle
can move with its own pace some of these
rectangles these micro services might be
releasing every hour other ones might do
once a year because it kind of works and
you just have to fix it down again so it
lets you move at the right rate for the
different parts of the system unless you
iterate really really quickly so part of
micro services for me is just you
release independently which adds
complexity yes it makes everything much
more complicated but it makes everything
much quicker right if you're doing a
monolith the mythical man-month
said years ago the more people you add
to a team the slower it gets so if
you're working on one massive monolith
and you just add more more people you
have more more meetings it takes longer
to decide anything it takes longer to
test anything so you gradually get
slower and slower and slower where
micro-services goes you generally get
faster as you add people because you
tend to make more micro services in
parallel and over time you get better
and better at doing the releases because
you're doing all the time so part of it
is decomposing your your system into
micro services and releasing them
separately the other part is social
and lots of companies have silos so you
have a testing silo and an ANA let
business analyst silo and a developer
silo and Libyan operation silo and
everybody does their little bit and then
first stuff over the wall for the poor
person next door who does the next bit
which is one approach okay and where's
the micro service approach is rather
than having vertical silos have
horizontal teams for each micro service
have one team that does design testing
development and runtime operations right
so I've been an open source for quite a
while and I found that just working in
open source developers tend to put a
little bit of extra care into their code
right when you occurred is going to be
on the public internet forever that your
future employee employer could google
your code you tend to kind of take out
the swear words and the kind of really
crappy bits or most people do I probably
don't what for but other people do right
and and if you're the person who's
writing some code and you're the person
who's running it in production you tend
to make things a little bit easier to
manage right you tend to make the
software a little bit easier to reason
about easy to stop and start you tend to
put more metrics in there you tend to
put better logs so when it's in
production you understand it because
you're writing the code and you're
running it you tend to think about
production first right if you want to go
fast we have to be thinking of
production first and everything else
follows from that rather than I packing
on my laptop I don't really care about
production and checking it over wall and
then it's someone else's problem right
we should be developing for production
all the time not using Windows or a Mac
to run your stuff you should be running
everything in a docker container in a
production like environment right so
that's really micro services these two
things split things into pieces and then
HT and then have a team aligned around
those pieces and then those teams can
just release independently right for me
micro service is a little bit like
concurrent programming right we're
taking out all the mutexes everywhere so
we've got lots of threads that are
non-blocking each team and each micro
services of thread that can just go as
quick or fast as it likes and release
whenever it wants there's no
coordination or meetings or scheduling
right you can go as quick as you like so
this is how we should be delivering
software these days if you want to go
fast if you will
to be competitive if you want to deliver
business value micro-services looks like
the best approach so that's kind of cool
but we now have some issues right if
you're just working on the model if
life's kind of easy right you've got one
git repository you release every year
maybe twice a year it maybe takes you a
few days to do it they doesn't really
matter and you maybe use shell scripts
and VI and all sorts of stuff to do when
they cease oh that's ok too but as soon
as you move from one monolith to say ten
micro-services a hundred micro-services
maybe a thousand microservices and in
each one's releasing every hour that's a
lot of releases that's a lot of projects
to start up that's a lot of bills to do
that's a lot of stages to do and you
can't really even start to go down the
Microsoft Microsoft 14 slipped down the
microservices world unless you've
automated everything right it's almost
like you should really automate it first
before you start doing all this
otherwise you spend all of your time
just doing releases and really the point
this is to go fast so to figure out your
automation first before you have this
micro service explosion and one thing we
found so i-i've I work on a team at
Retta
and we went started off with a monolith
and we've gradually moved towards
microservices and we've just had an
explosion of micro services now we have
tons of kit repositories and tons of
releases and this it's extremely painful
if you don't do your automation up front
a lot of companies like the Netflix's of
this world there lots of other companies
like gilt and so forth they have nearly
a thousand micro services right and
they're growing all the time so the more
you invest upfront on your micro service
journey with automation the better
because it will just save you huge
amounts of time and effort later so we
need to optimize all the things what we
really want is a simple open source
developer platform that developer teams
can just spin up micro services whenever
they want using whatever their
technology flavors that they wish to use
and the automata leaders system testing
load testing so testing staging
production monitoring metrics and
feedback right we just want the thing
that just does all of this and then we
can focus on the programming part and
actually making the software and all
this other mechanics can just kind of
happen right so I'd like to kind of show
you one of those so
I've been working on this open source
project at Red Hat cold fabricate for a
while
so fabricate as in to make so fabricate
micro-services but it's with an 8
because it's a shorter URL basically
fabricates dot IO and especially a whole
bunch of open source software that tries
to help developers be productive on the
modern technologies that we tend to use
today so what does it do it really has
wizards to help you create new
micro-services projects whether that's
Java say with spring booth with Tomcat
with wild fly with Wi-Fi swarm with
vertex or with nodejs or with golang or
with Swift or with PHP even or whatever
you want to use by pretty much every
language is supported we have automatic
ways of building your software into
docker images which are all versions and
that immutable docker image then moves
through testing staging and production
so you automate the migration of the
code through the pipeline so you don't
manually changing things to go from
testing to production it just kind of
happens automatically right then we have
a whole bunch of stuff that does rolling
upgrades right once you're in production
you haven't you need a new version and
you want to do a rolling upgrade of the
old version sorry the new version to
replace the old version and possibly
rollback if things are quite bad so you
can roll forward and rollback whenever
you wish
there's also whole set of management
stuff you need to do like centralized
logging and management that we'll talk
about later for metrics or logging
because otherwise you've really
something to production if you've no
idea what it's doing
you probably shouldn't go to production
right you need to know what's it what
are the logs for every container one of
the metrics every container what's
happening are you getting more errors
now than the previous version you need
this feedback so you can make informed
decisions right as soon as we got Alex
micro-services journey it's fun and it's
awesome and you tend to go really fast
but it can be kind of tricky to
understand what's going on right so we
need tooling and software to help us
understand what's happening and get
feedback so we can react right we can we
can react if there's an issue or a bug
or whatever
finally the platform lots of different
customers have different legal
requirements or technology requirements
of whether they can they use the public
cloud are using your own data centers
are using a partner's data center and so
forth so
we can't just assume it's just Amazon or
anything so we need a platform that runs
on your laptop
it runs on Google or Amazon or Azure or
digital ocean or it can run on premise
on any hardware you have so that's
pretty key
so everything in fabric is completely
open-source you can download it and play
around with it right now I'm not going
to tell you how to download it right now
until after my demo in case the Wi-Fi it
goes screwed but now I'm going to
demonstrate fabricate for you I think
it's easy for me just to show you it
then you can see what it does and then
afterwards I'll walk through how it does
what it does and what are some of the
other source technologies behind the
covers that you can kind of play with
and look at so let's fabricate some
microservices so I've already installed
fabricate I'll show you how to do that
later this is all running just on my
laptop so everything is on my laptop so
it's not the speediest thing in the
world
normally I would suggest you have a
couple of computers that you run this on
that's not your laptop you don't want
somebody to close their laptop lid and
then all the bills stop and you know
production ends so you probably want a
real cluster in the real world but for
now I'll using a laptop so this is the
this is the the front the homepage of
the fabricated web console it's
angularjs it's talking it's using
typescript and angularjs to talk to the
Cuban eighties REST API which I'll talk
about later first thing I'm going to
show you is just the runtime in my in my
teams each team have have their own
environments and I'm looking at the
runtime in the development environment
and this is where all the development
tools that live is a little bit bigger
so these are the out-of-the-box
development tools and runtime tools that
can be fabricated so fabrica is a
one-click install and all this stuff
just works you don't have to configure
it out of the box we use Jenkins you see
Jenkins there we've got one container of
Jenkins running
we have Nexus so Jenkins is for CI and
CD Nexus is for an artifact repository
so it's where all your releases go so
when you do a release your jars and Wars
and poms and all those kind of things
will be in Nexus we also use Nexus as a
proxy if you're running this in the
public cloud you don't really want to be
downloading the internet with maven
bells every build you just want to
download the internet once and keep it
on your cloud so we use Nexus as this
proxy that stores all the myth
facts over time so you never download it
twice we also use persistent disk in
bills
so once you've downloaded into your
build you don't download it again to tap
a lot of Nexus if you're an open source
company you probably put everything
public and on github which is cool if
you're an enterprise though you might
not be able to put everything on github
public so you probably want an
on-premise git hosting provider there's
a bunch of these you might want to use
github Enterprise you might use
Atlassian slack we bundle open source
implementations of git hosting out of
the box for you so at least you've got a
git repository to start with you can
work with any keep repository though you
like so we ship with this thing called
Gog's
you see the thing above Jenkins GOG is a
small girl line based git server that's
kind of like github but it's open source
there's also this thing fabricate Forge
which I'll show you later that's the
thing that's based on a tool called
JBoss Forge which is a tool for Wizards
to help developers do things and we'll
see that in action in a moment so that's
the that's the guts of what I'm running
right now let me look at the team
dashboard I created a little malarkey
microservice just in case my demo went
pear but I'm going to create a real
project now and hopefully that will work
so I'm going to click the Create app
you've now got two choices you might
already have created the Java app and
there's a git repository somewhere that
you want to import but I'm gonna assume
we're where all our team as micro
service teams go to pizzas wouldn't kind
of stretch this far so but just imagine
we're all the micro service team and
we're all about to write a micro service
together so we kind of go okay well
we're a team we hit the create button
and now we get a little wizard up of all
these different kind of wizardy things
we can make so if every views spring
dots start not springing yo we've got
that kind of wizard for spring apps
where you can choose all the modules you
want to use we've got a similar thing
for a fly swarm we've got a whole bunch
of archetypes for things like Apache
camel and cxf and all the Java EE stuff
in this case I'm just going to create a
vanilla micro service which is really
just a standalone spring boot women
these web MVC micro service I'm going to
create that one and I'm going to call it
they have box awesome they look cool
they looks cool
it looks cool there's no button name not
too long okay and we click the Create
button what these demons of the covers
now is is going to generate the source
code for whatever wizard we picked so if
it's a maven archetype it would generate
the archetype onto disk substitute in
the organization ID in the version and
all that kind of malarkey then it's
going to create a git repository it's
going to check the code into the git
repository and push the git repository
into the git repository into the git
hosting server now it's giving us a list
of pipelines to choose from now we'll
talk about pipelines a little bit later
but these are a thing that's part of
Jenkins - there helps you define your
continuous delivery pipeline so think of
it as a bit like workflow for Duke for
CD it's a thing that has all these steps
that you build your code you push you
build your code you generate your doctor
image you push the image to a docker
registry you run a system test in the
testing environment you stage it to the
staging environment there's a human
approval step and then we go to
production so pipeline defines all of
these steps you can have sequential
pipelines you have parallel parts you
could wait for things you can do fork
and joy and all that kind of stuff now
not that many people right now know how
to write these things so we've got this
library of pre-built Jenkins files or
Jenkins pipelines that let you do this
by just clicking a button so I'm going
to click a button I'm going to pick this
pipeline that use these testing staging
and production environments with human
approval to production so I'm going to
click that and click Next
right so now we've created the git
repository we've now we've associated
the Jenkins pipeline with the project
and now it's you can see it's kicking
off a build now what we've tried to do
actually Shrunk the screen resolution a
bit of month and what we've tried to do
is unify all of the things you're going
to need to look at into one screen so
we've been using fabricate to fabricate
fabricated for quite a while now and in
the early days we found we're looking at
Jenkins quite a bit and we're looking at
the git repository quite a bit and we're
looking at nexus quite a bit and with
we're looking at all these different
things all the time and then we're
looking in the environments and we found
we had so many tabs open and we kept
flicking a flicking of it and he just
kept getting really confused and so
we've tried to put everything on one
screen so from this one screen you'll
see as the pipeline runs we can see the
pipeline running we can see the
if I scroll down a little bit we can see
the logs flowing by just while that
builds going it will take like maybe one
minute I'll show you the other apps we
have so if we click this little thing in
the top right we have the app switcher
now these are the first three apps
you'll run but over the lifetime of your
journey in micro-services there's lots
of other tools you probably want to use
oh I didn't show you this let me just
show you if you go if you look at the
runtime of your development tools and
you click this Run button there's all
these other micro services that one
click away that you can run you might
want to run get lab graph on LeGarrette
solar cube you will not be you might
want to run chat chat ops with slack or
let's chat there's chaos monkey which is
really really funny that kills your pods
to check that your system recovers
properly we've got a whole raft of
different services and so over time you
can gradually add more more of these
tools to your pipeline into your your
team we charge you more capabilities but
then there's often the console you need
to flick to which is where this little
menu comes in so to start with there's
only a couple of things to look at but
over time there's more and more things
you can play with notice that the
testing environment now has something
really in it so we've what we've done is
we've generate the code we've tagged
everything with version ones they're a
warning get we've built everything
staged it to Nexis generate the docket
image tag the docket image with one zero
one push that into the docker registry
we've now done a system test which we'll
explain later but effectively is using
our Kilian to relay system test in the
testing environment now that's gone
green so it looks like the test should
should pass soon the system test is
asserting that the thing you've built
the kubernetes manifest and the docker
image and all that kind of stuff does it
does it deploy into the testing event
does it work yes he did he's gone green
so now the staging is kicked in and so
now we've done a roll out into staging
if you notice if you're colorblind I
apologize but if you look very closely
it's blue right now and then it goes
green and this is the difference in Cuba
native a container starts but often Java
takes a little while to really kind of
get going so blue is it started it's
running but
it's not ready and when it goes green
it's just gone green so it's now ready
which means it's ready to serve traffic
so it's listening on HTTP and so on and
so forth all of the fabric a tooling
generates a something called a liveness
check and a readiness check in Cuban
eighties a readiness check means is it
ready for traffic in other words should
I include it in the load balancer and it
might be in your app might have to on
startup connect to the database connect
to a message queue or something preload
a whole bunch of data so your cache is
nice and warm and they might take you
know a few minutes before it's ready so
you can plug in your own custom
readiness checks which is really nice so
you don't hammer it with hate to be
traffic until it's kind of warmed up and
so we're now properly warmed up and
everything and we're green and now I can
actually invoke that service so almost
everything on this screen is clickable
so I can navigate around all of these
kinds of things so if I click on that
little little link there it's going to
open the service that's running in the
staging environment and you can see the
wonder of this amazing wrecker service
that says hello world which is pretty
awesome I'm sure we're gonna that's
nothing real business value were already
anyways so but also all of these
different links are clickable so each of
these environments are full logical
clusters we can look inside and play
around with and they're all independent
of each other so if I click on say if I
click on say this button I can look at
the running containers in this
environment so I can see I've got my
malarkey that I ran an hour ago to check
the internet was working and I've got
DevOps cool so DevOps cool is the new
container we just ran and if I click on
this little bun
I can see it's been running for a minute
that's its IP address its image its IP
address is there on the right and if I
click the logs button I can look at the
logs of this container and watch it work
so we can look at all of your
environment so we can dive in and see
what's in there and we can interact with
all the services that they're interact
with the containers and we can scale up
and scale down that's all and so forth
let me just pop back to the micro
service console by the way wait so we
have two views off sometimes a team will
have multiple micro services so this
view is showing me all of the micro
services in my team and then each team
has their own dashboard so if I just
want to look across all the micro
services
my team I can look at this view and I
can see everything that's in testing and
staging production you'll notice there's
nothing in production yet and then if I
click on this view now I'm looking at
just one like a service so if you're
just developing on one like a service
you can zoom in and just look at one
micro service all the bills for what
micro service and all the environments
for what micro service okay and then
from there we can look at the git
commits and the versions of the Docs and
all I can stuff now what we're gonna do
is we're gonna approve this release so
first scroll down here and there's a
button here to approve or proceed with
the pipeline because we're waiting for
human approval and I clicked on that
button then that was kind of okay as a
micro services girl so I'm gonna say
proceed and now it should be deploying
to production as well so they're the
production environment is spun up 1:01
in production and now we've gone into
production now that was quite a lot to
take in there was a lot of things on the
screen there was a lot of things to
think about but what was basically just
done is in a couple of clicks created
all the environments for a team create a
micro service and we've taken a micro
service we've generated a basic system
test which I'll talk about later so at
least we know it runs and it stays up
and it doesn't fail and these liveness
checks and its readiness checks a-ok
which is like a minimal test you should
do more testing ideally but at least we
have a basic test that it can start up
then we've moved it to the staging
environment week where you can have user
acceptors testing or show it to people
and we can play around with it and then
when you're happy you can move it to
production so that was all completely
automated with a couple of clicks which
is pretty cool let me briefly show you
what happened under the covers just so
you kind of believe me and it's not all
smoke and mirrors let's first off look
at the git repository so if I look at
the git repository this is a kind of its
kind of like github so here's the git
repository that was created we can see
there's a pom.xml this is a basic spring
spring spring web MVC application you
can see it created a jenkins file and so
the jenkins file is a is a file that's
used to define your pipeline it's a new
part of Jenkins - and it's basically a
groovy file which is very groovy so see
that been groovy I don't know who wrote
that stuff but it's awesome it's really
awesome so this is a groovy file it's a
groovy DSL for defining
your build pots right so it allows us to
say a pod is a cubed it is time for
group of containers so it allows us to
pick what are all the software tools we
want to use in our pipeline so you might
want to use maven 3 0 3 or 3 3 9 let's
say let's keep it real let's use Neville
3 3 9 let's use a version of selenium
you might want to use a version of
Google Chrome browser for selenium
testing you might want to use whatever
tools you want to use in OGS image and
the solar so forth so you can pick all
of the tools you want to use you can
define the mini jenkins file we can also
do things like mounting persistent
volumes so we can map we can say I want
to persistently store this build
artifact forever because I want to keep
some history between the builds and then
we can define in just this simple groovy
tip syntax we can define stages and
steps and functions for how to do builds
now when you first if you kind of read
this it is kind of readable we're doing
a maven canary release where you're
going to may have an integration test
then we're applying the manifest into
the staging environment then we're
waiting for human approval and then
we're going to apply the prediction then
when we first started this we were our
jenkees file was basically just command
line stuff we just be running maven this
may even that maven deploy maven set
version and all those kind of stuff you
do to do a release in heaven
and over time we found that we had all
these jenkins files that were all kind
of similar so we started to refactor the
jenkins files into reusable functions so
there's this little magic thing at the
top at library the out library lets you
bring in a version of a library that has
the reusable functions and steps inside
so over time you can find that there's
very similar blobs of groovy that you
want to share across your projects but
what we found is pretty much anything
that's maven based the pipeline's are
kind of the same I mean you can
obviously edit the pipeline on the per
project Bocek basis but basically all of
our pipelines are identical to each
other and if something changes he's
normally in the palm it's not in the
Jenkins file so we really like the idea
of having this reusable library
functions that anybody can use in the
jenkins file anywhere and then have a
reusable library of jenkins files as
well so we don't all have to write
groovy I mean groovy is groovy and it's
fun
but it you can go faster by just reusing
it to start with and then over time
tinker with it if you need to so that's
the git repository I'm browsing the
source code and everything let me
actually just do a quick edit to the
code and so again in this single pane of
glass you can as you browse the source
code as well and so we can browse the
source code and we can edit it so you
probably want to use like a real ID like
IntelliJ or or Eclipse so you you might
want you to realize an ID of your
choosing and you might want to do a git
clone if you go back to the git
repository and then look at the home
page and you can do a git clone using
this URLs you can just get clone it like
github cloned into your laptop then
using you know IntelliJ Eclipse and
NetBeans Atem whatever you want to use
and then do a commit back and then that
Walter if you if your commit merges to
master it will then do another release
by default what we're gonna do is we're
just going to edit the source code to
show you what happens when you do an
update so I'm going to edit this and I'm
going to add loads of business value by
saying something else awesome
books malarkey and I'm gonna hit save so
we've made the source code change that's
under the covers doing a git commit so
if I now browse the git repository if I
click there and then click on commits we
should see I've just updated that and if
I view it we'll see I've done this
really awesome coach change which is
fine so we've changed it and because we
automated the creation of the git
repository and the Jenkins build we
automatically added a web hook in the
git repository so whenever you do a push
of a change it triggers a CD pipeline if
it's on the master branch so if I go
back to the DevOps thing and scroll down
you'll see build two has started so now
it's going to go through the whole
pipeline again and it's going to release
one zero to test testing and then one
zero two will then go to staging and
then go to production with human
approval so we can see our entire flow
is created forwards we'd have to think
about it we just click a few buttons and
we're good to go and if you really want
you can dive into the Jenkins pipeline
and do things differently
you could fork I'll check his pipeline
library and write your own pipelines and
do things differently you could fold the
the Jenkins file library and do those
differently if you wish you can have
your own you might find that if you're a
large organization you might want a
group that just look after the Jenkins
stuff for you so you have predefined
pipelines for the canonical way of doing
say and the Java and OGS or whatever
right so it can help you you can help
all of your teams just get going quickly
so they don't all have to learn Jenkins
right they can all just click a few
buttons and and go quickly so while
that's triggering away that's what could
take a moment to let me show you another
couple of details you've seen go examine
20 Jenkins yet so this is Jenkins we're
using Jenkins two and you can see we've
got two bills so this is if you haven't
seen it this is the new Jenkins blue
ocean user interface if all this is
looking like like too gorgeous for you
we can always show you the the keeping
it real traditional familiar familiar
the familiar and lovely Jenkins screen
so this is just normal Jenkins right
this is Jenkins we know and love but
then we've got like the new hipster
Jenkins which is they all color buttons
nice and if you click on this one
although I can see all my place deities
look at that I can see it go through all
the stages and I can see the log it
Scrolls a bit crazily mind you but yes
so you can kind of view it in Jenkins if
you wish and watch the beautiful colors
and watch the errors when you make a
mistake in nice red which is nice so
that's Jenkins it's just vanilla Jenkins
so you can always spin up your jobs in
Jenkins as well one thing about Jenkins
by the way is so Jackie's pipeline is a
whole new thing for Jenkins and the
basic idea is we we should now add
Jenkins files into our projects in the
source code right so in your git
repository for the Jenkins file in there
and then Jenkins knows how to build it
right and that means you've then
versioned your Jenkins build I don't if
this has ever happened to you where
somebody that you not quite sure who
makes a change in a build configuration
then it stops working and you don't know
who changed what when why if it's in
jank if it's in get you know exactly who
changed it so you can flame them but
more importantly you can revert the
change or you can least you know what
changed right so you conversion your
Jenkins files which then makes it much
easier remember
trying to go fast right so one team
might want to change the latest maven
and the latest nodejs
so they're racing really really quickly
something might be editing the junkies
file really really quickly other teams
might want to stay on a really old
crusty Jenkins file and that's fine
because it works so it lets each team go
as quick as they need to go right
because reversion everything in git now
having things in gate is also kind of
interesting because now Jenkins can find
the Jenkins files so there's a couple of
plugins in Jenkins once called the
github organization plug-in which you
can point Jenkins to the github
organization it was forget to enterprise
and github on line and it will iterate
through all the repositories in that
organization and for every repository it
will iterate through every branch of
every branch that has a jenkees file it
spins up your Jenkins jobs so the other
way of importing projects is if you've
already adopted Jenkins and you have
Jenkins files you can just get Jenkins
to import your projects and then they
all appear automatically on the on the
fabricate console
so that's Jenkins one other thing which
is not very interesting or noticed by
the way the testing worked we've got one
zero two now in testing we've staged two
one zero two and we haven't yet approved
to production I'll do that in one moment
I'm just going to show you something
that's not quite as interesting but it's
it's important is Nexus that we've
staged to the staging repository all
these releases so if the looking or
example or I forgot to clear this out
before the demo what was it called dev
ops call you could tell you knew a lot
of demos there so here's one zero one
one zero two so this is everything we
released into Nexus and if I look in one
zero two we've created a jar for the
spring stuff we've got a pom.xml we've
also got this thing this cuba Nettie's
yeah more thing which is basically the
blob of yam all that you can just take
and apply to any kubernetes cluster now
if you're lucky you can use this
pipeline to go straight into production
it might be there sometimes
different people have different rules
about the production environment like
maybe developers can't see it or touch
it or have any involvement in it so it
might be that the jenkees pipeline might
not be allowed to just apply the llamó
file directly in to the production
cubics cluster so you might want to
slightly modify your jenkees file so
instead of actually applying it to the
production environment you take that
yamo file and you maybe check it into
get repository or do a pull request or
email it to the ops people or something
so that then someone else in the ops
team actually does the apply because
they might want to review it or
something but hopefully we can all
automate all of this stuff right we we
want to automate everything right so
that's the Nexus part finally let's
approve this last release let me just
find this approval button my scroll
things got a little bit old a little
screen resolution so I'll click proceed
and if I'm really quick we'll be at
watch the running upgrade happen so you
seemed the production box the ones there
were two starts up then it scales down
the one zero once we've done the rolling
upgrade in production and I'll just wait
for the the green to happen and then
I'll show you running in production so
in a few clicks we've created project
it's create the git repository it's
create the source code it's creating the
web hook
it's create the jenkees pipeline it's
create all the environments for you for
your team and for your micro service
it's it's done a release we've actually
done two releases now okay we maybe need
to work on our business value but at
least we've done two releases so we've
got two iterations down and then we
could maybe do a few more and get better
and then let's see
awesome DevOps malarkey so we're making
progress right we're getting faster so
that's the basic demo I think that's
about all I was going to show it to
start with let me talk about really what
happens under the covers so first of all
how do you do this right so now my demos
worked you can now hammer the conference
Wi-Fi and download the internet so if
you want to get started go to this
website you can do this right now if you
want I'm sure the other presenters will
hate me for saying this I've got to
fabricate the i/o for Big Eight IO and
if you scroll down a little bit there's
these two green buttons the install
locally button if you click on that one
I've got this robot thing let me go to
one I downloaded earlier because I can't
be bothered to do a robot and if i zoom
up a bit there's a link here to download
the binary called go fabricate it's a
little binary there's a binary for
Windows Linux Mac you download the
binary for your platform and type go
fabricate start and that's pretty much
it well that then does is it downloads a
bunch of stuff that it says on that
screen but they download something
called mini cube which is really cool
tool that will download Cuban 80s which
I'll talk about a minute and build a
single node cluster on your laptop it'll
then download something called cube
cuddle a spell cube CTL but the nice way
of saying it is cute cuddle cuz that's
friendly so cute cuddle is the
command-line tool for interacting with
kubernetes and then it will install
fabricate on top of it so if you type go
fabricate start you might need to go get
a coffee because it will download a
couple of docker images but it will
start up reasonably quickly and then
you'll be able to do everything I just
did right now you'll be able to do on
your laptop right if you want to do it
it's maybe easier just to start on a
laptop really and then play around with
it get a feel for it and see if you want
to play around with it for real then
wait for mother do for real then you're
gonna need a real communities cluster
that's more than just a laptop and then
you probably like you might start with
just installing it on the cloud maybe
Amazon maybe Google maybe as you maybe
digitalocean if you click on this button
to capture again I cashed it already
there's this that you go to this page
there's a website called stack point
that I of this webpage to kind of tells
you all about it and this little video
as well there's a website called stack
point that lets you type in which cloud
you want pick a couple of VM sizes and
how many VMs you want like Amazon typing
your Amazon credentials and it spins up
the Kuban it is cluster for you in a
couple of seconds and then it will put
fabric here on top of it it's got a
lovely fabric hit button now bless them
so in a couple of clicks you can have a
real production grade keeping the t's
cluster running on Amazon or Google or
Azure we've fabricate or pre-installed
for you so it's really really quick and
easy to get going so it's easy to get
started it honestly is if you have any
issues at all we've got a feedback
button on the website you can get
feedback either by raising an issue
chatting on slack you've got to do the
slack thing we have to request an invite
and then we have to say yes come in but
that's the slack thing if anybody can
figure out how to avoid that please tell
me and or you can use IRC if you want to
keep it real like a proper geek so so
that's how to get cited this really
really quick it's really easy there is
no configuration as soon as you do go
for abacus that it will install Jenkins
Nexus the git repository the console and
everything kind of works all the
secrets away it up I could cry fight if
I thought about how much of my life I've
wasted by configuring just Jenkins and
Nexus to talk to each other and then
something happens in the in the Jenkins
server and then after start again and
then somebody craps on the Maven
settings file and you're like everything
just works you'd have to touch it you
don't have to mess with it everything is
beautifully predefined right so it's
really really awesome so please try it
have a play with it see what you think
and this will talk a little bit now
about what is fabricate what's under the
covers I've kind of given a few hints
already the main three things that
fabricate a docker kubernetes and
Jenkins so very very briefly docker is
the way we should all be packaging our
software now why should we be doing that
because it's an easy way of automating
the release of software right VMs are
big and heavy and expensive because a VM
has a complete operating system inside
it as well a docker container is just
your software just that in an immutable
image that you can move between
environments and you can run multiple
instances and never actually showed you
that let me just show you that by the
way if we go to the production
environment and we're looking at our
deployment so here's our deployment of
the DevOps cool we can just click the
scale button and run three and then now
it's going to run three containers of
that app notice they start blue so we've
got two blues and one green and fairly
soon they're all going to go green and
we'll have three greens and then the low
bounce that will then go across all
three of them right so it's really easy
to scale up and down any of your micro
services you really want each micro
service to be scaled independently
because they're all going to use
different IO and CPU and whatever so
micro services will be hammered with a
gazillion HTTP requests some micro
services might get one request a day so
you might not need many of them right so
you won't be able to efficiently scale
your micro services if I click on this
button I can see all the individual
containers that are running and like to
see all of their logs and so forth right
so you you could easily scale up and
down all right let me go back slides
there yeah okay so we use docker to
package things up into an immutable
image you can just run this is the
command line in docker to run something
if you have a docker image you just type
docker run name of the image and
just runs right so running docker
locally on your laptop is okay but what
you really want to do is run your
containers in the cluster so you've got
a bunch of hardware you can be scaling
up or down your cluster on say Amazon or
plugging new machines in as you go as
you find new hardware your hard way
might be growing or shrinking and you
want something that runs these
containers across all of your hardware
and that's what this thing called cuban
ities comes in how many people were in
the Cuban eighties talk that really did
from Google
earlier this week okay awesome so you
probably all know all about this now I
don't need to say too much but there's
quite a lot hands that didn't go up so
I'll say a few words firstly go watch
Ray's videos so whenever you get home
and you've slept a bit look at the
videos online from dev Fox and watch
Ray's Google ray from Google's Cuba
Nettie's talks it did about two of them
and they really really good negocio in
detail what communities is basically
kubernetes is it came from Google it's
based on all the decade of experience of
running containers at scale across lots
and lots of hardware and Kuban 80s is
really a thing it's a little bit of
software you install on every machine
and it turns the machines into a cluster
like a logical cloud or a mainframe if
you like you could think of it as a
distributed operating system of sorts it
turns your hardware into just a resource
you can just run containers on it so
this is the version of that dock of
command-line cube cube Caudill run you
give it a name of the image and you give
it how many replicas to run and if you
say replicas five it makes sure there's
always five instances of your micro
services running forever if one of your
services crushes or condoms it will spin
another container up if the machine that
was running one of your containers dies
it will spin another container up
somewhere else so it makes sure at all
times it's got this kind of feedback
loop where it's watching what's running
on your hardware and they make sure
there's always five running at all times
which is really really nice
so cubanía has really helps us run
stuff and it does all the load balancing
and all those kind of things there's a
little diagram we mentioned about
Jenkins
so Jenkins we now use the Jenkins file
to define your continuous delivery
pipeline it's a nice groovy script it's
not as simple and you can use the groovy
DSL and then you can use functions and
stuff to extend it and refactoring
and make it simpler and then we had so
we have two libraries one is a library
of Jenkins files and one is the library
of pipeline functions and steps and you
can use both of them together or you
could just use the pipeline steps if you
wish or you could fork it and just play
around by yourselves and do your own
things but we'd like it if you we love
contributions so if you write a new
function that's cool please just submit
a pull request and pull it back so we
can try and share this stuff across
teams and companies so that's the main
things in fabricated we stand on the
shoulders of lots of other open-source
giants so I'll just mention a few of
them I can't really mentioned everything
you fabricate because there's a whole
range of different tools and
technologies that you can then slowly go
into so that with Jenkins and Nexus and
the get hosting and then gradually
there's a lot of other things you can
kind of play around with the first thing
to play around with which I didn't run
on my laptop because I don't have that
much RAM is centralized logging and
centralized metrics so you have to have
centralized logging metrics in
production I'd even recommend it in
staging as well really I mean why not in
every environment rarely disk is pretty
cheap these days so for centralized
logging we use the tool called
elasticsearch which is open source and
there's a kind of a scalable database
ething for tricking blobs of yeah mole
into it or JSON into it and it will then
index them so you can query them right
so every log event if you think
java.util log SL foj log4j
is that all the three yeah all those
things all that java stuff that log
stuff and we can capture all of those
log statements we can annotate them with
what's the environment you're in what's
the team you're in what's the
application you're in what's the version
you're running we can annotate those
logs with more jess and stuff and
trickle into elasticsearch and then we
can search and sort it and stuff so you
can say show me all of the logs in
production in the last ten minutes in my
team or in my micro service or in this
one part of my micro service this one
container so unless you slice and dice
and see what's going on which is really
really nice so elastic search is the
backend that stores the the log events
the thing that collects the log events
is something called fluent D it's a
small little binary that we run on every
machine in the cluster kubernetes has
something called a demon
set and a demon set let's you say I want
to run something on every machine which
is you don't normally do this kind of
stuff but for management is perfect you
can kind of say I want this management
demon fluently through an every machine
in your cluster and then fluently then
just looks at all of the docker
containers running on that machine
captures all of their logs and streams
them all into elasticsearch so every
container you run on kubernetes all the
logs are captured and it's not just that
lava Java logs it's any docker image
look so your MongoDB your Cassandra like
Cassandra's Java MongoDB your Eiffel
randomness RabbitMQ memcache the DNS
hedgy proxied like any docker container
you run in cute including kubernetes
itself all of the logs are captured and
put in elasticsearch which is really
really awesome
then you need a front-end to clear all
this right there's a REST API but
there's a lovely user interface called
Cubana again everything in this
presentation is open-source and you can
just use in fabricate cabanas a html5
web app that talks to elasticsearch that
lets you do charting and graphs and
explore data and browse around and find
things on the metrics side metrics are a
little bit different their logging is
all around blogs of key value pairs that
get stored in an elastic search for
searching metrics are all about having a
time series of a numeric value right so
like the CPU of container seven over the
last week goes up and down over time so
metrics is all about capturing that
chart of ranges of values for CPU load
disk i/o memory whatever there's various
tools under the covers but the main one
is something called prometheus
and Prometheus captures all of the
metrics from every docker container then
fabricate also then exposes all of the
jmx metrics in every JVM so any mbeans
that are in your spring boot app or
waffle ice warm up or whatever all the
metrics of all the mbeans get captured
as well so we have a store of every
metric over time and then there's a tool
called a father that lets you view them
and chart them and slice and dice them
and so forth so this is a quick example
of a chart this is a Capanna dashboard
that shows you at the glance
top row is all of them all of the
commits on all the different
micro-services the next one is all the
builds the next one is all the actual
rollouts our deployments and the last
one these various different doughnuts of
things like logging and errors and so
forth I really got a time so I'll speed
up a little bit this is a graph on the
dashboard again it's a simple
out-of-the-box one and you can define
these - processor whatever you want we
can do things like we can compare
different technologies of micro service
and see micro service war on is really
massive and using loads of RAM and CPU
and micro services - is really tiny and
small maybe we should use that
technology and not this one so it lets
you help understand the relative costs
of your micro services so you could
iterate to reduce cost if some of your
micro services are quite expensive
particularly when you start looking at
things like databases or streaming or
messaging or storage different options
you could take have different financial
implications so the metrics help you
figure out the financial stuff you can
also create your own dashboards based on
whatever your key performance indicators
are like what are the metrics that
really matter to your business like if
you're an online e-tailer how many
orders per second am i taking right so
you want a dashboard that just got what
is my orders per second over time so you
can see how is your business actually
functioning right we have all the tiny
little metrics for like CPU and whatnot
and we can aggregate them but really
what you want to do is start building
dashboards that really tell you really
how is your system performing for your
customers and grow farther and
prometheus can really help on that
so that's log into metrics and again you
just run this in the fabricate console
if you have a slightly bigger box than
mine if you go onto the runtime if you
want logging and metrics you just click
run and there's a button called MIT
management let me scroll down there we
go we just click management we go run
I'm not gonna run it because my book
quite cope with it you do click run and
he will run the app and now you've got
logging and metrics enabled on your
cluster right it's really really simple
so that's log into metrics or the mind
you I would recommend highly always we
run logging a metrics all the time you
just you probably don't want to bother
on your laptop because you it might not
cope and another thing that's really
interesting when you start doing this
micro services
is each team is then focused on one
micro service and you call out other
services without really knowing much
about them because you're very much
focused on your micro service right
which is one of the the good things
about micro service each team is
specialized and looking at one thing and
knowing everything about this one micro
service which is good the downsides is
you're calling all these other micro
services that is changing all the time
and you have no clue what to do so what
often happens is you have timing issues
where it used to be kind of fast and now
when I call this thing it's suddenly
gone really slow why and this took all
Zipkin based on the opens Akins standard
that lets you add little breadcrumbs
into all of the network requests so they
can trace and visualize what service
implications have been made by your
micro service so you can get these kind
of call graphs of what micro services
are invoked and most importantly why is
that how long do those requests tics you
can see where's the hot spots so it's a
little bit like in the old days when we
would all obsessively performance
optimized your Java code you would find
what is the function that's taking all
the time
Sipkins kind of like that but for a
networked approach rather than for a
single process that's it kin and by the
way we have a one-click install of the
Zipkin console and Lisak in runtime so
if you want to enable Zipkin you just
run it as another micro service inside
the fabricator dashboard and it just
kind of works you do have to add the
zipping library to your java code though
circuit breakers is another one that
another common and popular thing circuit
breakers in general is a way if your
micro service is invoking something else
and that other thing could be slow or
possibly even not there you might not
want to fail you're like a web request
might be coming in from a from a user
and you're invoking some other service
to help return something to the user you
might not want to hang forever because
the user will think your websites
not so good so you might want to say
okay I'll wait two seconds for a reply
and then I'll timeout and now do I'll
use some default fallback data so if you
want to render say and
purchase recommendations if the
recommendation engine is down you can
always have a fallback set of
recommendations that you return as the
fallback
so circuit breakers like you have like a
fallback option if your service is down
and let and set a timeout when something
is down the this always confuses me but
the circuit breaker opens which means
it's not actually going to the backing
system it's just returning the default
then over time it retries and retries
and eventually closes again so you're
back to using the backing system so if
one of your systems has a problem you
don't keep hammering it constantly with
requests you just leave it alone for a
while and then now again ping it and see
if it comes back because usually when
there's a failure the worst thing you
can do with the system that's failing is
give it loads of load you can't want to
give it a little bit of a break and then
go back slowly history has a lovely
dashboard which again is a one-click
thing to run it inside fabric here and
it just boots up when it appears on your
drop-down menu and the history dashboard
views all of the states of all the
circuit breakers in all of your apps
which is really nice we have a historic
support in vertex in apache camel and
spring boot and in world fly swarm so it
doesn't really matter which technology
choice you go with they pretty much all
got historic support in the Box now and
then all of those histories metrics are
exposed into the history dashboard which
is kind of cool so that's history
chat ops chat ops is increasingly a very
common way of microservices teams
working together I think lots of us all
are increasingly using chat to work
together now the ideal thing is if
you're a developer you kind of could do
with a your own office with the door
right because then you don't get
interrupted all the time or you'd have
to put your noise-cancelling headphones
on and ignore everybody but if not so
often people might be separate in
separate rooms or people might have all
the headphones on so they can hear
anything
so chat is a really nice way of
communicating whether you're in the same
room different countries different
offices whatever what's interesting with
micro-services is because everything's
changing so much it's kind of good
practice to have a room her team and
every time there's a new micro service
created for that team every time there's
new release every time something goes
bad with a release build every time an
approval is required you can use the
chat room and we've got various chat
BOTS
that work we slack IRC jabber HipChat
probably a couple of others that have
forgotten let's chat using something
called Hugh bot that comes from github
so we basically let you use whatever
chat engine you wish and then they
basically fabricate can talk to you and
you can talk to it you can then trigger
builds via chat and you can do approvals
of promotions through chat which is kind
of nice so chat ops kind of fun plus you
get motivational squirrels I mean and
that one and that can't be a bad thing
culling really how do you develop I'm
getting short on time so I'm just gonna
briefly described so I've shown you
fabricate and how it will help you do
continuous delivery spinner projects do
the end-to-end thing operate things so
we've seen the kind of big picture how
do you do this stuff before you commit
right how do you like hack code locally
and then commit so the first thing is if
you're using maven we have a bunch of
little tools that will help you take any
mavin project you have right now and
move them into Cuban eighties and into
fabricate so the first command line you
see on this slide by the way the last
slide of this has a link to these slides
so you can just download these on the
phone or browser shortly the first line
of this is a little maven plug-in which
will add the maven plug-in into your
palm or you can copy and paste the pop
of XML whichever you prefer
once you've enabled the fabricate maven
plug-in in your project it's a small
little bit of XML it adds you can then
use the fabricate goals on your project
to do various things now if you haven't
run go fabricate start before you can
type the second line and that will
basically download your fabricate for
you and do go fabricate start so that
will create you a cluster that you can
play with on your laptop if you've
already created a cluster you don't need
that step but that's just there if you
want to do everything through maven then
the third option that runs that compiles
and runs your application let me see if
I can even demo that I might not have
enough time but I might try if I can
remember which which shell I had open
let's try this one yeah okay that's
quite a big shell okay let's do that
so I'm in a project here if I quickly
look at the project will say I have a
pom.xml this is just a off-the-shelf
spring XML web MVC example and if I make
this a bit bigger and scroll this is the
stuff that the Mifflin fabricate plug-in
added so it's just a simple
straightforward 11 plug-in you'll see
it's got an execution goal
so he's adding resource and build as
part of the maven lifecycle and if I
take maven fabricate run this is going
to take a couple of moments but what
this is going to do is it's going to
compile the code make the jar
run the unit tests it's going to
generate the docker image it's gonna
push the image into the kubernetes
cluster it's going to generate the cubed
ities manifest that defines what image
to run what environment variables what
the what the service is which open well
later what's the what's the liveness
probe what's the redness probe all that
kind of stuff it's then going to run it
and he's actually running now you see
it's running there so that's a normal
spring application running now the
beautiful thing about this and the thing
I really like is if you just showed this
to a developer who knows nothing about
nothing about docker nothing about Cuban
ease the developer thinks this is
running on their Mac or they windows box
this is actually really running in a
container inside kubernetes what the
maven tooling is doing is just tailing
the log of the thing that's running in
the docker container so what I just
typed there Mifflin fabricate run this
is running that appliance by application
in a container inside kubernetes well
we've tried to do is make you burn a
tease a look and feel like an app server
so if every views like Tomcat or jetty
or wild fly or spring boot you type
maven something colon run right and it
runs the thing is that normally runs on
your laptop which is the worst place to
run it you want to run it in a
production like environment so you want
to run it in a docker container inside
kubernetes okay what's also kind of cool
is if you control see it stops but he
stops by scaling down the thing that's
really in cuban it is because there's
not really a process running on your mac
user content in cuba notes which is
really really really cool okay my times
up
so I'm going to quickly fast forward to
the last slide which is a Muslim problem
there's where the slides are click that
slide link and all the slides there's a
couple the bonus slides I think we get
to that you
see unless they fabricate the AIA
webpage which is how you download fabric
here and get started so basically we all
need to go faster and download fabric it
is the best where we figured out so far
of going fast try it out see what you
think and please give us feedback
because with feedback we can get better
and we can make it better and pull
requests even more awesome but just any
feedback at all these good so thank you
for coming and listening and enjoy the
rest of the conference</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>