<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>10 Kotlin Tricks in 10 ish minutes by Jake Wharton | Coder Coacher - Coaching Coders</title><meta content="10 Kotlin Tricks in 10 ish minutes by Jake Wharton - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>10 Kotlin Tricks in 10 ish minutes by Jake Wharton</b></h2><h5 class="post__date">2017-04-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0sPzDwS55wM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay a little bit late alright so this
is a talk about ten interesting things
in Kotlin that are a little bit
lesser-known it's on an intro to Kotlin
so you have to have seen a little bit
already although I will go through
really quickly some some of the common
features for those in the audience that
don't really know the language so why
would you want to use a language like
Colin the first thing null ability is
pushed into the type system so type to
know whether or not they can store null
or not in this case the top one is a
string which cannot be null and the
bottom one is a string which is nullable
it has type inference so a lot of times
you don't even have to declare the type
so this string is obviously not knowable
therefore you don't it's redundant to
specify it you can just leave it off if
you're interacting with the Java Interop
story is really strong if you're
interacting with Java where you have
these getters and setters Kotlin
actually just exposes those as
properties which you can both read and
write to the language has string
interpolation so you don't need to do
bunch of plus signs and dealing with
building strength yourself you can kind
of just toss the variables in much more
readable way if you're only accessing a
variable directly it's even shorter it's
awesome types are local variables and
fields know whether or not they're
mutable as well as nullable so in this
case I have a user which is a valve
which means it's right you can only
write the value once and then it's
read-only that's not to say that the
user object itself is immutable just
that you can't set the user local more
than once and then if I want to do that
not only do I have to declare var but
our IDE gives us a visual indicator as
to whether something is can be written
once or written multiple times extension
functions which are basically syntactic
sugar around static methods so I can
have this super useful is Tuesday method
to the date class and then if I have any
date I can call it as if it was a method
on date it's got lambdas and it also can
infer lambdas from
Java interfaces just like Java does so
execute ticks are honorable and Kotlin I
just have to use lambda higher-order
functions so this is a function that is
an extension function which accepts
lambda you can see that in the signature
of the argument it takes in a function
which itself takes a T and then returns
a boolean the language also has
something cool called inline functions
where the body of this function will be
inlined anywhere that you call it and
the reason this is also super useful and
something like Android is that normally
this lambda would have to allocate an
anonymous class but because the function
body is inlined
you actually can get rid of that
anonymous class altogether so very low
overhead I talked about properties
earlier so you can define classes with
properties you don't need to actually
define a feel together in a setter
there's a super easy shorthand for that
plus this data modifier on the class
gives you equal - code into string for
free there's many many things that make
Kotlin a appealing language and those
are readily available and easy to find
on the website but what this talk is
about is ten tricks
hopefully in the next ten minutes that
are a little lesser-known a little more
interesting just kind of show you the
power and thoughtfulness of the language
all right these are going to be these
are going to go by quickly so explosive
placeholders a lot of times when you're
implementing new classes new methods
whatever and ID's doing this for you
maybe it'll put in a comment for to do
this is fine if you start using flow
control with branches your IDE will
actually warn you that like hey you're
not doing anything with this else you
should eliminate it but really what
you're saying to that ie with the to do
comment is that I intend to use this in
the future
there's a lot more problematic when you
actually have a function that has to
return a value so this is a callable
instead of a runnable this actually
becomes a compiler because you're not
returning from this branch in Java you
do something like throw an exception
which you can also do in Kotlin and
that's fine but there's a shorthand
syntax in collin which is basically just
a function that will throw an exception
and also will show up in the IDE as if
it were to do comment so you can easily
find it okay if you're writing a
function a lot of times it's good to be
defensive about your inputs to validate
your inputs aggressively in Java we
would do this with you know checking
that our arguments weren't null maybe we
have some requirement on the input that
the separator in this case to a string
joining function has to be more than two
characters if using something like guava
there's two no static factories that are
sorry static helper methods that can do
this for you but if you use them for
things like the argument check
unfortunately what you're doing when
you're creating this exception message
now is you you're creating that string
eagerly where you know 99.9% of time
this check is actually not going to fail
until you never needed to do that work
if we convert this to cholera and we no
longer need the null ability checks
because they're built into the type
system and the compiler omits them
automatically but the standard library
has functions similar to those guava
ones that look a little bit different
because now we're actually passing
lambda this is an inline function so it
doesn't actually allocate you know like
an anonymous class it basically D sugars
into the same thing that you would have
otherwise written so it's you still get
laziness while still getting the you
know easy readability and rideability of
the check there's a bunch of these for
checking null ability ones for a legal
argument ones for a legal state and ones
that throw assertion error as well okay
in Java all pipes derive from object
other than primitives and in Collin
there's a similar concept with a type
called Eddy so you have runnable and in
Kotlin that extends from any there's no
real distinction of primitives in the
language although there is a distinction
in the bytecode and that means that in
the language the integer type also
extends from any what's interesting is
that there's an additional one of these
types that's kind of everywhere and
that's the nothing type and nothing is a
type that actually extends from every
type automatically why do we need this
why is this useful one of the
as useful is in resolving the type of an
expression so here in this expression
I'm getting a potentially null user and
getting its potentially null name
so on the left this type is essentially
a string but it's a nullable string and
then I'm using the Elvis operator which
is basically a shorthand for a null
check to throw an illegal argument
exception if that users no or the name
is no the problem is that I'm assigning
this to a local so what type should a
compiler infer for that local well if
the throw statement was special case
like it is in Java then maybe it could
be maybe you could figure out just to
look at the left but in this case it's
not and so we need this nothing type
because nothing extends every type so it
looks on the left and it says user name
well that's a nullable string and it
looks on the right and then sees throw
throw returns nothing nothing extends
from string so the type ends up being
string so it's a shorthand for this but
there's other uses for this nothing
return type so like I said in Java throw
is special case where you can't write
any statements after throw the compiler
will will produce an error this is also
true in Kotlin but it's not special case
in the compiler and why this is awesome
is because you can write a method that
will you know throw never allows
execution to continue because it never
returns and there are methods that you
could write which also potentially never
return this is like a poor man's
implantation of a server that just spins
on a socket pulling off connections and
the only way it can stop is with an
exception so if you wrote you know a run
server and then wanting to print
something let's say the server is
running this print line statement is
never going to run because the only way
that run server can exit is by throwing
an exception you can tell this you could
tell this to the compiler in the type
system by saying this function returns
nothing and there are no implementations
of nothing so it will never return and
now your code gets the same compile time
benefits of you know throw and return in
that you get warned if you ever try and
write statements after calling this
function because it's impossible for
them to run
let is another function extension
function built-in to the standard
library it's got a bunch of cool uses if
you if you have a vowel which is
nullable and you do a null check inside
that if statement you can then treat
user as being not null but what if you
have a variable instead of a value so
another thread might come in and rewrite
that value in the middle of your if
block so the compiler can't
automatically allow you to assume that
user is not null inside that if block
because it might change that's a really
easy way to work around that where you
can do the null check in the language
and then it only reads the variable once
and then inside the block you can use
that reference as many times as you want
another advantage is that it only does
that read once so when you do when you
have a value when you do a null check
every time you reference the user you're
still you still have to look it up even
if it's you know if it's a field let
only reads that field once or in this
case the nullable user and then it
stores that in a local automatically if
you're writing code that is concurrent a
lot of times of dealing with volatiles
and volatiles are expensive to read and
write let is a super easy way to just
read that value once and then use it
multiple times without having to declare
the local yourself there's other ones of
these so I go to those fast but there's
one called apply is one called run and
in cotton one dot one is one called also
they act similarly but with subtle
differences which you can look up and
another great thing about let is that
you could use it with more than just
variables so if you call a method and
you want to use the return value that
method multiple times one one you have
to manually put that into a named local
variable and then refer to it multiple
times but the let syntax allows you to
use it multiple times without having to
declare that local variable explicitly
column language has multi-line string
literals so we're in Java you would do
something like backslash n or maybe you
try and make it look pretty with
multiple lines you don't have to do that
in Kotlin you can define actual
multi-line string literals
the problem is you know in this case you
have one that's way to the first line is
way to the right and then everything
else is slammed to the left which is
kind of weird so there's these two cool
extension functions one which allows you
to indent them wherever you want and it
will automatically trim that for you so
you can still have a nice readable
string with that indent that'll
automatically be kind of chopped off for
you you have to be careful here because
it will just pick the the leftmost guy
and chop off everything and so in this
case bar and bass would have one and two
spaces in front of it still there's also
a second one called trim margin where
you can put these little tick marks to
define where the margin is and
multi-line strings just like normal
strings you can still do string
interpolation okay half way lazy
declaring things lazily especially
important for Android in this case where
I want to take this string which is not
exactly an expensive computation and
make it lazy the way that you would
normally do this is have a nullable
field and then you read check if it's
null compute the value and then you can
use the value colin has this built in
with the lazy delegate and so the first
time you access this it will
automatically call the function the
function will produce the value an
interesting thing to note and something
that's relatively hidden with lazy is
that this actually uses double check
locking to ensure that the lambda is
only ever called once because you might
be doing something calling out to a
database whatever that you need to
ensure only happens once regardless if
two threads happen to call it at the
same time but a lot of times you don't
need that you have your desktop
applications UI thread you have androids
main thread where you're accessing these
things and you can guarantee that
there's only one thread lazy actually
has a parameter that you can pass to it
to define the locking strategy it so you
can turn this off and avoid the overhead
of the locks if you so choose there's
also another mode called publication
where it will allow multiple threads to
call the lambda but it will only use the
first person that returned okay if you
hate this trace and you hate jmh for
their accuracy you can fall back to
different current time Milly's for a
poor-man's measurement of time and so
normally this is kind of what you would
have to do to find locals and then
perform the diff it Scotland there's
kind of a theme here it's got a built-in
function which allows you to do this in
a block automatically and will take care
of measuring and dipping and then
returning that value you can do these
with nanos if you'd like and it's super
convenient for being able to add up
multiple blocks that occur in you know
the same method or class or whatever
okay
colin has deprecation just like java
except you can't just slap a deprecation
annotation on a method for class it
actually forces you to put in a reason a
string talking about why that function
is deprecated in the IDE it winds up
looking the same you get the
strikethrough to indicate and also a
warning when you're doing a compilation
but there's actually more to deprecation
than this there is a level which gives
you multiple sort of steps of
deprecation so by default you just get
you know that strikethrough in a polite
warning you can set this to error which
will actually produce a compile time
error and will mark it read in the code
forcing your users to make a decision
about what they want to do yeah so if
you try and run a compile this will
actually fail beyond that there's a
level called hidden where the function
is still defined but it's entirely
absent from autocomplete you like it
doesn't even look like the method is
still there in error you could still
resolve a method it's just one let you
compile in hidden it basically acts as
if the method is not there and so you
might be wondering why you would ever
need something like this and the reason
is for binary compatibility you can keep
the method in the class file but prevent
people from using it additionally while
deprecating things it's super useful to
kind of guide the user of how to fix
their code so there's a thing called
replacements where I can say don't use
this method use the built-in common
function and what we'll do is actually
match the argument names to the
arguments in the function definition and
so when I'm in my IDE that we're using
and I slap an alt enter on this
deprecation it'll say hey you should
actually replace it and it will figure
out the
that you're passing and do the
replacement for you it's also super
great when combined with air because you
know you're not presenting that person
from compiling their code so providing
them with a alt-enter
replacement means that they can resolve
it really quickly if you for whatever
reason need to import stuff like you're
using guavas joiner instead of
Scotland's standard library one you can
specify imports as well and then when
the replacement happens you'll get
imports the last guy is punching a racer
in the face hopefully we all know that
you can't implement the same type with
multiple generics and this was also true
in Kotlin we can't really get around
this limitation of the class file format
same is true for methods you can't
define team methods that have the same
that are race to the same thing so in
this case if we're sorting strings and
lists in the byte code it looks like
this and because those are the same
signatures that doesn't work the poor
man's way to work around this would be
to change the function names but that's
that's not fun
Kotlin actually gives us something cool
here where we can change the function
names in the class file but not change
them in the source file
so because it's compiler has superior
generic inference it can figure out
which one of these two were calling and
then in the bytecode it'll actually
replace that with the longer name the
more specific name and if you're calling
from Java you'd see those names as well
okay that was 17 minutes almost 15 but
there's a lot of things like this in the
cotton language that are very pragmatic
very well thought-out
definitely a language built by people
who've experienced the pains of Java and
so if you're interested in this I would
HIGHLY encourage you check out this
website there's a lot of documentation
and resources for learning the language
and that was my 10 tricks
thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>