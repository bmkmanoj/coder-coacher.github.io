<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>100% Stateless with JWT (JSON Web Token) by Hubert Sablonnière | Coder Coacher - Coaching Coders</title><meta content="100% Stateless with JWT (JSON Web Token) by Hubert Sablonnière - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>100% Stateless with JWT (JSON Web Token) by Hubert Sablonnière</b></h2><h5 class="post__date">2016-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/67mezK3NzpU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone my name is Eva Sonia I'm
a developer working on web technologies
for open device and today I want to talk
about JWT the story begins with my first
computer so we got it for Christmas 1994
ok it wasn't my computer for the
computer of the whole family when my fat
it was a Compaq Presario 33 megahertz
processor state of the art when my
father brought it at home with my sister
were like this is crazy
we immediately immediately looked for
games and for sure we found games but
then our cousin's clued us in about
ms-dos games Oh
each time I was you know I was at my
friend's house and he showed me a new
game I was like does it flip does it fit
on a floppy yeah it's 2016 and Amazon
Web page doesn't really fit on three or
four of them so another talk for another
time one of my favorite games was the
lemmings have you ever played the
lemmings now we're talking I mean I have
this friend he saw me recently was like
your pixelated Beatles t-shirt again it
doesn't really know the game is there is
there any Americans in the room yeah
okay so let's cheer you up a bit
bye okay so first must mention I played
this game everywhere on every console
but I never played here so
so this game is pretty simple you have
you have small elk at the Sun because
it's a bit dirty okay so it's fairly
simple you have little guys that fell
off a hatch in the world and you have to
save them to by showing them the exit so
let's okay and they are pretty dumb so
they only walk straight so you must tell
them to dig to climb to build some
stairs etc just like in real life and
let me do first face fast forward okay
so once you get them by the exit and you
save them your yeah where do you have
congrats but you also have a code and
what's pretty great about that code is
that it's pretty ND let me explain when
you play that and you're at the 17 level
and you hear a bear it's in no time well
that come come that code comes pretty
handy because I mean at that time you
had to shut off the computer so this
could hear you just had to enter it on
this screen and you could resume where
you were before okay
meanwhile at Netscape headquarters loom
on to Lee invents the blink tag yeah
don't laugh too loud I used it
you used it everybody used it and Lou
also has very good ideas it's still
we're still in 1994 and Netscape is
working for a client to develop a
virtual basket for e-commerce website
and back then in order to do this to
store state you only add the URL so I
pretty much makes the buying experience
like a vending machine you know one eye
one item at a time so Lou proposed to
apply the existing magic cookies concept
on the web and that's how HTTP cookies
were born so he worked with the John
genin layer and the support arrived
pretty quickly in Netscape the first
official use age wish to know if a
visitor on Netscape comm has already
come to the website so the beep the
behavior hasn't changed much but Joe's
just so we are on the same page let's do
a recap so when a user signing into web
site on his browser
he enters is user password and it
validates the signing form so the bars
are saying the post requests to the
server the server asks the database if
the user exists and the database is like
okay john lennon of course I know him
here's the hashed and salted password
then on the server you have to do your
you know your latest security protocol
to to check the password so we create a
script pbkdf2 whatever if everything is
okay the server can finally send the
response and that's when the browser
stole the key value pair name equals
john the very cookie we're talking about
okay and that's exactly where the
browser is like I'm a browser so what do
I do
I give the cookie back so
when the user navigates on the website
the cookie are sent to the server
automatically the cookie corresponding
to this website so then the server can
look at the request and say ok this is
John Lennon let's send him a dedicated
page but back then as an eight-year-old
child I acted as the browser I entered
the state myself I had my own made
framework the notebook and the thing
with lemmings is that we couldn't guess
the password for the next level that
would be too easy but in this case I can
easily trick the server to say well I'm
Paul but actually I was John yeah I
think it's that the server must find a
way to trust that what I'd give it to
him we need to find a real some
something for the server to trust the
browser and that's that one reason not
the only one because that's one of the
reason we invented session identifiers
so basically if I take my example back
once the server is about to respond you
just say ok so I got this from the
database about John but everything I
know in him and I'm gonna generate a
random ID so maybe a 42 and I'm going to
use a third party storing service the
memory a database it depends and I'm
going to say ok a 42 is everything I
know the session of John and then I can
answer the server the browser and I just
have to send in the cookies this random
ID and then I'm a browser what do I do I
send the cookies so once you navigate
you just send a a 42 and then the server
again we
need a third-party service the same
memory we used to transform this obscure
ID into information it really
understands so by doing a round trip to
the memory it can knows that it was John
actually so there are several several
problems to using session IDs let's yeah
let's do a quick pose maybe I need to
drink
something is wrong yeah let's do this
after sorry okay so there are several
problems with session IDs if your site
is successful you're like okay maybe it
will fail I don't know
so one server couldn't be enough no
problem they're like okay let's put a
load balancer and two servers and voila
okay thank you bye bye but let's imagine
you're very very very successful okay on
this diagram every node that the cluster
is the same instance whether you used
provisioning VMs containers in terms
that do it by hand as you want this is
the same configuration so each server
has its own memory and with a load
balancer if I arrive with the session
842 well I could end up on the correct
node that knows about session a 42 but I
could end up on a server that doesn't
know anything about it so the easy and
naive solution for this is to no longer
have any memory cache and maybe try a
share cache yeah so the shared cache
could know about a 42 but it would also
know about these 71 for example and
everyone could ask the shared cache and
that's when what what did we just do
it's going to work somewhat yeah what
did you did we just do
we ask all the requests to go the same
way in a very simple matter and actually
the result is not bad
and if I do fast-forward it's gonna get
ugly
okay sorry no it's gonna work someday
okay so the problem is we just created a
single point of failure and if the
server this magical shared cache felt
false we are basically screwed
so let's find another solution maybe we
could let each memory on each server and
put a distributed cache I mean we all
use them we all heard of their memcached
each cache etc so we set it up and
whatever the node the load balancer
chooses every node knows about every
session so it's okay and if a session
fails as a node fails some users may be
disconnected but the site isn't down so
it's it's not that of a problem I think
I mean it's better than what we had
before
there's I I've worked with many clients
and at some clients this was it works on
my machine I go to the ops team and I'm
like eh cache memcached what can we do
and they're like no problem and tomorrow
it's fixed and I saw other companies
where it was like oh my god we need all
the nodes of the cluster to see each
other it's going to be chatty all the
other place we have to open port bla bla
bla and three three no meetings three
weeks after that it's still not that
there so it will really depend on your
context but sometimes this technique it
is a bit complicated to handle
the other solution would be to to put
some intelligence in the load balancer
so with something that's called sticky
sessions so when a request arrives like
D 71 the load balancers knows exactly
where to send the request and if it's a
42 a 42 if that node falls well here we
we have a bit of a problem and that's
where old solution don't are not
releasable bullets so beyond that
nothing prevents you and it depends if
you have the budget or not to put a load
balancer with sticky session and
distributed cache a bit like here having
a seat belt and and an air bag so again
you're many in the room
each one has a different context the
different team skills ops devs different
budget - so it will really depend on
what you can implement but I I cannot
help myself from thinking about the fact
that if we were to manage the state on
the client side maybe it could be a bit
simpler and that's where the IETF the
internet Engineering Task Force gives us
RFC 775 19 who read an RFC recently oh
nice so let me simplify this RFC for you
so basically it talks about JSON web
token the first thing you need to know
it has nothing to do with Google web
toolkit okay okay it has nothing to do
with the Chinese man - it's about tokens
and the web and if you're like oh what
is it what is this mr. JW t you go to
Google so you
find some articles you know those
articles a bit like people magazines or
diet suggestions magazine you know like
cookies JWT
which one should I choose and you're
like hmm this is interesting and reading
it you should not you should not it's a
very MP key and there's someone in the
room who has to it's very different you
cannot compare those stuff it's what you
can compare is JWT and session IDs and
you're like but session IDs and cooking
are the same they are not and don't say
that to me if you're too close to me
please so we can compare session IDs and
talk and JWT because basically a jet
ability is a token just like a session
ID and there is two kind of tokens so
token by reference and token by value so
I like this comparison of you to use is
saying that a token by reference is like
it credit card so if I take the credit
card from Antonio there I won't know if
he's rich or poor I mean I need a third
party storing service is bank to know
about it but if it gives me a 500 euro
bill I'm like this guy is rich or maybe
he was and now I am but the difference
is with a banknote the only thing I need
to do is to check that he he didn't
print it at home on his Canon you know I
need to check that it was from the
European Central Bank and like that's
exactly how JWT works so let's take the
example again so within our one trip to
the database we check the password and
before we had we needed a third
the service now we don't we only need to
write and sign information so first we
worried okay this is John Lennon he
plays the guitar
bah bah bah and then just like the
Central Bank of Europe you stamp the
thing you sign it it's a it's an
official document and then you can send
it to the cookies okay I can use JWT
with cookies so all those articles were
not that great to say it friendly yet
you can so what does the browser do when
he has cookies I'm a cookie what do I do
I said I'm I'm a brother what do I do I
send the cookies so every time you
navigate the the token is sent back and
then the only thing you need to do is
verify first so you check the dollar
bill is okay or euro and then you read
the information okay I read the
information it's done let's say welcome
done ok so what does it look like JWT so
it looks like that the sheller comes in
the room should see some clues that
there is something looking like Jason
yeah
curly braces quote in base64 come on
okay there's actually three parts in a
JWT they are separated by dots the first
part is the encoded header the second
part is the encoded payload and the
third part is the signature okay so if
any of you in the room says to someone
after living from there
Oh GWT are encrypted the way that guy
told me no I said encoded okay this is
completely different it's encoded in
base64 URL so it's just like base64 with
a few differences to be URL safe and
actually if I use a base64 decode
function and I look at it it looks like
Jason so it's a strength basically so
now I need to decode it to parse it okay
now we're talking so let's look at the
payload in in the details so the the
specification tells us a lot of stuff
about the kind of information we can put
in the payload they are called claims so
this token is claiming information and I
will use the signature to verify if it's
true or false and there is a series of
public claims that our yeah public lame
that are reserved and specified and then
you can put whatever you want
allowing depending on the size you you
will try to focus on so the first is the
issuer so this is where you're going to
identify who printed the banknote you
know who signed the token so here it's
my authentication back-end it's a string
you can put the it really depends on
your context but you can put whatever
you want it really depends on your
business the second is the subject so
you can put I log in an email again
depending on your context it must be a
string the second the third is the
audience so if you're going to do single
sign-on you will maybe target the token
to specific audience you know
then you have the expiration time this
is one of the most important and at
first I was like so there's a payload
and he's giving me the information of
when he won't be relevant anymore it's a
bit strange no it's like hey I'm saying
this and I am the one telling you until
when I'm gonna be true but again because
it is signed I can trust that so you
have the date of when you shouldn't
trust the token anymore
you also have the opposite it can be
useful if you're providing a paid API
you can deliver token that will only
work at that period of time with the nut
before then you have the issue that
sometimes useful and lasts the JWT ID
will go back on this one after but it
must be an identifier really completely
unique to all the tokens you've
generated so forget that photo increment
and a UUID should be okay then you can
have some private claims and here I put
it a name I want to use in my system and
a few permissions okay so how does the
server trust this thing well if you
remember I had three parts and in the
first one in the header I have an
algorithm so bear with my French okay
here the algorithm is H Mac - 656 sorry
so what I need to do is - as a server to
trust this information is to use this
algorithm and apply a function so H make
sure to 62-56
on the encoded adder a dot
and the encoded payload so it's the
first part of the token actually and
this hashing function needs a secret so
don't use this one obviously and so
you're like the browser or any kind of
client mobile app sends me this this
payload but how can i really trust it
actually if i were to play on my browser
and maybe mess up with the yokohama or
something i could say my name is paul
mccartney and well it does the same
actually but he also plays the bass bass
like that yeah okay so as you can see as
I type you can't see it yeah you can
okay oh yeah it has to be yes sorry
correct Jason so the signature change
obviously so if I were to mess up with
the payload then I will have to maybe
guess what is the secret on the server
side and try a few stuff like this and I
mean at some point it's worse than
mining bitcoins because if you really
want it to fake the signature it should
be quite cryptographically impossible so
normally at that moment you're like this
is great I need to use this yes of
course there's some benefits but welcome
to the drawbacks after so the first
benefit is we have that simple load
balancing of course if I take my example
again I don't need any distributed cache
any shared cache anything I just need
some CPU and I'm saying that but it's
really simple to calculate a base64 and
ashmac something
parsing JSON and that's all I'm
completely stateless and because it is a
specification a standard it works with
any kind of platform in any kind of
language so you'll be able really to to
have your your architecture with maybe
several language using the same tokens
and since we talked about architecture
if you love microservice or or just
service-oriented architecture it works
really well so if I take my good old
monolith and I try to to split the logic
that is in it so maybe I extract the
full text search the basket handling
something etc I'm splitting my monolith
I have micro-services yeah you can put
that on Nicktoons I'm really happy but
have you ever talked about
micro-services with someone and it was
like oh I have all this it's a French
guy I have all this microservices and I
plug them to through MongoDB it's okay
no no it's not I mean at some point if
you can remove if you can remove the
state it would be better so let's try to
avoid the single point of failure so
I've been telling you about the secret
you know and it's shared around the the
architecture but as anyone knows when
you share secret it's not secret anymore
so what's interesting is that you have
two kinds two ways to sign a token the
first rizzo is a symmetric signature
with a shared secret but you can also do
a symmetric signatures with a private
key and a public key I didn't say it was
encrypted okay
this is just signing so remember the
header you could provide a different
hair color algorithm working with the
private keys and public keys and if I
take my example back here as I said I
have a shared secret everywhere so this
is bad
but if I say I'm using so public is
everywhere and maybe only a private key
on the the component of my architecture
that handles the security huh now a
token could be better maybe you could
use key cloak there's a good talk from
Sebastian from Monday on this if you
want to know more but that's the basics
okay so what about both - it's a
completely different topic or at least
it's a topic that deserves its own talk
so what you need to remember regarding
JED ability is that both two tokens are
mostly obscure opaque but there's no
reason we couldn't use GWT it's a bit
longer maybe but it removes the fact
that we would need a storing service to
verify stuff and we can actually check
the access token and the Refresh token
in a completely straight status way but
remember the purpose of a refresh token
would be to go to a database to verify
that John hasn't been dead sorry
okay so it's the same with open ID it's
a topic that deserves its own talk but
it's not like in the magazine open idea
readability which one should I choose if
you use JW open ID connect the ID token
is actually a JWT so specs
specifications are
getting together to share what's really
important in all of them so now we can
leave the unicorn world and talk about
the drawbacks the first drawback and the
most important one is tokens revocation
so what do you do if you have to revoke
a token but you don't want to revoke all
of them I mean at some point I would
like to fix the typo on my slide without
changing oh in my slides you know and
the problem is if you have your
architecture how can you in a stateless
way refuse someone and not someone else
think about the banknotes think about
the passports the only way is to have a
list of people that can take the plane
for example so blacklist and that's
where you use the the JWT ID in the
payload it's an identifier for this
token so maybe you could use a blacklist
to to have all the tokens that are not
supposed to pass hmm this is nice
interesting
but in security we always prefer to say
no one can pass and I have a list of
people that can enter if you do a
blacklist and if for any reason that
blacklist fails you're letting everyone
enter and you could be like well but I
won't have to store all those IDs I want
I will only have to store the revoked
ideas yeah so it's easier to to handle
but again it's as a security it's it's a
bit problematic so again on drawbacks
the security on single page
education it's not that much of a
drawback but you have to be careful and
there's a lot of articles that are like
okay JWT cookies you remember they are
not secured at all it's mostly wrong to
simplify that that way tradability are
not more secured or less secure than
identity am session identifiers but once
you use cookies or if you use what some
article sales light using local storage
to store this Jade ability you can be
subject to cross-site scripting attacks
so cross side cross-site scripting
attacks remember you have maybe User
Content that can be injected if they are
injected in your page they can read the
local storage and they can read some of
the cookies okay you have this third
party script who has never read the code
of Google Analytics of any script that
is from elsewhere I mean you don't know
what's in it and it can read anything
and send it somewhere else
and obviously you also have the problem
of non secure HTTP of our public Wi-Fi
but we all adults here so we're using
HTTPS so what about cookies actually you
don't use local storage you use cookies
but you use them with the HTTP only flag
and you also use the sexual flag so the
HTTP only flag prevents any JavaScript
executed on your page even yours to do
document dot cookies and to read them so
actually it's a bit like I'm a server
I'm giving you this cookies and the
browser a lot is like okay and keeping
the cookies I want
give them to the page but every time I
talk with the server I will give him the
cookies and the second flag is if any of
your users writes
mysite.com instead of HTTP mysite.com
the cookies won't leave if you're using
GWT with the not with the browser but
with mobile labs third party server
between third party servers you could
even use a transmit them with the
authorization letter sometimes some
libraries are easier to use with that
than parsing cookies so once we use
cookies I'm a brother what do I do
okay I I send the cookies and you are
subject to CSRF attack also known as
xsrf attack let's say C surf like the
like someone I don't know but I've heard
it's called like this so C surf attacks
imagine you build this malicious website
and you try to build a form and to get
people on your site and so they click on
it it's very simple if you want people
to click on that you put on your life
and your and your staff without doing
anything
people really click on it and if I do
that I'm on malicious comm and I'm doing
a request to Twitter so what does the
browser do is sends the cookies to
Twitter so obviously it doesn't work
with Twitter so how do they do actually
on their page when you load the page the
form to tweet contains a hidden input
and so they call that the authenticity
token it's also known as the
synchronizer token pattern so if you use
a symphony and PHP jungle and python any
Java framework all of them supports that
kind of CSRF
in pattern so how does it work the
browser sends the cookies as always and
Twitter is like okay this is station
session a 42 I know this guy and I will
send him and a random ID I put in his
session and once it talks with every
time it talks with me and he tries to
send to post a tweet he has to send the
cookies automatically but in the forum
there should be the famous token so
Twitter can go round trip to the memory
get the information about the user and
compare what's in the session with the
authenticity ID 36 if it's if it works
you can send the you can create the the
tweet if I were on malicious website I
wouldn't be able to forge and to send
the authenticity ID 36 because I have no
way to get it and so here we have a
session but can we do that with GWT of
course we can so it's only at that time
that you can use local storage only at
that time that you can use local storage
so imagine you have your website you you
are logging in ok at that time what you
do is write inside a GWT as always join
in on blablabla permission and you add
in the payload a random ID just like the
ID from Twitter but instead of putting
it in the session you put it in the
payload ok then you send the cookie as
always and you add a header in the
response so here I say my CSRF token is
36 okay and at that time your your web
app can do I mean angular react
any framework you have to put it in the
local storage and you put some
Interceptor on Ajax requests and on each
request you get the ID ID and you send
it in the request so that way you
completely isolated from the two kind of
attacks because as a jab as a JavaScript
in your page whether it's yours or
something injected you have access to
the local storage 36 but you don't have
access to the cookies okay and that's
why it's it works actually and on the
server the thing you have to do is to
verify the JWT at first and then compare
the the CSRF ID that was sent with the
payload that was sent by the browser
itself that diagram is like oh my god
okay you have to play with it too for it
to make sense it's been already a lot of
time it's frozen yeah so yeah don't
hesitate to go back to that diagram then
the tweet anything is created so there's
many other durability applications that
you can think of actually we have a
specification to sign information so we
could use it for anything else with on a
project we tried to remove the session
we needed to do multi-part forms so the
first part did the round-trip to the
server and we stored it in the in the
GWT we also tried to remove the token we
use in confirmation emails so what we do
nowadays is that I lost my password okay
I click the server generates the random
ID put it in the row for John so John if
he wants to reset its path
has to send a request with this kind of
ID and I send them an URL through the
email actually because JWT our URL safe
because of page 64 your honor you can
send them here the problem is maybe to
put a very short expiration then I want
to to close with a an ID we saw the
drawbacks the benefits and when I talk
about this topic I'm like okay so what
do i do do I do a blacklist should I use
it on the client on the server and there
is a pattern I really like is that if
you have some kind of API gateway
there's many of them and you have a
distributed architecture microservice
architecture what's very interesting is
to draw the limit and say on the public
part on the web I'm going to still use
session ID and on the private part I'm
going to use jet ability by doing that
under public world you still have
something opaque and in security it's
always better and on the private part
you don't have the MongoDB dependence
you know you don't have all your system
that requires a third party to know if a
request is valid and actually the API
gateway as act as a transformer it's
like oh your session 42 I'm going to
need at some some moment a storage
mechanism memory database but I will
only need it at that place and that's
where I do my white list of people
authenticated and then I can write GWT
that contains the information needed for
the rest of the handling of the request
and I can pass it so my server can be
okay I have a request to delete
something from this application in the
JWT I checked the permission and because
I have the public key I can verify that
this guy has the permission and really
you isolate the the private key maybe on
the API gateway or at some other place
and then you have really reference on
one side and by value on another another
side so I hope you have a better
understanding of how to to think about
this how durability works most of the
time I would say that you will be in a
better shape with stateless architecture
is the best way to save lemmings after
all thank you very much
do you have any questions yeah
so your question is about the size of
the token okay so the problem is because
you have the signature and the payload
in JSON it's very more it's more big
it's bigger sorry then a simple ID so
that's where you do what you did maybe
with your session is like having the
smallest session possible to simplify
stuff but yes it creates a constraint
because you have to limit it at some
point so I tried to do maybe for the
permissions to do a dictionary to reduce
the you know the length of the payload
it's it actually doesn't really help and
it opens security holes so if you were
used to put a lot of stuff in your
session it can be a problem there's
limits that are difference on many
browsers and also on nginx Apache etc
yeah yes how often should I it's so the
question is how often should I rotate my
private keys the it's a very good
question
I know that in the so it's not a
question I'm I'm really able to answer
but just so you know in the header you
can put an identifier for the key that
was used so there I think a product of a
she cope does that handling private keys
like that and that way you can rotate
them and used in the the idea of the key
in the head of the said ability to know
which one to use I would say rotate them
with an overlap and our life lifetime
but it will really depend if you're
doing a website for your grandma bridge
or if you're doing a bank
it it depends sorry is there any more
question yeah sorry hmm so the question
is when I do well sorry when I do this
oh my god I can't find it it's going to
be okay so the question is when I do the
verification and I had voluntarily
something in the payload I could I use
the the identifier of the token I never
thought about that so I'm not going to
answer right now but my first thought
would be maybe you don't want to couple
them and you would need you would want
the token identifier to really be random
and meaningless for the business and
just useful for revocations
but from that my guess is as good as
yours we would have to maybe to do some
research yeah yeah
yeah so so the question is if I want to
revoke John I need to know what was the
last ID in the last token I created for
him for us
yeah the thing is you could store that
in your database for users I mean this
is not an information you will need all
the time so maybe having to do a round
trip to know if this guy it has this
idea or not to revoke him you could do
that at the time you create the token
but not at the time you check it which
is all the time you know and really do
it at creation time maybe again I'm just
trying to to understand you know your
context but I would say that yes yes
yeah the thing if you build a black list
you only have to to store the token
until they their end of validity yes yes
what
oh you mean the cookie experience pick
yeah yeah well the idea is that if I put
an expiration time in maybe tomorrow and
the you lose you have in your phone an
application that's open with the token
that will work until tomorrow your phone
is stolen you need to to log in
somewhere else and to destroy the
ability for the store the thief to use
that so you have no way to change the
payload on the device you know once it's
been issued if someone has it it works
until the expiration time that's when
you need a blacklist and that's a
solution that's not really most of the
time really efficient or secured it's
not automatically ok I we can do that
after maybe for the details yeah
okay so I didn't mention that that so
the question is once I use once I use
the HTTP only what's the name HTTP only
flag on the under the cookies I cannot
read the cookies anymore
and yeah it's a drawback because one of
the purpose of the jet ability is to be
able to read the information in the
payload so for that we we needed that
once for a client we own we just had to
do a round trip and a round trip that
reads the information and that gives us
the payload without having the signature
and too much information and if you have
if you have a mobile app you won't have
this problem and if you work between
servers you won't have this problem too
so yes the only way to secure it on a
browser is to use HTTP only cookies and
it removes you the ability to read the
content which is a bit troubling yes it
was not the question I didn't understand
okay so you mean the Twitter ID I
presented no yeah yeah are you talking
about single sign-on okay can we do this
just after maybe it would be simpler to
do to understand is there any more
questions yeah
so the question is most of on many
websites when I log in I am logged for a
very long time how can we do that with
jet ability without being less secured
is it your question yeah oh yeah so you
want maybe to update it yeah okay so at
first we were a bit like you so we asked
our client do you want the session to
work like one hour after the last usage
or do you want it to expire after a
given moment of time after the login is
it yeah and hopefully they said one hour
after the login and that's also one of
the many problems of jet abilities that
if you want to update something in the
payload like the expiration time but I
also had to do that on one of my
websites to update your nickname in the
payload you have to issue another
another token and actually the previous
one is still valid so if you want to
remove a permission from the from the
token it's a bit of a problem you know
that's why in the end and again it
depends on your context but I think this
kind of architecture really helps you on
the server to only trust token by value
and simplify a lot of stuff but to keep
things very more secured on the front
end I think you should maybe keep opaque
session IDs it's open to debate
so I'll be available until Friday don't
hesitate to to catch me - to ask lots of
questions and thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>