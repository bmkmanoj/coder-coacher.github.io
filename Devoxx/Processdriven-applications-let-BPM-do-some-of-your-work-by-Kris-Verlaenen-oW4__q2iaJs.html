<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Process-driven applications: let BPM do (some of) your work by Kris Verlaenen | Coder Coacher - Coaching Coders</title><meta content="Process-driven applications: let BPM do (some of) your work by Kris Verlaenen - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Process-driven applications: let BPM do (some of) your work by Kris Verlaenen</b></h2><h5 class="post__date">2015-11-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/oW4__q2iaJs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hooya Morgan Alamo good morning my name
is Christopher Lana I'm the gbpm project
lead and I'll be giving a presentation
on what I call process driven
applications so first of all our quick
introduction so I'm the gbpn project
lead at Red Hat's JBoss so for those
that are not familiar with gbpm that's
an open source BPM engine so business
processes and everything related to that
so I basically focus and my team focuses
on developing tools engines whatever you
need to work with business processes a
lot of the things that I'll be talking
about are not really specific to gbpm so
a lot of the things are probably
applicable to BPM em BPM in general that
obviously I'll be I'll be giving
examples etc using using our project
just to make sure I'm not gonna give a
very long explanation about what BPM is
what the advantages are and all the
technical features that our engine has
for example I mean this kind of
technology has existed for a long time
probably all of you know what it is and
have seen a presentation either from a
another vendor or from our project
already that lists all these things and
maybe you even have experience with with
it but just to make sure we're all
talking about the same thing
this talk is gonna focus on business
processes so it's gonna use the typical
flow chart so this is very simple
example the key idea is you're gonna
extract some of your business logic say
basically you're writing applications
and you need to do something you're
gonna try and extract some of that into
a flow chart a higher level
representation of your business logic
and that has a lot of potential
advantages I'm not gonna say that if you
start using it you'll have all of these
advanced
it depends on how you use it but one of
the typical examples is well that's
visibility I mean you're gonna specify
in a in a graphical way the different
steps you need to take these are
typically long left so it's not that you
do all of them at the same time if you
do one now and you didn't maybe the next
one a week later and there's other
people that might be involved in your
process as well and by modeling it this
way rather than writing application
curves obviously it's much easier to see
what your process is trying to do but it
also makes it much easier to monitor it
because at the runtime when you're
executing one of these processes you can
obviously easily see again I'm currently
at that node or at these nodes you could
be a multiple nodes at the same time and
I'm waiting for example for my managers
to give some input before this process
can move forward a third aspect is that
business processes are a different level
than then writing code so when you're
writing codes you're using for example
when you're writing code in Java you're
on Java objects these are implemented so
you they have a lot of properties etc
that they could be fairly low-level when
you're talking about business processes
you're actually at a difference level
you could be using concepts that are at
a higher level that are specific to your
domain and that are much easier to
understand
then these lower level implementation
objects that you might be using in the
end so in a business process even though
we might be invoking a web service with
the next Mouse schema and whatever at
the process level we try to avoid that
so we try to hide a lot of the
implementation details that that might
be hidden underneath and then one of the
key reasons why we want to do this as
well as you want to continuously improve
and in a business process engine always
allows you to update your processes you
have your business logic your logic
changes due to whatever circumstances
and you need to update your process you
can do that and then you can figure out
what to do with your running processes
either keep them running on the older
version migrate them to newer versions
etc but it gives you the possibility to
evolve without necessarily having to
rewrite a lot of codes I mean if you
have to go to a code release that takes
three months to update your business
logic that might be too late it might be
a business process might allow you to do
changes that are almost immediate I mean
you still need to have the necessary
safeguards you don't want to just go
into production and and throw out a new
version without having it's totally
tested but it's a separate lifecycle
from your application code itself and
finally I'll get back to that later in
the presentation
it gives you also some benefits on
agility etc on the model more complex
things that might be difficulty in
normal programming languages and just to
emphasize BPM is is not just about
having an engine that executes processes
there's a an entire life cycle around it
from the authoring where you create
processes and the execution all the way
through the monitoring and figuring out
what's happening at runtime and then
improving your processes so it's not
just an execution engine I mean maybe
ten years ago you could call yourself a
BPM engine or a workflow engine at that
point if you if you only had a powerful
engine that could execute these
processes nowadays you need actually an
entire tool chain to support your your
users to model these tamal all these
things and so the presentation I'm gonna
do today is is gonna focus on what I
call process driven applications
so while BPM is actually technology and
you can just look at it as a technology
you can use obviously your goal when
you're developing something is to build
your application and you're gonna try
and use technology that will help you
with that and in the in the past I think
BPM might have been more focused on just
the technology itself unless helping you
solve exactly the problem
that you wanted to solve so process
different application is actually
looking slightly different that how you
use BPM and and
to help you develop your application and
I'll explain you why in the last few
years was actually evolved to something
where we believe we can actually start
doing this now and I'll assume in um for
for things where I believe we've evolved
and actually the the evolution is all
about we want to give you more we want
to give you more building blocks so it's
easier for you to do whatever you need
to do I looked up my slides from from da
Fox in 2008 I have a university session
here then just to I went through the
slides and it's it's very clear that at
that point in time we were talking about
different things and what I'm gonna be
talking about now in 2008 that did talk
about integration of processes rules and
even processing and how the technology
could actually combine all these
different paradigms into into one engine
so you can see that actually at that at
that point the the major themes that we
were talking about but at a very low
technical level how you can actually
combine these technologies they were
unnecessarily about building
applications that you could you could
use so I'll start with with these
evolutions and the first one is how
basically BPM evolved from what at least
our project evolved from being a
framework to the tool so our strengths I
mean the project's itself started as a
process engine so a core process engine
the and it's to where I mean the the
process engine itself is a very stable
very performant very lightweight engine
you can use anywhere and it's got all
the features you think it should have I
mean if a process needs to be persisted
it needs to participate in transactions
it needs to be performant it needs to be
scalable etc so basically all
engines all process projects out there
they have a core engine like that I mean
for example I mean the the gbpn process
engine just to show that it's
lightweight I actually have it running
on my android phone
they have lightweight it actually is and
you can scale it you can have just one
engine for very simple applications or
you can expand it and have it in a in
large data centers running thousands and
thousands of sessions such as in
parallel so that's how it all started we
were really focusing on okay you've got
a process you design it how can I
execute it what came next is basically a
standard to be given to standards that
typically now Alvin there's implement
it's it actually held because before all
engines has their own their own language
nowadays the people into standard
standardized language that all vendors
support to model your processes it
helped a lot with the learning curve it
helps with interoperability between
tools etc and implementing that on top
of an existing core engine well it
wasn't a huge amount of effort basically
it's an extension basically on how you
save your processes in a specific format
but we kept adding things on top of that
so I already mentioned to talk I did it
in 2008 what about well you don't
necessarily only have processes there's
different paradigms that have F similar
similar goals for example business rules
also allow you to extract business logic
budino in a different format so business
rules are when then format and complex
different processing is then about
processing high volume of events and
actually if you combine these three
paradigms in one you actually have a
very powerful solution where you can
decide how to pick whatever technology
is best to solve power of your problem
and combine all of them to solve your
entire problem
okay and then next well if you're
executing your processes etc and your
rules the next thing we'll do okay I
want to I want to figure out what's
going on people were expecting process
management tools to be available so we
introduced the process management
control or basically extended it because
it's you know it's been there for a
while but people were expecting more and
more to have out-of-the-box tools to
monitor these engines etc on top of that
for the for the actual modeling of the
of the processes you have a graphical
process designer so I mean I showed you
a very simple flowchart you can you can
model your processes that way but that's
just one part of the problem the problem
is is typically bigger than that it
involves data data you may need to
define as well so we introduced things
like a data modeler a for modeler so
you're solving problems other people
have to participate in that they
typically do that through a a form you
can you can generate forms based on your
process and show these forms to your
end-users so these forms also need to be
different it need to be designed so we
introduced the graphical for modeler
then BAM so business activity monitoring
or or reporting you need to be able to
generate higher level reports about the
current status of all your processes etc
so that that's additional touring that
was that was introduced as well on top
of that then the cloud came that kind of
changed or or is still changing the way
we deploy application and the scale we
deploy them at so then concept like BPM
pass and a process execution server
because the core engine at the beginning
people it's a it's a simple java
purchase you can embed it in your in
your application and talk to it directly
if you want more loose coupling there's
a
we call the nowadays call the process
execution server so that allows you to
basically set up a server and you can
send requests to it and it scales
automatically so you don't have to worry
about embedding it in your project
anymore you can set it up once and you
can you can have a very scalable
distribution it does have advantages and
disadvantages I'll get back to that in a
second as well but as you can see we
keep adding more and more building
blocks that you can use obviously it
depends on your requirements whether you
want to use them or not I mean we have a
lot of users a lot of customers say like
well yeah you for example have a mean
like BAM tool I mean but we are we have
our own and that that's typically fine I
mean this is all an open source business
an open source project we've only gives
you the choice of having this building
block but you don't want to enforce
anything for example if you go to a a
big company in select well we've got a
process engine and we've also got this
this human task service to manage all
your thoughts and your forms etc they
might say like well that's cool but we
already have that I mean we've developed
our own we don't want to use yours and
that's that's absolutely fine so we have
a building block process a human task
service you can use that if you're not
interested if you have your own you can
easily integrate with your own but we
want to try and give you all the
necessary building blocks and that leads
to what I'll call process driven
application development so this is one
of the evolutions that led to that we're
actually giving more and more building
blocks for you to consume if you want to
the second is there's an evolution from
what I call embedded execution towards
more as a service so if you look at how
people typically were reusing process
engines at least our process engine in
the past is that you develop an
application the engine itself is Java
purged or you can integrate it inside
your own application
just a few jobs you include and then you
can deploy that application and it's a
very developer oriented way of
interacting with the engine so basically
it has got an API you've got a ton of
operations you can you can call and you
can integrate at that level there's
persistence you can we can integrate at
the transaction level etc and it
typically scales with your with your
application so you build your
application you deploy it somewhere if
you deploy it on multiple servers
basically the engine is typically
deployed on on that server as well so it
kind of scales with your application
because it's embedded inside nowadays
especially as soon as you start thinking
about more loosely coupling various
services people are interested in in
having more a process engine as a
service so it's basically the engine is
there you can deploy processes to it and
then you can interact with it it's a
completely different deployment model
and it's got different advantages it's
got also disadvantages thinking for
example about fault tolerance or
transactions etc those are typically
more difficult to achieve if you do it
as a service but especially if you're if
you're developing an application where
your application is just fairly simple
but at some point you need to trigger a
process to make it move forward or to
start a new one having a that process
engine available through a remote API
it's actually very easy you just do a
rest call you don't have to integrate
with it with the with the engine inside
your application etc so and there's a
lot of different architectures
in-between but what you can say is that
actually there's much more choice
nowadays on how you want to deploy this
I have actually two examples of what we
call typical architectures that we see
nowadays and one is what I call I mean
we're going to scale as a service so
we're going to offer a process execution
as a service
and we want to scale that then typically
you set up this your process engine on
multiple servers in a clustered
environment and you deploy your project
to that if you do it in a symmetric way
that's typically you have fairly
powerful servers and you you distribute
your requests among the service and each
of the servers is capable of executing
all requests so assume I have two
projects I basically deploy them to all
my servers
well that whenever the request comes in
it's randomly distributed to distribute
your load and they're capable of
executing our requests this works very
well but it means that actually this I
mean it requires resources from the
service because that could be hundreds
and hundreds of projects deployed but
they all can collaborate their
synchronization with a with a database
which is soon as one database but also
that would be that's a logical database
it could be distributed as well of
course a different architecture is what
we call an asymmetric scaling it's the
same setup but basically you deploy
empty appro empty process execution
server and you can control where you
deploy your projects this is something
that if you if you heard if you hear the
term I cure architectures and stuff like
that people are thinking about these
deployments rather than these over well
big server but all your process is wrong
that really doesn't fit with with a
micro architecture then you actually can
deploy small projects either to just do
one server and you have a custom API you
can direct to it or you can deploy you
can you can control how you deploy your
projects projects so they give you a lot
of choice in in defining the
architecture and how you want to set up
the engine and use it
the third evolution is about as I
mentioned business processes are at the
difference level and that's important
because
they're not only targeting developers I
mean there might be processes that you
develop that are purely for your
developers I mean and users or more
business users they never see those they
just run in the backend it's just your
your DevOps that might be might be
looking into this but there are also
processes that are relevant for other
people for people that might not have
might not understand what all the
lower-level technology that you might be
using and by using by avoiding all these
implementation details in your processes
and use at hire using our level
constructs you can actually have them
participate note that I'm not saying
that we believe you can get rid of all
your developers and have your business
users all of a sudden implement all the
logic themselves because implementing an
executable process with all the data
passing integration with external
services etc it's still a fairly complex
problem but they can participate you can
look at the results they can possibly
update in a constrained environment etc
and they can understand the end result
and the first part and this is a very
simple example of the healthcare domain
even though for example you have let's
say you have a in in a hospital you have
a service where you can actually
prescribe medication which might be a
web service or a rest service or
whatever we're kind of high that we're
going to create a medication service
we're going to create a nursing task
we're going to create a notification
task and so when you're designing your
process you're talking about as well
owners need to do this task I need to
prescribe medication and eating send
some notifications you're not not
talking about this lower level concepts
so we want to we want to reach more
people not just the developers we I mean
if you have developer centric needs
that's fine we have an engine you can
you can embed it you can use it but we
want to appeal also to these father
users to the business analysts for
defining this but also to the end users
because I mentioned people might be poor
taste
but in the process you might have to
look at the task list you might have to
perform certain tasks that forms
involved etc so we we want end-users to
also participate in this process and we
want to have tools that they can use for
this and to be able to do that and
that's the the fourth evolution
customization is actually very important
if you look at the tools we have and
I'll give it small demo showing show you
some of the tools later but if you look
at the tools they are generic I mean you
can define any kind of process you can
start any kind of process you can
monitor any kind of process etc because
we don't know about your domain the
tools we offer are also what we call
generic but a generic tool isn't
necessarily very appealing to the end
users this is a screen shot where it can
for example look at all your running
process instances so all all the ones
that are currently running you can have
a list of these but it's it doesn't
necessarily mean anything to an end use
it it shows details and some of the
details might be very important for
example it might show variables or
documents related to this process
instance but again it's very generic it
doesn't focus on the things that you
find important in your process typically
we allow you to create custom filters so
you can easily find the process
instances you need but even then
customization is very important if you
want to have something that you can
offer to end-users and that they will
need to use on a day-to-day basis you
need to create something that is that is
very useful for them custom almost
custom-made another example is the de
monitoring so we have a web tool where
you can define these these charts
different kinds of reporting about how
many instances are currently
and how many thoughts are currently
available but and we have what we call
our default process dashboard so that's
like a dashboard where an administrator
can go and look like okay these are all
my running instances etc again this is a
very very generic thing and has only
limited limited usefulness because it
just shows a fairly technical overview
of what you're doing so what we
recommend this rather than using these
generic dashboards create your own so
create a dashboard that shows what you
want to show if you're processing orders
rather than just looking at ok that have
30 orders that are currently being
processed you can look at ok this is the
amount of this is the volume that's
coming in this is the the the average
all the amount that's coming in the
times all this might be might be coming
in etc you can really create customized
reports that show the data that you need
to show so we believe that's absolutely
important if you wanna offer these these
kind of tools to end-users that you're
able to customize them to your situation
so by having more building blocks for
you to use by offering more choice on
how you want to use the engine or all
the tools we have by trying to get as
much people involved as possible and by
giving you the opportunity to customize
those tools we want to help you develop
your application and that's what I call
process driven applications you're
starting with an idea that you need to
solve a certain business problem and you
want to use a process engine for that so
your business logic is a sequence of
steps for example and you want to start
using the process engine for that but
you want to quickly get to an
application that you can start using in
a lot of cases a lot of the applications
that are
developed a lot of the processes that
developed all unnecessarily that complex
there's a hundred people involved and a
thousand steps to be done usually just a
few steps that need to be done but they
need to be didn't need to be controlled
so that's why you need a process engine
but by having a lot of out-of-the-box
building blocks and being able to
quickly combine them together you can
quickly go from from nothing to a
prototype that shows what your
application might be able to do and we
give you the choice and the flexibility
to do what you need you might start with
something simple and at some point you
can for example say like well now I'm
gonna I mean we need to develop our
custom UI for this so we're gonna
replace the UI that we started with
we're gonna make it much more complex
and we're gonna find unit completely
that's fine you can and you can evolve
so you can start with something simple
and evolve I have the impression that
nowadays being able to quickly show what
you're capable of starting with a simple
application is extremely important
applications will evolve and you will
people then at that point need to figure
out how you're gonna scale and Mojave
are gonna customize them but getting to
a point where can actually sure what the
application is gonna do and what
benefits you get is extremely important
because I mean the company might not
might not be willing to fund an
application if it takes two months just
to figure out whether the application
itself is gonna be become a big success
or mass so this is about this building
block that I said that we are offering
and this is what we see as a very
typical set up if you're basically just
interested in all having a process
entity to execute your processes but you
just want to interact with them you have
your own your voice you just want to
develop them so you set up a process
server that you can use either you
embedded in your application you
is it it has a service but the typical
architecture there is well there's an
operating system and an application
server you can choose and then on top of
that there's multiple engines that are
that are deployed well there's actually
just one engine capable of executing all
these all these different paradigms but
then you implement your logic as a
combination of processes rules and
complex event processing for example and
there's a lot of other services that are
necessary to make it all work
think about timers services because
there might be timers related in your
process so that they need to be a
scalable distributed timer servers
they're asynchronous jobs your your
engine is typically executing a lot of
things so we have what we call a a job
queue where you can just put things in
the queue that they're executed also in
a distributed fashion obviously
persistence and transactions if you're
if your engine goes down your servers go
down you need to make sure you're always
in a consistent state and yeah you might
start on one server you might continue
on the other one etc so these are almost
like the the minimal set of building
blocks that you need to be able to
execute simple and fairly complex
processes and you can expose that
through a remote API so nowadays in our
project we have just rests simple REST
API but also a JMS api which is very
useful if you're if you're looking for
transactions GMs actually it gives you
much more value in that respect than
rest does web service integration a java
api where you can just that you can use
to talk to a remote engine egb
integration etc so we want to make it
easy for you to just integrate with with
the process engine that is deployed
somewhere from your front from another
application now this is then the almost
like the minimal set of building blocks
that you can you can use out of the box
but you can go much more complex and if
you if you look closely so this
combination of blocks this is actually
this block here so you can say like well
this
the the the the process engine for
execution of my processes but I actually
want to use more I want to use a web
authoring tool to define these processes
and I want to use the BAM capabilities
that we have as well and then a
web-based management console which I'll
demo in a second that actually combines
all of this so this is almost like well
if you want to use all the whistles and
bells you can pick whatever building
blocks you want to use obviously you can
see I had fun in building this this
example for you but might keep my kids
even have more fun but it kind of shows
like we have a lot of building blocks
and which one you use is up to you and
you can use the full stack or you can
just focus on underneath on the specific
things you have and so I'll show you an
example so this is what we call our
workbench aura it's it's a web-based
management console that tries to help
you through the lifecycle of the process
so as you can see that we try to kind of
show the different life cycles you you
alter your processes etc you deploy them
to a server in this case that's just a
server running next to the web
application that will that will execute
your processes you can start Frost the
season look at running instances you can
look at your task list and finally you
can get an an overview of the current
status reporting dashboards etc so in
this specific so if you want to develop
let's say a process driven application
you typically start with a process and I
just created a very simple process here
so an expense process where you submit
your expenses there's some validation
that needs to happen
your manager needs to approve that and
depending on whatever you submitted
there might be additional approval
necessary as well
and there's finally there's some
sometimes that if there's a receipt
check so you have to stand in receipt so
they'll actually verify whether your
expenses are valid at any point in time
the reporter it's also the person
sending in the sending in the expenses
might be notified etc and so all of
these all of these three are human tasks
you can actually see by the icon here
they are a person that needs to perform
a certain task the first one is what's
called a scrip task it's it's it's done
automatically or you could for example
use business rules to do some validation
as well if you want to externalize some
of that logic so this is one part and
that you did you start with in this case
I'm not using any any specific data
models so the the the process is
actually just gonna take a document as
input which each system and an excel
file spreadsheet that you send them that
lists all the expense items so there's
no additional data that data that I need
to define but I did define a form for
submitting for starting the the process
or for submitting expenses and actually
it's it's auto-generated because the
process knows there's a document
involved and there's a justification
that needs to be provided whenever you
start a process so it automatically
automatically generated a form the first
one is just say a document selector so
what it does is it allows you to select
a file from your file system that will
then be uploaded as part of the process
and then you can actually see that
there's it's being bound to a process
variable so in the in the process I
actually have a variable document that
will that will keep track of the of the
expense document that I submitted so
this one is actually being being used
and in the process to move to move the
expenses through the system so that
whenever I sent a my manager for example
approval from the manager I obviously
sent the documents link as well so they
could they can go and they can go and
look at the expenses as well so this
fairly simple process just a sequence of
a few steps allows you to done I mean
this is a project that I can now deploy
an execute so I don't need I mean
there's a few details hidden obviously
about for example here I can I can see
like this is to anyone in the in the the
program manager group can can claim
these tasks so that's details hidden
that I'm not gonna go show all but this
I made this an executable process with a
sequence of a few steps and I can deploy
this process now to my server so if if I
look there's okay it's the last one here
so I created just the first version
version 1.0 of the expense process and
this is deployed to the to the server so
you can go and look at okay what are my
process definition list so these are all
the processes that are currently
deployed in in the instance that I am
running here you can see that this
version of the process I can actually
start a new instance by let's say
uploading this expenses file giving in a
justification and then I can look at the
details of of this specific instance so
you can see actually validation was
successful in this case so now it's
going to wait for my manager which my I
mean depending on how you integrate the
task service might have an email
notification that he that there's a new
request he might go and look at his task
list and they take a look and approve or
deny the the expense what I've shown
here is what I call this very generic
souling so I mean you shown a process
list where there's a number of processes
you can look at
these are my running instances you can
just have a list under security for
example there's three experience
processes three experience processes
that are currently running you can look
at all the details but this is very
generic very low level and I don't
expect that as an end user you would be
this would be the ideal tool for tier
two years so what we allow you to do
rather than having to rely on this uy to
do all the work we we allow you to
create what we call an domain-specific
extensions to to our tool and obviously
you can just build your own UI
completely new and integrate with it but
just to show how it's actually fairly
easy to just create a simple screen
that's much more useable much more
specific to your application we have a a
component that allows you to define
custom screens and in this case it's
it's a very simple angular application
that will in in this case will list all
the expenses that I have currently
running so if you look at the code at
the top here there's the the HTML which
is basically just a table in this case
where I'm gonna show data related to the
expenses that are currently running a
button you might have buttons you might
I mean this is currently just a table
with a button but you can make it
slightly more complex as well and so the
angular application while it's calling
the controller and what this is actually
doing is it's it's calling or existing
remote API so it's going through rests
I'm not sure whether you're all be able
to read this but it's basically calling
the the REST API history process and
then expense process so it's going to
get all the expense processes from the
other tables that we that we have and
then you'll be able to I mean using
angular am
rendered is in the in a simple table so
this is very simple screen you can to be
able to use that you basically by
refreshing the application you can you
can make it accept new screens that you
just defined so whenever i refresh the
application its gonna look okay there's
a new application it and it might be
able to use that so to be able to access
this screen that i just defined i'm
gonna create a new entry in the menu
that i have on the top so i'm gonna
create a new dynamic menu item which I'm
gonna call expenses and then I'm gonna
link to the view that I just created the
screen plug-in which is called expenses
lists okay so I add this new menu item
to the application and if I now refresh
the application again there's a new
entry here which if I call it it's
currently listing the expense reports
that are currently active so what this
shows is actually it's very easy to
rather than having a very generic table
with process instances you can show data
which is very relevant in this case I'm
basically interested in the amount of in
the number of expenses that I currently
have and typically the the time they
will start for example so can easily see
there and you can easily add additional
buttons to go look in more detail or
like look at the expense fault itself
that it allows you to create custom
applications as part of our workbench
that are much more tailored to the
problem you're trying to solve to give
another example
there's something what we call a
perspective so a perspective is
basically a combination of multiple
components to create a 1:1 view so in
this case we have well we have three
types of components that you can use and
combined into one perspective the first
one is an HTML component and I just use
one here so this is basically just a
simple HTML I'm linking to an existing
image and you can use the screen
component so whenever you develop as a
screen like I just did you can you can
combine them and pick and choose them
for example pick any of the existing
components that we currently have and
combine them and finally we have what we
call the display ER component this is
for the business activity monitoring and
the and the reporting you can create
small small views that show relevant
information for your application so for
example if I want to show the amount of
expense items that I currently have
access that I currently have active I
can create a meter which basically looks
at all the expense processes that I have
which is data set I predefined but I can
just look at the count so the number
that I have and and customize some
additional properties like let's say as
long as I don't have more than 10 it's
fine and 20 is basically the limit that
you would have so you can you can easily
create a a a custom graph that shows
this kind of information or a similar
one that's let's say we want to show the
time where when the expenses were
submitted for example for a month
I must so just count the amount and then
let me just get rid of the legend here
so in this case it's I mean it's because
I I basically just demoted these three
expenses that we start this month so if
I save this you can you can actually you
can actually go and look at these
perspectives and they're dynamically
updated so you can create a custom page
where you can for example list the
expenses you currently have gathered a
few charts that show information related
to that allow you to to submit expenses
through that application etc so rather
than using the generic tool and you can
easily create a custom page a custom app
that is that is focusing on the problem
that you're trying to solve now finally
there's one other thing that I like to
mention it is also the final evolution
which is what's called flexible and
adaptive so one of one of the key
concerns that people might have when
they're trying to use a BPM engine is
that well it's actually I mean I have to
implement my logic and have to follow it
there's no way to adapt I mean there's
always exceptions there's always I might
not want to do this now I want to do
something else as well can I do this and
in in the past if you look at
traditional workflow engines they were
very strict you define a process you
needed to follow that you first to a
then do be tender see there was no way
to skip B or to do D you just have to
have to follow the process as defined
now that's obviously useful if you want
to have this kind of structure but in a
lot of cases you might have you might
want a lot more flexibility and then
there's there's a lot of different terms
you can use in the past we've called it
flexible processes
it's called adaptive case management as
well nowadays or at least some people
refer to this as adaptive case
management so what you need from your
process engine is the ability to to be
able to choose so you need to be able to
model something where the process
doesn't necessarily define what needs to
happen but there's someone else I when I
was at the University where I worked on
a company that did healthcare
applications and if you go to a hospital
ok so like what we want to help you in
defining these kind of processes for for
treatment of patients the first thing
they will always tell you is like well
that's fine but it's it's the doctor
that needs to decide so you you need to
give people the choice in these kind of
processes to for example do something
even though the process is recommending
to do something else and and there's
so in these cases there's a lot of neat
amount to more advanced concepts that
aren't available in for example the
beeping and two standards for defining
processes just concepts missing that are
absolutely necessary to do these more
advanced cases to model these into
execute these for example the concept of
a case file where you can just drop data
in and and and and collect data or
afford a certain case the concept of
roles like people are participating in a
process in a lot of cases it's very
important to know who you're
participating with the patients that
that's relevant for this process the
different doctors the different nurses
that are participating it's very
important to define these if you don't
have a very structured process you might
be working with milestones rather than
to track the state of your ins of your
process over on your case rather than
the the traditional process instance
view that I should that I showed earlier
to give you an example the VPN to spec
does allow you to add a lot of concepts
on top of the predefined concept so the
project we've taken is B we have added
quite a few additional features on top
of the the engine that we have to start
supporting these more advanced cases
this is a the healthcare example that I
was referring to and as you can see the
process itself isn't completely well
structured and there's there's basically
three process fragments as we call them
that are floating around inside this ad
hoc sub processes so this adaxel process
allows rather than the process engine to
define whatever needs to happen it
allows others to define this in this
case there might be a physician which is
looking okay these are the potential
tasks that I might need to consider
which of these do I actually want to
want to execute but there's also the
possibility to combine this with other
paradigms to automatically trigger for
example some of these so in this case I
might for example say that the blood
pressure measured
on the top is something that always
needs to happen if for example the
patient is older than 50 and has a
previous and we have data in his in his
medical record that shows he might have
these kinds of you might have some
symptoms that might might indicate some
problems so we were able to for example
have end-users decide what happens have
processes or complex event processing
decide which of these should happen and
on top of that you can actually add new
tasks inside this sub process even
though that not even defined in the
process so if at runtime the physician
is looking at the patient data and he
sees like well actually that's I mean
this is you see a problem here I
actually want to do an additional test
he can add this one you can add an
additional test to this ad hoc so
process even though it might not even be
defined in the process at all so these
kinds of capabilities allow you to to
model much more adaptive cases and in
this case it's it's still a fairly
structured process and the adaptive of
the ad hoc part is just limited to these
three but if you go to the extreme you
can have a you could start a case
without even having a process at all so
you can start a new case there's nothing
pretty find you can start adding Tufts
to it so it's like saying okay I want to
I want to do this I'm gonna add a few
documents then I'm gonna create a task
for one of my team members he needs to
go and look at this and there's nothing
pretty fine and you can that's the other
extreme but there's a lot of in-between
so from i from our point of view case
management and structured processes or
what we call a spectrum you can go the
entire extreme and not defining anything
up front and just doing everything ad
hoc or you could ever believe very well
structured process that there's no
distinction there's no clear line in
between so the technology we offer
allows you to model all of these using
the same same technology same engine to
execute all that and then finally
and now I have to I'll show a quick demo
on how you can actually combine than
what I just shown before the custom app
with this case management let me quickly
add a few services
so what I wonder what I want to show is
to be able to do give a physician than
the choice to to keep track of these or
for example to use the concept of
milestones if you want to follow a
patient to different milestones and have
a view that actually shows how a patient
is being is going through the different
milestones you can also create then
these custom applications that that will
be much much more useful for let's say a
physician or for whoever's looking at
using your tool so an application was
really deployed if I go in there's a
simple case process case management
process that I have and also a set of
screens that were developed to accompany
this so similar to the example I showed
before this is an 8 a page that is gonna
show a table with all the cases that are
currently running and that states in
this case the state is going to be a
little bit more complex and it's gonna
have a few buttons etc to interact with
the case as well and some logic to go
and get the information from the backend
services so if I go and look at the case
management view in this case you can you
can fairly easily create something which
is very specific to through your process
in this case I'm the cases of doing the
treatment of my patients I can see ok
these are the cases that are currently
running for these patients and these are
the tests that are currently still
outstanding and you can go and zoom in
on the details so this is a custom
screen that shows that these tests are
currently waiting to be submitted and
this kind of flexibility of being able
to to have choice for example we added a
simple button here where the
that the physician is able to choose for
example okay these are the the options
that I currently have you could add a
button to dynamically add additional
tests that might not be predefined but
that's not developed as part of this
demo but as you can see these kinds of
views these custom shoes that you can
you can easily create are from our
perspective much more appealing and much
more closer to the problem you're trying
to solve so to conclude we believe that
for process driven applications we want
to help you develop your application and
that means and I know that a lot of
people are not going to use all the
building blocks that we have and that's
fine we want to give you the choice if
depending on what you want to do maybe
you just want to create a quick
prototype then you probably want to
depend on a lot of the building blocks
maybe you just want to in the end if you
want to build a a lot of custom
processes in your in your company you
might end up building some some custom
UI yourself and you might not realize
for example on the task place because
you already have an existing UI to do
this kind of functionality so if you
want to get started with this
so the GBM project homepage probably
gives you two links to everything you
need the latest version currently
available is six three which is
basically the one that I've been demoing
if you want to get started the easiest
this is probably the Installer or you
can just use a doctor image to get the
environment that I've shown here and the
product
I mean Red Hat offers professional
support for this as part of the tables
BPM suite you can actually have get a
developer copy of that as well and if
you have any questions
yeah just contact us I'll be available
the rest of the day probably at the Red
Hat do it most of the time or just just
talk to me whenever whenever you see me
and we still have a few minutes left for
questions so
if anyone has questions feel free to ask
they're all so I'm not sure how many so
we have a few public references and then
depending on if you if you're interested
or sales organization can can provides
references that we have for especially
in the US a lot of the lot of the big
banks are using using this as part of
their portfolio not not all of them have
public references but yeah I'm not sure
how many of these I'm able to to
reference as public references so I
think on the website a few of them are
listed that I don't have them top of my
head at this point yes okay so the the
backend that we use for storing the
processes and the data models the forms
etc is is get based so you actually have
access so we we have both web based
tooling and eclipse based tooling I mean
it's not limited to Eclipse with any
through any IDE you can go into the to
the repository basically import the
assets that are there you can do
modifications and push these changes
back up as well that the back end is get
which gives a lot of additional features
like I mean different branches and
version control going back to different
previous versions etc as well so we rely
on get for that and and yeah have many
of the benefits that it provides out of
the box as well
yeah yeah absolutely so did the frame I
mean the the web tooling that we have we
called the uber fire project so that's
just a generic road bench whether you
can combine these different screens and
we just have a very simple one where you
can build this kind of angular
applications but you can build your own
screen and embed them or vice versa you
can build your own UI and I'm that some
of our screens we want to give that kind
of flexibility I just showed how you can
do it within the tool it's mostly for
demo purposes you typically I'm not
gonna come and develop your device
through through that so typically you
can just develop your application
communicate through the remote API and
then integrated with your application
either within our application or just
build build your own application
yourself yes yes that depends a little
bit of what you're trying to achieve
with your process so I my recommendation
would be like if you're gonna try and
model a process that you're gonna try
again end-users evolve and and and maybe
business analysts participating the
definition of the process you definitely
want to try and keep the implementation
details out of your process as much as
possible so for some of the more
technical stuff you might basically set
up a service that does that and then
have your process interact with that
service so you can hide some of the
complexity you might in some situations
you might just want to define straight
through processes for development in
that case having low level concepts or
implementation details in your processes
might not necessarily be a bad thing
so it depends on on what you want to
achieve but in general what we recommend
this is try to define the process at the
level of the problem that you're trying
to solve so try to define the concepts
at that level define all the data you
need for to solve that problem and then
have your process manipulate the data
and typically also invoke additional
services as soon as you try to do too
many complex things inside your process
you might want to consider splitting
that off either as a separate process or
splitting it up as a service that
basically is able to provide you that so
that the process that you're defining
can be kept relatively simple but some
of the complexities can be hidden in a
service which might you might want to
implement or you might want to define in
in a process as well all right any
further questions I don't think I see
any sir thank you all</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>