<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Modules in One Lesson by Mark Reinhold | Coder Coacher - Coaching Coders</title><meta content="Modules in One Lesson by Mark Reinhold - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Modules in One Lesson by Mark Reinhold</b></h2><h5 class="post__date">2017-05-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rFhhLXcOBsk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Birgit you make it do it makes it
alright good afternoon
hmm welcome to modules in one lesson my
name is Mark Reynolds I work on Java
many other things so this is a a skim on
the surface of of the module system and
the modular platform in the modular
modular JDK and all of that I am in
attempt to show you in in real time some
highlights what what does it mean to
create a module how do you make one
model depend upon another show you how
deeply integrated the module system is
into the platform and along the way show
you a few other things that maybe aren't
that tightly related to the module
system but they're cool features in Java
9 that I think I think a lot of people
don't yet know about so I'll highlight
those as well and hopefully at the end
we'll have some time for questions so
let's get going with our one lesson here
so I'm here in in a shell and you know
what one of the one of the curses of
working on the jdk itself is you pretty
much have to live on the command line
much of the time because when you're
working on the next version the platform
the old versions of the IDs don't yet
support the new stuff that you're
working on maybe you're if you're just
doing a new library yeah sure you might
you you might be fine but when you're
when you're doing deep surgery on the
libraries in the virtual machine and
changing the language then you're toast
so it's it's back to the command line
for you and that's kind of where we live
a lot of the time so I've got a good
look I've got a nine volt here JDK 9
build I can show you what the version is
I built this just a couple of days ago
so it's its latest version of the jigsaw
Jake prototype for a while Jake was way
ahead of the actual JDK 9 code these
days it's it's really pretty close it
runs a little bit of head and then we
then we bake things and
and through a bunch of tests and then
merge them in jdk 9 main line of course
we're trying to be towards the end of
the release so if those differences
really really small these days anyway
that's that's that's the version that
we're running and to start off just have
a really trivial application here it's
it's hello world whoa they see the
original but it's a bit but it's a
little bit different so it's a hello
world you know inspired by our brethren
in the land of JavaScript we have a left
pad method here kind of does the obvious
and and the main method takes takes it
takes some some input constructs a a
hello world string and it left pads it
and prints it out so pretty simple let's
let's just do the normal old compilation
thing here you see if I remember how to
how to do this what we got we got make a
random other stuff actually before we
get to that I need to show you a couple
of other things so one is J shell how
many people have heard of J shell how
many people have plight played with J
shell okay J shells cool try it out so J
shell
welcome to James shell what can you do
in J shell well you can even you can
type expressions it does math you know
big deal you can assign variables you
can ask it to do
tap completion on the variable axle it's
an instance of the string class and it
goes off in the string class asked well
what methods are here you can then do do
completion on methods here it tells me
that oh they're actually two overloads
one day there's one that takes a single
argument another that takes two
arguments press tab again to see
documentation and what does it do it
shows you a summary of the Javadoc
right there in the tool so X up sub
string two comma say 1 comma 3 and we
get whoo so ok so that it
tiny tiny intro to Jay Chou so we got
the string variable X what else can we
ask about X we can ask what its classes
we can ask its class
now what module is it in every class in
the module system you have your class
Madrid ek now is in a specific module
and this class draw blank string is in
the module called Java a base which
contains the foundation of the system
the fundamental stuff and and that
module object we can ask what its
classes it's an instance of a brand-new
type a new new type in the java.lang
package called module which is the
reflective runtime view of what a module
is so it really is wired pretty pretty
deeply in we can look at some other
classes let's import Java dot sequel
into RJ shell environment and we'll make
a timestamp say times 10 of 0 clip keys
mark J shell thankfully has history and
tab completion just like any any
reasonable shell so we can ask what T's
classes and it's module
Javadoc sequel has its own module it's a
different thing if you just have have
the base module you won't have any of
the sequel types if you if you're
writing a modular application and you
need to use sequel then you need to make
sure that somewhere along the line the
module that contains your code requires
sequel and we'll see more about that
later
already so that's J shell what else oh
right
so as I as I said this morning they're
there their lot there's lots of
confusion I see about being a people
thinking oh well Java 9 is not going to
run old code I have to compare
everything everything to modules or
there are lots of incompatibilities
because they they're hiding internal cat
classes inside of modules and stuff like
that so just to make a point here I have
here swing set to dart and in anybody
remembers the swing set demo back in the
old days when swing was a thing yeah so
swing swing set to what you know it's
the mother of all swing them as it demos
every swing component in every possible
mode this is the exact jar file from JDK
5ga dated 2000 for the star file is a
teenager Java not jsr yeah right swing
set to jar Katie canine build model
system everything and yes it it works
all that stuff is there we've got you
know the spaceman the kids so all the
babies that were born when swing was
developed in the early days there like
off in college now you know okay so
there there is actually a lot of
compatibility in nine it's not as bad as
you may have heard yes there are issues
but their issues with every major
platform release because we have to be
able to move the platform forward
alright so now let's go back to our our
hello thing so you've got this little
guy here named in Java let's compile it
Java CD classes
or source or go to I love I love tap
completion okay we do that jar it up in
the usual way let's put this in a Lib
directory jar but I keep typing that it
is some Freudian thing
openjdk and boom it works and we can
type
any arguments and it left pass the
string okay big deal mark you just made
a jar file this is like Java 101 why are
you wasting our time on this let's make
a little change we will convert this
into a trivial module how do we do that
well first crank up my favorite IDE
namely Emacs here's here's here's that
main class what we did so does main
classes down in its in its package
directory or org slash open JDK slash
hello we're going to put a new file
called module info at the root doesn't
go in any particular package directory
so but module info files are new thing
diseases these are where module
declarations go module declarations are
part of the language there they're baked
in pretty deeply to make a module you
give it a name or open JDK hello this
module doesn't need any other modules
actually it needs the baseball module
but since every module needs the base
module except for the base module we
actually don't need to say that you can
if you want but it has no value so we'll
just do that we've got a module info
this name is our module and now let's
compile bad again
unless classes okay cool we jar that up
whoops now what's in hello jar now we've
got module enjoy class module inside out
Java file is compiled by the compiler
into module info class file you can job
it you can run it through Java P I'll
just use the classes directory here and
it tells you well yeah that's set that's
what we expect that the requires base
was inserted to helpfully by the
compiler this this hello jar you can
actually you can actually run it as a on
the class path and the module info file
is ignored so just as I ran it on a
class path before I can do so again but
I can also treat that Lib directory as a
new thing the module path module path is
where you put actual modules in your jar
files that have module infos in them
although they're they're details that
I'll get it get and get into in my
second talk tomorrow so Java module half
Lib I'm going to tell it what module I
want to run JDK hello and I need to tell
it what class in that module to run and
that is me now okay
big deal but it but it is is sort of the
first baby step two we just took that
some that simple hello world app and
it's now a module and and now we can get
going and do some more interesting
things I love of other questions we can
ask about it in its in its life as a
module so we get we can ask we can ask
the runtime system okay look at the
module path and describe a module for me
and here it's printing out the runtimes
view of what that module is saying that
it requires Java dot base that was
mandated by the language spec it
contains a package or dead open JDK
hello and of course it's name is org
open JDK dot hello let's see what else
yeah okay so moving along just to make
to make life simpler I'm going to make
an entry point and we've been had we've
enhanced the poor old jar tool quite a
bit in this release with all kinds of
convenient things such as making
specifying entry points and in in the
module system the entry point for a
module is actually recorded in the
module info dot class file and now to
run that I don't need to specify the
class name anymore because there's now a
main class associated with the module
and if I ask it to describe that module
it will tell me well now I used to take
it should tell me what the main class is
there's a little bug okay what about no
all right so we've got we've got this
really simple module we've got a module
info we've got a main main Java
let's do refactoring refactoring is
always fun right so we're going to
refactor this into two modules right
since since you know again we know from
from from experience in the JavaScript
world left town really needs to be its
own module so we're input left pad in in
its own module and have have the
HelloWorld module depend on that module
so we'll see how module dependences and
how how exports work so let's let's do
some surgery first we've got to
rearrange some of it some of this these
directories here let's let's just arm
classes we're going to rename source to
org dot open JDK hello we're going to
make
a new source directory we're going to
move org open data Colette okay hello
into that and we're going to put some
some new stuff in there so in a modular
source tree every module gets its own
directory inside of which you find a
normal old package hierarchy so that
module info Java is right under the
directory whose name is the native the
entire name of the module and yeah
there's a bit of redundancy here because
the name is a module was the same name
as its principal in this case only
package but there you go it is the it is
the most sensible way to name to name
modules you pick them pick the main
package inside and that's the name of
your modules please use reverse DNS it's
just saner all right so let's ditch that
okay so we've got this let's say ways
we're going to we're going to sorry
first let's let's refactor the main
method the main class rather we're going
to take this out the left pad we're
going to make a whole new module org dot
open JDK dot txt or open JDK text let's
say powder Java
yeah
here we go package
I'm a class patter let's make this
public good static keep life simple now
we need a module info for this text guy
and that's going to go where's it going
to go right here in the root of the
module higher that this particular
modules package higher hierarchy so a
module gets a name whoops
there we go or OpenJDK texts now they're
there they're high-level there are three
fundamental things about a module module
has a name it has some number of
exported packages
maybe zero and it has some other modules
upon which it depends maybe just our
Java top base which is what you get by
default so the text module is going to
is creating an API for use by other
modules so it needs to export its
principal package so we write exports or
got open JDK not text it only needs to
have it up base so we don't need to say
that here
and now we ought to be able to compile
the text module let me make sure right
to do or create it
I'll just cheat here
right let's draw that up there's no main
class here oh oh dear
I know makes a directory first jar sure
we'll use that for you
okay so client we've got the classes
we've got the classes we got the Lib
here's text jar Scott that got its
module info now we can't run that
because there's no cuz there's no no
main but now we can compile the Hello
module which we first have to edit so
remember fundamental things about a
module it has a name it has exports and
it has to say what it requires and now
the Hello module is going to require or
open JDK text not not the package but
the module which happens to have that
pad that package of the same name
alright let's compile that
now let's save our work first mark
module not found or Gobind gatk text I
didn't tell the compiler where to find
the text module that we already compiled
so let's tell the compiler that the
compiler takes a module path just like
the runtime takes a module path I cannot
find symbol oh yeah that's 10 today - I
love static typing pattern left pad
I love static typing really I do import
or openjdk text patter okay what do we
got inner Lib directory but not free
have to make the jar market
Lib directory to jar files we can now
run
oh I forgot that mean let me just do
this
hello world and now it's actually
assembling at runtime it gets that it
gets the text module instantiates that
it gets
hello module in centuries that hooks
them up and it's running in modular form
so fidelity is is really important
fidelity across phases we've tried as
much as possible to make I mean not just
mundane things like the command line
options although it's the ability there
is useful too but the model system works
as much as possible the same way at
compile time as it does at runtime so
errors are detected in the same way more
or less in both phases and the error
messages are very similar so for example
in the Lib directory suppose I remove
Lib texts are well we actually actually
already saw an example of this but I'll
just run through it again but if I try
to compile the Hello module even though
I did have given it the module path it
says module not found or go for JDK text
because that jar file just isn't there
if I try to run the hello module I get a
similar message module open JDK text not
found it's not in the Lib directory so
you know that this is one of it one of
the great things about reliable
configuration it's not is reported right
away if something is missing it's not
like it's not like the class path where
if something is missing you don't
discover it until your applications been
up and running for hours or days you
know right away when something is
missing okay let's just recompile
texts model we'll get that back back
into place let's go into our requires so
here's the measures of the module into a
four for the hello module what if what
happens is we comment out this requires
can we compile it what do you think now
that's weird
Oh nuggets of two livability
it was confused by the classes directory
yep there we go package org open JDK
text does not exist because we didn't
require the right thing so the compiler
knows all about that too it's recompile
mmm
okay there is their variety variety of
other errors and another interesting one
is if you fail to export something so
this is exported API I could comment
this out recompile the compiler would
catch it I could try to run it at run
time and the run time system would
capture it as well alright so enough of
enough of that little little demo so the
JDK is we've decomposed we've used this
module system to decompose it into a set
of modules you can if you just type Java
dot list modules you'll get the entire
list there are quite a lot of them ooh
let's page that many of them they start
with the letters JAV a dot because
they're part of a Java SE platform so
they're you know they're official there
blessed by the by the JCP and all that
other all that other good stuff there
are a bunch of other modules they start
with jdk dot because they're part of
their jdk specific some of them are
internal they don't export any api is
outside of the jdk some of them are
parts of the jdk that you could actually
write code against they have AP eyes
that are say that our supported ins in
some sense but they're they're not part
of the standard so if you get a jdk from
from some from somewhere else that might
not have it there are quite a few
modules 7575 modules only only 28 28 of
them are are so are so-called standard
models and they're all on a graph right
wait you've got modules with dependence
relationships you can make a graph and
here's the graph so quick quick tour
we've got java java base at the bottom
there if you look at this kind of the
bottom part of the slide many of these
things are you know you can you can use
stuff down here without using stuff up
top right there is there's a module
called Java SE which gets you all of the
api's that are part of java SE and not
part of java ee there's a module way at
the
called Java scee which includes the
union so if you really want everything
that was in Java eight included
including all the EE stuff then you need
to use to use that module otherwise Java
SC is a somewhat trimmed-down set so
base is down here it's got troubling
object draw blank string IO slang util
net yeah but a bunch of security stuff
and they're all these other modules
sitting on top and then all the JDK
models many of the JDK modules per
contain service providers that they gave
to get hooked up to the Java the Java
modules through the service mechanism so
looking at this graph what do you notice
about it anything
remember graph theory 101 sorry it's a
dag there are no cycles right so this
module system doesn't allow cycles
that's a little bit of a controversial
decision but it doesn't allow cycles
because cycles in module graphs are
generally a really bad practice and it's
not just my personal opinion experts in
the field have been advocating this for
for quite a while so yeah no snow cycles
yet there are ways to induce cycles at
runtime if you really need to through
the reflection API but by default cycles
are are just not a thing another cool
thing and is they getting a little
little teeny bit off-track again but I'd
love to show it a Java doc knows about
modules now so the main Java doc page is
no longer a near infinite list of
packages it's actually a structured as a
list of modules you know there's there's
Java Donbass but you can scroll down and
you see all of the Java ones first and
then eventually some JDK ones that have
supported api's show up and and one of
the cool things about this about the
Java doc enhancements is you can go into
a module and the main page for a module
contains a partial module graph so it
shows you right there visually if you
use CORBA
then you're also going to get RMI you're
also going to get desktop because CORBA
and desktop polls and data transfer and
XML and of course everything ultimately
depends on Java based somehow so these
little graphs are really handy in the
Java Java doc to let you get a sense of
what's going on another really you know
quick ad for ultra cool feature in Java
doc Java doc has built-in search now
Java Script is good for something so if
I want to see like job what does the job
Lang model API look like I just typed
that and boom I'm there you don't have
to go groveling through trees and
clicking left right and everywhere you
can just search and there you go so
that's pretty slick
okay so there we go one last thing I'd
like to show you is is linking so in
Java 9 as part of jigsaw we've added a
thing that that Java has never had and
that is a linker you know CCC's always
had linkers right why didn't Java have a
linker well because Java is
predominantly is a very dynamic language
in terms of its runtime behavior the
module system imposes it just is
designed to impose just enough static
constraints that we can do linking is
one route this is one reason why it's
not you know it's not completely totally
lazy at least not by default so linking
let lets us deliver the jdk as a bunch
of module artifacts and you can link
custom images that contain just the
modules that you need and you know very
perhaps together with your own code so
here's this is a JDK I've been using
it's got you know I've been directory in
a lib directory and legal and other
stuff there's no arc our keys are in
there by the way the j-mods directory
contains a bunch of J mod files and
there's one of these files for each each
Java or JDK module in the system so
there's 75 of these guys so J mod is a
for is their not jar files J mod is a
different format it's specific to the
JDK it's sort of jar files on steroids
because for the JDK itself we have to be
able to handle you know things like
native code and legal notices and in
configuration files and lots of other
stuff and you just can't there's no way
to take an ordinary jar file and match
that in in a way that it actually makes
sense so J mods they write they are
based on the zip format like jar but
their data case-specific at least for
now maybe they'll get standardized later
if if there's a reason to do that later
on anyway given given that directory
full of J mod files you can run this new
tool called J link I'll be obviously
enough you give it a module path
you tell it what what modules you want
you always have to tell jailing jailing
where to start
we're just to start which you can just
make a simple image that has only the
base module in it and we'll put that in
let's say JRE yeah that should work all
right
it goes off in things for a while and
now we have our own custom JRE
here's the size of the entire JDK 9
build I've been working with 553
megabytes here's the size of the JRE
that I just made it's only 48 megabytes
it's got a bin directory but it doesn't
have much in Java and well keytool
because that part of the security stuff
is in the base modules I can run this I
can list the modules in it
woohoo all it has is the base module ok
we can go we can go further than this we
can let's go let's run Lib let's run our
hello module
that son
well anyway that should work but it's
not working and I'm not going to be like
getting real-time alright so we've got
these two these two Jerry's I another
cool thing Jalen can do is it can
compress so if you care more about space
than you care about time there are
additional options we can use let's say
compress compression - is the highest
we're going to use a minimal VM and
we're going to strip debug symbols what
am i doing
and we better put that somewhere else
because that will conflict so this is
going to do some compression it'll
strips strip things it'll use a
stripped-down virtual machine that
doesn't have things like JB MTI in it so
you can't monitor it remotely but maybe
we're going to stick this on a small
device and that doesn't matter so it
just goes off and it does some work to
them to them to them to them and our
compressor area is only 15 mix but it'll
run this it's Gaga drop a bass in it the
whole deal
and there you are okay so that's the
demo so far we've got about 15 minutes
left for questions so if people would
like to ask questions that's great
there's there's lots of information
available there are the jigsaw is this
enormous project has been going on for
quite a few years it's got one two three
four five six steps in in open JDK and
entire jsr in the Java community process
if you go to open JDK java.net slash
project slash jigsaw you can find pretty
much all the information that we have on
it this URL is out of date sorry it
should it should just say JDK java.net
JDK non Java deny will it will redirect
to the right place we we probably
publish the JDK 9 early access build
every week we publish the jigsaw early
access build every build so it's you
know whenever there is a whenever there
are changes in the jigsaw specific
forest those builds show up release date
well the scheduled occurrence schedule
says July 27th but with the drama
earlier this week I would say that
release date is in doubt I have I don't
know when the release will be hopefully
it will be fairly soon
don't believe a word I have said I work
for Oracle
questions please is there a hand mic
around or great or if you shot if you're
shy feel free to tweet me am reinhold
that'll work too hello over here yes -
is there an equivalent to the class
loader functionality for modules for
like dynamically generating classes in a
modular or something like that
is there equivalent to the class loader
function I'm not sure so so so the
module system actually cares very little
about class loaders and that that's
intentional as I camp as in order to
achieve good compatibility there are
lots of applications out there but do
lots of crazy things with class loaders
and we want them to be able to leverage
the module system you know as well as
just the platform itself so is your
question can you can you create a module
ok can you load a module dynamically
after the system has started up well do
anything dynamic currently I can see
that like even module contains a static
set of classes and obviously things work
but is run to download those classes at
runtime from somewhere or you know
designed I mean any no there so there
there's definitely provision for dynamic
behavior it's not as dynamic as OSGi and
that it's not a sort of sea of modules
that can come and go at any time in a
completely dynamic way instead in order
to get at to get a handle on the
dynamism so that we can do things like
linking and also report errors earlier
in time rather than later there's a
concept of layers so modules can be
essentially stacked in groups called
layers of Lea one layer it layers are
hierarchical so layers layers can also
be in the directed acyclic graph if you
just start up a system by default you
get the boot layer that's where all the
application models from the module taps
will be loaded and that's where all the
platform modules are loaded but if
you're if you're doing something
advanced you're creating you have an
application that they say has a plug-in
API and you and
user modules as as plugins to your
framework or something then you can spin
up a layer to load plug-in modules it'll
be no sub-graphs of plug-in modules that
relate to the model graph that's in the
lower layers so there's there's
mechanism for all of that and that's you
know that's intended to handle the
dynamic cases thank you where are we on
things like versioning I'm sorry hold up
closer where are we on things like
versioning so you know obviously not
like last patent hell at the moment is
different differing versions you know
I'm sure none of us here change our
public api's but once in a while that
seems to happen right so I need to stand
here so I can hear you so where are we
on versioning yes or you know so you
know I wanna patch ecommons with version
1.2 that's 1.4
right so so as I said this morning
they're jigsaw does not attempt to solve
the multiple version problem which is is
a really hard problem there number of
reasons for that
you know high-level summary if we did
you probably wouldn't like it at least
not with the tools that are available
now all of the tools that we have are
tightly oriented towards you really
trying to get only one version of
anything on the classpath right it's
going to take fundamental changes to
maven and other the other build tools to
move beyond that so that they actually
convey more of the model graph they
actually compute and allow those allow
multiple versions we also chose not to
put versions into the model system at
this time because it's really critical
for adoptions to be able for people to
be able to use the tools that they're
familiar with and guess what maven
Gradle IV you every tool that deals with
jar files today has some way of doing
version selection some way of doing
conflicts they're all different the
heuristics they use to resolve conflicts
are all different if we actually had a
version based resolver in jigsaw it
would you know it would piss off some
large group of people because it would
be different than at least one
maybe two of the major build tools and
and that would just be a huge barrier
barrier to adoption so it has been a it
has been a bit of a controversial
decision people think oh module system
you must have versions and well no we
don't but we chose that in order to
increase its approachability so that
people could use it sooner rather than
later eleven minutes left and sorry with
the same reasoning of version and you
said you can specify a version in the
module right you cannot specify every
minimum you can not specify the
reference all right so basically you can
have just one version of a module you
get you can have one version of a module
in any particular layer in any book so
if you're if you're in a more
sophisticated application and you really
need to load different versions of
things you can spin up layers to do that
and the API is actually quite simple so
if you're doing doing a plug-in
architecture you're writing you know
something akin to an application server
you know doing fancy things with stuff
at runtime you can you can load
different versions but we've but for now
at least we've left out to the API not
sure I'm not saying that we will get
there will never be versions in this
module system just that right now it
didn't make sense from an adoption
standpoint
so our coefficient so you've put the
module in the sort of is it like the
source level of the code right and so if
someone goes and add something you have
to go back and add something to the list
of modules that you're using let's say
someone goes back roof access code and
takes something out is there any
instrumentation that's being planned or
you expect connecting a debugging that
says hey you've got this extra piece in
your modules you don't really need this
you can get rid of it I keep a nice
clean module systems I say yeah I I
expect the unity the IDs and other
tooling in in do in due course will
offer that level of advice all the
informations there right you can you can
easily easily tell when when you're
exporting a package that has no classes
in it for example you can you can
identify when one module requires
another but never actually uses like
statically any of the types in that
module so maybe that's the requires that
you don't that you don't actually need
so do you know just as we have tools
that help clean up imports and stuff
like that I you know all the foundation
is there for tools to do quite a bit of
analysis on modules
this is against again this is related to
the versioning thing what did it make a
bit difficult for the CDC I process when
you don't have a versioning like I need
to have a live version there on my Nexus
and then I need to do another module and
how would you handle this scenario it
has to be packaged to do another module
I'm sorry the what process used an
acronym that I recognize now continuous
integration or continuous they deployed
like one play continues integration it
moves on with the snapshot version right
environment perspective right Phase II
maven or something so I found developing
two different models one more use
already live and I want to update that
module and versioning is not supported
right so how would you handle this
scenario it's up to your build system in
your and your CI system to update the
model artifacts is needed just like they
do today for jar files so I not sure I
see a problem here but maybe I don't
understand the question okay so module
system ok I need to think about I'll
come back the I to acute okay yes I'll
be around catch me later
dum-dum-dum
hello could you go back to the to the
graph to the motorcross here we go
like for example I want to use Java SE
OTE I can also exclude a module like
Nova nope nope
SCE required requires core but if you
don't if you don't really don't want
CORBA course you want korvac on if you
don't want corba then well just need
don't require the SE EE module but do
require Java SE and java xml WS and Java
dot transaction and anything else but
only CORBA was pulling in so here you
can do that but we take it we take
consistency really seriously if module a
says it requires module B we're going to
go find a B and if we don't find a B
that's an ER and what are the like the
color the color coding of the arrows the
color coding of the arrows is a blue
arrow means there's an API dependence so
the in the java dot sequel module it
exports packages that contain types and
the title end and those those types
mention types in the java dot logging
module the grey arrows are are either a
pyramid a shinto pendants or it's an
arrow in the java dot base because
everything depends on java dot base and
would be boring to make all those arrows
blue is you know is it is it the optimal
design no probably not but so what's
there today
way down here wait wait for the mic
please so that the recording makes sense
so if if you would export the module
that you don't export models use for
packages if you declare a module declare
module that has an interface and that's
everything that it declared declares so
and so interfaces are low or a lower
level thing an interface or example we
just declare a patter interface you
would not actually implement it would
that be possible
oh yes yeah it in in in the in the
little text module patter could have
been an interface there could be an
internal class that's either say package
private or maybe in another package
that's not exported that provides the
implementation of patter patter patter
yet and and that patter interface could
have a handy default method in it say
that could go get that instance and
would you would it be a an idea to do it
as a separate module implementation
would that be oh yes you can totally
separate interfaces and implementations
you can have interface you can have a
module full of interfaces another module
with implementations of those interfaces
but that all just works yep
it's aerobics it's good for you so how
would you recommend to move from javaee
to jello 9 with with care and
deliberation just like any major release
so so there we put in what put in lots
of tools to help with this because we
know we know it's going to be a problem
1 1 1 fairly recent addition is there's
now a what what we've informally called
the big kill switch so we know that
there's a lot of code out there that
that accesses internal api's that are no
longer exported so so that's an illegal
access there the flag is creatively
called - - permit - illegal - access you
can you can run with that and and the
module system is essentially turned off
but it's still there enough that it can
report error messages so you can find
out which bits of code are accessing
internals and we we've tried to make the
error messages as descriptive as
possible so you can go figure out oK
you've got a class path full of you know
dozens of jar files you got off central
you can now diagnose Excel you could you
know which jar file has code into the
sass accessing which internal API and we
strongly encourage you go report a bug
against that project and ask them to fix
it or if you have some time on your
hands
submit a patch submit a pull request
whatever whatever whatever it is that
they want so that that's that's one one
useful tool for for migration one other
question I had was I haven't thought
this through so apologies victims names
me getting stoned at the end and with
you you never dependent a good viewer
good yeah this so with the dependencies
are now sitting inside the module file
was there a discussion about getting
with the import statements oh why would
we get rid of them the important
statement because import statements will
tell you the dependency that your code
has
at the class level both then say that
you don't really need that because
you're setting that at the package well
the library or packing level I think
they're I think there's yes you could
you could and the compiler could in a
sense infer what all the imports would
be based on the requires but I think
there's still value at the level of
classes and interfaces to control what's
coming in just to keep your life saying
especially if there are things like you
know to like class names that are
duplicated you wanna have some amount of
control over that and the two-legged the
tooling supports them as as supported
import statements for years IDs filled
fill things in for you automatically and
it's it's not that not that much of a
burden just to the make sure that in
this lineage right you export the
package from the model from the
application of the model that means that
you from the model that depends on that
model see only the interfaces exactly
that at the cleric and that right it's
right right if if module a requires
module B &amp;amp; B has a package in it then
coded modulation only use the classes
and interfaces in that packages B
exports that package if B does not
export that package suppose you have the
interface that you have internal and you
don't export that long it means that you
use that internally yes if you in
command that one and that but it's not
visible
absolutely well necessary okay careful
it's not only is it not visible it's not
accessible which is a much deeper
guarantee the visibility is very weak
guarantee communing the same old info
declare Asian declare several models no
no no various so it's a module
declaration declares only one mom
different exports you in this end oh
yeah yeah well yeah you can export many
packages you can require many other
modules
there's also provision in the language
for services but that's a more advanced
topic but yeah there you can serve you
certainly do those kinds of things all
right time is up thank you very much
I'll be around just later if you have
questions
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>