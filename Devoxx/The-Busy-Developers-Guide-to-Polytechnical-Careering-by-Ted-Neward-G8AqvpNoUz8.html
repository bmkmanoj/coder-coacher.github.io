<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Busy Developer’s Guide to Polytechnical Careering by Ted Neward | Coder Coacher - Coaching Coders</title><meta content="The Busy Developer’s Guide to Polytechnical Careering by Ted Neward - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>The Busy Developer’s Guide to Polytechnical Careering by Ted Neward</b></h2><h5 class="post__date">2017-05-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/G8AqvpNoUz8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Birgit you play kit do it make sense
yeah this talk in particular was one
that the the devoxx conference
organizers program committee explicitly
requested because I've been known to
talk about a lot of different languages
and platforms over the years and so they
said hey you know would you be willing
to talk about you know polyglot and well
the problem with the term polyglot is it
only addresses languages and actually I
talk about a lot more than that so I
said okay how about we expand it
slightly and they said sure and and
let's talk about like how often you know
how do you manage that as a career I
said okay cool Polytechnical career ism
and they said what I said perfect that's
the title we're going to run with that
that's me by the way in case anybody
cares anybody care nope moving on so
what the hell is Polytechnical careering
well to do this justice really I need to
talk a little bit about the whole notion
of Polytechnical right because as many
people will tell you poly is good right
y'all got that that's good
um Polytechnical sort of embraces the
idea that in the beginning there was
this language called C and everybody
used it and everybody was happy the end
right yeah if you've been around in the
programming industry for more than about
five minutes you know that we've never
agreed on anything except maybe that the
idea that we don't agree on stuff means
we need to build additional stuff right
there's an xkcd to this exact effect
there are sixteen competing graphics
standards we must build one to unite
them all next panel there are seventeen
competing graphic standards yeah we
never agreed on anything and it's been
this collection this hodgepodge of all
these different languages all these
different data storage tools all these
different platforms all these different
things that are out there that people
can make use of right the platforms I
mean you can go this far back
the early 70s may interest you to know
that Java was not the first mainstream
platform that actually made use of an
intermediate like code format that was
then compiled on target platforms that
distinction actually belongs to Pascal P
code was the what they called the
bytecode format back then and nobody's
quite sure whether that stood
specifically for Pascal code or pseudo
code just everybody called it P code but
that dates back to like 1973 anybody
here born after 1973 show of hands come
on yeah I was born in 71 so it's all of
you yeah all of you are younger than the
ideas of computer science that are
expressed in the Java Virtual Machine
doesn't that make you feel young and
stupid the alternative is to feel old
and smart I'm not sure which is better
honest I'm really not there are three
Poly's that I will frequently refer to
polyglot of course is the term that many
people will cite first of all Niel
floored as far as I know is the first
one who coined the phrase polyglot
programming specifically specifically
the idea of using multiple languages and
then I did a little bit of Latin
research and discovered that Pali
preclude many storages the preclude was
actually the name of some of the jars
that they stored wine and other stuff in
and then Polly creppy dough many
platforms foundations because quite
frankly as a developer I have found that
having a range of software technologies
at my fingertips is a very very useful
thing to have so without spending too
much time in these guys polyglot the
idea that basically we've always had
multiple languages that we could work
with now to be fair like really the
world agreed on C a long long time ago
and not so much that they agreed on the
language C as much as they agreed on
some of the standards that C implicitly
set specifically if I have a library if
I have an executable when I get ready to
invoke a function it is described in
this way
and the parameters are passed in this
way and the return value comes this way
and as long as we all agree to that then
any language could make use of any
library that was compiled potentially by
a different language but usually by the
C compiler as a matter of fact some of
the very earliest languages were
actually sourced to source transpilers
this is actually how c++ got started the
si Lang compiler per se back in the
earliest days when garna true Strip was
first working on it was actually a
transpiler that took C++ source and
turned it into regular C source which
you then compiled with the standard C
compiler of your chosen platform C is
the back plane against which a lot of
this stuff was built and that was useful
because it meant that if I was working
on a new language I could just leverage
those other libraries and we we lived
that that lifestyle for quite a while
and then along came the web and the if
anybody was not convinced that the world
was clearly built out of multiple
languages the web most certainly
solidified that view because now you
have to in order to build a web
application today you have to know HTML
you have to know CSS you have to know
JavaScript
you have to know XML I mean you're like
really XML why do you need it well
because all the various support files
and so forth I mean you can't be a Java
developer and not you not know some
amount of XML because otherwise how
would you write your deployment
descriptors and so on and so forth oh
and by the way of course you have to
know Java right and then you have to
know Gradle the build scripts or you
have to know maven which is its own
disaster you have to know all these
different languages in order to build a
web application you are clearly having
to learn multiple languages there have
been some attempts to try to unify the
world under one particular language
there's an effort in the JavaScript
world's created platform called meteor
which is all JavaScript all the way down
oh but you still occasionally have to do
some HTML no there's got to be a little
CSS and you know sometimes they'll have
JavaScript on the back end in the front
end and and you know we could almost if
we splint really hard think about JSON
as its own storage format oh and by the
way when you store stuff if you store it
to a relational database well that means
you got in there some sequel or you got
to know some hibernate flavored version
of sequel or whatever your particular or
M library uses for ad hoc query and so
on and so forth excuse me
what's other direction the JVM in many
ways opened up an interesting new
development for a lot of people with
respect to languages because the JVM
itself was not tied specifically the
Java by virtue of the fact that we could
use this bytecode that could be produced
from anyone
there was nothing intrinsically Java
asked about Java bytecode uh than the
fact that you know it's produced by the
Java compiler as a matter of fact Java
one zero ships
somewhere around 1995 96 timeframe and
probably within three months general my
name of perf boxer has actually produced
a scheme compiler that produces and
produces Java bytecode and runs on the
JVM called Kawa K aww a very shortly
thereafter a couple of language
researchers actually produce a language
called pizza because nothing goes better
with coffee than pizza right I'm like no
dude that's for the beer virtual machine
you got that one clearly wrong but pizza
interestingly enough introduced some
notion of parametric polymorphism which
actually then was supplanted by Pizza
successor GJ also known as generic Java
which was then replaced by Java five the
guys who worked on Pizza were the same
guys who worked on Java generics that we
ultimately got as part of Java 5 so this
idea of the JVM being one platform many
languages
has been around almost since the
introduction of the Java Virtual Machine
itself and for a long time that that
knowledge was kind of left entirely in
the hands of the academics until a
gentleman sat down and said you know
what this notion of object orientation
is good but there are a bunch of
problems that doesn't solve very well
I'm going to actually look at a way to
try to capture cross-cutting concerns in
a consistent manner because he actually
worked on the common lowest common lisp
object system which supported a
full-blown meta object protocol and he
said that could actually get to be a
little too powerful being nice to be
able to restrict that let's create a
subset of that he called it aspects and
in 2001 Gregor Cazalas shipped aspectj
and that really opened Pandora's box
very shortly thereafter James Strachan
started working on groovy around the
same time martin oder ski starts working
on scala and of course everybody knows
how that story has since turned out we
now have what is it half a dozen popular
mainstream whatever alternative
languages on the JVM and that doesn't
count all of the obscure ones that you
don't even know exists yet meanwhile
over on the other side of the world out
in Redmond Washington where I live
there's this small software company they
make an obscure operating system you may
have heard of them Microsoft maybe have
you ever know now yeah the only company
that anybody knows from Seattle is the
Amazon or Starbucks
so yeah Microsoft saw what the Java guys
were sort of implicitly working on and
they made it an explicit goal as a part
of the.net runtime to have one platform
in many languages Microsoft shipped for
five if you squint really hard right out
of the box and that number has actually
only gone up since Microsoft worked with
a number of research universities to
experiment with doing various things on
the CLR etc etc we've always had this
notion of polyglot and now today with
the modern web platform and the idea
that anybody who knows
to make an HTTP request and consume JSON
well crap the world is your oyster you
got all these api's all these services
that you can consume directly regardless
of what they were written in or what
you're written in or anything HTTP in
many respects will enable that ultimate
level of interoperability that we've
always been searching for because
ultimately all you really need in order
to enable this level of interaction you
need to have some known common
communication medium whether that's in
memory or whether that's across the wire
we have to agree on some kind of data
frame format so that when I send you
five integers you understand that these
are big endian or little-endian or how
they're represented actually the frame
of format of choice today often is just
plain ASCII text and then some way of
being able to identify these things
which of course across the web is
generally just URLs but if we do this in
memory the C interoperability layer I
talked about earlier follows all this
same stuff right in inner communication
medium is basically the stack the
assembly language stack as long as
parameters are pushed in this particular
order etc that's your data frame format
and the identifier is metadata format
those are described in the file formats
of the executable files so as long as
you have these things your language in
my language can get along and talk very
very well now if we want to talk about
storage stuff um back in the really old
days does anybody remember a time before
the relational database the relational
database is sort of like this giant
blotter on all of computer science
history it's almost like nothing ever
existed before the our DBMS now it turns
out that there were several different
storage formats beforehand but this
gentleman by the name of EF cot aka Ted
as he was known to all of his friends so
he and I already have a lot in common
and I'm
grooving on that because this guy was
ridiculously smart he is the one who
effectively invented the relational data
formats the relational model he's the
one who laid down the spine for all of
this in 1969 and it took a while for it
to take off as a matter of fact you
could really argue that the relational
database doesn't hit its stride until
the 80s Oracle had several versions of
their database before it was actually
something that people could actually
trust it's hard to remember that there
was a time when corporations didn't
trust their data to Oracle but there was
a time and there were all these
different ways of representing data the
really funny part about the whole
relational thing is sequel right that
language that we tend to bury behind
programming languages that was
originally intended to be something that
was directly used by the non-technical
people who wanted to get data out of a
relational database the intent back then
was literally sit them down in front of
a terminal fire up sequel plus and turn
them loose just type in some sequel
you'll get your data back in a tabular
format what else could you possibly want
yeah because that'll work really really
well there are a number of different
data formats they usually had their own
storage format sometimes they were
referred to as network storage flat
files come from a lot of this this
historical time frame but the relational
data model kind of came along and reset
everybody's expectations by the time we
get into the 90s we finally have sort of
a universal agreement that relational
data is the only way that you can store
data it's the only way you can put
things in place as a matter of fact this
notion of the relational model is so
strong that again I live in Redmond
Washington I have a number of friends
who work at Microsoft and there is a
story I don't know if it's true or not
but it certainly sounds real to me
there's a story that says that Microsoft
decided to do a little bit of a
technical audit they decided to look
across a standard
stocke installation of Windows Vista I
think it was that was the operating
system when they chose to do this they
wanted to count the number of relational
database implementations not the actual
number of databases but the actual
database implementations that come out
of the box in a stock Windows Vista
install 17 17 different times teams that
Microsoft said we need to store data and
we're going to write our own relational
database like thing in which to start
and that's just out of the box we really
fell in love with the relational
database we really really did all the
world can be arranged into tables rows
and columns right there is no other way
to think about data other than tables
rows and columns and then came tags and
we looked at HTML and we said hTML is
really really cool and you know it'd
actually be really really cool is if we
had sort of an HTML like format but for
your own kind of data right and the
notion of and I'm not making this up the
notion of an XML browser was born the
idea that somehow people would make
something that operated like the web
browser but it would recognize your
custom tags and display however you
wanted to display that nobody ever
really explained how an XML browser was
supposed to work they just talked about
it right and then we sort of got into
the oh well XML yeah it's not really a
markup language like HTML it's not
really about display it's more about
data and then people started talking
about soap and wisdom and we kind of
know how that story ended fortunately it
did end but along the way people started
to realize that wow you know squares are
useful things in which to store data but
so are triangles because the problem
with the relational database format is
trying to store a higher
key in a relational format is really
really hard you ever tried to model a
company's org chart using tables and
rows and columns and then if you ever
tried to write sequel queries that can
actually join between the janitor and
the CEO to actually find how the path
between them goes and the interesting
thing is in the XML space we invented a
couple of tools first it was XPath and
then later X query in order to be able
to efficiently query this hierarchical
data structure and the best part was we
actually discovered along the way that
trying to move between objects which are
basically and a cyclical graph in some
places going from objects to tables
that's really easy right I mean it's not
like that's a ridiculously hard problem
that people have been trying to solve
for the better part of 20 25 years that
goes by the name of the object
relational impedance mismatch then
trying to map tables to hierarchies
that's even more fun and there was one
open-source project I will never forget
caster C a sto R caster JDO which was
this great open source project that was
going to take your object model turn it
into xml then take it over to the
relational database and turn it into
tables in order to take it back out of
the database turn it into triangles then
bring it back to your objects the
circles again because there's not going
to be any loss and any performance
problems doing that we kind of begin to
suspect that maybe different shapes to
data was kind of important and we began
to suspect that there were some other
issues that were appearing as a part of
the relational database world that we
needed to address Verner Fogle's is the
CTO of another small little known
software company in the Pacific
Northwest each node in the system should
be able to make decisions purely based
on local state if you need to do
something under high load with failures
occurring and you need to reach
agreement
you've lost what does he mean by that
by reaching agreement well specifically
there was this feature inside of a
relational database called two-phase
commit transactions how many of you have
heard of that show Vance yeah most of
you how many of you can explain it and
the hands go back down one in the back
to veins commit protocol is actually
really really easy to understand but the
best way to describe it is with
volunteers so I'm going to grab young
lady here in the blue shirt no no the
one that was on her phone trying to hide
it from me come on up what's your name
Kim come on up Kim now Kim one of the
interesting things about being
volunteered like this is it's better
with a friend so I need you to pick
somebody pick somebody that you also
want to torch I mean volunteer any day
anybody which guy that guy yeah the one
right in the middle of all of the people
so he has to like and and you could have
picked one in the very back so it would
take longer but what's your name sir
pull come up here pull so Paul and Kim
my volunteers the two-phase commit
protocol is actually very very easy to
understand because it's something we see
happening in Western civilization pretty
much every day and it goes something
like this
dearly beloved we are gathered here
today in the presence of God in this
conference to join together in holy
matrimony
Paul and Kim do you Kim take Paul to be
your lawfully wedded husband to have to
hold bla bla bla bla
if so respond by saying I do while Paul
recovers from his mortification at being
left at the altar this is known as the
planning phase in a two-phase commit
transaction I am actually asking each
resource that is a part of this
transaction to decide whether or not
they can commit to the transaction that
we're about to perform can they do all
the work in this particular case Kim is
thinking to herself well um gee I have
to now live with somebody who forgets to
put the
toilet seat down and my boyfriend might
have a problem with this or husband or
yeah exactly can I commit to this
transaction and she votes either yes or
no okay
now the thing of it is everybody that's
a part of this transaction gets an
opportunity to vote so then Paul do you
take Kim blah blah blah yes or no he's
got to do the same calculation he's got
a big man you know now I have to
actually come home at night instead of
staying out with my mates at the pub I
have to like I actually make sure the
laundry hits the laundry basket I
actually have to go out and buy a
laundry basket come to think about it
right because get admit it guys you know
when you're living alone there's no such
thing as a laundry basket there's the
floor and the chair and the bed and the
office right I mean you just get
whatever he's got to decide whether he
can commit to this transaction and if
they are databases which is the whole
point of this two-phase commit protocol
this is when they have to make sure that
everything will work they cannot run out
of memory
they cannot have problems writing to
disk there cannot be any schema
violations so they have to do all of
that deciding now and of course in the
traditional ceremony we also turn to the
audience if anyone knows why these two
should not be married let them speak
down forever older piece anybody want to
save these two you're screwed
therefore by the power vested in me as
an officially ordained minister of the
Church of the latter-day dude Judaism
calm it's the thing world's slowest
growing religion based on the principles
of the Big Lebowski great religion I
therefore pronounce you husband and wife
you may kiss the bride
yeah see the best part is I never
actually let them vote this is awesome
this is the commit phase having allowed
them the opportunity to vote I now have
to circle back because remember unlike
the traditional wedding ceremony this is
all being done remotely this is all
being done over Network lines and as a
result this means that Kim doesn't know
how Paul vote Paul is no Kim vote they
don't know how the rest of you voted
it's kind of like an episode of Survivor
nobody knows except me I pronounce the
results and I the transaction manager
say you're married the end and at this
point each of the resource managers flip
the bit that says yes this data is now
live now
remember when I said this is all
happening over Network lines those are
really slow as a matter of fact if you
do the math and you try to calculate how
much time it takes to go from one
machine to another across a heavily
congested land like what you might find
inside the data center you will actually
discover that it's roughly in human
terms about the same amount of time as
it takes to go from here to Pluto one
way so just asking Kim can you commit
that's two trips to Pluto asking Paul
can you commit that's two trips to Pluto
by the way using today's technology a
trip to Pluto takes about fourteen years
thirteen point seven thirteen point
eight something like that so imagine for
a moment I said to you hey I know a
great group up on Pluto let's go grab a
beer so you get in your rocket ship you
fly to Pluto you grab a beer you come
back that's 28 years I just got an OK
from Kim now I go to Paul 28 more years
now I go to you 28 more years that's 84
years and cumulated round trips so one
wedding ceremony and we're dead now
keep in mind that there are 9999 other
people who want to get married but can't
because they need you and you're in the
audience waiting for the results of this
action to complete each note in the
system should be able to make decisions
purely based on local state that is not
having to go remotely not having to talk
to other partners on the network if you
need to do something under high load
there are 10,000 people who want to get
married because for some reason this is
now Las Vegas with failures occurring
because these remote communications will
take a long time and failures will occur
just because internet reasons cosmic
rays who knows you ever browse the
website the website never came back
yeah failures occur in remote
communication and you need to reach
agreements you've lost
Amazon cannot do ten thousand
transactions every minute every hour if
everything has to be done using this and
this is something that databases do
really really well but if this is going
to inhibit our ability to scale we have
a problem did you did you kiss did you
you did get out go sit down god terrible
volunteers thank you see the problem
here was that did relational database
and its concept of acid transactions and
its concept of requiring agreement was
creating contention ten thousand
transactions cannot all happen if
they're all sharing the same resources
aka sharing the same database contention
is the enemy of scalability and scale is
the issue of the Internet there are
10,000 there are million people all of
whom want to use your website at the
same time what we were doing is we were
taking a lot of internal applications
and projecting them out onto the web and
as a result our ability to predict load
factors was dramatically reduced almost
eliminated entirely we needed to find
ways to be able to do a lot of these
things without actually having to do
this transact
no protocol around 2000 timeframe
gentleman by the name of I think it's
Julian Brewer believed he was a
professor at the University of Berkeley
University of California at Berkeley
yeah actually reasoned that their what
we're doing whenever we talk about
database systems is we're building a
database system that's based around
three key characteristics consistency
availability partition tolerance
partition ability if you want to use
that word instead as a database
implementer you get to pick to imagine a
triangle this is a three dimensional
graph if you will you get to maximize on
at most two of these things it's kind of
like as a software developer and you go
to your boss and you say boss
better faster cheaper pick two same
basic problem you can't have all three
you have to let me control at least one
of them the database vendors
historically particularly the racial
relational database vendors they
maximized on consistency and
availability availability is fairly
obvious the database that's out for an
hour while it does some internal cleanup
not going to be particularly useful in a
24x7 world like the internet consistency
of course the data is always accurate of
partition tolerance the database can be
split over multiple servers multiple
disk packs multiple whatever's okay well
the relational database world maximized
on CA the no sequel world that emerged
in 2000 starting with CouchDB and then
later exploding into a bunch of other
things said yeah consistency not so
important we actually need availability
and partition tolerance I need to be
able to grow to much much larger sizes
than what the traditional relational
database will support I need to be able
to actually spread my database load over
a hundred or a thousand different
physical nodes in the network and if I'm
trying to do two phase commit
transactions across 1,000 nodes forget
it I'm done
there's no way I'm going to be able to
make this work at scale now again once
we start talking about looking at all of
these different data tools where they
were talking about relational databases
whether we're talking about no sequel
databases MongoDB whether we're talking
about graph databases like neo4j and all
these other creatures we have to have a
lot of the same kinds of things in order
to be able to interoperate between them
I need to be able to understand again a
lot of this is basically communication
related stuff until I have that ability
to communicate between these two guys
however it's tricky it's hard now again
fortunately today most of these services
are relying on HTTP in some form of HTTP
data frame format XML JSON what have you
and meanwhile all the platforms
underneath major piece of software is an
operating system and operating
environment database under which various
smaller application programs can be
designed to run most of the time when we
were talking about platforms we were
thinking operating systems but it turns
out that there's a variety of different
platforms that have been around for a
while the closest we ever got to any
sort of Universal platform platform that
everybody sort of agreed on was back in
the day when Windows ruled the desktop
that was the closest we ever got but
Windows never touched the server in that
time frame and realistically speaking
Windows never mean they reached a point
of dominance but they certainly never
reached a point of universality there
was always those fringe groups some of
who are running Mac OS Mac OS 7
meclizine
michaelis 9 and then once Mac OS X came
out and Apple sort of rebooted the
company yeah at that point any hint that
Microsoft may have had some sort of
dominant monopoly was lost and now we've
got well we've got a ton of different
platforms
you've got the desktop operating systems
you got the server operating systems but
now of course we have containers docker
and its friends are making it much much
easier to in fact run in the number of
different places plus you've got the
mobile platforms
I can't wait for the day when I can run
docker images on my Android device
because you wait that's coming
somebody's going to come up with it and
invent that and make that work somehow
but then there's also the cloud the
cloud or definitely platforms the
verticals right you have various
companies that will actually make their
platform available for you to be able to
extend and use and that includes the
vendor platform Salesforce would
absolutely love for you to build
applications on top of their platform
and I'm not talking about Heroku I'm
talking about actually building things
that extend the Salesforce applications
as they currently set using data that's
stored in Salesforce assets at Sarah
Facebook Twitter
these guys are people they would love to
see you build applications on top of
their platform again in order to be able
to communicate we need some of those
basic communication factors in order to
be able to make all of this stuff work
and you're saying dude you just spent
the last half an hour going through a
whole list of stuff some of which I've
never even heard of why exactly do I
want to spend time studying all this
crap because seriously I actually have a
life obviously I don't because I'm
studying all this crowd but truthfully
there's a lot of pain that will come
with trying to live the poly lifestyle
to actually try to embrace all of these
things I mean the first obvious thing is
you have to have time you have to make
time somewhere in order to be able to
figure out how all of these things work
much less how they work together in many
respects the concern here is well yeah
if I spend a year say studying c-sharp
and then a year studying Java then a
year studying JavaScript and then a year
studying Haskell and then a year we'll
first of all that's five years that have
just elapsed and second of all what have
I really gained for doing all of that
and on top of that you know what
practical purpose does that really serve
because you know Haskell of the language
that compiles to native binary
executables but Java code compiles to
JavaScript
like those things work together
out-of-the-box so now I have to think
about how they're going to work together
if I'm somehow going to make make the
argument that knowing all of these
things is actually practically
beneficial and on top of that you know
the way in which Java approaches
designing a system is very different
from the way in which Haskell approaches
designing a system so what happens when
those two mindsets clash seriously this
this kind of feels like you're chasing
after dreams well the interesting thing
is in many cases it's not about directly
creating technical solutions in many
cases it's about changing your mindset
your worldview if you are an
object-oriented programmer if you grew
up knowing nothing but Java if you
started programming say 1998-1999 if the
first thing you ever wrote was the Java
HelloWorld nothing seems wrong with
public static void main perimeters
closed parens curly bracket and we
haven't even gotten to do anything fun
yet remember the first time you learn
Java especially if you'd never learn any
other programming language ever right
and you said okay well what is this
public class hello well class indicates
we're creating a class well what's a
class well class is what we use to make
objects well what's the difference
between a class and an object don't
worry about it well why what's this
public thing well don't worry about it
okay so what's this public static don't
worry about those either void well
that's the return type okay that means
that I'm going to be generating a value
no void means you're not returning a
value so I'm basically saying that I'm
not returning something yes so why don't
I just leave it out well you can't you
have to return something but I'm not
returning anything don't worry about it
now you write main well why does it have
to be called me it just does goddamnit
there's a lot of stuff that we kind of
took on faith back then meanwhile you go
talk to the Ruby developers and their
HelloWorld is put hello and you're like
wait why is Java better than Ruby again
oh yeah static typing yes because the
compiler actually will be able to
determine when you're working with
particular types and when you you know
when you're doing it wrong which is why
of course that when I put a string into
a list of objects I have to explicitly
tell the compiler that this is a string
when I pull it back out of that list of
objects because I know better than the
compiler does even though the compiler
is the static type checker that's
supposed to be saving me from making any
sort of type mistakes and the compiler
will be like oh okay sure that sounds
great man and then when it's actually an
integer it blows up at runtime but the
compiler is the one that's saving you
for making all of these mistakes right
yeah there's a lot of interesting
problems that start to emerge
particularly then when you as a Java
programmer walk up to a subject matter
expert and start asking them for what
are the business validation rules around
this and then you start discovering oh
well ok if somebody wants to rent a car
from us then if it's on a Friday and the
reservation extends across the weekend
we charge them twice as much Oh unless
they're a silver customer and then we
only charge them half as much Oh unless
it's over a holiday and then we actually
charge them twice as much which means we
charge them twice as much twice than
divided by half so we're actually only
charging them by twice as much Oh unless
their last name begins with a Z and you
got all that right you wrote all that
down and you got the exact order of
priority here so that the numbers come
out exactly correct and you actually
have verified this with all of the
subject matter experts and if you've
never ever wanted at some point to just
turn the keyboard and shove it at them
and say
you do it wouldn't that be great
seriously think about that for a second
wouldn't that be awesome to just turn
and give it to the business analyst and
say you do this because there are
actually languages where people are
trying to do exactly that there are
platforms that we're trying to build
that will let non-technical people do
exactly that this was kind of the whole
point of the domain-specific languages
model but that maybe maybe that's too
much right because at the end of the day
if we don't have to have programmers
then what are they going to do there can
fire the programmers and then we're out
of a job no that's not so good right but
when I go out hiring for developers and
whatnot and I'm looking for developers
all of whom have at least 5 to 10 years
of Java experience because trying to
understand Java trying to understand
HTML CSS JavaScript sequel XML Gradle I
mean you know you're not going to get
that right out of college right no
University teaches Java EE 5.0 right
much less Java EE 7.0 and it's really
easy to find senior Java developers with
at least five to ten years of experience
right I mean they're just hanging off
trees waiting to be picked instead what
we're getting is a whole bunch of people
who are making career changes learning
like JavaScript MongoDB and angularjs at
a coding Academy in nine weeks yes and
now this is your new team and you need
to work with that and the best thing is
to like throw them in front of in front
of a Java IDE here this is idea write
some Java code don't screw it up though
well Java is like JavaScript right I
mean they're kind of the same thing
because they're all based off of the
same name right yes Java is the
JavaScript like ham is to hamster sure
let's run with that awesome yes I'm sure
you will be a productive member of this
team actually if we have the ability
about this for a second the JVM
implementation of JavaScript on it was
originally called right now now it's
Nazz ORN because we they had to rewrite
it for some godknows reason why what if
a significant part of your codebase was
written in JavaScript running on top of
the JVM what if somebody actually ported
Express Jas to run on top of the JVM
what if you were the person that built
the necessary hooks between the
JavaScript business code that talked to
the underlying platform to do all of
that stuff that the JavaScript developer
could never possibly understand and now
all of a sudden you're gathering these
coding school graduates and filling out
the feet and filling out the jobs that
you couldn't find senior Java developers
to do how popular would that make you
with your boss in some cases we don't
actually even want to run it through IT
we do want to run certain things past
the marketing department let them make
their own changes let them change some
of the stuff that they're working on
what if we built the application in such
a way that effectively all of the
business rules were written in some
other language that we the developers
didn't have to worry about it and we can
actually train business analysts once
they gather the rules to actually write
them themselves and plug them into the
running system in some cases we've got
these really really complex logic
problems anybody ever tried to schedule
all of the employees at a fast-food
restaurant trying to remember that
lawanda needs Wednesday off from the
time of four to six and fred has classes
on Mondays and Wednesdays and Fridays
from like you know two to seven and and
and and trying to put all that together
it's like the world's most annoyingly
complex Sudoku puzzle and there are
logic languages that do exactly that
it's one called Prolog that does exactly
that kind of solution
and in some cases it would be really
really cool if we had languages that
were absolutely produced specifically to
a single purpose like I don't know
Gradle I think about this Gradle is
basically a language specifically for
building software just like make was
just like rake is over in the Ruby world
SBT in the Scala world lining in over in
the closure world yeah having all of
these different tools that your
fingertips can actually make certain
problems a lot easier because in some
cases the requirements don't fit in one
particular tool that we've got combining
them
excuse me combining them it's the only
way in which we're really going to be
able to accomplish anything meaningful
and so if you're going to have a team
with a wide range of skills because
that's a given
I mean you know not everybody is going
to be a 20 year industry veteran and
even if you had a team full of those
you're they're not always going to agree
they're not always going to have the
same background one guy will be like FX
C++ programmer one guy will be an X
COBOL programmer one guy will have the
same single year of experience 20 times
because all he did was basically write
Python scripts every day for whatever
reasons you need to embrace the idea
that there's all these different tools
out there more of them that we can
gather under our umbrella in a coherent
and consistent format the better off
we'll be able to adjust all the various
things that life will throw at us the
one argument I hear from a lot of people
is this could never work you're up there
on stage you're at a conference there's
no way that this could practically
happen there's this guy in the United
States we miss him terribly
his name was Barack Obama nine years ago
he decided he wanted to become the first
black president of the United States and
a group of people threw together and I
do mean threw together
in five hundred and eighty three days
from start to finish
ten thousand requests per second two
thousand physical nodes three data
centers one hundred and eighty terabytes
eight point five billion requests none
of it was architected it was all thrown
together people with PHP background
people with my sequel background people
with Java background because remember
campaigns in the United States are a
volunteer effort they didn't get to pick
the kinds of people that they got walked
through the door they just had to do
with what they had
yeah it could never work tell that to
the Republicans so how do you do this if
you're interested in this Polytechnical
approach how do you do this the key
thing you want to remember is this the
t-shaped individual if we look at the
idea of the surface layer here being
this is the number of different
technologies you know and the vertical
is the degree to which you know them you
will don't want to you don't want to be
an I shaped individual you want to be
somebody who really really knows the JVM
to an exceedingly deep level I mean you
could Brian gets is a buddy of mine
we've spoken together on the no fluff
just stuff tour in the United States for
six seven eight years together know him
pretty well Brian and I were talking
shortly after he got to Oracle after
Oracle acquired son and Brian became the
Java language architect and I said so
dude you know when he's going to get
bored with being the Java language
architect he said sarcastically and when
you're going to like you know go find
something else to do and he looked at me
he said what else could I possibly do
seriously going from the Java language
architect to what you're going to become
a director of software engineering at
some podunk startup I don't think so
Brian is very definitely everyday that
he's in that role he becomes deeper and
deeper and deeper on the java language
now don't get me wrong that's not how
Brian's actually managing his career but
that's the danger if you become too
deeply vertical in some space you end up
getting pigeon hold you can never really
break out of that there's a gentleman by
the name of John Robbins in the.net
world he's known as the bug Slayer
nobody asks him to architect systems
they only call him up when he actually
when he can save them from some weird
production bug that nobody can figure
out the danger of being too deep in any
one area is you have no breath you can't
do anything else you need to have some
breath to it you need to study some
other things now you can't go deep on
everything you don't want to be the
block shaped individual because nobody
can really approach that but in order to
get to this you have to wake up one
morning you have to look in the mirror
and you have to say I'm going to do that
I am going to embrace an aggressive plan
of self-education your company will not
train you I'm sorry those days are gone
your company will not train you your
company may occasionally pay for you to
go to a conference and listen to some
long-haired hippy up on stage talk about
getting people married or whatever the
hell that was
that's not training that's teasing I
talk about all this stuff but let's be
blunt there's not a whole lot you can
gather in a 50-minute period of time
except how to get started and how to
dive a little bit deeper it's on you you
have to decide for yourself that you're
going to learn deeper on whatever it is
that you're excited by it has to come
from you and you have to be aggressive
about it you have to force this time out
of whatever else is going on in your
life you have to formulate what I call a
personal ontology for technology an
ontology is effectively a categorization
system so when I say Haskell Youth a
programming language functional right
yeah hey I know where that sits in the
world and I say F sharp and you say
what's that and I say it's an object
functional hybrid language and
ah ok so it sort of crosses into the
object and the functional world okay can
I write that on top of the JVM no no F
sharp is a dotnet language aha okay so
it's an object functional language for
the CLR there I've just basically told
you where F sharp fits in my world where
does that sit in your world you need to
start thinking about what the technicals
landscape looks like and how it's going
to embrace or engage all of these
different things you need to build one
of these for yourself that works likes
to call them technology radars and the
key thing here is you need to pursue
stuff that isn't just like what you
already do how many people here know
Java show of hands
great everyone of you who raised your
hand you do not need to learn c-sharp
because guess what c-sharp is Java more
or less well actually less well more
because P sharp has more features than
Java but never mind you don't have to
learn c-sharp you do have to learn Scala
or you do have to learn closure because
they are really really different hey
Mark no no no come on back come on I
needed you as a volunteer earlier what's
that
I need somebody without a voice that's
that's fine just stand here look pretty
okay Daniel no no please no that's
creepy taste them when you get to these
new technical bits you need to have your
own evaluation function you need to have
some kind of project in there just don't
do anything no this is what you get for
setting me up with a blind ignite
jackass
anyway you need to have some way of
being able to evaluate these different
technology bits what I will call an
evaluation function you know all those
to-do lists that people are building
right now in the JavaScript world don't
take that what now you're drinking in
front of everybody
just go go clearly you're terrible at
this you need to have some way of being
able to evaluate all of these different
technologies right the to-do list is a
little too small what's an application
that's important to you what's something
that's that's useful to you if you're a
member of a church could you build your
church directory in this if you're a
member of a sports team could you run
the league off of this thing instead of
set cetera
whatever that is it's got to be personal
to you because you're the one that's
going to build it using said technology
and the key thing here is if you try to
study everything you're going to
basically be running in directions and
accomplishing nothing do not mistake
motion for progress you need to be
focused on what you want to turn away
you may say to yourself self I don't
really care about the mobile world so
therefore I'm not going to study that
stuff or maybe I only care about Android
Nano and I don't care about iOS I'm only
going to focus on the things that are
critical if you run a team you need to
embrace the idea of Polytechnical you
need to deliberately hire diverse lead
secondly you need to establish a formal
dissenting position when people have
opinions you need to establish what's
called loyal opposition the dissenters
that will specifically argue with your
decisions because that's the way we're
actually going to figure out where the
edges are prickly was done this real
hats you need to make sure you couch all
of this in non-technical terms so that
we're focused on what's important in the
business world and lastly you need to
discover where the core business is and
where it isn't so that you can focus on
the important stuff which is to accept
that not everything is going to be the
same because quite frankly if we're all
the same individuals but there's there's
nothing interesting there's nothing
exciting it's all boring
Oh fine I'm done be that way shoo go go
don't you have a conference to run or
something
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>