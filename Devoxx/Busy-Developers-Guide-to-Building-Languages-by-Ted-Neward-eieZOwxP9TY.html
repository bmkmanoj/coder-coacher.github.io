<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Busy Developer's Guide to Building Languages by Ted Neward | Coder Coacher - Coaching Coders</title><meta content="Busy Developer's Guide to Building Languages by Ted Neward - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Busy Developer's Guide to Building Languages by Ted Neward</b></h2><h5 class="post__date">2017-05-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/eieZOwxP9TY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Birgit you play kids do it thanks s the
alternative title for this talk by the
way
was where the real geeks come out
because let's be really really honest if
you have any interest whatsoever in
building a programming language you're
kind of a geek and I say that in a you
know fond way because I am also kind of
one of you but this is definitely one of
those talks that you know I you have to
have you have to have a certain brand of
crazy to want to do this there's a lot
of interesting reasons why you might
want to do some of this we'll talk a
little bit about that but just to sort
of level set the expectations this
particular presentation is designed for
those who have been curious but have
never actually done this so if you've
actually like worked on a language
before or you know god help us if you're
actually one of the people whose
languages that we are using or even
talking about at this conference I
strongly encourage you to either bail
now because it will be incredibly boring
for you or come up here and help me give
the talk because otherwise you know or
sit in the back of you email write or
play solitaire or whatever it is you
know these guys are doing on their
laptops right world of warcraft ears of
the storm which neither you're actually
taking notes on my talk oh it's a blank
screen that that's okay yeah that's
perfect
that's about the level of note-taking
you should be taking my goal here
basically is to give you a primer to
sort of get you started so that you can
start to explore this particular itch
and it's a fascinating topic and believe
me fifty minutes in this room is not
going to make you an expert language
designer this is a pit with no bottom
alright once you go down this path
forever will it dominate your destiny
I mean come on how many how many
speakers can work in a Yoda quote right
as part of their talk because seriously
this is this is an area where people are
continuously doing research they are
continually exploring new ideas and
that's part of the fun that's part of
the fascination the other thing quite
frankly is now you get to walk up to
Brian gets and say hey dude we're peers
you own a language I own a language
you're like creating syntax I'm creating
syntax you have billions of users and
we're peers so um you know again this is
this is really intended to be kind of a
survey get you started and get you
introduced to just a couple of the tools
why would you even bother well quite
frankly this is one of the classics of
computer science if you are really
interested in exploring a lot of areas
of what we consider to be traditional
computer science discrete finite
automata madhva if you're interested in
looking at state machines if you're
interested in looking at you know levels
of optimization this is where a lot of
those people hang out if you're
interested in reading a lot of academic
papers from computer science again this
is where a lot of those folks hang out
so this is definitely an area where you
can spend a fair amount of time just
kind of getting to understand the tools
that you are using one of the things you
will quickly discover as you start
diving into the java world and you know
in particularly the alternative
languages on the java world is that
there's a lot of interesting
optimizations that compilers could be
making the Java compiler historically
has not done much language level
optimization at all largely because the
position that Sun held for a number of
years is that's really the
responsibility of the just-in-time
compiler that's inside the JVM and so
there is no optimization flag for the
Java compiler if anybody ever did C++
any old-school C++ developers yeah the
pain is still
right there admit right you remember all
the stupid little flags we had to throw
on the command line I mean you know you
if you are working on like HelloWorld
and C++ the command line to compile it
would sometimes be longer than the
program because you had all these
optimization switches or all these knobs
and flags and things that you could
throw and Java is like yeah Java C hello
Java
we're done here there is no optimization
flag there was one way back in like Java
one zero and it disappeared by 1.2
because they said yeah that's what
hotspot is for
why would you want to make those
decisions at compile time there are a
lot of interesting optimizations the
Java compiler could redo it the Scala
compiler for example has a whole number
of optimization phases that it goes
through before it generates the bytecode
what is it that they are doing why is
this interesting what could they be
doing differently what could be better
etc the other thing quite frankly is
that a lot of what we talk about when we
talk about compiler construction these
are techniques patterns may I say that
could be used in a number of other
places so for example I was working on a
project couple of years ago consulting
project where we were effectively saying
alright we've got like 4 different
disparate technology systems that are
producing some data we need to take that
data we need to extract it we need to
normalize it in some fashion and push it
into this other system so that it can
then come back and do a later round-trip
through an entirely different pipeline
and I looked at that and said oh yeah
dude that's basically just a compiler
pipeline and everybody looked at me like
what you want to build an entirely new
language for this I'm like no no no no
no if you think about the output of each
of those four different systems as a
flavor of source code we need to
normalize it into what is effectively an
ast which we can then emit and then push
into this other system and it was
actually really elegant it worked out
really really well in the long run but
unless you spend some time in this
environment when you start thinking
about doing data validation how many of
you have ever tried to
validate an email address on a webform
and all the various flavors of that you
know what that is that's a parsing
problem wouldn't it be cool if you had a
utility that can actually you can sort
of define a grammar once generate some
code and if for whatever reason you need
to start dealing with some particular
edge cases you modify the parser and now
that code that library if you will and
would it be great if you could
generalize that across all forms of
textual input or you've got a boss that
comes up to you one day and said maybe
this isn't such a big deal where you
guys live but where I live it's very
common for people to begin their
projects with an assumption that you
know all the world speaks English
because as far as the United States of
America is concerned all the world does
speak English because all the world ends
basically at the wall right there's
nothing beyond the wall right you know
the whole concept of Mexico is this myth
that Democrats use to try to scare
voters or something I honestly don't
know what what is going on in my country
but we'll worry about that later
point is you often will start a project
and then later realize that you know the
Internet actually does stretch outside
of national boundaries and now you have
to go through all of your source code
internationalize you have to actually go
find every place there is a user facing
string and replace that with some API
call to pull the localized string out of
some resource bundle would it be really
cool if you could have a utility that
actually did that for you because that
would be applicable on more than just
this project this is again effectively a
compiler problem actually technically
would be a transpiler problem
transpilers are those that take source
and generate source as opposed to source
that generate binary and once we start
talking about transpilers well who
doesn't want to build their own flavor
of JavaScript
I mean seriously Microsoft's got one
Google's got two the open source
community has got how many dozens of
different ones I mean I'm just waiting
for the day when
nobody will stand up and introduce a
gw-basic
to JavaScript transpilers matter of fact
even as I say that one of you will
probably google it and find that
somebody's already done it because
that's everybody's favorite thing to do
these days is to do these
source-to-source transpilers on top of
javascript there's some really
interesting stuff here that starts by
diving into compiler construction for
example you could build a state machine
write a lot of different problems inside
of software are constructed out of state
machines and you could build this using
all the various patterns and so forth
but in some respects you're still
reimplemented that pattern over and over
and over again would almost be nice if
there were a way to lift that to
abstract that out so you could create a
custom language that captured that state
machine I've actually seen languages
that have tried to go down this path
with varying levels of success but this
would be interesting to sort of extend
on top of for example the java language
or you have the traditional business
rules right you've got a series of rules
the company has decided that we keep
track of stock-keeping units using a
particular homegrown scheme that was
concocted like a hundred years ago by
the founders wife and they've been using
it ever since and it doesn't match
anything that anybody has ever done but
you now have to make sure that this
school type that you're using is laced
throughout the system and validated
properly and it would be kind of nice to
be able to express these rules in
perhaps a declarative format which you
then used as source code to generate
either direct binary code or perhaps
additional source there's a whole slew
of straight-up computer science problems
that we simply haven't solved anybody
who believes that concurrency is a
solved problem doesn't understand the
problem much less the available
solutions this is a really really
difficult thing to try to address and
lots of people are going around
trying to come up with different ways
but to suggest that we've come up with
the solution that everybody likes yeah
not so much even the user interface
wouldn't it be kind of nice if we could
express a UI in a little bit higher
level terms than tag right let me think
about that how many different times are
we going to struggle to try to come up
with some facility that would allow us
to perhaps I don't know reuse components
of you I how many login forms do you
have to build before you die as a
programmer
how many master detail forms do you have
to build before you retire that is to
say you died because fruitless places
we're all hooked we're all going to be
doing we're addicts we're going to do
this until it kills us right how many
different times wouldn't it be great if
I could start from some kind of base
concept and extend it not necessarily
traditional object inheritance but take
a user interface template customize it
in a couple of ways and then if we
modify that template that's
automatically reflected in everything
that we do elsewhere lots of people have
tried to go down this path and usually
they go they say oh this sucks and back
away and leave it to us to work with
designers to somehow meld these two
together at runtime in various ways
security how many people think security
is a solved problem yeah you've never
been to Russia have you yeah I wouldn't
be kind of cool if we could bring some
concepts of security directly into the
languages that we work with not just how
do I harden the perimeter but even from
the standpoint of here I have an object
here I have this concept that supposedly
all of us as Java developers we
understand very very well here is an
account and I would like to express in
Java code what capabilities people can
have when working with this account
imagine if for example we were to take
Java instead of having like a throws
clause we could have a requires clause
that states what role or what
permissions you must have in order to be
able to invoke this method access this
field construct this object we have so
many problems left to solve the idea of
oh let's create you know another Java
like language but instead of requiring
the semicolon we'll just make that
optional yeah yeah nothing that that's
not interesting there's a whole
collection of these what the aspect
folks called cross-cutting concerns that
we haven't even begun to address and
those are the kinds of problems that I
think could be very interesting
particularly on a relatively small scale
I'm not talking about let's create a
security system that solves all the
world's problems let's focus on what
your company does if you could create a
language you could spend six to nine
months creating an extension perhaps to
the java language that would in fact
save the rest of your team the rest of
your company thousands of hours of work
and ensure a degree of consistency
without requiring programmer discipline
to have to make sure they call the right
methods at the right time yeah that is
completely worth you ROI so there's a
whole bunch of things we can go down and
this is even before we get to the
concept of the domain-specific language
which of course is let's build a thing
for users let's build a thing that users
can use directly this concept yeah you
know we've experimented with it you know
we played with it there hasn't really
been a shall we say a reference
implementation that everybody can sit
down and look at and say oh yeah that's
how we should do DSL but we certainly
see this concept appearing particularly
in the stuff that we do for example how
many people here have ever used maven
show of hands yes
the maven support group you poor people
that will be held at the pub later this
evening how many people have used Gradle
how many of you prefer maven over Gradle
yeah Stockholm Syndrome is a real thing
folks
gradle is a DSL for expressing builds
it's a way to basically try to simplify
and remove all of that pointy bracket
syntax because pointy brackets they're
sharp they hurt they like you know poke
at your eyes and you know if you don't
feel that anymore it's because all of
the nerve endings in your eyes have
actually been burned out because so many
years of looking the guy who invented by
the way the guy who invented and the
predecessor of maven and the thing that
convinced us all that XML was an OK
language to actually use to express
builds do you know why he used XML Frant
he didn't want to write a parser
straight up honest to god james duncan
davidson i used to lecture with him on
the no fluff just stuff tour before he
got out of technology entirely and think
about that for a second the guy who
wouldn't flick to the ant upon us all is
no longer using it he bailed he's like I
got mine I'm out to pulled the parachute
and he's now floating somewhere over
Greece I'm not mistaken yeah because he
didn't want to write a parser so I
figured yeah XML you know I can kind of
make a case that it's semi sort of
declarative right if he had sat through
this lecture we wouldn't have to suffer
through 5,000 lines of pointy brackets
called a palm yeah he still owes me a
drink for that one lots of tools are
available for things that you can use to
build languages it is much easier today
to get started building a what the UNIX
community used to call a little language
that is to say something that is very
specific very purpose-driven okay the
little languages were often referred to
you know said OCH grap all etc these
tools were designed to sort of compose
in various ways so that you could just
plug them all together and in the UNIX
world of course we just string them
together using UNIX pipes streams of
text blah blah blah but we have a whole
bunch of tools we're going to be looking
at one today
briefly I'm not going to go into any
depth called antler which is a parser
generator which for many people is the
hardest part about getting started with
the language is writing the parser and
thinking about all of the possible edges
and so forth and once you've parsed it
you get it into a tree and then you
start talking about doing code
generation where we have libraries for
doing that we have ASM we have Java Syst
we've got some template engines there's
there's all kinds of stuff that we can
use these language tools for and these
language tools can literally take a
whole bunch of the heavy lifting you say
to me Ted I have no idea what the file
format of a Java class file is I say to
you that's okay you don't need to know
that a lot of these code generation
tools in the Java world will take that
off of your shoulders or again if you
don't want to actually generate the
binary out the other end you can do a
transpiler source-to-source or in some
cases you can just do a straight out
interpreter that's usually the easiest
way to get started
once you've parsed it and pulled it into
a structure just start running through
that structure and executing it directly
yeah it's not going to be the fastest
thing in the world but depending upon
your particular needs so what didn't
necessarily have to be fast particularly
if this is happening offline not as a
part of your running runtime execution
so fundamentally there are four parts
now this is kind of like saying in an
enterprise application there are three
parts front-end middle to your back-end
cool now you are all Java architects go
forth and build big systems yeah there
are four parts and within these there
are a whole bunch of interesting
elements that we can talk about further
but it starts with lexing and parsing
I'll go through each of these and what
that specifically beam's
but this is the act of pulling in the
source code into what we call an
intermediate representation some data
structure that we work with internally
because that will be easier for us to
write code against once we have that
intermediate representation then
typically there will be some level of
analysis in other words I want to look
at this I want to find opportunities to
do
perhaps some very simple optimizations I
want to make sure there aren't any
particular errors right if I'm trying to
add an integer and a floating-point do I
even have the concept of types but let's
back up if I want to add an integer in a
string what should I do in this case is
that an error is that not an error etc
the analysis step depending upon how
strict you want your language to be
could potentially be ignored you could
basically say hey I want to build a
dynamic language which means I'm not
going to try to do any sort of error
checking until I try to do something and
it blows up right I'm just going to kind
of do like the JavaScript you guys do
and just say hey I'll write code and if
it fails so what we'll just issue
another patch and then you know do an
NPM install and blah blah blah that's a
perfectly reasonable approach as long as
you've documented it and everybody knows
what you're going to do so the analysis
step is more or less optional depending
upon what you want to do now in the case
of languages like Scala or Haskell where
they actually embrace the idea of
compile time errors instead of runtime
errors that analysis step will be like
80% of the work across all four steps I
mean there is a phenomenal amount of
analysis that goes on in any of these
modern typesafe compilers and then
lastly once you've gone through whatever
analysis you need whatever optimizations
you want etc you need to produce some
sort of output that can then be executed
later if you're building a compiler or
if you're doing an interpreter then
you'll actually execute that
intermediate representation which again
is what Ruby does in the case of
JavaScript the node engine they do sort
of a combination of both they will
actually parse things into an
intermediate representation as part of
their analysis they will do some
optimizations but then they will
internally generate assembly language
and then that's effectively what they
will execute so you're not actually
technically interpreting when you're
running node you're actually compiling
on the fly every time ok and of course
this is what the JVM does as well they
execute that JIT compiled stuff when we
start talking about lexing and parsing
these are two separate steps within this
source input phase lexing is the act of
transforming input into specific symbols
that is to say when I look and see the
characters 1 2 3 4
I recognize that those 4 numeric values
together represent the concept of a
integer constant or let's actually not
call it an integer constant because that
assumes a whole bunch of other stuff
that's coming further down the line I
recognize those 3 or those four
characters as a single token now in some
cases some languages may actually extend
that concept so for example if I see 0 X
1 2 3 4 that's a token as well or if I
see 0 Oh 1 2 3 4 that's a token or if I
see 0 B 0 1 0 1 that's a token now this
particular stage we're not interested in
validating we're not interested in
trying to determine whether this is
correct 0 B in Java means a binary
literal so 0 B 1 2 3 4 that's going to
be an error but we don't know that yet
because our first step is to transform
all of this into tokens the second step
the parser will be to say as I look at
these tokens do they actually make sense
in some fashion lexing is the act of
taking the words and determining whether
or not they are in fact legitimate words
blue airplane sundae beer that's lexing
as opposed to XY z ZX that's not a
recognized symbol that we see in the
English language anyway parsing is the
act of taking those tokens and
determining whether or not they make
sense so if I say blue beer airplane
sundae period
each of those words is a legitimate word
in the English language combined they
mean absolutely nothing
Bigley for example would be a lexer
error because that is not a word that
anybody recognizes except yahoo in the
white house on the other hand standing
up and saying i created 10,000 jobs for
the coal industry that is a completely
possible sentence that may still fail
validation when we actually start
looking at this code in the later
analysis phase so you can start to see
how we break this problem down in
various ways we don't want to try to
tackle everything all at once we want to
actually take this in phases so that we
can deal with these each in each of
these individual problems have any of
you writing java code if any of you ever
forgotten the semicolon at the end of
the line right and the java compiler is
so helpful it will even print out in the
console output it'll put a little arrow
underneath where the semicolon is
supposed to go this is a lexing I'm
expecting a semicolon to be here well no
technically it's a parsing problem
because I could recognize that symbol
there I can see that the semicolon is a
symbol I recognize it in its absence is
the yeah these two there's no
punctuation between the two sentences
but it's a very simple parsing problem I
could figure out based on the context
around it that there should be a
semicolon there that's been one of my
great I don't want to say frustrations
but it's one of the best jokes about
Java job is this really annoying
language you know kind of like your kids
they know you've done something wrong
they can even point out exactly what you
did wrong and then they just walked away
and left the problem there you're like
why didn't you just yeah once we've
Lexton parsed once we validated the
parsing we turn it into some form of an
intermediate representation this is
often referred to as an abstract syntax
tree although in fact they are once you
start getting into deeper and more
complex languages there are definitely
two separate creatures the the ast is
the tree structure representing the
entirety of the file or the program that
you are currently working on and then in
some cases we will transform the ast
into a different data structure that's
easier to work with so for example if
you look at the LLVM toolkit which is
what Apple uses for all of their
languages they specifically have a
language called IR hi IR and lo IR which
are designed to be more easily optimized
so a language will parse the source turn
it into an ast they will often use that
for a fair amount of their parsing
structure and validation Hey look I see
these tokens and I see this is the
method call and you're forgetting a
semicolon here because we're going
through that AST that tree structure and
working from there then for example
Swift or objective-c we'll take that ast
and transform it into a high
intermediate representation so that we
can then start looking at it picking it
apart doing some loop unrolling etc and
then from there will often be translated
into a low intermediate representation
which is closer to the assembly language
that eventually they want to hit now
that's a very sophisticated compiler
structure if you just wanted to build a
simple interpreter you can often get to
the ast and then just stop and use the
ast as your intermediate representation
and as a matter of fact there's a
there's a very simple calculator
language I'll show you in a second that
we do exactly that we use the ast as VI
our analysis kind of talked about that
execution this is when you actually just
interpret what you've parched
now the drawback of course to
interpreters is that every time you run
them they have to go through the exact
same sequence of work we have to Lex we
have to parse we have to analyze we
transform that into the ast before we
can start execution and this is where
for example Java tried to take sort of
that middle ground and say yes we want
to execute dynamically talking about
Java 1.0 here we want to execute
dynamically but I don't want to have to
go through all of that lexington bla bla
so we'll generate an intermediate form
which of course we know as John
the bytecode and then from there we can
do some additional analysis we call that
the just-in-time compiler before we
actually execute what was generated the
other option here is to create something
that's directly executable by the
underlying platform okay this is usually
where you will generate something that's
directly executable I you you know on
Windows it's the portable executable
format that's the actual structure of an
egg's II which itself is actually
derived from the common object file
format that's the data structure that is
that many older unix's will use for
their executable files unix/linux
actually uses elf binaries there's a
couple other different formats and then
the CLR in the JVM today those are so
ubiquitous that if you pump out dot
class files well technically they're not
directly executable you need a JVM
ditto if you pump out a CLR assembly you
need the common language runtime you
need dotnet installed in order to be
able to run this but for purposes of
this conversation we can sort of assume
that they are directly executable the
runtimes those environments will
continue to process everything in a
basically a binary opaque format and
then again you can transpile over to
JavaScript if you want to go from source
to source okay the act of lexing
basically this is taking an input format
transforming it into an intermediate
representation that is to say a stream
of tokens okay so here right
those are lexing errors the first line
by the way is not any recognizable
English that I know of the bottom line
is of course that they all Lex correctly
but they don't parse because they don't
follow English structure time parsing
but bappa like I said all of this wow
that's a complete duplicate that's what
we call a cut and paste error anyway
once we've got that stream of tokens
typically we want to compare that
against what we call a gram
now whether this is formal or informal
there will be typically some written
spec it will either be in a word doc or
some other form of prose or there will
be an actual computer science language
structure that we can say my program is
made up of one of one or more statements
and a statement is made up of one or
more expressions and an expression can
be a variety of different things it can
be a constant value it can be a variable
declaration it can be a opening curly
brace with a number of 0 more
expressions inside of it followed by
closing curly brace this is often
expressed in some form of grammar format
the most popular one in some respects
particularly amongst the academic crowd
is EB and F extended Becker now our nor
format okay
this is often what you will see when you
start looking at some of the compiler
texts and the the parsing tool which
I'll show you in a second actually uses
that this is e D and F a format here so
if I've got a calculator here I'm saying
that input is made up of some whitespace
and expression and then potentially more
whitespace followed by the hard-coded
semicolon here an expression is made up
of whitespace the factor and you say
well why whitespace what is whitespace
to find as well in this case whitespace
is defined as space or a tab or carriage
return right again new line or actual
carriage return character this is
effectively to create the language being
non whitespace sensitive if I were
working with something like Python I
would actually want to track this a
little bit more carefully so I could
count the number of spaces that use that
as a way to determine indentation levels
and whatnot but this is basically saying
anything that's not like an actual ASCII
character that we recognize we just want
to ignore we effectively throw it away
as part of the the parsing but I still
need to recognize those characters
because they're present there in the
file I need to know what to be able to
do with them an expression will be made
up of a factor
and then potentially again some
whitespace and either a star or slash
and then another factor where a factor
well that could be made up of a term
with a plus or minus term and then I can
have a term with parentheses and if you
work through all of this and you start
looking at all of the permutations every
basic for mathematical operation
calculation that you did in grade school
can be validated by this format and so
if I have an expression one plus two
well the one that is effectively a
number which is a digit which does not
include a dot and it does not include an
exponent and it does not include a minus
here with another digit okay so I have a
one that's great of course digit is made
up of all of the numeric characters and
then I have some white space and then I
have the plus
well again factors says all right a term
is made up of either a parenthetical
expression or a unary negative
expression or a number so cool that
makes a term which fits here and then I
have plus and then I have another term
that parses if I just have one plus well
I'm still going to be expecting another
term there and the lack of a term makes
this a parsing error the grammar here is
designed to make it easier for us to
reason about what the language will and
will not allow and many cases if you
cannot create a cohesive grammar if you
cannot express your language syntax in
terms of a formal grammar there are
often going to be a number of really
weird edge cases that you won't catch
until it's much too late
interesting side note one of the most
popular languages that never actually
created an explicit grammar perl larry
wall never actually sat down and created
a formal grammar for the Perl language
in related news Perl recently celebrated
the 15th anniversary of the announcement
of Perl 6
they may have shifts nobody really cares
anymore because Larry actually when he
started working on Perl six he actually
said point blank yeah it's probably
about time that I sit down and write a
formal grammar for Perl just so that
everybody is parsing and agrees on what
the Perl language is and he gave up he
couldn't actually do it because there
are so many weird edge cases to the Perl
language it couldn't be expressed in a
formal grammar that is a major major
major red flag now in many cases what we
do is we take that grammar and we feed
it to a utility that will actually take
that grammar as source code and produce
parser code out the other end so that
you don't have to actually write
something that reads from an input
stream and looks at the character and
says this is a whitespace this is a
curly bracket this is a number let's see
if there's another number there is
another number let's see if there's
another number there is another number
let's see if there's another one oh now
we have whitespace okay that's a number
you shouldn't have to write any of that
low-level stuff that's there's tools
that can do that for you the antler
antlr another I can't remember what
antler stands for it's an acronym it's a
very well known parser generator that's
what these tools are called that is
written in Java but can actually express
a number of different output format
languages so if you're looking to build
a you're looking to build a compiler for
C++ you can use antler that will
actually emit a C++ parser and then you
just leverage that directly compile it
library it use that to parse your source
format and the rest of that work is done
in C++ the actual language of the parser
generator who cares there are older
tools called Lex and yak Lex is the
lexical generator yak was yet another
compiler compiler that date all the way
back to before many of us were born back
in the UNIX world and then well there
was weird copyright issues so the good
news
folks created flavors of the same called
flex and bison get it yak bison yeah I
don't make these names up and they are
they're very old-school I mean that's
what you know if you go talk to some guy
who's been teaching computer science for
40 years that's what he's using and you
know they work you could use them
they're quirky I don't particularly find
their source syntax to be at all usable
but again they are definitely very well
known a number of your classic text
books on compiler construction including
the dragon book which we'll talk about
the sec it will I think but the dragon
book still talks about using flex and
bison lexing yak et cetera okay there
are easily dozens of these different
parts of generator tools if you don't
like either Flex bison or antler there's
there's tons there's tons of different
ones you just have to do a Google search
and find one that speaks to you in some
cases you can actually use some
alternative format to do some of the
lexing and parsing if you don't want to
create a formal grammar some people find
that to be more awkward it implies a
higher level of effort than I really
want to put to this some people have
used reg X as an input lexer and parser
I if I'm going to build a language I
actually want to have as much support
from the tooling around me and again you
know you could if you so desired you
could follow the example of James Duncan
Davidson and you could use XML as your
input format but now people are
programming in XML do you really want to
do that to your colleagues think hard
really really hard interestingly enough
how many people have ever used XML
schema alright from way back in the day
why is XML schema written in XML so that
you could use an XML parser as your
input and to validating XML schema could
they have used another format absolutely
but there was a certain amount of meta
that just felt satisfying to the schema
working group to say yes let's use XML
as the input format to validate XML
which makes it all just nicely circular
and met and whatnot ironically enough
we're now starting to see certain levels
of JSON validation and schema formatting
and so forth and guess what they're
trying to use as an input format for
their schema formats because it's also
wonderfully meta in some cases we
conduct the parser altogether there are
certain languages and Ruby is
particularly good at this for creating
what's called an internal DSL Gradle is
another such language Gradle is actually
just straight-up groovy code
there's no parser per se you're actually
just writing groovy SBT which is the
Scala build tool same idea we leverage
the facilities of the language to create
an entirely new format or something that
feels like a new format doesn't feel
like a traditional programming language
but you have to do this in a source
language that has a great deal of
syntactic flexibility groovy has that
Scala has that Python not so much
particularly because of the significant
significant whitespace and Java not so
much
Java's syntactic format is actually very
very restrictive which is why we don't
see a whole lot of dsls written in Java
if you've ever worked with rake the Ruby
build tool you've seen a tremendous
amount of that Ruby syntactic
flexibility if you've ever used Spock
well there they actually hook the the
the groovy compiler if you will runtime
and leverage keywords and leverage
format in you know they've actually
found this middle ground between build
your own language and leverage an
existing one to say yeah will leverage
parts of the existing one and then twist
other things around in completely
different ways Spock was a really really
fascinating example of people using
languages to do a bunch of stuff a bunch
of implementation choices Ruby groovy
Scala mentioned all of those f-sharp and
bouff you're not familiar with those -
those are over in the dotnet world boo
is actually based loosely off of Python
but will actually let you hook the
compiler pipeline and do various
interesting transformations very similar
to some of the stuff that Spock
does talked about XML delimiter directed
translation that's basically CSV files
if you're looking at you know hey
expression comma expression comma
expression comma you're using the comma
as a delimiter it's a way of being able
to separate the expressions as opposed
to being sort of whitespace free which
is what Java tries to do syntax directed
translation partial Combinator's and the
parser expression grammars are where
functional languages will really want to
take you they actually want to construct
a grammar entirely inside of a
functional language it's a bit weird if
particularly if you're not a strongly
functional programmer so I wouldn't go
there right away the intermediate
representation again this could be the
ast this is where you verify the
correctness this is where you can apply
optimizations etc again there's
potentially an intermediate
representation but this is really for
more of the more advanced languages so
it can either be a tree structure or it
can be an actual textual representation
if you're really interested in IR look
at the LLVM compiler tool chain from
apple it's all open source and they have
this IR and it's it's not assembly
language but it's relatively close but
it's not Java bytecode because it is
intended not to run on top of a runtime
so it's this weird sort of half way
state between Java bytecode and actual
assembly language and it can be
instructive to just kind of see how they
look at the world when you do the
analysis oh good lord there are so many
thousands of things I could put here but
simple simple ones constant propagation
if I have a final final int x equals 5
why can't I replace every instance of X
with the actual hard-coded value 5 as
opposed to having to look it up each
time that's constant propagation loop
unrolling rather than doing the check
and then branching if I have a loop that
says simply go from 0 to 10 why don't I
just take that block of code that's
inside the loop and just repeat it ten
times that would actually be marginally
faster these kinds of optimizations are
the things that a language could do that
as a developer you could do but it would
make your code look really really
ugly in a lot of ways and that's just
the beginning of all of the different
possible optimizations that the
environment could make execution you can
typically take the intermediate
representation and walk through the tree
directly there are interestingly enough
some some environments some libraries
that are trying to make this a little
bit easier in the jvm world there's one
such called Dino Lang which was created
by a Atilla the Getty who is actually
also known for doing the work on the
NASA one javascript engine that showed
up in java 6 and later Java 7 and later
so Dino Lang is actually present in a
lot of what it's doing when you actually
run JavaScript files on your JVM the DLR
is the dynamic language runtime over in
the.net world if you've ever looked at
c-sharp and notice that they have the
ability to have dynamic types that's
because they're basically making use of
the DLR at runtime interpreter just take
the ast and execute it directly
otherwise you have to generate code
there are some libraries again for being
able to do this but again a lot of a lot
of good starting places to do a
transpiler go from some source language
to C or go generate Java directly there
are a number of tools to be able to do a
bunch of this stuff suit is actually a
research project that came out of France
string template is actually part of the
antler project for doing string based
template ID generation so if you ever
wanted to do the handlebars style syntax
that we see in JavaScript string
template we'll do a lot of that stuff
for you let's look at an example so I've
got a very simple calculator language
it's simple for operation calculator but
I actually want to be able to support
the idea of variables I want to be able
to say a equals five and then use a
later so if I've got this script up here
at the top here I just want to echo the
constant value and recognize it and we
see that here Here I am creating two
variables a and B notice there's no
concept of type here and notice also for
ease of simplified grammar I'm just
using straight integral types I'm not
bothering with floating-point
so a plus B times two well okay the
standard operation of mathematics says
that B times two that should be six
times two is twelve plus five makes 17
and one plus 2 that 3 notice the
parentheses to force that operation
first times three is nine any questions
hopefully not because otherwise there's
probably a grade school classroom that's
missing you write very simple simple
calculator all right and correspondingly
we have some very simple lexing
requirements I need to pick up numbers I
need to pick up characters for variables
write names I just need to be able to
recognize the difference between those I
need to recognize the assignment
operator that is to say 2 equals I need
to recognize the mathematical operations
plus minus multiply divide and
parentheses for order of operations
everything else would effectively be an
error okay now in the antler expression
format we take this lexing set up and
combine it with the actual grammar of
the language into one file okay what
they call a g4 file antler version for
previous versions use dot G for grammar
files so when they went to antler v4
they made some syntax changes so these
are g4 files you can see very easily
write moldy VAD sub those are just those
character literals right ID notice we
use basically a regular expression style
syntax and say an identifier is any
lowercase letter or any uppercase letter
any number thereof okay and then an
integer value is 0 to 9 plus now if we
decided that as part of calc v2 we want
to support floating-point operators we
would need to modify int to be able to
recognize an optional dot and any number
of integer values that would follow that
okay but because I'm just focusing on
integer values I don't need to worry
about that complication we also
recognize the newline because we're
going to use that as effectively an end
of statement delimiter so all of our
expressions have to fit on one line just
by Fiat I
language designer decided those well not
really me this is an example that comes
out of the antler guys Taren spar is his
name he's got a great book from the
pregs pragmatic publishers pragmatic
press sorry and he uses this as one such
example so this is not my example but
the language designer boom decided we're
going to be delimited by end of line and
then notice the whitespace and here
there's a particular antler feature that
says anything that's a space or a tab
character any number of those skip it
just throw it away I don't even want to
see it as part of my parts that's lexing
that will transform the sequence of
characters into tokens which are then
being parsed now calculate a program as
you saw going back here this is just
basically a series of statements and I
say statements because expression feel
the value so here this is an expression
but this collectively is a statement
this a equals five does not yield a
value if I want a equals five to yield a
value meaning will evaluate a as a part
of that assignment then I have to modify
the grammar and there are some again
functional languages which take that
position that I should yield a value on
every everything that we see so here the
grammar labeled expression that's just
the name of what I'm building a program
is made up of one or more statements
where a statement is an expression
followed by a new line or an identifier
with the hard-coded equals followed by
an expression followed by a new line or
notice the vertical pipes vaguely
reflect the notion of that ebn F set of
rules so an expression can be made up of
basically one of these two operators
with an expression here or an expression
here or it could be one of these two
operators with an expression an
expression and why do I need to
distinguish between the two because of
the order of operations or it can be a
straight integer value or an identifier
or a parenthetical with an expression
inside of it okay everybody
so far now I feed this into the parser
generator the antler too will build all
of the necessary Java files okay
and I then one of the key things about
the antler environment is it will
actually build that tree and it will
automatically generate some code for
using the visitor pattern to visit every
node in the tree so now all I need to do
is create an evaluation listener an
evaluation visitor that will effectively
as it visits each node in the tree do
what needs to be done well I just want
to build a simple interpreter so all I
need to do is keep track of context with
is sometimes referred to as the
environment that's going to be well in
this particular case it's a very simple
hash map of the variables and what they
currently store and I'll use that as I
visit each node to evaluate each node
which will yield a value that will get
returns to node above it okay yes I see
the time thank you dudes back there
going you need to stop you need to stop
I'm hurrying I'm hurrying we start with
the eval visitor here a map of string
and integer the string is obviously
going to be the identifier name the
integer will be its current value next
when we visit an assignment statement we
will simply take the value notice now
what we're getting here is a context
that will be the node in the ast so when
I have an identifier equals this
expression the ID will be the identifier
so this is a and then I will say I need
to visit that expression because
remember this could be something that is
a equals parens one plus two or it could
be a equals B plus C I need to evaluate
that expression as well now if that
expression is an integer constant
that'll just come directly back and
there's no additional work that needs to
be done so here I say I'm going to visit
that particular expression and compute
whatever that value is and then I'm
going to put it into my memory I'm going
to put it into my context and you can
kind of imagine how the rest of this
looks when I have just a straight-up
value well I just visit that expression
again it could be some some compound
expression made up of multiple parts but
notice the newline remember we were
using that as a statement delimiter the
ultimate result is to print that out
okay now if I've got just a straight-up
integer value take that value and return
it again if it's just a straight integer
node I just evaluate that value and
return it to my parent I don't know how
this is being used it could be used as
part of an assignment it could be just a
constant living there on the statement
by itself I just need to let whatever my
parent node is I need to let it know
what that value is if it's an identifier
well again I basically reach into my
memory if it contains that key get that
value otherwise well we could error out
we don't recognize what a is or we could
just say unrecognized identifiers yield
zero again that's a language designers
choice here multiplication and division
gets a little bit more complicated but
again I visit the left hand side I visit
the right hand side evaluate those nodes
and then do the appropriate expression
multiply or divide ditto format video
for addition and subtraction lastly if
it's parenthesis okay we just drill
inside the parentheses and evaluate
whatever's inside there it's very
recursive once I've done that now I just
string together the pipeline oops I
don't have that displayed all right
I just string together the pipeline
pipeline by saying taking the input
stream feed that to the lexer feed the
results of the lexer to the parser feed
the results of the parser to generate
the tree interpret the tree by feeding
my visitor into the tree I'm done here
so if I really wanted to support
floating point values if I wanted to
support functions modify the grammar
modify the visitor to visit those new
nodes and evaluate it appropriately
release v2 and again I'm not doing any
sort I could if I later decide I don't
want to do interpreter I actually want
to generate Java source code I would
have a different visitor
to visit the ast each note if I wanted
later to generate straight-up Java class
files different code generator but all
of the upfront parts of this parsing
tree are exactly the same it's not that
hard to get started if you have an idea
of what it is you want to build you can
build a fairly simple language from zero
to working output in a day but like
anything it's going to take some time
and practice all right dude back there
is about ready to have a heart attack
because I'm keeping you from lunch so if
you've got any questions feel free to
come up otherwise I turn you loose
goodbye thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>