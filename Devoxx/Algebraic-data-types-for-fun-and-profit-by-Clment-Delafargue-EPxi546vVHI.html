<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Algebraic data types for fun and profit by Clément Delafargue | Coder Coacher - Coaching Coders</title><meta content="Algebraic data types for fun and profit by Clément Delafargue - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Algebraic data types for fun and profit by Clément Delafargue</b></h2><h5 class="post__date">2016-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/EPxi546vVHI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone and thanks for listening to
me during lunch
I'm Kimmel and today I will talk to you
about algebraic data types as we call
them ADT's bit easier to say so to start
I'm working at clever cloud we are an IT
automation company so you push your code
and we make it run in production either
on our public cloud or on premises we
have few customers one of them we like
it's devoxx
of course so if you want to discover it
or talk about a platform as a service
and deployment just ping me afterwards I
I will be able to show you stuff ok so
I'm on Twitter so if you have remarks or
question don't hesitate to put them on
Twitter so that I can answer them and
people not in the room will be able to
to see it okay so with that down back to
algebraic data types so that we three
words in algebraic data types type and
data should be okay for everyone so
algebraic data types are types we use to
represent data and we call them
algebraic because they have properties
they form an algebra I will explain that
of course so let's say I will start with
a an example let's say we want to model
a DNS record so we know that record has
a type either cname a quadruple a txt
stuff like that we have the domain name
for the record if it's a cname I get an
is and
it's an IP address or a like a record we
have an IP address and finally we have
TTL how long the resolvers can keep it
in in cash there are many other things
but I just wanted to keep the example
simple
so we have our record our class
representing our record and if it's a
cname then I will access the alias field
to do things with it if it's a record
then I know that we'll have ipv4 address
and stuff like that there is one big
problem with this modernization is that
you get an implicit subset of fields
it's not expressed in the code it's in
your head and if you lose track of it
then you will have errors at runtime
because you are able to represent a
state that doesn't make sense let's say
I put cname in the type and I don't put
anything in the cname alias and I put
ipv4 address so I got a value and I
don't know what it means it's supposed
to be a cname but it gives me an ipv4
address another thing is that you don't
have exhaustive 'ti with with this so
like in almost every cut basis I know at
some point you have case default in a
switch and it shows an exception because
the compiler wouldn't be happy with that
and the message like yeah it should not
happen because we somehow now know that
we have handled all cases and it's a bit
sad because like in your mind you know
that it's it's done on paper on
specification like you know you've done
everything but you are not able to tell
it to the compilers so you have to add
craft so a solution to to model that is
that to use algebraic data
types so algebraic data types you can
see them as either things called product
types and sometimes I will start with a
product type a product type is a type
putting two values of different types
arbitrary types together so you've been
bundling two values with each another in
some languages you can call them tuples
in other languages called records but
since we are devack's I will call them
pojos so a POJO is the epitome of
product type you have values in the same
in the values together in one value with
no behavior just values next to one
another and we call them product types
because if we look at types with mind of
set duration a product type is the
Cartesian products of your types so all
the possible values of a tuple are the
all the combinations of the values of
each type and it also works if we think
about the number of values in a type
more as we say it's cardinality for
instance if I have a tuple with two
boolean x' I know that a boolean has to
value up fully so a tuple with two
boolean as two times two four so it's
another way the term product means
something in relation to two product
types the other part of algebraic data
types called some types they are present
in less languages traditionally
functional languages but they're
starting to come in right swift stuff
like that a very simple version of some
type is available in Java
it's an enum you're saying it's either
this or this or this simple so let's say
I'm under moderating comments
comment is either pending or accepted or
rejected and that's all it is as some
type it goes a bit further and intimate
just attacking you can't have values in
in your enemy a some type is just either
a value of type A or a value of type B
and the same way we were able to look at
product types as products the same type
is a disjunction let's say I have a
status which has three values and a
boolean which has two so the combination
is five values so if I want to to model
my DNS records with some type I can say
I either have a cname with TTL a name an
alias or a record or something else the
idea there is that for each possibility
I'm having different structures but in
the end I know that each of these
different structures represent the same
thing at the NS record so it's really
interesting when modeling JSON objects
for instance where you have like
heterogeneous JSON objects which
represent the same entity in the in the
end you can model them with with some
types so Haskell it's quite easy to do
there is direct support in the language
declare a data type and then it's done
in scala it's a bit more verbose but
works as well you define case classes
stuff you will hopefully have in Java 10
and you have a silt right so silt right
is a bit like an interface but you can
extend it outside of the file so this is
what gives you the exhaustive et chaque
and the compiler knows that there is
only a finite finite number of values
and in some way you can even have ADT's
in
javascript javascript doesn't have type
but you can represent an ADT and the
structure of an ADT in javascript to one
give you type checking but it will give
you at least some tooling okay so there
is a problem in the in the first model
is a shinai I did is that TTL and name
are always in each case so we can factor
it out and have something which is a DNS
record and then let's say Dennis
recalled value saying it's either a
quadruple Wayne and stuff like that so
algebraic data types you can see them as
a tree of products and some types with
alternation and the property saying that
I was able to extract TTL and name from
each alternative to put them at the root
level it's a property we'll know well in
arithmetic it's called distributivity I
think we all know that a times B plus a
times C is equal to a times B plus C and
it's exactly the same with algebraic
data types and that's where they're
interesting that we can use we can use
equations our rules of rewriting that we
know well from arithmetic and directly
use them on types without thinking about
implementation stuff like that it's very
natural mathematical transformations
another one is commutativity so the
order does not matter it says that the
number of the order of elements in a
tuple is not a structural information
like you can go from one to another and
a good exercise is to look at all the
identities
you know format like saying a times one
is a a plus zero is a and look at them
in the realm of types so in this case
the one corresponds to an interesting
concept called the unit type which is a
type with only one value in Java you
would use right in Scala and other
languages you have proper type 2 unit
type saying I don't carry any
information I just have one value
another one is associative et and in
terms of types it gives you that you
have the right to nest arbitrarily your
tuples or split up your these junctions
and this is a fairly common property in
in maths and you can just use it to to
do your tight immobilization without
thinking too much about it because it's
something you you know and just to
finish my favorite part it's not really
about algebraic data types with an
extension the same way we so product
type as Cartesian products we can see
functions so function from A to B it's
somehow equivalent to B to the power of
a so if you count the number of possible
function then the number of possible
function from A to B is equals the
number of elements in B ^ elements in a
and this as the properties and exponents
are really interesting in terms of types
so we know that C ^ a times B is equals
2 is equal to C to the fourth B and that
to the proof a and if we look at it in
term of types it's an really interesting
property so let's say I have a function
of a a a and B - C and this property
tells me that it's equivalent to a - B -
C and you may know it as curing and I
think it's a good way to get an
intuition of why curing works and why
it's useful so what I did and why I
encourage you to do is that like look at
all the properties you know an addition
and multiplication and try to see
how what do they mean in terms of types
and when you're comfortable with going
back and forth then when you're modeling
your entities and your your objects then
you were able to to think about
mathematics and then go back to the
realm of types and the mental overhead
is way lower so you're able to have a
good intuition on what kind of data is
equivalent to another one and when
you're modeling it can help you a lot
thanks for your attention and if you
have questions I have one minute left so
quick question and then we can discuss
afterwards thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>