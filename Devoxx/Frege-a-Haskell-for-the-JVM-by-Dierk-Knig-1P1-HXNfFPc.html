<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Frege, a Haskell for the JVM by Dierk König | Coder Coacher - Coaching Coders</title><meta content="Frege, a Haskell for the JVM by Dierk König - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Frege, a Haskell for the JVM by Dierk König</b></h2><h5 class="post__date">2015-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1P1-HXNfFPc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">who in this room is a Java developer
okay thank you that was
calibrating myself to 100% who has ever
done any kind of Haskell or ml or camel
sessile Oh almost more than half of you
awesome we are addressing you Frigga is
as before the JVM because arguably
Haskell is maybe not the best language
designed but a masterpiece of language
design and the JVM is a masterpiece of
engineering and we are trying to bring
both together
my name is der könig
I work for canoe in Basel Switzerland
and for today I'd like to run an
experiment with you we are going to
program all of you because we haven't
programmed enough today and we should do
every day and we will use the best
computer ever which is your brain so on
to some dreaming of code I will read you
a program and I will asked you what the
purpose of that program is the program
has five lines of code and three
variables a B and C ok we're done I said
and we have value semantics and when I
say a equals 1 it means the the value 1
gets assigned to the variable a ok so we
start a equals 1 got it
again a equals one now B equals to C
equals B B equals a a equals C shall I
do it again I'll do it again okay a
equals 1 B equals to C equals B B equals
a a equals C what's the purpose of that
program a swapping of two values thank
you awesome
hmm swapping of two values is a rather
primitive operation and we need quite a
lot of sophistication to make that
running in imperative code so we stop
dreaming and try to engineer that
solution so how does it look like a
equals one so we have the memory
location for a being occupied by one B
equals to C equals B so a and B stay the
same and then what used to be in B the
value gets copied over to see like so
this is what happened in your brain you
know I'm reading your brain today now B
gets the value of a so a and C stay the
same but then the value from a gets
copied over to B and then again P and C
stay the same and the value of C gets
copied over to a well that's that's kind
of Li what happens around the
operational reasoning that
we do when we read the code but that's
what we do all day right we're reading
this kind of code and what happens in
our brain is this over here
and if this is difficult for you then
probably you wouldn't stay long in
software engineering we are a group of
people that have proven to kind of
master this kind of job it is it isn't
it test that you typically give to the
beginner in software engineering but
it's kind of hard why is it hard
well we have three different places that
we care about and we have three
different points in time that we care
about how does it come that we have
different points in time only because of
these operations of these assignments
when you have an assignment in your code
not the initial ones with only
definitions but when you have
assignments they introduce the notion of
time everything before the assignment
and everything after the assignment and
therefore we have in total nine
different places nine different states
that we have to care about now the
typical human and I'm not sure whether
you qualify for that has a short-term
memory of seven plus minus two you may
have mine I have five I make up for the
balance you know and that may be the
reason why I'm not very good in this
kind of test well not only is it a bit
difficult it is actually kind of
surprising in in the middle we have this
kind of state if somebody from the
outside looks at us this has sees an
inconsistent state in between so we have
to seal that somehow and even even
without the inconsistency yesterday you
said one and two and today you say two
and one are you lying to me or what you
know it's kind of difficult and two in
order to get our head around this kind
of changing state and doing this
rational reasoning we need tools booth
this kind of operation is the main
reason that we need a debugger there are
few more reasons but this is the main
reason just recently I have been
explaining this to my parents my mom is
75 years old my father is 80 years old
and they have no technical training
whatsoever and I have explaining this
you know but the Kaffee cap in glass of
water in changing things and they said
ah now we understand why this boy is
kind of weird and I said well you know
oh wait we we figured something else we
can do it differently and here it comes
we can use functions and what we do is
we take the a and the B and then we
leave it like so and never change it
again whoever looks at these two values
will always see the same state we do not
change the state at all never it stays
there since eternal times done
well said my father but you wanted to
see it swapped over right said yes
seeing it's not over is easy
so it took his classes and said well
imagine yet those present classes where
things just flip over and there you have
it and as many people can have as many
classes and look at this state in two
different ways one sees it flipped over
one only sees the first one one who sees
the second one one plus one times two
whatever and they never interfere if I
would have told you in this initial
example a comma B equals B comma a he
would have guessed a little bit quicker
for Peter so this is why we are here
the idea is that we want a program just
without assignments you know you can do
you'll be going for immutable state and
be applying functions on top of it so
assignments I'll glue it out we don't
use them anymore and assignments it's
just a special case of a statement so
which is in one go rule them out as well
and there's two ways of doing this the
blue pill and the red pill for all of
you that have not seen Haskell yet you
have only seen the blue pill which means
you know what we impose some discipline
on our developers we just don't use this
kind of state we are marking everything
final and we are marking everything
closed or var or whatever that is in
your language and we are not using any
mutation at all we are using immutable
values and you can apply this discipline
and the red pill is a new world we use a
purely functional language where there
isn't even an assignment not even the
syntax it is impossible to express an
assignment because since it's just
doesn't give it to you hmm
the question is um is that practical
well it can be really what this new
world this record is a good world is a
bad world just do we rather want to go
back to thee
it will be simple and easy blue one well
let's see I'll give you some code in
inflator which big it is it has before
the JVM as you already know and you can
follow up um you can follow along online
with the online wrapper try it out free
game - lang org by the way free game is
a bit difficult to pronounce in English
the German word the German name three
good and if you're not a German native
speaker you're allowed to call that
freaky if you want so here gaps in first
example let's define the function let's
say a function we're working in the
Drupal I just pretend to work in the
rental times a B this is a function x
which takes two parameters a and B yeah
the implementation is a times B
not-so-surprising yes hmm there seems to
be no types right we haven't given any
types is that untied is that dynamically
typed no we as we will see it statically
typed hmm how do we call such a fashion
well if we say x 2 + 3 and the the
notation for function application is the
most quiet notation that you can think
of the operator for function application
is white space very silent you know and
it gives us 6 good now how about this
type what type is x of what's the
signature of x if we ask the ripple
please give me the type of times it has
something crazy what could this possibly
be well let's get some help
first of all we said we declared no
types in the very beginning well then
when we did the function application the
the blank between x and two is actually
it's an operator function application
operator and it's left associative
therefore x two is the first expression
that we evaluate and whatever is the
return value of that will be applied to
three that's it so i i've given you the
extra parentheses that are superfluous
because it's left associative and now
for the typing the arrow marker which
denotes a function is right associative
so what it actually says is exactly what
we already inferred from the times two
which is that times two is a function
that takes in argument a and returns a
function that takes the other three this
one and returns something of the same
type
now there's something in the front
saying well this alpha that we have is
not just any alpha it must lie in the
numeric type class in Java you would say
it's an interface right the so-called
constraint and also as we can infer down
here like every function only has one
parameter we only we can only ever give
one argument a special thing if you read
this as a beginner the typical rule of
thumb is just you know the last one is
return typing everything before it is
just the arguments but this can leaves
you half a on your understanding to of
what's happening here and why it is
denoted as such let's proceed with this
times two over here we have seen times
two is a special thing it is a function
that it that takes a numerical value it
returns a function okay
how can
references it well this times too we can
even give it a name let's say two times
how can we call it we can say two times
three obviously and it gives us six you
see I left something out over here right
that's on purpose we'll see that in a
minute so if we ask two times four type
it says int to int Y into end and not
num2 num2 nom nom them well because we
already know this one is an int and all
the all the other ones must be in as
well it not subtypes of in so so must be
int from now on so how does it come that
we have this hole over here
well you could think of having a
parameter in there well the gray should
say it's not really there we just think
it's there well if we if we had it then
this would just be an argument like
normal and this would be a normal
function application as you know it from
Java right that with this kind of purely
functional language you can work with
your statements in your solution just
like with equations in mathematics you
know it's just like algebra and if this
was algebra by the way in algebra we
denote multiplication with a blank
character because it is a linear
function you know it's like linear
functions here and in algebra this would
be an algebraic equation we can cancel
out the X we can divide by X on both
sides this is actually what we do cancel
out the X you can do it mechanically you
can do it always in Haskell and inflate
leaving you with a nice two times
declarations which kind of reads nice to
x equals x to nice this kind of almost
partial application of a function is
often what currying written with respect
to has the curry
who worked in this area or shrink link
we did the theoretical basis on that
some people call it powerful function
application there are subtle differences
in that and there is but actually the
person who first published about this
functions that take functions as
arguments functions that return
functions loss bottle Vega in 1871 so we
used if function and just only part of
it now we use many functions and compose
them how does that look like well we
could say two times and give it as an
argument three times of two shook it up
twelve I hope so
but there's a second way of expressing
this and the second way is well we could
have a function six times which is just
the composition of two times and three
times composition is denoted with the
dot you can also use unicode character
220 220 which is the middle dot and then
you can ask six times two and you will
get twelve again so what's the type the
type of six times is in to end you
guessed it so what is the why can't we
write this as so because as you know
from high school measurement mathematics
this is somehow F of G of X and if you
have F of G of X you can make the
composition of F and G and apply this to
X so the composition make parentheses
over here and make this to X and here
would be the X as well and we can cancel
out the X right as we have seen in the
previous line and what's what stairs
over here is six x is just the
composition of two times and three times
so it's function composition functional
languages give you all kinds of extra
bits on how to manipulate functions
apply them partially combine them and so
on
so we can deal with this function we
have a language which is made only out
of functions what do we gain well we're
a fraction in mathematics can only work
on its arguments it cannot do any state
from the outside can capture any state
it has no observable side effects you
can call it as often as you want always
giving you the same result that would be
a pure function in mathematical choice
and we have that in figure how is it in
Java how's the Java method relate with
us so assume we have a method food that
takes a pair of types T in you and
returns something of type T what can it
possibly do well it most likely returns
the first element of the pair right okay
could it return now the yes of course
could it 49.8 exception yes of course
could add right to system out yes of
course could it do logging yes of course
could it right it through the database
yes of course could have read it from
the database yes of course could it
launch the missiles and start World War
II years of course in contrary in Frager
when we say we have a tuple with a pair
of alphabet n which returns alpha there
is only one possible sensible
implementation of that fact of that
function and this is returning the first
element meant because in first place
there is no null there is no null
pointer exception we cannot make new
values of alpha because we know nothing
about alpha alpha is universally
qualified for all alpha this is true we
cannot do anything else than returning
alpha well we could have endless
computation or sudden existential
failure of the world you know meltdown
of the computer something anything else
anything sensible yeah it can only
return alpha this is so strong
that you can actually write a program
that you feed it this signature and it
will spit out the only possible
implementation and there are such
programs you can infer the
implementation from the signature in
this special case you cannot always do
this
so in Java everything can possibly
happen we need to be careful not so for
pure functions in bacon it's kind of
nice if you have a pure function which
always returns the same value given the
same arguments hmm
you can catch the result and only do it
once it's got also memorization what you
couldn't wait well it's what's precursor
over here but you can wait until you
really need the value and do it lazily
too lazy evaluation or you cured well
the computers idle anyway you could
prematurely you could get preemptively
speculatively evaluate your values and
have them readily available when they
are needed you can evaluate concurrently
and this or in parallel and this is
guaranteed to be 100% safe no deadlocked
no race conditions and so on if you see
times two three over here and times two
or three over here in times two three
over here in terms of three over here
and your code you can refactor this in
do it in one place and this refactoring
can be done by the compiler because it's
clear to the compiler the compiler knows
it cannot possibly harm the evaluation
you could make I des that suggests these
kind of operations you know these kind
of refactorings safe refactoring if you
have anything else if you have like in
any other function let's say system
current time release and you have
multiple occasions and come and the IDE
says well how about factoring this out
in one place and only calculate that
once possibly not what you want right so
if you have purity you can apply
a huge amount of optimizations and I'm
waiting for the IDE vendors who will be
the first one to recognize this huge
potential programming can be totally
different in a few years if they only
recognize this potential hmm now in Java
right you're you have a refactoring task
and we sometimes do this it you know so
there's actually from one of our
projects the we should reflect that
question was can who which which kind of
method that we call and this calls next
method and next method the next method
where is the state change that
introduced the back so happy looking I
you have no idea where the state changes
so it took like a week for going through
the whole tree it's not only only this
list it is a whole tree of fraction
faults well and then you can find it or
you convince yourself that this kind of
got it's flat safe whatever you can call
it and currently okay and then you call
it concurrently because you have
inspected it there is no state change
and then tomorrow the next programmer
comes and makes a change there right in
to create beans string lobbying object
he has no idea about your assumptions
about this right in he will undermine
your assumption you have no idea of of
knowing and he has no idea of knowing
because of all the silent assumptions in
your code if you have pure functions you
can use the type system to tell you if
the type system and the very top
function would say you it's pure it is
guaranteed to be pure and it wouldn't
compile if anything down the call chain
compromises the purity isn't that cool
is that the silence of all the signs of
of miss believing Massa not quite sure
well this is what we can really do I
mean it's a totally different world we
are we have taken the red pill you know
now did we want to do this on the JVM we
have to interoperate with Java and Java
is to a large extent impure now if you
mix functional programming and object
orientation in one language or in one
paradigm whatever you don't really reap
these benefits of pure functions so the
flake approach is different and it's
best I know this the only language of
the JVM that goes that route do not mix
but make a clear demarcation let them
combine that them College other that
make a clear demarcation here is oo here
is FP calling from Java to figure is in
no issue right Vega takes Haskell code
compiles it to Java source code first so
with its valid Java source code and then
uses Java C to compile it to bytecode
you can at any time look at the
generated Java code and from Java you
can call that Java code of course if you
would ever want to know what is the Java
code representation of my current Vega
Haskell code you can in the repple I can
show you that afterwards M consult :
Java and it gives you the Java code even
pretty printed interesting is the other
way around so let's assume we would like
to use Java net URL encoded in code
which takes a string and encodes it in
URL terms right if you you'd like to
call it as encode diachronic
and you have this what is that a plus or
first and 20 or something and here this
unload thing so it that should do it
well encode is of type string to string
it takes the string it returns a string
it's pure it has no side effects we
encode this assumption in the type
system there are many other methods in
the in the JDK and in your code in every
pen Java there that are impure how does
that look like so it has no purity on
top here we'd like to call something
called Milly's and it is implemented as
java.lang system current time release
takes no arguments actually the unit
argument I'll get us to switch over that
and it returns not a long as in Java but
in i/o long this treats as it's an i/o
action it is something that I can
execute and when I execute it it will
give me a long and I can call it as
Millie's or Millie's but if I want to
calculate with this one like minus 1000
this will not compile because it I Oh
long is not along I first if I want to
do this I first have to enter this IO
type or IO context if you want you have
to enter the IO context and then you can
do your calculations but then once you
enter it you cannot escape anymore and
you yourself are IO Dirk for so right
it's unescapable and once you're tainted
it sticks with you in this kind this
kind of declaration is the key
distinction between fleiger and many
other jvm languages it's actually the
feature that got me sold on Vega said
well this somebody knows his craft who
has been inventing this so long story
short from if n you call from friggin to
Java you can do this that it's
can do never do it unprotected it's good
good rule in life never unprotected so
and you can you're just as explicit
about effects as you do in Haskell so
Haskell is between you you will feel
right at home even if you call into Java
maybe this is the key distinction right
all other languages on the JVM all the
popular ones go the route of saying well
we have these guarantees we have this
maybe compiled time guarantees or have
this runtime guarantees but once you
call to Java no guarantees whatsoever
how bad is that well it's pretty bad
because how often do you call into Java
how often do you call print 'ln how
often do you call something in Java
world all the time every second line is
like so right so this is the key
distinction once you have this you can
do global type inference I'm not going
into too much detail yet but we have
seen it with times two and three eight
an eight times B well how clever must
the system be that it can infer that
this would work for every single
numerical type not just for in stuff
just for floats but for numerical types
yeah it's pretty cool and that's global
I mean many languages have type
inference but it's always local you have
if you give me the parameter types then
I give you the return type or so
no no it's global if you don't want to
you don't need to give any types at all
almost right but at some point when you
give the type when you declare you type
the type in Forenza will again do its
work and will check your type against
his type and said well if you are more
specific that's okay but if you try to
be more generic than I infer it that's
not allowed how cool is that
so in the end since we have mutable
state since we have either since we have
something that the program should do the
main function is of course dirty the
main function is of type I or something
right if that is your threads deck from
thread from left to right and then time
from top to bottom so you have you may
have pure computations here and there
and they live in a sea of imperative
code so the color is on purpose and it
gets more and more dirty but the pure
computations are like crisp things yeah
but that we can hold on there are threat
safe by design how cool is that
and these bound ones that you cannot
escape they are called monads be brave
get over it they don't bite just the
name if you initially think a context
that's good you will later learn the
mathematical mechanics behind it so I'll
now like to to do some live coding with
you and that is the fizzbuzz contest who
has ever heard about fizzbuzz Oh like
hava well thank you so for the other
ones
it's the some people say it's children's
games some people say a drinking game
often used in interviews job interviews
so the question is please count 1 2 3 4
5 until 100 and for every third number
you save fizz and for every fifth number
you say buzz and if both comes together
you say fizzbuzz while the trick in the
interview is not telling these numbers
it is making a program that does it so
take a second how would you do it here
is an imperative solution in until
recently I would have created such code
myself right
it is a it is Java but that's an
accident so it could be any imperative
language I'm not pitching on Java you're
not at all right there are better
solutions in Java also so it's just
let's take it that's imperative well you
have to go from 1 to 100 firstly there's
this point when 3 &amp;amp; 5 come together it's
only every 15 ok
I have to take 4 they take that into
account and this must come first and
then either 3 or 5 this could be swapped
over and the last one is that I print
the number ok ok so far
who would have written it that way
nobody thank you oh oh you're lying at
me right now anyway so let's program
this in Vega yeah certain visible ok so
the idea is in an imperative language
there sorry functional language we can
distinguish between generation
generation a data structure and using
the data structure so typical data
structure that we can use if I see my
cursor would be the data structure of
natural numbers in the infinite stream
of natural numbers that we can write as
so while this raffle the read eval print
loop which is written in fleiger and is
using JavaFX for display is intelligent
enough for not generating the infinite
thing you know because of lazy
evaluation we can actually limit the
amount here so what we can also do is
we'd like we have them as strings ok
we'd like to have numbers so strings so
we are mapping a function over the list
of endless lists and the function that
we met over is the show functions like
to string in Java okay
numbers how does it look like okay
sounds good now we need an abstraction
for something like every third is a fizz
okay let's try with a list first one
second one third one is if his how does
that evaluate to us to that okay how do
I make an endless repetition of that
while I can cycle over it hmm that's
right this one okay cycle and we have
fished through the phases of his visa
fees nice endless infinite stream of
fizzes we give it a name the disease you
know I'm dizzy this is equals that okay
so for buzzes same thing right so buzzes
and now we are cycling I could use
repeat for or something but I'm actually
doing it this way making it buzz don't
forget okay so how does buzzes look like
this is the buzz buzz buzz buzz by the
way pay very close attention to what I'm
doing now it comes we would like to
combine fizzles and buzzes we have an
endless stream of hisses and we have an
endless stream of buzzes we'd like to
combine those into one into the stream
which contains fizzles and buzzes now
for that we have a function called zip
it's like zipper on your browser so it
takes two and you can specify the
function by which it should be a
combined that is called the zip with zip
with and not quite sure what's gonna be
the fizzes and the buzzes hmm what do we
take as the function for combination
well we could use string concatenation
that happens to be plus
how does it look like I'll give it a
name right away so this is our pattern
equals that and it's if we ask the
pattern there's a physicist buzz fears
fears buzz and if I have my cursor here
so right this position 15 it's fizzbuzz
okay that looks good now we have the
numbers remember and we have the pattern
and now we need to combine the number in
the pattern how do we do this zip with
okay hmm now comes an interesting
observation with skenvi clever trick
that was not mine but Kathleen Haney and
we can use an if for figuring out the
empty string and so that was my attempt
but he said you know what every string
that only contains digits is always
considered bigger than the empty string
and every string that only contains
digits is always considered smaller than
a string that starts with an alpha
character so actually if we only take
the maximum function we already we are
already set you know if we say fizzbuzz
equals lip with maximum the numbers and
the pattern fizzbuzz one two fits for
BuzzFeed seven Iron Fist sensor we get
the first zone so many the first 15 I
guess and yeah fizz buzzes kiss left up
anyway so now we have to print 100 of
those well we have an endless infinite
stream and now we can slide
out of that stream the portion that we
want and print it now for the first time
we do something that has an effect and
we do it with a function called for fora
takes something and then prints and then
death something to what we it read over
printing so what do we iterate over 100
oh sorry
we are taking the first 100 of the fifth
s right there you go oh we can drop 100
we can use any other kind of slice
that's the only piece of the solution
where we actually have an effect bless
you
so how does it look like in if we
compare here comes the thing you could
say well Dirk is playing clever tricks
here you know he made up this special
example especially so no I did not
actually the the these steps that I
showed you were exactly the steps that I
went through the first time I had the I
made this implementation in Vega it's
the natural thing to do anyway if you
compare these solutions here is the
physical solution you will see well in
the imperative code there are four
conditionals in the logical code there
is no conditional not the single one if
you would do the if thing you will have
one where do PACS come from in my code
from conditionals you know with this
five thing in short-term memory
therefore we have seven operators in the
imperative code we have the plus plus in
the logical code whereas you know plus
plus really is the function we use it as
a function not as an operator but I give
you that one okay the next thing that
level of ifs is 3 so cyclomatic
complexity
is three if not four because it's info
loop should actually be one higher
there is no nesting whatsoever
in the imperative in the logical code
the sequencing it's extremely sensible
to correct sequencing of these checks
right if you do the fifteen in the end
you'll have an error this you can do in
any permutation of the lines if you want
how about maintainability well go back
let's say we don't want to go to a
system out print land we would like to
put it in a database for places where we
have to change the code right not so
good let's say we have a new requirement
coming up every 7th number should be
DevOps ah can you imagine what you need
to do the multiples of 3 and 5 and the
multiples of 3 and 7 and the multiples
of 3 and 5 and 7 in the correct order oh
no I forgot the multiples of 5 and 7 you
know see that this is really really bad
what here well you have another cycle
you have another another zip it's like
business rules and it comes natural yeah
by the way when we created this code we
went like we did this first but makes no
difference so we created this one line
air to go incremental e at no point in
time do we have to go back and change
existing code at no point in time do we
have to go back and even compile it we
do not even have to compile the existing
code that we have first written this is
incremental development here any time do
any change you have to recompile
everything you have to touch every
you have to recompile everything not so
good for incremental development
incremental development is the big thing
because how do we create code one line
at a time and if we make non intrusive
changes only adding two things not
touching the other thing not changing it
not even recompiling it
what can we break nothing that is big
that is in my eyes the big thing about
functional programming that is kind of
under marketed so what is unique in
fleiger global type inference that we
have purity by default and if we opt out
of the purity it becomes visible in the
type system its explicit and therefore
we can detect purity by the absence of
the effects we are lazy by default our
values are all automatically immutable
because there are no assignments and our
guarantees even extend into Java calls
in all these points are in my eyes
unique to figure as a JVM language there
are other languages outside the JVM and
the few languages inside the JVM that
nobody knows of that have similar
effects bit here it is and why do we
care to have these kinds of
characteristics because it makes our
code robust the pure code robust under
parallel execution we can go safely
parallel without even thinking the
compiler can do it the IDE can suggest a
refactoring for doing it it is robust
under composition because of the values
because of immutable values when you
have a function error method in Java
that takes a string and returns
something how long do you consider
whether that is safe or not not for the
fraction of a second you know because
you know i given the string it cannot
mess with my string but technically it
can't with you nobody does it ok so
if do you have a method that takes the
list ah maybe it is something to the
list yeah if you'd pit of a person
object
oh maybe changes the person object
somehow you don't know it is robust
other increments as we have seen it is
robust it gives you a whole myriad of
new refactorings that you can apply by
equation or reasoning we can suddenly
reuse what the computational science
people have given us over the last 25
years and we have mainly ignored it if
you're interested in that kind of thing
I did run in a tutorial 90 minute
tutorial where a little bit more time at
JavaOne
it's it's available online somewhere and
I go into this little bit deeper at that
point and because we're in this world
where we have to we have no other chance
we have to work in a functional way
that's the best way to learn functional
programming even if we let her go back
into our Java whatever language we have
in the plier
or develop a discipline you know I I'm
pretty sure you want to do this anyway
so learning is much better than in the
pure environment it's like you want to
learn English go to England don't talk
any German word anymore for the next few
weeks if you come back later you will
have much better results then changing
all the time the best way to learn
functional programming and of course
it's just a pleasure to work with now
everybody says this about his language
but here it's true how do you learn it
well you can use any resource that
explains Haskell to you you learn
Haskell and you get Faga for free and
the two-for-one how good is that you can
use the box you can use the videos you
can use the massive open online course
by Eric Meyer you should sign up tonight
for that
because tomorrow is the deadline for the
first homework
it started mid-october you can still
sign up and I urge you to do this it is
a rather difficult it's not 101 it's
more than 101 but you will it's
difficult and it's tiresome that you
will learn functional programming I
promise so it's on the EDX platform
which is like for save up at
non-commercial concourses to the home
page and there's also some specifics
about fig and the frigate goodness free
ebook that you will find on the home
page as well and all the typical
channels are also listed on the home
page I am pretty sure there's gonna be
lots of questions first please provide
feedback in case you like the talk if
you didn't you know that P feedback
thing is not so important in otherwise
I'm happy to take questions and because
I know some of your questions you know
this brain reading thing from the
beginning I already compiled some it's
not the frequently asked questions
it is the frequent most frequently given
answers from here right
if Vega is implementing Haskell as in
the heckler report 2010 this is the
standard for Haskell and yes we have
permission from the Haskell people to
call ourselves
ESCO actually Simon Peyton Jones a lot
of people in the room will know him he
urged us to call ourselves Haskell
because he he said keep occupy even more
Hesco than the Glasgow Haskell compiler
because you're much more closer to the
standard we deviate from the standard
where it comes to what's called the
foreign function interface in Hesco
which is the native declarations in
failure otherwise take your Haskell code
run it in Frager pretty much unmodified
or only modifications with absolutely
obvious
um house performance isn't usual
question performance it's really good
because the Java code that we spit out
is mainly you know immutable data types
and everything's final and everything
static you know the the JIT just loves
it so we are roughly same speed as Java
when you do micro benchmarks you will
see quite a lot of deviation from there
if you want to learn more about that I
can dive into that compiler is
reasonably fast particularly when used
through the Eclipse plugin where
everything is hot and warm
you know the compiler is written in
Figure so it needs the JVM and if you do
you have JVM startup times and so for
the compiler so if it's hot it's better
we do have maven Gretel basil make
lining and integration for build tools
some people like to ask do you have in
have wrapped have array map to try yes
we have we call it hash map do we have
testing support yes we have quick
checkers in there in the exact same way
that it is in Haskell including the
shrinking thing if you know that so it's
it's rather advanced do you have
software transactional memory not yet
it's currently in the works do you have
more questions than that we have eight
minutes oh what a luxury yes please
so the question was how does it complete
people in the room who knows Carl who is
doing some Scala like everybody thank
you okay so what what's different so
everything that is unique in figure is
obviously different from Scala right
this is not meant as a joke this is mean
go back yeah here you see the main
difference Scala is is in it is I was
about to say an attempt no it's more
than an attempt it is it is an
achievement in trying to combine
functional programming and
object-oriented programming so you have
for example subtyping and parametric
polymorphism at the same time which
leads to all this covariance and
contravariance thing that I never quite
understood but maybe me you know so in
in Vega one testicle there are no
subtypes and therefore you have no
variance problems with that so it's it's
different
you can Scala is immensely powerful
right by mixing everything it also kind
of you know that adds to complexity
obviously and fig is the thing you can
combine it but keep it separate you know
object-oriented fine but here we do the
clean thing that that you know even even
these green ones with green blue ones
you can even see this as an architecture
thing you know have your java scala
closure or whatever over here and
there's Vega and you call it as a
service right this is the typical way of
integrating it passing at the string
returning a string passing at an array
returning an array in the end being pure
inside does it adjust the question not
fully I understand
yes sir more questions yes please
now take the first one so the the point
was well the GHC which has been the
classical Haskell compiler the main
compiler for Haskell there's many
compilers but it's the most advanced one
I would say thousands of compiler
options that you can use how does it
compare to the fake compiler well first
well there's there's a biggie page for
that but from the thousands literally
thousands of options that you have in
GHC which go far beyond has go report
2010 we pick one selection one
opinionated selection and implement that
one
okay so feature wise we are just a tiny
bit of this performance wise how how
fast is it now we have a master student
currently at canoe who's doing the
parallelism stuff and we have benchmarks
where take is considerably slower but we
also have benchmarks where fake is
considerably faster like four times
faster than native compiled Hesco two
times faster than native optimized Java
for excellent for the Mandelbrot set up
for example so this is kind of an exotic
data point but it gives you the feeling
you know it is it's not only from a
logical standpoint a good thing to do it
is also from an engineering standpoint
really well engineered you know we we
take advantage of both of the of the
crisp innocent of the of the cleanliness
of the design of Hesco and the
engineering effort that went into the
JVM so we combined this I guess it's a
pretty good story you have a second
question
the laziness but okay so question is how
what what I do think about the lazy
thing because many people have trouble
with laziness you do other
considerations it's certainly one of
those pieces where the blue pill and the
red pill deviate much I must say that I
understand that people have sometimes
difficulties especially in the beginning
because you have to unlearn lots of
considerations that you did before like
in fizzbuzz here ah infinite this that's
infinite long and another one that's
infinite long and when they can you like
that's infinitely long oh that's gonna
cost so much it will eat up all my
memory no it will not eat up your memory
because there's only two lists created
one of length three and one of length
five and no other list is ever be
created it's lazily created it's values
when it needs to accept this for what
what do you see here is more like an
iterator right and this is what I love
about laziness it gives you automatic
automatic fusion in all other languages
fusion is an optimization technique with
laziness you get it for free and
laziness is the thing that keeps the
language on its path you know when you
have laziness you cannot make deal with
the devil and go with side-effects and
whatever right because that wouldn't
work anymore this is the thing that
keeps you on track and therefore well
the
life is not always the best for
everybody but I personally really like
him pretty much
I'm not executed so sometimes you need
it yep so there's some times for
optimization you need strictness
annotations and yes we have them as well
you just make an exclamation mark in
front of your argument and then you have
it it's it's possible but it's one of
those concerns when it comes back is it
practical or not and some people may say
because of this is not practical and I
say because of this it's practical your
mileage may vary thank you so much and
enjoy the rest of the conference</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>