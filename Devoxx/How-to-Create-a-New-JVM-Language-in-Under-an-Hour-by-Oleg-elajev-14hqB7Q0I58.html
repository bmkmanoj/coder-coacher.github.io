<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How to Create a New JVM Language in Under an Hour by Oleg Šelajev | Coder Coacher - Coaching Coders</title><meta content="How to Create a New JVM Language in Under an Hour by Oleg Šelajev - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>How to Create a New JVM Language in Under an Hour by Oleg Šelajev</b></h2><h5 class="post__date">2016-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/14hqB7Q0I58" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning we'll be happy to see all
of you here and welcome to the session
about how to create a new German
language in under an hour so my name is
Alex life and I come from Estonia and I
work for zero turn round at zero at
around I'm a developer advocate so my
main focus of current work is to care
about community go around cool places
talk to smart people D some some kind of
research maybe publish blog posts on our
blog called frumble apps I'm also one of
the leaders of the virtual jack which is
the online only enjoy a user group which
you can and should totally join so twice
a month you will get excellent sessions
from the comfort of your home and if you
have any questions or if you want to
chat to me the preferred social network
of my choice would be Twitter and you
can call it ping me and ask any
questions so before that before becoming
a marketing person that ok that was the
property developer so I have some
experience with with Java in different
settings and a word about the returned
it's a company that does produce tools
for Java developers and currently we
have two main tools one is durable which
can reload code changes in your running
Java process immediately so it speeds up
your development cycle which is which is
a great thing always and we have extra
bull which is a performance tool for
Java Web Apps so if you are into that
sort of thing check it out my employer
would be happy they will send me to more
places to talk to more some people and
hopefully we'll everyone will be happy
so if you are still into that thing
today
0:12 will launch a public beta of a new
product called external hub which is a
performance tool
kind of like ex travel but is intended
for your continuous integration
environments and you can find
regressions in your web applications
without any significant investment in
performance testing so check it out and
everyone might be might benefit from
from this so without further adieu with
all that corporate stuff out of the way
we can focus on creating new gmm
languages and we can focus on actual
what this talk is about first of all I
would like to serve a year little bit
about the programming languages that you
use so who uses Java as their main
language of choice for solving problems
okay pretty much everyone do have Scala
people here should I avoid jokes about
Scala we have a couple so in a sense any
other languages fans closure two hands
that's that's a sad situation
Julie Kathleen it's a new language you
will get there so anyway there are there
are many many languages and they're all
created for different reasons and
despite the catchy title which obviously
worked because you're here now we will
not create the language right now on
stage because it's even even with all
the tooling and with all the preparation
it's kind of not that easy to do in 60
minutes and actually explain what you're
doing or comprehend what you're doing so
we will we will look at the example of
the toy language when try to maybe see
on the code level how it works
and also I want to have a disclaimer
that is this talk is not very applicable
so if you imagine that after this you
will become a compiler guru where you
will start working on incredibly useful
languages all the people all the world
will use them that would be a killer of
Java then sadly that is not the case so
however it's a very interesting talk and
I hope everyone will learn one two new
things and we all will be happy so why
do we why do we us as developers try
strive to create new languages all the
time it's because the State of the Union
is that everything is broken right all
languages are kinda subpar and when we
work with something you find issues that
prevent you from doing something that
you really want and you try to mitigate
that by creating new tools kind of like
which this is the premise that sent
JavaScript ecosystem winter is the state
that they currently have and this is the
Silver Bullet syndrome as as it as it
knows and howdy career here on the slide
has a session about how we tend to
invest new in invent new tools trying to
solve all the problems and then we
repeat the cycle because because there
are no tools that are applicable for all
the problems so the same with
programming languages there are many
they all have their disadvantages and
it's an interesting exercise to create
one or two figure out how they're
created or what drives drives them but
maybe it's not it won't be a solution to
all your problems so do we have people
who actually work day to day on creating
languages like somebody who writes a
Scala compiler or who is responsible for
some DSL somewhere at work to make life
of two people excellent you will learn
very little from this talk the rest the
rest are safe
so next question that we will want to
ask after we ask them why there are so
many we would like to know other any
languages that could be called the best
what's the ultimate programming language
and why do we create new languages all
the time the answer to that is very
simple
again because we work on different
domains we have different problems and
there are languages that are more
special-purpose than others so you have
Journal purpose languages like Java or
you can have something a DSL that
simplifies life of certain the
experts in your company or you can have
I know a PHP the language great
specifically to be hosted as is less
possible despite all other trade-offs
today the different lengths and draw the
language creation is all about solving
trade-offs differently so you can have
languages that are suited better for
fast execution rather than the fast
developing time in them or you have you
can have a very simple language that you
can build more complex languages upon
like a lisp and you will get the
flexibility then maybe maintaining this
higher-level language will be your
problem rather than somebody else's
problem so with Java is kind of very
easy all hard problems are solved in the
JVM or on the language level and we just
get to consume that if you build
something from scratch well you take on
yourself this responsibility so it's a
hard work and it's it's always rewarding
and cool but sometimes it's not as
rewarding especially when people start
hating your language and they they they
are not buying it still almost all
developers that I know try to they we
thrive on creating new things and
inventing and making things work like
remember if maybe 5 10 15 years ago when
he just started programming and he
created some components and it worked
but there is a button on the webpage and
you start clicking that and it works and
it does nothing but shows an alert and
you're like yes it works and for 10
minutes you just click that button and
you were extremely happy that you build
the thing and it works and this is this
is the feeling that drives a lot of
personal research and innovation
well obviously corporate work is
different so and part of the abscence
programming languages are tools that we
use daily we would like to create better
situation with that so we create
languages all the time sometimes there
are general purpose sometimes they're
very abstract and one of my favorite
examples of throwing languages and just
it shows how many there are is the P at
programming language
in which the program is actually an
abstract painting and the author of that
language wanted to name this after the
painter and Mondrian surprisingly that
that name was already taken so if you if
you think about that you pick them quite
an obscure name for a language for a
very esoteric language and it's taken
then you know that there are very very
many of those and well sometimes you can
contribute to that and sometimes you
cannot but well we cannot do esoteric
word programming language work day today
all of us some of us have actually right
well consumer applications or business
applications to generate the revenue but
in the free time we can definitely see
how it works so how do you create a
language there is an excellent series of
blog posts about creating language
called ankle by jakub and in 20
shirt not very short blog posts he
explained and created a small still
small in toy language starting from
defining the Brammer and how the program
will look like do you want they mean and
how to implement those details and this
is well 20 blog posts is not a small
feat like I don't know how much of you
how many of you write blog posts but you
have to do research and even reading
that it's kind of size of a short book
so it's a it's a lot of effort and I
would totally recommend you go there and
check the code examples and play with it
because gradually builds builds the
language creation but in a nutshell in a
nutshell any language creation and any
language creates of three parts so the
whole idea of the general how the
language works
you specify program and then at the end
that program creates some side effects
when it's executed on an actual hardware
hopefully those side effects are somehow
managed by the semantics and the
structure of the program rather than
generating heat to the universe but in
this this is the black box view of the
language inside that language there are
certain parts components of the language
runtime that are universal to all the
languages so you will need to have
something that takes the initial program
and split that into tokens and that is
called lexer so this is a lecture is a
program all those components are
programs that takes programs as an input
and produce other programs as an output
or a representation of a program
so first we'll have a lexer that takes
the code as we know it might be a text
file or it might be a painting or it
might be something else and it produces
tokens off of of strings basically the
identifiers that are reasonable for the
language that you're writing so it just
translates the free form into structured
stream-of-consciousness
of the developer then we'll have the
parser which is the program that takes
this stream of tokens and produces
typically a tree of the execution of the
program so it's typically it's called an
abstract syntax tree and it it shows in
a tree structure what this program is
about what it's supposed to do and then
at the end you take that abstract syntax
tree and and you produce a program that
is executed on an actual hardware so it
could be a JVM bytecode as a result of
that and then you reuse the existing
infrastructure of the the JVM to execute
that where you can produce the machine
code where you have can have a compiler
that takes an abstract syntax tree of
your language and produces JavaScript
run and browser or whatnot but in a
sense you go through those three phases
to create something executable from the
initial source and let's look in a very
short things into what those problems
are so the lexer is the part that
tokenized is your program what it does
it just the
a finite automata off of the tokens and
it's kinda is a solved problem so what
it does takes a file and create a stream
of tokens this can be done with regular
expressions if you are really interested
in where this can be done with the with
the automaton and Lexington is a solved
problem so it's just a string
manipulation you take that and then you
create syntaxes the syntax for a
language the next part is the parser so
what it takes it takes the
representation of a programs may be
mathematical arithmetic operations and
then it produces the tree that is
logically replica represents your
program so on exam on this example slide
you'll see a tree that describes an
expression where the operator is at the
root node and the children are sub
expressions so parsing your language is
also typically from the stream of tokens
is the more or less solve problem there
are tools to do that efficiently this is
not where you would invent that much of
that much new so typically you would
work on on the ast and then you would
like to make this ast run somewhere and
this is the third part where where the
compiler comes in so the compiler is
this magical program that takes a
representation of the program and
produces different one and it typically
if you if you think about working on the
ast levels so you take a tree and then
you produce a different tree and then
you produce a different tree again and
then again and again and you can
simplify it convert your textual
representation of the program into
something hardware acceptable so and
typically you would run that through a
series of steps and it will have
multiple multiple compilers that
optimize or transform different bits
pieces of your of your program there is
an really good resource for compiler
writers available on that page and it
has links to tons of other resources
books and blog posts about how to write
a compiler so it starts with the
philosophy and how previously the
compilers were created and lists books
on how to design that and you will learn
about optimizations and you will learn
about how the actual hardware works and
how to generate code and all that and
even from this list you see that it's
not an easy task because well if you if
you if you need to create a compiler and
you need to know all that obviously
you're not for a short journey here so
it's a complex task and we would like to
have it a little bit simpler so if you
would like to create a toy language
right now very rarely you would think
that oh you know what I would like to
read books for it like two years and
then start actually working on something
this is this is way complex for the
modern times we would like to hack
something together have it working and
then call it a day and move on on a
different type project so if you start
working on your own language the typical
typical stages that you go through
creating language the following so we
created prototype and you you if you
implement all this required modules and
you have something running so you have
an ast and you have a program that
interprets that just basically traverses
the tree and says oh this is the plus
operation I know how to add two results
of two expressions and you create a
prototype and it's kind of working
and then you figure out okay it's kind
of slow and it's boring and it doesn't
do anything significant so I would write
a virtual machine for that and you start
writing your virtual machine for that
and then you convince somebody else to
use this language for example that
happened was Python well 20 years ago
and people start using that and people
start
complain and there are two things to
complain about the language and first is
the syntax and verbosity and usability
and lack of proper constructs that you
would like that you've seen in other
languages and and B people complain
about that and second part people
complain about is the performance issues
they started the writing program as soon
as you have the ability to write program
people who write huge programs that
crunch lot of data do something kind of
time-consuming and then it will start
complaining about how slow it is and
this is a typical who has seen a
complain about program language being
slow I know you could like in Java and
you look like you're more than 10 years
old so you should you should know the
jokes about how slow Joe is knock-knock
who is there on pause Java so people
complain about that and then he rewrite
parts of the virtual machine and then
you create more optimizations and then
you you you create more compilers inside
that runtime and then you figure out how
to do the garbage collection and all
that takes work and people still
complain about that and then you say
okay fine I will create a just-in-time
compiler and I will use the
state-of-the-art technology and I will
invest like multiple many years into
into this project and people still
complain so you cannot get rid of
complaining but you can you might get
the performs better
so all those stages and this is how
typically the development of your
language goes so starts with grammar and
here's an example of the grammar of the
language that will create and the
grammar is the following so our program
will be an expression there will be a
super simple language not even language
it will be kind of like a lame
calculator that that will not move you
far so our program will be and this is
where we start implementing language we
talk about the grammar and we would like
to define which
strings are valid programs and which
strings are not valid programs so the
whole world of strings will be divided
into separate parts so to specify the
vile programs typically you would create
a grammar you would create the rules to
what is a valid program in this example
it will be an expression that can
contain mathematical operations you can
contain numbers and it will contain the
parentheses so this program defines
strings as programs this grammar defines
strings that can be represented as a
tree that we saw just a couple of slides
before so we have the arithmetic
operations that can join a couple of
expressions and we would be working with
trees like this so now on the street you
can easily figure out how to how to
execute this program he just pointed the
root node and you start moving a finger
to the left and then to the right and
then you compute those sub expressions
and then come back and and figure out
what the result is and when you finish
with the whole tree you have the result
so you know how to interpret this ast
now the interesting part comes in
because you want to create a proper
language and you want people not to
complain about lack of a lack of
features that they want so you will
start worrying about how to interpret
this exactly you would sort it maybe
define variables and as soon as you have
variables of func function or namespaces
you will have lexical scoping rules this
is something that Java Script did poorly
for example you would need to define
some functions and you need to figure
out the machinery t have the colon
vacations methods indications you would
introduce the type system you'd
introduce garbage collection this is a
lot of work that is very aligned with
the language creation but it's also
quite orthogonal to actually defining
the semantics and the innovation in the
language so if you want to create a new
language for example you you want a
great language that will taken a big
a painting as an input then the
innovation comes from interpreting that
right this is the new cool bit and then
all those things you still have to do to
make it usable but this is a very
different purpose of a different
different path of the innovation so but
still the right language you will have
to this is freaking yeah now it's
working so you will have to you'll have
to create that and it kind of will
always seem so close to you but you will
struggle with implementing those things
because it's really really hard and it's
not it's it's hard it's time-consuming
and is it expensive so there is a pro
tip about software development in
general solving hard problems is
expensive in terms of time in terms of
knowledge they have to have in terms of
everything so we know that many problems
currently in the world in software are
not that expensive you can create a web
app where a cluster of web apps in like
40 minutes and deploy that and show
multiple features by slapping
annotations together and but the thing
is it's only cheap when you have a
problem that seems hard but it's really
easy to do that means that somebody else
paid for that so they somebody else
create or the whole research and you
were just standing on the shoulder of
giants and reusing their work hopefully
this running hamster will remind you of
that so what we would like to have with
language we would like to concentrate on
the interesting part and have all the
rest kind of offered for us for free
because we are cheap like that so what
the stages out of those stages that we
saw before we would like to prototype
the language preferably using Java
because this is the language that we use
and know and we would like to create the
semantics and kind of specify how our
input program will correspond to some
sort of ASD and then when people start
using that they all have the whole
infrastructure for them there it's fast
it integrates with all the tools it also
runs with with the platforms that people
like and use and this is what we would
like to
have and hopefully well luckily we have
the tools to do that so enter the growl
and travel products so growl this who
has heard of growl before interesting
for people I salute you
so growl is a dynamic compiler and an
interpreter for the language runtime so
it was until is a research project under
the open JDK currently and the goal of
that project was to build a Java
compiler a high-level compiler that will
integrate with the JVM and the compiler
would be written in Java itself and it
would reuse as many features the JVM
offers itself but it will be suitable
for compiling different other random
managed languages onto the JVM so and
they created that so the capital
University I think it was the Kepler if
I'm not mistaken you started there so
and they created the high-performance
optimizing JIT compiler called growl for
the java virtual machine and they
utilized the platform and a couple of
things that crawl does really well and
how it's different from the typical like
c one c t-- compilers that we have in
the hotspot it has NIF different
approach to the inlining so it better in
lines the code it it simulates some
executions and can inline the code
smarter so it's it can be potentially
quite fast it uses different escape
analysis techniques and it does use
speculative optimizations top of that so
the goal of the growl was to create a
state-of-the-art compiler written in
java and integrate with the existing JVM
ecosystem on top of that so on top of
that on the ground so when we have the
compiler we would like to have some too
to leverage that compiler and there was
a truffle truffle is a language managed
language implementation framework that
is reasonably not recently extremely
cool it's a reasonable implementation of
a framework it builds on the growl and
it has a tight understanding of the
works between how it managed the
language and how the drawl and the JVM
execute things so they can feed the
information back and forth between each
other and optimizing compiler program
really really well so truffle also there
are some optimizations on the on the ast
level so it's a framework that is aware
that you would like to run your programs
fast and it can speculate about what
execution paths are taking three of your
language and it works really well with
draw so there are multiple
implementations of the languages that of
the that run on the truffle withdrawal
but the thing is if you look at this
spider diagram you know Matt photoshop
skills buy me the truffle sets in the
middle of this whole ecosystem so on one
part of that you have the virtual
machine if the hotspot or growl you have
the compiler you have different tools
and on the other part on top of that you
have the languages so it separates the
language from the underlying
architecture so you can have the same
tooling you can have the same
infrastructure you can have the same
benefits that that the vm engineers
introduced to the underlying virtual
machine and use that in different
managed languages that are implemented
of the truffle so there is a JavaScript
runtime that currently works there JRuby
runs with truffle I think there is a the
implementation of our the statistical
statistics language the trance of
truffle and you can easily create a new
language that that will sit on top of
that existing world that solves a lot of
heart problems and and you would just
focus on creating interest
it's for for yourself so next obvious
question when you know about this that
this this sort of thing exists you're
like how can I get this I want my hands
on this so to get the growl you can
download the drawl DM so it's different
lam it's a different executable and you
download that and you unzip it and you
have different paths and you just
overwrite your Java command and then you
can point to there and you will have the
growl DM running and this is amazing but
a little bit cumbersome and and not many
maybe the best the best thing so there
is a different way to do that so JT
canine comes with a bunch of new options
and one of them is is the double x+
enabled GMC I so Jo MCI is the JVM
compiler interface and what it allows
you with the JDK 9 it allows you to
specify what compile compiler would like
to use well to run in the in the JVM and
with a bunch of options just a couple of
options and just providing a jar file
that specifies the compiler you can plug
that in into your normal JVM so this was
this work was done as a part of the jab
t43 and the goals of that were to create
the interface that allows the compiler
and allows pluggable components to
access the internal VM state better so
VM is a complex machine right there is a
lot of things going on underneath a lot
of time and effort has been spent on
making those as bug free as possible and
working so through the compiler
interface you can get some levers into
the internals of that and the compiler
gets the access to the bytecode and to
the machine code and to the process of
producing the machine code for that and
it's really great that it landed in JDK
9 and you can totally try that without
downloading much external
external programs and utilities so it's
there you can try that I recommend you
trying that you can try running your
programs with that it's sufficiently
well it's not sufficiently stable I
would not put that introduction but it
sufficiently stable to experiment with
and to to try so this is exactly what
we're gonna do now we're gonna see how
it works and we're gonna try to look at
a small example of a toy language for a
tiny calculator so at this point of time
I will try to go to my IDE currently
happens to be eclipse
I love IntelliJ IDEA I use a daily but
for some reason for this project it was
eclipse so the program here is that our
our language is very simple so if you
download growl it counts with the
language that features it showcases the
features of the growl and it's called
the simple language and initially I
thought that I would show you the simple
language and how it works
but in fact it's not so simple there are
tons of classes and it's not even
possible to just figure out what's going
on it's just like with very many
features they have functioned they have
functioned redefinitions they have
impressed they have the polyglot
invocation so if you have different
runtimes imagine this this is very cool
bit about the growl and truffle on top
of that if you have different languages
in the same VM loaded you can interact
between those your JavaScript code code
can called your Ruby code and your Ruby
code can call the JVM back and
everything goes through a single point
of entry through the truffle and when
you think about how huge the program
would be in the tree and then you think
about that this is can it be efficient
enough then the truffle takes that as as
a challenge and just optimizes a way
through the language barriers and and
and the life gets amazing pretty fast
and you even forget that everything is
broken so however
in this project we we will I would like
to show you just the the most essential
parts of the language building a
language was truffle and everyone on
gras so first of all we'll have the
import and you can just add that into
your main project by just throwing in a
couple of dependencies they're available
in maven central so you just download
that as you would do with any dependency
and you get the classes in the api's to
do that
there was a truffle run time that he
would use and he would create an engine
on which you would execute programs so
the exact program creation here is not
that important but you follow all the
steps that you would follow in any
language creation so you get a string
somehow and then you you have to parse
this string and then you would have to
execute that so let's look at the
grammar for this twine language for this
I used the antler and our library for
generating grammars and generating
parsers and lectures from the grammars
and this is how the syntax loop so that
this is exactly the match not exactly
but this is a match for the grammar
sample grammars that we saw before so
the program contain consists of an
expression and an expression is either
the arithmetic operation or or the
number and you can see that we have like
four arithmetic operations and the
numbers the cool bit about the numbers
is that we allow allow dot in the number
representation so we are dealing with
floating-point numbers here so we will
have integers and floating point numbers
when we have this grammar the until or
will generate us a couple of classes
that look like this they're not very
readable by hand but the API is super
straightforward you know what we have to
do we just have to you parse that
running we will it will create a tree
for you automatically and then you will
just need to parse the tree by providing
a listener to run through the tree so
it's very default algorithm here that
you can you go through the tree and then
you have a stack of nodes that we
visited before and then we exit a
certain node we just specify that the
next node is the operation the cool bit
about the truffle is that you can create
type system for your language very
easily so in this toy language we will
specify the types that or we will have
lungs primitive lungs and we'll have big
decimal which is which will be our
representation of the floating-point
number so this would be you it can be
quite complicated to figure out how to
use a type system in the language and
this this example shows how easy you can
achieve that with truffle so you create
the just an abstract class and you say
that this is will be my type system
these are my types that I would like to
use you create the language and you slap
annotations on top of that to say like
Oh truffle you know what this is my
definition of a language and I would
like to call it this and I would like to
call it that you provide the context
this is a cool class so for a toy
language you don't have to specify much
anything it comes with batteries
included so you just use a couple of
annotations to say oh I want this
language and all you have to do is to
specify the type system that you'd like
and you need to specify the ast in terms
of the truffle objects so you create
some sort of ast from the grammar in any
way you like and in this example we do
that with antal R and then to leverage
the whole machinery of truffle and growl
you have to represent that program using
well objects that travel knows about and
those things aren't the notes the notes
are short classes or maybe not so short
but they they extend some truffle
classes and you have the information
about what it does this particular class
as an annotation so it's all works on
the
which is very familiar to Java
developers so this is the example of the
leaf node which is a number and it will
hold our big decimal values there and
when we execute this node it will just
return this value to us the same will
have with the long node where we have
the just a primitive long value and the
mathematical operations are the same
very simple you just specify when I see
a plus I would like to treat that as an
ADD node in my in my class cool thing
about truffle is that it allows you to
specialize the execution of of the nodes
based on the types of the arguments that
you receive so you remember we had two
types so in our program who had lungs
and big decimals and every node that you
would like can come with different
implementations of the execution logic
based on the operant types so if we have
two Long's and we we can we can say
truffle oh please
execute my method where I would just
call this functionality so we would use
the math class and we say if the
arithmetic exception occurs here then
please use a different implementation so
you you just hint truffle that there
might be multiple code pass executions
depending on the arguments and it takes
care of picking the right one based on
the argument types for you and then you
create all the notes where your for your
language implementation and they're
super simple so we have 20 classes here
this language probably cannot be created
in 60 minutes but you can read it in 60
minutes there are 20 classes that makes
3 minutes per class if you read fast you
can totally do this so the title was not
lying that much and in the end in the
end of the all that you use the polyglot
engine to evaluate a source that will
parse for this source using the where
using the --until our API just from
string it will go and create the lexer
and from the lecturer you create a
parser and then from the parser you
create a program you won't this is AST
program and supplying by supplying
listener you create the truffle truffle
nodes so you follow all the steps that
you required to follow to create
language from the parser to the AST but
then on that you convert that into the
terms truffle understands and everything
else is not your problem
because truffle takes care of everything
so we'll see if it actually works it
worked this morning so hopefully it will
work today right now let me just run
this we are running on truffle so as we
creating as we are creating a calculator
would expect it to work and you can see
that it indeed works for the small
values of Long's and as a result of the
program when we execute we would take
the class of the result of this result
value and to the result itself this
would show us that the our type system
actually works so let me try a more
complex example here just to show that
this this this works if I evaluate this
expression and if there are no bugs in
the mathematical logic of how nodes
evaluated shows us 10 and you can see
that all the all the values here are
integers so it parses correctly as
primitive lungs and it executes the
logic on the primitive lungs and it
works so what will happen if I just now
take this different expression where the
4 is for that oh so it's a floating
point and paste it who thinks it will be
10 who thinks it will not be 10 but it
will be something else well in
international it will be 10 because the
numerical value is still 10 but as you
would expect
the type of this program is is is
different so the thing is we in nowhere
so if we take this multiplication thing
and we'll look at how this evaluation of
the multiplication note is implemented
know where we specify the oh let's check
the arguments if they're primitive lungs
or if they're of this type let's execute
this code path or if they're not we'll
execute this code path we just know how
to multiply lungs or how to multiply big
decimals and the truffle will figure out
how to pick the correct specialization
of the code execution based on that you
can also specify more annotations to
hint the compiler that oh please you
know what do not inline this so the
responder ease what a compiler can it
cannot do there are more annotations you
can specify guards and conditions in the
code more advanced that just like Oh
have my types you can check for the
identity of the objects that are passed
to you so you can for example cache the
function execution using annotations and
you can wade through the annotations you
can leverage the full power of truffle
how cool is that
it's extremely cool so now look at this
so we have big decimal 10.0 if I take a
different expression so here we don't
have the 40 though but we have one
little at the end who thinks the result
would be big decimal 10.0 who thinks the
result would be something different one
person you think it's a tricky question
right surprising that the result is a
little bit different it looks different
it's a scientific notation of how we
represent this 10 plate own number and
since the result comes from just
printing out this big decimal I'm not
really sure why it happens
but it does happen so some somehow the
representation of that is different
probably this is just related to the
floating-point arithmetic
rather than the implementation of our
language but it is it was a trick
question
another good question if I take TV very
long values right and this is also
critical so it will showcase the
specialization so this big number is a
long Maxwell or minus one so if I take T
very long long values and add them
together what will I get
do I get a negative number who thinks
that will get a negative number who
thinks I will get a positive number who
thinks it will crash skepticism very
important software developer it's not
topic because I have a couple of minutes
left software development is largely
about being as pessimistic as possible
the happy path in the code and in the
business logic is very simple typically
and you just write that and it is if
everything works you code this concise
and and nice and clean and neat and
everything but then you start like
putting error checks and catching
exceptions in there and you start
thinking about all the things that can
go wrong and before you notice your code
is a mess so being pessimistic from the
start is is a virtue it's a good thing
so back to this long long edition so if
I execute that we will get a big decimal
value that is the result of those two
numbers added together why that happened
it happened exactly because we have the
truffle to execute the specialized code
pass in our code as we specified and as
we specify that if we get an arithmetic
exception here please just follow
fallback to a different implementation
and that is not cheating I would suggest
that is careful planning and and we will
fall back to the more generic
implementation of this code pass so if
if if we
fall back from the arithmetic exception
here the next the most general code pass
is where we add just two operands just
two objects and here yeah in this slow
code pass we do check the duty all the
type checks and we do instance offs and
we do create the big decimals out of
Long's and we add them as big decimals
so however we never we specify that Oh
truffle please try to use this fast code
pass first and then if it fails go to
the slope good pass the framework is
smart enough intelligent enough to do
that for you and know that
well first you want the fast execution
and now if it if it fails go to the
slowed cut pass so in this toy language
even with this very limited type system
of two types it's fairly interesting to
play around so it's a very tiny example
of the language and you can totally play
with it if you weren't interested if you
have never created that language to be
falling in life it's a way easier to
start with something small working than
to work through all your learning curves
and all the problems from front start
and from scratch and another cool
benefit of the truffle is that
everything needs in Java so you don't
have to Google what is it dereferencing
operator all the time
what's that % I think it was ampersand
maybe not so this tiny demo worked you
can I think you can access the code
you can access the code somewhere and
try I will put the code somewhere on
github and we'll see so as a result we
looked at this tiny toy language that
takes arithmetic expressions and
tokenize is that using Antal or and and
creating this stream of tokens and it
parses Internet ast then we traverse the
AST who is a very simple algorithm and
converted that into the truffle
representation of this tree that we
execute and then the truffle cake sent
and execute this thing as as it knows
how to do and then you get the result in
a good case that is a very readable ten
point whole result in a less interesting
case it's more interesting cases it can
be something different so if you're
wondering how useful that is and how how
how excellent the optimizations and how
excellent the compiler is then it is
pretty cool to know that for general
workflow on general benchmarks is quite
sophisticated for different languages so
ruby running on truffle and draw is
quick R is extremely quick so if you do
statistics you can try it's not the full
implementation of the are there might be
deficiencies in it's very early early
alpha you can see that the Java thing
and those results are not my needed but
they are by people behind the truffle
integral in the Java part the
performance of your program is on par
very often with the normal execution of
of the just normal JVM the hotspot right
so for patterns for the byte code and
program patterns that are less common in
the Java world for example if you use a
different genome language you can get
the benefit of the speed-up from this
new infrastructure for the compiler that
that growl offers so it takes the
different passes of less
idioms it might be better than than the
hot spot so you can see that Scala and
well it's a it's a it's a really great
effort and it's very interesting project
and now it comes to Java nine and and
hopefully we'll get more and more eyes
and hands on working with that and it
will become better and better now if you
want to create a language and you will
need to start with a grammar one there
are multiple of libraries and frameworks
how to transform there and how to
implement the grammar I in this example
I used --until or and it's a very solid
library they went through multiple
implementations of parsers and how to
create grammars there was a book about
this and they're excellent about this
and at the end if you want to create a
new language you have to remember that
any language consists of two parts very
loosely defined it's a runtime system
and it's a library or the ecosystem so
to have a successful language you have
to have both and if you are interested
in two in one part of that you would
largely want to reuse the cone knowledge
and the whole effort that was put into
the other one so if you want to create a
new grammar and offense esoteric
language you'd like to reuse the whole
infrastructure or if you want to use and
work on compilers then probably you
would like to get into the echo system
where a lot of programs are run so growl
and truffle fit that bill in a sense
that they've written in Java they are
easy to get started if you ever wanted
to create a compiler this is maybe a
cool place to start and then just to
follow up there are no there are no
people love languages but mostly people
hate languages and if nobody hates a
language that means nobody is using that
and well different languages have
different trade-offs at their quirks
doesn't mean that they're bad a good
their miniature
they're different so with all that in
mind this is everything that I wanted to
show you thank you for coming this is it
I think we have seven minutes so if you
have any questions there is a microphone
I'm not sure maybe you can yell a neck
and repeat
so the question is I'll just repeat so
no it's some video so the question is if
the problem is not to create a new toy
language or or the new language itself
but it is the problem is to extend the
Java and maybe start with Java and add
some syntax on top of that and if the
truffle and growl if the this framework
is good for that hmm that's a good
question it's it's interesting you can
it depends on how much you want to
extend language so maybe if you just
need a couple of tiny things it's easier
to just implement them in the open JDK
well the the runtime and the software is
it's open source so we can just go and
add the Elvis operator into the open JDK
project and have it have it have it
there if you want to create a different
language altogether then you would
probably need to you know small changes
would probably be harder with this
because you still need to parse the
source yourself if you would meet if you
would like to have a different program
than Java and then you have to translate
that into the terms of
yeah there are tools to create that
there is grammar for rental or for Java
so you can parse that and you get the
you where you get the ast the problem
that you will face is that when you
create convert that ast that you get
right which is not it is not like the
Java program in the JVM sense you get
the representation of this Java program
and then you will have to convert that
to the truffle implementation of of of
Java so it might be not complicated to
do but if you start from scratch and
yourself you'd probably be quite
cumbersome to do to handle the cases and
to implement because you will have to
transform the whole tree so there might
be so Java runs on truffle but they plug
the drow as the GM semi sei compiler so
they take the representation and then
they work on the internal JVM
representation of a program to enable
and enable those those things so you
will have to recreate quite a lot of
effort together but it might not be like
rocket science in the sense that it
might be very straightforward because
you work with Java things and you can
transform straightforwardly thank you
we have another question
great
so the remark is again to repeat just
for the video and the sound so remark is
that there was an product called NPS by
jetbrains
and it was for to creating for creating
not the manage language different
languages on top of the Java and you
could add the syntax and the grammars
very easily to the language so we would
like to extend the language you could
try using that I cannot say how much
JetBrains actually is working on the NPS
right now and how much they are
promoting that I know that they had this
extensions where you could specify the
tables of data in your program syntax
and they would convert that somehow to
like hash maps or something and that was
a cool feature so that might fit the
bill if you want maybe a little bit more
sophisticated extension mechanism just
to in terms of defining new grammar and
syntax maybe not but this is the
possibility that you would like to
consider do have anything any more
questions it's not cool if you have any
more questions ping me on Twitter I'd
love to chat thank you again</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>