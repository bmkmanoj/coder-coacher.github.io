<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Fighting fraud with graph databases by Vandy Berten | Coder Coacher - Coaching Coders</title><meta content="Fighting fraud with graph databases by Vandy Berten - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Fighting fraud with graph databases by Vandy Berten</b></h2><h5 class="post__date">2017-11-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5u4hyNOh0Tc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so thanks for coming to this
session i'm randy burton from research
department of company smiles in this
presentation i'm going to share my
experience about fraud detection in the
social security sector using network
analytics technique and graph databases
so this is going to be do land my
presentation um after having introduced
the context of graph and graph databases
with some comparison to the classical a
DBMS medela will explain a business
problem in the context of social dumping
and we will see how this problem can be
translated in a graph problem okay so
first of all we need to understand what
understand what's the graph well we can
see our world as composite of of
antiquey a person company building
computer all of those entities have
physical reality but we could or we
could also have entities that have more
like conceptual reality like a software
program package or a group of person
like a political party well so those are
entities that first of all the
relationship between those entities this
person is a friend of another person
this person is the buff to both of
another one this person works in a
company that sell houses this person on
the house is the developer of a package
that of a program that depends upon
under the package that rents on the
server and so on so all of those are
relationship between entities the
classical database systems or DBMS model
mainly focus on entities but by putting
the focus on the relationships and not
entity a whole new family of analysis
are possible and this is what we are
going to do with Network analytic and
graph databases
so this is what we call a graph or
network on sometimes we talk about a
social graph or social network because
our people some of the entities are
people okay so this took this kind of
model with where nodes represent people
or companies or group of places as been
shown to be really efficient in the
context of fraud or criminal behavior
detection as well for many other use
cases but the problem is that as we will
see in the following slides the
classical a DBMS model like Oracle MySQL
post-grant
are not good at all for storing and
querying a graph structure both is both
in terms of execution performance a
symptom of explosiveness of
expressiveness of the Korean language
usually SQL this is why graph databases
has been introduced putting the focus on
relationship instead of entities for our
DBMS ok let's talk a little bit more
about graph database but before talking
about graph database I will first talk a
little bit about a DBMS model the way
the way relationships are implemented in
a DBMS a DBMS model so let's assume that
we want to represent the relationship
between workers and companies and with
shoes for that classical a DBMS like
MySQL Oracle or whatever and we first
consider the simple case where our
worker can only work for one single
company a classical model for do for
doing that would be to have two tables
one for workers and one for companies
and using a foreign key in the table
workers to to point to some farmer key
in the company company's table if you
need if you need to get the list of
employees of a given company for
instance miles will write the sequel a
sequel query like this where we well we
select a field in the table workers we
put some chords with shown to say how
the two tables are linked together and
then we say that the company is
months in this request we have to part
somewhere we have to pad that concern
that that is really want to one to know
that consent the developer he wants to
get the name and he was the company to
business everything that is put together
is how the relationships are implemented
in the database but this part does not
does only depend of the model and should
not depend it should not change between
requests somehow we may say that this
part should be the DBS responsibility or
at least the the damo dollar or
responsibility now that there are no
difference between the field employee ID
and the field name from the database
point of view apart from the
interpretation we give to him okay let
us make the thing a little bit more
complex and considered know that the
worker can work for several company at
the same time or not what we usually do
is that we create what we call a join
table which contains a foreign key
stored the take that primary key of the
table workers and company again if we
want to get the list of all the
employees of company smells we need to
write something like this with well
still the same part that we want to know
and in the middle everything that
explains how the relationships are
implemented we need to join here because
we have to have two foreign keys okay
let's consider another model where we
have here something more like a social
network I would say with people liking
or following or depending upon on
knowing or whatever each other and we
consider for disabled people with all
those people and then the table for
instance lag with in each record our
foreign key while two foreign keys
towards the table people if in this
model we want to know who for instance
Bob liked we need to do this kind of
request withdraw the table people once
for Bob and once for the people that
black but black sorry again what we want
to know is the name of
the people and that the first people is
Bob everything is the middle is how the
relationships are implemented if you
want to just go one step further and
saying who are the people who like the
people that Bob like so we buy a black
square that's a question that that's
that is philic common in a weakening
recommendation system for instance
Facebook will recommend you to like to
be friends with a friend of your friends
or Ebay will recommend you to buy
product that has been bought by people
that bought the same product as you well
for that you need to we need to write
this kind of code with twice the table
people to us the table like the devil
likes and for a really simple question
it becomes really complex to - well it's
become it becomes a really complex query
difficult - why difficult to way
difficult to understand difficult to
maintain and so on of course in in some
database system like Oracle there is a
mekinese connect by photos who know that
that simplifies a little bit to Korea
but the execution is still quite heavy
so to resume the way relationship
between entities are implemented in a
DBMS database in the case of one to one
relationship the relationship between
antithesis is is is modeled by somehow
distorting the world of an attribute we
do not have a key type we need to choose
for in any kind of standard type like
integer whatever to have this key and if
in the M - M - n relationship we need to
somehow distort the world of a table so
there are tables representing entities
the are table representing relationship
but there is no way to distinguish those
table from from the base point of view
when we say that in our DBMS the
relationship are not presented to DB DB
itself MA but in the queries
also the jean mechanics is something
really heavy in execution time we first
need to okay we first need to find the
right company here the right ID here and
then you need to and for this you need
to look through this table using some
kind of index then for those index you
need to go through this table again
using indexes and for all for all the
IDS you find here you need to go through
this table again using index two to find
them at least that's something really
have in execution time okay with so with
growing need of stirring Ulf can of data
to solve or to solve all kind of
problems
well a DBMS are not anymore the
universal solution missing and because
of that a new world database familias
raised in the recent chairs that we call
no sequel on our SQL solution I'm not
going to talk too much about those no
sequel solution but there are mainly for
families of no sequel the key value
column document store and graph database
in my presentation here I'm going to
talk about this last family the graph
database family showing some example
with the market leader in growth
database which is neo4j okay done in a
graph database we do not consider and we
do not store table tables anymore with
but we store all entities and
relationships
for instance here we have three we have
four entities that represent well some
things I would say those entities have
attributes or properties or key and they
value the key name as the value for
instance smells of John of so on and
those know those nodes have also
labelled of a type so the two blue nodes
are of type people that means that the
represent there is a node company there
is a node
and so on okay so those are the entity
the entities and we have also a
relationship between those entities that
again could have LaBelle's and
attributes so in this model I may say
that have a person whose name is John
that works for the company smiles with
friends with Bob and this Bob lives at
the given address in a graph database
those relationship are going to be so
like pointers that means that in a node
will have the physical address of all
the nodes that are pointing that
pointing by the relationships but the
graph databases have to mainly two
objectives the first objective is to pit
apart the relationship definition how
the relationship are implemented that
should be done at the creation attempt
the creation term of the database and
the matching torso decorating should not
take about should not take care about
those relationship definition that's one
side and you decide is to really fast
mechanism to to office to to to traverse
relationships not using the join McCann
is vicious not to be really heavy in
execution time just to be a to give a
small example of how how should like a
graph database or query in this example
so this is this decoder I needed to use
to know the who other people who like
the people that Bob plugs in in SQL and
if I transient translate this in neo4j
the in cipher which is the language of
neo4j I will need to write something
like this I will will need to much note
of Thai people whose attribute name is
Bob with a relationship to to another
name another node of type people
relationship of length two of tip type
like so I'll come back later to this
kind of credits
well just to give another example how I
shot the code could be in the near
future this is the code that the MySQL
code that was using that was used by a
client of neo4j before they switch to a
nearfall J and this is how they
translate the query in the in the neo4j
so much shorter but also much easier to
understand to wait to read as said you a
little bit earlier that the graph
database could be really good for the
recommendation system and the eBay uses
new for jet for the recommendation
system they said in a some report that
thanks to an effigy they've been able to
do things thousands of times faster with
queries that request
10200 time less code ok so this new
foreshadow so know for sure is the
current graph that with leader that's a
company that is 10 years old now the
engine is returning in Java and with the
platform they propose to addition a free
addition and an Enterprise Edition to
the to our open source of course we can
query this database from any kind of
language it's from the consistence point
of view it is at acid compliant and the
database can be queried through cipher
the old language or gremlin which is a
like a more standard language to graph
database okay no let's look a little bit
more how we can build requests and we'll
consider for that the same example as in
interaction with the leaf list of
employees of a given company in this
case we will leave two kinds of nodes or
a worker node work or not and a company
node and one type of relationship works
for in my example so what we need to
find
is all the path with a worker connected
to a relationship through a works works
for relationship to a company node whose
attribute name equals smarts and this is
somehow exactly what we are going to to
write in the cipher
language language I went to find a
worker worker node connected via works
for relationship to company in the word
was a two-bit name is equal to smells
and form for each time I find this
pattern in this database I will return
the name the attribute name of the
worker to be the birthday attribute of
the worker and studied of the
relationship okay again so the
parentheses mean a node the two after
the two dots that means that the label
of the node yes or no doctype worker not
of thoth company and our with the
brackets in the middle means a
relationship of type works before I can
even write this a little bit shorter by
putting the the constraint aware
constraint in the in the node here so
this means that I want to too much and
know a node with the parentheses of of
type company with attribute name is
equal to smart then I don't need any
more the way apart in my request okay so
if we compare the way it works in the
two systems as I said before in a DBMS
model to find all the people that works
in a given company we first need to go
through this table through an index
which is going to have a logarithmic
complexity and then from this we need to
go through this table again logarithmic
complexity and then to do through this
tables with the index logarithmic
complexity with the graph database what
we are going to do is that of course we
first need to go through an index to
find the note that attribute name is
smiles but that
from from this node we have the database
content contains the list of founders
towards all the neighborhoods of these
nodes so that means that following we
just we just need to follow up on to
assist community to be a constant
complexity okay so well as you may know
smells my company works many works for
public institution in in Belgium and in
this context my team are supposed the
National Office for Social Security in a
fraud detection mainly related to what
we call social dumping so the social
dumping social dumping is when a foreign
company sent low-cost workers in other
countries in our case in in Belgium this
is something that is hollow by allowed
by Europe but it has been done in a
strict framework that the national
office for Social Security so in charge
of controlling I will first present two
declaration that have been filled by
companies and then the underlying
database structure and then we'll see
the kind of pattern we may find we may
need to find so my company is you see is
well as develop those two application is
in charge of maintaining those
application then we are doing data
mining of those data so the production
application are in a classical a DBMS
model Oracle mainly and then in order to
do data science in determining we export
the data from those database from those
a DBMS database too and therefore a
database so the first application we
need to consider is limos are so limos
eyes as to be filled when a foreign
company that we call the sender wants to
send out workers in Belgium so in this
case this company needs to declare who
is going to work so the worker for which
company this work is going to work and
where this this worker is going to work
the web part is firstly called the place
of course the place of work so it could
be either an address the physical
address like building address or
whatever political it could also
be in some kind in some case company
then in Armadale a declaration is a node
with links to the empire of the center
link a link to the worker a link to the
client and a link to the place of work
and if in the case this place of all is
a company we have an additional link
between this place of fork and company
ok so this is the model data mining
model I would say that not the
production model which is a little bit
different
okay so limos off when foreigner worker
come to Belgium another declaration that
has been that is need is on working
sides often many company working
together
there are usually organized in a sort of
hierarchy we have a main entrepreneur
that husk some other company to work for
them on a given works work side and
those company asked other company to
work for them and so on then we say that
a company as a subcontractor on a given
rock side and this is something that has
been - that has to be declared in the
DDT application for the class on the
travel in French so in graph model did
it DDT declaration note says that on a
given work sides that we call the Depot
piece of work here a some contractor
some contractor a company has
subcontractor of course of on the
working side we have we do not have only
two company working together we have
many companies and in this case we could
have some this kind of declaration
saying that on a place of work on the
working side po here in purple a main
contractor a has to subcontractor B and
C and the C Company has another
subcontractor D okay then we can combine
those two counts of declaration if our
foreign company send out workers in
Belgium to work on some big
work site we found data into two
databases in limos articles that's a
foreign company that sent people and in
DDT because that's on a big working side
so the control service were working for
is interested in several kind of
patterns and we have here an example of
such pattern so for some legal reason I
will I want detail too much here if
foreign company is and those workers to
a client being so if a foreign company a
centered worker to a client be to work
on a given work a given work cell which
is given by a company that's in llamosa
and if DC is declared as this Company B
is declared as the subcontractor or this
company C on some big site then for some
legal reason it should also be declared
as subcontractor o of someone on this
big site okay well that's the constraint
that means that if we can find such a
pattern here so does the circle here if
you found this then we need to find this
path below if you don't find this does
there's something wrong that should be
investigated by the control service so
this main loop can be expressed in the
cipher quite easily so this is the
limo's about the part of foreign company
that sent out people in Belgium and this
is the subcontractor path so the DDT
apart okay so the the main loop can be
expressing in cipher this way so a
company a is linked to a limos a
declaration here which is so here which
is linked to a limos a place of okay
which is linked to company C and so on
and then then back to two limos a
declaration okay so that's how we we
need to write this in the cipher query
and then the path below that should not
exist is the well at least that part
below that should exist
but if we if it does not exist we need
to report it it's expressed this way so
a related to some the declaration note
here related to this data
DDT piece of rock ok so the full query
look like this oh well this is exactly
what I've shown before the where is the
not existing existing part here and what
I want to return from this too is to
return all the triplets of company ABC
that fulfills this query so we have
domains we have the main loop but we do
we do not know we do not have the path
below and for the first those three
companies I need one how many
declaration limos a declaration this he
normally demos a declaration disappear
and in a minute EDT declaration in this
appears okay well so we have copied a
lot of data from the production system
to our neo geo database that more or
less well twenty million of note and 45
billions of relationship we have notes
we have companies we have declaration
with a duplication group I'll talk about
later with addresses and so on so that
means many conflab labels many kind of
relationships and so on from this
database with a graph with with a cipher
query the psychic we had just shown
before it took me a little more less
tense are going to get 300 results and I
will switch to this no almost
okay so this is a new photo browser the
new photo browser is the web interface
that is provided with new full shape I
can see that here that I have many kind
of nodes for instance I can click here
to get a sample of limos a declaration
node and if I so those are notified
double click on a node
this says me that these declarations
says that this work so the all the data
you will see are on animals randomized
or sensitive data here so this worker
works for this company and this in this
case the client and the employee are the
same it should not usually be the case
okay here we have a client so the
belgian client he the foreign employee
here and the worker head in this case
there is no piece of work it could open
many different kind of situation okay
okay so now i can run the query have
just shown you before and a short of a
station of the this query that just give
me back one result so this is my foreign
company with this random name this is
the the patient clients the the place of
work and subcontractor relationship
between the two okay and from my request
I know that I should not have any path
from this piece of work here to this
foreign company here and I can he double
click here to expand this display so
forth so on this piece of four three GDG
declaration I can expand them and I see
that indeed I don't have any
relationship from this place of up to
this and this is not really normal and
that means that this is the kind of
situation that the control service need
to deeper investigate
so we make I got this result in less
than one second under the dabassisst
yeah 24 millions not 45 million
relationship or now on not that big
server a more normal self and and if I
run the query that give gives me the
full tip the full table of results
should take about maybe 10 seconds I
want it a little bit before he it's
gonna be faster okay so these kiss this
says me that this company as would a so
the foreign employer the foreign company
the Belgian client and the piece of folk
here present in almost 300 limos a
declaration and 70 DDT click declaration
we thought having this this part that
should exist so that's really the kind
of company that is problematic because
very often they forget to declare the
relationship between the Frank company
on the on the work side okay well if I
should have done that in in a classical
SQL or a DBMS model we need to realize
that any no Dean or any relationship
corresponds to record so I should have
more less 65 millions of records and any
LaBelle of any type usually corresponds
to a table so I should have more or less
24 or table and in my cipher query and
in relationship I have between two two
nodes relationship between a node of
type type 1 and type 2 relationship of
type well 1 corresponds to a double join
with this joint table that means that
microwave formed before will contain
something like 20 joins 20 SQL Jones
on the 20th great jump sonar data base
with 65 millions records it's well in
many cases something that will not take
10 seconds to him to run for for sure
that would be far more complex too wide
to way to understand and to maintain and
much longer to to run ok well this would
work what I've told before if the the
the the company are declared the same
way in my two database in the limos a
data base and DDT database the same way
with mean is the same official ID the
same official company ID every company
has an official employee ID or company
ID that should be used in the two
databases to be able to map them to the
same company the problem is that in some
databases mainly for Frank company that
is not one that we are told to use the
official ID so just giving the name and
the address of the giant client of the
the foreign company is enough and this
that's quite difficult to map them
together to realize that yeah that if
the same canoe we have ended that away
some company that appear in more than
thousand times with different IDs but
exactly just the same company that just
just give the name thousand time without
giving the company and then in all the
production database they are considered
as thousand different companies so we
need to deal with this to be able to do
data mining on on the data so this the
first step in
well duplication management is to
identify all the ponies all the company
nodes having the same name or almost the
same name in this example we are showing
three company nodes that have after
being standardized the same the same
name so by standardized I mean putting
everything in uppercase or lowercase
removing old enough abit alphanumeric
characters like dots and so on and we're
also removing
the legal forms like I see I'll visit
with Si and so on
so what once we found a group of nodes
is almost the same name for after
cleansing we create what we call a
duplication group node here in the
middle that links them all together so
that means that from this node that's in
the data bit in the graph database that
quite easy to find other nodes that have
the same name or almost the same name
using just cleansing technique or using
more complex technique like levenshtein
distance and and so on but of course
having the same name does not mean to be
the same company we need to use some
more information this is something that
could be done using data quality tools
like radium for instance or open refined
for open version of this it could also
be done in a Python or or whatever but
usually that's well that's that's more
efficient in in tools that are made for
that ok
an additional information we could use
could for instance be addresses so we
have address information in many
database but the main problem is
addresses is also the data quality so
for instance of the node of new phones
me some Samy sweeten up dot phones me
sometime Avenue phones me some tampons
nil on in the init Netherland in that in
Dodge so that means that before doing
anything with addresses we need again to
standardize those to put the same
address that should be written the same
way with everywhere in the in the
database so that's again something we we
need we need professional tool to do
that professional tools that have a
knowledge base to be able to do to could
not shake so him my my graph structure
says that on new phones me on number
thirty seven there is the company that
allowed on the boat twenty there is the
there's
company smiles and smiles he's also on
the Willowbrook number 38 in Brussels
okay so a note here is a street and not
an address but that such shows you've
made that allows it to to yet to to be a
little bit more flexible you know you
know you know analysis and of course we
have far less nodes in the database okay
so we can now put those things together
now and we place in any query any node
by bias we we could replace any node we
went to spit by this kind of diamonds
with in one side a one corresponding to
the company the company no declared in
one database and the
one source of the base and a two
corresponding to the the company no
declawed in the other database for
stones a one in the DDT and a two in the
limousine in our case so with this we
make sure that a1 and a2 F almost the
same name or exactly the same name
according to some constraints liquid
good we could give on this duplication
good name and also they if they share
the same street if you want to make sure
that they have the exact same address we
need to to put some additional
constraints on the label he because we
put a number in the street in the in the
relationships okay that means that if I
want to to consider that those the
company's three is the Company B is
picked
so the Belgian client is speaking to
duplicate that's quite easy to wait to
modify the the schema and then to adapt
the query well we may know that a
classical approach to process
duplicating in database is to merge the
duplicates into a proper CC
pre-processing phase by applying some
rules for instance we may say that if
the name of to Rickles is the same and
the city is the same then we merge those
two because as well as if the name is
almost the same and
versus the complete address is exactly
the same then we merge those but in our
approach in or approach adapted to the
graph database it allows us to keep some
flexibility the idea that we could for
instance want to be really sure that b1
and b2 are the same company but we could
be a little bit more flexible by
splitting aids into two companies except
images that have the same name and we do
not care about it the address I have an
example here just need to sub here well
I want this example little bit earlier
because it's a little bit longer than 10
seconds to when this sorry so this is an
whether the B node so the the the C note
so in the place of work is splitted in
two so we have one node which is
declared as the parent the the
contractor of the relationship here we
have another node which is declared as
the as the place of work on this
relationship but we know that they've
almost the same name here thanks to this
duplication node and also that those two
company nodes shared the same address so
we may think that there are actually the
same company here that was not found
before with the other the first query
that the simple query it's okay so this
will conclude my presentation so from my
personal experience and not only my
personal experience a personal
experience of many people graph
databases are really a really good
partner for fraud detection problems
from many point of view the outperform
our DBMS and from the expressiveness
point of view from the execution view
point execution speeds sorry point of
view for this kind of problem of course
for problem is we really have
relationship between entities this is
this is going to be only efficient if
the data quality is properly taking into
consideration in the model at least if
the data quality is not really good but
that's really often the case for big
database we have applied it for for
detection but that's far not only the
the the only only application domain
like I've talkin about recommendation
system infrastructure management master
data management intelligences all that
all well many
when the sector where graph database are
really interesting to consider I put
some references here on the on the
website smells research dot de I've put
in I've put the slide of my presentation
here I've put also some blogs in French
that have written on this subject
here are some well books references
about 12 database and also the fraud
detection in using graph database and I
thank you for listening if you have any
question of be happy to take them a
little bit after I'll stay a little bit
at the smells stand in the in the big
area down there
thanks a lot</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>