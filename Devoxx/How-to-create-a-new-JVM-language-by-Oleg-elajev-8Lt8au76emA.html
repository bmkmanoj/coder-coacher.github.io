<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How to create a new JVM language by Oleg Šelajev | Coder Coacher - Coaching Coders</title><meta content="How to create a new JVM language by Oleg Šelajev - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>How to create a new JVM language by Oleg Šelajev</b></h2><h5 class="post__date">2017-04-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8Lt8au76emA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so hi we're here for the session about
how to create a new GM language in under
an hour which is a very good thing
because we only have 50 minutes here my
name is Alex life and I come from
Estonia which is a country far far away
like nine time zones away so I'm very
happy to be here and while I mostly just
a mini Sonia I will to work for dirt
around which is a pretty cool company my
position there is a developer advocate
so and as such I mostly care about
community and people and developers one
of them my main responsibilities is our
blog that is called rubber labs where we
try to publish interesting technical
content and I also am a cool leader of a
virtual drug which is an online-only
july user group which is a ridiculously
amazing idea because well you can join
the meetups from the comfort at home and
twice a month so sometimes just watch
the technical sessions from the best
speakers all over the world which is
great so if you're not a user of it not
a member of virtual drug yet you should
totally join and if you have any
questions about the session or if you
would just like to chat you can find me
on Twitter which is my preferred social
network because the messages are tiny so
I can manage and that's it so enough
about me
one more slide of the necessary material
your eternal to the company that does
tools for Java developers so currently
we have two major tools one is durable
which can reload your Java classes and
writing process even speed up your
development process by eliminating the
unnecessary weight while you wait for
you build till to finish working or the
process at heart so and we have an extra
ball which is the reference tool for
Java web apps so if you are dealing with
doing work with Java where you're doing
work with Java Web Apps you were welcome
to check out the tools go download see
how they work figure out if you need
them or not my employer will be
amazingly happy if you do so and they
will send me to more conferences to talk
about cool stuff to people so with all
that necessary but not the most relevant
to the topic information away we are
here to talk about creating new
languages and when I was imagining this
talk and how it will go the main idea
was that we would create a language and
the main point is that it's actually
pretty easy to do so if you know the
right tooling if you if you if you know
what you're trying to achieve there is a
quite a lot of tinkering and fiddling
with bits involved but still it's way
easier than a lot of people realize one
question about the audience who of you
mainly working in Java who is whose main
languages Scala
ok drooly or something yeah so mostly
mostly mostly I'm quite expected that
will be with general people so this
session will not be directly applicable
to to your careers most probably if you
do not deal with creating D itself or
your customers where if you're not even
though even then probably won't be very
applicable but this is one thing that I
realized yet so while I'm watching the
keynote is that the art has its utility
also having fun has its utility
so this consider this more of an
inspirational session where you kind of
get into the world of maybe creating new
languages and if that was a long very
old dream of yours or if you just want
to get into that field maybe this will
be useful coming back to work and
telling your boss oh I watch this most
amazing session and it was about how to
create toy languages for
not the best idea ever so why do we why
why the developers really want to create
languages again and again and again
after we have like ton of them right
there our language it's almost as bad as
with JavaScript frameworks but you pick
a name and probably there is a language
based name that way the real thing is
that creating the ultimate language is
nearly impossible so the whole language
design is based on trade-offs and this
depending on which which sides we would
pick in every trade-off you would get a
little bit different language so you
could have a general-purpose language
where a specific DSL to make somebody
lives easier or you can have a language
that is really concentrating on being
fast and efficient at the prototyping or
it could be a language that you would
rather spend years developing
applications in and then it will run
very fast and give you solid job
security for the 50 years to come long
live COGO so all those questions are
fundamental to any language creation so
before you start doing that you would
like to have an idea what you are trying
to do however not all languages have to
be like very useful and we slightly
getting closer to the topic of creating
Toyland --which in the session one of my
favorite languages programming languages
is language called PF and what's so
fascinating about that is the source
code for the program Cynthia are the
images so they look like that it's like
cubism of something basically it's a
number of shape and and this image
encodes a program and the author of that
that we wanted to call it Mondrian
based on the his favorite painter artist
thrower artists perhaps but that name
was taken and the modern language is
actually quite boring way less boring to
this but we cannot all be creators of
the esoteric programming languages
but some of us could or if you have a
little bit free time you definitely
could so this is where it all starts you
have an inspiration and you have this
itch that you would like to create
something or maybe there is something in
your existing to chain that you are not
happy about and you would like to change
stuff right you would like to create a
new Java or a better Java or you just
want to figure out how to write a
compiler and the only limitation that we
have at this design phase is the
imagination as you can totally see then
you start googling about like how do you
actually achieve this would go through
this drawing of creating language from
scratch and one of the best resources
for that that I know and very consumable
for a Java developer is the series of
blog post by jakub where where he
creates language from scratch and then
add some variables and add some state
and functions and so on so and so on
and in 20 posts which probably took him
a couple of months to create he goes
into up to the point where he could
write the real application with it and
it's fairly time-consuming process even
to read through all that so today here
we will speed up all that process of
learning how to great and what you need
what tools you need to create language
how to create a language much more
efficiently but if you're interested and
if you liked sibling with languages I
would recommend that for series so to
create a language you would need basic
building blocks of any programming
language and you would need three major
components to have that so imagine all
the languages are there to specify
programs - for people to create programs
and then you do something with that and
at the other end of this pipeline the
Machine executes something and heats up
your apartment Elizabeth and produces
some outputs so to do that you need to
go to the series of steps and the first
program inside this programming language
tool chain will be the lecture the
lectures purpose is to take a stream of
consciousness
as painting over the pixels of certain
color or words or the e words for the
language the and then split it up into
some tokens that do make sense in in
terms of language so it takes the text
and it just spits out a stream of
strings and it's fairly simple then you
have a parser that changed into that
process and then takes those streams of
tokens and creates a structure for your
language it creates a structure for your
program that is semantically meaningful
within your language and then the last
part which is the most interesting part
at least to me is the compiler and the
compiler is the translator so what it
does it takes a program specified in one
way and it crunches it and produces a
program specified in a little bit
different way so typically it just goes
and translates into a lower-level code
for the next compiler to take it up pick
it up and compile again into the
lower-level code until the CPUs will see
the instructions they can understand
because nobody probably wants to
programming in in in machine code and
there are languages to that so we will
go through all those pieces and we will
I will show with the examples a little
bit later so lexing is a fairly
straightforward and kind of basically
more or less solve process so you have
the out-of-the-box tools that you can
use to create lectures and you just need
to generate you just need to create a
grammar so you need to say which words
are allowed in language and how they
look like for the lecture to take that
and parse into the string of tokens
which then you can combine into your
hierarchy the parser is where is the
interesting bits come so you the person
gets the string of tokens and typically
what it does it builds an AST the
abstract syntax tree which is the
hierarchy of those tokens that specify
operations so for example it could be a
calculator language that will have the
mathematical operations
and then you organize your whole
computation in a tree structure where
you go down and then you evaluate your
program by traversing the tree so we'd
like to run parser you can probably
build up an interpreter so you just
traverse the tree you specify which
operations of the work and you will have
the working program however the most
interesting bit is the compiler and
typically it would not be a singular
compiler but it will be a chain of
smaller compilers that can do certain
operations on this predefined structure
on this like hierarchical representation
of your program and then they can do
various things to translate it to the
machine code or some stages closer to
the machine code over they can optimize
some software so your program will run
faster or it can introduce direct issues
and bugs into your code and we will talk
about a very interesting compiler so now
with all three blocks you can imagine
that it would not take as very much time
to create language and indeed it is so
however if you want it to be useful or
at least recognized or at least
reasonably complicated then you will
probably go through the process like
this so when you write your language you
start with the prototype you use
something to generate the lecture for
you and in the parser and you implement
that and you build your AST and they
need Traverse a tasty and you see the
first outputs and you're like yeah this
semantically this language kind of works
so you you made the first step from
nothing to something that can run a
program though scroller would be slow
and it probably would be quite
cumbersome to extend further if you
would like to do so so you start writing
a platform for that where a virtual
machine or some sort of a program that
will know more about your language
specification and how it were
so it could do better things and then if
you're lucky people start using that and
they complain the Big C language is
super slow that's very natural because
people always complain about programming
languages if you have never complained
about a programming language I would
totally recommend you doing so you will
learn a lot in the process both about
programming language and reflectively
about yourself and then the language
grader would start writing optimization
things and will start writing a more
advanced compiler and maybe introduce
like an internal representation of a
program to crunch stuff and optimize on
that and then at some point you will
write a just-in-time compiler so you
language would be compiled dynamically
at the runtime and will be extremely
fast people will still complain that
it's slow but at least that would be a
step in the right direction and like
always it should be moving teacher as
always with programming languages it
kind of like and in general in software
engine it very often feels that the your
goal is something that you would be like
I would do this and I will be happy with
my thing it's just like just a little
bit out of your reach at the same time
it's always like a hurdle and stressful
and if you have to invest a lot of work
to achieve achieve that and actually get
get to the ball which is a very
interesting and somewhat philosophical
topic I don't remember where I heard it
first but solving I heard this thing and
I wanted to share so many hard problems
is expensive so it's time-consuming it
requires expertise and it requires money
as well probably so in software
engineering anything is a hard problem
and the lower level you go down to like
JVM level or the programming language
level in the operating system level the
problems only becomes harder to solve
and that's more expensive and if you
there is only one way to do something
cheaply so only things that achieve are
the things that somebody else paid for
so if you can get
something reasonable that they can use
that was created by somebody else and is
supported by somebody else this is the
good thing and this is the only way to
to actually have more fun doing
programming than otherwise so imagine
that writing a language would be a very
different process so you product up your
language preferably in Java because it's
already an amazing language and then
it's out of the box so it's extremely
fast it's extremely customizable it's
easy to maintain and it comes with a
bunch of tools for the tooling because
what language without the debugger is
like that is not very sophisticated
language more so it's a cool language
out of the box and this is what we're
going to build so obviously somebody
else has to pay the price for for us to
have this amazing ability to create
languages fast that are reasonably well
done so we'll talk about draw and
truffle so growl is a dynamic compiler
an interpreter for the language runtimes
it all started several years ago at the
I think Kepler University I think yeah
it should be a couple of University and
it was a research project and the goal
of that project was to create a compiler
that is pluggable into the JVM and that
would be dynamic and that would be
written in Java and that would be state
of the art and will produce very fast
code not surprisingly they achieved that
so now girl is a reasonably stable
industrial products it's either I'm not
sure if it's already integrated or going
to be integrated into the open JDK for
us and it works with the hotspot them
through the JVM compiler interface or it
comes with you can just download the
pre-built JVM for drying with growl
growl speculates a lot
draw does a lot of optimizations and is
a very smart compiler the main featured
why I like brow is that it's written in
Java so I feel uncomfortable when the
language has the stars and ampersands
and I need to do reference things that
kind of unsettled me so I like things to
the reunion Java and Girl feeds that
billow a lot and then the second part
besides having the compiler that can
integrate into the existing
infrastructure of the JVM we have the
truffle which is a framework for
implementing managed languages which
sounds not very impressive but this is
actually the crown jewel of the pair of
brow and truffle it is a framework for
the multi it's a multi language
interpreter framework which is which
exists for the reason for other people
it exists solely for the purpose of
other people implementing languages on
top of that it works incredibly well
with drought and in integrates they know
a lot about each other so Brown can
optimize truffle things inside but the
most important part is that truffle is
the middle layer between the language
you want to implement and all the cool
stuff that has already been implemented
and that is available for you in the
ecosystem so your language can sit on
top of the truffle and be translated
into the say truffle structure so travel
will offer you a certain classes to
explain what your language looks like
and then from the other end would be the
grippe compiler ready to optimize the
language and produce fast executables
and there will be the JMS to run that
resulting code and one of the coolest
thing is that truffle provides you with
an interface for the tooling as I
mentioned debugger more if you consider
a problem when you get an exception or
error and you would like to link that
back to the source code if you create
something from scratch its kind of
probably
not the most intuitive thing to do but
travel offers you tools to do that in a
common way and you can spend less time
fiddling with that with those problems
it is all available on the Internet
so you can just like go and download
download both drawl and truffle they
come with a sample language called
simple language so it's a it's a semi
SCI semi like large toy programming
language that counts with a lot of
features it has functions implemented
than polyglot runtimes so it can call
rather all kinds of things different
languages one of the cool things about
truffles is you can run multiple
languages on top of that in a single JVM
and they all can see each other and
interact with each other pretty cool so
the simple language is in fact not very
simple so it consists of about 100
classes which doesn't sound like a lot
but they are quite abstract they talk
about like three structures and notes
and everything and and it wasn't very
easy to get into so for the purposes of
this session I created a simpler
language much much simpler language just
to show you how the things are going and
how would you use the tools to create
language yourself so you are welcome to
download growl and check it out and play
with the simple language if you get
confused or if you like a smaller
example to set to get as a starting
point we will try to do something right
now
so without further ado I will try to
exit this and I will try to mirror my
displays
right and then we will use two main
tools we will use you see that right so
okay tu-tu-tu-tu-tu-tu poo poo poo poo
poo presentation load excellent you can
see that right maybe can be always with
order will see if there are any
questions will figure out so we'll use
the IntelliJ IDEA as our IDE to create
the whole language and we use the
beloved terminal where we would run
certain commands to generate stuff and
we will we will use this one so it's all
ready so first of all as you remember
when we are talking about creating new
language we need to define its structure
and what things are allowed in the line
in the program and what things are not
allowed in the program so and that would
be described in the grammar there are
multiple tools to generate lectures and
parsers and we would use a tool called
until our on our which which has the
ability to parse it certainly formatted
grammar files and create lectures and
allow and create the Java API for you to
go through the tokens and create the
abstract syntax trees and formalize the
semantics of a certain program in the
language so this is the example of a
grammar how it looks like until R and
you just start with defining the name
for the grammar and our program would be
very simple at this point because we
just want to start and it will consist
of an expression if you are wondering
why this grammar is not if not is not
empty and why I'm not typing all the
things
for that I'm not extremely good at
typing especially weird things and
second when you start doing something
when you start a new software project
you very rarely do so from scratch what
typically you do you Google stuff and
then you end up on Stack Overflow and
you copy the simple example and then you
modify it to fit your needs so this is
exactly what what this embodies so we'll
start with simple grammar because I mean
simpler but it's a full full full full
thing now and we'll see how it goes so
our program is an expression and an
expression is either an expression in
parenthesis or mathematical operations
we'll skip a couple lines but we'll come
to back that back later so when we have
the operators the mathematical operators
we have two parts of the expressions to
be combined in a single one and then an
expression could be just a number to
make things things interesting
our numbers would be in the format
described like that so its digits 0 to 9
then possibly dot and digits 0 to 9
again this simple thing the simple dot
is it seems trivial but it actually
introduces quite a bit of complexity
because now we have at least two data
types that we our language will support
so we'll have integers and we have
floating-point numbers right so this
means that we will need to devise a type
system for our language to know how to
operate with those different data types
and how to treat them how to maybe
convert between them and how to run the
code specialized for for different types
so probably integers could be handled
much faster than 14-point numbers so if
we would like a fast language we would
like the code pass for handling those
and that specialized and different
so with language like that with the
grammar like that what you can do you
can go and invoke the --until are common
line common line utility antler comes in
the form of a jar file there is a maven
plugin for that and whatnot but
typically they're getting started guide
says that oh just download it and expert
that in a class pass and you will get
the whole ability for you to to run the
commands from your common line so what
we say we just want to compile these
grammars that we saw from this file math
dot G for its until r4 so the grammar is
the first version and if you think about
that it's very reasonable that you would
not like to implement your own lexer and
parser where parsing grammars if
somebody else went through multiple
versions of the same name software
improving and improving them improving
again so until R is very stable and
solid and maturer those two comes with a
bunch of grammars for existing languages
as well so if you ever need to parse a
piece of java code until our could be
your help your friend so when we invoke
this command nothing happens and it
doesn't print any output but on the
background it actually generated us a
bunch of classes that call that are
looking like this for example there is a
math based listener which is the
interface that we will use to go through
the source file and and convert that
into the representation that truffle
understands so besides having a bunch of
files what you can do with antal are it
comes with the utility called dream
which is also Java class and what it
does for you it shows you an interest at
part three of the expressions that you
type in I hope this works a weird swing
utility so it that does work all the
time
but what you can do you can submit
sample source files and you can see what
forestries the Antelope parser will
generate for you so in our case this is
the part three that look it looks
similar to the abstract syntax tree that
will define the actual semantics of our
language it's not exactly the same
because the parentheses for example are
not in the abstract syntax tree they do
not change the operational aspects of
our language but it looks very similar
and you can debug that visually if you
made any mistakes in the grammar so
that's a cool thing to know and to
experiment when you create a grammars
for your language after that when we
have this the class is generated what we
need to do we need to combine everything
and actually pull into our normal Java
project the truffle managed library the
managed language library managed
language implementation ivory so since I
have this Malin project here and it's
very how they do this homework so now
from XML surprisingly truffle is very
easy to include it distribute it in the
maven repositories so you just specify
dependencies and you get those classes
for you and you get the DSL processors
and everything so we are ready to look
at how the language looks like so first
of all ah this is the wrong shortcut
something happened
Jaron lank this is how the language
looks like it's a normal Java class that
extends a certain type from the truffle
API which is a truffle language and it
has a bunch of annotations on top of
that which tell the truffle that I would
like this particular type to be
registered as the managed language in
your runtime and after that it's
everything that you need you can specify
the mime mime type and use that but
basically after you have the class that
is annotated with the truffle language
you are ready and when you run the JVM
this class will be picked up and run on
the JVM so if you want to see the main
class
the main class is super straightforward
so its main class you instantiate the
polyglot engine that comes with truffle
and then you need to get the run time
the truffle run time for you and if you
ask to the languages you will get all
the registered languages after that it
is just a question of parsing some
source creating the source files for for
your language and then evaluating them
so as we saw in the grammar we will
build a simple calculator language and
from that we will evaluate the engine
that thing sides also in the jar link I
messed it up yeah say it's an echo here
this is where the antler comes into so
if we go through a series of the first
methods what it does in the not in the
nutshell you take the input stream of
your program and then you create the
until our lecturer class that was
generated for you from the grammar and
then you create the parser class that
was generated from that and then you
walk the parse tree the tree that we saw
on that swing application and it kind of
traverse that and from that what you
need to do you need to take that tree
and build the AST the abstract syntax
tree described in travel terms so
basically you convert one tree
representation into a different tree
representation using truffle classes and
that is everything that you need to do
to get as fast and reasonably
optimizable language that is easy to
convert and we do that using a very
simple three listener so if you want to
traverse the tree you have typically two
approaches either listeners where you
would get events when you enter a
certain node and enter the certain node
or visitors were you kind of like get
the same but you just bundle that in a
single event so two
go over the calculator language tree
what we need to do we just keep a stack
of notes which are we will look at that
a little bit further because those are
actually truffle class those are our
class that implements truffle API but we
keep a stack of notes and we just parse
in free we walk the tree and when we
exit expressions we just push certain
notes so when we exit the number
expression which is just a number we try
to convert that into loan and create a
note long mode where we convert that
into a big decimal and push that as a
big decimal the operations are
mathematical operations are fairly
simple and it's quite repetitive this is
why I didn't want to type this thing as
well and then we have the parentheses
which is just wrapping the last note
pushed on the stack so now we were kind
of ready to look at the notes it all
starts with the jvm for our case it
starts with Jaylin rank node which
accepts a truffle class node so truffle
operates on a tree truffle works with a
sts and truffle is extremely great at
optimizing them and working with them so
for a language creator it's much easier
to figure out a way how to represent the
language semantics in terms of the
truffle ast rather than discard that and
implement it in a different way and then
bother to create this whole ecosystem
that comes with truffle so a note is in
the tree is something that can be
evaluated so we can it can be executed
and we will have for every node a couple
of methods they can execute as long
where they can execute generically and
this is where the type systems comes in
right so we had two types in the
calculator normal integers and floating
points and now we would like to
specialize the execution of the code for
that and that's why we would like the
separation between executing stuff
expecting normal lungs back and
executing stuff expecting objects
declaring types in truffle very simple
you just create an obstacle ass and you
just slap an annotation and enumerate
all the classes that you would like to
have other types you can have the built
in Java types because it just make sense
you would like to be interoperable with
the underlying platform and you can have
class custom types for your language for
which you will have to implement a
little bit more code but you can totally
do that and you can build your own type
system so if you would build a DSL for
example you could have multiple types
here that make sense for your DSL but
this is everything that we need to do to
make truffle realize that there are
multiple types and that we would like
efficient code to be specialized for
those another important class that we
have is language context which is comes
with a fairly large number of code lines
but the most important part is here the
context for language serves as a
namespace or at least it can surf or as
a namespace so this is where you will
register the functions being a tie to a
surname just on an identifier and then
when when truffle will need them and
when you will implement a note saying
that oh please can you execute the
functions at what's called hello world
it will go and parse the context and
figure out what the what the target of
that function is and it will work now
let's get to the notes for simple times
for leave notes of our calculator
language we would have a very simple
class you just need to say that it
extends our note and you just need to
say that oh I would like to execute
generic stuff interesting
since this is the long note it should be
able to execute long as well see that
wasn't expected but it should work
so in this long note we have to pass
passes when somebody expects long it
will execute one method and the
specialization kicks in in there for the
big decimal note which will represent
our floating point of floating point
numbers we would have just a node that
contains the value of big decimal and it
works exactly the same way except it
doesn't execute as long because normal
big decimal you cannot convert into long
and this is our data types so now our
tree can consist of of what often leaves
which are the numbers so if we just in
this running example type number it says
that it registered some functions and
then it returns the result of this
expression which is one surprisingly if
I do 0.3 it says big decimal 3 based on
so now it knows that we can do the types
of our language and now we are ready to
go into the implementing the operations
so we had the mathematical operations
and they look like this you extend a
note and for your convenience you can
specify abstract members in your note
hierarchy and it comes with a preview
DSL so if you if you use for example
Lombok of something where you just add
an annotation and it takes care of your
code adding say getters and setters or
creating properties from from your
fields or something then this works kind
of like this we can just specify that
our node will contain two node two
children nodes called left and right and
the actual country
classes for the binary notes will will
have those fields and available
pre-generated so with the binary note we
can say just our addition note we'll
extend that and it will have a couple of
operations for us so the first one is
the addition of two Long's and you don't
have to specify any code wiring or how
to convert the values into the invaded
into the operations travel will take
care of that you just specify the
business logic of how to add too long
values and in this that this time we
just use the math at exact and say left
and right those are the values that will
be provided by the left node and right
note of the children you can also add 2
big decimals since we have those types
who want to specialize the code and we
would use the big decimal API notice
that there is a specialization
annotation this is the hint to the
compiler that we would actually like to
have those methods invoked when our
arguments for that when our additional
nodes support a certain class at certain
conditions so for example by default it
will try to go into the passes method on
the top with Long's and it will do the
stuff if the result is long and
everything is good everything is good
and it will get compiled and at some
point of time grow and travel together
will optimize the tree and kind of maybe
squish some notes in the tree but if we
hit the arithmetic exception it will
rewrite this piece of code and it will
fall back to a slower code pass so it
will fall back to the adding big
decimals or just object which worked the
same way as big decimals so other
mathematic operations nodes are kind of
fairly similar the division is
interesting because there is an
exception so the same way we try to do
that if we divide stuff and
it overflows under the minimality
of the lung then we throw an arithmetic
exception and rewrite that rewrite the
implementation big decimal divide way
better than Long's because you can get
the more specified response you can have
the semantic footlongs to have the
integer division where like 10 divided
by 3 would be 3 right and just the
remainder is just beautiful gated the
disregarded but for the calculator
purpose it makes more sense to convert
to more expressive data type and also
shows for the demo purposes show the
specialization things fairly nice so the
multiplication is the same and the
subtraction is also the same very simple
so if I just go into my just main class
because I have a sample project common
symbol instruction here so now we can
possibly write some instructions to our
calculator language so if I hit enter it
will start parsing this tree it will
create the truffle ast combined
consisting of the nodes of the classes
that we just saw so our parser that we
implement it with until our and the
listener on top of that parser will just
go around the tree of this expression
and then it for every node it will
create an corresponding truffle ast node
and built one big truffle is T not big
but one tiny truffle AST expression
graph and then truffle will take care of
invoking this as a function and running
that so as a result of that we have we
see that there are only Long's and only
integers and the result is ten actually
it's supposed to be ten so this is
pretty cool if I copy this line let me
just remove this if I copy the second
line right so I
4.0 there the mathematically the results
should be the same right it's also 10
because the numbers just work this way
but in our language representation types
do not belong type cannot represent 4.0
so which will have to fall back to
decimals so who expect that if I hit
enter the result will be also launched
10 who'll expect something different
what would that be good point that's it
that's very the answer was that probably
it will throw an exception that's a very
very fair point dealing with technology
so we always bet on exceptions the same
if you there is a there is a session I
think maybe it wasn't I hope it was
yesterday called the paddlers right the
Baroque and stuff so they also asked
questions what would certain code
produce so the as a person who saw a
couple of sessions like that always bet
on the null pointer exception
that's just the rule because now for
interception always happens in this case
however we get the big decimal ten point
O which mathematically again is correct
but it shows that actually our
specialization worked we had the
mathematical operations where the
operands were different types loans and
big decimals and travel pick the right
specialization and we as language
graders we didn't have to spell we
didn't have to implement anything to
command it to the south
if I do this so yeah we notice that in
the part of the class denote right or
have a bunch of those here so in the
division of two Long's we didn't check
the division by zero and that is a
fairly like analyze a rookie mistake
because you know if there is a division
somebody will divide by zero so what
would happen if I just print if I just
type and command it to divide one by
zero for things it will throw an
exception who thinks it will print some
reasonable or unreasonable result but it
will not result in an exception who can
guess what is tax rates would be this is
interesting so we get the division by
zero because we didn't check for that
but we get that from the dividing two
big decimals which is because of the
full-back because we have the rewrite
rule on the arithmetic exception so when
we divide two lungs it shows an
arithmetic exception to us and then it
goes and face oh maybe I could just try
and do that with big decimals and it
converts the types and and and works
works like that so yeah I think I need
to rerun this now because now the
process has failed so we get an
exception but that is a very good
question it's not from the most
intuitive place where we would expect
that maybe that works yes it works so if
we would be proper language implement a
we would need to handle that case in the
division of big decimals as well let's
try let's try another one so this one
wants big decimal ten right what would
happen if I would ask
it to compute this next line that is
currently selected so all I did I took
the point zero from behind the four and
put it behind one who thinks it will be
big decimal ten point O who thinks it
will be something else who thinks it
will be an exception it will throw an
exception huh smart very nice it is big
decimal it does finish the calculation
it just prints it in this scientific
notation which is one the notation goes
that this is ten to the power of one so
the stuff after E is the power of 10 and
1 is 1 so that is also 10 why does print
that instead of 10 point oh I have
obviously no I are what happened I have
honestly no idea yeah
willing in the previous in the previous
example I also be divided big decimals
but like it's just division by 2 is is
not something that can be easily
represented so like 0.5 is not something
that can be I think don't remember sure
for sure but 0.5 kind of the 0 4 &amp;amp; 5 can
something else it's about the floating
point numbers it's hard if you implement
a language like that you will try all of
that however let's see another example
so if we if I take 2 just long values
which is the max value minus 1 and I
will add them together what would be the
result so things it will throw an
exception so thinks it will compute and
print something will be along will be a
big decimal nobody knows let's find out
it is a big decimal so here that the
rewrite rule on the street
can code hits again we have two Long's
we add them with mass exact at exact it
overflows it shows an adversary
exception truffles is their truffle is
dirty kind of back us up and it's like
oh I couldn't do this with lungs let me
try it with big decimals and that works
beautifully so now we have a fairly
trivial but sophisticated calculator
going on another think that I think I
have a couple of minutes yeah I have
some some minutes I also have some
slides but I want to show you this how
to extend this so we skip this important
canonized feature here in the grammar so
this arrow something expression what I
want this to be I want to evaluate that
expression here that goes after the
arrow on a separate thread I want to
introduce a little bit of concurrency
into my language when it's not proper
concurrency but you will get the idea
how to implement that so imagine if we
just added this line here to the grammar
then we need to parse that in our
listener so if you open the listener and
we find this async expression a listener
method so what we just do we push a
certain note which looks like any other
node in our truffle API objects but
however when we execute the generic and
you can see that when we talk about
concurrency we don't really care about
what type that is is a small longer big
decimal so we just easily detect stuff
what we do we run the expression
execution on a different thread through
the completable future and then we if
something goes wrong we just say okay
yeah we give up because it's a
calculator restarting but I would like I
would like there's just show we also
blocking the gap so it's not a truly a
synchronous computation but it gives you
an idea how if you would like to expand
the computation on where I introduce
like larger types like maybe completely
futures into your type system and then
do the lazy evaluation of expressions
this would be the starting point so now
if we just do this again and have this
amazing
expression is this valid expression yes
because it's the async expression
followed by another expression and we
can see that we evaluate that note on
another thread this is not the most
interesting example because this
strength is not over written but if we
do something like this we can see that
we actually get the nice message why we
have that nice message because our
binary note supplies the two string
methods which is very important for
debugging purposes because you will get
a lot of mistakes in the code and you
will rather see normal representation of
your language structures rather than
travel higher objects at hashcode
something-something so and indeed you
can see that it's executed on a
different code on top of that the next
the next thing that you would build in a
language would be probably the functions
and you will add me to add grammar and
you need to enhance the listener and so
on but I just would like to go over a
couple of slides just before we finish
so what we did in this very hasty
session running through code right there
so we started with expressions that are
the mathematical operations with
different types Long's and big decimals
and we looked at the parser that was
generated for us by Aunt Laura and we
created the abstract things like syntax
tree in terms of the truffle object so
it all come back to the truffle and then
that Unicorn is obviously the truffles
framework and it ran on our normal hot
spot jdk and it produced some sort of
result sometimes tempo at all so that's
how you basically you will need to
follow those steps to create any
language and you will need to solve a
bunch of trade offs so truffle is fairly
fast and especially on growl it has
multiple languages implemented on top of
that so Ruby and jeribai now they work
fairly closely with truffle team and
they
have the truffle Ruby so he do Ruby
development you were really really maybe
should check that out and it runs fairly
fast so if you if you look at the
JavaScript for example it's it's just a
little bit slower than I think that's
the eight or something in the in the
slides so benchmark is not by needs
benchmark by the travel team from last
year there was a book about Aunt Laura
how to grammars if you like probably you
if you are getting seriously considering
starting writing toy languages to work
maybe not so two languages probably you
want to read about grammars and the
parsers there was a lot of intricacies
and recursion schemes and left recursion
writers version and the terms and verbs
and whatever it's not that easy to just
come up with that on the spot what
travel offers us it's off of us a
support for very simply defined type
systems types usually in programming
languages used for two reasons first
they show if the program compiles a lot
and they hint the developer about what
they're dealing with and the second
types I used at the runtime for figuring
out what the code what code should be
executing and based on that the compiler
works efficiently advanced compiler can
figure out which code to execute which
code to compile further or optimize
further so truffle and the types that we
saw on that are more on the runtime side
you also can build a compiler and the
verifier for the curio types but that
would be you would need to take a
different approach the Interop between
the language and the runtime underneath
is very simple truffle is a polyglot
engine so all languages can export
symbols to the general global context
and all languages can call all other
languages so you can call JRuby from
JavaScript and all that will be run on
truffle and the trees AST so that could
possibly be merged and if you run it on
the ground not on the hotspot I think at
least not now
they can merge that and compile that
mass of two languages into a single
executable which will be much faster so
the Interop should be no problem if you
want to talk about concurrency truffle
doesn't offer you much but well given
the power of GM you can pick whatever
whatever primitives that he need so if
you don't want to believe futures just
pull in akka threats akka actors or I
don't know fibers or any any primitive
that you would like if you want to check
out the language that is built for
highly concurrent performance
applications based on actors there is a
thing called Pony lank with a very
adorable logo of a small horse you
cannot avoid garbage collection because
you sit on the JVM so everything will be
managed in terms of memory well you
could very soon you can probably plug in
the epsilon garbage collector that
actually doesn't collect and kind of
manage memories yourself if you're that
sort of person and just to finish this
up the combo of growl and truffle are is
it's very sophisticated very easy
compared to any other language or
compiler tool chains that I've seen I'm
not an expert but this was the easiest
way to get into that so if you are
interested check out the project they
are both on github so you can just I
don't know start the repository and
watch that and see how development goes
and learn things and and and be there
and well the best pro tip for running or
creating your own languages there is a
main trade off between optimizing the
runtime and how it executes and
optimizing the extra stivity of the
language basically the standard library
of that and well most probably you would
like to focus on one of those which is
more interesting for you and just reuse
the whole thing from the other one so if
you're interesting creating an esoteric
language focus on the library and just
reuse the coal runtime for
JDM travel and growl and however much
you try people will still complain about
your language and there is no way to go
about that the only language is nobody
complaints our are the ones that nobody
uses and with that we are at end</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>