<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>“Right Size” your Services with WildFly Swarm by Heiko Braun/Dimitris Andreadis | Coder Coacher - Coaching Coders</title><meta content="“Right Size” your Services with WildFly Swarm by Heiko Braun/Dimitris Andreadis - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>“Right Size” your Services with WildFly Swarm by Heiko Braun/Dimitris Andreadis</b></h2><h5 class="post__date">2016-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/S8L9qTaEO7Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">it's good afternoon my name is haiku
Brown I've got a fellow right here
Demetrius and rallies we're both from
Red Hat and we are going to talk about
what let's warm this afternoon
in particular in the context of like
right sizing services and we get into
that in a in a minute what that actually
implies so when you attend conferences
like these there's two things that you
typically two terms that you typically
run into monolithic architectures
Microsoft's architectures one way or the
other the big question that always comes
up the discussions in the in the in the
hallways are typically about like bold
claims made for one side over the other
so there's people pretending that well
monolithic architectures are easier to
reason about and soft we should stay
with that other people are all into
micro services for all the benefits that
maybe they may bring in fact the
industry as a whole I believe except for
very few companies has a lot of
experience with with like large-scale
micro service architectures so the
question this raises is this an
either-or decision and when I thought
about preparing these slides I it
reminded me of of a quote from an
American author called Ming Ming said
well there's always a well known
solution to every human problem it's
neat
plausible and wrong and I think in the
context of this discussion why I brought
it up is that we shouldn't believe that
neat plausible micro services are going
to solve all our problems
neither do monolithic architectures so
it's really about engaging with the
thought process like what's right for
our specific circumstances to frame this
discussion I think it's useful to to
further look what's actually implied in
these names or in these terms that we
use
if you look closely we easily speak
about the monolith or a micro-service
but in fact it's it's really about
monolithic architectures so it's about
the properties of those architectures
and micro-service architectures going
further looking at what the IE says
about like what what actually is a
software architecture they define it as
a fundamental organization of a system
embodied in its components and their
relationships to each other and to the
environment and the guiding principles
for its design and evolution I think
that that's a quite useful approach to
kind of like address all the questions
of where we position ourselves when we
have to take architectural choices and
if you further break it down into
different properties attached to the one
side or the other you see that typically
in monolithic architectures we talk
about at a very at the market level at
very at fewer components things that we
have to worry about whereas the
microservice architectures we typically
have many of these things quoting
Jonah's bony he says
micro services typically common systems
right so it's not one single service
it's it's a bunch of them the
relationships are quite different so I
just added a few things that came to my
mind preparing this talk hmm and
monolithic architectures typically you
have like when you consider the space
aspect
things are co-located whereas in micro
service architectures the services are
typically distributed so regarding the
time aspect monolithic architectures
typically force you to change things
together whereas one of the tenants of
micro service architectures is that you
can change services independently there
are many guiding principles but just to
name two very general ones that I found
useful for this discussion is that it
seems monolithic architectures are
mothers in the
need for uniformity whereas microservice
architectures propose diversity so the
worst choices of run times programming
language is cetera
it's a non exhaustive list so you can
add your own ideas it's really just to
set the scene and frame the discussion
the way I see it and it's useful to to
guide these explanations that you've
seen in a minute about what what
multiply swarm actually is and what it
brings to the table I think it's very
useful to understand that there is not
one way or the other you know it's
actually about a continuum of
architectural choices that we have to
make so there may be monolithic
architectures on the one hand this is
where we are coming from what we are
almost familiar with and micro services
on the far other hands but there's also
something in-between when you're coming
when you're coming from Java EE the
question is where where would you
position yourself like if you have to
put a stick in the in the ground like I
would think that typically most Java EE
applications tend to be reciting more to
the monolithic side to the left and in
my diagram here so why why is that the
case
well application servers have been built
to accommodate each needs the guiding
principles have been slightly different
and the way we used them have been
different as well but in fact it doesn't
have to stay that way
and this is what leads us to while flies
swarm
so hi I'm Dimitri some the engineering
manager of the wild flyin tables the
reprise application server team so this
part of the talk is about well fly storm
itself which is a it's a sister project
- - while fly or a sidekick project so
while flying term is internally you know
the same one called JBoss application
server so obviously it carries a long
history behind it it started about 15 or
16 years ago so the basic idea behind
swarm is that we essentially have a
transformation process we take the
typical application where in Java it
involves most probably some kind of
runtime and application server in which
you have your base api's and services
implementations of those services and
the application makes use of them and
through this transformation process we
want to take your app and the pieces of
the runtime that are relevant to your
use case and package them together and
make this self-contained binary that you
can execute and it's more aligned with
you know DevOps practices and and cloud
environments and and all this stuff so
so in this in this way you you have the
option of right sizing your runtime so
you can start from monolith and break it
down in you know more and more smaller
monolith there was a very good talk just
this afternoon talking about modular
monoliths and how you can create either
you know componentize slice of your
application with some services included
and maybe a separate web layer and that
can be very good you know use case for
for the majority of
systems if if you know scale is not your
your first priority or go all the way to
the right implement you know
micro-services there dozens of way to do
that so swarm gives you you know options
during this transition and of course the
goal of swarm is this uber jar the fat
jar or however you want to call it which
will bundle together you know
application and capabilities so in while
flies swarm parlance capabilities are
fractions we will talk more about the
fractions but for when looking at this
fat jar you will find inside of course
your app and there's an internal maven
repository that will contain the code
and the module two for the fractions
there is some bootstrap code obviously
to glue everything together
and it's also the notion of a of a
hollow jar which is the same thing -
your deployment so your your actual
application and this is interesting to
cases where you know you're developing
and deploying many multiple times a day
possibly so the part that changes is
actually your applications are at the
runtime the customized runtime might
remain relatively constant so you don't
want to pay the the cost of transferring
this runtime back and forth so you have
this option as well now since I come
from you know the JBoss part of the
house and in wildfly I should say a few
things about the the base base runtime
that enables both well fly and and well
fly swarm this comes from a sub-project
of the wild flap location server called
the world flag core
and I think there are few pieces that
are interesting for this discussion some
capabilities that we've built into this
this kernel when we did our that's our
third-generation refactoring of wildfly
so you know 15 years project the third
generation was created sometime around
2010 so some key characteristics course
the the modular architecture so we we
have our own module technology of course
before Java 9 and all the stuff that
comes now which helps a lot if you wanna
split the server into pieces and
capabilities so you can pull it into
well fly swarm and it lets do more you
know nicer design you don't have class
loader here you you can combine pieces
more easily and the other piece which is
very interesting is our kernel we call
it the modular service container which
is a has this property that I don't
think anyone else has it it's it's
concurrent so when we design the third
generation of application server we had
in mind that we have more or less peaked
in terms of how fast processors can go
so now processor have more cores and to
make use of the course you need you know
parallelism and the fact is that most
frameworks when it comes to boot time
they're pretty much serialized except
one fly well fly actually booting
parallel so we don't we don't have to do
a lot of lazy loading tricks we do some
lazy loading but not too much so when
you boot the server you have you know
parallel threads you know executing your
deployment plan so to speak which leads
to very fast and lightweight runtime
that can scale from the biggest monolith
to the smallest microservice and I think
that's interesting we also have some
features that leads to you know cloud
friendliness so for example we have
replaced Tomcat with
our new web server called undertow
undertow was designed from the start to
be a synchronous based so it leads well
- you know reactive based applications
or applications that need to scale at a
high level and it's very fast also you
can find on the net some very
interesting benchmarks compared under
those the other web servers and there's
also other interesting things like you
know multiplexing all protocols over
HTTP whether you know JSON or rate or
you know even
rmi even you know JMS so we can do all
those those nice things to reduce the
number of ports we're using the cloud so
back to fractions fractions is our
compositional unit in swarm and it's
really maven artifact and the fraction
builders what what they do is they they
include the code essentially - they have
a means to package the capability so
when you're thinking about capabilities
when it comes to Java just think about
you know AE api's so things like JP Ajax
RS CDI those are separate capabilities
that we treat us as far as fractions and
the fraction code will we package this
and we'll have a way to configure this
capability when when it brings it to the
runtime and we'll do that with some
reasonable defaults which is key in
swarm so when you bring the various
fractions into your runtime you don't
have to do much work which is very
interesting and for the most common use
cases where you want to override things
you know that are common like a port
number or binding address you can do
that with properties that's you know a
very easy way or you if you are more
familiar with the wildfly configuration
model you can actually use XML
so swarm can accept the the stand allows
don't XML descriptors that we use to
configure the application server if if
that is your your choice and swarm
contains large number of fractions about
80 something fractions you can discover
if you go to the wild fly swarmed at i/o
website half of them relate to Java EE
half of them relate to other
capabilities that a hiker
will talk about to connect you with you
know cloud services discovery
distributed login and all those nice
things and you know more fractions are
added some of them are stable some of
them are experimental so you're welcome
you know to join the community it's very
you know welcoming and it's an open
source project so you know you can add
your own fractions if you want now to
enable whiteflies form you you have to
use either maven or cradle but maven ism
the primary you know supported use case
so all you need to do basically is just
stick the the swarm plugin into your
palm and and then not specify as
dependencies as maven dependencies that
the fraction yet that you want to bring
into your application there is also the
option of not specifying any dependence
in which case farm we will enter a mode
where it will try to detect what you
what you want to use for your
application so it will check all the
imports of your classes and it will pull
the fractions that are necessary and
fractions core have dependencies so so
when you when you know when you ask for
you know jax-rs jax-rs might bring in
login for example and there's also ways
to have you know collections of
fractions order or some name so
again heiko we'll talk more about this
about micro profile so micro profile
more or less defines three different
fractions that are brought together and
that's pretty much it that's what you do
to enable a standard Java EE project and
and make it you know swarm fat jar so
then you do that and then you do maven
Packard's and your war or jar will be
packaged together with the fractions and
you will get back this my application
does harm that jar so that's the fads
are and then you of course you have
different ways to to run it you can run
it directly on there you know Java - jar
the name of the jar it's executable
obviously or you can run it through the
maven well fly swarm run target or even
you know in the ID you can click on on
the default swarm main class this is our
go well platform swarm class or there
are cases where you can also provide
your own main if you somehow find that
the configuration options the default
ones offert does not do what what you
want to do you want more fine-grained
control you can get control of main and
this is roughly how you do it so you
just provide you know main class you
reference it from from your poem and
this class you you instantiate the
runtime so the the swarm class
represents the swarm runtime and you
just create it you add the fractions in
terms of code so in this example we see
we we add the exact RS fraction and we
just accept the defaults you see there
is nothing we configure nothing there we
just add this fraction and when we're
done we go and we say start the runtime
and deploy the default maven artifact so
if if that was a war it will
we deployed and started and you know for
this use case you see now I just want
like sucks RS if you try that with some
lucky application you will get something
like a binary that's about four point
five megabytes big and can boot in you
know one one and a half second and there
are cases that you will not have more
fine-grain control so in this example
you see how you can configure it data
source and a Ana JDBC driver so
obviously there there is no reasonable
default when you want to connect to
database you have to say you know I want
this database driver and those are they
you know the options to connect to the
database so if you do it in code you
will create the datasource fraction and
you have this fluent API to configure
every single you know detail in in the
datasource and it's interesting if
you're familiar will fly with well fly
you might see the difference between the
names of the functions and the
configuration model in a wild fly so in
fact what we do is we actually generate
the fluent API from the schema that
describes the configuration model and
and that's that's how we do it and with
that I will pass it back to to high code
to move you further into this this
journey with more advanced use cases
you've got an outlook how our swarm
actually works so they do as he said the
basic idea is like deconstructing the
observer and putting it back together
pairing those parts of your application
with just the parts of the runtime
actually required so far everything is
based on Java EE that's where we're
coming from if you remember the
continuum of choices that are online
outlined in the beginning and actually
if you listen to people like Adam bean
for instance he has an excellent video
channel where explains what what you
actually might be doing with Java EE can
take it very far like if you want to
move into micro service areas so Java is
quite capable of doing many things and
there's good reasons to stick to those
api's that you're familiar with but the
further you transition to the micro
services side like at some point you
uhit cases where you need additional
capabilities things that are not given
in Java EE or box and these toolkits
approach that we take in swarm to
transform like the application resources
using the fractions into standalone
binaries that's one half of the story
the other half is like bringing it in
additional capabilities that you that go
beyond Java EE so you're moving to the
right and the first thing that you
notice is that the complexity basically
moves elsewhere so we've got a nice
monolithic architecture as well it's
it's easy to reason about everything is
in one place it locks to the same file
Diagnostics are fairly simple to do but
the downside is all the updates to the
application that moves as a monolith
have to be coordinated outside of the
technical region so you need to talk to
your peers and make sure that everybody
agrees on the same release date before
you can put something in production this
is actually why people look into micro
services on the other end because here
if cuts well-defined services hopefully
with dedicated teams behind it and these
services are to be moving separately so
but what you see is here you get the
benefits of moving separately and faster
but the complexity for instance the
operation complexity and drastically
increases plus you are actually moving
from like a single co-located thing to
like a distributed system the point here
is not about saying one way or the other
is preferable it really depends on where
you're coming from and what problems you
need to solve and what kind of
architecture we are talking about and
what systems you need to build so I
think it's better to frame this
discussion in in in terms of like
there's better or worse choices
depending on what you need to achieve
folder multi folder mm identifies three
testing competencies so he coined this
term like you need to be this tall to be
able to move to Microsoft's
architectures and this is the article
that's reference right here it's it's
super file read and the gist of it is
that he outlines three different
competencies that are needed to really
make use of the benefits of Microsoft's
architectures promise so you need rapid
provisioning that means like the ways to
stand up servers quickly you know when
they are needed it shouldn't take like
several weeks to all our box sent it to
the data center and have somebody
setting it up today should be a click of
a button and cloud infrastructure for
instance you need additional monitoring
capabilities obvious reasons I mean the
operational overhead increases to a
significant amount things get
distributed as a lot of services running
in parallel they update cycles are
different so how do you get an overview
of what's going on in the system and how
to eat through your diagnose problems
and even more importantly all these
micro services ideas don't buy you
anything if you're not able to really
rapidly deploy the application to
productions or that means taking it
through the whole chain of like
implementing the new functionality
running it through the testing CI
environment into production faller and
many other people agree that this should
be automated and to end ideally not
everybody sends in the same position to
achieve achieve that but interestingly
these are really just competences that
are not that it's general applicable to
both monolithic architectures and
service-oriented architectures and going
back to swarm this means that there are
some if you move across this continuum
to more service-oriented approaches for
the benefits they bring there are many
aspects that you need to consider that
go beyond swarm so we have swum is in
providing the continuous deployment
pipelines you know we are not going to
provide you the cloud environment that
you are going to deploy to that these
are just things that you need to be
aware of when you make a decision like
where to put your stick in the ground in
this architecture continuum but
nevertheless tools like swarm can
support you in three different ways so
first of all extending the functional
scope of what's inside Java EE providing
additional integrations with like new
technologies other systems etc that
means like additional libraries
configurations stuff like that and
extending the programming model that's
that we have in in Java EE and this is
best outlined if we look at a few
examples in the next few slides of what
you can find out of the box in swarm
there may for instance be the case when
your application so we now have think of
a self-contained binary and this moves
across the different environments as
Dimitri's outlines in swarm by default
everything is baked into the binary for
good reasons you know you want
reproducible results across these
environments you want to prevent
configuration drift so it makes sense to
kind of like nail it down and have it
traceable back to us
line-in commit a single commit messaging
kit you can say well this was the change
introducing a configuration modification
that led to this behavior in the system
but for some cases this doesn't work out
the JDBC URL that he demonstrated is a
good example so you need a different
database to test within staging
environment and another one in
production in swarm one way to go about
that is to pair the self-contained
binary with an application your project
stages Yambol that you see on the
left-hand here it's broken up into like
different documents and in Yama speak so
this is like the small dashes that you
see and each stage carries a logical
name so there's one stage for
development or on stage for production
and the idea is when your application
moves through these different
environments you can flip a switch to
enable of configuration overlays to
change the lock level the JDBC URL
anything that might change between stage
in production other environments that
you Traverse here
that's out-of-the-box behavior it's not
a specific correction it's something
that we just inhale inherently provide
with swamp another common case that you
run into like if you move from
monolithic to Microsoft's architectures
services need to talk to each other so
how do they actually find them it seems
to be obvious but there is no common way
to achieve that there's a bunch of
service registries that you can lean on
like console zookeeper cetera but it
needs we need to provide means to kind
of like advertise our existence for
others to look up the service and get it
to to kind of like interact with it what
you see here on the left-hand side it's
basically it's always a couple of like
this is the fraction dependency that you
can refer to and at the bottom in this
case you see an extension to the
programming model that allows you to
kind of like say well this particular
deployment should be advertised
the pricing service so we've got a bunch
of integrations with like various those
registries for OpenShift for console et
cetera another common thing that you may
run into is the need for providing
health checks to the clock which is
particularly relevant in cloud
environments so if you think of for
instance kubernetes based systems they
break down into a scheduler and the load
balancing component and somewhere in
between these these boxes in between
those are the services that you built
with much less warm in kubernetes the
terms are liveliness and readiness
checks so there is a time when the
scheduler says well create another
instance we need to scale up the
workload because the or the number of
nodes because the overall load of the
system increases and it needs to know
when when it's ready to perform actually
work to be registered with a load
balancer this is the readiness check
liveliness is is the corresponding way
of probing into a working node and
checking if it's actually able to
perform work these are typically
application level concerns so one way I
didn't implement so our example
programming extension down here that you
see is an extension to the jax-rs
specification or CDI specification you
add an health sanitation and it provides
an API for you to signal if the system
is lively or not by indicating health
status up or down here it's always up so
there is no logic to actually verify
anything it might be a call to a
third-party system to verify that the
system is actually it available like the
database performing file system checks
memory whatever is useful and reasonable
in your specific cases and this is then
used to provide an entry point to the
scheduler down there where it can poke
into your system continuously and
periodic times to see if it still has if
it's not healthy or just discard service
and
schedule another one again just an
example of something we already have so
here the dependency of the fraction is
called swarm monitor which gives you
both like the service part like the
underlying runtime capability to enable
this HTTP endpoint that's and
discoverable and supports a specific
wire format and an extension to the
programming model by bringing in one
simple dependency and as we move on you
can hopefully get the idea what we are
trying to do with Swan so it's both
extending the base capabilities that you
find in Java EE sometimes this requires
us to extend the programming models like
in this case and overall hiding the the
complexity behind that I mean you could
do the same thing like implementing a
custom HTTP endpoint using jax-rs but
there's a lot of nitty-gritty details
that you need to worry about another
common issue that you find when you move
from service-oriented architecture from
monolithic architectures to
service-oriented architectures is you
think of the system like when it's being
decomposed you break it up into distinct
services and these services kind of like
interact with each other in our example
here what's happening is that they
client might be a browser client invokes
on a service and this service then
requires to talk to another service or
there's a series of interdependent
remote calls which are all good
throughout most of the time just in the
one case when it's not good anymore and
all you see on the client side is that
the request takes forever now with
everything being distributed running on
different virtual instances that are
ephemeral also so it's really hard to
tell like when when they come and when
they go and where to poke into it's hard
to say was it the library that was like
taking up all of the processing time or
to store the price
servus so this two beauty tracing
Connect brings this information forward
it conceptually it just attaches the
client the first invocation from the
client with a generic and you UID which
is then propagated through all these
service implications and each service
here has an instrumentation side which
kind of like text it information and
reports it to some storage back-end so
when you then go to that back-end for
instance Zipkin provides back-end or
open tracing provides another one you're
able to see similar a similar
representation a graphical
representation of how a complete series
of requests unfolds again here the case
is you see an example of how it's being
configured in swarm it's really just
adding the Zipkin fraction and telling
it where it should report the data what
the results ampere rate might be cetera
so there are some configurable settings
but the wiring like actually attaching
that to an incoming HTTP call that's
then mapped to adjuster s resource which
performs the business logic and returns
the response is something that's taken
care of under the hood so you can think
of fractions as internally they actually
do much more than then they look like so
they bring in api's in some cases here
they also instrument like the HTTP
invocation so they integrate without
that should be subsystem in that case
but they also tweak web.xml for instance
if needed like whatever is required to
set up that functionality and properly
integrate it into the overall
application so if you think about this
example here the client doing the remote
invocations and assuming that all the
services are separate and have to cross
network boundaries it's useful to see
that I was one faulty guy like
in nine out of ten cases the store may
be failing and taking up all the
processing time typically in inept
service as of today most of the
processing is still attached with single
thread so they were invocation comes in
we attach a threat to that we run
through all the business logic and then
we return the result and free the threat
the issue here is in those situations
what might the customer that they
decline actually see here it sees a wait
waiting indicator and it's browser that
spins forever what do I do are typically
reload and I reload again so with every
reload another threat is being spawn up
what tools like hystrix for instance do
hystrix is a component that comes from
from the netflix open source environment
is that they collect detach or
encapsulate certain invocations
in separate commands that run on a
different thread pool so that's the one
thing you can think of a simple runnable
that's kind of like taking performing
the job that's in creating the web
client here and doing the remote
invocation and then processing the
response just the fact that it's
happening on another thread frees the
calling threat from like being stalled
but in addition to that it watches the
execution of that command and aborts it
if needed so it really stops the
execution if exceeds a certain time out
if continuous problems occur
it kind of like shuts down and switches
to a default fallback to fail fast until
somebody fixes the problem here again
swarm kind of like takes java a little
further or the use cases that you may
anticipate by bringing in other
components here that hystrix component
in a way that history itself is already
set up and prepared for you to make use
of it and it at the same time extends
the programming model by introducing
this circuit breaker annotation so this
is just another way to
and straight like how this our fractions
actually so bring in additional
capabilities and extensions to the
programming model and all of this just
to support your journey from the
monolithic architectures to the
service-oriented ones there's plenty of
things to it much more that I can go
through in this session
so as dim to set we've got roughly about
eighty fractions at the moment and half
of it are dedicated to Java EE so when
you get going with what fly swarm the
first thing that you notice is
practically all Java EE capabilities or
the the Madrid majority anything that
define and wild fly it's supported
out-of-the-box so you need jax-rs you
structure as neat JPA use JPA the other
half is dedicated to things that make
the transition to service-oriented
architectures easier like in the
previous examples
so there's integration with locks - and
fluent ease or if you have the
elasticsearch locks - cabanas stacked
running somewhere to collect all your
logs to make sense of what's going on in
the microsoft's architecture there's a
fraction to integrate logging or to
change the logging to push it to a
remote system into network in india that
remote and there's integration with
netflix ribbon so ribbon is another IPC
library from from netflix that tightly
integrates with with histories like with
the previous resilience examples it can
be used as an alternative to using jacks
or s client api as for instance we've
got support for various service
registries i think in the example
previously a demonstrator or a showed
how how to educate with console consoles
of prominent one written in golang there
is plenty of work happening to ease the
integration with OpenShift or kubernetes
based environments so the hell's
checking for
instance plays into that there's work in
the pipeline to support kubernetes
config maps so if you think of the
initially the this quick configuration
in the brief configuration example that
we did rather than having a file in
kubernetes you can have like system
provide all these properties to you the
determinate system which is called
config maps and there's an integration
with that there are means to kind of
like bring in swagger to document your
services so swagger is a way to annotate
your jax-rs resources so that it
generates a contract description of that
our own API description it can be
displayed and handed to other people who
need to invoke with that service here
again an adding swagger would just mean
bringing in the swagger fraction which
also brings in the API for swagger that
carries the annotations that you can put
into place but also the instrumentation
cannot render the swagger
J'son file that describes the contract
at the end without you having to touch
all the nitty-gritty details we've got
an integration with vertex so what X is
the JBoss approach to reactive
programming here the integration is yet
another fraction that allows you to kind
of like specify which vertex event pass
you want to talk to so you can dispatch
events to it and receive events through
it into message driven bean lets you
locally have a management in finished
been integration we inherit all the
management capabilities from from
multiply itself so what fly has a fairly
sophisticated management infrastructure
you can remote manage all the nodes that
you spin up with one fly swarm using
either of the tools it might be the
command line tool to poke into a node or
the web management interface there's
integration with active and queue we've
got many of the components integrated
with a tool or product or key clock a
clock
Identity Management authentication in
single sign-on which is quite useful if
you like break up into different
services and you need to secure like
service to service communication this
requires quite some work on various
levels on edged P level and on the on
the jax-rs level and this is taken care
of
there's extensions for contract based
testing if you're into that or familiar
with that so our contracts testing is
the idea of having rather than
integrating everything and running one
integration test suite which in
Microsoft in areas can be quite
cumbersome or a lot of effort at least
you basically specify the client side
contract of what the client invocation
would look like on a service it's being
recorded into a description of that
contract which then can handoff offline
to the service provider which we place
these events to make sure that anything
the client expects to do the service
implementation is capable of doing so on
by this it detaches or it prevents
having both services to be instantiated
at the same time and verifying it
through more sophisticated and
integration tests much of this work that
goes beyond Java EE plays into an effort
that you find on this conference as well
which is called the micro profile I'm
not going to share too much about it but
their basic idea is to take enterprise
Java to a level that's suitable to
address all these service-oriented needs
you know if you move through the
continuum a lot of questions come up you
need additional integrations to go and
in the micro profile you basically
feedback these ideas that I demonstrated
here into a wider group it's an open
collaboration between like single
individuals from the community
representatives from the from the the
different windows implementing
tools like swarm with the attempt to
find consensus like to see what works
wasn't what's needed and possibly
standardized it but it's just a name I
would call it a pre standardization
effort so it's about like figuring out
what's actually needed today by
Enterprise Java developers and finding
common ground between the majority of
Wenders so that you get a kind of
application portability and reduced risk
with that but still being able to
proceed quicker than we did with the JCP
and other terms which doesn't mean that
nothing of this will could then actually
end up in in in Java e8 and in fact if
you look at the Java one key load of
this year you find some of the ideas
already proclaimed by Oracle themselves
so they change the technical direction
of e8 to accommodate some of these ideas
that we saw here already so EA it is
supposed to include health checks it's
supposed to include configuration you
know it's a little bit uncertain where
the journey actually takes us but this
is just a outline that swarm has the
intention to kind of like bring it into
the swamp open source project first then
feed it back these ideas into the micro
profile and from there it may be ending
up in the Java EE 8 or in other future
version or just recite within the micro
profile if you're interested in this
particular topic there's a buff tonight
so at 8 o'clock where we just meet and
greet and talk about what might be
useful or needed in future terms and
there's a session tomorrow morning where
people from Ferrara
Tommy tribe whiteflies swarm and IBM
Liberty actually meet to demonstrate how
what we've achieved so far
so coming to an end
what we try to address with swarm is to
provide a spectrum of possibilities so
it's really about enabling choices one
way to go about the next project might
be a combination of monolith and micro
service architectures so taking a
low-risk
element of your monolith extracted to
become a service and leave the remainder
on your application server that's
totally fine learn along the way like
figure out where the nitty-gritty
details are what the caveats are where
the problems are what's challenging and
how the organization maybe needs to
align with that an alternative approach
is something referred to as
self-contained systems and there's an a
fabulous webpage about self-contained
systems if you google it from some I
think it's a bunch of German companies
who coined this term and self-contained
systems take many of the guiding
principles of Microsoft's architectures
but I are less rigid about the
decomposition so you could think of a
self-contained system as a smaller
monolith it still has a front end and a
persistent storage but they the aim is
here to kind of like provide a more
majestic monolith that moves fast given
that you have like rapid provisioning
and rapid deployment kept competencies
in your organization without taking it
too far to the right end and I believe
that there's actually very few companies
who take it to the extreme I mean not
everybody is Netflix or Amazon we we
wouldn't all have like thousands of
services that are updated every minute I
think in the future it's more likely
that in a few years time I think we see
that this idea is kind of like converge
that the micro services side learns from
like the monolithic parts and the
monolithic architectures learn from the
micro services and there there will be a
new term maybe for for these kinds of
architectures so
thought bugs came up with this idea of
calling it evolution evolutionary
architecture so - - can I get back from
this what's really a bad choice to call
it microservice because it implies like
something small
the first reaction from the programming
communities or these practitioners who
attend these conferences like this was
well that has to be measured in in lines
of code which doesn't make sense and
today we're a little bit more smarter
but in general the our partitioning
practicing communities like all the
software developers out there are the
architects all the people involved but
building software are still in a way to
learn how this could actually best apply
to their own circumstances and I think
swarm as a takeaway message is an
attempt to kind of like address the need
for people coming from Java EE to engage
with this journey and help them by
bringing in additional capabilities and
the aim to kind of like hopefully
standardize or priests and entice some
of that Thanks
so there's a project webpage it's a
friendly community engage with the
community ask questions for the
remaining ten minutes we've got a
microphone right there Demetrius and I
will be around so if you got questions
this will be the time for it
good thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>