<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Optional - The Mother of All Bikesheds by Stuart Marks | Coder Coacher - Coaching Coders</title><meta content="Optional - The Mother of All Bikesheds by Stuart Marks - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Optional - The Mother of All Bikesheds by Stuart Marks</b></h2><h5 class="post__date">2016-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ej0sss6cq14" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning thank you for coming my
name is Stuart marks I work in the core
libraries team in the JDK group at
Oracle so today's talk is optional the
mother of all bike sheds I'm not really
going to explain all that this is about
but the notion of bike shed is that
optional seems to be a pretty simple
class but it's generated email
discussions far out of proportion with
the amount that's going on in it or the
amount that's apparently going on in it
and it seems like under the covers or
around the covers there's a lot more
that's going on that might meet the eye
hence this talk so what I'm going to do
is just go over the basics of optional
what it is why it's useful and show some
use cases about it then show what I
believe are the preferred techniques for
using optional then I'm going to talk
about some counter examples or
anti-patterns or what I call abstruse
use or even abuse of of the optional
class and go through a set of examples
of reasons of ways that I believe you
should not use optional then I'll get
into some a little bit of discussion
about the design rationale and that
that's that's where the bike shedding
comes in all right
optional why is it useful so background
is the optional type which is a generic
a generic type was introduced in Java 8
and it's a very simple class it can be
it's in Java util it can be in one of
two states it can contain a non null
reference to an instance of type T or it
can be empty so when an optional
contains a non null reference we say
that it is present and when it doesn't
have one we say it's empty and I think
it's very important to be pretty pretty
consistent about terminology here and
not say that an empty optional not
confuse the terminology and say that an
empty optional is a null optional
because I think that that really
confuses the issue note in particular
that
a an optional cannot contain a present
and null value it's either non null and
present or empty or also we use absent
as a synonym for empty now there are
some primitive specializations of
optional optional int and double they're
mostly the same there's some there's
some minor differences I'm not really
going to cover them today I'm going to
focus on just the java.util optional
class so optional is an object in Java
and as you know objects are referred to
by references and those references can
be null never use null as the value of a
reference to an optional and so that's
very important so if you need to return
if you have a method that returns an
optional never return null from it if
you have a local variable that contains
an optional never assign that to null so
just don't do that that basically
defeats the purpose of using optional so
I have a series of rules that I'm going
to play out as I go through the
presentation so this is rule number one
never ever use null for an optional
variable or return value all right why
is optionally useful so I'm going to go
back and when we were designing the
streams API run through an example of
where where we ran into this where we
ran into the need for something that was
better that that we we decided that we
needed to have something better than
simply returning null from some of the
streams methods so here's here's an
example suppose you want to search a
list of customer for some customer
object that has a particular ID so this
is a draft API this is not this is not
the actual API this was something that
fact I came up with it during the
streams development and kind of the
obvious thing to do is to say okay let's
have a search method that takes a
predicate and it finds a member of the
stream that meets that predicate and
returns it alright next question is what
happens if there is no member of the
stream that meets that predicate no
return no of course that's what we
always do in Java alright so so let's
use this in a method customer buy ID
takes a list and a customer ID and
returns a customer reference and so we
say costless dot stream and then call
search and pass it the predicate now
this again this is a draft API this
isn't this isn't real but this was our
one
early prototypes so what this means is
that the null that's returned from this
this hypothetical search method is
returned from this method so customer by
ID also returns also can return null and
so we have no starting to propagate all
around our system well suppose we want
to refactor this and say ok I don't
actually want to return the customer I
just want the customers name so we can
call get name on that customer instance
so you might be tempted just to call get
name at the end of that stream well
that's a problem of course because it's
going to throw a null pointer exception
if no customers found so what you have
to do is say ok get the result from
search store it in a local variable and
then test it against null and then say
ok so if it's not null at that point we
can call get name and if it is null then
we do something else like return unknown
and this is kind of a problem so it's
really cluttered it totally broke up the
the fluent style of the streams API and
it's very easy to forget so you could
very easily just call get name off the
end of that and suffer a null pointer
exception so we decided we needed to do
something better and so the the idea was
to create an optional class and so here
this is actually sort of a back
formation there is a whole range of
discussion of optional and then
distilled from that Brian gets and I sat
down and wordsmith a paragraph that says
here is what optional is for optionals
attended to provide a limited mechanism
for library method return types whether
it's clean clear need to represent no
result and we're using null for that is
overwhelmingly likely to cause errors
and so I think you saw that on the
previous on the previous example so that
was the return type instead of returning
a bare reference which might be null we
say maybe let's do something different
return this optional thing instead again
that's in the return position of a
method signature and where use of null
there is likely to cause errors or
overwhelmingly likely ok but I think
that is pretty true right sometimes you
call a method and you just say oh great
now I have one of these guys I'm going
to call more
methods on it and you know if you forget
that something's not able you can easily
run into null pointer exceptions so this
is the case that we are focusing on we
are not trying to solve a much more
general problem of of a maybe monad or
something like that if your functional
programmer and most importantly we are
not trying to get rid of null references
from Java entirely nulls are mods are
out there
optional does not replace null
references all right so let's try to
figure out how to use optional so
returning to this example we have our
customer list this is the actual stream
API that that ended up in Java 8 it's a
little bit different instead of passing
a predicate to the searching or in this
case fine first we put the predicate in
a filter operation upstream and then
call fine first on that and so fine
first does not return a customer instead
it returns an optional of customer and
so in our example we want to get the
name of that customer so we can't call
get name on it because optional does not
have a getname method so we get we get a
compilation error here so what do we do
about that well we could take that
optional customer from the stream and
then do something with it in order to
get the customer out of out of it and
then call get name on that customer
object so those question marks there say
what do we do what do we need to do to
get the customer instance out of the
optional of customer all right well
there's a get method on there okay
that's great
so we get the we we we run our stream
pipeline get the optional customer
result and store that in a local
variable opt and then call get on that
and so now we have our customer and then
call get name all right well what's
wrong with that
what if there was no customer so instead
of a null reference to a customer now
what we get back from the stream
pipeline is an empty optional instead of
an optional that has a customer in it
what happens if you call get on an empty
optional well throws no such element
exception
so we haven't actually helped anything
here we've replaced nullpointerexception
with no such element exception and so so
now we are going to launch into range of
use cases for how to how to use the
optional API effectively but that's the
setup for the issue which is we have an
optional that might or might not have
some value how do you work with that
value that might or might not be there
in other words we need to find a way to
safely get a value from an optional
alright um so let me take a quick quick
break here and and talk about my Twitter
thing here ah good okay
alright now that so you see a hashtag up
in the upper left eye if you have
questions on this I think the easiest
way to get them to me is to tweet them
using this hashtag and so the hashtag is
dev aux optional and since everybody was
saturating the network during the break
I wasn't able to get it on my iPad but I
have it now so I'm not I'm probably not
going to be monitoring it during the
talk but when the end when I get to the
end of the talk I'll look there and see
if there any questions ok without out of
the way let's revisit our customer
finding example so we run our customer
list stream and we get our optional
customer out of fine first now we don't
want to just call get on it because that
gives you a null not a sorry not a
nullpointerexception
it gives you a no such element exception
but it still gives you an exception so
you know maybe one way to do this is to
call is present before before calling
get so you can do that so there's a
method on optional called is present
returns a boolean that tells you what
state the optional is in very good so if
it's present we can get the name get the
customer out of the optional and then
call get name otherwise return some some
alternative to string like unknown so
this works but I mean really still this
is this is no better than what we had
before because we've replaced a null
check with a check to the call to is
present so again this is this is hardly
any better than what we had before so
optional hasn't yet added
value meanwhile I think this is the
right time to introduce rule number two
which is never call optional yet unless
you can prove that there is a value
present in that optional and so I think
that's very important because if you
don't do that you get almost exactly the
same problem with unexpected exceptions
you just get a different exception type
instead of nullpointerexception you get
no such element exception alright so
there are cases there they're in fact
fairly common cases where you can just
because of the context of the code that
you can prove that there is a value
present in an optional and in those
cases it is safe to to call get now one
of the problems with this though is that
this style hasn't
I mean it's bought us a little bit it's
bought us a little bit of safety because
instead of getting a customer out of the
stream which might be null we get an
optional so there's an extra object in
the way so you might be tempted to call
customer methods directly on that return
value but it doesn't work because it's
an optional instead so optional is
adding only a tiny bit of value here
because it's reminding you oh you have
to the thing you want is actually inside
the optionally so you have to do a
little bit of extra work but you're
doing extra work here and you're still
cluttering up the code and you have to
remember to do that and so it's not
really it's not really that useful so
this leads to rule number three which is
let's in prefer alternative method calls
to optional is present followed by
optional gap so I'm going to go through
a bunch of examples of this so so if you
look at the optional API there are I
mean like I said there it's very simple
there's two states present or absent
when I forgot to mention it's also
immutable you can never set the value of
an optional after it's created but
anyway the states of the object are the
states of the optional object are very
simple but they're like a dozen method
calls on it and some of them are kind of
arcane so that's what I'm going to go
through next all right
but anyway so if you find yourself
writing optional is present an optional
gap sometimes there's sometimes there's
no way to avoid that but in many cases
there are alternative methods that you
can and should use all right so the so
here's an example there are three
methods on optional let's start with or
else there's or else or else get and or
else throw and there take a little bit
of getting used to use used to how to
read these methods but basically if I
have an optional and I call or else on
it that returns the value if it's
present but if the optional is empty it
returns a default value that you provide
to or else so or else get is kind of
similar except instead of you providing
a default value you provide a supplier
for that default value so what that
allows you to use a lambda method or
reference method reference in or else
get and what happens is the creation or
retrieval of that default value is lazy
it only occurs if the optional is empty
and there's another variant which is or
else throw which takes a supplier of an
exception and so what that does is it
returns the value present in the
optional but if the optional is empty
then it throws an exception that's
constructed by calling the exception
supplier so more methods so there's a
map method on optional so it's map in
the sense of transform and so let's sum
what's returned to the customer example
get name what we were not actually
interested in the customer we're
interested in the customers name so this
is this is the example where we ended up
before and so we can rewrite this code
like so so instead of calling instead of
testing is present and then calling get
on that optional we call map and pass a
transforming function which gets the
name from the customer and so that
function is called only if there's a
value present in the optional and in
fact it's called it's called on that
value that is present in the optional
and is expected to return a a substitute
value
which may be of the same type or of a
different type but if the optional is
empty then map simply returns the empty
optional so it just passes it straight
through now what you can do with this is
chain or else on the end and now it
becomes a little clearer how how you use
or else so what I'm saying what this
code is saying now is okay I might have
gotten a customer from this streem
pipeline and I want to map it through
the get name function and or else if it
was empty return the unknown string okay
so now it turns out we no longer need
the to have a local variable here so we
can just merge this map and or else call
onto the end of the stream pipeline and
now it's really starting to look much
neater we have a stream pipeline filters
and does a find now there's a little bit
of a wrinkle here in which the chain of
method calls looks like a continuation
of the stream pipeline but it's actually
no longer a stream at this point the map
and or-else methods are method calls on
the optional that was returned from fine
first but anyway this gets rid of a
bunch of clutter in processing the
optional optional that's returned from
the finding method all right so there's
another another method on optional
called filter so this this originally
came out of open JDK there's a layer
Java file actually it's been I've been
told by the author of that file and one
of the maintainer is that file it's no
longer no longer the case but this it's
an example of pattern that I've seen
elsewhere so in this particular case I'm
going to need to set up the example a
little bit we have we have a
configuration object and we want to look
at the parent the configuration object
now a configuration might or might not
have a parent and the requirement here
is that this can figure out
configuration off sorry this
configuration object must have a parent
that is
the same as this lairs configuration so
the this is all part of a larger context
on the objects but it's interesting in
that the it's an interesting case
because it shows a good example of the
way that filter can be used so here
alright so so we so if you look at the
code we have the configuration object
and we get its parent and so parent
returns an optional configuration so
might or might not have a parent so what
we want to do is we want to throw an
exception if there's no parent but if
there is a parent we want to make sure
it's the same one as are as as you know
this objects configuration and if it's
not then in either those cases we want
to throw an illegal argument exception
and that's what this code does and it's
it's kind of okay but it's one of those
things where you have to you know you
have to puzzle over the boolean
conditional logic a little bit so it
turns out that the optional filter
method gets rid of a lot of this gets
rid of a lot of this problem for you so
what so what filter does is it runs it
takes a predicate and runs that
predicate on the present value and if
that value meets the predicate it it
passes through an optional containing
that value so basically it just passes
it through in fact it returns it returns
what it was called on on the other hand
if the if the present value does not
meet the predicate it returns an empty
optional now a filter is called on an
empty optional to begin with then it
just returns an empty optional so
basically what it does is is it is it
sort of temporarily opens up runs the
filter on the value in the in the
optional if there was one and returns a
result indicating that and so in this
case we want a filter for the
configurate for there being a present
configuration that is the same as this
configuration or else we want to throw
an illegal argument exception and so
that's exactly what this code does
alright so another method is if present
which is a bit unfortunate because it's
very easily confused with a method I
mentioned earlier
called is present so here's another
example from the jdk codebase there's
something that wanted to get a task from
somewhere and there might or might not
be a task so it got an optional task and
but if there is a task we want to we
want to pass that to an executor by
calling run task on it
so here we have the typical is present
followed by get and so like I said
earlier if you see is present followed
by get maybe look around for different
methods on optional to to make that
simpler so here's one way of rewriting
that we can say get tasks and instead of
storing the optional in a local variable
we can just chain if present on it and
so what if present does is says if
there's a value present run this lambda
expression on it if and if there's no
value present then it doesn't run it at
all and so that's exactly that's exactly
what we want to do in this case so we
can simply call get task and then chain
if present off the end of that optional
return value and then we pass a lambda
that does what we want to do so now if
you look at this lambda then it it just
calls run task on that task and so we
can this is this is kind of standard
stuff this doesn't have anything to do
with optional we can just replace that
with a method reference and that makes
this code you know really nice and tight
alright there are a few more methods on
optional they're kind of utility style
factory methods and stuff so but
basically there's no Constructors there
are no public instructors on optional
the way you get an optional is you can
either call optional dot empty and it
returns an empty optional or you can
call optional dot of T and you must pass
a non null reference to an object of
type T and that returns you an optional
that contains T there is a flat map
method which is kind of like math except
that it instead of returning a value it
returns an optional that might contain
the result so there are if you have one
CH of functions lying around that return
optional and you want to you want to do
mapping on them then flat map is what
you want to do there optional also has
equals and hashcode methods which is
which is sort of obvious and a little
too easy to ignore but it turns out
equals is really useful for doing
assertions in unit tests so if you have
a method that returns an optional you
might have a bunch of cases where in
some cases you so you might want to have
a bunch of test cases where in one case
the the method should return an empty
optional and in another case the method
to return an optional containing and
expected value so it's typical unit
testing well there are a bunch of
different ways to do it and after
playing around with some stuff it turns
out that you can just use assert equals
and you pass in the expected you pass in
an optional that matches what you expect
and so you can say optional of expected
value or optional empty and equals does
the right thing with that all right
another technique that is useful with
optional is two sometimes it's useful to
have a stream of optionals so here's an
example where so let's let's kind of
resurrect this this list of customers
example so we have list of customers and
we oh sorry we have a list of customer
IDs and we want a map or we want to
transform that into a list of customer
alright so what we can do is we can take
that stream and map it by customer dot
you know customer find by ID but notice
if you if you recall from the example
before find by ID returns an optional
containing a customer not an actual
customer so now we have a stream of
optionals which is which is a little
which is a little interesting so how do
we deal with that well what we can do is
we can filter the filter of the stream
using optional is present and then we
can map that using optional get and so
here again we're it's actually it's like
kind of a different case we are calling
optionally as present before optional
get
and instead of doing this in an ordinary
if statement we're doing it in a stream
but this is adhering to that rule that I
mentioned earlier which is that only you
should only call optional GATT if you
can prove that the value is present and
in fact that's exactly what the filter
upstream does so this is this is a nice
technique and then anyway so so once we
once we've filtered the stream to have
only optionals that are present then we
get the customers out of them so we
transform a stream of optional of
customer into a stream of customer and
then we just collect those into a list
so that's what the top half does now
little preview of Java 9 optional has a
stream method on it that returns a
stream containing 0 or 1 elements
depending on whether the optional is
present or sorry all the way around it
returns a stream of 0 or 1 elements
depending on whether the optional is
empty or present and it turns out this
this is exactly matches what the stream
flat map method wants it wants a stream
that is interpolated into the outer
stream everyone wants to call a function
that returns a stream whose values are
interpolated into the outer stream so
you can collapse the filter and map
methods into a single flat map call all
right um
so optional is new and so there might be
pieces if you start using it there might
be pieces of your code base that are
using optional but you might have some
older code that still uses null and so
there's a need to adapt the nullable
world to the optional world and so you
need to go in both directions so if you
have a nullable reference and you need
to get an optional out of it there's
another static factory method optional
of nullable and so instead of unlike
optional dot of where the argument you
pass must be not null this allows a null
reference to be passed in
and an old reference is converted into
an empty optional and of course if the
reference is not annulled you get an
optional containing a value now if you
need to go the other direction if you
have an optional and you want to pass if
you have an optional that might or might
not contain a reference you want to pass
that to something that either takes a
reference which may be nullable then in
that case to go the other way
you call optional dot or else null so I
would say that only use or else null if
you need to generate a null value that
is something that is expecting nulls
sometimes I see this is overused people
people like people are comfortable with
null references and so after they after
they finish using the this noon
this this this new and unfamiliar
optional API they want to get back to
their they're comfortable null reference
world so I see a lot of or else null and
so I would say so it's it's not as
strong as one of my style rules but I'd
say generally don't use or else null
unless you really need to get a null
reference that you pass to something
that is expecting null all right so that
ends the section about my preferred
preferred usage of optional and now I'm
going to start talking about optional
anti-patterns and misuses all right so
one of the things that that I think
people find strangely attractive about
optional is the ability to change
message and you know this this idea of
chaining methods is pretty cool but it's
very easy to overdo it so here's here's
an example of a code pattern that I I
see all too frequently which is I have
some method that takes takes a nullable
reference and whew instead of using
conditionals let's let's use this new
optional thing so the first thing the
code does is wrap it up in an optional
using optional of nullable and then
start chaining methods on it and this is
really simple there's only there's only
two methods in the chain so but what you
think about this this wraps it up in an
optional and then calls or else get
which which invokes some function
if the object if a value is present
otherwise it does otherwise it does
nothing and it's not clear to me that
this is any better than just you know if
you than just doing a null check if you
have a method that might take a knowable
reference check it for null so rule
number four generally I think it's a bad
idea to create an optional for the sole
purpose of chaining methods on it at the
end of which you unpack the value so I
think again the the issue here is that
this is this is kind of an off-label use
of optional our primary focus in
creating optional was for return values
for methods so if you find yourself
creating an optional for you solely
within the context of a particular
method that's a pretty odd thing to do
and in fact I don't think it adds any
value so if you if you look at this
example I mean you can add a pretty easy
to find examples more complicated code
where people will wrap something in an
optional and chain a bunch of methods on
in fact I have some more examples coming
up later and I think this this subtracts
value from the code it makes it harder
to read and understand and it actually
creates it actually allocates objects
where not where no allocation is
necessary all right so another thing
that people are fond of misusing
optional for is avoiding avoiding
ordinary if statements so this is this
is a little weird example but I found
this on Stack Overflow you can see the
link at the bottom of the page but some
guy had some guy had an issue or he had
a use case where he had two optional of
bigdecimal okay but he wanted to combine
them in an odd way which was he wanted
to add them together and there was a
special case where if if one of the
other value was present then treat treat
an absent big decimal as zero but if
both values were absent then then he
wanted the returning optional to be
absent so that's a little odd thing to
do but that was
use case and so there was a long
discussion and some pretty bad answers I
thought quite frankly on stackoverflow
so so here's here's one of them somebody
said oh I know you could take you have
these two optional so you can you can
put them into a stream and then you can
filter them for being present and then
since we know they're present we get
them and then reduce using big decimal
colon colon ad okay that's that's pretty
clever and you know it's nice it's
generalized you can if you have if you
have three or four or an arbitrary
number of optionals you want to combine
that way what is not at all obvious is
if both if both optionals are empty then
filter filters amount returning an empty
stream and reduce returns an empty
optional so this matches the
requirements that the original poster
stated but it's completely non-obvious
from looking at this so reduce in fact
can return an empty optional if it's
it's called on an empty stream and so I
really think this style of coding
obscures the logic incredibly badly and
so I would I think this is this is a
kind of coding pattern that one should
avoid it's one of these patterns that I
think is clever but it's it's too clever
for its own good
so continuing with this here's another
one and I'm not even going to try to
explain this but this this works I
believe this this is correct it meets
the original questioners requirements
but if you look at what it does is calls
map on the first optional and then it
passes a lambda expression that calls
map on on the second optional and also
chains or or more methods off the end of
it and then it wraps up the result in
another optional so that's very
interesting it's mapping something to
optional : : of very strange thing to do
or else it returns the section object a
second optional so this is this is
incredibly clever it's code it's it's
great code golfing so if you're if
you're having a code golfing contest I
think this guy is the winner but man in
order to figure out what this is doing I
had to haul out a piece of paper and
write a state diagram and figure out
what the what the potential results of
every possible input at every possible
intermediate expression wise and so you
want to talk about obscure code I you
know if you're if you're interested in
this stuff prove that this is correct
and meets the original problem statement
I believe it does but I recommend never
writing code this way so but I think
there are some interesting rules that
come out of that and so in thinking
about that instead of saying oh this is
bad code oh do that I think there's some
rules that we can distill out of it
and then here is actually if I were
writing that code in production here's
the way I would write it so first I'll
do that and I think this is a strange
enough case that is worth being so sorry
let me talk about the the original
posters requirements so it has the
strange thing where an empty optional
might be treated if 0 as 0 if there's
another value present but if they're
both empty then the result should be
empty so so given that requirement I
think it's a strange enough requirement
that it's worth writing out the code
more verbose Lee than you could say
compared to what was on the previous
slide but I think it makes it absolutely
clear what is going on and that this is
a special case and so write out an if
statement and say if they're both absent
return an optional empty otherwise
return an optional containing the result
of summing them ok that's longer but I
think the code says exactly what it does
so now if you if you recall the previous
code what I think made it correct what
might what I think made it complex was a
couple things were going on in it so one
was it did optional processing in the
lam that I was nested inside the
processing of another optional and that
that's kind of that kind of caused my
internal stack to overflow so that's why
I had to pull out the piece of paper and
map it all out and I think that's it's
really hard to reason about because
there's just so many so many potential
things going on the other thing is if
you're processing optionals and you ever
find that one of your intermediate
results is an optional of optional of T
it's like hmm
that's that's kind of a little strange I
mean it works but I'm trying to think of
an intuitive model for what an optional
of an optional is so it's it's pretty
strange so anyway so that's what I'm
proposing as rule number five if you if
you have an optional chain that contains
a nested optional chain or if you have
an intermediate containing an optional
of optional of T then you're probably
trying to do something that's too
complex maybe break it up and use
explicit control flow or explicit
testing all right so I wanted to switch
subjects here and talk about a problem
with optional get and there's this wall
of text here which I'm not going to not
going to bother to read but you'll see
it in the slides so last year at Jack's
conference and yell like a longer had
interview with Brian gets who's the
language architect at and the Java
language architected Oracle and she
asked him what his biggest regret with
Java 8 was and varieties went off on
this rant about optional cat and so you
saw some of the pitfalls with optional
cat but I really think there's something
going on here which is get is such a
simple short and obvious method name and
it's used all over the place in the JDK
and in any any container object that you
might want to write and it's usually
totally innocuous if you have a
container you want to get something out
of it great you call get totally obvious
the problem is with optional get is a
trap because it leads you into it's so
tempting to just call get and it makes
it very easy to forget how to handle the
empty case in fact and that's basically
it's the same problem as null references
and so optional is an interesting class
we've we've talked about some
interesting coding styles and methods
and and lambda expressions and stuff but
if you look at optional get it's a
magnet for misuse and so I you know
brian has ranted to me a couple times
about this and I kind of didn't believe
it's like yeah yeah Brian
you know what's the big deal and then
what I did was here I actually actually
explained what the what some of these
things are I actually actually did a
survey of code in the JDK and I did a
bunch of read a bunch of code on grep
code and looked for uses of optional yet
and frankly I was appalled there were a
bunch of cases where people are calling
get and they weren't they weren't
guarding it and then there were other a
lot of other cases where it wasn't
incorrect and people were calling if
present followed by get but they were
really not not at all taking advantage
of the the capabilities of optional so
in discussing this a bunch and lots of
mailing lots of emails and more
discussions with Brian I think you know
I've come to the conclusion that I agree
with Brian that optional get really is a
problem and I think if you look at if
you look at the definition of optional
talk yet it's actually very strange it
throws an exception if there's no value
present and I don't you know maybe
obviously in the billions of lines of
Java code out there maybe somebody else
has written a get that the throws an
exception but that's very unusual if you
look at all the gets you know like on
the collections framework or whatever
they don't throw exceptions I mean
through throw exceptions if you know an
index is not a bound or something like
that but this idea of throwing exception
if something is not there is actually I
think pretty foreign to this concept of
the simple get method that we usually
have so there's been a bunch of
back-and-forth on this and discussion
and so I'm working on a plan which is to
introduce a replacement or a substitute
forget that has a more explicit name
something like get or throw or I think
it would be worth having a discussion
about what the the substitute should be
named and then get should be deprecated
because it's misused so often that
that's worth generating a compiler
warning for that now it won't be removed
as you know and my alter-ego doctor
deprecated er is introduced deprecation
with a flag that says for removal
so get will not be removed
ever but this would be an ordinary
deprecation where it just generates a
warning but in fact get is used actually
too frequently and introducing warnings
for all uses of gap caused a lot of
people to object because you know
warnings are a pain to deal with
sometimes so so we've kind of pulled
back from that a little bit so this plan
is not going to be executed in JDK 9 in
particular get will not be deprecated in
JDK 9 if there's time I'm not sure I
might be able to introduce a replacement
alongside of get in JDK 9 so that it's
there and then maybe pursue this plan in
future unspecified versions of the JDK
but anyway that's that's the issue there
with get I think there is something
going on there
meanwhile I strongly strongly recommend
that you look at the other methods on
optional and there's usually way to use
one of those two to replace uses of
plain optional gap alright so there's
there's some other issues here I've
noticed a tendency for people to want to
use optional in a bunch of places where
we didn't intend it for it to be used
and you know that's okay right we we
were focusing on return values and
people want to use it elsewhere you know
I guess that would be okay if it were
useful but I think for some reason
there's a desire for people to to to do
that and if you look at the code that
results from that it turns out to be not
useful or or worse than the code was
before and so my recommendations are not
to use optional in fields in method
parameters or in collections so there's
I have some more discussion a little bit
later on about fields but there are a
bunch of things about you know when you
have we have why are you tempted to use
optional in a field
well maybe it's to replace maybe it's
the replace at null value and actually
I'll save that for a little later I have
a slide later on that that focuses on
use of optional and fields optional and
method parameters kind of doesn't work
the way people really want it to
sometimes people want to
find a method where the caller is not
required to pass all the arguments oh
well not required means it's optional
right so I'll use a Java util optional
well that doesn't work because it what
it does is it makes the caller box every
object into an optional and so if I want
to call my method and just pass it a
string or no string I have to write
optional lot of or optional dot empty
all over the place and that that's I
think that's counterproductive that puts
a lot of work out to the caller and for
no good reason and then finally with
optional in collections sometimes
sometimes it's just a little strange
it's like having nulls and collections
but it's worse because instead of you
instead of a collection of values now
you have collections of optionals and
then those optionals might be present or
empty and so it's just kind of a very
strange thing to do and it's kind of
beyond the scope of this presentation
but if you look at code that puts
optionals in collections then usually
it's sort of if you think about the
modeling a little bit maybe maybe this
should be represented a different way so
one of the things about optional and one
of the reasons we're concerned about
overuse of optional is that optional is
an object we call it a box I mean it's
really nothing I mean not much more than
a container for a reference to another
object and so people talk a lot about
performance cloud stuff requires you
know higher densities of services in the
cloud people use micro service and stuff
so so even though you know who cares
it's only 16 bytes if you have a lot of
these things floating around the
expenses add up so one thing I found is
that if you if you take a data structure
that has nullable fields and you you
start using optional in it if you
overuse optional then you end up doing a
lot more object creation you add GC
pressure 16 bytes is not that much for a
for an object but if you have a whole
collection of them or if you have lots
of objects with optional fields then
those add up and another problem is a
cache locality and so if you want to get
some
thing if you have a reference to it but
you might take cash miss but if you have
to go through an optional you might take
cash miss getting that optional and then
when you open up the optional to get
what's inside of it you take another
cache miss and so this you know if you
use optional in one place okay that's
fine
the return position is potentially very
optimizable because the jvm can use a
scape analysis when it does when it does
is JIT compilation and actually
potentially avoid even allocating the
optional object but if you start storing
optionals into data structures and
things then you I think you should it's
not well I think you should think about
these issues it's not necessarily the
cause of the net your next performance
problem but it might be so it's it's
something to consider like I said at the
beginning of the talk optional is not a
replacement for null so nulls can and
should be used and they can be made safe
if they're well controlled particularly
in private fields if you have a class
with private nullable field then you can
do local analysis that code and there
are tools that help with that to say yes
this is a nullable field and it can be
you can be shown that you're processing
or handling the null cases correctly in
all cases an alternative to using null
is a the null object pattern sometimes
that's useful to represent the absence
of value in in in a more convenient way
passing nullable parameters into a
method is is pretty useful we do that in
the jdk sometimes just to avoid adding
an extra overload it's sort of I say
it's D class a it's not the best API
style but sometimes it's like okay it's
not too bad
if you're writing a library method okay
this this parameter is knowable so you
put in a null check at the front and and
handle your special case that way or
maybe assign a default value there so
there's no no need in those cases to
have a an optional print a parameter
whose type is optional all right so now
I want to get into the bike shading
phase of
and I'm going to endeavor to avoid using
up the entire rest of the time with this
but it it might not be successful okay
all right so optional for some reason
has been a magnet for for just all kinds
of questions and discussions I'm not
going to go through all these but there
are a couple that I think are notable
that are worth discussing in particular
one thing that comes up repeatedly is a
complaint about why optional isn't
serializable and and that's a fair
question
because it I think it the design
rationale about this has not been
communicated particularly well there's
lots of email and the OpenJDK mailing
lists and having all that rationale and
discussion buried there is totally
inaccessible so what I've tried to do is
kind of mine this out and you know
basically sort of backfill some of the
design rationale for this so anyway so
serializability alright so before I talk
about serializability I want to talk a
little bit about value types and project
Valhalla
you've probably heard Brian gets talked
about project about how the introduced
introduction of these new things called
value types so it's sort of like an
object but it has no identity and it
doesn't it might but it doesn't
necessarily live on the heap and so you
don't have a reference to a value object
you just have a value so the the slogan
for project Valhalla is it codes like a
class and works like an int and so when
we created optional we I talked about
the potential memory and performance
costs of optional so we're very
concerned about that and we said okay
well if we introduce optional now maybe
we can convert it into a value type in
the future when value types come along
so when we when we decided that we added
kind of a disclaimer to the optional
specification in the Javadoc basically
uh this is value based class use of
identity sensitive operations such as
reference equality identity hash code or
synchronization on instances of optional
may have unpredictable results and
should not be should be avoided and so
that's rule number seven don't use
identity sensitive operations on
optionals okay so that's sort of
background
now well more background but let's look
at the background to serialization
there's a rule in the JDK JDK has many
compatibility rules one of them is for
serializable objects the serial form is
an external representation that we want
to make sure is backward compatible and
forward compatible so that's that's an
elevated level of compatibility so
usually we say something is backward
compatible so when you upgrade to the
new release the old stuff still works so
but this way if for serialization since
it's an external format it has to go in
both directions so if you serialize an
object on an old JDK you should be able
to deserialize it on a new JDK and if
you see realize an object on a new JDK
and go back to an old JDK and
deserialize it there assuming that that
object was that the class was defined in
the old JDK it should be able to the old
JDK should be able to deserialize that
as well and so there are a whole bunch
of mechanisms in in serialization for
dealing with presence and absence of
fields and constructing custom serial
forms and stuff but a lot of that is in
support of the both forward and backward
compatibility and that that actually
creates a considerable maintenance
overhead for serializable objects I
think what one of the things that people
don't realize is it's not that difficult
to take an object and make it
serializable what is difficult is making
sure is that this compatibility
constraint is adhered to across multiple
JDK releases and sometimes we have some
very arcane discussions about this where
we say oh I'll just add a field here
well what happens if you deserialized on
an old JDK oh I hadn't thought of that
what should we do oh I guess we can't do
that I guess we'll have to do it a
different way and so around we go so so
that's actually a significant expense
and sometimes produces insurmountable
problems so there's another issue is
that serialization really only knows
about objects I mean it also knows about
primitives and then there are a couple
special cases for stringing
oome but basically if we had optional
and made it serializable in the external
serial form it would be an object and
serialization depends inherently on
object identity and so in order to
reconstruct an object graph at the
serialization time in order to handle
things like cycles and and multiple
different objects referring to the same
object see serialization preserves that
and in order to preserve that it has to
know about the identities of objects in
order to match things up and also to
deal with back references the things
that occurred earlier in the serial
stream and so forth so this starts to
get really complicated but what that
means is if we made optional
serializable what would happen when we
convert it into a value type so he just
said value types don't have any identity
so if we made it serializable then okay
so there's it's not necessarily an
insurmountable problem but it raises a
bunch of questions that we don't have
answers to right now so we don't know
what the consequences would be in the
future for value types if optional were
made serializable today one possibility
might be you know the compatibility
issues are too strong if we main options
serializable it can never be a value
type and we're not willing to do that
another alternative is okay well let's
say optional make optional serializable
and it gets converted into a value type
but if you serialize it and deserialize
it then it gets boxed into an object so
it's no longer a value type
it's a boxed object it's like hmm well
that might be okay that's kind of
compatible isn't it well on the other
hand suppose you have a list of a
million e of these things and they're
values a list of them well I just said
don't do that but suppose you suppose
you serialize some object structure that
has optionals in it and you d serialize
it and you're getting all the benefits
of of value types so when you d
serialize it what would be the
side-effects of boxing all of those
value types well one you would you would
greatly increase the amount of heap that
was necessary because instead of being a
value type which resides in some object
you have a reference to to somewhere
else you deal you have to deal with the
dependent load latency and cache miss
and stuff and so serializing and
deserializing something might have a
bunch of side effects on your
application that you know could be a
serious problem and that's not something
we're willing to I mean that seems to be
a big risk if the side effect of
serializing when you serialize and
deserialize something you expect to get
the same thing back and if that has side
effects of causing value types to be
boxed that that seems like a bad idea to
me so anyway so the upshot is we don't
feel confident that we can deal with
value types with optional being value
type in the future if we were to make it
serializable today so we've held off on
making it serializable so that's the
that's the rationale there all right
finally this is the slide I promised
about fields and unfortunately again I'm
running short on time so I'm going to
have to gloss over this a little bit I
think I'll just say that I think the
trap that people fall into is this idea
that oh great now that we have optional
then we don't we can use it to replace
nulls and so if they have an object with
a bunch of nullable fields let's replace
them all with optionals and basically
I'm saying that's that's not a good idea
instead I think you should you should
really think about alternatives for well
maybe using nulls is just fine but if
you want to use something else maybe you
should think about alternatives to
converting all of those knowable fields
to optionals the performance
implications it clutters up the code and
I'm not sure that converting a knowable
reference field to an optional field
actually buys you anything I think it
clutters up your code in addition to
slowing it down and making it consume
more memory so there's been some
discussion about this I will provide
links to a couple interesting blog
articles one is from Stephen Colburn
optional
pragmatic approach so I recommend you
read it he has some interesting advice
there one bit of advice that I think is
relevant to this discussion is he says
yeah don't use optional in fields just
continue to use novel fields but if you
want to have optional exposed to your
API in your getter box up the optional
at that point okay that's one approach
and then there's another article by Mike
Ernst nothing is better than the
optional type and I like that title
because it's one of those ambiguous
things he's basically claiming you
shouldn't use optional at all
you should use null and actually his
interest in this is he he developed the
he and his team developed the checkers
framework and so they have a nullus
checker and what that could do is if you
annotate your source code properly it
can it can verify that you are handling
nullable fields or non nullable fields
and variables correctly and I think
that's a very interesting approach it's
a good alternative
I think it's a worthwhile alternative to
turning you all of your knowable fields
into optionals and so you might think
well this is you know here I give I just
gave an entire talk on optional and here
I'm citing some guy who says don't use
optional so obviously we have we must
have had a pitched battle and must have
a serious disagreement no actually if
you go read that he you know talks about
don't use optional here and there and he
says well it actually is useful in some
cases because in particular cases you
can you have you can you can use the
methods on optional and use lambdas to
get really nice concise code in fact
that's exactly what I said use it for
those cases when you have a return type
you can you can call things like if
present on it and it works great so my
claim is the optional glass is
one-quarter full and his claim is the
optional glass is three-quarters empty
so it turns out I think I he's a good
guy I had a good conversation with him
about this and I think we actually agree
quite a bit more than you you might
think we do all right so let me wrap
this up real quick here a quick thing
about new methods on optional coming in
Java 9 there's a stream method which I
mentioned earlier in code example two
new methods are optional if present or
else and optional dot or I'm not going
to describe exactly what they do
recommend you go read the Java 9ea
documentation for that but basically it
just expands the repertoire of methods
that you can chain in order to handle
more cases for for dealing with optional
all right so I will recapitulate the the
main rule here limited mechanism return
types where null is likely to cause
errors and on the last slide here I will
summarize all seven rules here so I'll
leave that up for people who want to
take pictures of it and I think we might
have time for one question here if I can
get this to come up quickly
all right well you know I there's
there's a lot of lot of chatter on here
and I don't quite have enough time to to
really to really do anything so thank
you very much for your attention
and I'll try to answer Twitter and enjoy
the conference</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>