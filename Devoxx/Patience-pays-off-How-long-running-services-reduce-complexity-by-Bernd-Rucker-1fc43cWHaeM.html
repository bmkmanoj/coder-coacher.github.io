<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Patience pays off. How long running services reduce complexity by Bernd Rucker | Coder Coacher - Coaching Coders</title><meta content="Patience pays off. How long running services reduce complexity by Bernd Rucker - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Patience pays off. How long running services reduce complexity by Bernd Rucker</b></h2><h5 class="post__date">2018-03-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1fc43cWHaeM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon hi I want to take talk
about today about a whole longing hope
how long running services reduce the
complexity I'm also probably in your
architecture my name is Ben Hogan
co-founder developer advocate of kimono
you're basically an open source workflow
automation company and based in Germany
I've written a book I probably mentioned
that later on a bit and if you want to
reach out to me there's my email address
there's my Twitter handle I'm here till
the basically the early evening so if
you have any questions afterwards we
will probably run short in time in the
talk but approach me on Twitter send me
an email approach me afterwards I'm ask
me anything you like that's it as a very
short introduction so there are a lot of
things currently going on basically in
modern architectures with may make Moke
most architectures are quite distributed
once so hence are probably who has has
not any single remote invocation in his
system at all no rest call no soul
nothing
oh there's one that's an interesting use
case Oh probably something embedded or
how does that work no oh that's
interesting indeed but normally like
it's it's everybody has at least one
thing in his architecture and that makes
most of the systems a distributed one
and I actually like this metaphor very
much for for distributed system so the
nice little Hut over there that's your
your service your java application
probably there you're on one day vm you
have a transaction management it's nice
and cozy it's you have a heating and
it's great life to be there so it's fun
to develop within that Hut but whenever
you open the door you're facing the
network and you're facing quite a lot of
challenges would swallowed messages
turned around packages and whatever so
you have no idea what's going on out
there and that's quite a complexity to
handle I recently have published an
article about that and basically I named
it the three common pitfalls of micro
services integration it it could be any
distributed system but micro-services
the most catchy title at the moment and
how to avoid them so you probably want
to look that up so a couple of the exams
I do today are in that rkt article as
well and there the I mean they're
they're an awful big pile of
basically probably pitfalls in
micro-services and but I picked these
three to three priests which is
communication is complex so it's hard to
communicate within distributed systems
you might want to do that asynchronous
which is even harder sometimes sometimes
not I will briefly go into that later on
and my basically my favorite topic is
about distributed transactions and I
want to talk about that a bit today and
that's actually an a great recursion of
the of the of the talk itself so I want
to ask you for a bit of patience because
of the title patience pays off I come
back to the patience later a bit later
on but I wanna wanna lay some current
work first so let's assume you have any
kind of system where you have a lot of
services might be these or many more
whatever what we start to accept is that
some parts of the system might fail I
mean the bigger your system you have the
more services you orchestrate and the
more pieces of the puzzle you have the
higher the probability that that
something fails and it's just we start
to accept that it's too expensive
actually to avoid that to make it such
reliable services such reliable hardware
and whatever and and till they still
then it might fail at some point in time
so we start to accept that but the
interesting part is that we want to
avoid this basically taking down the
whole system so we don't don't want to
get into these kind of cascading
failures where the whole system blows up
so that's the the basic idea what we do
a lot of things we currently do in
distributed systems are basically to
yatra scope these kind of resilience
patterns and so on I want to do a very
simple example today I want to start
with a very simple example and that's I
basically just use two services for the
moment so I have a payment service and
that because payment you very often
don't deal yourself with credit card you
have an upstream credit card service you
just call by a REST API so that's easy
to imagine right I hope yes awesome
I used Java and spring boot in order to
get going because I want to dive into
the code as well I don't want to when I
have slides only and let's quickly do
that
so I'm in the background I have my
there I have a bit of Java code and
actually it's spring boot code it's Java
code so it shouldn't be that hard to
read what it does and I don't want to go
into all the details because that's
simple Java and swing boot so here I
have rest controller
I have request mapping so I met between
API message in URL basically and
whenever I do a put there I want to
retrieve a payment then I do some some
data stuff because I don't have real
data in that example and then I charge
the credit card and this is a bit of
code using the rest template of spring
you could do it in whatever way you want
and where I create a charge request send
that to my rest endpoint with the post
get some response back and that's it so
you probably have who has done something
like this in the past already okay
couple of the people so you know what
I'm talking about that's a simple rest
call so that's what you do Nate they
flee when you when you start doing rest
communication what happens actually if I
call that it's very easy so what I have
here this is the upstream stripe service
from my Eclipse I directly I started the
payment service of what I can do and I
can use a REST API in order to call the
payment service sending the put and I
get a response back hopefully yes so
that's pretty good but very easy I think
so let's let's see so we get an HTTP
where is it 200 okay that's boring I
think that's setting the scene so that's
very easy to get so what happens that's
the next thing I can now make my service
responding slow so now my stripe service
the upstream credit card service is very
slow it has a delay what happens if I
call it that's a warm-up question that's
easy
it still works yeah what happens at slow
yes of course
so um I do it again what do you see is
that it's blocking it's blocking the
request it's blocking it's blocking it's
blocking
until at some point in time eventually I
get a response it still works but it's
very slow and that's it's we're still in
the warming up phase and that's actually
pretty bad because why
now the payments are
is blocking waiting for the upstream
credit card service and that means
whenever the threat pool of the payment
rest server is exhausted we cannot
handle any payment requests anymore
so slow upstream services are actually
inverse than non-working upstream rest
services so that's actually a pretty bad
situation to be that's actually well
known who of you knows of the circuit
breaker pattern most of you that's great
not all of you so some of the people
should do some homework but most of you
there's actually an untaught from from
Edison later on on service mesh that's
probably good to go there he brought I'm
not sure if it does it today but you
should also talk about circuit breaker
the beauty of the circuit breaker and I
used history to make it in code is that
it can be very easy so here and that's
different to service master later on but
here I use a circuit breaker and I
basically just added this line of code
to have a circuit breaker and what it
does now is whenever I do the post it
can like like in your house when you
have strange things with the electricity
it just switches off and that means when
I still having the slow service but
calling this v2 service whenever I do
that I'm the circuit breaker switches
off I get a basically hysterics
exception so there was a timeout and but
the the good thing is I I don't get down
my payment service by this slow upstream
service so the circuit breaker is very
important and it was actually I'm pretty
good that most of the people know this
this is very common actually so the
circuit breaker is very common and this
is what's normally called fail fast so
you you want to fail as fast as possible
to not in this case bring down all the
thread pools of you're sure of the
different services like cascading but
the important thing and that's what I
want to talk about today is that this is
not enough fail fastest not enough so I
want to give an example and that's
actually my favorite example you
probably have used an airplane before
yeah you're kind of familiar with the
concept so you booked a ticket you go
you get an email later on when you book
the ticket and please check in for your
flight your flight is ready for check-in
you go on the website you select to see
you basically confirm you don't have any
dangerous good then you can book in and
the next thing I'm you can do is there's
a button where you can say okay now send
me the boarding pass right so that's
what you normally do when I did that
actually last year when I prepared
another talk it was a great coincidence
that I got an error message in this case
I feel from German to to London so it's
a German web site but I think you get
the idea and they basically said okay
there was an error sending you the
boarding pass okay so I got that error
what I imagine that happened in the
background was something like okay they
have that web user interface they
probably have a check-in component a
service or whatever it is and that
probably needs some upstream services
like output management to generate a PDF
or probably the barcode generation
that's doesn't have to be like this but
this is how it's in my head actually my
own little word it looks like that and
what I think that happened is that the
barcode generation didn't work and
actually I discussed it so often with
customers during the last years that it
seems that output management PDF
generation it's a greatest source of
arrows at all because if you mentioned
output management in whatever meeting
it's always like yeah we have to do that
somehow so I think this is pretty pretty
often the case so the barcode generator
probably didn't work they had some kind
of circuit breaker there because the
website was still responding that was
good which is not like the usual case so
that was a flight from New York with
United there same button I got this one
so that's the really the worst thing you
can do the the cool thing about giving
this talk now I'm a couple of times that
I'm always happy if I these see these
kind of error messages because I collect
them and I have a lot of Airlines by now
and I start to see patterns which use
this kind of error handling or not so
this was United so they even didn't have
a circuit breaker everything was
basically programmed at and but it's
still bad even if they have the circuit
breaker it's still bad because what do
they do with that arrow they have in the
barcode generator they basically turn
support it to me as a user now it's my
problem I have to do something with it
what would you do
I asked that actually very often and I
have three or three common answers so
the first it's kind of the end user
answer that's also what my mother could
say something like oh I would print the
page with the error message yes that's
great I'm not sure if I get at the
airport anywhere but um okay I could
print the page the second answer is kind
of the management kind of answer and I
would escalate it I would call the
airline going on their nerves probably
could word could not Bert what's a
programmer answer very obvious try it
off and on again exactly retry it that's
exactly what I did that's I mean for me
as a as a program it's even like natural
oh I retired yes of course that's an
error I retry it for my wife that sounds
a bit strange but for me it's not okay I
retried it it didn't work I retried it
like five minutes later didn't work so I
made me a calendar entry in order to
retry it four hours later or five hours
later so I got reminded I did the retry
it did work so that I could resolve it
but I had to do it on my own it was my
problem I had to do what I call a
stateful retry because I had to remember
it I had to remind myself I have to do
it like a couple of hours later and
that's a bad situation actually the
funniest part of this story is when I
flew back from London I had a flu
easyJet and they even give me that work
instruction what I should do they say
please log on again that's the retry if
that doesn't work please try again in
five minutes Oh increase the interval
and the best thing is the last one we do
actively monitor our site we'll be
working to resolve the issue there's no
need to call it's your problem don't
bother us don't bother us solve it
yourself okay
it would be much better much better if
they say something like okay we have a
technical problem it's our problem so we
care about it or a self and we send you
the boarding pass as soon as we can
you're safe we send it early enough for
your flight everything that's okay
because it's I mean I don't have
problems with the boarding pass not
being sent right away I need it when I
go to the airport not before but I don't
want to do that a retry so what they
could could have done they could have
done the retry itself probably in the
check-in component
themself they have my mattress they have
the mobile number so they can do it
without me I'm at all and that and
that's one one important lesson here and
that would even like reduce the scope
which really has to see that failure
message who has to care about this
failure message and in this case it's
it's kind of customer facing facing I
see that from the outside and but you
have the same problems if you have
service to service communication within
your whatever it is service on it
architecture Microsoft architecture
distributed system whenever two services
communicate you have more or less the
same problem we can you can take the
error and just throw it to the next
service or it can handle it and handling
it is very often the better user
experience and users our services I also
see them as kind of users the problem
and that's actually why why I see a lot
of people not going down that road not
doing this is now you have to handle
state I talked about that for hours to
reset the boarding pass for example and
you have to care about that because if
you promise the user to send his
boarding pass on time you should do it
actually would be a really bad
experience if you then don't do it so
you have to handle state how do you do
that normally like the knave approach
would be and what I call a persistent
thing because I would say like a
database table but nowadays it could be
like also a document it could be
precedent persistent actor there there
are multiple things you could do but
it's kind of your own persistent thing
and the problem with that is normally
not persisting something they're pretty
good at that more or less but you have
to do a lot of things additionally
because um then um you get these kind of
I'm scheduling for example you have to
do that retrying Oh does the barcode
generation now works does it now work
does it know where you have long-running
things because if you retry that for
hours or even days and you change the
logic you have kind of versioning
problem what what is with already
running stuff what to do with new
versions and these kind of things you
have to operate that so you probably
want to see what's currently going on
which are they the current active free
tries if you fix the barcode generation
probably you want to
when a trick of the retries or you want
only want to want to have like one being
retried to check if it's not working or
whatever so there are a lot of things
you have to do and that normally gets a
lot of accidental complexity and that's
pretty true right I see that very often
there's a second approach which is for
me very natural but I see for a lot of
developers not their their state
machines out there most of their there
named workflow engines and they can
handle these kind of things the normal
like concerns I hear when I when I
propose this kind of solution is that
there are very complex stuff it's very
proprietary like I'm you buy from the
big vendors like a huge suite you have
to deploy that on machines it's very
slow it's it's kind of a low code
approach so it's really hard for the
developers to keep track and it cannot
handle the load we have and all these
kind of things and that's actually not
true and I want to quickly go to through
that if we look at the current market of
Route 4 engines and that's actually
pretty interesting we see a lot of
things going on especially in the last
two or three years so there's first of
all we have a server last heart just
before me in the room so if you look at
the server list world most of the
vendors start having something there for
example AWS has the so called step
function so that's how you can basically
make a workflow stateful workflow within
the server less world so it's pretty
relevant there the launch at one and a
half years ago what the AWS reinvent so
it's pretty pretty modern what they do
there at least from the market part of
it if you look at all the Silicon Valley
companies you also see that they do
something so if you look at for example
and Netflix they release conductor like
two and something years ago where they
also have kind of a workflow engine
underneath and uber did more or less the
same thing with cadence both of them
only live in the in the world of the
yeah of their companies that like
Netflix you need a dynamite to be which
normally you don't operate or ubers
only with Cassandra and go which kind of
limits the use cases and there's quite a
quite a lot of big group especially in
the Java world of what I was would call
lightweight open-source engines so like
you probably heard of activity or jbpm
or kimono
the commune engine is the one I want to
use - for today's example that's by
coincidence the one I from the company
are confounded so that's the one I know
best but there the others are pretty
comparable if you want a very currently
also working on an open source project
called CB that's probably interesting
because there and we can scale up the
word for execution beyond what we know
from these other kind of engines for you
where you rely on a real relational
database which kind of limits the
scalability but there rely on
append-only locks and achieve really
truly and horizontally scalable systems
but I don't want to go into details of
that today if you have any questions let
me know
what I mentioned earlier I will go for
coming over today and in your head you
could replace it with the others I'm
pretty convinced that we are better but
do that exercise yourself so it's not
about coming as the best it's about what
I what I want you to remember is that
there is there are these kind of
lightweight engines available and if you
have these kind of problems you should
use that so let's apply that for the use
case we had in hand so we have that post
request that simple rest call and what I
could do and I actually also prepare
that to save a bit of time so we still
have our rest controller that doesn't
have changed but in this case I said I
am using spring boot so what we have in
common is the spring boots Dora so you
just add a spring boot starter to your
palm and then the the red flow engine is
started as part of spring all the wild
with the data source transaction manager
and all these kind of details and then I
can just use auto wired to have the
process engine there the next thing is I
the next thing I do whenever I start it
up I create a workflow definition we are
using BPMN for that I come back to that
in a minute
create an executable process this
process has two steps so it's very easy
I started with a start event then there
is a so called service task which
invokes some logic and the next thing is
there's an end event so I'm done so
that's very easy like start do something
and very easy
the cool thing is with that service task
I can attach logic so the first thing is
what you can see is I use expression
language so I attach the spring beam I
show you the spring beam in a minute but
that's basically the code we already
have like invoking the rest service so
that hasn't changed at all but now I
have the state machine so what I can do
is I can attach like and retry intervals
and that's stateful that that's stored
in the database that can be like lasting
for days and even survived like a
restart of the system so in this case I
make it very easy I say
we tried three times and with the delay
of period time one minute so that's what
I can do there and that's it don't have
to do much more here and then I deploy
that flow to the to the workflow engine
and there it gets versioned and so on so
on so what's that stripe adapter that's
the last piece of the puzzle so I have
everything in one class so that's a best
practice no of course not but it's very
easy to demo so I have the stripe
adapter that's implement it's
implementing an interface from from the
engine and then whenever workflow
instance runs through we're calling that
execute message there and this is
basically what I already had and this is
a code I already had as well so I still
have the the rest request I still do the
post I guarded by history so that hasn't
changed at all
so what you can see it's very easy to to
actually to integrate that and now the
behavior changes again so when I am
calling this and my service my credit
card service is still slow I can call it
and now what I get back is no longer the
history exception but I get back up okay
I said pending but this one is the more
interesting and I get back at 202
accepted so I'm not sure how familiar
you are with the rest return code so 200
says okay everything done I'm fine
here's the result trying to accept it
says okay I got the request I cannot
kind of give you the response right away
but I will come back to you I got it I
take care and that's exactly what we
want here so in this case the we cannot
call the stripe service now because it
still slow history says no I'm but we
want to do it later on
and what happened is that in the
background we basically started a
instance of the word flow so if we go to
that one and all these kind of tools
have kind of operating consoles so in
our case that's cockpit for the other
tools it might be named differently and
then it can look into the the just
kicked off instance so we having want to
go to the runtime we're having one
instance basically waiting for that nice
little middle flow so we do an order
laid out so we can show it graphically
and we say okay we are on stripe we're
currently there we're retrying it so if
I go to the console you still see the
exception and we are still in the way of
retrying it okay so far okay cool
the next question and I come back to
that on the slides in a minute but I
want to show you that in that in the
demo right away actually
the next thing what normally happens if
I show these kind of things is that
people say okay but now you're having
that turn the to accepted and let's
assume my stripe service is going back
to normal so now it's fast again and if
I call it like this I still get the 200
to accepted right if I go back to the to
the to the console actually and what I
can see is that I forgot to the history
and I see that I now directly
immediately executed this request
because it's working I mean everything
is fine but I get that 202 and that's
very often people say ok but now you
switch completely tration goodness
processing we don't want that to happen
and and the cool thing is and I don't go
into the details of the code but
everything I show us on github so we can
dive into yourself it's actually like a
very small piece of code in order to
again to basically using a semaphore to
wait for the workflow instance to
complete and then and this is version 4
what happens is that I directly get it
202 okay whenever everything is fine and
what he can also see is that this is not
slow just because they're using a
virtual engine doesn't mean it's slow at
all so it's it's very fast actually and
whenever it gets slow here on the on the
crowd
so as soon as we have a failure we're
falling back to 202 accepted and that's
actually a very useful behavior we are
off and try to do it synchronously if
you want to but fall back to a
synchronism if it doesn't work because
that's much better than handing out the
arrow the failure to your client in
order to handle it there make sense so
far okay awesome
very good cool so what you can see is
that we have a very easy flow so that's
a very easy flow and a lot of people
don't have that use case in mind for
workflow engines they think of very
complex workflows but we currently have
a lot of customers doing this kind of
very easy flows actually just basically
to leverage the state machine now that's
what it gives you it gives you the
persistent state and a lot of
reliability within there
what do you also see and that's actually
a very important thought to keep in mind
I come back to that in a minute whenever
the client does that kind of retry what
you have to provide on the service
provider side is idempotency and I think
that I mean if you remember two things
from the talk the first and probably is
lightweight virtual engines are awesome
for for certain problems and the second
thing should be do everything you do
provide eight idempotent services that's
so important in these distributed
systems that I should repeat it on every
side slide because I mean you retry the
stuff so you probably call that multiple
times you should be really prepared to
do that but that's actually a good idea
anyway and I using a consumer basically
consumer facing services as another
example whoever did pay by credit card
probably most of you as well right um it
doesn't happen that often anymore but
like like two or three years ago it was
pretty calm you entered the credit card
details you hit the submit button and
there was something like saying we are
processing your request
don't hit reload did you know that
remember that how does it does that make
you feel I'm traveling a lot I do these
kind of things in the Train
that's kind of a really unreliable
Network it always raises my heartbeat
like Oh wha
although internal talent might make
faster do it faster and that's really
bad idea I mean it's technically it
should be idempotent should be something
like hey yeah you're processing a
request great that you want to pay you
want to want to order something that's
great we love it and we will make sure
it will happen if you hit reload do it
it's fine for us I mean you you you you
can take care of these kind of things
and it happens more more I mean these
these other messages are starting to
vanish and that's the same thing for
service to service communication if they
were only retry they should always be
safe to do it always try to provide that
we have by the way another problem to
solve as well and it's great how many
stuff you can put in such a simple
example so if you do something like
charge their credit card upstream stripe
service and then let's say the retries
expire we try it for like four or five
times doesn't work then we could raise
something like payment failed right
remember we're distributed systems and
there's really one mean thing in
distributed systems which is you cannot
you cannot differentiate these three
situations so you could call the service
buy a rest and if you get a network
error it could mean that the request
never reached the service it could also
mean the sir requests reach the service
but somehow the service blew up while
doing it
or it could mean that we didn't get the
response back because that word was was
lost somewhere and it's it doesn't care
if you if you're using synchronous rest
communication or sending messages and
waiting for response messages you have
that problem all the time so if you
don't get a response back if you get a
network problem you have no idea if it
happened you cannot so that's probably a
bad idea here because then you say okay
I retried it so I called it multiple
times and then I say payment failed and
probably you have done it you probably
you have charge the credit card and
that's important to also know in these
kind of systems so you have to take care
of that so for example there are
multiple strategies to do that you could
be something like you you issue and
refund and probably you say if the
refund gets an error of no payment
therefore that we found it's okay for us
you
ask if the credit card was charged there
a couple of things but you have to do it
and again you have to do reliably so
your customers probably not that happy
with something like oh yeah we wanted to
refund but then we had to restart the
server and sorry your money no it's gone
oh yes I understood you and you
restarted the server that makes sense of
course not by the way what I use here
these nice little diagrams and that's
called be payment not sure who of you
knows BPMN
that's an ISO standard that's important
thing here so it's not in any way
proprietary it's not that yeah let's say
hype at the moment so a lot of like if
you're not looking at what Netflix is
doing also AWS is doing they're
reinventing in no own yeah a state
machine language like on a JSON format
or Yamal or whatever and they're
starting where we started with workflow
engines like 10 or 15 years ago so bp-
really mature I love the standard what
the language gives you so I think it's
words to have a look at but that's
probably again my opinion mated view but
it's an ISO standard so it's nothing
proprietary and what is so earlier what
we for example provide you also on DSL
so it can program everything in Java
how this flow should look like and then
we create that nice little diagram or
you do model in with a graphical
graphical modeler so that's basically
completely up to you and we are also
working on a young dialect in order to
define these kind of workflows in Yamal
and then creating BPMN out of it so I
actually don't care about this being an
XML file where I can understand that
some developers are not really like fans
of XML that's for me that's okay but the
language underneath the concepts in
there are really powerful though that's
that's pretty awesome and the important
thing is that we now have that state
machine and that gives us basically time
so that means very oft this is referred
to as long-running processes which is
kind of a misleading term I use that
myself but long-running basically means
that we that we wait so state machines
are great at waiting so that means we
are really keeping that state persistent
and
we can recover from there we can go on
we can do that retrying we have all this
notion of time and that's pretty cool I
give you another example why this
improves or basically decreases the
complexity in the overall architecture
let's keep a stick to that payment
examples so we let's say we have an
order micro service or service or
whatever it is it wants to retrieve
payment so it calls the payment service
that does the credit card as we already
have seen and now this time this doesn't
fail but it gives us a like a business
fault like the card is rejected for
whatever reason so again the the very
naive thing what it could do is just you
pass it on to the order service you pass
it on to the order server and say okay
this card is rejected we cannot do the
payment and and then whenever you
introduce new requirements like and you
probably know that from github
when github wants to extend your github
account and wants to do that money from
the credit card and if it's expired they
send you an email please update the
credit card you have two weeks if you do
it within two weeks it's fine otherwise
we close your account and this is
basically what it could do you could do
something like oh it's rejected we
inform the customer to provide us new
credit card if he does that everything
is fine and now the question is where do
do I want to implement that do I
implement it in the order that moves
complexity of payment handling to the
order probably have multiple components
doing payments or retrieving payments
and now if I have this requirement
implemented everywhere that doesn't make
a lot of sense so it's very often it
makes sense to handle it as close to the
to the real requirement or to the
service owning that kind of requirement
which in this case would be payment so
it would be much better if payment
handles that and then tries to update
the customer credit stuff and whenever
this is done or that two weeks time off
has happened we send a message like or
give a response like Pam received or
payment fared much better design because
then you have all the failure handling
local in the
and again if you're thinking about rest
calls it could be that the order to
payment rest call gives a synchronous
response directly payment happened
within like nine ninety percent of the
cases only in cases where this cannot
happen we're switching back to
asynchronous II so that's very that's an
important thought actually if you think
of that and again you in order to do
that and that's why a lot of people
don't do it
it's actually you have to under has to
have to support this kind of
long-running requirement good and this
is how it for example I could login BPMN
charge the credit card of that doesn't
work and form the customer and then I
wait for him to come back and then I
have this notion of time like seven days
for example so that's pretty cool like
so
another type of failures that could
happen always by the way is also where
we also handed over to humans normally
it's kind of operating arrows so if
charging the credit card doesn't work
for for kind of a and whatever failure
it is not a network failure but for
example some data conversion failure
because stripe has changed the API or
whatever we get like these this red
bubble or our so-called incident so the
different tools might use different
names but basically the operating to can
tell you okay there were arrows why we
try to invoke it like in this case three
hundred seventeen please have a look at
that and you get a lot of context so you
see what's currently waiting there how
it get there what data is attached and
these kind of things and you could and
then act on that so an operator could do
something okay I fix it or I do a retry
or I skip that so what a lot of people
actually otherwise very often in program
in their programs is something like this
I I try to do a it didn't work um so I
invoke an operator for however I do that
probably lock a message and then this
guy says okay retry it
okay aborted I do it manually or resume
with the next action we see that all the
time and this is basically built-in so
you don't have to model these kind of
things and you don't have to program it
um and again this is a stateful thing
because you for an operator you probably
have to wait quite a long time until he
gets into the system
the important part and this is a very
important thought actually is that this
kind of workflows are now living within
one system so what I did it's not the
only way I blocked about that how you
can basically run these kind of workflow
engines within services so what are the
architecture options but what I did here
is I used the engine as part of my
service so I used spring boot in this
case I can run the end and embedded as
part of the service so that's a very
lightweight way of doing it so and this
is important because very very often
people think of workflow engine of being
something separate of like a central
workflow engine which I have to talk to
which is not true it's just a library
within the scope of your service because
you want to want to deal with these kind
of long-running systems requirements
sorry but this is one option if you're
running different architectures in Java
like Tomcat wildfly WebSphere you can
also run it in a kind of similar way
there we run the engine as part of the
container and then you deploy a war file
which contains this kind of workflow
definition there in more ways of doing
that but you can can look into the blog
post if you're interested if you're not
running Java which might not be that
important here at the moment but this is
important for a lot of customers you
normally talk to the engines remotely
via rest for example so there are a lot
of options to do that and what I already
showed you in the demo earlier on it
doesn't mean that you have to get
asynchronous so he still can have some
Kronus results ok very cool by the way
for synchronicity I I discussed that so
often so my favorite story was from a
customer railway company and they did
order management basically and that's
very easy to to understand from a
customer perspective so if you want to
want to order a ticket basically you go
in on the web side you search the
connection you hit the button you say
okay I wanna when I have a ticket yes I
want to have a reservation you select
the seed and so on so on and the end you
you click on book and then it does the
payment it does the seat reservation a
couple of other things generates a PDF
and presents it in the browser right so
that's what what normally happens and
they are so convinced that
this must be a synchronous thing the
customer wants this PDF right away shown
on his screen which I think no why I
mean I don't want to have a PDF anyway I
want to have it in the app and if the if
the choice is between okay I normally
get a synchronous response but if they
blow up and that happens for example if
you get a new credit card it happens for
me for all the sides like they say I
cannot process the payment oh yeah right
I have to provide new credit card fees
oh no all my details are gone I have to
do redo the whole process that doesn't
make any sense that's not nice for a
good customer so I don't think
synchronous responds are so important
like all the people always think of and
the I actually like that quote very much
it's from Montgomery and Martin Thompson
from the go-to in Chicago quite a while
ago but it still true so they said
synchronous communication at the crystal
math of distributed programming so it's
like I mean we are so used to do
synchronous stuff calling a method
calling a rest service it's so easy to
understand I just call it get a response
back that's it that we somehow know okay
that might not be the right way because
what I said earlier with the rest
request I even have no idea if it
reached the other party if I get an
error so it's not really synchronous as
we think of it like a method call but we
think of it like a method call it's so
easy and let's do it again just one time
and then next time I do it better
so it's sometimes make very much sense
to to question these kind of synchronous
and patterns but if you look at a
synchronicity that's very interesting as
well so if you make the same example
like ahead early on with a check-in and
the barcode generator
it doesn't change that much because now
this time we are we're reusing messages
sent back and forth because we probably
even use still use request response and
okay now we have to monitor timeout but
we basically do the same thing we want
to have have it local we have um the
notion of time so again avert 400 might
be very beneficial to do that so we
could do something like a sentiment
generate barcode command and then I wait
for it and if this doesn't happen within
a certain time frame
I might even resent that so this
like I do it every hour I resent that's
my retry could do that if I like to and
you even again it's stateful so it's
very reliable and very easy to handle
this kind of times and we could even do
more sophisticated patterns this is
probably if you don't know beep Amen
it's probably a lot in one slide but I
think it's very easy to catch so this
one here means it doesn't matter where I
am currently in that root flow here
whenever it's four hours before the
flight starts I cancel whatever I do
there and do something else
okay the business requirement here might
be a bit probably not what they want to
do but whatever so they get the idea out
so for me it's that not even such a big
difference here if I'm doing synchronous
or asynchronous it has to be again you
have to retry it has to be idempotent on
the other side so that doesn't change
that much actually who uses a message
bus here in his architecture oh not many
people not many people normally it's
more okay so Vienna has to do some more
messaging who has from the I think three
people who has know our problems
operating that message bus oh yeah one
over again when I talk to you later
no normally it's like a but that's
really cool because normally it's really
it's like one one one guy showing up
okay I don't have problem not only
people have a lot of problems with this
kind of messaging architecture why
because they end up with like I sending
messages there they couldn't be
delivered so I have dead messages for
example whenever I have these kind of
death messages I even so customers
having overflowing debt message queues
so they lost messages whenever they look
at the message they have no idea where
they coming from they can sometimes not
even access the payload or even fix the
payload because they see problems in the
data they cannot easy-like click a
button and say redeliver all these kind
of things so they build a lot of tooling
and this normally called something like
message hospital in semi-human in the
micro-service book he also named the
earth message hospital so that's quite a
common thing to do it's it's amazing in
too
9:18 that you still have to do that but
I think a lot of people do that and
that's interesting and the what I see a
lot of customers currently doing or at
least some of them is that instead of
what the normal pattern is what we see
with our engines is like we're having
that word flow and this is actively
calling another service why arrest or
actively sending a message into a queue
to another service customers start to do
changing the direction of the
communication so this is kind of the
other one was kind of a push thing now
it's a pull so the service could ask for
work so we have an API for that I'll
show you that in a minute and this
allows to build architectures where we
use the word flow and earnest kind of a
vert distribution that's a very
interesting thing actually and then
saying hey this service like this
service is still owning the word flow
model and deploying it to the engine but
other services can fetch work and then
it works like a kind of a queue which I
don't want to want to propose as this is
the architecture how you should use it I
I know really a lot of discussions about
smart and middleware which you should
avoid so I'm definitely with that but I
know a lot of customers actually doing
that quite successfully so that's for
also interesting option to have in mind
I show you that in the demo in a minute
I have to actually look at the time so
I'm last thing I want to talk about and
that's actually my very very favorite
topic is a plan to do a proper blog post
on that for ages I'm distributed
transactions so we have this distributed
system who uses two phase commit X a
transactions in production owed to
people you're happy with that I cannot
see your face actually you have to raise
their hand you're happy no no oh no I
can't even see that in the dark it was
like a very very clear sign of not
liking it there's there's actually good
literature on that so you probably know
this and there's from Patel and he was
at Amazon at that time he wrote a couple
of good papers one of them is life
distributed transactions and opposites
opinion so he basically explains very
well why two-phase commit distributed
transaction in a technical way and don't
scale beyond a certain limit so if you
have like a scalable system it doesn't
matter it doesn't work and I didn't see
a lot of other issues with distributed
systems so my my favorite story is a
question on AWS it again thick overflow
and somebody asked something like
whenever I start up that JBoss
application server
I get warning from that hour you know
transaction manager whatever that is for
for something like this it looks like
that and and then another guy answers
and says okay you have to go to this
directory and delete all the files and
the guy answers or her comments on there
and says oh yeah awesome Network yeah he
deleted the pending aborted transactions
from the transaction manager he would
have to take care of them himself so
these are like income documented in
consensus of his transaction manager
because sometimes a transaction manager
cannot I mean he cannot do magic if it
doesn't work in the end you have to sort
it out nobody understands these kind of
things so it's a very bad idea actually
to go into these kind of distributed
transactions but you will have the
requirement of like doing like three
things in like you know all-or-nothing
semantics like you do all of them and
the third thing fails you want to want
to rollback basically the other thing
and what do you do in these kind of
distributed systems and you probably
find something also under the name saga
pattern that starts to get more and more
uncommon term nowadays and in bpmn
that's called compensation and this is
how it looks so you could do something
like I have I want to charge the credit
copy before that I probably deduct money
from the from the customer account
because he probably has a vault or
whatever and if the credit card handling
fayus now we can do and undo basically
that's the compensation there so there
we trigger it and that means all the
activities which were executed
successfully in the past and
have this compensation activity
configured there the accommodation
activity is executed and that's me
that means it's semantically undo right
so you probably see it on your on their
on the credit on the customer credit
account for example you see okay this
was deducted and then it was refunded so
it's not like a real cancel of a
transaction but it basically makes sure
that in the end everything is consistent
and again this is totally reliable so
even if you if you raise that payment
failed here and the credit customer
credit service is not available at that
moment you just retry it you make sure
it will happen at the very end important
and that's but that's kind of a true
nature of a distributed system you can
live with these kind of temporally
inconsistent state where you say okay I
have deducted credit but not charged so
that's kind of inconsistency but you
live with it you can live with it as
soon as it's sorted out in the very end
let's quickly go into that one the last
and them of today so what I have is
actually I have that what's on the slide
so what I said earlier you can also use
oh no that was the wrong one you can
also use the tanks Eclipse don't care oh
that was Java class sorry yes thank you
eclipse so you could also use the
modeler that's what I mean meant earlier
I'm that's a graphical modeler and this
is exactly what we had on the slide and
if I run that which is version six you
can see that this is happening what you
can also see and just make sure that my
credit card service is back to normal
because then I start to get also I know
I get 200 to accept it all the time why
that's important I wanted to to quickly
show that because I have these deduct
customer credit and this time I what I
meant earlier I used that as a verb
distribution so I don't actively call
the service here but I let some work
asking for work and to make a bit more
fun here I used actually JavaScript it
could be everything
it's and github again you can look to
the code it's not that interesting here
but the basic idea is I know ask the the
rest endpoint of the engine to to fetch
for work and hand in a couple of
parameters which are not that important
at the moment and then what I can do I
can start that yes okay and it starts to
processing these instances so the ones I
already started are now processed so
that's kind of the asynchronous stuff
because I brought it back and now I
start to get 200 yeah that's actually
what I wanted so some of them fail
that's kind of a random thing I'll show
you that in a minute because I want to
roll back their transaction some of them
fail but but most of them should be a
200 ok so let's do a couple of them and
what you can see then is if I go back to
the to the monitoring part what you can
see for the payment v6 if I look to the
history or into the history you can see
that I now had like seven instances
which completed completely five of them
failed and for these five of them I also
did the the restoring and we could look
into this is out of the thing but I I
think you believe me and you get a lot
of like these kind of ordered data
historical stuff and so on so on so
that's pretty pretty awesome ok so
that's the next part so if you want to
do this kind of compensation thing it it
means that the service provider has to
provide it actually that's the next
tricky part in distributed system very
often you can do something like retrieve
money but refunded it's probably not
there so plan for that from the very
beginning and then you can you have a
lot of basically power to handle these
kind of problems you have there you have
to handle state a bit but that's
actually very easy if you use the right
tools for that and then if you look at
that I use one random example for from a
client 24 hour fitness they're doing
gyms in the US you know what it Jim is
doing probably always ask for no they
are doing a lot of things they're like
the million stuff and they said what
most of the and people using that are
saying before mapping processes
explicitly with ppm the truth was burned
in the code and nobody knew was going on
so that's the other side of the equation
so as soon as we have the kind of
workflows there visual you can see
what's going on it's always the truth
it's not something you program somewhere
else so it's really living documentation
for this kind of long-running stuff you
have the operations part that's what I
showed and if you like by the way if
you're more I showed a lot of things
about request/response rest and and even
like messaging request response if
you're more into DDD meant driven stuff
there's also an example it's online we
don't go into details today it's using
Kafka underneath and to carmona
instances their spring boot again I
showed that last year here as well if
you're interested in that and ask me
later there you can see what I meant
earlier with the word flow now really
lives within a service so we have
different workflows for different
services and we don't have any central
workflow engine that's not necessary at
all awesome if you ask for people really
doing that there are a lot of people
really doing that one example I
personally like solando there are also
active ears or they're shipping closes
and they're pretty big and they showed
how they do their order fulfillment
process so the process of solando
they're using Kafka underneath they're
using kimono so it's pretty comparable
to what I showed here and they're doing
it's more or less exactly like that so
that's pretty awesome so that's it
that's a summary so a lot of people know
about fail fast which is great I think
that's better than like two or three
years ago but it's not enough for a lot
of use case not for all of them but for
a lot of use case you can do better by
by introducing long-running things and I
mean this introduces new components like
like the virtual engine but it gives you
a lot of concepts to handle failures
much more local and that basically
improves a lot of yeah a lot of things
in your architecture so that's it that's
all I have what I said early on I'm
still around for the next like two two
and a half hours so there's anything let
me know I cannot join tomorrow I cannot
join in the
I'm sorry but thanks for coming when I
say</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>