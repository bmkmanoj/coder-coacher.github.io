<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>It’s Java Jim, But Not As We Know It by Simon Ritter | Coder Coacher - Coaching Coders</title><meta content="It’s Java Jim, But Not As We Know It by Simon Ritter - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>It’s Java Jim, But Not As We Know It by Simon Ritter</b></h2><h5 class="post__date">2016-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bhSBpNXwa60" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good well good afternoon and welcome
um I have entitled this session it's
Java Jim but not as we know it and I
have to say the inspiration for this
particular presentation I'm doing came
from Jarek who's sitting down the front
here because I saw him do a presentation
on this subject
bakit boxed in Zurich earlier this year
and it kind of got me thinking about
this and so I've kind of done a
variation on what Jarek did so what are
we actually gonna talk about well we can
talk about lambda expressions but we're
really gonna go more into what's behind
lambda expressions so quick show of
hands who's using JDK 8 okay good
quick show of hands who's used lambda
expressions okay I'll bet you haven't
used lambda expressions like we're gonna
see in a moment because lambda
expressions as we use them in JDK 8 are
very powerful and very useful and so we
use them in lots places where we want to
pass typically we want to pass behavior
as a parameter rather than a value and
so we can then evaluate based on that
behavior and this all goes way back in
terms of the history of lambda
expressions to the 1930s and Alonzo
Church who came up with this thing
called lambda calculus and lambda
calculus is really the basis of
functional programming so again let's
have a quick show of hands because your
Java programmers but who would consider
themselves a functional programmer yes
you see there's a few people there but
there's not many and I have this issue
as well because I'm not a functional
programmer and I remember when I was at
university I did one course on Lisp and
I remember at the time when I did it
thinking my brain doesn't work that way
you know I could do imperative code I
can do procedural code you know done
lots of languages and I have no problem
with that but functional programming
takes a different kind of thought
process and so lambda calculus is really
the sort of basis for that what does it
have to do with Java
right so what we're talking about here
is exploding head Landers so we are
typically imperative programmers we
understand about loops we understand
about variables we understand about
maintaining state all of those good
things functional programming is not
about that functional programming is
about using functions and applying them
repeatedly
so in effect sort of like a recursion
approach rather than using a loop and as
we'll see you can do some kind of weird
and wonderful things with this but
interestingly enough and this is kind of
what we're going to talk about in a bit
more detail is the fact that lambda
calculus and Turing machines are
functionally equivalent so anything that
you can do with a Turing machine you can
do with lambda calculus and this you
know it's more kind of interesting
things there because Alonzo Church was
actually the supervisor for Alan Turing
so there's you know another connection
there
but when you get into using these things
in a much more sort of complex way well
it certainly gives me a headache just
trying to work out how these things work
and well talk to you through an example
as we go through so the idea of this is
what can we do in Java only using lambda
expressions so we're not allowed to use
any primitives we're not allowed to use
any types we're not allowed to use any
operators how can we replicate what is
you know possible in Java only using
lambda expressions so the first thing we
need in terms of lambda expression is a
functional interface because a lambda
expression represents the implementation
of a single abstract method in a
functional interface for the purposes of
this particular session what we're going
to do is we're going to use an interface
called a lambda okay very original name
there and it's going to have a single
method called apply which takes as a
parameter a lambda and returns another
lambda so you can pass lambdas get them
just back that's all you can do there's
nothing else in there it's just lambdas
what we need to do is we need to
understand some of the basics about
lambda calculus and what you have so we
can create a very simple lambda
expression which is called identity the
identity is a lambda expression that
will return the same value that you give
it okay there's nothing very exciting
about that but it is very useful it's
very powerful in terms of lambda
calculus and what I'm going to use as
well to kind of make life easier in
terms of being up see these things is
I'm going to use lambda notation in some
of the examples just to make it shorter
rather than having to put all of the the
actual Java code there because otherwise
it gets very very complicated I will
show you the code at the end make sure I
got enough time for that running in the
IDE so you can see it actually work so
the way you represent that is just
lambda X dot X so that's the the
equivalent lambda expression what we
then need is representations of boolean
values so we need a true and we need a
false now interestingly if you look at
this what you get is boolean false is a
lambda expression which returns another
lambda expression and the länder
expression that it returns is identity
so the thing about that is that false
will always return identity as a lambda
expression true is logically the
opposite or false so we have a lambda
expression which returns another lambda
expression which is not identity so
false will always return identity true
will always return some that I Lander
expression which is not identity so
immediately I kind of look at that I go
oh hang on well well shouldn't it be the
other way around because true should
always be sort of like identity but
anyway so what we then need to do is
look at numbers so how can we represent
numbers with lambdas and these are all
called church cardinals so church
numbers if you like and 0 because 0 and
this is where we see the link with
mathematics 0 is the identity for
addition and subtraction so if you add 0
to any number or you subtract 0 from any
number
you get the same number so it's like the
identity for addition and subtraction
and if we think about some programming
languages like C is a good example if
you do an if statement you don't have a
boolean in the sense that you do a
boolean type in Java so what you can do
is you can say well in that case 0
equates to false and anything that's not
0 equates to true so we can see how
false in that case is identity because
its identity is 0 and it's the episode
it quotes to false so 0 is the same as
false which is the same as the identity
so we have a same lambda expression that
we use for false we can use for 0 if we
want to create numbers what we do is we
simply apply a function to X in terms of
our lambda expression and if we want
higher numbers we simply apply that
function multiple time so we apply
function to a function to a function
however many times we want that
particular number so in the case of 1
what we have is a lambda functions an
expression which returns a lambda
expression that implements a function on
or applies a function to a value for 2
we have a lambda expression which
returns
that's just typo there lambda expression
which applies a function and then
applies function again to a value so we
end up with 2 applications of the
function and you can do that as many
times as you like to kind of make things
easier you can then also define much
more complicated lambda expressions so
you can define a successor which simply
takes a number which remember is
represent by lambda expression and adds
one to it but in the case of this what
we actually have to do is apply the
function again so you end up with this
lambda expression which returns a lambda
expression which then returns another
lambda expression which applies the
function and then uses n dot apply of F
and applies X to that you can see where
you know things start to get more
involved
the predecessor and I'm not going to go
into too much detail about this but the
predecessor as you can see is even more
complicated because what we need to do
is we need to reduce the number of
applications of that function by one and
we need a very complicated lambda
expression in order to define that
addition and subtraction now addition is
essentially what we're going to do is
we're going to take the numbers that
we've got so we've got two numbers and
we want to add both represented by
lambda expressions and then we're going
to use a Lander expression to manipulate
those lambda expressions to create a new
lambda expression which is the value and
so I'm going to show you example of that
in a moment
subtraction is slightly simpler simply
because we can use the predecessor
lambda expression that we've already
defined so you can apply that and then
reduce the number by one but sorry you
can subtract the to one number from the
other so let's look at an example let's
look at solving two plus two now I was
working on this yesterday morning and I
was having breakfast with my son who's
ten years old and he's doing maths at
school and he's you know he's getting on
well with that and he was saying like
daddy what are you doing I said well I'm
trying to figure out what's two plus two
and he looked at me like a stupid he
said most easy it's four and I said well
yeah but what I'm trying to do is I'm
trying to use lambda calculus to do that
rather than just numbers and he's like
ah okay so he looked up what I was
writing he said no I don't understand
that and I knew exactly what he was
talking about there right so if we look
at two plus two we know that two as a
lambda expression is represented by this
so it's number F lambda X and then apply
the function f twice on itself on the
value X to give us the representation of
two plus the lambda expression that
we've already seen is represented by
this lambda expression so we have M n
which are values that we want to add up
and then we've got F X the lambda
expression and then we've got M of F and
a
F applied to X and what we want to do is
we want to essentially say using polish
notation plus - - and if we were to call
this as a lambda expression we would say
lambda 4 equals plus dot apply to apply
- and that will apply the lambda
expression and generate the result so
let's see how that actually works
because this is this is where life kind
of gets interesting okay so we have the
lambda expression that represents
addition okay and M and n are the two
values that we want to add up so what we
need to do is we need to replace M and n
in our lambda expression with the lambda
expressions that we have for the numbers
that we're adding
so in this case it's 2 &amp;amp; 2 so replace M
in the lambda expression with a
neulander expression which is 2 and take
off the lambda N and lambda M because we
don't need those anymore because we've
done the rip replacement what we then
need to do is evaluate what's inside
these brackets that I've underlined so
this is where we're essentially applying
the lambda expression on the left with
the value or the value on the right to
the länder expression on the left so
we've got two examples here the
identical where you've got lambda f of
lambda X F of f of X and the value that
we want substitute there is f now if we
look at the left-hand side of the lambda
expression then we've got lambda F so
essentially we're replacing F with F
which means we get exactly the same
thing so we basically just drop the F
and we get that so we simplify the the
lambda expression down so now we've got
the situation where what we actually
need to look at is this part of the
inner brackets so we're saying okay
we've got lambda X dot F of f of X and
we want to apply to that a value which
is another lambda expression so we're
going to replace X in the left hand side
with the red part which represents
Bamber X dot F of f of X and so we put
that in the middle there and we say F of
lambda X of f of f of X
and effects and then all we need to do
now is to evaluate the lambda X of f of
f of X with X so we're going to replace
X with X which is quite simple and we
end up with the situation where lambda F
of lambda X F of F of F of f of X and
that's four so we've actually added the
two numbers giver just using lambda
expressions so I've got a minute and a
half left a couple of places you can go
for more information if you're if you're
actually interested in this enough to go
further it honestly isn't really very
practical in terms of writing Java code
it's just more a kind of fun thing I
wouldn't actually expect anybody to
reuse this garrix presentation is on
YouTube you can see that's not more
detail and it goes into a lot a lot of
other stuff with this and then there's a
guy called Dickson yang yang Yang who
works Microsoft and he's written a very
good set of blog entries which a c-sharp
based but you can you can see the
relationship because c-sharp and java
have a lot of similarities so I'm just
going to quickly couple of seconds here
just so I can show you right here we go
so this what I've got here is I've got
the lambda for plus which is yeah so m
dot apply of F apply n dot apply of F
dot like X I've got lambda 1 lambda 2
and then before so we can see what the
those lambdas are and then we're going
to apply plus we're going to apply to
two plus and then apply to two plus
again so get the total you know there's
an extra line there I don't need and you
will see at the bottom that we've got
two plus two is the same as four so
we've got the the actual correct result
and that actually uses again garrix
library that you wrote in order to take
a lambda expression and then print it
out in the form which allows you to see
on the screen like that which again uses
some some kind of strange
some magic insight so there you go them
that's that's all the time we've got for
that hopefully that has been fun thank
you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>