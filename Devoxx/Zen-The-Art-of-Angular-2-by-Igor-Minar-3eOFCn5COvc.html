<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Zen &amp; The Art of Angular 2 by Igor Minar | Coder Coacher - Coaching Coders</title><meta content="Zen &amp; The Art of Angular 2 by Igor Minar - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Zen &amp; The Art of Angular 2 by Igor Minar</b></h2><h5 class="post__date">2016-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/3eOFCn5COvc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody hi Guys hi doing my name
is igor urban our I'm the tech lead on
the angler project I work at Google in
California and I came to talk to you
about angular we released the angular
version to a couple weeks ago and I
would like to tell you what it is and
why it's awesome but before we start I'm
curious how many angular developers do
we have here how many angular 1
developers do we have here ok about
one-third I think uh anybody familiar
with angular 2 already Wow ok almost the
same number cool ah how about people who
don't know anything about front ends
that's awesome we have so many front-end
developers here cool I'm going to sell
lots of licenses today angular's
officers projects so it's really free
you can use it so in order for me to
talk about angular 2 it's important that
we actually start with angular 1 i've
been on the project from the very
beginning angular 1 started on around
2009-2010 and in order to understand why
we built angular 2 let's take a look at
very quick like angular 1 angle of one I
was built for a different kind of web
that we have today on in order to
understand that we have to look at like
what kind of applications were building
back in those days those are mostly
jquery applications we had some great we
had adobe flex we're talking about thin
client versus thick client that was big
debate about which way to go on and
angular decided that really what we want
to do is we want to change the way we
look at the browser and we want to make
browser into something what it would
have been had it been built for building
client-side web applications because
back in those days the browser was
really built for displaying static
documents and this is how most of the
server-side rendered applications work
the server-side templating enjoy the
services framework would generate HTML
would send it to the browser the browser
will display it you
the clicks on the button around the link
it goes back to the server the server
generates new HTML document senses to
the browser so in in late two thousand
we saw that people wanted more
interactivity so we started doing most
out with JavaScript and we soon realized
that it was getting really difficult to
build interactive applications with the
kind of JavaScript and browsers we had
at the time so that's where angular came
and in 2012 we released the angular 1
and it actually turned out to be a huge
success and in just this year on our
community became the fourth largest
community on github on in terms of
number of contributors to the project
and it's funny because there's also
google which is number five so angular
that comes from the google is bigger
than most of the project most of the
other open source project that under the
google organization and so this was a
great success we we liked what we build
we like to use it but we realized that
it's awesome that we were successful
back then but we knew that success is
not going to last forever we knew that
there were going to be challenges ahead
of us and we saw that there were changes
to the web that we built angular for
coming in the next few years so around
2013 we started thinking what would the
version of angular for the future
version of web look like and in order to
design a framework like that we have to
look at the environment how the web is
changing and one thing we saw was the
promise of ECMO script 6 which in 2013
looked like a pipe dream it looked like
maybe it's going to happen maybe it's
not going to happen tc39 was not really
making a lot of progress and was
uncertain when all of this stuff is
going to come but we saw a lot of
promise in es6 in es6 especially in
terms of adding new and new syntax
features like classes that allowed us to
express the components that angular
applications are built with in a much
better way we also saw that the module
system that was designed for like my
script 6 would allow us to deal with the
scaling problems that we had as the
number of files a number of
the size of the codebase was was growing
and lastly there was a ton of syntactic
sugar just like fat arrows and many
other things that just made the code
that we wrote on daily basis much more
pleasing to read and also too bright so
we thought okay es6 is coming probably
not this year probably next next year
hopefully the next year how about we
start designing framework for this new
version of es6 and take the advantage of
all of these new features that are
coming into the language and that was
one of the influencing factors for
angular 2 the next thing that we saw
that was coming and that was changing
the the web in a very dramatic way was
web components web components is an
umbrella umbrella specification for a
bunch of standards that talk about
interoperability on the web at the level
of the Dom elements and we really liked
the ability to take components build in
other libraries in pure JavaScript code
and just drop it into angular
application and just make it work with
binding and everything so it's just
seamless and this is actually one of the
things that we did in engli too we also
like the composition model angular 1
applications even though we didn't start
with with the component composition in
the in the true way we started with
controllers and stuff like that but over
time we evolved to building applications
using components as the basic building
block web components reinforce this
notion that using components as the the
basic composition model was the best way
to build large applications so this was
one of the things that we kept in
angular and made it d primary way to
build applications in angular 2 another
thing that came with web components was
a notion of capsulation whether its
encapsulation of state within the
component or exact encapsulation of
styles in the component and we build it
into angular 2 and there were other
factors that were influencing where the
framework needed to go in order to be
useful in the future there were things
like user expectations have changed
quite a bit the applications that we
build in 2012 that were considered to be
state of art were totally not very
user-friendly four years later
users expected much more interactivity
from applications user now expect
applications to be really fast to be
smooth and those were not the
requirements we had in in 2012 because
nobody thought that we will be building
such a complex applications and with the
with all these features the application
complexity and the size of the
application was just growing and to deal
with that things we reading is more
tooling but also we started needing to
have larger teams to build these
applications because in the past you
just had one front-end developer
developing a bunch of John jQuery code
but now you have full teams where often
we even see people developers from the
server side coming to the front end
aside to build the UI for the for the
API is that they are exposing on the
server so we need a solution that would
scale not in terms of just the code c
and code base size but also in terms of
contributions from the growing growing
team and we took all of these changing
requirements and all of these new things
that were impacting how we build
applications and build angular 2 we
released it about six or seven weeks ago
so it's relatively fresh and um one of
the first things that we one of the
first questions we get when we talk
about angle 2 is what's the difference
between angular 1 and angular 2 and I'm
going to focus most of my my talk on
this just to talk about what are the key
differences between angular 1 and
angular 2 but before we even started I
want to say that the core principles of
angular are the same between angular 1
and angular 2 we really want to help
developers build awesome applications
that people like to use we want to make
the developers productive and doing this
and we want to help them guide guide
these developers in building these
applications in the right way how this
is done is quite different between the
two frameworks and we'll see soon what I
mean by that I'm going to focus on three
areas on in of the the differences one
is going to be developer productivity in
angular 1 we spent quite a lot of time
talking about the productivity how
declarative templating was the way
to go how data binding was reducing the
code but we decided that angle too we
really need to take it to another level
and to take it to another level we need
to go deeper which often means looking
at the language that we are using and
for many this was quite surprising
because we formed a very good
relationship very good friendship with
the team from Microsoft out of all the
places called Ted script typescript team
is building a language that is a
superset to JavaScript and does it in a
way that is doable that has a lot of
benefits of static typing and the things
you like the most when when interacting
with the typescript team besides just
being a bunch of cool cool guys and gals
was that we got a lot of error checking
which is important to us your
application grows you want to learn
about mistakes as soon as possible and
typescript and the static compiler tells
you about these mistakes very early on
we also like the ID support we like the
auto completion to help you get us you
or thur your code and also the
refactoring support as your application
grows and you need to change your code
which is very frequent on it's great to
do it in a safe way and it's difficult
to do this in JavaScript because
everything is dynamic it's hard to make
safe refactorings once you have a type
system overlaid over JavaScript you can
do factoring in a safe way where it's
guaranteed that the application still
will work after the refactoring and the
last thing that was I think key when
considering different alternatives to
type script was the JavaScript
interoperable interoperability on
typescript is really just a superset of
JavaScript it doesn't add any new
language features on that available at
the runtime it only transpires code that
is not yet available in the browser so
it tracks the latest specification of
ECMO script and for features that are
not implemented browsers those are
transposed into into code that runs in
today's browsers but it doesn't that add
anything new that isn't in es6 the only
thing that it adds on top of javascript
is a type system it overlays this and
this is
mission is used only during compilation
time where it gives you all error
checking and the ID support but once the
transformation is finished there are no
types and you just have JavaScript so
for many people that are worried about
typescript one cool thing is that if you
try using typescript it doesn't work for
you can just try and spoil into
JavaScript and you can continue from
there on because it's very it's pretty
much the same code just the type does
stripped the next thing I want to talk
about is that this uh the typescript was
so influential for us that we decided
that we're going to model our ID support
based on how typescript does it
typescript has this concept of language
services which is a library that
analyzes your project and works with
your IDE that provides visual interface
for all of the refactoring
auto-completion but all of these
information is really coming from the
tapestry itself it's not something that
is implemented in the in the ID we saw
we did the same thing with with angular
language services which are going to be
released in a month or two I think on
and with with this feature we will have
all of the error checking of the auto
completion all of the refactoring that
you have in imperative code also
available in angular so the clarity of
templates as soon as we started working
with es6 and typescript we realized that
some people are intimidated by tools
they don't like setting up their build
systems they don't understand what is
happening when when you need to
integrate all of these tools and that's
why we create a project called angular
CLI which abstracts away all of this
stuff it allows you to boost you up the
application by scaffolding the project
it provides you with with development
server with the build system setup and
so on so on on in angular 1 we talked a
lot about testability and to make
testability easy we provided two tools
we provide a karma for running unit
tests and protractor for running into
incest in angular 2 we made this tools
better and we also added a third tool
called bench press bench press is a way
we do performance testing so if it's
something that you want to track if you
want to track performance on a project
and there is a tool called branch best
that you can use for that
last thing in this category of double
productivity is a material design in
angular 1 when we release the framework
we didn't have any set of components
that you can use and what we notice was
that when developers start to build
applications they really need some set
of basic UI components to just get
started because creating new buttons and
new menus all every time is not great so
this is why in angular 2 we started a
project material design for angular 2 as
early as possible so that we can release
it much sooner than what we did for
angular 1 currently the material design
has pretty good coverage of components
and we're expecting stable release in
the near future the next area then I'm
going to talk about and you're probably
going to hear a lot about performance
and angular in the future because this
is where we spend literally two maybe
two and a half years of our lives and
one thing that we soon realize is that
performance is not a single number it's
not a good or bad there are many shades
of that but also there are different
aspects of performance and one thing we
realize is that we need to focus on at
least two of them one is the bootstrap
performance which is influenced usually
by the size of the application so the
smaller we can make the JavaScript
payload and the more code we can lazily
load the faster the application will
start and the next aspect is the runtime
performance how fast does the UI update
once the application is running how much
garbage is collected and how much time
is spent doing garbage collection and
many many other aspects similar to this
when you look under the hood of angular
2 one thing you realize is that it looks
kind of similar to angular 1 we have
HTML templates we have CSS and we have
JavaScript code or typescript code and
this is the input into angular compiler
we had angular compiler in angular 1 as
well and one thing I want to point out
is that this compiler is very very
different from the one in angular 1 in
angular 1 the compiler would look at the
application will start run it as we
would run this application create some
temporary data structures and would
interpret this data structures so one of
the one parallel I can make is angular
one was sort of like interpreted
language arm and that also caused some
performance issues that we saw in
angular 2 we took a very different
approach we do static analysis on the
application so we actually analyze the
templates we analyze the composition of
your application how the components are
nested we understand your model pretty
well and what we do is we generate
optimized JavaScript this is very very
different from regular one and what this
means is that once the compiler is done
what we are left with is the code the
imperative code you wrote your
JavaScript I script code and the code
that angular generated specifically for
your application considering all the
bindings you have any application all of
the components and how these components
are nested this this code is heavily
optimized so that it runs really fast in
the in the browser and there are many
other benefits that I'll talk about in a
bit but how does this translate into
performance on one thing we wonder is
like yes we're making all these
improvements but how can we measure and
how can make sure that what we are
actually doing make sense so what we
decided to do was we analyzed a bunch of
big applications reduced the common
patterns into a suite of performance
tests one of them is the benchmark which
is one that we heavily rely on which
tests the composition especially in
large applications if you have lots of
components nested how what's the
performance of creating this view is
destroying this views on and we
implemented this benchmark by hand using
the most efficient method we could come
up with this is not the code that you
would typically bright in the
application because it's very verbose
and it's very difficult to maintain even
if you ever use this kind of technique
to write code you would do it in one or
two very hot places in the application
but this is how we implemented the
baseline and then we looked you know
what does with us angular one
implementation of this benchmark look
like how does it perform
arm and then we compared that to angular
2 so right away we saw that there was
major major reduction on in the overhead
that the framework was adding right now
right now we had a 1.5 x of the baseline
are not goal is to reduce this down to 1
point 0 on so that we are as good as the
optimized code and again this is code
that is generated by the compiler and
it's generally the scale that is not
possible to do by hand we do it for the
whole application so um this is really
really good result if you notice on this
this compilation just like an angular 1
runs in the browser this kind of setup
we call the JIT mode where the
compilation happens in the browser just
in time as we are bootstrapping the
application and this is slightly
different from what it means in the Java
world so please bear with me but one
thing we realized yes we can statically
analyze the hell application wouldn't be
great if we could actually not do this
work in the browser because when the
browser is starting that means the user
wants to interact with the application
and for us to analyze the application
generate the code we're just delaying
what the user wants to do so instead on
we implemented ahead of time compilation
which is the same we use the same
compiler we just run it in the acid
build step where we analyze the
application and we generate code that is
then sent to the browser so when the
browser when the application starts all
it's doing is just running this code
that was already pre generated as a
build step and this results in in many
many key benefits we call this mode to
have time mode and when it comes to the
benefits we get major reduction and
payload size because what this means is
that we don't need to ship the compiler
anymore the compiler is something that
is used during only during the build and
then angular 2 compiler actually makes
up most of the framework I don't know
the exact number but I Willis commits
like seventy to eighty percent of the
whole payload is just the framework and
it's just the compiler the other benefit
is that we significantly reduce the
bootstrap time the first time to render
because we don't need to do the analysis
we don't need to do the compilation and
all the application
is doing it as soon as it started starts
rendering the UI on we also get the
benefit of error checking because we are
statically analyzing the application we
can catch errors early on so if you
create an improper incorrect binding if
you bind to expression or a property
that is not valid we can tell you there
in the compilation time you don't need
to run the application and this is a
figure this out in production and last
thing I want to point out is that we get
a increased security in the Google
securities team is just ecstatic about
this because by not having the compiler
in production we are reducing the attack
surface of angular applications because
once the code is generated the set of
functionality that the application can
do is limit it to the code that we
generated there is nothing new that the
application do can do which is not the
case if the compiler is in production
and if the tackler manages to trick the
compiler in compiling some malicious
templates or malicious components then
angular applications can can get into
trouble so security team really likes
this feature when we look at the
performance comparison in this deep
three benchmark we see significant
reduction in the low time but also
significant reduction of the payload
size once we have the alt mode own we
can create hello the deep tree or hello
world style applications very simple
applications that are 49 Kane in this
case in case of hello world and super
advanced optimizations we can get down
to 30 but we are hoping to do better in
the future but this is a very small this
was a very small use case that doesn't
really show that true power of a ot when
we started to talk to a team that built
lucidchart switch implemented angular 2
we were blown away by the results that
day God with a OT they did a case study
where they compared the digit mode and
the alt mode and in this case lucid
charts it's it's a very rich
applications for building graphs and
diagrams and on the the difference for
their applications was just huge and
they
they're using the head of time mode
right now and they saw major increase in
user satisfaction increase there are
other things that we are doing to make
the bootstrap fast boost up time faster
we reducing the code on use the the tree
shaking methods we are making sure that
in any kind of debt code that is not
used is not shipped to the browser but
we are also doing something called lazy
loading if you ever build very advanced
or more advanced java applications you
probably have to deal with class loaders
and which allow you to load Java code on
the fly lazily which can bootstrap which
can help you improve the performance of
your application this is not something
you typically want to do it gets messy
it can be pretty tricky so what we did
in angular we we did this kind of lazy
loading for javascript and we built it
into the framework so that when you're
building the application you don't have
to think much about how to set it up on
we recommend that you split the
application into small pieces based on
routes routes out like the screens of
your application and the whole framework
and the tooling is set up so that you
get this benefits of lazy loading very
very easily and yes I won't shut up
about performance because performance is
so important to us many people ask us
for example like do we have virtual Dom
no we don't have virtual Dom we actually
looked at virtual Dom that was made
popular by it by react and realized that
that's not the path we want to go
because we saw several performance
issues in that area and this was
actually proven by incremental dome
which is variation on virtual Dom that
what shows that virtual Dom is very
inefficient generates a lot of garbage
on and there are better ways to do it we
think that the way we do it with static
analysis and cogeneration can can give
us a major adventure advantage compared
to these other methods and that that's
what we're doing so if you're asking the
over children please don't ask me a
virtual dumb because it's not worth
trying to do we found better ways to
deal with performance but there are
other things that we are doing we're
doing web workers angular is probably
one of the first mainstream frameworks
that
ads direct support for web workers what
this means is that we get concurrency
for application typically web
applications the client-side ones are
single threaded so if you do more work
on your main thread than what you should
you're blocking the UI rendering in the
application gets choppy with web workers
you can avoid this and it gets pretty
tricky to use web workers without any
kind of support by the framework so we
made it very easy for you to use web
workers we are also using service
workers that we support service workers
for you to do better caching management
and build offline applications on we are
constantly improving the code we
generate so it's faster using different
optimization techniques and we are
reducing the payload size our goal is to
get to 10k for hello world which if we
do get then we're going to get a cake
that's what I was told so we're working
for a cake many of these things are
still experimental or in development if
you're curious come to talk to me and i
can i can tell you know which which
scenarios these technologies are useful
for but we are working on stabilizing
these and start releasing them as stable
in the in the future and the last area
so we talked about the developer
productivity time we talked about
performance the last area where angular
2 is significantly different from
angular 1 is the area of reach of the
application or or the reach of the
skills that you can apply once you learn
angular with angular 1 once you learn
angular you could build web applications
primarily consumer or disk list of
enterprise applications that was the
thing that we build it for it in 2012 on
over the years people start using a glow
one with mobile applications ionic did
the awesome job of adjusting angular 12
to be suitable for mobile applications
but with angular 2 we thought you know
we we are building this framework for
the next 5-10 years we should really
think about all of the scenarios where
people want to use angular and realize
people are using
there are applications across many
different devices so the way we built
angular is we wanted to make it scalable
from the low end mobile devices all the
way to desktop browsers where you use
enterprise systems with lots of data and
lots of interactivity and anything in
between so this was this was our goal
and we partnered with several teams to
make this happen where you're working
with a chrome team at Google on making
sure that progressive web applications
the kind of new breed of mobile web
applications can be built easily with it
with angular we were working with
partners that are helping us build
installable mobile apps like I only
concern you I and native script on
whether it's a rendering whether these
applications use a webview for rendering
or native Native renderers like in case
of native script and the last category
where we we saw interest in the
community was electron applications or
applications for desktop that integrated
with the OS and take advantage of always
level ap is so we have a electron
integration that allows you to build
these kinds of applications but it's not
just about how we render the
applications or how users use the
applications now that angular is
architected in a very different way we
have the possibility to render and run
the applications in completely different
environments we can run angular
applications on node or asp.net on the
server side and use this to pre-rendered
applications this is very useful if you
want to further increase the bootstrap
performance by preventing static HTML
that you sent to the client the browser
displays it and while the user is
looking at static HTML you're
bootstrapping the dynamic applications
in the background so this is already
available in node 4 node and asp.net we
are currently looking into
implementation for Java because Google
Google is a Java shop and there's a lot
of interest in this kind of solution for
job we don't have it yet but it's
something that we're looking into so to
summarize the key differences between
angular 1 angles who is really in the
productivity the tooling that you get
with angular 2 and how we thought about
architecting not just the framework but
the whole ecosystem to make developers
more productive we spend a ton of time
tuning the performance to make sure that
the application is built with angular 2
are fast to load they rear-ender very
quickly and allow you to build the
smooth applications and reach
applications that users expect today and
the last thing is we want you to be able
to acquire skills that not only make
good angular developer but thank you
good developer in general and once you
have these skills you should be able to
use them for many different scenarios
not only for building one kind of
applications but whether it's a mobile
application desk good application or
server-side rendering application you
should be able to use the same skills to
build these this is something people so
people ask me who's using angular and it
was just released angular 2 was just
released six seven weeks ago but around
that time when we looked at how many
people are using angular 1 we measured
this by the interactions are unique
visitors to our documentation sites and
how many people come on a monthly basis
and we estimate that there is about 1.2
million developers that build angular
applications that come to our website
and learn about angular and and what was
surprising to us that already in October
we had 600 23,000 developers looking at
angular 2 learning it actively using it
and this is not just a spike because of
the launch this is something that we saw
as a trend increasing trend during the
beta phase and the RC phase of building
the framework so we had high hopes that
people would accept angular 2 and adopt
it but this doesn't totally blew our
expectations away and we are very
grateful for the community to have this
kind of interesting angular 2 one thing
that angular 1 didn't have when we
launched that angular 2 does have is an
ecosystem around it when we launched
angular 1 there was a small community of
crazy developers working with us on
github and building their applications
with angular 2 was launched we had a ton
of partners that were building courses
writing books creating workshops events
widgets and different components tools
integration all kinds of stuff
most of it was already in a usable state
by the time we got stable so this was
really great for developers that started
using angular 2 because they didn't have
to come in and try to struggle with you
know where do I find my materials are to
learn about angular it's already
available and one thing that also
surprises us quite a bit was even during
the beta phase before we were stable
people started building angular 2
applications because they like the
solution so much that they did not want
to use any other technology they wanted
to go with angular 2 they saw the
promise and they liked that they had
really good experience with building
applications even in the early stages of
the framework development we have many
teams at Google that use angular 2
already that ship into production some
of them are mission critical like Google
Adwords and double-click for advertisers
there are many other big financial
institutions on NPR and national fabric
public radio on Microsoft is heavily
using in order to and many many others I
would like to show you some of the
angular 2 stuff so we talked a lot about
why did we build it how do we build it
but I would like to invite still in
flowing a developer advocate on angular
team and together we a bill going to
build angular 2 application just to show
you how does it work and what what does
it mean to build angular 2 application
so one of the things that eager talked a
little about is this idea of developer
productivity so we are going to hear
together live build a or try least to
build a very simple angular application
that takes advantage of a number of the
different features and parts of the
ecosystem so instead of using the CLI
and waiting for the network connectivity
I have instantiated here a mobile
application or excuse me a web
application so this is a pure baseline
application that was created by the
angular CLI using ng new I'm at the
command line and so let me just give
this a test here to make sure it works
so i'm going to use ng cesare little
bigger absolutely sorry it's already
running in the background
alright so if that's already running in
the background that we should be able to
pull up the browser and take a look at
localhost 4200 and we have an app that
works so once again this is just
scaffolding so this is setting up all of
the the typescript translation all of
the bundling using webpack and all the
things under the hood that you might
need to to build an application we
should mention the type Scriven though
it's a preferred solution it's not the
only language you can use you can use
es6 you can use babel if you want to you
see a sixth bubble or you can use es5 we
just have the best experience with
typescript so that is why i recommend
typescript as the primary way of
building applications absolutely so i'm
going to bring in two dependencies here
so i'm going to bring in material design
so we're gonna bring in a material
module from the angular material project
and then we're also going to pull in our
router so the router in a single page
application if you're building with
javascript is what allows you to map a
URL in the browser into some level of
state within the application so now that
I've pulled in those two dependencies
I'm also going to go ahead and add them
to my module so that my angular module
knows that they are dependencies here
and right now I'm just going to pass in
an empty array of routes so we won't use
the router yet window bigger window
bigger definitely can do that also you
can show of some of the auto completion
you're getting with the editor sure sure
so as i was typing router module here
you could actually use because we're
using typescript we could see all the
things that we have and then as soon as
i used head completion there i can see
or i should be able to see all the
methods on the router module so here we
can see that for root is one of the
methods which is allowing us to set it
up the appropriate providers for the
router i'm sure this is something that
java developers have never seen before
and one more thing i'm going to do is
I'm going to copy in some simple CSS
styles so when we use our material
design we have the default theme perfect
so what I've done is I've basically
imported the default theme and then I've
reset some of the more basic CSS and
HTML so there's not a lot of magic going
on here but if we take a look back we're
going to see app works here and then
what we can do is we should be able to
use those styles so what I'm going to do
is instead of a simple h1 that we get
automatically I'm going to go ahead and
wrap first let's change the application
name here let's call it angular github
browser and then let's go ahead and find
the HTML for this there it is we're
going to change these out from h1 tags
into md toolbar tags and give them the
color of primary
alright so what we're going to be doing
next is we're going to be actually
connecting this to a live data back end
so I hope that the internet actually it
continues to work so as you can see here
it's all material design looking now so
I'm going to create a new file here i'm
going to call this my repo service so
the idea here is we're going to build a
service that connects to the github API
and pulls down a list of repositories
that match and have the term angular
within them so i'm going to import a
couple things from angular yep jerk the
pool it's the problem with typing in
front of 900 people guaranteed to make
some typos all right we're going to use
completion there and so I'm making an
injectable so that angular's dependency
injection knows how to find it and then
I'm going to export the class and then
I'm also going to do one more thing
because we want to use the HTTP we
actually want to make network halls i'm
going to import HTTP here and again
using dependency injection i'm going to
pull an HTTP into this class and so
we're using that type script type
annotation to understand hey i'm
creating a variable called HTTP here of
type HTTP and then angular is actually
using that type to look up hey what
provider am i looking for here also in
the application there is a definition
what the implementation of HTTP is and
so I'm creating a local member variable
here called repo this is a great example
of where typescript is awesome but you
don't actually have to supply types if
you don't want to and then I'm going to
say this stuff repo equals HTTP don't
get and I just realized we don't have
any completion because it doesn't know
this as a typescript file let's go ahead
and save this real quick
that's a little bit better all right so
we should be able to type HTTP actually
let's create a local variable and just
put the a path in here the broom to
Sue's of the top let's do them did you
forget how to write JavaScript I did one
hundred percent I just learned this this
morning's on rather new alright so we're
going to get the path and then what
we're going to do is we're actually
going to use observables here so fewer
from the RX java we have very similar
our xjs and we're going to go ahead and
map the response that we get into Jason
and then I'm going to get the items
property from that and I want to set
this to the stub repo alright and the
last thing we need to do to make this
service available within our angular
application is we need to provide it
somewhere your do you want to talk a
little bit about what providers are
providers are the definition of food
dependency injector so in dependency
injection you have the injection site
where you say I need HTTP providers tell
you what the definition of HTTP is and
this is set up at the module level of
the application where you say loading
all of these providers all of these
definitions for dependency injector so
we know when the application asked for
each to be what to actually inject with
the construct perfect alright so i'm
back in the map module and what i'm
going to do is I'm and actually
configure the router now with a couple
different routes so the default route
which is just an empty brackets I'm
going to point at a new component we're
about to create called list component
and then we're also going to create a
path that uses a variable so it's
parameterised and will call the
parameter ID like it hit a single quote
and we'll refer this to detail component
and you'll notice that neither these
components actually exist yet so we're
seeing an error but we should be able to
use the your CLI to actually create
those for us so i'm going to do n GG for
generate and I'm going to make a
component called list and then I'm going
to do the exact same thing for component
called detail
so what it's done is it's actually going
to scaffold it out those components so
that as we create them I'll be able to
refer to them to import them
from OC so what happened is I the ided
angular skill I actually updated my
module but it didn't propagate into my
ID for some reason well it there's also
concurrent modifications so let's just
reload this and it should just be there
because I shouldn't have had to type
that at all but I didn't save my pads
should be using webstorm actually the
web storm has really good support for
typescript and on our team we see people
use both Visual Studio code and webstorm
are both of them I excellent but they
have different strengths and weaknesses
so depending on your preference we see
people use either of the two all right
so I finally gotten those routes in
there and I've actually saved the file
this should be ID and then what we're
going to do is we've added a router
outlet which is where were actually
going to render those routes that are
loaded so if we look back on our browser
list works so this is the default that
we're getting from that list component
that is now being loaded via that that
URL parameter via the router so let's go
ahead and jump into our list component
and now we want to render out that list
of github repositories that we're seeing
here so I'm going to add a dependency on
our Rico service and then i'm going to
use dependency injection to get a
reference to it and then i'm going to
once again expose that as a local number
variable
alright and this actually is a list of
repose so I'm just going to do a little
bit of refactoring to make it cleaner
perfect all right so now we should have
a list now that's available to our
template so I'm going to jump into our
template I'm going to actually render
out that list we're going to get rid of
this I'm going to use an MD card and I'm
going to iterate over all of the items
in the list so we're going to say what
repo of repose and then maybe we'll just
to start render out the repo name as you
can see on in angular 2 we still have
this ticular templating use HTML with
extra information that are tell angular
how to create views out of these HTML
templates the HTML is still status the
standard HTML it validates using old
validators that properly implement the
spec on and the thing that we like about
this kind of way of building
applications that it's more inclusive
because you can have mixed teams where
you have designers and developers
working on the same code base and unlike
with other solutions designers really
much more preferred working with with
HTML are in the angular way then and
then when the HTML or CSS is in line in
the JavaScript or tax group alright so
just done two things I've made each of
these cards a link so if you click on
one the URL should change and we should
end up at the detail route and I've also
made the toolbar a link here so i think
the the only remaining thing here is
that we need to render the detail view
so in order to do that what we're gonna
do is we're going to get that parameter
from our detail which actually comes
through as an observable and what's nice
about that is if you change the
parameters on a route we're not actually
recreating the screen that you're
viewing at that time we're actually just
allowing you as a developer to decide
what do I want to do with this new
information
alright and just like before I'm going
to want to use that reactive programming
style and I'm going to actually want to
convert what comes in as a list of
repose and i'm just going to want to get
out the exact repo that matches what I'm
looking for here so we're going to say
this repo equals repose map so this is
going to take in a list of repose and
we're going to want to do is a rental
want to filter that or excuse me find
the item from that list where the item
in the list has a item dot ID that
equals our params and the way we're
going to get the params is we're going
to use a switch map of the the route
parameters that are coming in from the
router so I'm gonna add that as a
dependency here in a second how many
people are familiar with reactive
programming and reactive extensions some
ok so our our xjs or reactive extensions
is a third-party library that we
integrated into angular on which allows
you to write applications in a reactive
style which means that you've read the
applications in a way were on you set up
the application and you let it react to
events that are happening it's similar
to how you set up the application with
chain promises but rather than one time
even propagation through the chain of
promises you have a stream of events
that are coming through these pipelines
that you set up and this is what r XG is
gives us and we integrate the directors
directly into the framework the thing is
really cool all right sort using
dependency injection to get an activated
route which is the current route that
the users tried to get to and then we
should have a method on route or
observable called params dot params
perfect and we're going to switch map
across those and all of this switch map
and map this operator similar to load
ash if people are familiar with lodash
library for a writing functional
programming all these operators are the
same thing but for asynchronous reactive
programming all right
and we failed the imports which maps
somewhere
all right operator what's that that
operator yeah it is thank you about us
once again just learn this this morning
all right so uh so we have this repo
variable which should now be an
observable of repose matching that ID
we're not actually doing it with that
yet so let's go ahead and just make an
MD card and instead of being anything
fancy let's just dump it out as Jason so
I'm gonna say repo a sink because we
want to unroll the observable and I'm
going to print it as Jason observable is
the underlying primitive just like
promise is in JavaScript observe
abilities for reactive extensions all
right so this time when we click on a
route here what's the refreshes we
should jump to the idea and there's the
unrolled Jason exactly as we asked for
so that as our application so we now
have the angular router taking us to
various states in the application we're
pulling in live data from the internet
which is crazy during a live demo we're
using material designed to make it look
not terrible or a little bit less
terrible and then if anyone saw my demo
earlier this morning it's actually
relatively easy to wrap this up into a
mobile application as well for example
you can either do that by a kind of more
pure web where we can add device mode if
we want to just see what it looks like
on a smaller device or I can jump back
out into the demo that I gave a little
bit earlier and as long as the ww
folders pointed at the right place and I
have compiled my code which I need to do
so I'm going to build it for production
so I'm gonna strip out all the comments
and i'm going to use ahead of time
compilation just by adding dash dash aot
and as soon as this is done completing i
should be able to do two things i'm
going to remove the gzip because for
some reason the cordova project does not
like gzip files and then i'm going to go
ahead and Cordova run Android so it's
doing the slowest part is actually the
asset processing so looking at all of
the static files and saying hey is there
any way to make these smaller so that's
a capability of web pack
so this should be done by now let's give
that a try and see what new errors it
throws what could go wrong I'll build
successful that's a good sign install
successful launch successful let's take
a look here at our emulator almost oh I
made one mistake I did not miss you're
supposed to point that out for me I
needed modify the base path because
Cordova doesn't like doesn't assume that
everything's at the root path so let's
go ahead and just rebuild using code
again and then as soon as that's ready
we should be able to run this command we
should see a mobile application next
time can you prepared this the most more
than three hours before the presentation
yeah whew if you want just teasing him
he's awesome yeah we did this live once
where we had the audience call out what
they wanted us to build we don't do that
anymore haha alright one more try here
looks like it's working there's our
anger get up browser nice
cool can we go back to slides okay Thank
You student thank you so that was a demo
um I'm sure you have lots of questions
and you can't wait to start building
angular applications so if you want to
learn more I suggest that you head over
to angular I oh we build a site with
lots of tutorials documentation you can
learn a lot about angular there you can
also find resources to other courses on
one question that I want to address
before we leave is what about my angular
1 application so many people here
probably am maintaining and building ela
one applications we have thousands of
those at Google we don't plan to upgrade
all of them to angular 2 but there are
many that are being upgraded to angular
2 and to make that easier we build ng
upgrade which is a library that helps
you mix and match angular 1 and angular
2 applications and we published a
tutorial or a dev guide on how to do
such a migration we're keeping
continuously updating this documentation
with new insights will learn about
migrations that are happening right now
because most of people started migrating
just in the last few weeks so as we
learn more about things that work that
don't we will be updating this
documentation you can learn more about
that there with that I want to thank you
very much um thanks for having us here
and I hope you'll have fun building
English applications thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>