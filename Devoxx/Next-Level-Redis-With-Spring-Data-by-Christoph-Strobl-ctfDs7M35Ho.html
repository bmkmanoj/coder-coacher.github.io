<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Next Level Redis With Spring Data by Christoph Strobl | Coder Coacher - Coaching Coders</title><meta content="Next Level Redis With Spring Data by Christoph Strobl - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Next Level Redis With Spring Data by Christoph Strobl</b></h2><h5 class="post__date">2017-08-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ctfDs7M35Ho" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay good perfect
alrighty I guess it's about time to
start Oh welcome back after the break
I hope you enjoyed your meals Oh we'll
start with something very light after
after our lunch so basically a
next-level radius with spring especially
spring data and what are we gonna do in
the next 50 minutes we'll have a look at
the basic Redis commands or what right
this is typical ready setups how you can
interact with Redis and how spring and
spring data help you integrate your java
application with the ready store okay
about myself my name is Christophe Cobra
I work for pivotal and there I'm in the
spring data team basically responsible
for these two abstractions for a MongoDB
read is a little bit of solar I do JPA
if I have to not too much of it of
course a little bit of key value and all
that stuff but let's jump right into it
so what is read is actually read this is
the remote directory server and was
invented about seven or eight years ago
by Salvatore Sanfilippo who lives in
Sicily and he backed the time when he
invented it had a need he needed a fast
store key value store namely that he
could interact with over the network and
so he came up with this little C program
and called it radius in short and Redis
its main purposes it serves as a key
value store but they're already time
people used it for many more things
different to just the main key value
store where the key and the value
associated with it but also it serves as
a cache it K this is often used for
queues it use it's used for distributed
locks it's used as a session store I
mean take spring session for it it has
an integration with Redis so you can
store your session data inside of Redis
you can use it for analytics using bit
operation
and all that stuff and uh since 33.2
release it also has our support for geo
indexing and geolocation data in there
and to serve all these use cases ready
has a set of data structures built
within so the the most basic data
structures strings then we got lists we
got hashes we got sets we got sorted set
and the structure called hyper lock lock
which is especially fast and calculating
unique things so imagine you wanna have
a page counter for your web application
that counts by IP address you can use
high pole or log as a fast data
structure to just keep track of unique
page visits per IP address over the day
and time and what I what have you on top
of that Redis offers additional features
like pops up a public subscribe
mechanism it has sort of transactions
but we'll come to that a little later
what mean what it means to have
transactions in Redis and it also allows
you to execute Lua scripts on the server
and menu manipulator there with Lua
script that's basically all about Redis
so for us being on the same page we'll
have just a short look on basic Redis
datatypes the ones we talked about
already and how you can use them
especially the radius commands and what
you can achieve issuing those commands
against the server let's get started so
the most basic and trivial data
structures obviously strings and those
are used for storing especially keys and
values so both of them our inside of
phrase is it's just byte arrays so where
this doesn't really care what you put in
there but for us humans it's likely that
we use human readable strings so we get
a key in the value and we can set the
value of a key using the set command and
of course very trivial we can get the
value back for D key using the cat
command we can also call cats
which basically gives us the value
stored for the key and at the same time
set the value for the key in an atomic
operation at on the server we can use a
set and X which is a set if not exists
or if T value already exists we won't
have it set it will be untouched only if
it didn't exist so we can ask for the
length of a string pretty obvious we can
append something to a string we can
somehow get a range out of it or set a
range which would be some substring
operations basically if you are thinking
in Java and there is a special case in
Redis though the data structures called
strings there is a special meaning to
strings that happen to be numbers those
can be integer or floating-point numbers
because on those you can call operation
operations like increment which would
increment the stuff by one increment by
giving a a non floating number would
increment the value there by this and
increment by float if you want to
increment a floating-point number and of
course you can do it the other way
around by just calling decrease decrease
plant trees by float okay moving on to
EU Reddy's list so given the family
start here because Aria we catch on we
got brown and potentially some others
lists in Redis of course allow
duplicates would be hard in here but of
obviously you could append another area
at the end of the list and yeah you can
push something to the list on the left
side calling out push push and you can
just get it away from the list and
retrieve it calling L pop on the left
side the same applies to the right side
of the list at the end you can write
push and write pop that stuff you can
ask for the number of elements within
the data structure issuing the L line
command and of course you can set
the value at the given position in the
list calling using L set you can
retrieve it obviously you can insert at
the certain position so you see there is
a big similarity between the data
structure we have in Redis and the ones
we have already in in Java because it's
the empty nature of the data structure
you can get a range out of the list by
calling an L range and we can remove
something from the list using positive
and negative offsets that indicate how
many elements to remove from either the
right or the left end of the list we got
set o sets
same as in Java doesn't allow duplicates
so this is much more appropriate for the
lannisters let's say and we can add
something to it set calling a set and
you already recognize a pattern in here
so the Redis commands for lists all
start with L while those for set start
with s I mean the pattern isn't isn't
really going through but it's it's sort
of a pattern okay you can use as pop to
retrieve a random element from the list
you can ask for all elements of the set
sorry
you can ask how many elements are within
the set stored you can ask if a certain
element is a member of this set and of
course you can remove something from the
list in issuing SRAM because poor timing
got unfortunately shot by his son so
he's no longer there sorry for that
though he was a bastard I guess so he
deserved it we got sorted sets in in
Redis are calling C sets and yeah taking
again the lannisters sorting them by
let's say age in as an inverter the time
in Jersey AJ metering and we can add
something to Lily's call me say C set
set at command we can get a range out of
it we can we
worse the arranged we want to get out of
it so the commands get tricky in here so
we got set the rev range and there are
even more commands that allow you to use
lexical ordering those get really tricky
so you could use something like set rev
range by LX what have you so those
commands somehow prolong themselves by
nature I can show you some of them later
on and of course you can order them by
store by score which would be the index
number in there in within these words
it's set and you can reverse that stuff
and you can ask how many are there using
the set card command you can count that
stuff and you can ask for a certain
score which would be the position in the
set set for using the set score command
great and you can increase the score if
you want to and of course remove that
stuff we got hashes here we have
Daenerys and we stored all her
properties let's say as a key values as
a hash inside a hash and so we got the
last name tag Orion she's obviously a
queen and she has a pet or free of them
dragons all free drinks as a pet and we
can set something calling the H set
command which would set a key within the
hash inside we can use the HK command to
get the value pet in fact we can huge
use H M set to set multiple values at
the same time and get them back we can
ask for the number of elements we got
within G hash using the age line command
we can remove something calling H del
and we can get the keys D values and of
course both of them calling H get all
the Gio commands and those have been
added in a three-to-two version so if
you happen to use it oh by the way
anyone using Redis in a year already
not too many too obviously
okay so for those of you who don't use
it which is the majority
already says the geo command since do
you three the two version which allows
you to add which reuses the cset date
structure basically to store a geo
information inside a c set so it reuses
this this c set data structure but has
different commands our twit so that
Redis knows how to calculate all that
stuff so basically this court that we
had before for the C set is calculated
out of the even and odd bits are of the
G use of the Geo position that you put
into it and don't I hope I don't get it
wrong it was the the even bits make of
the longitude and the odd bits are for
the latitude and there has been a torpor
Salvatori how he uses that stuff to
create tiny little squares and all that
and so on to allow gu indexing and
cheering on that stuff I always get a
headache when I watch it but maybe one
of you wants to give it a try it's out
there on YouTube on for I guess it was
last year's Reddy's conference it's
worth watching
definitely ok having that set you
basically can add a geolocation
with the given name and along you to let
it you pairs to the C set using the Geo
add command you can ask for the position
that you added given using the given
name and did you post command you can
calculate the distance between two
already existing points in the indc set
using geo dissed you can ask for the geo
hash representation of that position
within the set using geo hash so it will
give you that nice little view hash
string out of it and of course you can
ask for all the points that are within a
given radius you can ask for all points
that are within a given radius where the
center is one of the already existing
elements within the cset and of course
you can remove stuff from this Issa I
mean in this case King's Landing was
pretty much destroyed so you can use a
said Ram to just remove that stuff said
RAM in this case because we are reusing
the the cset and so what we didn't want
to add and you command which isn't
obviously necessary to do something in
there so it's said Ram which is more or
less a geolocation remove well you can
just have to remember that you know with
spring data we offer you something
that's called G um or delete on all that
stuff so that you don't have to think
about that there is a C said in behind
that stuff and now moving on to
transactions will be the last part of
this Redis introduction transactions in
Reddy's happen to be a little bit tricky
because Redis is as some of you might
know single-threaded
so everything you push to the server is
basically executed in one thread and
that's how all those operations by
nature become atomic because only you
want to request can be handled at the
time and transactions are somehow like
you issue a multi command which puts the
server in the queuing mode then you set
something you go on push all the
commands you want to have and as return
value those aren't executed immediately
but they get queued on server side so
you basically set with a key and a value
and it gets queued and then on the same
connection to the server you call get
with the key which gets also queued and
doesn't return anything immediately and
then you get you the option to either
call X AK which will execute all the
commands or in a row that got cube
before so this and it will give you back
all the result values from the
operations you could cute before so in
this case it would give you okay
for this add command and give you the
value for the key you just set or you
just go on in this cart that stuff and
everything's is fine that nothing
happened
transactions however only work in a
single note environment and cannot be
used in a clustered environment because
they don't work over the borders of a
single server so be aware of that when
using transactions and potentially want
to I and when you potentially want to
upgrade to a clustered environment so
those won't work they're just keeping in
mind this brings us to the more or less
typical already setups
so when you get started to read this
what you do is you basically go to you
read this website download that stuff or
hopefully you're on a linux environment
so because just have to come to make it
on your built that stuff on your own
machine and then you spin up a server
standalone server let's see how that
looks there's something I want to show
you
additionally because when you go to the
you read this website there is besides
the download and all that stuff you can
have a look at the command and you get
the list of commands down here and
what's really unique for the for a Redis
is that it gives you the runtime
behavior in here for each and every
command so you get the time complexity
all what log n in this case for the Geo
position command and this is something
I'm not really used to a familiar with
from other other data stores but that's
really unique for Eddy's and many of
those operations have Oh from one which
is pretty fast so Salvatori really cares
about performance and that that thing is
is really fast and that's probably one
of the reasons why it's so so popular ok
I've already downloaded that stuff onto
my machine and I've already built it and
once we get started with a single server
there we just go to the register rectory
and there is something called ready
server and I started the server and it's
on port six three seven nine and it has
a pit and all the stuff it's running
there is nothing in there I have
already started et it comes to you ready
CLI let me just stop that one thank you
there is also the command line to
command line interface ready CLI you can
start it up it will by default connect
to the local host and report and then
you can just go on and play around with
Redis by calling let's see set key one
is worst third key to is okay then you
can ask for the keys how many keys do we
have okay we have two keys in here and
those are key to and key one and of
course we can get key one and get two
obviously and we can use can get
multiple keys at once and get multiple
get oops and get k1 k2 and we get the in
the order that we requested the keys we
will get back all the values so it's
pretty easy I'd say to get sorry before
a distinct command so trivial those are
well documented what they do and you
just go go ahead and play around with
Redis oh no big deal in there okay but
the the thing with a single node is
always what happens to your to your
application if that node dies hmm well
in the worst case your application will
be dead for some time until someone goes
there and restarts the server and
hopefully you got all that stuff
persisted to disk so that all the data
is reloaded not the thing you
potentially want to have so what you
potentially want to have is something a
high availability cluster and all that
stuff so you just start adding at first
additional servers slaves to your master
server that hold copies of the original
data so that you can faster failover to
that stuff and the failover want in this
case won't not happen automatically so
again there
be a human needed or at least a script
needed and watches that stuff and
notifies everyone that this were just
died and someone has to promote the one
of these slaves to master and all that
stuff so it's really a pain and
therefore for a couple of years ago
Sentinel was introduced so Sentinel is
basically a ready server that behaves a
little bit different so it watches all
your master slave configuration with a
heartbeat and then checks if the master
goes down and then there is a master
election going on and the clients get
notified automatically that the master
is down and that the new master has been
elected and that this particular server
let's say the the upper one there is now
the new master so your application might
fail but it won't be too long depending
on the configuration you have and that
sentinel provides for how long it takes
through to promote a new master and yes
so this is a much more convenient and
you got all the all your key space
basically are still on one server and
it's not not distributed so it's not
spread around a clustering in that case
so it's pretty easy to interact with
them okay since raid is three we got
something called Redis cluster so run
Redis cluster is different from this
high availability scenario that we just
talked about with these sentinels
because in Redis cluster there is no
such thing as a sentinel but there are
there are master servers in their slaves
and the whole cluster constantly talks
to each other so that the all nodes are
at the time know which nodes are a
master nodes which are slaves which
nodes are no longer available and the
cluster does this a mastery election on
its own however a cluster has an
additional feature and this is automatic
sharding so as we saw before with the
sentinel there is only
one master in slaves and all the daters
on one of those servers at the time in
Redis custard data is charge it and it's
shard in a way so that the cluster has
16384 slots so swatches a slot is a
logical partition of the cluster each
slot can have as many keys as you want
in there but all slots have to be
covered by the cluster at all time if
one of these slots isn't covered by the
cluster because all master nodes and
slaves that serve a put a specific slot
range are down then your whole cluster
is dead until all slots are reserved
again and the server's are restarted so
please keep that in mind okay let's have
a look at Redis cluster and how it feels
to work with the Redis cluster we got a
really nice tool since the 302 version
which is a trait cluster tool before
that you had to set up the cluster
manually or assigning all slots manually
or using potentially some Ruby script
this has gotten much easier in d3 the
two version so we just can use the
utility that comes already with the
Redis distribution called create cluster
and we just start a cluster in here okay
so we're starting three nodes
Ringmaster's and a slave to each master
we used to read ECL I using the - C flag
for okay
let's move to cluster mode and we'll
give it the port for the initial node to
connect with so with the - P command so
we're connecting to basically the first
node in the cluster okay now that we
just started the cluster we can call
cluster nodes okay to see oh how many
nodes do we have in the cluster at this
moment and there is only one node
currently so the nodes are still not
connected to each other so these are our
three independent our six independent
Redis instances
at the moment so we have to create a
custom configuration and this is the
step that you had to do manually before
what that you might have to to do
manually if you're managing a larger
cluster than the one I have here okay so
we can use cluster create to create a
cluster and this basically assigns the
master node with master and assigns all
these slots in there so you see this one
covers how many slots it covers and this
this lot range that is covered by each
master then we got these slaves that are
for those and we have to accept that
stuff so we type yes in there now we
sent a class to meet commands and all
that stuff and designed these slots and
once it's done it hopefully says all the
slots are recovered and now when we go
back and ask the register again if it to
tell us how the cluster looked like with
the cluster node command well there you
go
it basically tells us okay there are
there is no there is a master node that
serves the slot range there is a slave
for that master and so on and so forth
so you see all that stuff is it's there
and now we can go on and can again add
stuff to the register by calling set key
one boxed okay that worked pretty fine
so set key to Vienna oops
now you see something that I talked
before this is the automatic sharding so
what do you see here is basically when
we tried to set the key to to Vienna
Reddy's told us that the slot the key to
maps to isn't covered by the server we
sent a request to so we got redirected
to another server that serves this exact
slot range and we now have a look at the
slot last key slot for key to you see
this is twelve thousand four hundred
twenty two and that should be covered by
yes over three in here because it's in
in that range
okay pretty nice so far and then we can
go on and get the key back that works
pretty nicely we can get D to pack get
redirected again because it's it isn't
served by the servitude recently request
to ant and we can call em get key one
key to and boom that didn't work as it
did in the single note environment and
as it would have worked in a ready
Sentinel environment and this is because
Redis doesn't allow cross slot requests
within the cluster so if you want to
retrieve multiple keys or there are
other operations that involve more than
one key you have to make sure that all
those keys that you have within a single
command map to the very same slot not
the same machine physically but really
to the same slot on the server otherwise
Redis will give you an error so what you
could basically do is you could pin a
key to a certain slot by doing let's say
set and then you use Kali branches
brackets key one and bar so you put it
inside those curly brackets and what
Redis does it basically looks for the
innermost curly brackets takes the value
in there and calculates the dislodge
from the value in there so it in this
case it would just be key one and yeah I
get redirected and could call em get key
one and this again k1 and that worked
because it's the same slot nice okay
let's move on and see what happens if we
let's say call the use D keys command
because you already know in the using
keys in a single node environment just
gives you a list of all the keys in the
cluster environment it will just give
you all the keys from the server that
talking to not necessarily all the keys
within your cluster so if you want to
know all the keys that you have you will
have to go to each and every node and
ask it for your keys it has so much for
that just keep that in mind okay that's
some of the issues you will face when
using Redis cluster but still is it's
pretty fast and once you know about the
limitations it's really easy to work
with and of course we are in we in the
spring team and especially in spring
data team try to make data access for
you as easy as possible and as
convenient as possible so there a spring
that already this will help you deal
with the special cases that might appear
in the Redis cluster environment so
let's start off with a few spring data
Redis basics what we have is a template
for those of you familiar with spring
will know the the templating stuff that
we have in there for JDBC template and
all that stuff so it's basically the
template does the resource management
and exception translation into Springs
exception hierarchy the template works
with a connection factory because in the
Java world we have a different set of
ready strivers so there is no official
Redis driver out there but there is a
bunch of community projects and so we
have this abstraction of a connection
factory that gives you a Redis a
connection to a single node server to a
sentinel environment or to a cluster
using a custom connection and we got
several serialize for that stuff because
as you know Redis doesn't really care
about what the data looks like that you
put in there so you can basically
serialize your stuff using a jetty case
you realize the strings you realize or
some Jackson and below the connection we
got all the rest drivers the ones we are
going to support in the future are
jetties and lettuce there are two more
drivers but will drop support with the
next release for those two because
they are maintained for years now and
it's gotten a pain to work around all
the limitations those drivers have so
lettuce and Jerry's are the drivers we
were going forward with okay so let's
have a short look at house bring data
Redis words in a clustered environment
when you got something here so this is
just a normal spring boot test
application we connect to the cluster
that we just set up use on the port we
set up the connection factory so we get
the connection photo effect we ought
wire queue we retrieve a cluster
connection from the connection factory
and just in setup we just remove
everything so that we have a fresh
installation and then we go on and use
the keys command and what we expect to
do is we expect uh the implementation to
take care that we get really get all the
keys from our cluster so what what
happens behind the scenes is basically
we detect that this is a command that
has to be executed from all nodes within
the cluster at least on all master nodes
we go there asynchronously talk to each
and every master execute to command
their aggregate the results and once
finished we return it to you okay let's
let me just run this rendered stuff in
here to prove that it works so it
connects the cluster splits up and
collects the results and everything is
there so we get the keys that are
distributed on two nodes are within the
same collection of course you can read
all keys from a single node so what you
would do in this case is you would
basically go here go here and tell the
connection that you want the key is from
a specific node this is different to the
Java drivers that are out on the
internet there because they normally
only talked one server and we just took
the opposite approach so if you we
basically talk to all servers and if you
want to talk to a specific one you name
the one you want to talk to you
at the moment because in the other
scenario it might be depending on the
last command that you executed a random
server that
you potentially don't know about well
not that stuff we want to have okay so
you can read all keys from a new cluster
node which I shouldn't have switched to
intelligently Utley now I mix up all
these shortcuts okay and of course we
support executing those cross lock
commands where is that the key one key
to and we expect them if you issue and a
multiple gate command that we don't get
an error or something like that
but we just get yes nope
damn you this one we expect them to be a
returned in the correct order that we
issued the stuff because as we go
they're asynchronously it might happen
that the results come in in in different
orange you reorder that stuff and so
that we keep in sync with the contract
you read this documentation has for you
out there okay
I got to hurry up a little bit all to
finish in time so that's more or less
the basics for already connections with
spring and the cluster handling I want
to talk about a little bit more advanced
topics now something called the object
hash mapping this isn't really new there
there have been projects in Ruby around
four years by now but we just recently
picked those up and use those for later
on implementing spring data repositories
which you might already know from
MongoDB and JP and all that stuff on top
of Freddy's but we need object hash
mapping for that because normally we
live in a in a rather complex world are
not only having keys and values but
having let's say a person object as a
first name last name a complex address
within there and when you want to store
that stuff inside of Redis or one
approach you might want to choose is
just flatten it out make it a chaise and
throw it in to write this as a string so
you call set give it a key and then just
put in there DD JSON string well it
approach works pretty nice works fast
you just have to go through the overhead
of JSON serialization but that's
too much I'm pretty efficient by now but
the the thing is all you can now do with
that JSON string is basically you can
get it back and put it into serial as a
back and deserialize it again I wouldn't
recommend trying to alter the string
that you've just put into Redis for an
update or so but just go through the
whole serialization process again and
then update devalue India another
approach would be the object hash
mapping which basically goes here and
flattens out all the properties that you
have in your domain models so that they
fish fit into a hash into where this
hash so what you would have then is
basically you would have the ID D first
name and for complex objects you would
then just by point separate the
properties so you would have address
country and then in order for to
indicate that this is a a complex object
or a complex nested path and you use the
domain metamodel to just map it back on
the visualization the thing that you now
get with that is you can just retrieve
everything H get all just the same as
with the get command but you could also
just use H get the ID and last name this
should be a gem get but no don't worry
about it which would be something like a
projection so you just take out a few
elements that you want to have depending
on your need of data you could ask if
there exists a property within the hash
if that matters to you and of course you
can do something like a partial update
by just setting a certain key in the
hash let's say the last name is then no
longer origins no but John Doak you had
a typo in there or whatever so you have
partial updates and don't have to
serialize these you realize oh the
entire object over and over again okay
and for spring data we offer something
called a an object hash mapper which
takes the spring data domain model so
it's inspect your domain types and
caches
that stuff and inspect your domain type
or finds out about all the properties
and those types and then just does all
the hashmap pain for you all you need is
a an object hash mapper within your
configuration or doesn't take any
special arguments and then you just go
on creating an address let's see it's
Winterfell Indian orphan the person is
chance know with a boy obviously he hey
who lives in Winterfell not for long but
at least for some time and then you just
go on and create hash and then you just
set the hash and then you can retrieve
it back also so basically you read all
the values there put it in the hash map
ER and get the person from that you know
okay this one no damn you so that
obviously works and if we now look how
did it turn is so we could call keys I
guess yes there is this one
Oh give it the key so this is how the
representation within red this would
look like there please notice there is
this almost go class attribute that we
render in there this is basically more
or less the same the checks and does
it's just an indicator to know the route
type so you can map the stuff back
because you could put in there could
give the the map or just an interface or
something like that and we need to store
the exact class to just read it back
nice that worked so far so let's talk a
little bit about secondary indexes
because in some cases you finding
entities by by their key unique he might
not be enough so think about a session
store where you potentially have a user
associated with multiple sessions within
different application and you've got the
single sign-on or what have you and so
you and the key would be the email
you want to retrieve all these sessions
for for this particular email then you
might end up with secondary indexes
because those data structures help you
to identify data not only why I add
their primary key so to speak so let's
take the example from before and what we
now do is we use a set to create those
indexes so we would have a set of with
the key first named John which would
take all persons the dara'a first name
is John and we put in the ID of the
entity which is saved which would look
something like this so we put in one two
three into the first set now we would
index the last name just the same way
all people under the names know and what
we now can do is we can use the S inter
command set intersect of those two sets
and would retrieve the ideas of all
people who renamed our John's know
obviously and then we could use just H
get all to retrieve that stuff or we can
use s Union to or create all people to
create an or query so all people that
are John or snow what have you so that's
pretty so it's pretty easy to just
determine entities and their in their
IDs and we're spring to the Redis oh we
support that by using the Redis
repositories so we got a crowd
repository and we can just add an
annotation down there so we just add
index to first name and at index to last
name you can set this up
programmatically Padron for four slides
it's better if you have those
annotations so this will basically tell
this bring that array this
implementation to create an index for
those properties who also works on
nested properties so you could put
something into address and address city
and it would get indexed as well but for
here we just call a repository safe give
it the John Snow and what it does just
uses the object hash map route that we
have in place to create the hash
and it detects the indexed our
annotations and the values tenants at
subsidy sets for you for you it also can
handle something called partial update
so you can call a repository update and
give it a a partial update that sets the
first name because you had type win
there and what this does it detects that
there is an index on that first name so
it will set not also alt it would first
set the value within the hash that you
have and it would then go on and remove
the old value from the already indexed
stuff and add it to a new index or an
existing one depending on if there's
already someone with if there's already
in the next year so that happens behind
the scenes so it will detect indexes it
will detect the values that you already
stored you will remove them and take
care of all the index updates for you of
course this takes a little bit of time
so think about it when you use it think
about the number of properties you want
to index and because every index
operation just grows the metamodel and
te teko path you have to run through for
for every operation you do and of course
you can then have derived queries on
properties that you have indexed so
spring data registry posit Ares allow
you to just types declare a method in
the interface by find by first name and
last name which doesn't require you to
have an implementation so we'll derive
the D query for you and once you then
call repo find by first name and last
name it will create the s inter command
for the indexes with the values and then
just get all the IDS from the repository
and later on fetch the fetch D values
using the H get all command ok we got a
few more minutes so I'll just quickly
show you how that works so this is the
repositories this isn't just a spring
built application we enable you read
these repositories we
the personal repository in here should
be declared on there this is the
personal repository we got you defined
by first name and last name method we
got the historic family again which is
then just set up by Adi flash test users
so we got find by multiple properties
using ant so we just execute the find by
first name and last name so we just
search in Arya Stark yay I remember the
key is the shortcut yes okay that worked
obviously nice we can use the same stuff
for worse we can find by last name first
name or last name should work as well
yes okay so since we only got five
minutes left I just wanted to point out
something that you might not be aware of
already supports something called key
space events since the three-door
version so what we have in sprinted
there is basically we allow you to
listen to those key spins events and get
notified when ever a key expires and you
could have something in your domain
model that is called a time to live you
annotate the property and this will tell
ready to just expire or that entity
after some time this is useful
especially for sessions let's say you
you have a session that may only last
thirty minutes we set the a tea tea tea
tea times live to 30 minutes and the
entry will be gone after after some time
now if you have the key space and events
enabled your application will get
notified via and spring application
event that this particular session just
expired and it will give you a shadow
copy of the object that expired
the trick is Redis tells you that the
key has expired after it already deleted
the key so the data is already gone when
you received event
but if you have a time to live defiant
will to keep track of it create a shadow
copy for you if you have the key space
events enable keep all the modifications
for you and in sync and then return you
the Shadow Copy so that you know which
way is exactly expired and not just the
key because who knows what this key
might have been before okay to give you
a little outlook on what to expect for
later versions of the project okay there
just right before there is some more
stuff you can do you can add references
so that you don't have to copy all the
values if you got nested elements and
all that stuff you can add custom
versions conversions for types so let's
say you want to convert the address into
a JSON object if it's nested in your
domain model you can do the just
register custom coercion using a
Chasen's you realize and all that stuff
will happen for you you can have spell
based indexing if you want you and now
let's move on to what's next next will
be GU indexes so that you have spring
data repositories that you can have a
geo index set up on a point which would
allow you then to just have let's say
derive find or find by address location
near you give it a point in the distance
and it will execute the geo radius
command for you given the distance and
what have you and just return you all of
the results and more interesting we're
busy working on spring data to the door
release arm we have a first milestone
out there and our focus is on not only
the upgrade the Java baseline upgrade to
Java 8 but also the integration for the
reactive programming model in there and
so what we'll have is we will have
reactive commands or in Redis for
MongoDB as well and for Cassandra in the
first place and we will make use of
project reactor which is something like
yeah Rx job on steroids let's call it
that way
and what you see in here is basically
the return types who would have flax and
mono as return types where monel would
be something like an Rx Java 2 maybe and
a flux would be something like an
observable if you want to so a flux can
give you more elements and the model
might be zero or one element and this is
how the API will will potentially look
like you'll see more in milestone 2 of
that stuff if you want to give milestone
one already a try don't care about
spring data read is in January but take
MongoDB if you're more familiar with
that just give the reactive approach
with new spring data projects a try and
and I would really encourage you to give
us B feedback on what you think about it
how it is to use so that we can
incorporate that stuff before we go GA
which will happen later this year a
second milestone will hopefully be out
by May which will include the Java 8
baseline upgrade so far I guess I
finished just in time so thanks for
coming
enjoy the rest of the conference if you
got questions I'll be around for an hour
or so just come by and yeah have a nice
day thanks for listening</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>