<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Migrating to Modules by Mark Reinhold | Coder Coacher - Coaching Coders</title><meta content="Migrating to Modules by Mark Reinhold - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Migrating to Modules by Mark Reinhold</b></h2><h5 class="post__date">2017-11-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/g5OM1skiuew" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning and welcome to migrating to
modules so this is when at one of
several talks here this week modularity
is is a deep and complex topic the
module system is on the surface designed
to be approachable but there are lots of
subtleties
so just to calibrate how many people saw
Alex Buckley's talk yesterday ok good
maybe half how many people saw my talk
yesterday ok more it more than half ok
that's that that's a good foundation but
still they so this again is like my talk
yesterday is gonna be almost entirely
live coding I might make some mistakes
if you see me make a mistake and you
know you know how to fix it just shut it
shout it out also if you have a question
of clarification feel free to shout that
out as I go but I might I might defer an
answer till later so here we are again
with a a few days old build of of JDK 10
9 10 just because life life on the
bleeding edges is so much fun what are
we gonna do here so this is the this the
theme here is migrating to modules we're
gonna look at a little application an
application love me somewhat more
sophisticated than the hello world that
I would that I was playing with
yesterday look at this little app
application we're gonna convert it into
a module now this application uses some
popular libraries that have not yet been
converted to modules so we'll see how we
can still modularize our application
even though those libraries have not yet
been modularized and then we'll do the
reverse thing if you remember alex is
sandwich diagram from yesterday but it
will do the reverse thing we'll go back
to the application just being a regular
old old jar file we'll pretend that
we're the maintainer of the libraries
that we used in the first part and we'll
modularize those then we'll see how we
can have modular libraries and at
modular application and then finally at
the end we'll have just a beautiful
model ultra graphical everything will be
modules the classpath will be empty and
and life will be good so that's the
general the general plan here ok so to
get started let's let's look at the the
little problem we're gonna solve I have
so I have here a file JSON file data
format of the century of tweets so bunch
of tweets off my timeline from Twitter a
year or two ago you know it's it's well
you I guess you can read it if you
really want to but it's it's kind of
difficult so we're gonna write a trivial
little app to format these tweets in a
nicer manner actually we're not gonna
write it I already did write it so up
what have we got here's my source tree a
little application called tweets um it's
got a main class and a tweet class let's
take a look tweets um main ok it's in a
package it uses lists it uses the
jackson json data data binding the
library so it's gonna deserialize that
jason using jackson do an object mapper
thing it's got a public static void
method it makes an object mapper
configures it reads reads from reads
from the standard inputs input stream
construct some tweets and then displays
them nicely and it uses this tweet class
nearby which is just a very simple POJO
object we can look at that too here's
the tweet class it also also uses a
couple of jackson annotations to
identify the fields it stores the time
of the tweet in a sequel timestamp just
for amusement and it's pretty obvious so
it's got a text field which is the text
of the tweet it's got a type the
timestamp and and the annotations to
tell Jackson no please please convert
this using the following format into a
sequel timestamp so that's all pretty
straightforward let's just make sure
that this this all works will just
compile
package this as a normal normal little
application so let me compile this in
the old-fashioned way glasses let's see
I need I've got my lib directory here
you're here at the Jackson jar files is
actually a little a slightly old version
of Jackson but that's okay it still
works in obtains or data behind all
right I've got classes pretty much what
you would expect so I'll create a jar
file
all right so now I'm ready to go drop a
class path the class path is so tedious
I'm gonna cheat and use class path wild
cards how many people know about class
path wild cards obscure feature
introduced in Java 6 but really handy
for stuff like this so class path wild
cards they just they're just gonna be
just gonna pull and put all of this jar
files directly on the class path because
that's the way the class path works
tweet some dot main and let's read JSON
file boom
nicely formatted tweets ok slightly
marginally more interesting than hello
hello world so we've got tweets um let's
convert that into a module there's our
source tree again to make this into a
module we need a module Declaration and
module declarations go in files called
by convention module - info Java and
that's going to go in the root of the
tree right here right right under right
right in the in the directory
corresponding to the module name so we
pop up here module info table Java and
we'll use the recommended reverse DNS
Convention same as for package names and
in fact the one package in this module
is the same as it has the same name as
the module itself that's fine so what
are the two fundamental things about a
module what does it export and what does
it require right so what does this
module export nothing very good it's an
application doesn't need to export
anything a a module is a set of packages
designed for reuse footnote or a set of
packages that's an application and it's
designed for reuse but not as something
that you can require so we don't need to
export anything what does it require
well we know that it's using those jacks
and you know it's using the jackson api
to to deserialize the json into into the
tweet dojo instances so we could write
requires
if I can spell requires but but but but
what because those jacks and all we have
are Jackson jar files
they're just jar files they're actually
jar files that are a couple years old
there are not modules what do we do here
well we could just give up and say oh
now this might have this module systems
the system stuff is too hard but
actually there's an and that well if
there's another thing we could do is we
could go and pack the Jackson jar files
and and and force in our own module
infos but that's not really a good
recipe for a maintainable system taking
other people's jar files and editing
them and making your own that almost
always leads to tears so so we won't do
that what we will do is we will use a
feature of the module system called
automatic modules Alex mentioned these
yesterday automatic modules are a way of
treating a regular old jar file without
changing without - without changing it
at all if you're a regular old jar file
as long as it's reasonably clean and
consistent you can just treat that as a
module instead of leaving it in a Lib
directory and put it on the class path
you can put it on the module path that
puts the both compile-time and run-time
the module system will see it there and
as long as the odd of the the the jar
files you're using is automatic module
don't have conflicting packages there's
there no split packages amongst them
then the module system will treat them
as modules it will in effect synthesize
module declarations for them at
compile-time and run-time it will make
sure that they they essentially all
require each other by default because
that's the only thing that makes sense
and this allows you to migrate your own
code before your dependencies have
migrated so what will what will these
things you know a question here as well
what you've got a jar file it's it it
does it itself is not a module you put
it on the module path what is its name
gonna be and that's what I need to know
to type something here if I look in the
Lib directory well all I see are you
know artifact ID slash you
- version number jar so the answer is
and this is a heuristic but it but it
tends it turns out it and work it works
fairly fairly well is the name of an
automatic module is taken from the name
of the jar file take the name of the jar
file lop up the lop off the version of
the version part if there is one convert
remaining punctuation two dots you drop
drop the jar jar for suffix on the end
and a couple of other little
aristocratic and so in fact what we have
are three modules called Jackson
annotations and Jackson dot data bind
and jackson dot core so I can go back in
here and actually type this
okay so I'm gonna use the e I'm gonna
use these existing jar files as
automatic modules there's another way to
figure out what modules an existing jar
file application might need and that's
with the Jade EPS tool how many people
know about Jade EPS we actually shipped
and shipped an early version of it in
JDK 8 so they could you could use it
earlier there's a much improved version
of it in nine you can run jaidev's
with the - s option and it will tell you
it will do static basically it does
static analysis on the byte codes and
figures out what modules might be needed
I should tell it here about the
automatic module so it's all good I'll
give J depa create up some module path
no sorry no I need to do this class pass
still there we go right so we see we see
that that tweet some jar file it needs
those the three jacks and annotations
jar jar files it needs Java base because
every module needs Java base whether it
wants to or not oh and it needs Java C
claw remember I used that Java a sequel
timestamp class for the timestamp so I'm
also going to need to write requires
drop a sequel in my module declaration
alright now I should be good to go I'm
not missing anything
Oh little side note another another cool
thing Jade EPS can do is check for uses
of JDK internals a internal API and
since this what this doesn't use any JDK
internal api's but if it did
Jade EPS with lit would list what they
are and in many cases it will offer a
suggestion of what standard API to use
to replace it because you way there are
there many uses of internal API is out
in the world where standard api's have
been available for a decade or more
anyway end of side note ok so we've got
our module declaration let's compile
everything here I'll just remove that so
Java C so Java C has gotten fairly
sophisticated it understands the
structure of a modular source tree it
can generate and exploded classes
directory that has an additional level
of directories for modules and that's
what this mods directory is going to be
it also understands the stands module
source path so Java C dash d mods we
need to tell it where those automatic
modules are they're here module source
path
source and we just tell it what module
we want it to come to compiled and it
will go it will go into the modules it
will go into the source directory find
the directory named org tweets um and
compile everything under that we don't
have to do the tedious old thing of oh
yeah go find every Java file because
that's just tedious alright
and there's my my modular output
directory
I've got module emphatic class the
compiled form of the module declaration
I can run Java P on it like with any
other class file and it will essentially
disassemble it and tell me what's inside
I can now create a jar file in the usual
manner I'll tell it what the main class
is to save some typing weight around
- please okay there we've got that and I
can see what's inside there's my modular
jar file with the module info inside it
so not only is Java C got sophisticated
but the Java launcher has gotten
sophisticated I can run this now well
actually first let's let's take a look
there's there there's some more options
on the Java launcher that will that can
let you inspect what's inside a module
that it it can find on the module path
so let's describe that module and here's
output in a you know easy easily grep
bubble form if that's what you need to
need to do here's the word tweet some
module here's what it requires here's
what it contains and of course it
doesn't it doesn't export anything okay
so we should now be ready to run this
right we've got our order our file we've
got our old Jackson jar files we're
gonna use those automatic modules
they're there in the Lib directory so I
should be able to just run the Java
launcher tell it to run to tweet some
module and give it the tweet SOT Jason
file as input right it's gonna work
loaded question I know all right oh it's
not alright what happened
what happened was let's see exception
and thread main java.lang reflect
inaccessible object exception unable to
make or tweet some tweet accessible does
not open work tweet some to module
Jackson dot data bind what is going on
here well remember we concluded that
that the tweets of module doesn't need
to export anything because well it's not
providing an API to anything but the
Jackson data binding library is it's one
of these reflective rant frameworks that
uses reflection to go manipulate pojos
instantiate them and fill in their
fields using the reflection api but
since we have strong encapsulation of
one of the main features of the module
system that strongly capsulation is
getting in the way and the Jackson data
bind library it's it's attempt to use
reflection to set up instances instances
of the tweet class is just not working
so what can we do well all right let's
try exporting even though it's not yeah
it's not an application this isn't an
API but I will export it in that in that
and that should make it accessible to
the Jackson data binding library so
let's compile this again
read your it up and try to run it no try
to run it that still didn't work why
didn't it work well it didn't work
because I didn't read the error message
closely enough we've we've tried to put
a lot lots of hints and advice in in
these in these error messages so when
you export a package then a compile-time
and run-time the public members of that
package are are available for use the
Jackson data binding library is trying
to use reflection to get at non-public
members of the public tweet class and if
you just export an API you can't do that
and that's a good thing because that
because that means when you have a
module that exports an API you can you
can defend the modules internals against
against abuse by code outside of the
module whether that abuse is accidental
or malevolent so as the message suggests
here there is another way to do this
there's there's an alternative to
exports called opens it's a little bit
like exports but it's but it's actually
fairly different and go back here and
say that or tweets um opens the org
tweet some package what that means is
the public types in the tweet in the in
the work tweet some package are not
accessible at compile time so there's no
API here you can't compile against it
they are accessible at runtime for use
by refill reflective frameworks and not
only are they accessible at runtime but
if a reflective framework wants to
really get get down and dirty in and
access private fields it can use
java.lang reflect accessible object set
accessible about the magic set
accessible method to dig into those as
it always could in the past so basically
if you're if you're writing a module
that you know is going to be manipulated
by some reflective framework
you need to open the packages that
contain clot the the classes that the
framework will manipulate if you you
know if you want if you have a module
with a lot of such package you can
actually right then open every package
in the module by writing open at the top
but we'll just stick with this for now
all right
let's recompile that let's reach our it
and finally
we should be able to run it there we go
okay so here we have a mod modular
application an application in a single
module it's using the Jackson jar files
as automatic modules and the system is
working as intended there is if there is
nothing there's nothing left on the
classpath right now okay we can take it
wait let's make a little Jerry to take a
take a bit of a closer look here and
I'll just use a macro I'd left left
around so here's a little Jerry it only
has the modules that we need and I can
now run using this and that should work
okay good
I can also use it there very various
other diagnostic options for example
show module resolution will show you the
activity of the module systems
resolution algorithm as it figures out
what it needs to do so we start at the
top the the route module them at the
module I gave the majalaya I identified
with the - an option I told the launcher
please run right please run starting
with this module so that's the route
module it saw that that auric tweets um
requires Java sequel and then Jackson
data bind and Jackson annotations in
Jackson core it tells you hopefully
where at those jar files are in case you
need to need to find them it also found
for me Java sequel requires XML and XML
and sequel requires logging and so forth
and there's some other stuff going on
here so it's a very useful tool to
diagnose exactly what's going on at
system startup so you can figure out
maybe you know if some auto got loaded
you don't know why you can read this
output and figure out what's happening
all right so that's the automatic
modules automatic modules are there good
for modular modularizing applications
and code that that you own and
maintained I strongly recommend that you
do not make use of automatic modules in
a library that you publish it would it
would be a bad idea if you maintain a if
you maintain a library and you put and
you publish on maven central and it says
requires jackson dot annotations that's
not the best plan the reason that's not
the best plan as well the maintainer zuv
Jackson they might decide they will
actually hopefully decide to use proper
reverse DNS module names and it'll be up
to them to figure out what those are so
please don't publish a jar file that
that presumes to give someone else's
module a permanent name they're active
there actually is a way as a as a little
baby step towards mom towards modular
ization if you maintain a library you
don't want them to do the full
modularization just yet but you want to
stake a claim for what you think the
module name is going to be we actually
defined a new jar file manifest entry
called automatic dash module - names you
can put that in your manifest and then
if your jar file is used as an automatic
module that is what the name will be
rather than than a name synthesized for
the jar file so if you want to claim
claim a name for a published library
module today you can do that with a very
simple change and then worry about
writing your module info later on okay
so let's let's rewind here I'm gonna
clean things up and I'm going to push a
patch here
and now we're in we're not in a slightly
different environment we're gonna get it
going to do now is modularize the
jackson source code maybe I'm putting on
a hat pretending I'm an honorary
maintainer of Jackson and we'll look at
the source code and make some module
infos and convert those into proper
modules and we'll do this while treating
or tweet some again just as a plain old
plain old jar file so I'll need to
remove that
I'll recompile that I'm going to use
this little JJ command to save some time
okay no module info it's just it's just
a just a plain old jar file okay so
let's let's modular eyes Jackson we've
got the Jackson sources here I can run j
dep so i'm on the library forms right to
see what what they might need and that
works well enough for figuring out
requires but it doesn't tell me what
those jar fight with it with those jar
files as converted to modules need to
export now if i actually you know we're
at jackson maintainer i might just know
but i think it pretend i'm i'm a newbie
jackson maintainer I just came onto the
team and Here I am trying to trying to
figure things out so another thing I
could do is I could look at the
directory structure of of each one in
that because he got that gives me some
information about the packages but
actually another thing that Jade EPS can
do Jade Epps's is sort of the Swiss Army
knife of of tools of tools for analyzing
class files with respect to modularity I
can ask Jade EPS to generate a module
info Java file for me so Jade apps
generate module info it will put it
we'll put that into the end of the
source tree and I want it to generate a
module info for this jar file right
there and it goes off and does that now
if you if you use this option of Jade
EPS it's important to treat its output
as a draft right Jade depths can only do
so much
there are many things that it is
incapable of comprehending being a very
fairly simple
static analysis tool
so here's what Jade Epps produced it
found every package and just decided
okay yeah we're gonna we're gonna export
every package don't know any better and
it also figured out something about a
service that Jackson the Jackson core
module provides now services what what
services what's that all about another
big feature of the module system is it
actually understands it understands
services if you remember the service
loader API introduced way back in Java 6
that's been enhanced and integrated with
the module system so not only kind of
module require another module and export
packages for use by modules that require
it but a module can provide services and
it can it can use services that may be
provided by other model services are
very powerful indirect mechanism and if
you ever find yourself in a situation
where where you think you might need to
have two modules and each one depending
on the other the answer is the answer to
that problem is probably for one of them
to be providing a service and the other
one to be using that other module as a
service but end of digression I don't
have time to get into services in detail
today but anyway just did so we see that
the court the Jackson core module it
provides the service and Jade EPS
figured that out because Jackson core
actually has
this meta and services entry for Jason
factory alright nothing about that okay
so I can now compile
the modular modularized jackson core
takes a little longer because there
there's some real code in there and I'm
putting these new ones in a different
directory called M Lib okay so that's
done I need to do an equivalent thing
for annotations and data bind so let me
do that I'll just do all of these at
once okay okay it tells me it's written
those those three module infos let me
check them out data bind module I forgot
Java here it's exporting everything
remember this is a draft should it
export every one of these well probably
not in fact packages that can contain
the token in pull mmm those are probably
in journals let's not export those and
there might be other things that
shouldn't be exported that won't go into
that here okay Jackson annotations
that's very simple it only contains one
package and they're just annotations so
of course we want to export those
alright
okay let's compile these
some input files over user override a
deprecated API Oh
we just have so many things to fix but
we're not gonna fix that one today okay
so now we've got our modularized jackson
modules we've got our old tweets um jar
file we should now be able to run this
so java module path and Lib class path
liborg tweets um jar and we should now
just be able to say org tweets um main
tweets are jason unable to initialize
name class or tweets um name what
happened here well what's going on now
is I've got some code on the class path
and I've got some modules in the module
path but the launcher and the compiler
would have the same problem there's no
way for the module system to tell well
what on the what modules might the code
on the class path need so I actually
have to tell the module system myself
and I do that with another option called
add modules
so I do this and now it works okay so
now we've got kind of the inverse of
part one the tweet some application is
just in a jar file sitting on the
classpath the Jackson libraries Oh
Jackson Jackson jar files that have been
properly modularized with explicit
module declarations and they're sitting
on the module path so now to finish up
let's just go back to the tweet some
source code will put that module in
fit-out Java back in will recompile to
eat some
and now we've got in EM Lib four modules
explicit modules and we can run
everything right there we don't need the
classpath don't need to say add modules
now everything is another module
oops except I forgot to do that oh well
tell it what we're the main class is
there we go
everything everything's a module now we
have a nice nice clean modular system we
can also do things like so much show
modular at resolution as we did before
and here we see that the Jackson modules
are being loaded as we they were before
but previously in this output when they
were automatic modules each one of these
lines ended with it with the adjective
automatic so you could tell they were
automatic now they're not automatic
they're actually explicit everything's
nice and clean
ok so I hope I've been able to show you
that migrating to modules is is possible
you can do it from the top down that was
the first part using automatic modules
you can do it from the bottom up if you
maintain libraries and and all of the
dependencies of those libraries have
already been modularized and eventually
you know everybody hopefully can work
towards having you know the entire world
be modularized but that will of course
take some time this is at a higher level
kind of a migration trick that we
borrowed from generics if you remember
generics when we introduced them to Java
in Java 5 one of the aspects of that
design that to this very day remains a
bit controversial is the fact that they
use erasure some people find that
dissatisfying and would prefer you know
full it fully reified types fully
reified generic types but the reason we
went with the ratio is that it allows it
allows gradual migration of code
relative to other code whether the other
code uses generics or not you can
generate genera phi your own code
without waiting for a library that you
to be genera fide and likewise you can
genera for a file library without
requiring all usual users of that
library to genera fie their own code
this is the same kind of migration
compatibility forwards and backwards and
you know trick that we're doing here you
don't need to wait for all of your
dependencies to be marginalized before
you play with models yourself and light
and likewise if you're if you're going
to modularize your own library you're
not thereby forcing all of your users to
moderate or modularize before they can
use the new version of your library
alright that's it for now we've got
about 12 14 minutes for questions any
questions oh wait I should I need to
show you one more thing
whoops sorry don't believe a word I said
and here's where to get more information
at the the Jepson the jigsaw project
page there's a link to do from the
jigsaw project page authoritative source
fairly dry but intended to be complete
references if you want you want even
more information I would recommend the
recently published book by Sandra
mattock and Paul Becker Java 9
modularity from O'Reilly ok questions we
have a hand mic much easier than me
repeating things there is there are some
microphones on the mezzanine
sorry he's closer he wins I'll get you
next worth I'm sure I missed this but
you cautioned us against using automatic
names using automatic module names for a
library that you are going to put into
them centrally you yourself modularizing
so if you're in the middle of the stack
and the things that you're dependent on
have not been modularized
but you're a library that you want to
export to other people what is a way of
getting around the problem that you told
us about that wait if you're if you're
in if you're in the middle of the stack
it's best for you to wait to publish a
modernized version
of your thing until all of its all of
its dependencies have been modularized
there there's there there's just no way
about that and no way to get around that
that it's potentially that's a problem
you know happy to hear solution if
you've got one we you know we thought
about it long and hard and and and just
don't see a solution for that I mean if
you're in a situation where you maintain
those libraries for internal use you
know within a constrained organization
such that you can control it then sure
go ahead and do that publish them
internally but please don't publish them
to central because eventually eventually
the maintainer of those libraries will
choose their own module names and
they're likely to be different and then
everything's gonna break all over again
so it's a risk you can take but you're
you probably would be B you'd be doing a
disservice to your users so really what
you're you're going to be urging every
library maintainer to put in that
automatic module name
exactly exactly that that's that's
that's the first thing to do if you
maintain a library you don't have time
to to to think deeply about it
modularize it today but you know what
you want its module name to be then just
add that manifest entry only takes you
know a couple lines and palms out XML or
whatever and and claim you know state
your claim once you do that it's safe
for others to use your library with that
automatic module name so yeah that's the
recommended path okay there was some
here you explained about the reflection
opening for other libraries but how does
that work if you want to use modules can
you use it as well yeah automatic
modules implicitly open everything so
yeah I mean they're automatic modules
are there they kind of well I could say
something rude but I want other
questions
well you were right next to a mic but
your eking is this one if you want can
you use white quartz in the model info
the Java file no and then that's an
intentional design decision because we
thought we we think that exporting
something is is an act you should think
intent very intentionally about if if
you could say exports star then
something's likely to go wrong down the
road other questions yeah how do you
deal with it if someone makes a module
not open and my I want to actually use
entities in that module by Jackson
reflection so it's not an open module
but I do want to use those entities for
reflection access so that that's that
there's a good question there are there
are various workarounds there's a little
bit there's a a in in the API you can
actually delegate the reflective power
from one module to another sometimes
that works as a last resort on the
command line there are options and these
are all explained in JEP 261 their
command-line options whereby you can
force you know any arbitrary module to
export a specific package or open the
specific package so that that's kind of
a hammer that use of your if you're
desperate if I saw it correctly you use
the smaller JRE how did you create it
yesterday you showed how to link us some
modules to the application but how to
create an isolated check GRE with only a
subset of modules so I made that Jerry
with the same kind of jailing command
that I used yesterday using their job at
the Java linker and I did I just
specified to it that I wanted you know a
a set of for JDK modules in the L in the
resulting image and and without any
application modules so you know it's
just another instance of the jail in
command
any other questions I'm sure where we
are on time when you use the open
statement
can you open up to a specific module
good question yes you can you can open
you can open a package to a specific
module or a set of specific named
modules you can also export a package to
a specific module or set of named
modules so you can constrain the
accessibility of what it is that you're
making available and that's we actually
use that a lot in the jdk modules
themselves because you know there's
there still there's still lots of lots
of interconnections since it started off
as we started off with this huge complex
monolithic system with lots of bizarre
dependencies some of which we just
couldn't get rid of so if you go look at
the module infos in the JDK source code
you'll see that they're Java based
module 4 for example you know it exports
you know Sun dot and turn on your JDK
internal blah blah blah you know to a
specific you know probably a dozen other
JDK modules and we have a a hashing
mechanism in module artifacts that
enforces that you enforces restrictions
so that you can't spoof the system UK if
you can't make your own module named you
know Java dot sequel and thereby get
magic access to enter the internals of
Java dot base we did think about that
problem all right any other questions
Thanks anybody closer I'm getting lazy
no you're not that much closer no no no
no no no he's where were you here let's
try to go in order you explained this I
can imagine that many of the backwards
compatibility problems with modules will
be using previous JDK
for all the bad reasons
so how would you compile much will
compiled jars against alert JD case
right so one of the one of the the
beauties of modular jar files is they're
just jar files so if you maintain a
library that you want to make into a
module for use online or later but you
still want it to work on earlier
versions of Java say I don't know JK sex
you can do that you need you just need
to make sure that you compile the module
info Java with JDK 9 or later and
compile all the rest of your code and -
release whatever that earlier the
earliest release it is you want to
support and then the resulting jar file
you can put in the module path in 9 or
later you can put on the class path in
it for for an earlier release and the
module info class is filed we're just be
ignored there's no reason you know the
VM the compiler will never look at it
because they they have no reason to they
wouldn't understand it if they did so
that that's the solution and there I
think there's some I think on on the May
one of the maven web pages there is that
there's actually an example of how to to
to configure your palm so you can
compile the module info with nine and
the read all the rest of your content
with an earlier release and get one of
these hybrid modular jar files okay
there was someone else get your next
there's a cushion on the board about
versioning you know that it's would you
now useless if you don't have versions
there would be more so the modules would
be more useless if they did have
versions actually so this is this is a
frequently asked question there are
several answers to it some philosophical
some practical the philosophical one is
that we don't put murder we don't put
versions on classes we don't put
versions on packages we don't put
versions on fields or methods modules
are a linguistic concept in the
programming language we shouldn't put
versions on those either it's fine and
useful to put versions on the artifacts
that define these things
but putting versions on on on the actual
you know the actual actual modules
themselves is not is not helpful I
thought I'd turn that off okay um a more
practical reason why the module system
doesn't do versions itself is that
whatever it did would almost certainly
conflict with what maven does what
Gradle does what Ivy does would all
these other existing version resolution
systems do and they're all different so
it would make it would it would be very
unsatisfying we basically we would
created model systems a few people would
use if we baked it into the system and
it conflicted with all of the existing
build tools so we so we didn't do it and
it's a it was kind of a surprising
conclusion when we came to this because
a very early prototype of jigsaw did
have version constraints in it but when
we realized oh these other tools that
everybody's gonna keep using already
solved the problem maybe we just don't
need to solve it and that's worked out
fairly well okay just a couple minutes
left yes the jet the java packager in in
jdk 9 understands modules
JavaFX we modular JavaFX so it's it's a
set of I don't know it's like five or
six modules as well so yeah you can make
a modular FX application and j-link it
up and you're out and off to the races
any other questions to use to libraries
which is if you have two libraries that
export packages with the same name
weight yep do you have two libraries and
they define each defines a module and
the module has the same name no no you
need to pick one you pick one by
configuring your build system to only to
only have one of them in your module
path at least only one in each directory
of the module path and whichever one is
first wins
right the
there's there's no heuristic clever
enough to figure out which one of those
two things you actually need now let me
go check the time quick Oh
one minute left last question
anybody can a module extend another one
no there's no there's no inheritance
amongst modules that would be
complicated it's 30 seconds use the time
wisely it how does it fit with OSGi it
it it does not interfere with OSGi OSGi
works great on top of JDK 9 without
change and with that we're out of time
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>