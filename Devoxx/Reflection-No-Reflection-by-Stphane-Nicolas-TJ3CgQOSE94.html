<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Reflection No Reflection by Stéphane Nicolas | Coder Coacher - Coaching Coders</title><meta content="Reflection No Reflection by Stéphane Nicolas - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Reflection No Reflection by Stéphane Nicolas</b></h2><h5 class="post__date">2015-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/TJ3CgQOSE94" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi welcome to this talk about reflection
and Android so we are going to present a
few research researches that we've been
doing at Groupon my name is Stephanie :
I'm a senior Android developer at
Groupon now working in the Android team
I got around 20 years of Java coding
experience and I also participate in a
couple of open source software's like
Robo spice uber juice bound dachshund
Jack's most of them are related to
Android that not all so I'm a normal or
pure Java stuff so yeah work at Groupon
and yeah we are airing so if you want to
spend some time in California actually
it's a great team a great environment to
work there so feel free to join us so
today what are we going to talk about we
are going to talk about reflections no
reflection it's a project we started
like two years ago
our main focus was trying to improve the
performances of dependency injection and
enjoy it I came back to that so we have
been working on trying to find
alternatives to reflection on the
Android platform so we'll talk more in
depth about our motivations also explain
what is reflection and we could identify
some alternative technologies that we
could use instead of reflection so we're
going to talk about that too and then I
will introduce a new technology that we
have been thinking about and developing
during the last month which is called
reflection or reflection and then we
will have a conclusion about all this
research work prior to this talk I would
strongly recommend that you have some
background knowledge of dependency
injection the eye and bindings by this I
mean like stuff like butter knife Dart
so everything that you can assign a
value to a field basically inside an
activity or fragment whatever and some
background knowledge also of annotation
processing we will have some reminders
during the talk so whatever what are our
motivations that group on why do we
study reflection basically we have
developed during the pastures
dependency injection called Robo juice
Robo juice is actually
based on juice as the name says it so it
means that it's a very old technology
from Java its feature-rich it has been
developed for almost like six or seven
years now it's very stable it offers a
couple of ad very advanced feature for a
dependency injection it's very easy to
configure and if we would want to
compare it to dagger one or dagger two
for instance the other popular
dependency injection frameworks on the
Android platform there is actually no
requirement to manually define the graph
of injections which is quite a big
advantage when you think about it there
is a lot of boilerplate code that has
been introduced by dagger one and even
more by Tiger two to define this graph
but we juice you don't need to
explicitly do so but juice as a problem
it's that is slow and so Robo juice is
also told to be slow so we can yeah we
will detail that a bit more in a call of
seconds
so in Robo juice 3 our latest release
last year we actually improve the
performances of Robo juice by 35% which
is quite a lot so the way we did it is
that juice was based uniquely on
reflection and we introduced an
annotation processing phase at the very
beginning of the compilation so that we
can skip some part of reflection or
boost them made them faster if you want
to know more about what we did we have
some slides on speaker deck there are we
introduced a technology cost called
blender and Robo blender an annotation
for juice an annotation processor for
juice so let's compare exactly the
performances of the different difference
injection and the Android platform so
I'm going to show you a couple of
numbers that have been produced on
genymotion which is a very fast Android
emulator as most of you might know it so
let's say you got a class a very simple
no fails nothing and you want HB a
dependency of some other class and you
want to inject a into this class so you
will have to build an instance of a and
assign it as a dependency of our outer
class if you want to create 1,000
instances of a using the constructor
call the
you can see that it takes roughly less
than one millisecond for 1,000 creations
of instances of a if you do so using
dagger one then it comes up to ten
milliseconds with the rubber juice - we
were actually very yeah much slower it
took around 30 milliseconds roughly
Rabideau Street decrease that you like
17 milliseconds and Robo juice is making
it a bit better or apple juice for is
making it a bit better
but still even if we could make large
improvements 35% is not enough compared
to jaga one so we want you to improve
that and we think that the main cause of
slowness of juice of Robo juice actually
comes from reflection so if reflection
is slow let's try to kill it completely
to remove it completely from juice and
try to build something that is juice
like and got the best of juice that how
easy it can be to use it but more
efficient and faster so that's what we
have tried to do and I will summarize
our research on that so first let's talk
about reflection what is reflection so
here you got a very simple schema that
explains the cycle of development so you
got your Java source code inside your
IDE you send it to the compiler Java C
and then you will get some byte code the
byte code will be interpreted by the JVM
so it can be Dart are that vague or a
standard JVM and then you're gonna
running application so reflection takes
place when the application is running
reflection gives you a way to actually
see your own program when it is running
so you can manipulate classes methods
constructors fields it's actually very
simple and intuitive it offers a very
simple API very close to the web object
oriented program talk about program so
it's not very difficult to learn as you
can see you can just define a class
finest constructors can through them
invoke them same for methods fields so
you can call methods you can call
constructors you can assign fields so
reflection gives us the ability to
modify actually the program when it's
running and we need to be able to do
this to inject the difference
so that's our goal when using reflection
inside juice is to identify all the
dependencies that are annotated with
@inject all the fields for instance or
all the methods and to be able to call
them call the methods or to assign
values to the fields to assign the
values of the dependencies to the fields
but yeah reflection is slow especially
on Android so you might know that in
Java reflection is not so slow in pure
Java on a GVM because there is some
caching policy so by default the 15
first calls to anything based on
reflection on a GVM will be actually a
bit slow but after 15 code the JVM is
going to cache the calls and so all the
code is going to be executed by a
just-in-time compiler as usual and so
after 15 calls everything goes very fast
but on Android we don't have this
technology there is no G for reflection
and that's why it keeps being slow but
what exactly is slow in reflection
because everyone says ok juice is too
slow it's based on reflection but what
exactly makes it slow in reflection so
we want it to get some numbers yeah so
what we did is to benchmark a few
aspects of reflection so as you can see
on the upper-right figure when you scan
fields to detect annotations to see
which ones are annotated to scan methods
to see which ones are annotated this
actually takes a lot of time loading
classes via reflection also takes a lot
of time when it comes to field
modifications so you got a field you
want to assign it if you do it directly
it let's say if the public fill you just
assign it a value for 1 million field
modifications it would take roughly 1
millisecond if you do it via reflection
then it can take three times more time
for method calls in the lower right
corner you can see that it takes a bit
more time for reflection but not so much
and actually there is a huge difference
when it comes to constructors so if you
instantiate 1 million objects by a call
to the constructor directly it takes
like two hundred milliseconds still a
bit slow it's actually slow to create
Java objects
but if you advise reflection it takes
five times more time so what are the
alternatives if we want to bypass
reflection what can we actually do let's
come back to the central scheme of this
presentation and identify three
alternatives so what we could do is use
byte code weaving so we can take the
byte code make changes there inject the
dependencies for instance inside the
byte code directly so that would be
possible a second alternative would be
to use a SD so ast is our abstract
syntax trees we will come in more depth
to what area ASDs are and so it would
also be possible to modify and jet out
Java program at this level so between
let's say the compiler and byte code and
there is a third alternative that is
more popular these days on Android which
is to use annotation processing
so let's study do three alternatives the
first one is byte code weaving what is
by call weaving so Bikol weaving is an
old term on the Java platform and I
think the first time it's been
introduced is like the second year fu
jia has been published and actually in
java there are two ways to modify the
byte code there are there is a dynamic
way to modify the byte code and there is
a static way to modify it so on a
standard JVM you can use what is called
a Java agent and a Java agent will be
more or less monitoring the JVM and as
soon as it loads a new class the Java
agent would be triggered and the agent
can do some bytecode manipulations at
runtime so this is possible under
standard JVM but not on dalvik and not
an art there is no equivalent of Java
agent maybe we could use instrumentation
but it's much more limited if you want a
more in-depth talk about bytecode
weaving and Android I suggest that you
go to speaker deck and we got some
slides also and bytecode weaving but we
want you to study how really it is it
would be possible to use bytecode
weaving and Android so we have created a
full stack to do what we call static
bytecode manipulation so opposed to
dynamic biker manipulation the static
bytecode manipulation would take place
just right after the classes have been
compiled so you get like
Class A plus file sorry and you were
going to dig into that class file and
manipulate the bytecode just right after
classes have been compiled and they will
be embedded into your Dex file into your
apk so it is actually possible it is
required quite a lot of work we spent
like two month trying to develop a full
stack so that we could completely modify
the bytecode in the way we want
something that is flexible enough so we
could achieve some good results for
instance let's take this is an example
of the library we've developed we're
using bytecode weaving and Android let's
say you got an activity like this main
activity that extends activity you just
annotate it with a simple annotation
like at log-log life cycle you add a
gradual plugin and what we are going to
do is to scan your byte code the byte
code of the main activity class to
identify all the methods there are life
cycle methods of your activity and
before they are cold we will log
something and after they are cold at the
end of the call we will log something as
well so you can for instance measure the
time spent in every method which is part
of the life cycle and IVA of an activity
and as you can see it's as simple as
just annotating the class and that's it
nothing else to do which is actually
quite powerful so if we want to
summarize what is good and what is wrong
inside the the bytecode weaving
technique you can see that it's very
simple to use it's actually there is no
boilerplate at all what you do is just
annotating and then we will give meaning
to these annotations via library the
library is very easy to use you just add
a Gradle plugin to your build it will
interpret the annotation modify the byte
code for you nothing else to do
so we think it's actually very powerful
because you could change the behavior of
a class in every way you want and there
is kind of a standard on a Java platform
which has been developed over time which
is called Java assist most of the
bytecode manipulations on the Java
platform I are done through this library
so it becomes add like a de-facto
standard on the bad side let's say that
the libraries are based on byte code
within
are actually quite complex because you
need to dig into the byte code you need
to have to use some kind of reflection
like API provided by Java cysts and
there are also very difficult to debug
because you can do whatever you want
with bytecode manipulation you can do
even very strange things like a method
with the two return statements in a row
so you are a very at a very low level
and it's yeah a bit difficult to
understand exactly what troubles you can
get into so yeah it's powerful but it
also comes with maybe too much power
sometimes one big disadvantage of this
approach of Michael weaving it is that
it has never been standardized so inside
the grid a huge gradual build cycle in
Android you might know that there are
more like 100 read all tasks involved
now but there is no real room for I mean
no official room for triggering
something based on by cool living and
one also one limitation of by cool
living the way we can do it and Android
it statically is that you can modify
class files or easily jars also Java
assistant been developed for Java so it
works with all that but actually not Dex
files so for instance if you got an AR
dependency it would be difficult it
would be impossible using Java sis right
now to actually open the a AR open the
Dex inside and do some bytecode
modification inside it receive
everything and use the aar Devon see
there is currently a fork of Travis's to
work with Dex files but it has not been
reached a maturity level still also
there is something coming up with the
Android platform the use of Jack and
Jill and whole new compiler so the the
idea of the Jack and Jill tool chain
let's say is to get a very precise idea
of every change you make during the
compilation cycle so you change one line
we can identify exactly what place in
the bytecode has change or what resource
has changed so we can know it in the Dex
exactly what has changed and inside the
apk exactly that's the small portion
that has changed
and hopefully in the end we can even
just send a small Delta to the device so
whirring when you are developing we are
not going to shoot a full new apk as
soon as you do a small change that may
be just a small Delta of the apk and we
can use the new application but Jack
engine is not official yet we think he
is going to to be fully released in
during this year or 2016 let's say and
actually Jack and Jill is not very well
documented yet if we know that it's
going to use a new format that is not
the class file format which is called
J's and no one knows exactly the
specifications of J's and there is no
real announcement of any specification
coming so it looks like something very
internal to Google and we don't know
exactly in which extent we are going to
be able to modify the bytecode in this
format but we can come back to that
because things are changing a bit on
this side and also one big disadvantage
of bytecode manipulations is that the
modifications that you couldn't reduce
with the library based on bytecode
weaving are actually invisible to
developers so you are editing your
source code you just add an annotation
and we are going to manipulate the byte
code which is completely visible to you
so maybe we are going to introduce some
stuff which you are not so confident
about and many developers fear that that
actually we are going to introduce
behaviors or bugs that would be very
hard to debug because they don't even
have a a source code associated to it
that you could review so that's one of
them yeah that's the Jews are the main
disadvantages of bytecode weaving but
actually it works and it works great
even we could also publish two or three
other libraries based on bicycle weaving
one of them is directly the equivalent
of the toe knife so we don't use
annotation processing we just use
bicycle weaving we did also the same for
resources not only views now but a knife
does it also and we also did the same
for the extras so that you can pass in
an intent from an end one activity to
another and we could do some bytecode
modification to actually inject the
values of the extras pass through your
bundle so yeah it works but it's also
comes with a dark side so let's
study a bit more the second alternative
which is ast manipulation so ast is an
acronym that stands for abstract syntax
trees so abstract syntax trees are
basically data structures that are used
internally by the compiler all of them
when I mean all of them I mean Java C
the official Java compiler but also the
alternative compiler of Eclipse I don't
think anyone uses Eclipse anymore but
still those two compilers internally use
abstract syntax trees what they do is
that the take the source code that will
transform it into an AST
in a first pass of the compiler and then
after that the compiler is going to
compile the ast s into a Java Java class
file into bytecode but between the two
between the first pass and the second
pass we can actually manipulate the ast
s directly a few libraries do that in
Java the very well-known Lombok project
does this in Java I don't know if most
of you are aware of it I think on
Android it's quite fresh not so many
people use it still so with loon but you
can for instance just annotate a field
and Lombok is going to generate the
setters and getters for you for instance
one of the cool things it can do here
you got an example of a library that's
been developed really for Android by
someone called Matthews from Poland if
I'm an emu is good so we developed a new
project called Jose which I probably
pronounced very bad so for instance with
with this project you can transform a
class into a parcel level very easily so
you can just annotate a class extend the
interface and bye-bye code by AST
manipulation we are going to add all the
methods needed to actually implement the
parcel level interface so the Creator
the describe content methods and the
serialization method so just by using a
simple annotation so you can see it's
very close to what we can achieve with
by code weaving this actually works in
which works pretty well so you can
create parcel labels like that and you
can find the whole source code
github so that's also an alternative so
let's compare what's good and what's bad
into aliased in manipulation into this
approach so again it's very simple to
use there is absolutely no boilerplate
you just have annotations to add that's
it there are very easy to use you just
add plug-in to your build or to your IDE
but now they are pretty much in sync
with fuse Android studio and Gradle and
it's very powerful we can do a lot of
information as much as we can do it by
cool with it on the dark side we must
say that manipulating the IOC's is even
harder than manipulating the bytecode
why because there is no standard library
to do it so you rely on something very
low-level so there are some Java classes
that represent a STS but you will have
to do everything and you will be on your
own basically so yeah it's order to make
those libraries work even if you look at
Lombok it's a very complex project
because it has been even designed to be
able to run on both compilers the
Eclipse compiler and Java C compilers
for her say for Android the author just
focused on Android compiler the official
Java C compiler but still there is only
one implementation to provide but it's
stuff to provide it also in the same way
as by convenience notes
non-standard in an Android build it's
the same here for AST manipulations its
non-standard and if Jack and Jill comes
up we come into the play then again we
will have some trouble because we will
have to manipulate the ast s but maybe
Jack and Jill is going to use a
completely different format from which
which would be difficult to create STS
if possible and again these
modifications are also invisible because
they occur after the editing of the
source code inside the IDE same
disadvantages bytecode weaving now let's
focus on the third approach the third
alternative which is annotation
processing so here is an example of
annotation processing inside butter
knife so you just annotate a couple of
fields like the edit text username you
are going to bind it to an Android I see
inside the layout
and we are going to with butter knife
we're going to generate some new code
and there will be some boilerplate code
needed to actually invoke the code that
is generated during annotation
processing there is still some
boilerplate code that is needed oh by
the way it's something that is often
funny to me is that during this code
there is some reflection so you cannot
say when you use butter knife you don't
use reflection at all there is some
reflection to actually call the right
code you see that you just bind this but
internally butter knife will load the
generated code for you via reflection so
annotation processing is quite simple to
use not very complex it's a Java
standard which is quite a big thing
compared to bytecode manipulation and
IHT manipulation it's really part of the
official documentation of the Java
platform at the requirement of a
platform to be Java compliant and it's
relatively powerful so not as powerful
that would be the Pikul with e or the
ast manipulations we will see why in a
second on the dark side the API is
difficult I don't know if most of you
have actually tried to implement an
annotation processor but it's actually
tough it's very different from
reflection it uses a whole new API a
whole new bunch of concepts like type
elements which are a bit yeah messy
sometimes not so easy to catch really
even if you you are used to develop
annotation processing you will log a lot
of stuff because it's hard to remember
it's hard to map mentally to what we
what we use as concepts when we talk
about a Java program also one big
limitation of annotation processing is
that you can only create new code so by
design the annotation processor has been
limited so that there is no way that you
can modify existing source code with
annotation processing there is no
workaround well actually there is one
little thing you can do yeah maybe it we
can come up during the question period
so you cannot modify the program that
you can generate new code and that's why
you will actually nearly require some
boilerplate code to
did cool the coat that has been
generated during annotation processing
that's why you do the burner knife that
inject this or bind this the problem
with annotation processing is actually
what is happening what has been
happening during the last two years on
the Android platform is that when Google
decided to use Java it was for two
reasons first one to recruit Java
developers and we are opinions of people
knowing Java it's not a very difficult
language we learn it at school and those
people could be converted into Android
programmers so that was a good guess but
there is also a second thing that is
very compelling inside Java is that we
could reuse a lot of technologies a lot
of libraries a lot of libraries that
have been maturing during like ten years
inside the Java world or twenty years
and we could reuse them on the Android
platform that was a real boost at the
beginning of Android so it was not
something fresh and everything would
have to be rewritten but if you want to
bypass and at a reflection all the
libraries that are based on reflection
and you want to make them very efficient
and Android you have to use annotation
processing for now it means that we are
going to rewrite everything and that's
basically what has been happening so
juice was not good enough we had to
rewrite it into dagger 1 even dagger to
butter knife was would have been
possible with reflection would have been
a very simple library to code but it had
to be completely written from scratch so
that it would not use reflection and the
same occurs for every kind of technology
you can think of for instance of our
aims are very popular in the Java world
but in Android one bottleneck would be
to use them because they are based on
reflection so we could create annotation
processing based our aims but it means
we are going to rewrite everything which
is quite a big disadvantage also you
need some boilerplate code to invoke
generated code which is not as easy as
just not having to write it so let's try
to dig a bit on what is happening during
annotation processing so you take your
Java source code you pass it to the
compiler and actually the compiler is
going to fork there is it will trigger a
tool called the annotation processor
side the apt annotation processor inside
the Java C compiler and we will process
all the annotations prior to compiling
and then it will generate new Java
source code potentially or you can even
generate some other stuff you can even
generate classic class files if you want
but most of the the annotation
processors we know of actually generate
Java source code and then we will take
the generated source code the original
source code pass it to the compiler and
get byte codes bytecode files here is an
example of some code that has been
generated by better knife so you we are
binding a few text views and as soon as
butter-knife annotation processor is
going to run it will create dollar sign
dollar sign binder which will assign all
the views to their actual views inside
the other layout the exam XML layout so
as you can see the code that is
generated is quite simple to follow and
this code will have to be invoked by a
call using reflection like butter-knife
that inject this so what do we use
actually annotation processing for we
use it for accessing fields like here we
are just using these fields to assign
them a value we could also do that for
calling methods like in the case of
Tiger one or dagger true like to provide
our methods for instance that are called
by they are invoked by some code that's
generated during annotation processing
we can do the same for constructors for
dependency injection creating the
dependencies so we are doing exactly
what we want to do with reflection so
both of them are kind of equivalent we
can do exactly the same thing as we can
do with reflection we can do them with
annotation processing but still there
are a couple of limitations so no bite
so no class modification on in new code
which means some boilerplate also we
lost something if you look at the fields
the text views inside the DTD activity
on the top and on the right you can see
that they are not private anymore they
should be private they should be private
your activity but if you make them
private
then the generated code cannot access
them because we are creating a new class
in the same package so the usual
workaround is just to remove the private
modifier so that they become package
protected and the generated source code
can actually access them okay it's not
such a big deal but still we lost some
power inside Java we're using that with
reflection there is no such limitation
you can actually change the modifier
visibility of a field or a method using
reflection prior to using it so when we
see this alternative we were thinking
okay maybe we can get the best of both
worlds now trying to make it easy to
adapt reflection all the the libraries
that are based on reflection we could
try to just adapt them a little bit not
to rewrite them fully but just to modify
that slightly so they would not be using
true reflection it would be nice to have
that second we want to take the best of
reflection which is easy because we
actually use a very simple API very
intuitive API and get also the best of
annotation processing with the speed so
if we could combine these two into a
single technology maybe that would be
great and third we were thinking that no
one wants to see the generated code when
you're using butter knife you usually
don't care and so it would be
interesting to keep that properties and
hi to generate it code as well so what
we've been doing or thinking of is that
we could generate reflection light code
via annotation processing that is really
the central idea inside reflection or
reflection so we want to use annotation
processing to generate something that
will be 100% compatible with reflection
but would actually not be based on
reflection let's see how we can do that
so it will involve three steps the first
one is going to be to define what we
call R and R so for reflection or
reflection classes so those classes are
going to be one
person compatible with reflection and we
are going to fill those data structures
during annotation processing time so
inside the annotation processor that
you're going to write instead of
manipulating this awkward API that is
used for annotation processing it would
be great if actually we could use
reflection because it's simpler so what
we are going to do is to generate
classes that are fully compatible with
reflection but we are going to fill all
the information those classes require
like how how many fields do they get how
do they have how many methods do they
have what are their annotations of these
methods the parameters everything that
your reflection provide we are going to
try to completely get all this
information during annotation processing
and create the data structures for
reflection so this only takes place
during annotation processing time the
second step is once you got those RNR
classes then you could generate them so
if you generate those classes then it
will be possible to use the RNR classes
at runtime
not only at a Dacian processing time but
during runtime as well so you generate
the code of the classes that you've been
able to build during annotation
processing and you expose them to the
runtime so they become available for the
application itself in the same way as
reflection is available so we could do
that
if we do so we will have most of the
features of reflection except one
modifying the field or calling a method
so all the code that we can actually
generate will hold all the information
of reflection but will not allow a write
access like reflection does so we
decided to add a third step to actually
generate new code that will allow to
modify the application in the same way
as reflection allows to do it so we can
invoke methods invoke constructors and
assign value to fields so I will detail
a bit more with three steps the first
step is so it takes place during
annotation processing the main idea is
that you're going to take your source
code pass it to the annotation processor
then we're going to build R&amp;amp;R classes so
those classes again are exactly the same
classes or they expose the same API as
the reflection classes so we are going
to create those classes and from now
what it means is that you can create an
annotation processor that is based on
reflection so instead of using the meta
API two of the annotation processing API
what you're going to be able to do is to
use reflection to create an annotation
processor so it makes it much more easy
to actually create annotation processors
and then the generic generated Java
source is going to be sent to the
compiler as usual so at the end of the
first step when we could achieve that
the result was that we could manipulate
fields we could manipulate methods we
could manipulate constructors we could
scan all the classes for instance to ask
for the annotated fields and at eighteen
methods just using reflections so it
means that you're going to use classes
or methods fields before they are even
compiled that is really denote what is
central inside the other with the
annotation processing API why doesn't it
use reflection by nature is that
reflection is about classes but
annotation processes processing takes
place before compilation so there are no
classes that's why the intro in Java
introduced a new API what we did is to
unify those two ap is so that you can
manipulate the classes even before they
are compiled just by the view you get of
them via the annotation processor so
using unification of annotation
processing and reflection API according
to us just by itself this achievement is
quite a good milestone in Java we think
it's interesting for the language itself
or maybe it can even demonstrate that
maybe a language changes is required
because we could do something that is
much simpler at the annotation
processing level or maybe Jarek could
change so that's that was a good result
so the second step remember is to take
those are in our classes that we have
constructed during annotation processing
and to generate them so that they are
going to be available at your end
time we did that also so we take the
generated code to fill the are in our
classes which idea on our classes that
we generated and we generate the code
for them so we are going to create code
that are going to be able at runtime to
fill those classes again I don't know if
you can follow me I hope so so the first
step was to fill reflection like classes
with data obtained via annotation
processing second step is to generate
code to recreate those classes and so
that they are available at runtime we
are going to create code to create again
those are in our classes at runtime and
so the application will be able to use
the RNR reflection api so we could do
that but the limitation is that is going
to be read-only so no write access no
fill modification no method invitation
no constructors invitation that's the
end of the second step here is an
example of what an R&amp;amp;R class looks like
so we generate code to create those
classes as you can see we generate code
to create a class which is not a java
class actually you cannot create a new
class like that you cannot call new
class in Java on the reflection classes
but with our run our classes we do it
this way so we can define a class we can
define all the fields inside this class
we can define all the annotations of
those fields same form methods same for
constructors
so all this code can be executed at
runtime and create a pseudo class like
with add which has exactly the same API
as reflection but it will be available
at runtime and will actually involve no
reflection at all it will have just been
filled by code that is generating
generated during annotation processing
so yeah it's possible and all that could
work so all our classes are going to be
one great person compatible with the
reflection API we got even a bunch of
tests to test that we are actually
exactly compliant with the reflection
api's we are going to use the classes
our filler during annotation processing
they are going to be available at
runtime in in pretty much the same way
as you would use reflection so for
instance you could use class dot for
name a class name and you would get an
hour an article
that you can use to ask for fields
methods constructors so a first step to
what we have as a result is that we have
our on our reflection classes that are
available to libraries and applications
they will expose something that is
completely compliant with reflection it
will be available at runtime and it's
much faster than reflection so you can
ask a class give me all your annotated
fields and for this class is just going
through an ash map basically that's it
and there is no native code to actually
open the byte code to look through the
indexes nothing like that so it's much
faster to use our in our classes
compared to reflection that's what we
need an Android so that's a result of
step two one of the limitation of step
two was that nothing was mud if you
couldn't modify anything so it was a
near read access to reflection
information so we decided to add a step
three during this step three we are
going to generate not only our in our
classes but also to generate what we
call reflectors class reflectors those
class reflectors will allow a write
access to the classes of your program
how we can do that so here is what a
reflector would look like so here you
got a reflector for a Class A so we are
going inside the reflector to provide
methods to actually assign values to
fields to actually call constructors to
actually call methods so we're going to
pass this reflector to an R and R class
every R on our class will know of its
associated reflector and we will be able
to not only read the information of
reflection but also to make
modifications to the program itself when
it's running just by generating all the
code that changes the program itself and
as you can see the code that's generated
does a news reflection I don't either
for instance if we want to use the first
constructor of a class then we are going
to just call new a and that's it it's
just some rapper to call the constructor
but it gives you the feeling to use the
reflection
API it's something very generic but
actually there is no reflection involved
that's the base idea so we can use those
reflectors to modify the fields to
access them read or set them to invoke
methods and to invoke constructors as a
result of step three we can now make
juice classes the RRR classes still
available through applications and
libraries at runtime
they will provide read and write access
to reflection information and still
there are faster than Android so we are
going to generate an reflection like
layer of your own classes that is
exactly the same as reflection but it's
going to be faster and not involve
reflection at all
that's why we call it reflection or
reflection so it means that if you have
a library that uses reflection let's say
an ORM or a dependency injection library
you could just instead of using the
classes of the reflection API you use
the RNR classes and that should be the
only change you would have to do and you
would get the Android version optimized
speed efficient to use for the annual
platform but not a big rewrite as we're
doing right now there is yeah there are
a couple of more details we can go
through if you want during the question
period so actually one of them was to
create annotation implementations we
could succeed in that also but we
decided not to have a slide dedicated to
it but it was very interesting from a
syntactic level point of view so ok
up to now I explain you how we could
create the RNR framework so we got it
working great what do we do next
but basically we want it to do all that
for improving dependency injection so
let's try to fork juice let's try to see
if that works if we can reuse juice the
way it is using reflection just general
couple of packages replace that Bar by
RN our classes and we should be running
so we try to do that so instead of using
juice with
which uses reflection for processing
accessing fields invoking methods
invoking constructors we try to fork it
to make it our and our juice and instead
of reflection we would use our and our
reflection for everything from
processing accessing field invocation of
methods etc this actually was a great
attempt it took like one week and it
failed it just failed why did it fail
because juice was using actually pretty
much all the features of reflection and
some of them were quite difficult to
implement using RNR we could do it for
most of them but we were realizing that
we were introducing a lot more changings
changes inside the juice source code for
instance there are some things that you
can do with reflections that are very
tied to the very nature of a Java
compiler for instance let's say you got
a class you can call a dot class which
is a class literal and it's actually the
exact same object as you would get with
a dot get class which is reflection so
on the left side you got reflection and
on the right side you got a compiler
statement which is a class simulation
and there is no way we can achieve these
kind of features with something that is
not linked to the Java compiler itself
so our and our classes could not do that
you could not have this equals there and
actually inside juice it was used quite
a lot of time so we could work around it
but it would mean to process the aided
class to find the equivalent or in our
classes which would slow down the whole
process for just an equal sign and it
was not the only trouble we had but one
of the biggest ones and we just realized
that ok or our classes work and
everything but it's not as easy to
change a library that is not that is
based on reflection to use something
alternative so ok it failed but we tried
again so we decided to take a different
approach this time instead of using
reflection or on our reflection for
processing which means for instance
comparing classes as we just saw what we
did is just using the RRR classes for
the manipulation of the program itself
so when you invoke a method via
reflection we will change that to
in our reflection invoking the methods
via our Naraku Anna Rana our and our
classes sorry and do it again for the
fails methods in its end constructors
but just change that very ultimates
process not use our in our reflection
for the whole thing inside juice but
just for the very last mile we could do
that and that only and actually it
worked it worked pretty well we got some
better results like almost 30 percent
performance gain but then we yeah we are
thinking that okay we gains 30 percent
so it makes it very close to dagger 1
performance is very very close but still
we have introduced quite a lot of
complexity to achieve that and that was
a bit disappointing so as a conclusion
we think that ok maybe the biggest
achievement of this research has been to
show that we can indeed unify completely
annotation processing and reflection so
maybe everyone could use could create
its own annotation processor using this
stuff because it's as simple as using
reflection and everyone is able to do it
so that's something that works and works
well and pretty stable not very
complicated it doesn't add anything any
other head at runtime nothing just makes
annotation processing easier recording
step 2 and step 3 which is kind of a
generalization of all the work that has
been done and Android using annotation
processors we think that ok we can
circumvent reflection it's possible but
it's going to add a lot of classes to
add a lot of generated code to add some
quite tough steps inside the Java
processing the Java compiling step
inside your build is going to add a lot
of methods to your Dex is also to make
the applications bigger just to provide
a layer of abstraction of reflection and
ultimately all this complexity will come
to like a 30% gain
not so much so we demonstrated that this
approach is feasible but we're not so
happy about it so we are thinking of
yeah maybe releasing a new version of
juice based on that
but maybe not we're not sure yet we're
still testing the technology and
actually not so happy about it because
it adds a lot of complexity it also
means to add a lot of maintenance to to
get in a direction that is yes it's
interesting but maybe a bit too big also
for the company like us that would be
maybe more the role of a raccoon or
Google to do this kind of stuff maybe
not our so we are still considering a
bit what to do with all this stuff and
also we are thinking that after all what
we've been doing is trying just to
improve the Android platform but at the
very programmer level which we could do
without the tools that were available to
us and the knowledge we had but the real
solution could be elsewhere when you
think about it if inside dalvik or
inside art Google would make some
efforts to make reflection faster that
would pay off and would be much simpler
so that's something that might be will
change some people are considering to
add a just in time for compiler for
reflection so everything would be ahead
of time with art but reflection code
would be compiled just in time that
could be possible a second alternative
which looks maybe closer in time is to
use the new transformations API ice so I
don't know if all of you are aware but
inside the new Android Gradle plug-in
actually it's still in beta
I think the version not social change is
so often I think it's 1.5 not so sure
about that but they are introducing a
new transformation API so inside the
Gradle the Gradle build cycle it's will
very soon be possible to do some
bytecode modification this
transformation API has actually been
needed by Google so that they could
create the jackandjill toolchain to make
it work and still keep a couple of
features that are used there related to
by code modification
like for instance code coverage when you
are running your tests now and you can
do it pretty easily with within the end
Android's to UID so you can create a
test and launch the application and
launch a test and see what lines have
been tested on what which lines have not
been tested to do that you have to
change the application under test so in
every line basically you would have you
would add some code to say if this line
has been cold or not during tests so
they are changing the bytecode that's
the way we do code coverage and Android
so they needed the transformation API to
make this kind of transformation
possible and to keep the code coverage
feature but still be able to move
forward to jackandjill and that's going
to happen this year so maybe at this
level we would be able to use by tool
weaving and that would be interesting
for the whole platform because we can do
something that is even more faster yeah
faster than annotation processing for
instance if you would buy it a field
elaborate or knife you would still need
some reflection to actually find the
binder which binds the field but with
transformations API you could just take
your class and as soon as the layout has
been inflated you replace all the fields
by the values of XML and that's it
so that could be an opportunity to make
reflection faster if they don't want to
improve the art JVM thank you very much
for attending this reflection on
reflection if you have any questions or
comments they are welcome thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>