<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Power and Practicality of Immutability by Venkat Subramaniam | Coder Coacher - Coaching Coders</title><meta content="The Power and Practicality of Immutability by Venkat Subramaniam - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Power and Practicality of Immutability by Venkat Subramaniam</b></h2><h5 class="post__date">2018-03-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/FQERMVABRrQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks for coming are we gonna talk
about power and the practicality of
immutability so I want to talk a little
bit about what is immutability I'll talk
about when it comes to programming
languages like Java where we have
predominantly focused on emulating state
of objects all the ears how could we
suddenly think about even making things
immutable well books like effective Java
has reminded us in the past that we
should favor immutability but of course
there was a great recommendation but you
know what's it really even practical and
and that's exactly what I want to focus
on today maybe three different things
one is talking about what is
immutability a get a little deeper about
what it really means to make things
immutable and then talk about what are
some of the reasons to really do it so
let's get started
well best time to ask questions or make
comments is when you have it so please
don't hesitate to ask questions or make
comments along the way if you draw my
attention and speak I'll be delighted to
hear what you have to say so let's talk
about what is a really Amidala tea mean
well it may it really of course is the
opposite of mutability where mutability
is where we modify the state of a
certain object whether it's a primitive
or a full-blown object we modify its
content and that's basically what
mutability really is now it turns out
that mutability is something that we all
do quite often but then why should we
really be concerned about doing
mutability if you really think about it
we do certain things that are very
predictably irrational let's think about
this for a minute let's step back to
Java 1.0 I know that's a long time ago
let's switch back in time what was the
you know thread class constructor taking
as a parameter it took up as a parameter
runnable no remember what runnable
interface is it is public well of course
because it's an interface and it's a
void and then run and this now think
about this for a minute what does that
method saying it says I will not take
anything as an import and I will not
give you anything as an output how rude
if you really think about it right so
here is a function that takes nothing
and gives nothing that's like some
employees that work right nothing goes
and nothing comes out of them but if you
really think about it this is pretty
darn scary because if you really think
about it how do you really use a
runnable the only way you can use
runnable is to put a mutating state out
there and then call a function and say
you go I put a variable there you can't
take that variable and use it and then
you can put back a state in it and I'll
come back and get it so this is why I
call it particularly irrational because
this forces mutation on our code by the
definition of the fact that you cannot
send anything to it and get anything
back from it which is pretty scary
because what have we learned from since
the time of Java 1.0 and that is that
mutability is okay sharing is a really
good thing remember what mom told us we
should really share but shared
mutability is devil's work and
unfortunately the minute we bring in
shared mutability it becomes really
really hard for us to work with
concurrency in code so we want a really
favored immutability as much as we can
but the question is how do we really
create immutable code in Java well sure
we can ticular things final maybe we can
prevent modifying things but that kind
of makes us wonder because we often
modify state and objects and is it even
practical to think about creating code
where we would actually keep things
immutable well actually I have a good
news for you it is very practical to
create a code where nothing is mutated
and I'm going to show you one such
example right now and I promise you when
you run this code no state is ever
modified and here you go that is the
example of a code where nothing changes
and of course there's a slight problem
here this core doesn't do anything
useful either so the minute we start
doing anything with it we have to start
mutating each state isn't it so that
begs the question is it even practical
to do it what I want to draw analogy to
there's something else a little bit but
before that one of the key things about
functional
is functional programming emphasizes two
different things one is that we should
program with immutability they talk
about pure functions I'll revisit that a
little bit later they talk about
immutability quite a bit and they it's
near and dear to functional programming
that we should honor immutability and
then of course we also use higher-order
functions as well so one of the things
about functional programming is it
really says we should favor assignment
less programming if you look at
languages like Erlang for example or
even Haskell well there is no assignment
operator in those languages so when you
in airline especially if you say X equal
to Y it's not an assignment equality but
it's actually a comparison so if it
really verifies that the value of x is
equal to value of y and if one of them
is unbounded it binds it the first time
but another time if it's invalid it
tells you that it's actually you know
not really equal so the question really
is is it practical for us to even create
a program where we can do assignment
less programming well so from the
practicality point of view I want to
really switch gears just something else
from the past so let's think about this
a little differently think about
structured programming for a minute so
what is what a structured programming
espouse it says that we have building
blocks in code we have an entry and an
exit into these structures and we build
applications using these common
structures like for example a if
statement or a if block or a while block
or a do block and so on and function
procedures these are the building blocks
of structured programming but remember
the good old times from structured
programming and I can't think say you
know we probably cannot think about such
a programming without thinking about the
good old Edgar Dijkstra
what did Dijkstra tell us he wrote a
phenomenal paper where he said go-to is
evil and and anytime anyone even thinks
of writing go-to he's he moves in his
grave and and that is basically the idea
is we don't want to be writing code with
go deuce well let's think about this for
a second if I say over here in this
particular piece of code if I were to
simply call bla over here what
that's very carefully what error we are
getting it says blob error not a
statement just leave the thought of
sight for a minute blah is not a
statement on the other hand if I say go
do now look at the error we are getting
Java doesn't say not a statement insert
it says illegal start of expression that
kind of makes you wonder what does that
really mean well what that means is go
to actually is a keyword in Java but
they tell you I dare you to use it so
they want to really prevent this from
using this so they made it a keyword and
then made it forbidden so we don't even
you know use it as a variable name or a
function name ever that's how much they
actually went with the Vengeance to say
we shouldn't use it so clearly you
wouldn't you know really appreciate of
anybody who uses a go-to if somebody
tells you that they use go-to in the
code you're going to distance yourselves
from them you wouldn't call them friend
anymore on Facebook you'll unfriend them
right that's how we feel about it but
the point really is I'm gonna write a
for loop right here and say int I equal
to zero I less than 10 and then of
course I plus plus and in this case
let's do something really simple if R is
greater than 5 then I wanna output the
value of I so nothing really exciting in
this code just a structured programming
well clearly we can all agree that this
is a structured program it's a really a
nice if structure and there a for
structure in there and the main
procedure hey that's just life as usual
in structured programming no big deal
well not so fast let's come back to this
for a second and take a look at it let's
go ahead and say a Java P minus C and
I've already aliased minus C on my
machine so Java PE and let's take a look
at the sample dot class if you will just
to take a look at the bytecode that we
have here and if you look at the
bytecode
there is a beautiful surprise waiting
for us in the bytecode level and notice
what we see right there and you're like
oh my dear god what just happened here
well the point really is go to is like
matches I can bet you everyone if you
have matches in your house isn't it but
you don't go to the children and say
children I'm gonna go take a shower
here are some matches for you to play
with I hope you don't
you that well that's the exact point
Goethe is for adults to deal with it not
for us to deal with in our daily basis
well the problem really is if we are
using go to the court turnin to a
spaghetti code it becomes really hard
for us to work with so the essence
really in this case is that we you know
say we shouldn't use go to but I'm gonna
say go to ease to structured programming
as assignment is to functional
programming and the reason I want to
draw this analogy here is our parallel
here is that we do agree that we don't
want to use go-to but just like what we
saw doesn't mean there is no go to it is
just that you and I don't use use go-to
in our code but there could be go-to in
layers below that we are calling in a
similar way when we are writing code
with assignment less programming it
doesn't mean there's no assignment at
all it simply means that we don't do
assignment in our code but there could
be assignment and mutation in layers
below our code but of course the
question is if we are mutating what is
the problem with that well if you're
mutating in your code describing what
the code is doing reasoning the code
becomes really hard understanding the
code becomes hard maintaining the code
becomes hard making the code concurrent
becomes really hard and and there are a
lot of these problems we run into I
remember one day a developer came to me
and said I've written this code it
doesn't work and you helped me and to be
fair it was not a very large piece of
code it was a function only 30 lines of
code
I quickly I balled it and I said if you
sell this input it should give you this
output is that I know right but it
doesn't so then we both are looking at
it like stupid and going through every
single line and then I asked him the
question hey on line 9 you're modifying
the input variable given to you did you
really mean to do it he stood up for a
second stare at the code and he said I'm
stupid and he walks away this is what
happens when we start mutating code it
becomes really hard to reason leads to
errors and bugs in code so the question
is you know we don't want to do
mutability in our code but is it okay
for mutability to happen in layers below
well here's the beauty if you call a
functional library and if they do
mutability then what happens reasoning
the code is not your problem
it becomes their problem understanding
the code is not your problem it is their
problem and maintaining the code is not
your problem it is their problem and
making the good concurrency is not your
problem it is their problem and I love
that because in life you want to make
things always other people's problem so
this really works really well because
they can deal with it and you don't have
to deal with in your level so I'm going
to say that go-to is to assign
structured programming like assignment
used to functional programming meaning
that we don't do the word I really want
to emphasize here is explicit mutability
it should be avoided so I'm not saying
here that we don't want to do mutability
what we are saying is we shouldn't be
doing explicit mutability in our code it
could happen in a controlled fashion in
layers below and that's perfectly fine
if that's what it's going to do so
having said that let's talk about how we
could potentially remove mutability
one is to really use recursion so we
could receive a parameter into our
function and rather than modifying the
variable we could return a value a
change the value of the function in
memory as part of the stack call into
another function you know really simple
for instance something along the lines
of if you want to call a function called
increment and you are getting a value
let's say five well what increment could
do is take a value but it could return
again and say call increment value plus
one and of course in this case we're not
mutating the value we are just calling
the function by incrementing the value
on the stack so similar to this approach
we could use a recursion to prevent
mutability in a record or avoid
mutability in a record fairly well so
that is one approach we could take the
other approach of course is to remove
the mutability to layers below
in fact in languages like Java this is
while this could be a solution to begin
with it is not gonna scale too well
unfortunately because Java itself
doesn't have tail call optimization
today
and as a result if it is a very large
recursion we're gonna get a stack
overflow error and that's not going to
be really fun so this is really useful
for a very small
limit on the values but not too
extensively but moving it to a lower
level is probably a good idea so what
are some of the benefits of doing it
well this is where it moves towards a
decorative style of programming let's
look at a couple of different examples
of this just to get a feel for it let's
say I want to take a minute to total
values that are in a collection how do
we total values that are in a collection
let's say I have a list of numbers 1 to
10 right here and what I want to do is
to total all the even numbers in this
collection well to total all the even
numbers in the collection first I'm
gonna say into total equal to 0 and I'm
gonna print the value of total when we
are done but what do we do we say far
int I equal to 0 I less than or less
than in this case of course numbers
start sighs and then I will say I plus
plus and then of course I would say if
the value of numbers dot get of I is
even for example in this case he's you
know Mar 2 is equal to 0 then I want to
say total plus equal to maybe I want to
just total the double of all the values
so in this case I'll say numbers start
get and then times to all the double of
even numbers in the collection well that
gives us a result of 60 but if you
notice there is a lot of mutation we do
in this code first of all notice this
poor variable I is not a constant we
keep incrementing the variable through
the loop every single time and so as a
result if you were calling another
function which is an anonymous inner
class scope we cannot pass I to it as
you know because I use mutable so we do
silly things in code something like int
the temp is equal to I and then we would
use temp inside that function in inner
class scope because temp will become a
local variable and we have really
written code like this in Java in the
past quite a bit because of mutability
intervening with what we do and the
second thing in this case is the
variable total if a turn up the volume
of the computer and run the code you
will literally hear the variable total
say out out out on this code because we
are constantly changing that as well by
mutating it well the code worked but
like I said there's a lot of effort to
write this code we have the reason with
this code turning the code concurrent if
I ask somebody how do you make this code
concurrent usual response I get this
laughter like are you crazy are you
kidding with me because it takes a lot
of effort when you have mutability in
code how could we do this differently
after all well the one way to do this is
to start with a you know the collections
and use an internal iterator
so we could say number start stream then
we do a filter and we say give an
element element mark to is equal to 0
and then I can perform a map over here
and then I can say given an element
element times 2 and then finally I
perform a some operation on this piece
of code to get the result so when I run
this code you can see that code produce
the same result as the other one but
there are some really interesting
differences in this code if you look at
this code notice that the imperative
style code was constantly mutating
variables the Declaration and functional
style code does not have any explicit
mutability and and that is one of the
beautiful things about this code I'm
very proud to tell you this code is very
humane no vailable was tortured in the
making of the result for this code so
that's basically one of the reasons why
this is incredibly simple to make
parallel as well if we choose to and
that uses the benefit of avoiding
explicit mutability now clearly in this
case you may argue mutability is being
done under the hood and that is exactly
the point I made earlier is it's OK for
the muta-do to be handled or done under
the hood as long as that under the hood
is a very trusted source where they take
responsibility to say we will do
mutation but we will keep the mutation
localized and we will make it safe for
concurrency without messing with
performance and and
correctness and that's perfectly fine
I'm okay for a trusted source in the
layer below to handle the mutability
similarly this actually becomes a lot
more effective moving forward and I have
to tell you I have seen this code being
written poorly so many times so I want
to emphasize that it is to the point of
being scary I get email almost every
single week from somebody saying this
code worked fine and when I turn down
parallel it's all messed up what am I
doing wrong
so it's a very common anti pattern
people run into let's quickly take a
look at this
so I want to double the values and put
them into a collection how do I do this
so I'm gonna say numbers dart stream and
I'm gonna say dart filter given a number
number mark 2 is equal to 0 and then I
do a map over here and I'm doubling the
value everything went so beautifully
well so far and then probably the
programmer writing that code takes a you
turn for the worse what the programmer
then does this says all right this is
good so far lists integer well it's a
result is equal to you let's say in this
case new ArrayList
and then comes along over here to say
I'm gonna take this resultant say for
each and give an element I want to say
result dart add and put the element in
this and I'm gonna just put oh no right
here because people take pictures and
tweet these days this is dangerous if I
just leave it without the comment
somebody says this guy is stupid is
writing this so I just want to make sure
don't ever do this right so the point
really is this is a terrible programming
practice why well the reason is this
code you may even run this code and
argue it works but I think the words it
works is a terrible choice of words in
English to use when it comes to
programming
I quit saying these days the program
works now I say the program behaves
that's all I can say because I cannot
just predict what the correct result is
but the point really is this code kind
of behaves in one way but the minute I
turn the code into parallel we can never
predict what the result is going to be
there could be raised condition
the code he turns into a disaster so
what do we do to prevent this particular
problem in this code like I said if I
you know go back and print the result
you may even say that the result is
there so it behaves but it's necessarily
not correct in this case so this is
where we would want to change this to
using a collect method for instance and
collect users collectors and in the
collectors of course we would then say
to list for example where we will bring
in the collectors if you will and as you
can see in this case we can run this
right here and this is going to put this
into a result of collectors and we will
instead of assigning it simply return
the result of that into that variable
and we can simply use that in the code
as you can see right here so the point
really is what is the collect net that
really do well the collect method
internally creates a collection but it
takes care of mutating the list as we
did before but does that in a very safe
manner in a way that if you turn on
parallel it will do this with thread
safety as well so you and I don't have
to fight that problem the creators of
the method have taken care of it for us
so this is not only easy and elegant to
write it is also very thread safe for us
to work with so yes there is mutability
in this code but no we don't have to
worry about it
because they took care of the
concurrency concerns the minute we want
to turn concurrency on this that becomes
really easy so that brings up the
question where does this take us in
terms of mutability and to emphasize
this I want to talk about a couple of
different things that are very critical
to think about and that is I want to
talk about pure functions so what in the
world is a pure function well a pure
function returns the same result result
as many times as you call it so it
returns the same result for the same
link port and of course in this case no
matter how many times you call it so
this is one of the features that you get
out of a pure function
a pure function returns the same result
for the same input no matter how many
times you call it so in other words it
has no side effects so in effect you
want the pure functions to have no side
effect but I'm gonna talk about two
rules of purity and this becomes
extremely important as we go forward
because a lot of times when I talk about
these two rules of purity when I mention
the first rule usual responses duh of
course that's obvious everyone knows it
absolutely but it's a second rule that a
lot of people don't think about and I
think the second rule is as important
maybe even more important than the first
rule or maybe they are equally important
as a bare fair way to say it so what is
the rule number one for purity well the
function you would say does not mutate
any state or we can say does not change
anything and of course you may
immediately say duh of course that is
obvious so a pure function does not
change anything and we can definitely
agree to it right away and say yep that
makes sense a pure function does not
change anything but the rule number two
is the function does not depend on
anything that may possibly change this
is a very stringent and very highly
important rule of purity of function so
it's not so here's a slogan I like to
use to emphasize it a pure function sees
no evil and does no evil where I
considered the mutability to be evil
it's not enough that you don't do evil
you should even not see evil so if
somebody is doing something really bad
you shouldn't encourage that either
that's what this really says so
essentially from the purity of functions
you don't want to mutate something but
you also don't want to depend on
something that is being potentially
mutated let's understand this with a
little example while we talk about the
benefits of pure functions and pure
functions have a lot of benefits it is
amazing once we start looking at pure
functions and
good benefits we get out of it let's
talk about some of the benefits we get
out of these the first benefit of
immutability is it opens the door to
reason with the code really well so when
you're dealing with immutability when
you're dealing with pure functions it
becomes easy for you to walk through the
code and describe what it is doing I'm
sure you've done this before right
you're looking at a piece of code it's
so complex and it's mutating every
corner you turn and you try to go up and
down with this function and finally
you've had it you take a piece of paper
you put the variable names on it
you are marching through you're writing
the values and you're holding all that
in your head and while you're doing it
somebody opens the door and says would
you like to go to lunch and what do you
do at that point you just stare at them
and they're like are you ok and you're
not answering you're still staring and
then they say you weird what's going on
and you say look what you just did and
they took all the mental state you build
and by asking do you want to go to lunch
they just shattered it and that state is
all here and now you have to put this
back in your head before you can start
moving forward and you really hate the
person who just walked in well you know
non-programmers never understand this
they come and ask the question and like
you look weird it's like no this is
absolutely torture because we have to
rebuild all the state in our head before
we can move forward and that is the
complexity we have to deal with so when
you're starting to really build all that
state in your head it becomes really
hard whereas a code that doesn't deal
with mutability becomes easier to reason
it becomes easier to understand as well
as we are reading through it easier to
explain but one big benefit is it is
easier to test what a what a beautiful
thought here now if you have a function
you are calling and if that function
changes state constantly every time you
call it it gives you a different result
and how would you work with such a
function well you are saying you know
what I have a function over here f
one I need to call this function f2 but
this function f2 is a complete mess
because every time they call it it gives
me a different result what do you do in
that case well what you do in that case
is a test will call f1 but I will call a
test double or two f2 this is for
example what you use as you know stop
mark etc so in other words when a
function you depend on is in P or you
have to use stubs and mocks or testable
to test that code it becomes enormous ly
complex on the other hand you're writing
a function f1 that depends on a pure
function f2 I don't need to do any
stinking mark objects because every time
I call that function it faithfully
returns exactly the same result I don't
need any marks to work with it and I can
just directly call it and benefit from
it so in a world of pure functions we
actually use fewer of these things like
test double testing generally becomes a
lot easier to work with
and that's definitely a good position to
be in
from the testability point of view
forest so no stub or mark needed in this
particular case because of that
mutability concerns we have well the
next thing is we have a referential
transparency what in the world is a
referential transparency so referential
transparency is a beautiful word but
here's what it means a an expression or
a function may be replaced by its value
art with its value so in a sense you are
trying to say I can take an expression
or a function and I can replace it with
its value so why is that a good idea
well if you call a function and it does
all the work it needs to do to return
the result to you if it can replace it
with the value I don't have to do that
work at runtime this becomes really easy
for us let's take a look at an example
of that just to see how that may work so
I'm gonna say over here let's define a
variable a equal to 1 and a variable B
equal to 2
and let's make these two are as static
variables just for a minute in here I'm
gonna go ahead and say output let's say
seven plus eight just for a minute
look at seven plus eight now seven plus
eight you know seven is a constant 8 is
a consonant plus is a really wonderful
function it doesn't sneak around and
mutate any state so we can say that
seven plus eight is a pure function
there's no doubt about it so we can say
seven plus eight is a pure well if I run
this of course it gives us a fifteen not
a big deal on the other hand I'm gonna
say a plus B now the question is is this
pure well let's apply rule number one
rule number one says a plus B is pure
according to rule one if a plus B does
not mutate or change anything and plus
says I am innocent I don't do any
changes you send me data I'll give you a
result I am done with it from rule
number one if our definition of purity
was fairly limited and naive we would
have used only rule number one and we
will go home thinking this is a pure
function but rule number two says the
function does not depend on anything
that may possibly change well gosh a
plus B both a and B are mutable so this
is not a pure function after all because
of Rule two fails right so fails rule
two and as a result this function is not
pure well you know it but guess what the
compiler knows it as well notice the
result is three I'm gonna take all the
effort to prove to you the code is doing
what you expect it to do so I'm gonna go
ahead and run Java P one more time
notice what we see in this code right
here and right here is the I add
function it loads the field a and B
performs the add to get the result of
add adding a and B and then sends the
result to print and so clearly that was
doing the work however I'm going to now
go back to this code and change this to
final int a and int B now the question
is is this pure and I am going to apply
to number one rule number one says a
plus B does not change anything well
clearly we can agree a plus B doesn't
change anything but what about it does
it depend on anything that may
potentially change well we know that a
and B are final they're not gonna change
and as a result I would argue this is
pure the result is still three but not
only do we know it the compiler knows
this as well and the Java compiler says
aha I could use a referential
transparency at this time so if you
notice over here in the code there is no
longer a DI add function in the pipe
code the compiler generously evaluated
this function replace the function
entirely with the result of that
function we just saw a filter
transparency in action this is a very
simple case if you will but what could
have a language potentially do if it
knows that functions are pure it can
lead to better optimization at the
compiler level so in other words it not
just its referential transparency but it
leads to better optimization and
performance as well which is a great
thing you can expect this also leads to
one other thing which is memorization
this is something I learned when I was
programming at Haskell my mind was blown
I called a function which took literally
fifteen seconds to execute and then the
result came back and displayed I was in
the repple I don't remember quite why I
did it but I just said run it again and
I was going to just relax putting my
hand in behind my head taking a good
break for about 15 seconds but the
second time I ran it it snapped back
with the response I'm like whoa how did
this really run so fast this time when
it took 15 seconds the first time to run
it and that's when I discovered that
Haskell knowing that functions are
really a pure he is performing
memorization and optimization to a great
degree under the hood automatically so
this can lead to that behavior as well
but one beautiful thing is immutability
makes
laziness possible and this is a
phenomenal behavior we can benefit from
when it comes to performance of code
let's understand this with quickly a
little example here let's say for a
minute in this case I want to go ahead
and write a list of numbers we want to
ten here and but in this list of numbers
I'm gonna say 1 2 3 5 4 notice the
sequence but not what I want to do here
is find the double of the first number
greater than 3 and is even so how do I
do this in the imperative style of
coding well in the imperative style of
coding here's what I'm gonna do I'm
gonna write a function for our cells
called let's say boolean Yi is even and
this is going to take a number and all
it's going to do is return number let's
say mod 2 is equal to 0 similarly I'm
gonna write two other functions I'm
gonna write EES is greater than 3 and
this is going to simply return number is
greater than 3 and then of course I'm
going to go ahead and say en double it
and I'm gonna simply return over here
number as times 2 so I've got little
functions that I'm gonna use right now
how do I do this in the imperative style
in the imperative style I'm gonna say
result is equal to 0 and then I could
say far Inc element in numbers and then
of course I could say if element is
greater than 3 and then of course I
could say for the element and is even
for the element then of course I would
say a result is equal to well in this
case double it and then of course I
would have to break out of the loop
and once I come out of the loop I could
simply print out the result I have on my
hand and see what the result value is in
this case it is 8 well we know one thing
about this imperative code while it took
a refer to write it it has got the
performance we need how much work are we
doing in this function we're doing eight
units of work it checks if one is
greater than three it is not and because
of charts are curing it never checks for
even then it checks for two
three all of them are less than three HX
five which is greater than three checks
if it's even it's not then it checks if
4 is greater than 3 4 is even and
doubles it and break so that is 1 2 3 4
5 6 7 8 units of work so the imperative
code does 8 units of work that's awesome
we could be very happy about it let's
write this function in functional styled
instant so what are we going to do in
here I'm gonna then say over here number
start stream and then I'm going to say
dart for each filter rather and then in
this case of course I'm gonna say given
an element I want to ask if it is
greater than 3 and then I'm gonna say
filter I'm gonna ask if it is even and
then do a map over here and in this case
I'm gonna ask you to double the value
and then finally I'm gonna say find
first and get the first value and if it
doesn't exist maybe I'll return a zero
at this point
now when I run this code you can see
that it gave us the same value also but
that begs the question how much more
effort did we do make no mistake if you
look at languages like Python or Ruby or
groovy our JavaScript as the language
itself implements these things are going
to create one collection to a second
collection to a third collection to
afford the collection and then throw
away all those collections the more
garbage you create the more garbage you
have to collect and if you have a very
large collection a million values that
will not be good in performance when you
want a value which you start secured it
but thankfully because of purity we have
a benefit and the benefit is that purity
leads to lazy evaluation so what does
that really mean well in other words
what this means is here's a way to think
about it about stream stream does not
execute a function on a collection of
data instead it executes a collection of
function
on each piece of data but only as much
as necessary so this is a very different
behavior of streams so stream does not
execute a function on the collection of
data instead it creates a collection of
functions it fuses these functions
together those three functions become
one function under the hood and that one
function it executes on every piece of
data but only as necessary to understand
this is really true let's see if we can
you know verify this so I'm gonna go
ahead and comment this out for just a
second right here and what I'm gonna do
here in this code is to say output right
here and then we will say in here you
know is even called let's say and this
is going to be a far and we will output
the number similarly I'm gonna output
over here is greater than called let's
go ahead and say that and then finally
I'm gonna say double it called for it
I'm running only the imperative style
code right here and notice the result of
the imperative style code is exactly
what you just saw here is it calls those
eight functions right there and there's
there's the yeast greater than called
four times Eve is even called after that
and then is greater than called again
that's the output we saw now let's go
back to this functional style code and
see how this is going to work now what
is the functional style code do it is
absolutely lazy in its performance and
when I run this code notice it also
evaluated exactly the same number of
times as the imperative style code did
and that is one of the beautiful things
is you don't have to really worry about
doing all this extra work for it yet it
does the laziness for you automatically
well as a result you get performance out
of this code and that is a huge benefit
so you don't have to really worry about
saying oh gosh I got beautiful elegance
in this code but what about performance
you get elegance and
performance at the same time thanks to
laziness but how does it really relate
to immutability let's talk about that
real quick well the beauty of this
approach though s is very short layered
if we don't honor immutability so to
understand this let's step back and look
at one other example which can
illustrate this problem let's say for a
minute we have again a collection of
numbers and in this case I'm going to
just take a shorter collection 1 2 3 and
what I want to do here is create a
stream we'll say off integer right here
and these integer values I'm going to
say stream is equal to let's go ahead
and say a number start stream dot map
give an element element times two and
then I'm gonna say stream that for each
and we will say system dot out over here
and let's say print line so in this case
of course we're just going to print
those values out and let's look at the
lambda expression right now you would
argue this lambda is pure isn't it how
is it pure it doesn't change anything
and it is not affected by anything that
may possibly change how so two is a
constant yi is the big integer which is
immutable
we are pretty safe right now however I'm
gonna take this code and change it like
this final int factor is equal to zero
now in the sky is equal to two in this
case I'm gonna change this to factor
when I run the code you can see the
result still the question is is this
pure or not well
I just put the word final here even
though that's not needed in Java
eight because in Java eight we call them
effectively final and effectively final
means it's as good as we treated it as
final so here's what effectively final
means Java says you and I have been
going out for twenty years together I'll
trust you so if you don't put the word
final that's fine as long as you treat
it like it's final and don't mess around
so in this case as you can see we don't
have to put final and the code still
works and this is still a pure function
however if you notice over here if I
come in here
once a factor equal to two now for a
minute
I put the word final here and compile
the code error is in line thirteen line
13 says no you don't want to do this
because that variable is final if you
don't put final right here and for just
a minute let me remove this code and and
you can see that in this case I don't
have that code right now and I mutate
this because it's not final I don't get
any errors on the other hand if I were
to write a code like this suddenly you
know this is no longer pure why is it
not pure because e times factor depends
on a variable that possibly changes in
fact it does in fact notice if I put the
word final the error is on line 13 if I
don't put the word final the error is on
line number 11 because Java is trying to
protect you and say you don't want to
really do this in this case because
that's not a pure function unfortunately
Java is not gonna protect you forever
with cases like this this is one of the
differences between languages like Java
and language like Haskell Java will tell
you don't do that and then it will kind
of walk away it would have nag you over
and over language like Haskell is very
different you will tell you don't do it
but then it'll follow you home it watch
you while you're having dinner and say
don't even think about it
so if this is where the difference is in
fact this is one of the things I love
about language like Java language like
Haskell nforce immutability and the life
is very boring can you imagine being a
Haskell programmer you go to work you
write code everything works at 10 a.m.
you take a long let's come back do some
more coding and you go home tired they
say how was the day at work named I did
coding everything worked I'll go back
tomorrow in the case of Java Java is
different because Java doesn't enforce
immutability it just assumes it which is
beautiful because when a language makes
assumptions and when you violate those
assumptions you know who's gonna get
hurt and and you if you code in Java you
late at night debugging this and then
you go home very tired at 10:30 and the
children say wow you're home finally how
was the day let me tell you the stories
we have stuff to talk about now isn't it
so that's the whole point this is really
a disaster in the making why is that so
well as you can see here Java said don't
do this and yes of course we couldn't do
it good news
unfortunately not all programmers are
created equal you know some programmers
at work when you show them that Java
does this they will have this very
vicious villain smile on their face and
they will tell you let me tell you how
to fool Java very dangerous programmers
and they will come with the very weird
smile and say Squire bracket and say
that I would say new in square bracket
and then do just that one over here and
I'm gonna say in this case a value of
two
now I come in here and put a square
bracket zero and then of course let's
just leave it as square bracket zero for
a minute what's gonna happen when we do
this code hey it seems like it worked as
ended but unfortunately this is a
disastrous programming why because if I
change this code to a zero and ask what
the result is the result is gonna be one
of three things somebody would say it's
gotta be two four and six somebody else
says it is zero zero zero and somebody
else says let me think
in fact the first two people also
usually say let me think this is not a
good programming practice in fact I use
this as an interview question I show
this to people during interview and say
what is the result of this code if they
try to answer I tell them you are fired
even before you're hired
because their right answer is are you
all stupid to write code like this you
are hired because I want people to write
code that is easy to understand so we
can actually release production code I
don't want a puzzler but unfortunately
in this code when you run this notice it
gave us zero make no mistake do you
don't think the java didn't care
in this case java actually cares java
said i told you don't do it but you're
not listening but if you really close
look at the Java see you would see Java
see actually shaking its head thinking
who your parents how did they raise you
to be like this so absolutely this is
not what you want to do in writing code
this is really a bad programming
practice because this is impure code
well it turns out that impurity can
cause quite a bit of trouble because
laziness doesn't go with impurity and
the result becomes unpredictable so
don't do this this is a bad idea
this also translates to what if you have
a field within your class and then your
lambda is depending on the field you
could be in a similar situation as well
you have to be very careful about it
well so in other words immutability is
absolutely critical when it comes to
laziness and trying to use laziness
without immutability is a disaster in
the making but not but then of course
you cannot turn off laziness in those
code that's a default behavior in
languages like Java and other languages
too so we have to abide by the rule of
the line and finally I'll quickly
mention that laziness immutability
rather makes paralyzation very
affordable as well because you're not
dealing with shared immutability you
have the safety net of the you know not
having affected by the shared mutable
variables and you don't have to worry
about race conditions in your code that
becomes a lot better for you to work
with so that doesn't really mean that we
have to really deal with total
immutability and practically we can
approach this with their design by
telling ourselves you know maybe we
could use data structures that can
promote immutability maybe we can you
know push the mobility layers below so
we don't have to deal with it and take a
look at data structures that provide a
you know immutable access to those and
evolve in a reasonable amount of time
complexity and space complexity we can
program with those languages like Java
we can also use libraries that are
providing that as well
so in a sense one of the key things to
think about is purity of functions and
we have to honor purity in a lot of
cases and if we don't a lot of other
constructs
rely on that kind of purity and then
without really honoring purity our
programs may end up really producing
rather unpredictable results and that's
not gonna be fun spending the time
debugging that code so your ability
immutability is very critical in the
modern days that we live in and and
those are some of the ways we could
probably focus on achieving it but we
have to be very cautious when it comes
to languages like Java as well hope that
was useful thank you thank you very much
banquette
does anybody have any questions and also
once you exit the room please don't
forget to vote anybody has questions for
banquette please is there a way like a
link where Java could say careful that
was functional and something you should
you should because you knew right really
good question
the short answer is not yet so I think
as time goes on we will have better
tools that can do it but we're not there
yet you know in the past tools like fine
bugs have helped us a lot to find some
of those things and that's kind of where
we need to really rely upon you'd be
ideal if the compiler itself can really
prompt us but you know without that link
tools would be really useful I mean I
don't think we are too far from it
but it's not there yet thank you for
your talk just good question so Joe is
really popular because of gdb C and
stuff so all database calls are immuno
not bu right so how we deal with that
really good question so what I what I
normally talk about is I talk about the
designing functional systems and and I
just throw a little catchphrase for that
I I normally say a circle of purity and
then with a small let's say a pen
a ring of impurity so what I mean by
that is you want to create a circle of
purity and within that circle of purity
you don't do any immutability so this
this is architectural II there's a bit
of a reverse of how we normally do this
we put the database right here and we
build functions around it instead let's
let's reverse it let's put functions in
the middle and let's put UI and database
on the circle the ring so we will do the
immutable immutability enter the circle
of purity but the functional pipeline
keep that pure when you finish it get
out of the functional pipeline and then
do the impurity so the database
operations UI all that I do on the thin
ring of the peripheral rather than
saying I'm gonna do it right in the
middle of the pipeline so think about
the pipeline as a train for a second
when you look at a pipeline when you are
when you're looking at the code which is
a pipeline of course the very short
pipeline but all these dots if you will
so if you were to go through this
pipeline of code if you think about this
is a train you want to get into a train
before the train leaves you want to get
out of the train when the train reaches
the destination you never want to get
out of the train or get into it while
the Train is in motion not a good idea
it's the same way I think about it so
think of it as a train do the impurity
before you get in do the impurity after
you get out but never when you're in the
transit so I design it with things
around it just as a quick side note I'll
mention one small thing one thing that
really excited me and changed my way of
thinking is the language called elma Elm
is a Haskell's intact with a little bit
of F sharp that compiles down to
JavaScript knowing it's JavaScript
that's running I constantly start
thinking about it and I said wow Elm
actually does that exactly they do the
UI on the ferry furrow and then they
push through functions take the result
and do the mutation on the outside so
looking at languages like Elm can give
us a good inspiration how we can
actually do that circle of purity and a
thin ring of impurity that could be a
really good design approach good very
good question thank you
more question well thank you very much
again baby this has been very
enlightening
thank you and again please remind that
let me remind you don't forget to vote</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>