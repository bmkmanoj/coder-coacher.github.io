<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Deep into the IoT trenches: how to build a connected product by Jeroen Mols | Coder Coacher - Coaching Coders</title><meta content="Deep into the IoT trenches: how to build a connected product by Jeroen Mols - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Deep into the IoT trenches: how to build a connected product by Jeroen Mols</b></h2><h5 class="post__date">2017-05-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rZ4b7UxE920" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Birgit make it do it makes it good
morning everyone and welcome to my talk
how to build a connected product I'm
Yahoo moles
I'm Bolton and I've worked on various
connected products before most of them
Phyllis products and currently I'm
working on the coolest IOT system in the
world which is Philips you we already
have quite some amazing use cases that
we support futur we have some even more
awesome features in our pipeline so if
you're interested in helping out
building those we're hiring practically
actually so you can check out our career
page there and if you have any questions
about the stock later on you can always
follow me on Twitter so today we're
talking about connected products and to
set the scene right it's not enough for
your code to work whenever you're
building something that you're going to
ship to users you're going to use it for
quite some time so it doesn't just need
to work it needs to continue to work you
need to be able to handle all of those
legacy cases so it takes quite some good
engineering practices to get this right
now what is actually the challenge in
building a connected product well
imagine if you built simple product like
a speaker everything nowadays has
software into it so even a simple
speaker would have some software it gets
more interesting when you add a
smartphone to the mix because then
you're communicating over for instance
Bluetooth Bluetooth le so there's a lot
more cases where stuff could go wrong
the downside still is you cannot really
control your product fiery internet
because the product doesn't have any
connection to the internet so if you
want to support that
you need to add Wi-Fi connectivity and
suddenly the Wi-Fi router comes into the
mix and while you might think like yeah
so what it's just a Wi-Fi router well
that's not really true because there's a
lot of crappy writers out there
we really don't handle your connection
as well and they also may not support
every technology like for instance UDP
multicast those could be troublesome in
the field but yeah only connecting your
product when you're
that's boring so you also want to add
your own back-end so you can all allow
out-of-home control and yeah if you
really want to have interesting use
cases you could consider adding a bridge
which is an always on always connected
device for us for full of you we
actually are bridging technologies for
bridging from Wi-Fi to Sig V so we need
to have this excel as a bridge but it
also simplifies our Wi-Fi setup
it adds simplicity security we can run
automated katene routines so home
automation scenarios and more stuff like
that so adding a bridge of the long run
could be an interesting approach but
yeah you're not aiming just to build one
product you're building a system right
so after a while they're going to add
similar products or completely different
products yet still some way we are the
other you need to be able to support all
of that via one entry point into your
system for instance your mobile app so
there's hardware diversity to take into
account but not just over there also
your bridge could fyf I could have
Hardware diversity we for instance have
two different bridge versions because we
needed to support apple homekit
and apparently asking users to solder a
new ship into their existing bridge
isn't really a good uux so when you
launch new bridge and there could be
other cases to control your system like
why a SmartWatch or any other
integration you can imagine a cloud to
cloud integration and other connected
product in your home so this stuff gets
really really complex really really fast
and to make matters worse for Phillips
you if it's even more complex because
every single part in our system is
software updatable so you can have
different software versions plus we not
just have power devices you also have
battery-powered devices so yeah if you
add all of those things up it's
challenging to build a connected system
to me the main challenges are how to
make sure that users still understand
what you're actually doing so how to
make it understandable for users and
obviously also how to make sure that
your system works and works slow at the
first place and how can you
No all of that diversity all of that
legacy how do you handle that how do you
cope with that so this is basically what
we're going to look at in this
presentation only the last part the
handling diversity and legacy that's
such a complex and broad subject that I
won't be able to cover it completely in
this talk so we're just going to touch
base there okay so first things first
how to make stuff understandable for
users now I guess this is the single
most important thing if you're building
a connected product it's making sure
that users can actually set it up they
go to the store they buy your shiny new
products for instance a speaker but how
on earth can you connect the speaker to
your Wi-Fi network it doesn't have a
display so you cannot select which is
the SSID of your particular home network
nor does it if aqui board so you cannot
enter the Wi-Fi password yet users need
to be able to get it set up because if
this doesn't work yes that's a returned
product because users are completely
lost so this is the crucial aspect of
your system how does that work typically
you'll ask the user to do some kind of
interaction with the product so press a
button or first time following it up and
that's going to make sure the product
starts its own Wi-Fi network a set up
network typically an insecure network
the phone can then switch from your home
network to the set up network and send
over the SSID and password of that home
network then the product switches back
to your home network the phone does the
same thing and if everything goes well
then you're successfully set up sounds
easy enough now if you look at a
practical scenario how for instance
chromecast does it the first thing that
you should notice is that it's a lot of
screens and that's almost always the
case like that setting up a product is
quite a tedious process another we user
is technical most users actually aren't
technical so you want to really grab
their hands and step-by-step guide them
to it so same for the scroll past how
does it work
first they ask you for your location
permissions well this is odd I just
sort of a product but you need to be
able to scan for Wi-Fi networks around
you and to be able to detect products
and because you could implicitly locate
somebody based on our networks that are
around them you need to ask for location
permissions then you actually scan for
devices around you and once you find the
device here the chrome grass for two for
four then you're ready to actually start
setting it up so the first step is
actually to connect to do another the
network of the chromecast so now the
chromecast has open up set up network
and the phone is going to connect to
that Network by the way network
connections are rather slow so if you
need to configure a new network and swap
to it via an app that could easily take
like somewhere between ten to thirty
fifty seconds if you're unlucky on
Android you can do this in the
background automatically on iOS you
cannot do this on iOS you need to ask
the user to basically leave the app go
to settings and then select the Wi-Fi
network and get back to the app so
that's yeah quite tricky for users
because once they leave your app they
don't have any context of what to do
anymore so you might already lose them
there but imagine if you get connected
to the chromecast then you optionally
could confirm that this is actually the
chrome crafts that you want to set up
and not one of your neighbor you could
give it a name and enable some other
options and then we get into the really
interesting part which is telling the
product which network it should connect
to and this is where it goes wrong in
99% of the cases because I don't know
about you guys but my Wi-Fi password at
home is rather random and have you ever
tried entering like 20 random characters
on a very small keyboard that's not a
fun experience especially if you need to
swap from alphabetical keyboard to
numeric to simple keyboard back and
forth back and forth it's really a
tedious process and it's even worse
because if you enter the Wi-Fi password
we can't simply do a simple rest call to
see if that was the right password we
need to actually ask the product to
disconnect from its set up network try
and connect your home network and only
even that fails then you would know if
the boss was correct or not and that
could easily take around a minute
so it's a complex thing to do and the
feedback loop is really really long so
this is where most users yeah simply
don't make it through an additional
aspect of this by the way is that a lot
of people simply don't know that they
have a Wi-Fi network because typically
your telecommunication
telecommunications provider just comes
to your house install some kind of
router sets up all of your products and
then a lot of users don't even know that
they have Wi-Fi let alone that they have
a Wi-Fi password so also that could be
problematic here now good news at least
for Google and Apple they have a
solution around that so Google they're
able to autofill the Wi-Fi password for
you and guessing the tech specs that
they are fetching this out of your
backup so your Android backup letter
just fetching the Wi-Fi password from
their Android this is slightly
differently but they also don't need
this step but these solutions aren't
open to all of us so if we want to build
something like that you need to ask the
users to enter the password
so once the password is entered your
Chrome crafts are going to try and
connect your home network your phone is
going to connect back to your home
network and if both of them succeed boom
you're ready to go so it should be clear
that this isn't a simple thing to do
because entering the password is
problematic like I already discussed but
also switching those networks it's very
very fragile that goes wrong in more
cases than you might think I'm going to
show you a diagram of all of the bad
weather scenarios later on that's not a
fun thing to build and then even if the
switching goes well some phones avoid
networks if they don't have internet
connection which a setup network by
default has so then they would yeah
every time you try and connect to them
they they would just disconnect
automatically or also your operating
system your Android OS could simply
refuse to write a direct your traffic
over that network so yeah if you would
now look at the bad weather scenario so
this is when we in 2011 originally
designed the
I set up slow these are quite a couple
of screens to build and it doesn't even
yeah take into account every possible
thing that could go wrong so it's really
really tricky to get this right
but you must get it right because if you
don't it's a return product now an
example of for instance how an operating
system change then because also the
operating systems on your users phone is
going to change how that could affect
your Wi-Fi set up flow so Android 5-0
decided to do things differently before
if you will be connected to a Wi-Fi
network without internet then Android
would just don't care about it and
redirect every request over the wife and
network as you would expect but starting
from five that one higher they decided
to be a bit smarter so if your Wi-Fi
network would have poor connectivity but
you would ever working 3G 4G connection
why wouldn't you route everything over
that connection so they started doing
that and then you may say like yeah but
they're smart enough to see if this is
an IP address on your local network so
then not reroute that traffic right well
actually big words so suddenly Wi-Fi set
up completely broke theirs luckily your
way around that so in a presentation
there's going to be sometimes a bit of
code I'm an Android developer so it's
typically going to be Android but it's
mostly to give you the gist of things
that could go wrong and that you get the
general problems so you need an API
check then you can ask like hey I want
to use a Wi-Fi network so you make a
network request and you ask for a Wi-Fi
network
you also connectivity manager hey I need
to use this Wi-Fi network let me know
when I'm ready to use it and then
unavailable you could start using it
this is if you want to do it for one
request but you could also do it for all
requests which is exactly the same the
only thing that changed is that an
unavailable you bind process to the
network and then every subsequent call
you would do would go over the Wi-Fi
network okay so if this Wi-Fi setup is
so problematic aren't there any good
alternatives yes there are and probably
the best one is just to have a product
which is hardwired to the Ethernet cable
to your router
that's what full of use does but like I
said we need to do it because we need to
bridge from Wi-Fi to ZigBee but also
other products like saunas also used to
do that for the longest time there's
also this technology called WPS Wi-Fi
Protected setup
does anybody know about that yeah so I
see a few knots but not even the entire
audience well this used to be like the
Silver Bullet you just press a button on
your router you press a button on your
product and if you would do that in a
particular time frame then both of them
would duel
Wi-Fi password exchange and it would be
connected well besides that technology
being plagued with many security holes
it actually also not every router in the
field has it and if a router has it the
button always looks differently and many
people don't know that they have a
router so it's somewhere tucked away in
their metering cabinet so people simply
can't figure it out WPS
so it's basically a broken promise what
you good to whatever is instead of using
the Wi-Fi network which switching Wi-Fi
networks is fragile you could send over
the passwords and the SSID in a
different way like riah NFC or high
frequency sound which is really really
cool that's also what they use not for
the Wi-Fi started but what I use in the
chromecast by the way because high
frequency sounds that's like the knife's
tendency that it doesn't travel through
walls so you have the impulsive security
that only you're sending it within your
own home and they use it for a
chromecast guest mode by the way and
then the last alternative is to use rack
I think it's wireless accessory
configuration which you can only do for
home kit devices and in order for that
to work you need to have an apple chip
in your products but if you have that
and for all your users that will be a
non-issue because Apple takes care of
that for you okay should you go with the
approach that I first described a very
simple pro tip is make sure that all of
the products have a random setup SSID
because otherwise if you're debugging
your product are you testing it out on
your work floor multiple people can be
doing this set up at the same time or
somebody forgets to put their product
out of the Wi-Fi setup and then you're
going to the set up in your
the original products are setting up
extremely annoying been there don't do
that
and even the chrome glasses they just
offend a couple of random characters
through their setup name okay now so
user experience first part Wi-Fi setup
that's covered now good versus bad
further scenarios we're going to look at
another setup flow this is nothing to do
with Wi-Fi setup but this is basically
we're commissioning a new product into
or already connected system in September
we launched a new motion sensor and if
you want to add a motion sensor to your
system what you basically have to do is
users need to pull the battery lives so
the motion sensor gets activated and
then it starts searching for a network
to join then you need to tell the bridge
to look for that motion sensor once it's
found it you select what room you want
to use the motion sensor in and then we
set up everything for you
so in essence this is like a super great
experience right because you users
select a room and depending on that room
we already select the right default the
right time on the right settings the
start end times and so on we program the
dynamic behavior so during the night
your lives will only go on them during
the day they will go go on full
brightness only if if it's dark enough
in the room stuff like that we do all of
that heavy lifting for you but that's of
course in the happy case in the bad
weather scenario you could be looking
for a motion sensor and not find anyone
or you could find multiple ones or what
if you find one and then your phone runs
out of battery and it just shuts off so
then you're left in an inconsistent
state because you have a product added
to your system but it's not configured
same for room selection there could be
no room in your system or another app
could be removing those rooms as you are
selecting them or the type of the rooms
because we rely on the type of the rooms
to give you the right defaults you could
look at the icons of the room so the
living room and the dining room could
have a different icon but users might
have missed that and just only change
the names of the room so also the dining
room could actually be a living room so
then they would get the wrong settings
and of course from programming we
already can think of all the things that
can go wrong Network croquettes that
failed your which could be full we're
relying on timing so what is the bridge
reboots somewhere or crashes and it just
needs to reboot it doesn't have an
internet connection will it then still
have the right time internally to
trigger those kind of things so many
many bad weather scenarios I'm just
listing a couple of those here but the
entire gist of it is it's nearly
impossible for you to reproduce those
manually and even if you could it's
impractical because it's so many of them
and you always need to make sure that
you're able to cover regression so you
need something that scales better so
what I would suggest is that you build a
simulator not like a system simulator so
that you actually have a separate
application running a LAN laptop which
are connecting to to be able to simulate
all of those things we actually have
that within you that also has these
benefits but just something very very
simple built in into your product itself
so in our case to be built into the app
itself and that could then just provide
us with hard-coded responses simulate
dynamic behavior and also make sure that
you can reproduce this bad weather
scenarios a very simple way of doing app
because it sounds hard but it isn't
because if we're building a product like
we described before you already have two
ways of communicating to that product
you can either locally on the Wi-Fi
networks and direct requests or do
something over a restful api of your
back-end server so you need to be able
to switch between both of them anyways
so you need to set some abstraction
which could very well be a strategy
better so why not add a simulator
strategy a very very simple class and
you just hard code some of those things
in there and then for instance the
dynamic behavior I could very simply go
down there that if I open up my app and
it's a debug build that it just starts
shifting the UI from red to green to
blue to red to green to blue so that you
have some dynamics to look at very
simple and works very very well
a pro tip to end of this section is
don't talk about devices because
the device any single one of those
things could be a device so it's better
to use the term product so you're
explicitly stating like we're talking
about the speaker or about the bridge it
sounds simple but the terminology could
get quite confusing so next up is making
sure that your system actually works and
that it's performance now first of all
the discovery so imagine if your
products are actually connected how can
you find those back hey you open your
app or a desktop application you need to
look for the products you're actually
able to communicate with well basically
if you open up the app or the controller
then you need to do two things you need
to know which are the products I can
talk to root remotely and which other
products I can talk to locally so you
need to run both the local and remote
discovery local discovery works fairly
simple it's typically multicast base so
your phone would send out a message like
hey I'm looking for products which are
able to do this and those products would
either reply directly to the phone like
a hear em or they would also broadcast
the same thing typical examples are SS
VP or mdns as fallback so what you could
do is you can do an IP scan so you just
yeah take your soup nuts
see all of the IP addresses which are in
that range and then one one by one try
to connect to them which is very
brute-force mechanism it does work but
it consumes a lot of resources and it is
slow or you could ask the user to enter
a manual IP address or and this is
actually quite an interesting approach
is to have some kind of proprietary IP
server so what you can do with Philips
you is you can Shaw just call this link
so on any device on your laptop on your
phone to the manor and it will return
you all of the products which are
connected behind your external IP
address so this is a very simple way of
getting the IP addresses of all of the
products on your network and the real
interesting thing about this is that
this is besides the manual IP the only
approach that actually works in a web
app so that's also one of the main
reasons why we build this
remote discovery is different but yeah
as you would expect so your phone
communicates with your back-end server
there's some authentication there it's
on the server which other products I'm
allowed to communicate with because it
cannot yet the server knows about all of
the products in the entire world but the
user isn't allowed to simply control
those so there's some kind of implicit
comes security there the server returns
these other products are allowed to
connect to and then the phone could just
start connecting to them now one
important thing here is before this can
work you need to have set up your
product locally because it needs to be
able to contact your backends regularly
to tell the backend like hey Here I am
this is my IP address so let's now look
at a very simple app where we actually
try to optimize this and make it as fast
as we possible K possibly can the worst
case scenario is when you call start an
app so you completely kill the app and
then you start it from scratch yeah you
have no idea where the user may be so it
could be either at home or it could be
at work so you don't know which products
are going to appear locally which remote
and yet you want to make that super
super fast for users well the first
approach would be like let's see if the
app starts let's simply look for all the
products that are local look for all the
products at our remote so we start a
local and remote discovery once we found
those we're going to connect to them
which is nothing else than just fetching
their latest states so we can show
something meaningful in the UI and once
we have that users can start controlling
them that would look something like this
the app starts we see a spinner were
searching for devices we found the local
ones the remote ones likely later now
we're connected to the local ones and
our connected to the remote ones so
works effectively but it's rather slow
so another great user experience even
more imagine if for some reason you
can't find any products at all your
screen would be empty which really sucks
from user point of view so how can we
optimize this well the most
straightforward thing to do is simply
store the products in a database if you
store them in a database
yeah you still need to run your local
and remote discovery because you don't
know their IP address or their
connection state to connect to them and
you also still need to fetch their
latest states because yeah otherwise you
can't display something in UI so
basically this is as slow as the
previous mechanism only it looks nicer
for a user so we start we can
immediately show something meaningful so
the user sees their previous products
and then you have to wait longer now
we're connected to local ones connected
to remote ones and we're good to go
a small interesting thing about this is
that whenever you start storing devices
in a database or products in a database
you also need a way of deleting them
from a database so now suddenly you need
to build some kind of management in your
app so let's take it a step further I
already hinted at it let's also save the
last state in the database so if you say
the last day then you're assuming that
when you start your apps that your
product is still going to be in the same
state so then you can just already show
it as that and only when you know how to
connect to them so you only have to run
the discovery because also discovery
users could start connecting your
product so if you look here app starts
we're assuming that the devices are
going to be in that state who are going
to discover them so we can allow
connection and then users can start
controlling them this was really really
fast this mechanism right the
interesting part is if you looked at the
kitchen speaker dairy actually made a
mistake because if I run this animation
again you would see that we are going to
assume that the kitchen speaker is going
to appear online as if it were on but in
reality it was off so we connect to the
kitchen speaker so we run the discovery
we know how to connect to it so the user
could start controlling it from now but
then slightly later we discover that
it's off and then your UI is going to
flip back this may seem a bit odd but
actually it isn't all at all because in
reality multiple users could be
controlling your product at the same
time so this use cases or UI certainly
updates without you interacting with it
that's going to be a valid use case
anyway so UI is instant ready and you
can allow control off the discovery so
now we're two three to four seconds
optimizing this further is also storing
that connection state in the database
and then you're just being really really
aggressive you just remember that SSID
of the last Wi-Fi network you've seen a
product on and the IP address on that
network and you're just when you start
the app you say like I'm going to assume
that the app is still connected that the
products are still going to be connected
like that and the users could start
controlling the UI immediately I don't
care because everything is going to
solve
afterwards so then you just open your
app and boom everything is there you
could still make a mistake like with the
kitchen speaker but then that would
update later on so all you need to do
for that is remember the IP address and
the last SSID okay a prototype to wrap
up this section is so basically your
product could be in three connection
States it could be connected locally so
you need to communicate with it over a
Wi-Fi network
it could not be connected at all or it
could be remotely connected and
typically for both the local and the
remote connection you need to run some
subscriptions so you get like the latest
events on the product so you always know
it states well a very simple way of
simplifying things is not allowing the
transition from locally connected to
remote connect connected immediately
just always push it through the
disconnected States from a user point of
view they're not going to see it because
yeah in your java code is going to run
really really fast but from the number
of states you have to properly handle as
a developer it gets a lot easier depends
a bit on your architecture so so control
speed how do you make a product work
fast so basically the first things you
can do make sure that you always use the
local connection make sure that local
connection is really really fast reduce
the amount of requests you do and also
do some UI tricks to make it look fast
for a user and if you look at this then
you may say like huh why are we only
optimizing the local connection and that
because there's because of two reasons
one you always want to use your local
connection if you can because your
remote can
that goes over your server so that has a
got a cost attached to it so it's simply
cheaper to use your local connection and
- yeah if I'm out of our home who cares
that your products respond a bit slower
so if I tell my life to go off and I
need to wait for that for five seconds
to happen if I'm not at home I don't
care
well actually also for you that's not
true anymore because we do
cloud-to-cloud integrations for instance
at Amazon Alexa so then suddenly the
remote licensee does get important but
when you're starting to build a new
product chances are that it isn't at the
first day so let's look into those so
you should prefer the local connection
fewer help it helps it's always going to
be faster you have this cost saving and
you need to make sure that with the
Wi-Fi set up I discussed that sometimes
you need to force the connection so also
here that's the same story so how can
you prefer the local connection or
remote one if you go back to our
strategy pattern we can throw a
composite pattern in the mix and what
you then basically do is the composite
strategy would have an ordered list of
three strategies and we just try all of
those strategies one by one so it would
just ask like it's a simulator strategy
available no because it's not a debug
build okay it's a local strategy
available yes okay let's use that one
and then the remote one will only be
used as the local one it's not available
very simple again very effective then
optimizing local connection I'm not
going to cover this in detail basically
use okay HTTP and make sure that you use
all of the data compression cache
headers and that you reuse sockets if
you want to analyze in depth the way
that your products communicate with each
other your app communicates with your
product you can use Wireshark to do that
with that we were able to successfully
like remove UDP TCP interference but one
pro tip about that is in this set up
wireshark doesn't work because what your
product sends to your phone that's a
direct connection between product and
phone let's not get that doesn't get
sent to the laptop so if you want to
sniff direct traffic between two things
you need to do a little trick which is
basically add to Wi-Fi networks and then
put the help in between so then Wi-Fi
network a would send everything prior
the hubs the Wi-Fi network B and help
but also make sure that all of that
traffic ends up at your PC PC not really
hard to build but it could maybe help
some of you reducing the amount of
requests here you basically you have to
take two main things that you want to do
if users do these toggle sequences like
on off on off on off on off on off you
don't want to send every one of those
requests because they are just
meaningless all you want to do is you
want to make sure that you've sent the
last one and that ends up in the state
that the user actually requested the
last time so that's one case you want to
cover the second case is imagine if I do
multiple actions on my product at the
same time for instance with lights you
could turn them on set the brightness
set the color and do some other stuff
yeah if possible it would also be nice
if you could yeah I combined all of
those actions in one request well again
there's a very simple way of doing that
what you could do is simply add a hash
map and then the hash map you would put
the key values that you actually put in
your JSON so the key would for instance
if you set on it will be key on and then
yeah the value of is on so if users
would now present yeah president but on
in your UI multiple times then yeah the
key is always going to get updated and
hash map but ash map can have this key
only once so you would only have one
value 13 in the hash map what you also
need to do is every action you do you
need to make sure that that's also sent
to your device so you call center update
which simply tells the strategy ok to a
new request to the strategy you could
then pass the same object over and over
again for instance an update request
object which basically as a get
attributes method and what it does here
is it takes all of the values from that
hash map and clears it again you need
some synchronization in order to make
sure it's thread safe but the really
cool thing here is then the strategy
could simply have a set which is the
queue which
only contain every object once and then
all you need to do is you can always
just add a request to the queue it will
only be once in the queue and then
whenever the strategy has time to
execute that request it would
automatically combine all of your
requests make sure that the toggle
sequences are gone very simple way again
- yeah to solve this problem
it's all of you currently yeah we do
more complex stuff so we've built an
entire active fuel management system but
yeah
this would be a really good way to start
if you ask me then your instant UI so
have a look at the left and the right
app they basically do the same thing
they can like a loudspeaker if you press
the play button on the leftmost app yeah
then it's not going to change States
until the product is actually
acknowledged the request stopped playing
and sends back like and now in the past
state so you press the button and
there's a big delay between play and
pause on the right hand side that
doesn't happen you press the button and
it immediately flips to the past state
without waiting for the product to
respond so this is a very simple way of
making it more attractive to users they
also very cleverly do this animation
where you rotate from a play to a past
which also then covers part of the time
it takes for a product to actually start
playing which one of these would you
prefer as a user the right one right and
the only tricky thing about it is that
when you're assuming that your request
is going to be successful but yeah your
request should be successful no because
if that doesn't all true then probably
there's something wrong in your entire
system and you need to fix the bug there
so you can make this assumption by the
way in practice the leftmost app was a
lot faster than the right more steps and
actually putting the player to pass but
the rightmost was a better experience so
final product here if you start
optimizing the amount of requests that
you do and that you like cleverly
combined requests and you don't send
toggle sequences as a developer you may
have this reflex like yeah it has both
the codes it works well put a proxy in
between
and we'll talk again after I've I fell
into the strap myself a lot of times
already only when you really yeah debug
it see what's actually happening only
then you can make the statements so last
part handling hardware diversity and
legacy yeah so developing a system
imagine we're going to develop a new
system we have a team for developers and
every feature that you build exactly
takes one developer for one sprint so
the first print we're going to build
three features okay but the next sprint
assuming that we have for instance 10%
maintenance on every feature we would
also have a bit of maintenance for the
previous features and the next sprint
because the maintenance is recurring we
have a bit more maintenance and a bit
more maintenance
so r2 for Sprint suddenly the fourth
developer is also completely booked so
we have to drop a feature otherwise it
doesn't sit and sprint anymore and if
you scale this and you scale it further
then you see what's going to happen
after a while you cannot build any
features anymore you just stop
innovating so how can you find that the
true cost of software I hope you all
know that is in its maintenance you're
basically trying not to shoot yourself
in the foot in the future but then
reality you're going to shoot yourself
in the foot anyways so we just want to
be you want it to be your small toe and
that's our entire fault right so focus
on automated testing take time don't
just do unit tests I hope everybody is
doing unit tests is that the case so
everybody writing unit tests
I see no hands at all so let's assume
that's good sign also write integration
test for every single component in your
system on the component level so by that
I mean isolated as a component so you
don't want to do any networking there
and then add integration tests for your
entire system end-to-end that also
includes very very basic stuff like a
signup flow where the user creates a new
account and then get the email back to
come
ferm that the counters created that's
also a flow you would want to automate
because it's just so tedious to test and
you want to have some kind of automated
way in place to be able to capture that
because all of those cases they're only
going to increase increase increase in
the future and yeah you need to be able
to scale up so you need to have that
under control so need for a good
architecture is key and what I want to
make there yeah very explicit is like a
good architecture isn't an architecture
designed by somebody who wrote the
design we wrote or who read a design
patterns book and then just implemented
those patterns for the sake of
implementing it a good architecture is
something that looks the way you expect
it to look looks ingeniously simple and
I gave a couple of examples about that
hopefully in the past couple of slides
but it's something that is also easy to
scale so over-engineering also has a
tremendous cost attached to it and then
an interesting business think well
before we introduce a new feature
because once you introduce a new feature
taking that away from consumers that's
not really an easy thing to do and
people nowadays have many many different
channels to be vocal and so they are
also actually quite focal but on top of
that the flip side of the coin is
they've bought your system and they're
also continuously expecting new features
so you need to be able to walk this line
by choosing the right things to build to
make sure your customers are excited and
happy but also to make sure that you
don't introduce something which you may
regret later on so that's a fine line to
build and even at philip view we
sometimes still on the learning curve in
order to get that right so team wise
focus on co-located teams developing a
system and like you see before you have
software in the bridge in the product on
the back end in the app maybe have an
sdk all those kind of things so you need
to have a lot of interaction so if you
add an extra time zone into the mix or
an extra location maybe an extra JIRA
board all of those things just
complicate matters so try to avoid that
as much as you can and also yeah but I
think as a developer we all know that
things don't need to be big to be
effective usually smaller teams can get
more done than bigger teams then I'm an
app developer so one of the challenges
that we have is like if you build an app
you typically don't build one app people
that Android and iOS apps so then how do
you maintain consistency between both of
them because the iOS app may program
something into the bridge and then the
Android app need to be able to read it
out and understand what it is that's
ridiculously hard to get right and even
if you manage to get it working then
later on you're going to refactor and
improve your code so it needs to keep on
working which is even more challenging
and if you're launching a new feature or
a new product because you want to cover
all of the things you've mentioned
beforehand make it easy for users make
sure it's performant you are not going
to get things right from the start you
will need to try something out test it
with users reiterate and probably you
need to have a couple of reiterations so
don't start developing features on two
products at the same time so on the iOS
and Android up at the same time because
that's going to be a lot of waste it's
better to just take Android leading for
feature a and then after five iterations
when you think you got it right then iOS
can catch up and the other way around
that's going to be a more efficient way
of handling it I'm Leonard developer so
I also have some Android tips free silly
but a bit for I fell into early on is
trying to detect if a Wi-Fi network
could have an internet connection which
you can do by the way but you run into a
system timeout at the NS timeout which
you can upset and which is rather high
so trying to simply ping google.com yeah
you need to wait for 30 or 45 seconds
before that would actually give you a
result and then all the gold you need
around that to be able to make the
proper conclusions that just makes it
impractical and a benefit you get out of
it is simply numb so don't try and do
that it's just it's not worth it run
your tests in the JVM then they're going
to be superfast if you build a new app
make sure you prepare for orientation
changes from the start
you don't you really don't want to be
adding all of that code if you already
have like sixty eighty hundred hundred
twenty streams and if you yeah listen to
all to my presentation you're going to
end up at that many screens because as
many times in your app you need to guide
the user very gently throughout the
entire process to make sure that you can
actually do the things he wants to do
and then another one the final one I
want to touch one is like make sure you
tightly control your treading and
notability have one line in your
architecture everything on top of that
is going to be on the UI thread
everything below on the background
thread and just pig-pig that as a rule
it may seem obvious but I don't want to
tell you how many code bases I've seen
where they're simply running stuff on
the UI thread because they don't know
which trail is on they're also just post
on your iPads or do on background tab
type they don't have any control about
that threading so make a clear line
solve it there and then threading is
never an issue for you anymore and same
goes with no ability I'll actually wrote
through potentially interesting blog
posts for you like how to make your unit
test awesome and also why your app
should actually crash by crashing it's
not always a bad thing
okay so let's wrap things up so I
already mentioned this but your design
choices now are going to bite you back
in the future and it's typically going
to be earlier than you expect them to
return so if I if there's a few things
that I want you to take away from this
presentation is that developing a
connected product is hard but developing
a system is even harder maximize your
local connections try to get the most
out of those keep things simple for
users and really focus on the automated
testing and make sure you get your
architecture right the key is typically
also in the people making shortcuts is a
very very painful thing to do when
you're building a connected system okay
the image credence I didn't make those
images myself and then basically that's
it so thanks for attending my talk I'm
Daru malls quite eggs on Twitter and
also actively write a blog so feel free
to follow me there are there any
questions yes yeah so what we currently
try and do is keep our teams between
five and seven people I think maybe even
slightly smaller than five between four
and seven people I think seven is
already quite big I would actually go
for like four or five but the amount of
yeah the challenge and also building an
exciting system is that you have a huge
backlog of things you actually want to
build so then in that sense you need to
make sure that you can have the right
throughput first still the efficiency of
the team so to be honest that's also
something we're still balancing a bit
with and then seeing how well it goes
but I would say five yeah
because we have to take walls
yeah so the question was like how well
do connect systems basically work in
practice because your Wi-Fi signal or
whatever communication standard you use
as like limitations through some walls
it cannot go well that's a bit of a
difficult answer to that's a difficult
question to answer what I can say is
like we've had in the past for instance
with an air purifier we had issues where
yeah if you would be in like Amsterdam
in the Netherlands the density of Wi-Fi
networks around you could be so crazy
high that the product simply wouldn't be
able to index them all and then your
network you would want to connect them
to it yet it would fall off that list so
those kind of issues they are real and
they are also very painful for users
because there's no general
one-size-fits-all solution for that so I
think that's something that we as an
industry are still learning on how to
combat that and now we can better deal
with it you know where for instance the
Google proposition the Google Wi-Fi
proposition where you can buy like a
Wi-Fi router which comes with three
atoms to make sure that you properly
cover your Wi-Fi network for Phillips
you fortunately what we have is we have
a mesh network so ZigBee mesh is further
so you just need to make sure that you
have a bolt in between bulbs so then you
can hop over one bulb to the other and
you can infinitely expand your network I
think that makes your system
significantly more reliable but then
still on the Wi-Fi side if your Wi-Fi
wouldn't reach as far and until you with
the fish issues there so it's a complex
and painful thing
would influence you you mean yeah so the
question is like if you want to know in
the field of all their connection is
order any yeah
protocol wise support for you to be able
to measure that and to be able to keep
the bookkeeping of that to the question
right well actually I haven't gone as
deep as nuts so I wouldn't know but from
top of my F and can't really I wouldn't
really be able to pick out a thing it's
also IOT is a very broad range because
yeah
what is IOT for instance we use the
ZigBee network but you could be using a
Wi-Fi network or a Bluetooth Ali network
or and then the solutions per network
layer are probably going to be different
because blue totally the characteristics
are significantly different than a mesh
network obviously yep
yeah so that's a very interesting remark
so the question is like instead of only
using Wi-Fi to set up a product what if
you were to also add Bluetooth so then
you can yeah keep an open connection
while the product is actually swapping
Wi-Fi networks so then you would have a
better feedback well that's super
interesting idea and what has
historically held that back is the bomb
cost because if you add an extra chip to
your product yeah you also need to pay
for it
so that would increase your selling
price so historically the bomb costs are
salted back but if you look very closely
at what now a lot of chip manufacturers
are doing they're increasing their
integration and then many chips are
becoming gumbo chips they would have
like maybe a Bluetooth and Wi-Fi
combined or maybe even Wi-Fi and ZigBee
combined
so in that sense I think looking forward
the economy of scale is probably going
to make sure that that also that that
becomes more of a reality but then again
also if you yeah yeah okay then you just
need to handle a Bluetooth connection
it's probably going to make your life as
a developer also easier but then you
need to have more firmware development
in the product because you need to so
everything comes to the conference so
our times up many many thanks for
attending this talk hope those
interesting</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>