<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Dockerize user stories with Mayfly by Maarten Dirkse | Coder Coacher - Coaching Coders</title><meta content="Dockerize user stories with Mayfly by Maarten Dirkse - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Dockerize user stories with Mayfly by Maarten Dirkse</b></h2><h5 class="post__date">2015-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cHU8yEV8FwQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay let's pretend all that never
happened not convincing anybody my name
is Martin de Dixon I work for the
bullpen school volcom and I want to tell
you about may fly today project that
we've been developing internally at the
bull for a close on a year and a half
now we've been sort of telling people
about it to see if what we're doing
excites them or if they think it's
really boring or if they think it's
really not the way to go and so for
those phones been pretty good so that's
why I wanted to tell you about it today
first of all a little sort of the the
sentence that it says in the package may
fly is a docker based user story
centered development platform written by
and in use at bolcom what all that means
i will explain in the moment first i'm
gonna give you a little bit of
background or rather tell you what i'm
going to talk about the background why
did we develop this platform what does
it do for us what problems does it solve
what are the principles behind it so
what are the sort of core ideas behind
the the actual platform going to give a
small demo yeah if the the demo gods are
our gracious to me i'm going to dive a
little bit deeper into a bunch of the
aspects of the platform and finally I'll
tell you a little bit about the state
that it's in at the moment internally at
the company and what we have planned for
the future so
a little bit about my the company I work
for bull calm we are the largest online
retailer in the Netherlands and in
Belgium we have in the IT organization
which is about roughly a quarter of the
entire company 42 scrum teams and it
seems like there's a new one every week
but 42 at the moment with about five to
eight people on a team and it's usually
multidisciplinary so there's database
engineers and and Java developers and
information analysts and some people
that do all those things we have a
pretty strong from culture we we did
like a sort of cold turkey migration to
a scrum process in 2009 and we've been
using it ever since we've we've done a
bunch of bull specifically highlights 2
2 the whole process but scrum is really
ingrained in our DNA as an IT
organization we've got a landscape
behind the web show behind the web site
itself of about 130 different services
and applications most of them are like a
java database combination there's
there's a bunch of sort of exotic things
written in go or javascript other things
but most of it it's java and finally we
have a deployment model which is like a
mix of a four-week sprint and which
everything gets deployed in one big bang
and there's a whole bunch of teams now
that are starting to experiment with all
kinds of continuous delivery
methodologies and I to enable that is
one of the reasons that we develop
mayfly so why did we develop mayfly we
had we had the following problem or the
following situation we have four teams
let's say and they're all developing
their user stories ural developing on
the master branch and there are
deploying their applications their
services to the shared test environment
and this this model is a model that was
actually prevalent within bullet come up
until not that not that long ago so what
happens and oh and we have a shared
Jenkins environment where everybody
builds their code so everybody's working
on this on this
big shared test environment where all
the code gets tested and where all the
code is to a large extent developed as
well so what happens when we have a
problem in one of the user stories did
everybody see that little lightning I
can I was worried it might be too small
but does that come across yes excellent
are you all awake because I hear I
literally hear like absolutely nothing
okay and I can't see very much either
okay so what happens when there's a
problem one of the user stories well if
the code is broken in some way that is
that is still broken but not broken
enough to actually break the build then
it gets deployed on to the test
environment and that service could be
broken in some way and that service is
now in use by the entire organization
everybody testing on the test
environment is now using that broken
service so what happens is the other
teams that are dependent on the service
get upset because it's broken someone's
deployed broken code to to the test
environment and then usually what
happens is the team that deployed the
broken code gets very nervous and starts
sweating a bit because they have to
either roll back the code but then they
have to make sure that nobody else
depends on their new features or they
have to fix it as fast as possible with
in any case until it gets fixed the test
environment is degraded for everybody
that's using it and because it's a
central test environment everybody uses
it so we we took a look at the situation
about two years ago when we thought well
wouldn't it be nice if we could give
every team and perhaps even every user
story its own environment so you go to a
situation where you have a production
environment you have a team that
develops user stories they develop that
user story on a separate branch and the
indigent repository they have an
entirely separate bunch of Jenkins jobs
that build that specific branch they
have an entirely separate isolated
runtime environment that actually runs
that code as if it were a test
environment or that it is the actual
test environment except that they're the
only ones using it and then finally when
it's done that code gets deployed
directly to production so
no intermediate test or acceptance or
integration environments just tested an
isolation develop it in isolation
accepted in isolation and when it's done
deployed directly to production wouldn't
that be nice because once you do that
that team can develop several stories in
parallel and in fact multiple teams can
actually develop multiple stories in
parallel and once something goes wrong
one of those stories see a little
lightning icon something went wrong one
of those stories and that code gets
deployed the only thing that will break
is the actual runtime environment for
that particular story it will not break
anything central anything shared and so
all the other teams will not be impeded
by the fact that someone has checked in
some broken code and once you do that
oops once you do that you can actually
scale to a X amount of teams X amount of
stories because an X amount of
applications because nobody will ever be
in a situation where they impede other
teams from doing their work as you as
you would have with a shared test
environment so that was the idea and
that that was the idea behind mayfly and
that's what we set out to achieve that
in a bunch of other things that I'll
tell you about in a moment that are also
very important but this is the the main
problem that we set out to solve so some
of the central concepts behind may fire
that the user story should be the unit
of work so like I said we have a pretty
strong scrum culture within Bowl and the
user story itself is like the the most
atomic piece of work that that is that
exists within mayfly and because
everybody uses the the more or less the
same scrum methodology it fits we can
tailor it pretty well to sort of fit our
way of working and we drive the workflow
from JIRA so setting up this isolated
environment making the the branches etc
etc not something you have to do
manually it's something that should be
done automatically by the mayfly
platform using events that are emitted
from zero because deer the issue
management system we use is where you
keep track of you know which stories in
progress in which story is done etc etc
we wanted to give our development teams
as much control as as possible over the
entire process so we used that we
decided that the the sort of basic
building block would be a docker image
we don't care what happens inside your
build as long as it produces a docker
image which we can then run and because
a darker image can run more or less
anything you can do whatever you like in
your project and we can still work with
it in the mayfly platform gives
developers a lot of control over how
they how they build their apps and how
they want to run their apps we use
feature branches and pull requests and
we also have mechanisms where these pull
requests can be accepted by the the team
that has operational excellence over a
particular service so that no team can
change code in a service that is not
theirs without the team for that is
responsible for that service actually
approving it knowing about it and not
only doing a code review so not only
looking at the code and saying well I
guess it looks good to me so why not
merge it but also having the entire
build build CI pipeline and a running
environment that ensures that stuff
actually works before you merge it into
the master branch so before you make it
before you push it to everybody else and
finally we use Jenkins to do to do must
for builds or to almost all of our
builds and there's a great plug-in
called the job dsl plugin which lets you
script Jenkins so the generating job or
configuring jobs that are so there can
be something you can do automatically
and we actually spawned completely new
Jenkins jobs every time a new user story
is created just to make just to give it
this isolation from everything else
give every user story an independent
runtime environment for developing
testing the Sutton so that's really
important everything that you do on a
user story that when you when you start
in a used Orion application you should
have your own runtime environment where
that version of the application is
running that you can test that you can
access that you can run your automated
tests against and that you can even go
to the business and say hey this feature
I've developed this feature on this
environment here could you please go
there a check that it's to your liking
and then accept it so that we can take
it to production that's obviously a
challenge because we don't want to stand
up the entire bowl that come landscape
for every single user story that would
be very beautifully expensive in terms
of resources so there are some tricks
that we did to to make that work and
done as in the scrum definition of done
like a story is done when it when it
satisfies a bunch of requirements should
mean that it's ready to go directly to
directly to production so there
shouldn't be any sort of intermediate
environments that it is first has to
pass through no like performance testing
you should have to be done no other kind
of testing on some separate environment
where a whole bunch of stories are
aggregated no done means deploy it so
this is what mayfly does peruse the
story you get a feature branch in source
control and currently we use git and we
use stash as a repository manager you
get a continuous integration environment
which is just a bunch of jobs in Jenkins
that are generated for you according to
your own job dsl specification you get
an isolated production like runtime
environment which is essentially a
darker cluster running your application
and then you get an automated definition
of done check so definition of done is a
scrum principle which is essentially a
list of requirements you have to satisfy
before a story can be considered done
and I don't know I mean if you actually
use scrubbing your day-to-day work what
you might recognize the phenomenon where
you get together have a meeting you
define your definition of done and you
feel really good about yourself and then
you put it in a drawer somewhere
wiki page somewhere and then six months
later you think yourself time we had a
definition of them we should really
update that thing you never look at it
in the meantime that's the experience of
a whole bunch of teams within Bowl and
we wanted to give people a win to give
the teams a way to actually
programmatically define the bunch of the
requirements that have to be satisfied
for a story to be done and then have to
platform check those for every commit
that gets done in a particular story
obviously that means that you can't
define really fuzzy things like you
can't have a definition of done rule
that says I should feel good about this
change because there's no way to
quantify that but stuff like the
coverage must be exactly the same as
before for the unit tests or the
acceptance tests must must pass or
someone from team a must approve this
change that's the kind of thing you can
actually put into that definition of
done and I've get checked on every
single commit on every single story logs
and metrics so just the the sort of
standard infrastructure we have for for
all of our stuff also gets tied into
these user story environment so you can
check their logs and their metrics for
those particular versions of the
applications that you're developing and
finally an optional per user story
database that gets provisioned along
with the actual user story specific
service that you can use for testing or
just running your application okay demo
time
so I had this all set up in the night to
restart my computer so bear with me for
one second
that does not bode well one second
well I have no internet connection at
all which is
so what I'm going to show you is I'm
going to develop a story on a test
project that we have that we use for
occasions like this I'm going to run
through the entire cycle of spinning up
the user a specific environment and then
developing the story making some changes
in the code seeing that it gets deployed
to the environment and then actually
merging it back to production or in this
case not actual production as in the
bulacan website but production for this
test project of course none of that will
happen if i don't get a network
connection
you might wonder why I'm looking up
there and sort of down here because that
part of the screen is nicely on the
screen
yeah okay
ok
alright so we go to JIRA now I can
actually look here again and we go to
the project that we're going to actually
modify something I'll just increase the
size is just a bit so it's easier to see
so the first thing we do like I said the
whole thing is tied into the giro
workflow so the first thing we have to
do is create an issue so we're going to
create a user story because like I said
the whole thing is used to rebased
devoxx demo and then we actually created
a plugin for jira to to give us a bunch
of added functionality that helps with
instructing the mayfly platform as a
witch source control repository should
be used for a particular story in this
case it's the it's this little CD
application field right here where I
will choose the demo project and then
create the issue so let me take a look
at the issue and then the other thing we
did with it with a plugin is provided
bunch of actual extra panels in the in
the actual user story or in the actual
issue view so we have here assets which
is empty because we don't actually
create any assets like a runtime
environment or Jenkins jobs for user
story unless it goes into the to do
stage instead of the and so that we're
in lesson goes into in progressive to do
rather and then we have the definition
of done which it which it gets from the
the master which already has a
definition undefined and in this case
there's a whole bunch of unknowns
because we have net bird any builds or
there's no environment up and running so
it the only thing that it knows is that
the the feature as now because we
haven't actually made any changes it is
up to date with the master right so we
start progress
and that'll actually trigger the mayfly
platform to to provision a whole bunch
of these resources which will appear in
a moment and in the meantime I will show
you
meantime I'll show you the Bulldog home
stash server and
so this is the repository for the for
the project which contains just a normal
it's just a normal Java project with a
great old built and it has only one
specific thing for the the whole mayfly
platform which is this folder called
flywheel and in there is a bunch of
stuff that I talked about earlier for
example you have your DoD XML file which
I will also increase in size slightly
this is an XML file where you can
actually define the DoD rules that will
be applied to every commit on your
project so in this case we have we have
one that simply called unit tests rule
which means that the unit tests must all
pass otherwise the definition of done
isn't satisfied someone from this list
of people must approve the change
otherwise the definition of them isn't
satisfied and we've actually made it
extensible so the teams can write their
own rules so if a team were to say I
only want to deploy stuff on a Wednesday
they could actually write a rule that
enforces that on a platform level
wouldn't be very practical but you could
do it then we have the project up dsl
which is essentially the the definition
for the bunch of Jenkins jobs that will
build the project not quite as clean of
a DSL as it as we'd like it to be yet
but gets the job done so if you're
familiar with the job dsl plugin this is
just a basic job dsl groovy file or a
groupie code and rather and then finally
we have the service descriptor and
service of scripter it actually contains
things like you know what's the project
called how many resources should get
when it gets deployed to the cluster
should we a should we deploy a database
alongside the project so that it can use
the database different configuration
things that that we need to in order to
actually deploy to the cluster
effectively so you can use the project
to do useful work so now if we go back
to the if we go back
if we go back to the assets tab here
you'll see that the whole bunch of
assets appeared and for example the
logging asset is just a link to our
internal logging infrastructure where
the logs from this particular user story
environment end up the branch is a link
to stash to the particular branch that's
been created specifically for this user
story the pipeline asset is a link to
the Jenkins jobs and finally we have the
application which is linked the actual
running instance of the application for
this user story so let's take a look at
those things real quick so the stash
branch is the branch is actually called
the same thing as the use as the issue
key in JIRA that's what we use to
correlate all the different pieces of
information so right now there's no
there's no difference between the the
branch and the master because we haven't
done anything yet the pipeline has also
been created it's on a three Jenkins
jobs which of which the build job is the
actual one that will build the build the
project when we do a commit so it's like
your normal CI work for you do commit
the system notices does it build pushes
the new artifact which in this case is a
darker image and then finally we have
the actual application running here so
the application itself and I should warn
you you have to brace yourselves because
it's quite something to behold
if it works
it's
alright
there should be dragons and dancing
ponies but apparently maybe not today I
don't know any case it's a really simple
project just to sort of demonstrate the
the entire process I should note that
along with the this version of the
project we also have a version of the
production a production version of the
project running which simply lives at
the the username so this is this is the
original version shall we said this is a
version we're modifying in a and a
specific user story environment and when
once we complete the your story and and
move the code to production or it will
actually change this page so this is a
different page a different service a
different running instance from the from
this one and this is the this is the
actual instance where you do your
development so let's do that now well
let me let me make that a bit bigger not
with the equal sign but with T ok so we
we go to the DP IT project we do a git
pull and then we see that the rather we
see that the actual feature that for
which the branch was created by the
platform gets pulled in so it has the
same it has the same dirac key as the
issue that's like I said that's how we
correlate everything so if we then go
and actually change something
and in this case will change just the
the index page and we'll change it from
the company at which I gave the last
demo to deaf ox and then in the actual
body itself will change that device oops
device so let's close that so now we
have we've got the change will commit it
yeah oh that's an excellent point get
check out so we do the deep end epi if
you can t
yeah that's a good point we should
actually check out the branch itself
before we making you so go back and peek
at what the actual issue key was 5697
alright 5697 so and then we solve the
change excellent let's see oops
like I said
if I also forget how to type it'll
become really difficult and so we've got
to change I will commit it so and then
we'll push it and once with you that the
the build job will kick in and will
actually start a new build so you can
see from the logs here it's just a
normal Gradle build with one added thing
and that at the end of the entire bill
that actually produces I or it builds a
new docker image which it then pushes to
the internal registry which son gets
deployed and that's it's just a simple
sort of docker extension to Gradle that
we that we cut it up which is it's
pretty easy to do and you can see here
that actually makes a new docker image
and will then push it out to the
registry at which point this is the
platform will deploy it to the user
story environment
so while we're waiting for that so if
you go here to the so the branches and
stash you can actually see that the the
branch for our story has been created
here and then if you go to the pull
requests you can actually see that the
pull request which takes the code that
we've modified in the branch and applies
to the Masters also been automatically
created and not only has it been created
but it's also been because we have this
rule and the definition of done that you
have to approve it there is an approve
button here that you ESU you have to
actually take before you can before it
can be merged now I realize I'm
approving my own change and you might be
wondering how does that work it's just
because otherwise I would always have to
have like a colleague somewhere in the
back approving my changes if we actually
close that particular security loophole
so that's why that works but it's just
the demo so so the bill is a success
then we go to the to the actual user
story environment which is this and I
should be getting any moment now
sometimes it takes a while to deploy but
I should be getting hello dev ox instead
of hello world and you can actually see
because the the actual deploy is done by
marathon oops which is a marathon as I
kind of like a past layer on top of
mesos which actually deploys docker
containers so if we go there we can
actually see the
in the myriad of deep EIT containers
being being deployed but this is ours so
it should be finished here we go okay
we've now changed the user story
environment and seen that deploys works
everything is cool now we go we go back
to the lagera issue and we go back to
the definition of done and now we see
that everything is is all right
everything's past us has passed the bill
grant has passed the current feature
branch is up to date with master that's
lunch it's pretty logical because we
haven't done any other changes and the
branch should deal the veiled artifact
that actually runs and which has been
which we don't which I demonstrated just
now so actually it delivers a working
artifact it's also really important one
of the rules you can actually turn off
because of the risers you know what's
the point the only thing that hasn't we
haven't done yet is proved to change so
let's go ahead and do that approve so we
also built a plug-in for sash which does
this kind of which notifies the platform
the mayfly platform with these kinds of
things like approvals of code and which
helps in various admin functions that we
built that we need in stash to actually
work properly and then if we go back to
the definition of done and we refresh it
everything's past so it's picked up on
the fact that someone's approved the the
code so now that we're happy with
everything we say resolve in JIRA and
once again we get the definition of done
so we can check everything's all right
if something doesn't if something
doesn't satisfy earth if some part of
the definition isn't satisfied you
actually cannot resolve the issue so you
cannot commit stuff that doesn't satisfy
the definition of done and
when we resolve it'll actually merge the
code into master it won't actually
rebuild the artifact because we we
ensure that any chain the only change is
between the the user of the story branch
and master are the actual changes in the
story branch so it takes the darker
image that created for the story
environment and deploys that to the to
the production environment because
that's that would be the exact same
thing as building another darker image
based on the on the master branch what
it does do is it cleans up a whole bunch
of stuff on the the various places that
we've created stuff so if you go to the
the branch overview here you see the
branches actually is gone and then if
you go to the Jenkins jobs you'll see
the Jenkins jobs have actually
disappeared as well this is the used
story environment that's been cleaned up
and then if we finally go to the
production environment where the code
should be merged and the demo gods are
gracious to me and
took a while in the user environment as
well so there we go right so that's the
entire life cycle you know I always feel
so ambivalent about when people clap
about that but people clap when I show
this because on the one hand it's nice
to get some sort of recognition for the
fact your demo works with the other hand
it's like you set the bar so low like
i'm here to show you something and then
it actually what I'm what I want to show
you works and then you clap as if you
were expecting than not to work kind of
I don't know gives me really ambivalent
feelings about the whole thing but I
enjoy the applause nonetheless right so
I just showed you the entire life cycle
of a story we get a separate separate
isolated container containerized
environment where you can actually do
your development you can also do your
acceptance you can say to your business
you refer to come to hey look it says
dev ox now is that cool yes let's cool
okay so we can deploy to production
everything separate for that user story
alone which is exactly what we set out
to do so I will I will reload this
presentation because I didn't have
internet apparently
alright
so I will tell you a little bit more
about the architecture the architecture
which has all kinds of nice icons in it
but yeah that's a good point let's try
that
sorry about this we just
never installed Linux near Mac only
leads to problems
alright so this is the end this is the
internals of the of the project now
there we go this is the internals of the
project it's the platform itself
consists of a bunch of micro services
that do different things like actually
create the environment in marathon for
you talk to stash create the database
create database containers that actually
give you your database which you can
work with in user story environment
instrument Jenkins talked to giro etc
etc and so this this all lives sort of
outside of those those components and
but it runs on top of on top of a
marathon so Mason's is a way to
essentially take a whole bunch of
computers and make them into one big
computer a marathon is like a pass layer
on top of that and then we use docker to
actually run everything this is when we
first did this it was pretty
cutting-edge now it's more or less
pedestrian because everybody does it
like that but it works so it's cool and
then we have an internal service called
triangle which we developed which
actually does database for visioning for
different kinds of databases so the
branching model and one of the one of
the important things that we have to
actually ensure is that we never get
merged conflicts between the different
stories as they emerged production so
the way we do that is as follows so we
have the master branch for every project
then if someone starts developing a
feature he actually branches out from
the master branch adds a couple of
commits there's a pull request and
someone does a someone checks the box
that it's okay and then it gets merged
but what if at the same time someone
else is actually developing another
feature and that person actually
finishes that feature before the other
guys finished with is so now the gorge
on CC e23 actually gets a will get a
merge will get a merge error will get a
merge conflict if by chance he has
edited some of the same code or he will
be behind master in any case if he tries
to do this pull request here so in order
to prevent that what we do is every time
a story is closed we take the code from
that story so the code the difference
between master and that story and we
push it out I said push that we push it
out every other open story at the same
time so that guarantees two things one
that your that your feature branch will
never be behind master and two that any
merge conflicts that arise from the fact
that you have different code in your
feature branch will have to get solved
not unmastered with on the feature
branch that means the master is always
deployable which is really important so
then George can fix whatever merge
conflicts there are and then finally
when the system goes to merge when the
platform goes to merge the actual code
from his branch back to master it'll all
work so that's how we ensure that
everything is always up to date with
master and we can merge any given
feature branch to master at any time
automatically by which I mean when you
click resolve in JIRA stash will
actually do the work for you you don't
have to view yourself another thing we
always try to sort of explain is why we
have no integration environment and when
we first started talking about this or
where a lot of people that said I need
an integration environment and actually
I forgot to do the little animation
where it shows up when you hit the space
for because there's a lot more dramatic
when you know no you don't pops up but
we don't actually think you need an
integration environment and why is that
well or to be more precise we don't
think it's worth having an integration
environment so let's go back to the way
that that we internally at bull used to
develop software we had this four-week
cycle where every team used to work on
their code for four weeks and then
finally deliver a new version which will
get deployed to the acceptance
environment and finally to production so
if you look really carefully it's like
the most subtle animation or subtle
change in slides ever but you can
actually see the versions running
through from dev to production that's
the way it used to work now if you want
to move to a more continuous delivery
style of delivering your applications
that means that all those teams will get
a chance to choose their own rhythm of
release and if you still want to keep
this integration environment
what is an integration environment well
integration testing on integration
environment is essentially testing a
known combination of services for a
particular amount of time if you don't
know what you're testing you may as well
not test it so you have to know which
combination of versions you are testing
for any particular set of time in order
for your integration test to make sense
that's important now let's say you move
to a continuous delivery model and every
team gets the freedom to choose whatever
cycle they want so the first team is
still in the four-week cycle the second
team decided to go to afford a cycle the
third team is a nearshoring to earn is
an offshore team in Guatemala and they
have the Mayan calendar nobody knows
what the hell they're doing but they're
releasing and the last team just
releases whenever they feel like it they
have no schedule so now you go to your
integration tests because you still want
to do that you have to lock the
integration testing environment in terms
of what versions are on that environment
for a particular amount of time to do
your testing because again if you don't
know where you're testing you might as
well not test there's no point in
testing unknown versions of our known
combinations of application versions
what that means is that for as long as
you're doing your app your acceptance
testing your integration testing those
teams that are on a schedule that is
actually faster in terms of releasing
features then you're then the duration
of your acceptance tests or integration
tests will be stuck so let's say your
acceptance tests or your integration
test takes five days for instance
because you have really complex
performance tests or whatever that means
that three of the four teams will
actually be stuck in their deployment
they can't actually deploy new features
because they have to wait for that
exception says to finish you've just
created a huge bottleneck in your system
if you want to give your team's the the
possibility of actually releasing stuff
on a schedule that data side so then the
question becomes what's the point of
integration testing if what you can test
can change at any time and what's the
point of integration testing if it means
blocking all those teams that want to
deploy on the schedule that you own
control
so then we say well there is an
integration testing environment that's
already out there that you have to
create and it's called production and
it's really cool because it has all this
production like load and production like
data and you can actually it's it's
usually the most well instrument in a
monitored platform in the entire
organization so what we what we decided
to do with mayfly and in getting rid of
the integration testing environment is
to say okay if you define if you have
the service-oriented architecture with
well-defined interfaces between the
different components then we think it is
worth the risk of occasionally finding
bugs in production which to be honest we
you do anyway and we do as well in order
to get this extra speed for those teams
that want to release at their own pace
and not do this integration testing step
so it's a trade-off and and the
trade-off and as far as we're concerned
it is or is more positive when you say
get rid of the integration testing
environment and actually do the
integration testing itself or the
integration testing that you want to do
on production and do as much sort of
isolated testing as you can before you
actually deploy to production but don't
do integration testing that make sense
yes no
so what's the current state of the
project all right we've almost gone GA
within within the company itself we're
signing up more and more teams to
actually use the mayfly platform it's
really important to the to the team that
I'm on the team that's actually writing
the platform that we don't have any sort
of company-wide edik that says you must
use this platform we want to eat entice
people to use it and if we can't then
that means there must be something wrong
with the platform we have really robust
support for Java services and their
databases not you might say well it's
just a docker container that comes out
of the build why is the support for Java
more robust and other things is because
of the Gradle plug-in and the
integration we have with that it's just
easier to do a Java project than it is
to do a ruger project for instance
although Ruby budget be that much harder
it's used by 12 teams internally and
obviously we the team that's developing
they fly use it as well to actually
develop the services that make up the
platform so the future better monitoring
and alerting of the platform itself and
to this end where we're pretty far along
and sort of doing a proof of concept of
a tool called prometheus which is a
really nice new monitoring tool built by
the guys at soundcloud better service
discovery support right now we use
consult sort of wire services together
but we don't use it to the full extent
that we actually should so there's more
work to be done that and that respect
multiple applications for story
environment right now if you launch a
story environment you get one
application when you're working on we
want to make possible for people to
actually launch two applications and do
the entire orchestration thing with the
source control management etc etc with
two applications simultaneously for
those those occasions in which you
actually need to develop a feature which
has so much code in both services that
you actually need to coordinate that a
little bit better than just developing
one part and then developing the other
in sequence actually deploy form a
flight to production so the platform
itself at the end point right now is the
our own test platform which is which is
still good because the
a test platform gets a lot more stable
than it used to be when everybody was
developing directly on the test platform
but we actually want to deploy from a
flight directly to production but that
has all sorts of other problems like
actually getting the operations guys to
support darker and production etc etc
and finally we want to open source it
you might have been thinking this is all
well and good but what the hell does
this have to do with me well we're going
to open source it so you can use it to I
used to I used to promise like we're
going to open source by the end of this
year but I yeah I can't really promise
that anymore the only thing I can
promise that we will open source it and
it won't take a year I hope that's it
there's a there's two websites you can
check out the the mayfly CD website is
actual information about the project
itself the the information that we've
published a couple of presentations that
we've even before and then there's a
bull come get up account which has a
bunch of other projects as well and
because we paid for this presentation I
should say we're hiring if you want to
come work for us work on stuff like this
please see me or come to our booth later
alright any questions
yes
right so the question is what does it
take what would it take to run a local
local may fly behind your own firewall
it's essentially the the the
architecture of slide I showed earlier
essentially you need a mesas cluster you
need marathon running on top of that and
you need console and that's it and that
may sound like a lot but once we open
source it will provide a really easy for
example docker compose script or a
vagrant environment in which you can
really easily test this and good
documentation s how to set it all up so
as long as you have the the baseline of
marathon and may sauce and console
things will basically work and the
mayfly itself will will make sure that
every part of it is running and
configured correctly yes yeah sorry you
yeah yeah
because he's been up
mm-hmm yeah
I guess there are multiple stories
develop
yeah yes so the question is if you spend
up an environment for every user story
doesn't mean you spin up a lot of
environments and doesn't that become
prohibitively expensive yes we spin up a
lot of environments but because we use
docker an environment is essentially a
database process and a java process
that's it and so you could you could I
guess do the same thing with VMs but
that would become really resource heavy
but that's exactly why we chose to use
docker because it's darker is nothing
but a sort of wrapper around a process
at the OS level so a new environment and
in the case of the the story or in the
case of the service I was just the demo
service is just literally a new Java
process and you can pack a lot of those
on to modern servers so yes we start a
lot of environments but darker makes
that fairly feasible and not too
expensive yeah
stories at the end
mm-hmm yeah
right
that's running but
certain if you push it
yeah so the question is if you have a
lot of stories being developed
concurrently then and you have code
being merged into the different story
environments their code being merged
into master and back out to the stories
you should have a a good way of seeing
that nothing is broken apart from just
the stuff compiles and that that it at
that deploys exactly that's that's
absolutely true and this ties into the
whole integration testing on production
that I talked about earlier you have to
have a pretty comprehensive suite of
tests on the API level on the functional
level for your service that should pass
before you actually mark your story as
resolved so that's the whole sort of
Amazon way of development like
everything every services every service
has it as just an API that it publishes
to the outside world and every other
service within your company should be
treated like an external API that's the
kind of yeah the kind of model you
should adopt if you want to use this
because exactly because it precisely
because we're going directly to
production the guarantees that you want
from from your user story environment
should be a lot more or a lot more
precise rather than the ones that you
get from the test environment if you
know that you're still going to
integration so that's part of the
trade-off of dumping the integration
environment and going directly to
production that you have to have a
pretty comprehensive suite of tests to
actually test your service before it
goes to production
yeah right it breaks unless you have
what we have internally which is a rule
that you must support one major version
backwards compatibility for at least six
months so you have to work around it but
we think so you have to there's a whole
bunch of stuff you have to do also an
organizational level in order to get
like the full benefits of this model but
once you do that it becomes pretty
powerful and it's so I'm convinced that
if you if you want to have a large-scale
software deployment of something like
the Balch on web shop which has 130 plus
services you're pretty much going to be
forced to move to that model anyways
because otherwise it just once skilled
within your IT organization and may fly
is just a way to may fly supports that
model fairly well all right anybody else
okay thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>