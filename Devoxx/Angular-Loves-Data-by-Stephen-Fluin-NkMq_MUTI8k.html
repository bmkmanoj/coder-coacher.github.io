<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Angular Loves Data by Stephen Fluin | Coder Coacher - Coaching Coders</title><meta content="Angular Loves Data by Stephen Fluin - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Angular Loves Data by Stephen Fluin</b></h2><h5 class="post__date">2017-04-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NkMq_MUTI8k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so this talk is angular loves
data my name is Steven flowin I'm a
developer advocate on the angular team
and Google so I submitted this talk
after attending at dev X or dev ox
ve and I gave a presentation there on
mobile and there's a really good
response to kind of seeing how and your
manifest in different areas of the the
kind of the development of world and so
one of the areas that I really feel is a
strength for angular in an area that we
have to deal with a lot as developers is
this concept of consuming and using data
that's coming into our application and
so I wanted to talk about some of the
ways that angular interacts with that
but just to make sure we're all starting
kind of on the same page angular is a
platform that makes it easy to build
applications with the web and I use a
couple of those terms very specifically
in terms of I use the term platform
because we're really trying to move
beyond just being a framework in terms
of really owning all parts of the
developer workflow from creating new
applications Deponia data to testing and
all that I also use the term with the
web very intentionally because while
most angular applications are built and
consumed in a web browser that's no
longer necessary so if you compare in
your jeaious to the older version to
angular we are now Dom independent and
so you can actually run angular in a lot
of very interesting places such as in a
web worker or in a service worker or
even server-side using angular Universal
um so we started getting to know some of
the crowd over here but maybe I'll just
do a quick poll here how many people
have written something in angular so a
version 2 or later ok so it's almost you
guys so if I go too fast feel free to
stop me if I go too slow just to feel
free to come up and kick me and say hey
I already knew that the agenda for today
is gonna be relatively brief so we're
gonna go through the component model
that was an angular that's it most of
you've already written in angular I'll
keep this very short and also talked a
little bit about reactive programming in
rxjs with an angular then I'll Drive
into firebase which is a really good way
to pull in real-time data behind your
application then I'll move on to graph
QL which in the real world ends up
solving a lot of problems that
developers face and lastly we'll talk
about a Redux style pattern
from a library called ng rx so starting
off with angular component model most of
you've written angularjs applications
starting with one v in angularjs and
with every version of angular after that
we really recommend that everyone build
applications in in terms of a component
model so instead of a scope and
controller now everything in an
application is a component so if you
look at this sample superhero cape store
that we've built or not really built
here you have a lot of products you're
selling you've got details about that
content whatnot but it's actually all
wrapped into an app component so this is
where your application lives in his
bootstrapped within there you got for
example and have component maybe you
have a sale component then you can have
like multiple instances of a product
component and then components are very
often and almost always nested so you're
gonna be composing additional components
so for example within that product
component you might have a button
component and every component under the
hood is simply a set of HTML a set of
CSS and a pure es6 or es2015 class
though lets you define the functionality
and the behaviors and the properties on
that class so when we look at kind of
our angular application we really think
about it as a tree of components and so
if you contrast what we did in angularjs
from a change detection standpoint where
what we did in an Gorge as the old way
was we would basically evaluate all of
the expressions throughout your entire
application and then we would do it
again and see if anything changed and
then we do it again and see if anything
changed and we would do it until
everything's settled because we didn't
have a very concrete or firm way of
knowing what things might have side
effects as part of running your
application but where's now that in
angular we've moved to this component
model we can be absolutely certain there
should never be a side effect from any
of your change detection on the rest of
the tree and we're so certain of that we
want to help developers ensure that that
in development mode so which is what
you're normally developing and when
you're in that dev loop cycle we
actually run change detection twice and
if anything changed we're gonna throw an
error and say hey this is not valid
you've done something wrong and we throw
away that second change detection cycle
in production the kind of core of what
ends up taking this data and this
structure and then making it something
that's can be renderable or viewable
within a browser or whatever
- it's all about our templates so they
they start with HTML then you add in
custom components custom directives
these are things that you're building
all the different components in your
application or any components you're
pulling in from third-party library
we've got square brackets for property
binding you've got parentheses for event
binding you can combine them if you want
double binding and then lastly we have
expressions and pipes so one of the
important things that you really have to
start to understand when you're using
angular's we've eliminated about 40 or
50 of the directives that existed in
your GIS so in angular almost everything
is either the property or event binding
or one of these built-in kind of
structural directives or a structural
directive that you built yourself and so
these are directives that allow you to
create and compose templates in a very
kind of natural way I don't give a few
examples of that and then the most
important thing that I've used in terms
of the the built-in capabilities when it
comes to expressions is this ability to
have custom pipes that do something
interesting with the data in your
expressions and so this is a pipe a sink
is how you're gonna see it so if we look
at an example of this that's gonna use
both the ng-if and the ng for structural
directives at the top you have an NG if
user list pipe async and you're actually
gonna see a little bit of version 4
syntax here so now we've added to the ng
if structural directive the ability to
save out local variables so you don't
have to repeat over and over and over
that async pipe we can actually save the
results of that async pipe locally then
we have the user profile which is could
be a custom component underneath that
and I'm gonna iterate over that with the
ng for structural directive and I'm
gonna say let user of users and then
I'll pass in by a property binding the
user that I got from that iterator and
then I can use that local variable to
pull out the link and then I can also
for example create an NG template and
call that loading and then use that
somewhere if I wanted to
when we run change detection under the
hood in angular as I said it's it's a
single pass across this component tree
but we even take it a little bit further
in order to help developers have really
well performing applications so the
first default mode is every time a
change detection happens we're gonna
evaluate all of your expressions that's
a pretty good default in terms
if you compare what we do in angular to
what we didn't in your guess it's about
10 times faster even just doing this
runtime check everything process but
we've also given you a few ways to
modify what happens during change
detection so the the first thing you can
do is you can actually modify the change
detection strategy on a component by
saying it's on push and what that will
do is it will only update the view and
it will only apply change detection to
that component and then therefore all of
the components in its tree if either the
inputs that component change or if one
of the for example one of the
observables emits a new value and then
there's a an even more advanced strategy
that you can do which is not built into
the component directed or declaration
but it's a command you can actually do
if you inject the change detector where
you can actually completely detach part
of your component tree from the change
detection so if it's detached nothing
will trigger changed nothing will
trigger a dirty check unless you call
mark for dirty check yourself and then
what we do in angular is we actually
trigger all of these events via zones so
we know whenever a task is completed
like a button click or an href call
automatically and then we can trigger
change detection because it runs so fast
we can do that relatively often angular
really loves this concept of immutable
data mostly because of what I talked
about in terms of this on push support
where we can say hey most of my tree is
not going to change very often and I
can't guarantee that it's only gonna
change when one of the values of the
inputs changes and so when you combine
this idea of immutable data so we'd get
an entirely new object so we don't have
to do deep inspection plus on push
change direction your entire application
is going to work faster by doing less
work I've heard a quote from a colleague
a few years ago which is that the art of
doing less work is maximizing the amount
of work not done excuse me so if you
maximize the amount of work not done
that's when you build really great
applications and great products so the
the first way that we pull in data now
and really connect this back to a real
world sort of system is firebase so I'm
going to talk about this a little bit if
my clicker works
so I was looking at just confronted from
memory what sort of products are
included in firebase now so when it
first came out or when I first started
learning about it it was really just
focused on this real-time database so
it's a no sequel store where the way
that you bind into the no sequel omits
new values every time something changes
in the backend which was really exciting
because for the first time you can pull
up two tabs and get the same data in
both of them and everything syncs in
real time and then they added features
like authentication now they've added
hosting storage and then actually wanted
to pull up the website to see what the
the actual list today I don't use the
even all of the features and it's
actually grown quite a bit and actually
a couple months ago firebase announced
that they acquired fabric and so you can
expect really firebase to become this
kind of hub of developer productivity
and tooling because they have everything
from crash reporting test labs so run
your application on multiple devices if
you have an APK or something like that
as well as cool things like just in the
last few weeks I believe we launched
cloud functions which is the ability to
instead of having to build a server to
manage or guard some of the data within
your firebase instance you can now run
on JavaScript code directly on our
servers for you and then it will react
to changes in any database structure so
I wanted to yeah good yeah
yes absolutely and I mean if you look
back at this slide
it actually has all of those buttons so
you can add firebase you can add to iOS
Android and web and I mean this isn't a
firebase talk but I'm happy to answer
any questions around that as well
because when he gets into mobile that's
where firebase is investing kind of a
lot of time right now in terms of making
it great for native mobile but obviously
you can also build mobile applications
with web technologies right using ionic
or native script things like that so I
want to do a tiny bit of live coding
here with you guys and hopefully this is
somewhat interesting as I wanted to
build a DevOps chat app from scratch
here in just just a couple minutes using
something called angular fire and so
angular fire is a library that we offer
as part of the kind of angular tools
suite even though it's not built by the
core team that allows us to expose a lot
of what's going on within firebase using
observables using patterns that are very
familiar with in angular but then also
expose the power of firebase so I'm
gonna jump out to my IDE here what I've
done is I've scaffold it out using the
angular CLI a brand new CLI project and
so you're gonna have a few very simple
things it's going to come with a module
it's gonna come with a component then
it's also going to come with all the
environment configuration get
configuration and a set of files for all
of your tests and so what the first
thing I'm going to do is I let's go
ahead and try and serve this application
I'll do in the terminal down here
all right see if this works and you
serve so this is the seal I command it
will spin up a live dev server that will
automatically refresh every time it hits
save how many people here use the CLI
okay I highly recommend it if you're
using angular it's probably one of the
easiest ways to get started and to kind
of continue developing so I've typed ng
serving it's gone ahead and built my
application and so on 4,200 we should
now have a server so we're seeing app
works and that means our application is
actually live and running so what I'm
going to do now is because it doesn't
look the greatest I'm going to quickly
add material design so I'm going to
import material module from angular
material and then I'm gonna add it to my
ng module imports all right then it's
gonna need a tiny bit of CSS here
because otherwise it comes unstyled by
default and I'll just copy and paste
this it resets the Styles the padding
with the margins things like that and
gives me a little bit nicer look and
feel and then we're actually gonna jump
up to our HTML and we're gonna use
material design I'll put this in any MD
toolbar instead of in each one and I'll
give it the color of primary and then
we'll have close that tag and what we
shouldn't see now app works alright and
that looks just a little bit better or
maybe a little bit less terrible I
should say and now let's go ahead and
pop it into mobile here alright now that
we've got that the idea was to build
each hat app so let's go ahead and start
building out what might be a chat app
for us so I'm gonna build a div here
where we're gonna throw all the messages
and I'll say height 400 pixels overflow
Y scroll and let's put a border on it
all right now so in this dip we're gonna
put all the messages so I'll come back
to that and at the bottom what I'm going
to do is I'm going to create a div I'll
make you display flex we're going to put
three things in here we're gonna give it
a input for the author so you'll specify
where your name is just give this a
local template variable called author
and then we'll say input placeholder
equals message and lastly we'll create a
button
if we make this one flex one this should
look like a very simple chat window
no it's just too small 400 pixels is too
much for this group let's try 200 all
right now you can see we've got a very
simple chat we've got author message and
sent so let's go ahead now and actually
hook this up to firebase and so I
already created a firebase back-end took
about two minutes I can do it again if
you guys care and what that gave me is
it gave me this configuration object so
I'm gonna copy and paste that here in my
app module just like I imported material
design I'm an import angularfire module
from au or fire - I'm gonna make go
ahead and add that to my ng module
imports as your fire module dot
initialize app which then takes that
configuration object alright so that was
the now I've connected my clients to the
firebase backend which means I should be
able to go into my component now and use
dependency injection to get ahold of the
angular fire object angular fire and
then I should in my constructor be able
to say public they have it's an angular
fire I'll just leave that empty and then
what I'm gonna do is I'm gonna define
any sent but actually no I need to
define so here what I'm gonna do is I'm
gonna use that angular fire object and
I'm going to populate something called
messages so what message is it say
object of firebase list object it's
gonna be a firebase list object which
actually extends observable and so it's
just a normal observable you can listen
to you can subscribe to et cetera but
then they added additional method on
that called push so I'm going to set
this to this top messages equals AF dot
database dot list and we'll just list
the messages endpoint on our firebase
server and then we need to define our
send object our send method and if you
remember it took a message I believe
we're going to author in a message in
that order
alright yep so we're gonna say author
message and then just using those local
template variables I should be able to
save this stop messages stop push
and I'm gonna give it an object where
the author is author dot value and a
message where its message dot value and
then whenever I hit the send button we
also want to clear those messages so I'm
just gonna say this author value equals
message value equals empty string so in
those three lines of code we are
listening for the list of messages we
are pushing new messages up to the
server and we're resetting our local
state so now the only thing I need
should need to do is actually say what I
want those messages to look like so what
we'll do here is we'll just do something
relatively simple
so we'll just in this div we'll say Dave
and G for my message messages pipe async
so the async pipe is actually creating a
subscription only to that observable and
only is in the context of this component
so when this component is not
instantiated when it's not on the screen
for example if I'm in another route it's
automatically going to dispose of and in
that subscription so that we're not
wasting resources in order to keep that
alive and then he in here I should be
able to say message dot message and then
I'll just put by message author
and I forgot to close something here
just like I didn't all right so we have
author message and a send button here so
let's say it's a Stephen hi everybody
and once it's sent so that message
popped up right away because we're
seeing a full round-trip to the server
and if you actually pull up side-by-side
two of these
I'll just duplicate the tab pull this
one off what a great audience that's you
guys
why oh and I forgot I was gonna make
this big announcement about make sure
you turn off your Wi-Fi so it doesn't
didn't quite need that one today all
right and as you saw all that happened
in real-time and you can actually use
the firebase dev inspector to see what's
going on in real time all right let's
jump back to the slides
so does that make sense what we just
built so we just built a real-time chat
app we didn't add authentication we
could if we if we wanted to if you guys
care we have extra time but it really
just shows that the power of the
real-time database and the ease of
synchronizing in those objects in where
I get access to these properties via
observables and then I can render them
however I want using they be kind of
declarative template syntax in angular
you can actually do a lot of very
powerful things because we're doing this
all by observables in rxjs and so this
is an example of where I'm taking two
different features of firebase and
combining them into a single stream so
what I'm doing is I'm taking the off
data so firebase has a full
authentication workflow which supports
Google Twitter a bunch of others and
then as soon as we get a new event so
which would happen any time a user
clicks a login button clicks a logout
button there the state of their
authentication is going to change and
sarena get this state object out and
then what I'm doing is I'm checking and
saying if there's no state then I'm just
going to give them a false back I'm
gonna omit that false but if there is
state then I'm gonna return another
observable which is actually a database
lookup based on this other endpoint and
so this this looks a little bit
complicated but what it's doing and when
it gives you as a developer is now I get
a stream of data about the user that
updates automatically whenever they sign
in or sign out so we're pulling in the
combination of auth data and user data
into a single stream so that I can do
things like and G if off dot is admin
right and I can just in one line say I
do a full check for who is this user and
what are their permissions and then for
example if in the back end of the
application someone removes their
permissions in real time that actually
flow and the view will rerender or vice
versa right I have what I've tried to do
something and I didn't have permissions
and I asked my admin hey can I get
access to do that thing if they add
permissions in real time my screen will
actually rerender as it gets those new
permissions because the off state will
change and that the property of that
observable will update and then I'll
immediately have this very reactive
feeling to my application because it
will be based on whatever is happening
in real time
within the database and you can actually
use this paradigm to do any sort of
level of rule based access control right
so you can define five different roles
within your application and check for
them each of those permissions or each
of those roles in a very same way
firebase also is a really good
permissions model so one of the the
things that we have trouble thinking
about a lot of times is how do we secure
this data right now that we've got we're
moving more and more code from the back
end into the front end how do you make
sure it's secure
so what firebase does is it gives you
the ability to set rules at any level of
the tree so they go through a couple
examples here so in my users list I give
any user acts right access to their own
data so slash users slash my own user ID
will work only if my user ID matches
what the authentication has given me a
little bit more complicated example is
that volunteers role that I talked about
where someone may be where we're
maintaining this list of volunteers that
exists in our application and I can only
write this if the currently
authenticated user exists in the X Lash
admins
section right so I'm looking at the the
root of my my database here looking an
admin plus their user ID and if that has
been set which only admins have
permission to set that then I know that
this user is allowed to update the
volunteer status of the users and we
have a much more complicated rule here
which I'll just explain very briefly you
can do kind of much more complicated
lookups this is a one where we've given
that volunteer role access to just one
parameter on a greater a larger object
the use case for this was we were
actually building a conference website
we built it with this idea we have
admins when we have visitors right
visitors can see everything and not
touch anything admins can edit anything
but then the week before we realized
that we needed to empower volunteers
that were helping us run the event to
actually make notes on the conference so
like hey this room is full or there's
two seats left and whatnot and so we
didn't want to complicate the permission
model too much but we were able to
create this role just by having a slash
volunteers endpoint and then we gave we
added this additional check that said
volunteers are only allowed to access
and edit this endpoint if they're
editing the notes right so they can't
change the name of a speaker they can't
hear the name of a session but they can
access and modify the notes of a session
so this is that combination of looking
up whether they're an admin that exists
or what looking whether they're a
volunteer and then combining that with a
parameter lookup a lot of developers
that come to conferences and I talk to
they're always like tell us secrets
weddings or do you guys wanna hear
secrets okay that gentleman gets to hear
all the secrets
so in general angular is relatively
public so pretty much all the curve all
of the source code that we write ends up
on github so if you paid a lot of
attention to every commit that we write
you would know pretty much everything
that's going on but this is one that not
a lot of people have seen and we haven't
talked about before but one that I'm in
particular very excited about so one of
the features that's coming to your
angular fire is that we are going to
start lazy loading and modularizing it
so if you use angular fire today what
ends up happening is we load about 400
kilobytes of additional kind of bundle
size into your application which is the
entirety of the firebase SDK for web
which is pretty big when we're trying to
build applications that are kind of
under 250 Kb and so on and so what we've
been working with david ee sexy on who's
the original author of angular fire is
we come up with a paradigm where we do
lazy loading and so what what happens is
because all of the angular fire methods
for authentication for database lookups
etc they're all asynchronous what we can
do is we don't actually want to load the
angular fire or the firebase library
until you actually use it and so what
this means is that because we have this
write in angular we have this very nice
lazy loading concept where you can have
a module that is lazy loaded in your
application so that your users to your
homepage don't pay for that extra bundle
size we can take it one step further and
then tell on one of your components you
actually try using authentication we're
not going to pull in the authentication
part of firebase or until you start
using database which is the biggest part
of firebase we don't actually need to
pull that in and so we believe that once
this is complete we can actually get it
to a point where none of that dependent
you don't pay for any of the
dependencies until
you're ready to actually pull data down
which is really exciting and it's a
model that we kind of want to see
replicated across the ecosystem because
a lot of times if you can save library
cost and save bundle size and save it
for defer it that's a very desirable
thing so you get that nice first time to
interactive or for users for your
applications so the last section that or
the set in the next section excuse me I
want to talk about a little bit is graph
QL how many people here have written or
seen graph QL okay half so graph QL is
actually a relatively exciting
technology so we're all used to building
out these API endpoints and rests fine
points and micro-services whatnot which
is fantastic right it's a great way of
building applications but then what you
end up having to do is you have to build
this middle layer where you have to do
perform all these lookups you're saying
hey I want my data to look like this how
do we go and get it that little bit of
data from these six endpoints and make
it useful on my client-side application
so that I'm not doing 50 different
lookups two or six different lookups to
that back end and what graph QL does is
it allows you to it's a transport
protocol that allows you to do those
lookups very declaratively
so this is stolen from the graphic UL
website but basically you provide a type
so here you've got a project which has a
name which is a string you've got a tag
line that's a string on a contributors
and then you write a graph QL statement
which looks like this it's you say
project and I only want projects where
name is equal to graph QL and then I
want the tag line object so I'm
specifying not only the objects I want
in terms of here's the filters and
here's the the criteria but then also
what fields and what data I want back
and then what you get back is exactly
what you asked for and you'll see they
look almost identical right so now I've
got a adjacent object with that project
and there's the tag line for that
project so you'll notice two things here
it's very it's very typed so you're
specifying string number it's that or
whatever data type you want to get back
but it's also very declarative does that
sound familiar and it looks exactly like
how we do they're kind of angular
philosophy I'm designing templates and
so there's a project called Apollo which
is from the team at meteor and so what
Apollo is is it's a both a server-side
they
handles all of the graph QL resolution
and the client-side library that allows
you to do lookups and so what you can do
is you can set up a server-side graph
queue or Apollo instance that knows
about your data types and you can say
hey here are my six endpoints this one's
a sequel server database this is a my
sequel database and then maybe I'm gonna
go pulls in some JSON based weather API
and once you give it information on how
to resolve those endpoints and resolve
that data then you can make graph QL
queries to it from a client and it will
automatically figure out okay in this
instance I need to go query this
endpoint in this instance I need you go
query these three and then combine the
data and so it handles all of that data
resolution for you and what's nice is
then because of how Apollo is written
and in how well it integrates with
angular is we can actually combine
queries they come from multiple
different components and bash them into
a single request right so if I have a
request coming from my tool bar and I've
got a request coming from my side nav
bar and then I have a request that sonic
some specific content page typically
that would be three requests to a
back-end API if you had to design the
middle layer yourself or if you didn't
have access to build them and a layer
for yourself
and so what graph QL does it actually
allows you to have all of those things
automatically aggregated by the Apollo
client within angular and then it makes
a single request to the server and then
stores that in a Redux store within
angular so what does this actually look
like so first you need to write a query
so you can see that we've got this graph
QL tag a method that's using the the new
template literal syntax where we're
giving it just the declarative syntax of
hey I'm creating a query
I want a feed object so in that feed
object give me the current user and the
login and then I also want to when that
feed is created and what score it had
then what you can do within your angular
component is you just do us a watch
query or a query and so this is you
basically give it that query that you
just define so you give it that graph QL
query then you sign it to a local object
so this data is now an observable of the
responses from that graph QL query and
so we know what this data is going to
emit because it's exactly what we wrote
here in the graphical query and because
everything's strongly typed
on the backend we know exactly the types
of every object that we're gonna get
back and then now that you have this
object in this data parameter within my
component it's really really easy to
iterate over that so we've got let entry
of data type async because it's just a
pure observable and then they've
actually added additional pipe called
select that lets you do client-side
filtering of result sets in order to
help take advantage of some of the
caching that they build into it so here
I can iterate over all of the entries
that came back from that data set and I
can render out to the screen for example
the score from that entry so does that
make sense
I talk to people about graph QL and it's
it's kind of weird because it's this
magical thing real like oh I just tell
it what I want and it gives it to me but
a lot of the magic ends up being in the
resolvers so the server-side piece where
you say here's the three databases it
comes from obviously if you already have
a no sequel store and you've architected
it in a very logical way for client-side
development it's about the same effort
but most of the times we're working in
companies that don't have that right I
graph QL is actually very similar to I
believe Netflix Falkor is that right
doctor net like conceptually okay so so
Netflix actually I believe they were
kind of the pioneers of this concept
where we have all of these micro
services across the company and its
really kind of a pain to have to build
these middle of tiers and so using
things like Falkor I can say hey
declaratively say this is the data I
want back and soso graph killed was that
exact same thing if I understand
correctly but graph QL is all based on
open standards whereas Falkor is a
little bit more proprietary I believe
graph QL is intended to be an open
transfer protocol and I believe they
give you a reference server and they
give you some tools for testing and
inspection just so you can see what my
graphic UL query would return on the
server side but they leave it open for
people to build their own clients and
servers which is what Apollo does so to
make this very nice end-to-end
experience the next piece that I want to
talk about is a project called ng rx
store so this is from ng rx which is
reactive extensions for any
this was a project actually I believe is
founded in part by Rob Wormald who's on
the angular team he's my another tool
for advocate on the team so what
basically this allows you to do is it
allows you to take the Redux pattern of
immutable data and apply it in angular
in a very kind of nice ergonomic way so
for those of you that aren't familiar
the Redux pattern how many people here
know about redux okay nobody knows
ratings awesome of course you do
we knew that so the Redux pattern is a
an emerging trend in development where
we're very used to having local states
and managing kind of state ourselves so
manually within my application every
time an event happens I go and say what
does this event mean for my world and
then anytime I have that event happen
anywhere in my application I have that
event happen I have to say okay and it's
this case I wanted to do this in this
case I wanted to do this
what redux does is it allows you to say
hey I'm gonna have this very simple set
of concepts and then I'm gonna apply
them rigorously throughout my
application so the first concept is an
action so this is something that happens
in my application either as a response
to something that happens on the server
side or as a response to something that
user has done and so if we look at an
example here let's say I'm building a
very simple counter alright so you can
increase increment it you can decrement
it or you can reset it so these are
they're defining three actions that you
can take within my application and
obviously this is a little bit contrived
right it would be very simple to manage
account or locally but it's much more
complex when you have nested objects
deep inspection and objects that are
coming kind of across an application
where you've got maybe 30 or a hundred
different data types so then you combine
these actions with a set of what are
called reducers but basically what a
reducer does is it takes a state so your
initial state is maybe my counter is
zero and then you combine that with the
action and you return a new state so in
this case we have our counter reducer
and it takes in whatever state we had it
at the time and it takes in an action so
if we had an increment action then we're
gonna return the state as it is today
which is that counter and we're
incremented by one if you decrement
we're going to reduce
I won and they're gonna return that new
state and then what we do is we have a
selector which is actually going to now
select that piece of data out of our
data store and so we're gonna get this
counter equals store dot select and give
it counter and so in this use case in
this example this dot counter is an
observable that emits a new value every
time an action is applied and then there
you can see that we've got three methods
that are maybe hooked into our HTML so
an increment decrement and a reset that
just dispatched that event and so well
you can definitely do this yourself when
simple case of late counters I talked
about how this can really help more
complex cases one of the ways that it
does this is because the data is
immutable the store actually keeps a
copy of every previous state if you want
it to and so what it can do is you can
actually use something called time
travel where if you're inspecting your
application there there's a bunch of
Chrome extensions and tools to do this
you can actually see every action that's
applied to your up within your
application and see the order it's
applied in and then step back through
your application and because these are
just observables when I set if so if I
had plus plus minus minus plus write the
end state would be one but if I hit back
then the end state it's gonna go back to
zero and I can see how that ripples
through my entire application and so if
I have a series of actions that have to
happen right maybe I'm building a web
store where I have to charge the
person's credit card I have to validate
their address and all these things are
happening in different places in the
application I can actually see how each
of those actions affects the ends the
the state and the stage is very
centrally managed and very clear to
understand and then these selectors
allow me to just get out a very narrowly
targeted piece of that state so that you
you get that kind of reactive feel to
your components so that they're changing
behaviors every time you get new data
and it's very fast and very performant
in large applications because of things
like on push where we know we only have
to render once that state is changing we
don't have to do any sort of comparison
to the objects we'd say hey we've got a
brand new state object let's rerender so
here is the the HTML that would go along
with that counter right so you click you
know increment we're rendering that
counter by the async pipe we just
automatically doing that subscription
and once again if you don't subscribe to
an observable what's a cold observable
you don't actually pay any costs for
that so every time the counter changes
if I wasn't listening to that we don't
rerender it we don't process that at all
and then I have a decrement any reset
button so hopefully this has made some
sense about how angular really focuses
on the ways that you can have data
within your application I hope we can
reflect that within your view and we can
make that very easy to both manage and
to mutate and then there's a ton of kind
of open-source libraries such as fire
base such as ngr x such as graph QL and
apollo that make it even easier to do
this when you've got maybe a hundred
developers or a thousand developers or
megabytes of data and state information
that you need to be managing across a
large application and you might not
always be able to know and understand
everything that's going on at one given
point in time and these sorts of tools
can help you with that so first thank
you guys for coming and then I want to
jump into is there anything that you
guys want to see or questions you want
to ask about angular because I'd be
happy to kind of continue our little
demo here build it out at
ah so so usually initially you said an
initialization of the data visualization
of the data so that's relatively
straight the visualization the data it
really just comes in to how do you want
to render your template so do you like
are you thinking a chart like charting
libraries yeah there's a number of
different charting libraries so we've
got for example we zoom out has angular
support there's something called ng
chart and so there's a lot of very
advanced charting libraries and this is
something that we're continuing to work
on so for example we're working on a
angular material data table but the ones
that already exist such as ng chart they
already support things like lazy loading
of content infinite scrolling all those
sorts of things so I would probably if I
had to build something today I would
probably use an G chart I believe I can
pull that up here so it's five dollar
software oh sorry I'm mixing up charts
and data tables because I almost in
every large-scale application we have
both right a lot of financial
institutions and of using charts and
data tables so there's another demo that
I recommend you take a look at there's a
gentleman by the name of Alex Castillo
and what he he's built out is a random
data visualization and so he randomly
fluctuates data like a million times a
second and then he's trying to render
that out on a visual just throwing
colors and whatnot just to show off the
change detection performance and the
reef lowing in the layout so if you if
you look up alex castillo visualization
demo you'll see a really cool kind of
like fancy color rendering which is not
really useful in the real world but very
handy to understand what's going on
under the hood in terms of change
detection and rendering any other
questions yeah
yep
mm-hm
enterprise that's we've been there yep
sure sure so WebSockets are obviously
the ideal answer I would say for most
use cases that are using restful
backends if you were building graph QL
for example graph QL actually has
built-in polling and so it will based on
whatever interval you give it with
whatever back-off you want automatically
pull and refresh the data so in the
graph Gil there's like a client TS file
or you can specify what sort of window
you want to use for batching and how
frequently you want to be refreshing
that data but that's that's the in the
graphical world that q also supports
real-time data just like firebase but
you obviously need a database engine
that supports like triggers and
notifications and whatnot which most
current existing database setups aren't
kind of built to do when it comes to
just building a pure angular application
were you doing restful data queries I
would definitely love to do WebSockets
but if you don't have WebSockets then
you're gonna be long polling what's
what's nice about angular's because
everything's in observable you can do
interesting things like debounce your
requests or have exponential back-off at
the observe level so you define hey
here's this HTTP endpoint here's how we
want to process the data that's coming
in maybe I want live refresh maybe I
want whatever but then from your
component when you're actually designing
how you want that to look and render and
flow in your application it's exactly
the same right you just assume II I'm
getting a stream of data that's gonna
update whenever I get that data and then
you leave all of that other stuff to the
the definition of the stream which is
very nice
sure sure sure
um I like to show you one strategy here
let's see if I can find it so on Monday
in Melbourne Australia I ran a workshop
for about a hundred people and one of
the things we did is we we talked about
simple data caching so if you're using
an API endpoint one of the questions
that a lot of people that are new to
angular ask is why to use observables
inside of promises right promises
resolve exactly once and they either
succeed or fail and they can be
cancelled
but then observables have very similar
functionality but in an HP request
you're only gonna get one response right
or zero or one responses theoretically
but the reason we do it with observables
is because of what you said we're often
I'm pulling from multiple backends or I
need to live poll or I need to retry
things like that and so observables let
me do some very kind of interesting and
very cool things
so simply HTTP caching one of the things
you can do with this observable is you
first you subscribe to it and then
anytime new data comes in via HTTP cache
that into local storage and then using
an observable operator called start with
you start with that data and so what
happens is the first time you load the
application the observable is gonna emit
a new value we're gonna save it to local
storage and render it to the screen
right because you've got two subscribers
on that information and then the second
time that you hit refresh we're going to
instantly render the version from local
storage and then as soon as that HTTP
request comes back it's gonna update and
not only is it gonna update the UI but
again because the stream is gonna update
that saved version and so this is this
is how quick that can look like so at
the top we have a normally speak call in
I can make this big I'm sorry about that
we have a normal HTTP call where we're
gonna say HTTP GET and we're gonna give
it a path and we're gonna take the
response and turn it get its Jason
but then what I'm doing is as I said I'm
gonna subscribe to that and store a JSON
version of that called activity cache
and then the version that I actually
render to the screen these activities
start with and then I pass in that
storage version and so you do this and
you instantly get offline capabilities
right so if you combine this with a
serviceworker which in angular is now
just one flag in the CLI so you say
serviceworker equals true all of your
vendor j s your index j s etcetera get
cached in that serviceworker so your
who's your user has a poor internet
connection or loses their internet
connection they're just fine
we're gonna serve all the functional
side of things from locally from the
cache manifest and then your user's data
is still there because we're doing this
very simple caching into the HTTP area
into that local storage that pattern
does that make sense yeah yeah I built a
much more complicated version of this
about a year ago where it did first
check if it's in memory then check if
its disk and then check if it goes and
gets from the Internet I did in promises
and it was a nightmare
using observables it's much much cleaner
because like doing this idea of starting
with a value it's very hard with
promises because you need to figure out
ok has the promise resolved the promise
hasn't resolved we need to set some
local state and you have to create
manage these two separate states whereas
all this flows through a single
observable any other questions yeah
yeah correct
sure sure
yeah so we don't need a virtual Dom
because what we do is we do all the
dipping at a yes 6 class level so we
evaluate the expressions in your class
and then that gives us a state and then
if that state has changed then we render
out just the changes so we have a render
so it actually ends up happening is you
write these these declarative HTML
templates and then it actually ends up
being compiled into JavaScript so vm
optimized document dot create element
etc and so in general we do we don't
need virtual Dom because we're just
doing this kind of object level dipping
or on pushed change detection and then
we propagate out the changes yeah
mm-hmm sure so I don't I'm not aware of
a library I mean the the ecosystem is
huge so there there might be someone
that's already built helper tools but
with with Couchbase are you looking for
like real time sink or what features of
Couchbase are you looking for help with
because I mean couch weights obviously
offers a restful api right so that you
can just isn't it a no sequel database
that has it all so it was the restful
api I'm not a couch bass expert so I
mean you you can always just do the HTTP
calls but it would be I would be
interesting to hear what you're hoping
for from a library like that all right
well I think we're a little bit oh sure
well let's do let's just do one more
question then people can come up after
and ask question
what do i I'm not I've never heard of
server-side events what are server-side
events like push notification like
so I'm not familiar with that so you'll
have to tell me more about that is
anybody else heard of that
yeah exactly I mean you your very inmost
inner in a lot of environments you're
totally hands-off on the server and so
none of the cool things that we want to
enable we can enable because like for
example in web applications we now have
push notifications right so if I build a
a if I use it at a service worker to my
application I can now wake up my
application from the internet whenever I
want to send a notification or whenever
I say hey you did as is here which would
that would directly solve your problem -
right just well send a push notification
the user whenever stuff changes but
you'd appear on the backend
infrastructure to do that that doesn't
help all right well thank you guys so
much and I'll be around for chatting
later Oh two other really quick
announcement sorry I should have said
this earlier
number one version force planned on
being released today which is really
exciting it should be very easy upgrade
shouldn't break everything should just
make your application bundles smaller
and we add a couple of new features that
I one of them I mentioned that new Angie
if syntax so that's a big deal that's
that should be pretty good for you guys
second it's my birthday</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>