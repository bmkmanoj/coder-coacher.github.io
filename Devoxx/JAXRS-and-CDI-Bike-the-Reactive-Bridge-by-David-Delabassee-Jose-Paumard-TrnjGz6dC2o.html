<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JAX-RS and CDI Bike the Reactive Bridge! by David Delabassee &amp; José Paumard | Coder Coacher - Coaching Coders</title><meta content="JAX-RS and CDI Bike the Reactive Bridge! by David Delabassee &amp; José Paumard - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>JAX-RS and CDI Bike the Reactive Bridge! by David Delabassee &amp; José Paumard</b></h2><h5 class="post__date">2017-11-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/TrnjGz6dC2o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay we're good to go
welcome and welcome to this session
where we will discuss jax-rs and CDI
just for the intro so my name is David
Alaba say I work at Oracle in the Java
and container native organization where
we're doing technology such as java java
c open source project such as GlassFish
Jersey open JDK but also order a
cloud-based stuff so as I said I work
out right before that has been 10 years
at CERN working on son oh sorry working
on Java server side but also client side
and even before prior to that I was
working in a telco in Belgium because I
live in Belgium where I was also working
in the early days of Java so basicly has
been spending quite a few years with
Java in fact my first Java one the first
one that I attended was in 1998 so
almost 40 years ago
and my name is Josie I live in the Paris
Area it's really hot I should remove
that it's not that funny in fact you can
follow me on Twitter it's a technical
Twitter account only and I also have a
Content open source projects on the on
my github account the size of the of the
presentation will be made available on
SlideShare to adjust that to that do you
counsel also follow me on on YouTube and
I think in this next slide is for you
yeah yeah so how does it told you I work
at Oracle and a few months ago I was in
Sweden at the focus where I was giving a
talk on Java yet and someone in the
audience tweeted that it's not a real
conference unless you read Oracle's f
ever statement at least once
so enjoy now joke aside well so well you
can try to understand what this is it
what this is saying but basically it
says that you shouldn't make any profit
decision based on any forward-looking
statement that I will make today we're
going to discuss Jack's arrest
jacks or x21 and CDI too and also the
compression stage API of Java C 8 so
clearly there's no foreign-looking
statement so you're safe on that front
having said that despite my French
accent I'm not French I'm from Belgium
and that despite my Belgian accent I'm
not from Belgium I'm from friends sorry
for in French so the the tiny well let
first give you an explanation set the
context of what we're going to discuss
today so in the title we are using a
reactive term so basically jax-rs and
CDI can help you to cross to cross the
reactive reach now if you look at
directive manifesto so the reactive
manifesto talks about elasticity
resiliency Mestral driven and also gid
here is that we will will talk about
being reactive in the sense that
reactive for in the in this context
means having the ability to react on
event right and obviously at the end of
the day if you are being if you're able
to react on even in a efficient manner
by the cleanliness Acronis fashion your
application at the end of the day will
be able to cope with more load will be
able to scale easier and so on so this
is really what we mean by reactive
having the ability to program
application that react in a very easy
fashion to event for that we will use to
api Jack's res and CDI which have been
defined in Java yet so we will really
use the latest version of those API Java
yet has been finalized
so those API are finalized and stable
but having said that even though those
API are coming from the Java platform
you can also use them just
on top of Java LC and in fact if you
look at Jack's arrest jax-rs
is obviously heavily used in the Java
space while jax-rs is also used
standalone on pure java c context so
what we're going to discuss today apply
of your sleep to Java but it also apply
to Java C so you take jax-rs
and or CDI on top of java SE 8 or java c
9 and the pattern that we are going to
discuss today will work exactly the same
way so it's not a pure Java e talk so
let's talk about Jack's arrays
so in Java 8 we have we have Jack's rs21
if you look at Jack's arrays in Java 7
we the major addition of Jack's arrays
in Java 8 was this new client-side API
so basically since access to Java 7
we have an API that we can use to easily
consume a rest endpoint now if you look
at Jack's rise to 1 there are a lot of
stuff that are being done but let's
focus just on the client-side API of
jax-rs
and in fact this example is a Jack's
rest to example so how it works if you
want to consume a restaurant point well
you first need to have an instance of a
client side a container so this is we'll
check the rest client side container you
get that client container through this
method invocation so can be learn new
client and you will have a client
container that you can use to invoke
remote rest endpoint then once you have
the client container you will based on
that container construct a web target a
web target is at the end of the day just
the location of your remote endpoint so
the remote endpoint that you want to
access so this is my target I have the
ability to configure and construct my
target once you have the target set you
will you will have to construct the
request and obviously at some point in
time you will invoke the request to get
some result from the remote endpoint
obviously given that we have these
clients I can tell her you need to make
sure that you close that client
container once you are done nothing
really new here
so what we have in jax-rs - we have this
flight of this fluent API that you can
use to easily construct an inverter as
requests so it starts from the client
from the client you said the web target
from the web target you consider the
request and then you invoke the request
the key here is that if you look at the
bottom of the example we have this get
method so this is a HTTP get request but
this is really a blocking call so that
means that my method will not return
until my remote endpoint at as send me
the result so this is the default
behavior this is a blocking a
synchronous behavior now if you look at
jax-rs - so that's Java e7 we have also
had it support for an analysis Kronus
behavior that's what we have at the
bottom of the slide so we have this a
sync method which is basically used to
tell to the jax-rs client container that
this is an a sink invocation and if you
look at the return time of that the
return type of that invocation what we
get in return is a future of string in
this case so basically you have a future
object that you will be able to use at
some point in time to get the result
that will be sent by the remote endpoint
get the result or see what what the hell
was if something went wrong so the thing
is that this is a synchronous so when I
do my get my return my method will
return directly but obviously at some
point in time we need to access the
future object and if you do that I get
on a future you know that it's a
blocking call so we haven't really
solved the the blocking issue that we
had with the pure jax-rs sync api right
so this is really blocking now the
result needs to come from a remote
endpoint to the network so you also need
to make sure that you set some timeout
you will set some timeout directly on
the gate but you'd better also set the
timeout on at the jax-rs level to make
sure that at some point well
worst-case scenario your code will block
for let's say five seconds but not more
but this is still blocking so this is
not what we want to have
let's keep that let's keep that - so
where I want to go is to this we have an
a synchronous behaviour in Jack's res -
but it's blocking at the end of the day
the good news is Jack is that in Jack's
raise - we also have an asynchronous
invocation callback facility that allows
us to work around that blocking issue so
we have an invocation callback with two
methods the first method is completed so
it's a that callback that completed
method will be invoked whenever we have
the result from the remote endpoint and
then we have the fill method that will
be invoked if something goes wrong so it
works like this so it's a pure jax-rs
client-side request
it's nothing requests obviously it's a
get request and then we have to pass it
an implementation of our invocation call
back with the - callback that we have so
the completed that one will deal with
the result that will be sent by the
remote endpoint and the field if
something goes wrong so it's fairly easy
to see how it works now if we put that
into perspective so we have a basic
micro services like scenario where we
have a travel agency services that will
consume four back-end services and the
idea is the following so we have a user
that comes in and we would like to
suggest to that users based on is a
travel story some destination you might
want to visit for that the travel agency
services will use the jax-rs client api
to consume the four back-end services so
the first services will be the customer
services so we want to have the history
of that customers once we have that we
will reach to the destination services
so we want to have a few destination to
suggest to that user based on its travel
history but before we send us the
destination we also want to reach to the
weather services and the coding services
because we want to have some pricing and
some weather information to the city to
the destination that will send back to
the to the user so that travel urgent
services will have to implement using
the jax-rs key and the api some kind of
orchestration between the four back-end
services now one thing is sure is that
we don't want to do that in your pure
synchronous fashion why well it's easy
if we just put some weight on the
request we'll see that in this example
we have we want to suggest ten
destinations so we first hit the
customer services then we hit the
recommendation services and then we have
to eat ten times the destination
services so for all the destination
sorry we have to eat the pouring
services and also ten times the forecast
services because we want to add to have
those information so obviously the total
time to get all the result would be just
too long so we want to go in an icing
fashion for that why well it's easy I
mean if you look at at the graph we have
dependency between services so for
example we first need to have the travel
history then based on that we will hit
the destination services but then we can
invoke in parallel the calling services
for all the destination that we have and
we can invoke in parallel the weather
services because there is no dependency
between the services and at the end of
the day if we can do that in a lasting
fashion the total time should be way
less so if we try to implement that
using the sync API of jax-rs - but
before we do so we have to simplify a
little bit and let's pretend that we
just have two services instead of four
so using the jax-rs - api it could be
something like this
so we first do a request to the
destination services so to get some
recommendation
it's nothing requests so that mean that
we have to pass it an invocation
callback my callback needs to have
obviously sorry magnification callback
need to have to call back completed
we'll deal with the result so once we
have all the destination we basically go
over all the destination and we do
another request for all the destination
we do that request in the same fashion
so that mean that we have to use again
an invocation callback with a completed
callback
so basically when when we have the
weather forecast for that given
destination we put that in in
synchronized map and so on and so on and
the thing is that obviously we also have
to deal with any oh that my hawker so we
need to make sure that we implement the
failed call back to at the two level
because we have two invocation to type
of invocation
back and so on and so on I guess what
you see where I'm going to this is what
we call the hell called the callback
hell and clay writing that code is very
difficult so at the end of the day you
will have code that is difficult to
write debug and nine ten so clearly we
don't necessarily want to go that route
the good news is that in Jax rs21 so in
Java 8 timeframe we have a new invoker
and that is a reactive invoker if you
look at the bottom of the slide we have
this rx method so this is basically how
you can invoke the jax-rs client
reactive invoker and you see that this
is a standard jax-rs
trends our request the only thing that
which is different is the invoker Oryx
instead of a sync so this is a nothing
request but in your reactive fashion and
you see that the return type is not a
anymore a future type of the response
but it's a completion stage of the
response that we do Excel expect now up
to you thank you
so in fact the following of the of the
processing of this data turns out to be
finding the right completion stage
patterns that we want to use just to
complete and to get the result in an
asynchronous synchronous way just a
quick poll before before I continue who
was that venkat talk about computable
futures and streams and things like that
ok so not not that that many people all
right
so we are we are going to see that first
what is a completion stage from a pure
technical point of view a completion
stage is an interface from Java 8 so
starting Java 8 you can use that it's an
extension of the future object so
everything you can do with the future
object you can do it with with the
completion stage from a design point of
view and design pattern point of view in
fact a completion stage can be seen as
as a model of a task it's triggered by a
task so it contains a task and that
completion State will allow us to
communicate with that task in an both in
a synchronous fashion as the the with
the get method from the from the future
object and in an asynchronous way with
the new methods introduced on the on
this on
interface this task may be set as part
of a chain remember that to interact
with the future object you need to have
a reference to it and basically what you
can get is are you down give me the
result or cancel this kind of thing that
you can give orders to it and and the
bridge must be on the thread that
launched the task and the thread that is
executing the that task and built that
that that's future object so this huge
object is in fact a bridge between the
thread that created the task and
launched it and the thread that is going
to execute that touch that task a
completion stage is different a
completion stage is real fire-and-forget
object you create it you configure it
and then you forget it and it will kind
of work hopefully the way do you want it
to work they are okay we can see two
basic operations on the completion stage
first trigger the beginning of a task on
the completion of another task we have
many methods for that
the idea is to apply your function to
the result and to trigger that function
once the task here cs1 is Donna and we
have a second function to that which is
a then compose method that takes a
function that itself returned to
completion stage on the example we are
going to see the situation is the
following we made a request on the
weather service for instance to get the
weather forecast this weather service
will reveal written written response
sometime in the future we don't really
know when we will have this response but
on the on the completion of this weather
service when we have this forecast which
will probably be a JSON object what we
want to do is trigger the and marshaling
of this JSON object so this task does
not is a purely synchronous task it will
not return a completion stage itself so
we will trigger this and marshalling
stuff on the with this with this then
apply method just because the en
marshalling will not take care much time
it will be done synchronously but
suppose that the triggering of the
weather forecast triggers another
request on the
see nation surveys for instance because
the forecast is bad and you don't want
to send your customer there because what
this person wants is to understand on
the beach right something like that then
it would be another a synchronous task
so you will need the zen Campos method
to launch the second test and get
another completion stage so this then
applying cast can be seen as a mapping
operation and the then compose method
can be seen as a flat mapping operation
unless you want to to put that you know
in the stream API perspective this is
the first kind of pattern
aggghhhhh task triggers another task but
we can also have several tasks here too
that are both triggering a third task we
are going to see an example of that and
this kind of pattern is triggered with
the then combined family of methods once
again there are there are many methods
in fact in this completion stage API to
do this kind of thing all right so with
those two basic operation we can then
create any kind of pipelines we want we
have a first task that is a synchronous
suppose the the gate destination the
destination request service the changes
of its re that we are requesting then
when we get the destination maybe we
want to trigger a request on on the
weather forecast this is the second task
but we probably also need to send some
kind of information in some kind of
logging service or be maid service or
whatever so we can also trigger a second
task that will do some side effect and
thing like that in the first branch of
the pipeline once we have the the
forecast maybe we want to do something
else with it so there is another task
that is triggered and this this third
task will in fact have to wait for
another task that has nothing to do with
it but on the completion of those two
tasks 31 on a we are going to trigger
the last task of our process so this is
this is the kind of pipeline that we can
build using using this completion stage
API now how can we move that to our
example travel service agency we have
the
client target forecast that is going to
to ask for the forecast of the
destination once we get the destination
we call this Eric's method from the
jax-rs API that will in fact create an a
synchronous task and return this
completion set object and since this is
res service query it will return of
course a JSON object
now this JSON object we need to learn
more char it the unmarshal operation is
not going to be a synchronous because
it's a quick operation we can just do it
like that so we just create a function
to do this and muttering and we will
apply this function once we have the
destination yes this is just be secure
JSON code so once we and then to trigger
the the completion the second task on
the completion of the first one we need
this then apply method in our code what
is this the apply method will take as a
parameter well it will take a
destination as a parameter so this is
going to be a function that takes a
destination query the forecast service
with this desolation this is picture
time David thank you can we have another
one without thank you thank you very
much the Stefan will think that we're
making fun of him we shouldn't be doing
it okay well was i yes the destination
so we have this destination once we have
this distinction with this destination
we trigger the weather forecast and once
we have the the answer from the weather
forecast we need to march out the JSON
object we got so this is basically the
two steps of our stuff this is obviously
a function that takes a destination and
since this is n then accept method takes
a consumer that does not return anything
it will return in stage of completion
stage of voyda that is just here to tell
us that yes this task has been as
completed properly now the choice that
has been made here
is that we have a destination object
this is our model and in that
destination we have some kind of
forecast property and the system is
going to set the value inside this
destination object so we are not we
could have made other choices but this
is the the design choice that we've been
made so what we want is in fact to
populate some fields of the destination
object with information that are coming
from rest services requests great we can
do that with any kind of other property
here we have a quotation also so we have
two services forecast and quotation
services that are going to set two
different properties of our destination
object right so this is the basic block
of our of our system now when we want
what we want really is that we have
several property to set in the
destination object and what we want is
another completion stage that will tell
us hey I am done populating all the
different properties of that destination
object so in fact we are going to wrap
all the requests that are made in
parallel of course because everything is
asynchronous all the requests that are
made on the different services that are
going to set to update this destination
object and wrapping all those completion
stage in a single completion stage that
will be done that will complete once all
this sub completion stage are complete
we are on the two then one branch of the
graph we've just we just draw a few
minutes ago right so this is really our
our final functional takes the
destination and returns accomplishable
to complete our future void that tells
us the destination is completely updated
with all the information we need to have
but now what our services returned us
was a list of destination now in a
single request and not a single
destination so we need to further
convert that in we have a list of
destination for each destination we are
going to make a synchronous requests so
what we would like to have is a list of
from of completable future that we will
further convert in a single completable
future to know that in fact all our
destination
have been properly updated with the
result of those of those requests so
this is this this third function takes
that list of destination that list is
going to be we could have done that with
a for loop all right bit but this is
Java eight so we have a stream API to do
that so we are going to stream this this
list of destination map that stream with
this populate destination that is going
to populate a single destination with
all the properties requested from from
other service souza and this is a
mapping that in fact takes the
destination and returns a computable
future avoider in that case because it
is just the previous the previous method
this mapping will return immediately
because because we are we are just
creating computable futures that are
going to be created immediately they
wouldn't know we're not complete
immediately but they will be created
immediately synchronously and we are
going to put all those computable
futures in an array for further for the
next processing step so in fact we have
three levels of computable futures first
and we we just saw the first two the
first level is to update all the
destinations it in itself trigger is
triggered by the completions by the
completion stages that are triggered by
all the the individual properties of
each destination object and when we
gather that in another level because
what we have is a list of destinations
right and the next step is in fact to
compose the destination request that we
just made on the destination service
with this popular destination let me
quickly back go back to the previous
slide these populate destinations is the
the function that takes the list of
destination and returns me a completion
state that would complete once all those
destination have been updated so I'm
taking this big a synchronous completion
stage task and I'm composing it with the
with the destination or with the request
on the dis
Nishant service and at the end of the
day the the pattern is really simple
because it's just a composition of two
functions great and then if I want that
the problem is that this completion
stage all off returns a completion stage
of void and what I would like to have is
a completion stage of list of
destination so here I'm just using a
trick I am further composing that with
just this simple function that will
return in fact the list of destination
so this is a pattern that in fact takes
a list of objects a synchronously from a
request on a red server but it could be
of course anything else
each object will be analysed and updated
synchronously with other requests
another service other everything would
be gathered for each object then all the
objects are gathered in a single list
and at the end of the day we have a
single completely complete whole future
that will complete when all the
operations all the sub operations have
completed which is which is what we
wanted to do in fact all right so if we
if we put all these in in in a single
pattern now these popular destinations
rest for jax-rs I could as Ajax the rest
method it's a pure judge service method
we get this as Ingram we have in fact to
pattern it so I should explain so so if
you know jax-rs you know what that
that's just an annotation does so
basically it's a way to tell jack right
so we are on the sort on the server side
it's a way to tell jax-rs that we have a
request coming in and we want to post
the request processing meaning that we
will do some lifting computation in a
different rate and at some point in time
we will resume the request processing
from that external thread so it's
basically a way to deal with long
operation in jax-rs
so it's a jax-rs resource method
we tell jax-rs that we want to pull the
request processing because we have to
invoke many back-end services like here
we have this completion stage that will
go to the destination services and so on
and so on
and then what we are doing here we are
we are well we are performing our
execute execution flow so this is
basically our execution pipeline where
we deal with all the result and then we
need to tell to jax-rs that ok we have
all the results so now we want you to
send the result back to the to the
client right so for that we are using
the a sync response object that we have
injected in as a method parameter and on
that object we have the resume method
which is basically when we say
Jackthreads ok
during now you can resume the request
processing and obviously we have to pass
the result that we get through our
completion stage pipeline execution and
that result will be sent to the channel
so that's why we are where we have to
get ahead da so basically we we want to
have all the result and we want those
result to be sent to the client now
something which is important we are
putting the request processing on the
server side virtually the IO thread will
not will be will be blocking on the
server side and on the client side so
the client even though the request
processing is done in an icing fashion
on the server side the client will have
to wait obviously that it gets the
result from the server side so this was
the old way of doing things
using jax-rs - and now injects rs21
we still have the ability to inject
classic do a sync response object to
post the request processing but we can
also do it in a different way so if you
look at this method this is again a
jax-rs resource method but this time
this method is returning a completion
stage so this is basically a way to tell
to my Jack's rest container that we want
to pull the request processing and the
all it takes then is for that method to
return the completion stage object with
all the result and once that completion
stage will be executed jax-rs will use
that to continue the request processing
so basically sender is
back to the client so here we are
so before we we have explained you how
you can use basically the composition
state and jax-rs trying the site API and
here we are going a step further we are
using that on the server side and we are
also using the completion stage facility
objects rs21
to also handle a long-running operation
on the server side yeah the the biggest
difference between this pattern on the
previous one is that this pattern will
execute very fast why because all we are
creating our completion state objects
that are created immediately the
previous pattern there was this gate
call that was blocking so the method
would not have returned until the the
result would have been available which
is not the case here this is some more
technical confusions edge code is just
the creation of the function that I
showed you on the on the previous slide
so everything is created just just just
immediately in this Indian in this
pattern now the question is what happens
if some kind of error is coming in in a
pipeline let us take the previous let's
come on I showed you just a few minutes
a few minutes ago suppose that see s21
which is a request on some kind of read
server cannot complete because the read
server is down or anything all right so
this completion stage is in error the IP
I the API tells us that in fact all the
down streams completion stage of the
graft we've been building will also
complete exceptionally if we do not do
anything so it will in fact crash all
the other pipeline well that we created
now the nice thing is that this
completion stage API also provides a
method to handle errors get the
exception and do something with it and
either we throw it to say okay yes all
the pipeline is in error so we cannot
compute any kind of result but you see
that in in the in the case we are
dealing with this destination example
maybe if we do not have the weather
forecast is it's not too bad we can we
can live with it it will be a missing
information but
it doesn't have to break all the process
so we can also do that with with
completion stage in fact we have a first
method called exceptionally that returns
a new completion stage so it's really a
call that can be integrated in a chain
of a synchronous processing using this
API it will complete when the completion
stage it is called on completes itself
so there is no no lag or whatever in
this in this column either with the same
result which is the normal completion so
if this did not throw any error an
exception this exceptionally
Commission's it will just be transparent
nothing will be made in it or it will
trigger or if there is an exception the
exception or method will be called
getting that exception and that week
then we can do something with this
exception we can log it we can decide
that this exception is not too bad and
then just swallow it
and continue the processing normally all
we can wade through it just because we
think that all the process should or
should should stop this is the first and
I would say most basic method that we
can call to enter exception there is in
fact other exception there is the end
all exception that will take both the
result and the exception as a B function
that can do the same kind of thing
taking some kind of decision on what to
do with that with that exception the
difference is that this time this B
function will be always called with the
result and with new if there is no
exception because not the case in the
previous example and we also have a one
complete method that also takes this
time it's a big consumer and there are a
synchronous versions of it so suppose
that we are querying a given weather
forecast server and that this server is
not there with this one complete method
where if there is an exception we can
decide to trigger to request for for
another weather forecast for instance
and get a result that would be maybe
different but that will still be
valuable to their to the customer all
right so those are those are the
patterns of the of the exception and
laying first with the we have this
quotation Soviet that is requested with
the then apply in martial operation
so put that something goes wrong either
in the request itself or in the end
marshaling operation then we can call
this exceptionally method and just for
instance decide to swallow the exception
it's not so bad if the quotation service
did not respond maybe it is but in this
example it's not so bad and then we
continue then except destination that
set quotation so in fact here we are
just getting the exception decide that
the quotation is not there so we'll
return no because we do not have any
quotation and we'll just set the new
value in the quotation field of the
destination object so it's a way of
handling the exception saying okay not
too bad the distinction object will not
have its quotation but we can live with
it this is this is another another way
of doing it we can also have called this
and all method that will take the
quotation and the throw ball and then if
the throw ball is new set the
destination if it's not do do something
else right try to do something smart
with this with this exception so inside
this completion stage API we have
everything we need to enter exception
and either we throw them or deal with
them in in a normal way and lock them
and and do them handle them in in a way
to Italy it will not it will not break
the whole process of all the pipeline we
are doing okay so we have talked about
this new reactive invoker that is part
of jax-rs to 1a for our example we have
just used the get method but obviously
it's supported by all the method that
the jax-rs client-side container support
so it's basically all the HTTP method
except the patch method so you can use
the reactive invoker on all those HTTP
verbs using the jax-rs client-side API
now we have discussed a lot about the
completion stage api of java c 8 but on
the jax-rs side
also acknowledged that there are other
reactive API on the market so if you
look at the specification the jax-rs 2 1
specification has been written in a way
so that it's open
so the specification says that if you
want to be compliant with jax-rs 2 1 you
need to support the compression stage
API so this new rx invoker but the
specification is also open to other
solutions so a jax-rs
to one implementer might decide to
support other api than just the
compression stage api of java CA and in
fact that's what we do in Jersey so in
Jersey we obviously support the
compression stage API but we'll also
support the listenable future from guava
and we also support our X Java in our
Java 2 and that means that basically you
will be able to use those reactive api
and obviously the pattern that we have
discussed will slightly change but at
the end of the day you will see that
it's it's very similar now let's move on
quickly to CDI because CDI well first
play an important role in the Java
platform but this is not a Java I talk
so if you look at CDI 2 which is part of
Java 8 beragon you can use CDI outside
of Java and in fact it's one of the big
focus of CDI to being able to use CDI
outside of Java EE there's a new edition
which is quite interesting so you know
that in CDI we have since the beginning
and an event mechanism the thing is that
that even mechanism is synchronous so
it's blocking so it's basically a
consumer producer-consumer pattern
implementation so you fire you produce
an event and then you will add somewhere
else in your application consume that
event the thing is that you will consume
the event in the same thread as the
producing trade in jax-rs
2 we have support for a synchronous
event it works exactly the same way so
you inject an event and then you will
invoke the different methods so if it's
synchronous you will invoke the fire
method if it's a nothing event you will
invoke the fire I think method that has
been introduced in CDI - so basically
you are firing an even innocent fashion
and then you see you will have at least
one observer that will react on that
event
it has to be a nursing observer so to
tell that it's a nursing observer you
just need another method and you use the
this new ad observed I think annotation
to basically link the two so we have our
we are producing the event in a nursing
fashion and we are consuming the event
in a same fashion and if you look at
when we fire the event you see that the
return type that we get is a completion
stage of the given payload so basically
we have a competition state object that
we can use and combined with the API so
basically we can combine that with for
example the jax-rs pipeline execution
that we have just shown in a previous
example something also is that if we are
running well if we are running in a an
environment we might have to specify the
executor services that were using
typically if you are running in a Java
container you will have to specify an
executor services and in that case that
would be a manager executor services and
if you see you have the ability to
specify that on the CI front but also on
the jax-rs front you can specify the
executor the executor services to use so
wrap up so today we've discussed two api
that are coming from the java platform
java 8 that's Jack's arrest 1 and CDI 2
but basically we have used them outside
of your pure Java EE typical scenario
having said that all those patterns also
apply to to Java EE the thing that we
wanted to highlight is basically how you
can use those new capabilities with the
Java EE completion stage API to evolve
evolve your code to be to be more
reactive so again reactive in the sense
that your code is able to react on even
that are produce in an efficient manner
so that means that most of the time we
have to do that in a lasting fashion now
these efforts so Jax rs21 CDI two are
obviously part of Java 8 so they are
part of a larger effort and very quickly
we've done a lot of other stuff in Java
8 like having support for HTTP 2 adding
a new JSON binding API
having his new security API and so on
and so on now this is clearly not a Java
Java e8 talk so I will encourage you to
check Java 8 but also to look at those
API jacks or s21 and CDI and give them a
different point of view especially when
using the completion stage of Java SE 8
so with that we have a few minutes for
questions so is there any questions or
remark yes the completion and repeat the
question yes so the question is what's
the relation between complicates
completion stage and computable future
from a technical point of view
completion stage is an interface that
extends the future interface from Java
util concurrent in Java a5 sorry
completion stage has been introduced in
Java 8 and computable future is the
provided implementation of that
interface now there is something that is
kind of unusual is that in the interface
you have a two computable future method
that is present and that returns the
computable future object so in fact
there is a cyclic dependency between the
interface and the class and by the way I
used that in the slides just just to
match the the signature of maybe you
noticed it just to man the the the
signature of the other method that is
one of the method I was using was taking
a completable future and what the object
I was using was a completion schedule so
you have this this method this method on
this so yes this is the relationship
between between both elements of the JDK
any other questions yes
okay so the question is when you are
using jax-rs and the completion JPI on
the server side what happens if you are
calling it with the client that doesn't
understand that is not completion stage
or where nothing I mean it's just checks
RS call so it's basically when I was
discussing that we have the ability to
pause a long-running operation request
processing on the server side the client
will do a request we will post the
request processing on the server side
but the clamp will keep waiting that the
server send back the requests so it has
no impact on the client side the thing
is that for example if you look at the
travel agency services when we are using
the compression stage API to compose our
execution pipeline in an icing fashion
we are just reducing the time it takes
to basically send the result back to the
client
so we are improving the client but the
clown doesn't have the I mean it's pure
over the network we are just doing rest
call nothing else in fact when you
interact with this service you don't
have to be some Java code it can be can
be PHP JavaScript whatever because
everything that jax-rs
well everything that is seen by the API
is just a conversion of an HTTP call
pure HTTP so it's not necessarily Java
on the client side here on the example
it was Java because well yeah and also
something something which is a little
bit sometimes confusing is that we have
talked about you jax-rs client-side API
but if you look at our example we have
used the client-side API on the server
side so yes - yes
your are you talking about race
condition something like that is this
what you're thinking about okay so the
question is we have we have a beam that
that may be created in the main thread
and then we transfer that beam in an a
synchronous way to other threads from
the pull of thread from the executor
service that is going to handle all the
synchronous stuff other threads by the
way all the methods we saw could also I
said alright we're going to launch those
operation in other threads from inside
the completion the executor that
executes service all the apples before
links and things like that are our set
up in the in the completable future API
so that so that it's it's thread safe
and so that you won't have any race
conditions and in this kind of thing now
we're thinking of other things if you're
if you're getting your object from some
from the database from the from the
transaction thread and this transaction
thread dies because because it's the
HTTP thread which is the main thread and
you've returned you've left the jax-rs
method and you're just in a synchronous
way I haven't watched precisely this
part of the specification but since it
is done all over the place I would guess
that jax-rs the jet service guys took
care of that not not to have to not to
let all those threads die and those
objects link to the thread being some
kind of inconsistent or or corrupted
state first - yes but it's it's a good
question from from the pure Rayz
condition perspective everything is in
the completion stage API so it's okay
yeah well just one one thing so if you
look at the jax-rs specification so
jax-ur is basically defined how it works
on top of java c but also it works it's
also define
I would first on top of Java so I
haven't checked that particular detail
too but I will assume that this is being
addressed on the Java side specification
of jax-rs yes so the question is is
there a plan for supporting those dreams
I mean the reactive streams the flow the
fluid yeah yeah yeah which is yeah not
at this stage having said that if you
look at the early days of Jack's rs21
there has been some discussions
regarding the flow API the thing is that
Java e8 and and Jack's rs21 has to work
on top of IC 8 so that's something that
will I likely come and given that we are
moving the Java development to EE 4j
that's something that will likely come
on the e4j side
I think I get the question so the idea
in the example we repeat for the for the
recording so the example we get we have
a single destination service that
returns a list of destination and when
the the the downstream operations on the
completion stages chain are triggered
this place of destination of course is
full with all the destination objects so
the question is suppose we have several
destination services responding at their
own pace and we want to deal with that
well I think that what could be done is
that every you have to approach for that
either you think that you need to have
all the list of destinations to trigger
the rest of the processing then you need
to create a computable future that will
wrap all those different services and
that will complete when the slowest
service has complete ok all the other
the other approach is to say all right
each service will respond will respond
at its own pace so I will take every
service individually and then trigger
the rest of the other of my chain for
the quotation the weather service etc
for this subset of destination and then
trigger another completion stage for the
overall process of all the all those
chains and if the service is answering
is responding too slowly for instance
since you are
since computable the completion stage is
an extension of the future object you
have this get with the timeout on it so
if you say all right I want the answer
in 300 milliseconds and at that time you
don't have it then you can throw an
exception with the timeout call
exceptionally with it and do something
with this time I would maybe removing
the faulty
destinations due to the to the service
that was too slow to respond this is a
really powerful API very rich and you
can perfect yeah absolutely you can you
can deal with the the problem you stated
with it
with this approach yes I think we're
we're i turns up okay so we would like
to thank you for everything thank you
very much for your attention</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>