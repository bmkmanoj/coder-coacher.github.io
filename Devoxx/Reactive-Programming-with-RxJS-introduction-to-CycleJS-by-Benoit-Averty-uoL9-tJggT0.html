<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Reactive Programming with RxJS, introduction to CycleJS by Benoit Averty | Coder Coacher - Coaching Coders</title><meta content="Reactive Programming with RxJS, introduction to CycleJS by Benoit Averty - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Reactive Programming with RxJS, introduction to CycleJS by Benoit Averty</b></h2><h5 class="post__date">2017-06-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/uoL9-tJggT0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so my name is Benoit dirty I work
at Zenica where I do consulting and
training I like both front-end and
back-end developments but today we're
going to talk about JavaScript and more
specifically reactive programming with
rxjs my goal today is not to make a
comprehensive introduction to reactive
programming it's not to show you how to
do it from scratch or things like that I
have two two goals today it's one is to
show you that reactive programming it is
not just the the latest buzzword it's
not going to disappear as soon as there
is something more height and the second
thing is to the the most important one
is to show you that there's nothing
magical about rxjs it's really not that
complicated and it's a it's a technology
I think that is quite simple actually if
you if you don't do a very advanced
stuff but there isn't a lot of really
good resources on the internet to really
understand what's going on when you use
a reactive programming so we're going to
start with a little bit of theory so
hopefully it won't get boring the goal
is just to show you how our XJS fits
into the JavaScript JavaScript our
landscape and you will see that it's
really the logical continuation of the
the evolution of the language and so
what I'm going to do is talk a little
bit about basic building blocks of
JavaScript applications starting with
the function and what's interesting to
me about the functions in this talk is B
is the most basic way for a piece of
code to get a single value that you
don't know in advance so
really what I'm interested in its
dysfunction and not procedures which
means a function that takes a zero or
more arguments and get a value in return
so a function when you call it you
immediately get a value you can't do
anything between the time you call a
function and the time you get the return
value because javascript is a
single-sided language and it functions
with an event group and the the second
thing is that you can get only one value
as a return of the other function and
the first thing the first variant of a
function that you can have it the the
plural version which means you can get a
several values and this is the iterator
an iterator is much like a function it's
almost the same thing except that you
can get several values from an iterator
you have an object you have a next
method on it and you can call this mate
this next method several time possibly
an infinite number of times and each
time you will get a new value until the
iterator notifies you that there are no
more values to get and secondly the
second axis on which you can change
something from the function is the this
push pull mode to difference mode and
sometimes you will see a spatial and
temporal two and the equivalent of a
function but in push mode is the
promisor the main difference between the
function and the promise is that you
with the promise you can get a value at
an indeed at a later time and in the
future or immediately and the most
important thing to note is not the
timing of the value that you are going
to get it's the the way that the promise
will push you the value when you use it
so the real difference between a
function and promise' is that
it's the promise that decides when the
value is going to get sent to your to to
the code that uses the promisor and
really it's not the it's not the timing
that is important because the function
can take a long time to compute the
answer or a promise can be instantaneous
but when you use a promise you have no
way to know when you are going to get
the value or if you are going to get a
value at all because it can be an error
or cancellation and you probably guessed
where I'm going with this because
there's a that's a blank place on this
slide and until reactive programming and
libraries like Eric Jes this was a
missing piece in the observe in the
JavaScript language and this is the
observable that fits here which is the
decor object used in rxjs and in fact
you can see that it was a radio missing
piece and that it's a logical
continuation because now you have
observables in the JavaScript standard
you don't need to use our ideas to use
observables and the observable you will
see has both the features of an iterator
and the features of a promise so you use
it like this with the SUBSCRIBE method
if you have a one observable you use the
SUBSCRIBE method and it works quite like
the then method of the promisor
in which you you cook you pass a
callback function as a parameter and
this callback function will be called
with the data that your observable is
that is sending you and this will allow
you to make sure something with this
data you can also use an observable in a
more functional style by using for
example the operators kilter and map
which which look like the operators that
you use on arrays or iterator in
JavaScript and on this slide slide you
can see that the observable is both like
a promise because you don't use the
return
value of the observable that you use a
callback function and it also has the
features of an iterator array because
you use this kind of functional style
with the filter and map so really if we
summarize what I've just said the
reactive programming you have events
that are propagated by a source the
observable these events are Pro back
propagated in push mode whereas the in
which the the observable decide when the
values are going to arrive and you as
the developer as the user of the
observable you only define the reaction
the behavior of the that is going to to
happen when that arrive so this is not
complicated it's just the observable
design pattern this is something you all
studied in in school but the difference
in reactive programming is that we are
going to use this design pattern and as
the an entire programming style you will
make entire applications by using only
this design patterns and this is where
libraries like rsjs or others can really
bring you alerts and because they will
allow you to make really complex things
with this simple building block that is
the observer design pattern so I'm going
to talk about RIT is a bit rxjs is the
most popular library to make sure
reactive programming in JavaScript I
think if you've seen the we talked about
reactive systems this morning Eric this
is in the same category of libraries
which are inspired by the eric dot net
and has been noted to lots of language
including c++ for example but we are
only going to talk of javascript so in
our case you have observables of course
and you can you can create them from
several several ways the first one is to
use the from constructor for example on
the interval constructor and
the front constructor will make an
observable that emits the values
immediately upon subscription so when
you subscribe to this first observable
you will get the values 1 2 3 4
immediately but not as an array each
value will be separate and we'll call
the the observers one time each the
second one is the almost the same except
it will it will send you an infinite
number of increasing integrals with one
second interval so each second you will
get an integer which is growing these
are two ways among others but the most
generic way to create an observable is
to use the create constructor and in
this create constructor you can pass a
function and this one in this function
you will be able to define your own
system event emitting logic so this is
with this constructor that you can
create any observable that you like and
we're going to talk a bit about this one
after if you have observables of course
you need observers then this slide let's
assume I have an observable that I
created or maybe that someone passed to
me and when I call the SUBSCRIBE method
and this observable the parameter to the
SUBSCRIBE method this is the observer so
as you can see is the it's only a plain
old JavaScript object with three
callbacks three members that are
callback functions one of them the next
method is going to get called when the
observer send some data when the
observable send some data sorry and the
error on complete callbacks are called
when there is a respectively an arrow or
the completion notification of the the
observable when the observer doesn't
have any data left send earlier in my
slides I have made a subscribe code with
only one function as a parameter when
you do that rxjs will just assume it is
the next
call back so this is a variant that the
generic way to do that is by bypassing
this kind of observer of observer and
finally and perhaps the most important
things in our GS our operators operators
are simply a functions that will allow
you to transform your observables and
combine them and manipulate them and so
it will each time return a new
observable and don't it want to change
the the original one and this is what
will allow you to make really complex
applications and complex behaviors
starting from really simple building
blocks of a simple observables and I'm
going to show you some examples to
illustrate that so the first one is the
filter operator that you have already
seen it's probably familiar to you if
you use to make to you to do functional
programming or other things like that
and as you can see the result observable
on the bottom emits the same advance as
the source observable but only if they
satisfy the predicate that you give that
you have given the deity
so you have always on this kind of
diagrams which we call the marble
diagrams you have the source observable
on the top the operator in the middle
and the results observable at the bottom
and the second one is map operator which
is again exactly the same operator as
you can find on iterators or arrays in
JavaScript and it will just pass all the
events of the source observable into a
simple transforming function here a
multiply by 10 and the result observable
will emit these events and these two
operators that we have just seen they
probably look familiar to you and that's
because they don't use
the chronological feature of the
observables they don't manipulate or use
the timing of the events they just send
the events at the exactly the same time
and this is why these operators are the
same as on a race for example but there
are also other operators that will take
advantage of this feature of the
observables that arise don't have the
first one that I want to show you the
demurrer of the rater
in this one you you have two observables
and the emerge operator will make you an
observable that is the combination of
the two that will emit all the events
which one or the other source observable
will send and here you can already see
that this wouldn't make sense on a race
it wouldn't be possible to merge two
arrays like this because you wouldn't be
able to to know in which order to send
the events and you would need to provide
some other way to order them for example
a comparison function or something like
that but the male operator like this
with only the two parameters it doesn't
make sense without the notion of time
and you can see here that this event
happened between the two others because
chronologically it happened between the
two and if it happened just a little bit
earlier it would be at a different place
in the result observable even do the
even though the order here didn't change
at all and not on that you have also
operators that will be able to
manipulate the this time and just not
just use it the first one is the delay
observable the delay operator which is a
very intuitive here you can see that the
events on the result observable happen
after a one-second period of time for
there is the source observable this is
just a coincidence EP one here
and this for example makes it very easy
to implement features like like a
consolation delay for example if the
source observable is the an action made
by the utility by the user like you're
clicking on the button and the result
observable will be used to trigger for
example a network request you will be
able to use the delay of the operator
and implement a delay in which the user
will be able to console his action so a
grant on a little bit more complicated
operator this is the last one that I
will show you
it's the debounce greater and the debond
operator looks a bit like the delay
because it's it's it makes the advance
on the result observable happen later
than the source observable but here the
difference is that if you have a lot of
events that are that happened very close
in time only the last one will be
emitted and here you can see and if this
event happened earlier then it would be
emitted because you have the one second
period of silence between between him
and the next one if this like next one
happened here then it won't be sent and
again this this allows you to make a
very easily a behavior that is more
complicated without that it's for
example if you make an auto completion
form that can auto complete you don't
want you to make too many requests to
the server and especially when the user
types lots of of keys here for example
in a very short period of time it's
because he knows what is typing so he
doesn't need the auto completion
suggestion and only when when you have
here a period of silence in which the
the user has finished typing then you
can make your request to the server and
and suggest a list of of completions
with the result observable
okay I won't show you all the operators
because there are too many of them but I
want to talk a bit about some confusing
behaviors that can happen when these are
questions that I've asked myself myself
when I discovered the reactive
programming for example why isn't my
observable doing anything for example if
I wanted to make an HTTP request and
observable sometimes it doesn't happen
and you will see on the internet
sometimes that people say tell you and
observability is lazy and you need to to
activate it somehow but sometimes the
the opposite problem happens to HTTP
query with queries our executive twice
where only one would suffice you have
also the notion of hot hot observable
that's called observables and this is
not really easy to understand with based
on based on the internet articles and
synchronous or asynchronous nature of
observables this is not mr. necessary
that complicated but there are
contradictory informations on the net
sometimes you will see that observables
are synchronous sometimes you will see
that there are asynchronous and it's not
that easy to to know which one is true
so whenever a smelted these questions I
decided to go back to basics and to to
create my own observable to already
understand what's going on and this is
what I'm going to show you today so
originally I had the plan to do this
live coding in front of you but I wasn't
sure I would be able to speak in English
and at the same time do my programming
so what I did is I I recorded myself and
I will just comment the code so this is
a the code that I've done another we try
to explain to you
and to do that maybe I should yeah okay
so as I said the goal is to make an
observable from scratch and to prove to
you that I'm really starting from
scratch and not cheating of something
I'm just starting with a blank code and
the function and this function I call
dr. level but for now is just a plain
old function so I can use it like this
by using console dot log and passing it
the return value of my function and as
you can see on the right it works I have
my console dot log inside the function
and I get the value that I print in the
console the problem here is that I can't
do the the two features of the
observable the first one is be able to
send to return values and as you can
expect here it doesn't work because the
the second return is dead code it's not
going to get executed and the second
problem is that I can't do this input
not if I want it for example use the set
timeout to send the value after one
second I'm not able to do that because
as I said earlier JavaScript is a single
sided Caesar programming language
nothing can happen between the start of
the function and the return and there is
a one simple way and well-known way to
solve this in JavaScript is to use the
callback functions so this is what I did
what I did
I used the callback function and instead
of returning the value I call the
callback with the value the function
this way is no it's not use the exactly
the same but it's very similar and here
you can see that it works for now it has
exactly the same behavior but this time
and I am able to send two values to the
observer for example
42 and 43 and I am also able to do this
in push mode one second later for
example in this segment or and here you
can see that the value arrived at a
later time and what I have here is
already almost an observable you can see
that I have the two features of
so the board and this is really the core
of the observable but to go a little
further let's do something a little bit
more concrete and call make an HTTP
request to a server so you the server is
on the bottom right of the of the screen
here and it will just print when it
receives a request and it will send the
hello world string back to the e-collar
so here you can see that I've made the
network request and then on the top you
can see that I've printed the results
hello world in the console but if I do
if I'm going to start making a network
request I have to handle error cases for
example I'm going to simulate a network
error by Miss typing the address and
here you have the dreaded unhandled from
is rejection which is bad because it's
it's an error and you didn't manage it
and it's even said that in the future it
will completely dominate the anodic
process so it's not good
of course the basic way to handle this
and with the fetch API is to use catch
of the this is premised method and I can
just catch the error and send it to the
observer in the same way so here you can
see that I've handled my error I don't
have an intent and handled promise
rejection but this isn't a really good
practice because you are I'm handling
the error exactly in the same way that
I'm handling data so I have no way of
the observer I have no way to know when
I receive an error if it's an error or
some data so instead of just calling the
observer parameter I'm using the next
and error callbacks and instead of
passing just a function I pass be an
object which begins to look like an
observer and I had I have two different
call backs and on these two different
callbacks I am able to have two
different behaviors
for the error and for the data just to
okay and here you can see that my error
wasn't it was handled as an error and
not has as some more piece of data while
I'm heading callbacks I can also now use
the last from the self callback which is
the completes call back and this
callback is going to get cold when there
is no more data to be sent by the
observable in here since my observable
just does one request to the server it
will just tell the observer that it has
finished right after sending the result
of the HTTP request and it works
I get the observable has finished a
notification after and what I have here
you have to believe me it's almost
exactly like the observables are in Eric
J's of course Eric's provides the other
things like a row handling and educator
and but we will already be able to
answer some of the questions that we've
asked ourselves earlier and the first
one as you may have noticed I have an
observable but the shape didn't change
it's still just a function I didn't make
a class or anything I don't have close
rules and private parameters or
something like that it's still just a
function and if I command out the call
to this function of course nothing
happens this is perfectly normal because
it's a function but it's exactly the
same thing with the node server ball if
you don't call if you don't subscribe to
your server ball then nothing happens
it's perfectly normal so in a sense yes
observables are lazy but so are
functions it's a little bit overkill to
say that functions are lazy it's quite
obvious that if you don't call the
observable nothing will happen this is a
perfectly natural and then the same is
true if I call my observer or two times
this is perhaps less intuitive but if I
call my observer to time
you can see that I found the side
effects two times and in particular my
server received two network requests
again this is perfectly normal if you
remember that observables are just
functions and this is probably what
happens when you have two networks
requests it's just that you've
subscribed to your observable two times
if I wanted to avoid that to avoid the
making two Network requests what I could
do is take this request this fetch call
and put it outside my observable and
just use the result inside the
observable and if I do that then this
time I had two side effects to the
console that club inside may observe one
up and two times but on the bottom you
can see I observe my server received
only one request which is what I wanted
and what I've made here is just that
I've made a hot observable this is the
only the key difference let's say
between a cold and hot hotels
observables because observables are
going to upon subscription subscription
they will create their source of data
for example here network request but it
could be a WebSocket connections or
things like that they will create this
source of data and start emitting events
from this source to the observers on the
other hand hot observable will use a
source of data that is already existing
somewhere in the application and they
won't create one each time each time
they are called and this is really the
only difference and the last thing was
the synchronous or asynchronous method
matter and there is a really easy way to
test this is to make console dot log
before and after calling my observable
and I will be able to see when the
effects happened is it before or after
the second console the target when I
execute it you can see the orders of
events and the results terawatt which is
the result of my HTTP requests happened
after the second console dot log so it
would seem
here that in fact of solder balls are
synchronous but in actuality and what
happens is that my network request which
uses premised this is what it what's a
synchronous promise is a synchronous and
the observable it's like the observable
itself again it is just a function so if
inside I do something perfectly
synchronous like just continued observer
that next and this time you can see that
the 42 happened before ii consulted
trouble so to answer the question
observables are neither a synchronous
know they are synchronous they it just
depends on what you do inside it again
it's just a function so if you do
synchronous stuff inside and the
function is going to be synchronous if
you do asynchronous stuff going to get
asynchronous and again I can prove it to
you like this that you have to believe
me it's exactly like that in our exist
you can do the test yourself if you do
an observable in rxjs with only
synchronous stuff inside the observable
will be a completely synchronous the
subscription with this includes okay I
think this is the end of my video
so a quick summary and why isn't my
observable doing anything is it because
it's lazy yes that so is a function so
it's really just that you need to clock
the observable for anything to happen
because it's just a function same is
true for the HTTP queries that I
executed twice it's probably because
you're subscribing twice to the
observable and this is why when you go
to the internet they will tell you to to
use the share or multicast operator
something like that which seems quite
magical but in reality and what these
operators do is that they create a hot
observable from the cold observable and
the this will allow you to share one
source of data between all your audio
servers instead of making the the HTTP
queries several times and finally a
synchronous or asynchronous neither it's
just a function so it depends on what
you do inside there was last one
question which is a hundred how to know
what operator to use and as you can see
here and this image of the arrived J's
documentation there are a lot of
operators so there's no secret the only
ways to go read the docs and there is a
wizard that is done that is very very
well done where you can click on
questions that describe what you want to
do and it will tell you what operator
you most likely I need to use okay
speaking of operators here I've done
yeah I've made an observable from
scratch but we didn't make operators and
this wouldn't be complete if I didn't
talk about operators so as I've said
earlier an operator is just a function
that takes an old observable as a
parameter and will return a new
observable and this new observable is
just an observable like any other so
it's a function that takes an observer
as a parameter and we call the value
of this observer the callbacks of this
observer with some data so how is this
new observable going to get its data the
data will come simply from the
subscription to the old observable so
when you call the new observable it will
subscribe to the old one and pass it an
observer and in this observer we will
drill we will just call the callbacks of
the new observer so this is what what
you can see here when the old observable
sends a complete notification and it
will call the complete notification of
the new observer which was passed to the
new observable same for the error and
for the data this is when we'll be able
to implement the behavior of the
operator for example in this case and
when the old observable sends some data
which is for example the string this
observable will compute the length of
the string and send send this length to
the new observer so this is my operator
I use it by calling it like this we know
with an observable as a parameter and if
I do this then nothing happens except
the console that logo that is inside the
operator this is perfectly normal
because what I did is I just made a new
observable but I didn't I didn't
subscribe to it and if I didn't
subscribe to the observable is normal
that nothing happens especially and it
didn't subscribe to the old observable
so if I want to use this new observable
I just have to store it in a variable
and use it exactly the same way as I did
earlier by colonies and printing the
result in the console and this works so
what happened here the observable the
results was called which is the new
observable here and the type program
this new observable subscribed to the
ordered Salvador which made the network
request then it sends the value to its
own
observer which is you have server that I
defined inside the observable inside the
new observable that is inside the
operator and this computed the length of
the hello world string which is 12 and
sent it to be printed in the console so
if you're not used to to functional
programming and higher-order functions
did this may be a little bit more
complicated than the simple observable
but it's really not as you can see it's
still just functions there's nothing
magical in this and you can just spend a
little bit of time at home doing that
again and you will see that it's really
easy to make to make to get it to work
and here you will see that I wasn't
lying when I said this is very close to
rxjs because what what I'm going to do
is replace some of this code with the
code from rxjs and you can see that
nothing much much will change here
instead of creating my own function for
the observable I'm using the create
constructor I talked about it a little
bit at the beginning I saw that in the
function which is exactly the same i
remove my operator because i don't need
it because the rxjs provides already
lots of operators and including the map
operator which is able to do exactly but
what we've done and here instead of just
calling my observable I use the
SUBSCRIBE function and here you can see
that everything happened exactly the
same and this shows you that I've just
changed changed some plumbing some
utility functions but the behavior of my
event emitting is the same in the
parameter that I've sent to the
SUBSCRIBE is exactly the same so in fact
when you use the create constructor of
RIT is what you what you're giving to as
a parameter is just the SUBSCRIBE method
almost
okay so let's go back slide now you've
probably seen that the term reactive
functional reactive programming is used
quite a lot and this is because lots of
concepts that we have seen here are
exactly the same as in functional
programming first the unit immutability
of data and of observables because you
don't change observables and use about
operators you just create new ones a
pure function we without side effects
operators our pure functions and the
function that you will pass to the
operators it's a good practice to make
them pure as well and the notion of pure
data flow because the that the data will
travel in one direction from the source
observable through the operators to the
observer and in the opposite direction
you have only the subscription which
we'll get from the SUBSCRIBE method to
the source observable that you had at
the beginning and manipulating that is
fine but web development is not only
that you will also want to react to
click events for example to interact
with the Dom to make a single page
applications you will want to do network
requests and the question is how do I
make an application with only functional
coder and this is in fact a question
that I've got I've asked myself the
first time I discovered the functional
programming in engineering school
because my teacher said to me you can't
make side-effects in functions you can
have a input/output and I wondered how
do I perform a network request for
example if I can't do net
functional if I can do side effects in a
function and when when I did a little
bit of research about that I've seen
that you have to use monads it was said
so on the Internet at least so I've
looked a bit at what is a monad and I
found in particular one article that
said monads are the most complicated
thing in the history of computers
and this was a little bit scary because
I was young I just wanted to print
something in the console so I thought
this isn't a problem in JavaScript
because JavaScript it not it's not a
pure functional language you can do
imperative code in your subscribe method
and everything is fine but still this
question exists and this is what cycle
J's aims to answer for those who don't
know cycle J's it's it's a little bit
less known that arise Jess it's a it's a
framework a tiny framework that will
allow you to make functional and
reactive applications so to do that
cycle J's will take care of two things
first it will create observables as
input of the new application and this
are called the source observables in
psychology S will also perform the side
effects for you it will read the
observables that you pass and as a
result of the application the syncs
observables and they will perform side
effects for example a network request
etcetera and the application itself
between that is completely pure reactive
and functional and it will do that with
the help of drivers and drivers on the
the components that are really
responsible to create the source
observable from what they call read
effects from example the clicks HTTP
responses or things like that
and they will they will produce write
effects from things observables which is
for example dumb structural changes HTTP
requests and things like that and so you
can see that that on your on this slider
on the top you had you on your
application which is called main
function by convention inside you will
only use operators and observables you
will combine them you will have the
the pure data flow between all your
operators and observables and at the
bottom you have the drivers which will
perform the side effects and do all this
imperative stuff that you can do in
functional programming languages and
cycles is the framework it will only
connect these two things as you can see
on the on the diagram and this is what
forms the de cycle between yo main
function and the drivers and you have
lots of drivers that allow you to do
lots of things the most basic one on the
Dom drivers and the HTTP drivers and
this will allow you to make sure to
perform to change the structure of your
page to make a HTTP request and react to
events and there are also a lot of
community drivers for example you can do
WebSockets you can manipulate react
native or something like that you can
use the notification API of your browser
all of this you will do by passing some
special values in your observables in
your things observables so I've made a
very simple demo application which is as
you can see the most basic one I have a
counter on the right and I can change
the value of this counter by with two
buttons here is the code for this so I
have this main function here which is
the application itself as you can see it
takes the sources and the parameter and
on the bottom I have my be run method of
the cycle Jaso framework excuse me and
this run method we will do the will
create the cycle between the list of
drivers that product provided here and
the main function
inside the main function you will want
to do and most the same thing each time
you will first create observables that
represent the actions of the user then
from these action observables you will
be able to compute a state and the state
of the application again is just an
observable that will emit events
whenever the state change and from this
state you will be able to construct a
virtual Dom tree a view more generally
and this view is what you will send to
the drivers and which will be used to
render your application so let's dive in
a little bit here my actions are the
clicks on the buttons made by the user
so I take my dumb driver the source
observable that comes from my dumb
driver and this this is provided by the
cycle J's framework I select the
elements in my page that has the
increment CSS class and on this element
I take all the click events and which is
what I did here so what I get in this
observable and are the the kick events
as you are used to to get when you
perform for example on hum click and
handler so it's a complete dumb event
with the target and value it's red straw
and what I'm doing here is I'm just
mapping this entire event to just the
value 1 which is the only thing that
that's interesting to me here is that
when the user clicks on the button I
have a 1 that is sent in my observable
so this could be for example this
diagram here the user clicked three
times then I do the same thing for the
decrement actions and the difference
here is that I take the decrement CSS
class and instead of nothing to the
new one I map that to the value minus
one and this could give for example this
this diagram and then I want only one
observable for all these actions so I
use the merger operator and I get this
observable here as a result which will
emit the value one when the user click
on increment and the value minus one
when it clicked on decrement okay so
this is the way I modeled the actions of
the user and I modeled it that way
because it will make this easy to
compute the state of my application so
here on the counter state and I take my
observable of actions I use the start
with operator which is very intuitive it
just append the value 0 at the beginning
of my observable and then I use this
scan operator for those of you who know
the functional programming or who do
react or redux for example this is much
like the reduced function except each
time a new event arrives I will compute
the intermediate value and send it on
the observable so here you have the you
pass a function to the scan operator
which will take the current value of the
observable and the accumulation of all
previous values and it will be returned
the same the sum of the two so here for
example if I have had this observable of
actions then I get zero as a value from
the start with then I receive the one
value here so I do 0 plus 1 which is 1
then 1 plus minus 1 this makes 0 then
plus 1 I get 1 and thus when I get to
this is like readers from reduce on the
right except each time here you get an
event and the source observable I omit
the temporary value that is in the
observable and this is exactly the state
of the counter
that I will want to display then when I
have saw this count of state observable
and I used very simply the map function
the map operator and I will map this
count of states to a virtual Dom tree
which I described here by using div
button and P like for example this
function that I provided by cycle GS and
which describe virtual Dom tree with the
HTML tags but I could also use JSX for
example in here like I do in react and
this observable of virtual Dom trees I
send soon I don't driver excuse me and
the Dom driver will render your
application based on this
so here is the is a really nice
animation that I found on the Internet
unfortunately the screen is a little bit
too small so on the left here is the
application as you would see it on the
screen as you've seen in fact in the
previous slide and on the right is a
representation of the application with
the Box being operators and the observer
was done and of the lines that go
between them so when I click here on the
buttons I get some reasons that I are
not described and the events are mapped
to value and then they are merged into
action
these actions are used to compute state
the state is transformed into HTML tree
and this tree is then sent back to the
application and the Dom drivers will
rerender it based on this virtual Dom
tree of course this uses virtual Dom in
the background so it won't render the
entire application each time it would
make this very efficient but the basic
idea is the same it will just take
observables very simple observables as
advanced at the beginning and combine
and transform them into complex things
like complex Dom tree and requests and
things like that
which will be end up handled by the the
observables so as you can see a
psychologist allows you to make
application that are purely functional
and in fact as an experiment many people
in cleany have tried to use a special
configuration of es lint linter to
forbid everything that is not functional
in a in JavaScript so you can do you
come to the return you can do step
animals you can do anything that isn't
purely functional and even with this
configuration of es lint you are still
able to to make
applications with psychology s just with
the exception with the exception of the
the only cycle does run call to launch
the application thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>