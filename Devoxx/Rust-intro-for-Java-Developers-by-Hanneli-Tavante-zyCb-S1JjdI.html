<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Rust intro for Java Developers by Hanneli Tavante | Coder Coacher - Coaching Coders</title><meta content="Rust intro for Java Developers by Hanneli Tavante - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Rust intro for Java Developers by Hanneli Tavante</b></h2><h5 class="post__date">2017-04-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zyCb-S1JjdI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yes we were good to go
so welcome to the rest intersection at
devoxx I was surprised when this help
was approved but I needed to try to
bring rest because I am a Java developer
and I've been trying Russ for one and a
half year something like that and I'm
reading pressed with some some of the
features that I could find in this
language my name is Hanna Lee I am from
Brazil kind of a little bit far from
here I started the Brazilian rest meetup
in 2015 a while ago I write software for
this company called code minor 42 quick
disclaimer here let's set some
expectations this is a session about
rest features this is not going to be a
tutorial about breasts it's going to be
more about the theory behind the
language and why things work in a
different way for us and for Java for
example I'll be comparing both of the
languages because I guess everyone here
is quite familiar with Java and that's
gonna make the process easier to handle
with along the presentation so we're
going to see some gifts because I like
it's and it's you know early in the
morning before lunch so we all deserve
gifts so I'm gonna leave some references
for those who are really interested into
jumping into the language but this is
not meant to be a language war I guess
we both can benefit from different
resources from different languages so
that being said what is rest
what is rest come on talk to me a
language so if you go to Wikipedia you
get this interesting and super
meaningful description rest is a
general-purpose programming language
compiled strong and static type typed is
sponsored by mozilla research it is
designed to be safe
concurrent's vertical language
supporting functional ends imperative
procedural pair dictums it's like
wonderful we all know everything about
Russ now it's like when you go to
Wikipedia to try to understand more
about something and you end up
understanding about anything and more
than that you you you start questioning
your own existence
like what so rust is not another yet
another language built on it out of the
JVM that needs to be clear a while ago I
went to a Java conference to talk about
breasts and everyone thought that
breasts or almost everyone thought that
Russ was another language and adaptive
JVM and they were asking how can we
compare us to groovy in terms of byte
code I was like no no no no wait wait
wait
so that needs to be clear from the
beginning let's talk about why we could
go for the rest as a language she used
in a real project I don't know about you
but I have worked with embedded systems
systems for a while and sometimes due to
harder restrictions or so I wasn't able
to use Java well we can you know
sometimes we have restrictions so if you
can't use Java which is a language that
I assume you're all familiar with which
language would you choose to work with
embedded systems to think about hardware
with memory limitations and you know
sometimes you can't flush things into a
desk you need performance what would you
choose we could think about C or C++ and
that's the most common choice that I
that I've seen through embedded system
projects sometimes C and C++ are great
but if you're coming from an exclusive
Java background it could be a little
challenging to the budget right
especially if the team is not familiar
with you know C++ templates and things
like how or things like that it could
also be difficult to maintain deck
sometimes the language helps you to
write a better codes a code that it's
easier to maintain and so sometimes it
doesn't help you and from my experience
it's challenging to keep good code for
C++ it's very easy to mess up and come
with code from different templates and
things like that another challenge is
manual memory allocation right raise
your hands if you never forget to call
free you never forget to do that no it
was in your life well I do that all the
time when I write C++ but again
depending on the team memory manual
memory management can be a problem so
sometimes C or C++ can be a little bit
inconvenient depending on your team and
on the type of the project that you are
working on so in terms of a language a
good language to help us on the
development process would be a language
that doesn't force us to do manual a
manual memory management would be a
strong and static typed language
preferably compiled something that we
can you know achieve performance results
for embedded systems something that we
could reduce the number from time a
horse a language that is preferably
preferably open-source because we could
have a community around it helping to
maintain is helping to fix bugs helping
to spread knowledge that's those are the
features that we might be looking for in
a language so that's when I met rust
rust met all those requirements here and
along this presentation I'm going to
explain you why so let's take a look for
into a quick quick overview of Russ
structures have you ever tried to write
some code in rust is anyone in this room
totally new to rust
most of you are so I'm prepared for that
so let's have a very quick five
a tutorial about how we write coding
rest and then you can get the general
feeling the sense of this this language
so here's our function main equivalent
to public static void main right and
again like a good programmer I need to
write the fizzbuzz in a language to feel
how it looks like so let's write the
fizzbuzz is everyone in this room not
familiar with fizzbuzz not familiar with
fizzbuzz so fizzbuzz is gives you the
idea of printing sequence of numbers and
if this number is multiple of three you
print fizz if the number is smooth power
of five you print buzz and if the number
is multiple of three and five you print
fizzbuzz so from a sequence starting in
one going to up to ten or let's use ten
I would print one to face five six seven
eight nine ten
sorry once your face four plus six seven
eight sorry I can't do that from the top
of my head but I got the idea and then
when I reach 15 I have to print fizzbuzz
does it make sense
besides my terrible debugging and test
running mode so let's try to write a
function that performs this simple
action of getting a number checking if
it's multiple three five or three and
five and then actually printing
something to replace the number itself
alright so in our function main we call
a function fizzbuzz and in rest we come
with the name of the function right and
then we define F n for a function and
then what are the parameters that I
should pass here tell me an integer and
in rust we need to specify the type of
the parameter so in this case an integer
is an and yield 30 to sign a 32 bits we
have different
as well but that's the most common one
right so what do you need to do now we
need to iterate over this number we are
passing here right and then we can just
delegate this logic to another function
that actually is going to perform the
fizzbuzz let's write this function tell
me what are going to be the parameters
the arguments of this function another
integer another u-32 right and what
should I do now I'm sorry to give you a
programming challenge early in the
morning but that's not the most
difficult ones reverse and red-black
trees is much more difficult
so we basically are going to add this
ugly stuff it's not the best code that I
can produce but it's what you do in
order to try a language so if the
numbers if I bow by 15 which means it's
both both multiple of three and five you
print fizzbuzz if it's by three you
print phase and if it's by five you
print bus and if it's any other of these
alternatives you just print the number
itself okay
does it make sense does the syntax make
sense I think so
the only missing thing here is
implementing the function is a visible
by what are going to be the parameters
of this function the number itself and
the number you are trying to divide so
from there it's pretty much
straightforward just your name calls and
you get the read of the division all
right are we all set yeah we are so we
implement it fees the fees bus and with
that we can understand some basics of
the rest language first one we need to
specify the types so it's strong typed
we also need to specify the type of the
return of of a function or method so for
example is is visible by is to return a
boolean right now we do that by using
the arrow we saw of basic for loop we
also saw if-else closes and it's
important to notice that rest
as a limited type inference so you can
come up with a number or a string
sometimes you don't need to declare the
tie but when you have functions you need
to make it make it explicit right
another interesting information that are
having in rust as you know see those
macros so the language has mattress to
help you to be a little bit less verbose
the same the same thing that are having
Java rest is as variables as Java is
sometimes a little bit more so you can
come up with markers to help you to
reduce the number of code that you
actually write so let's continue ah with
some interesting information that
interesting information interesting
concept that are having rest in Java are
we allowed to do that you come up with a
variable and then you add plus one well
in realist and that's probably one of
the first things that it trying a
language but that's gonna give you a
compiler error but I like you just
downloaded the language and you try to
write this one plus one and then you cry
because the compiler yells at you say
don't do that
bad boy so in rest everything is
immutable by default which means that if
you really want to make mutability
explicit you need to use a keyword
saying hey I am aware that I want to
change this value and I'm gonna add some
the mute reference here so this way if
you have a mute value we can actually
change an ad plus one okay so everything
is immutable and there is a good reason
for that
let's go through another overview really
quick quick another programming
challenge for you we want to find the
sum of all these squared odd numbers
under 1000 difficult now we can make it
even early in the morning we can make it
so first thing I did was defining a
function called is odd that gets a
and checks if it's odd right we define
an upper limit and then we can do some
sort of functional programming here we
come with the sum of squared odd numbers
which is gonna return us the sum that's
why it's 32 right then first thing we do
we get all natural numbers squared does
it make sense
do you like functional programming in
Java so it can pretty much follow the
same concept below the upper limit which
we set here right that are odd and then
we fold them to sum and then we print
the result difficult so rails has high
order functions and that can be pretty
convenient right other interesting
features are tuples and instruct
straights I'm not gonna gonna go over
through all of them we are gonna just we
are going to see traits by the end of
the presentation but that's not the main
focus so Russ has some features now that
I've had the sense of how the language
works and how you organize your code and
how you call some basic functions and
pass parameters risk claims should be
memory safe and data raised free and
having that immutability attach to the
variable bindings is part of the key
concepts to achieve memory safe in
database free you have a very smart
compiler and it's a very variable
compiler if you do anything wrong in
terms of types or in terms of
assignments the compiler is going to be
yelling at you all the time and throwing
you a bunch of a bunch of compiler
errors but that's good because it
reduces the number of runtime errors so
it's better to get an error at compiler
time rather than getting it at run time
it has a very good interface we've seen
C++ which means you can call native C
and C++ functions it has good generic
support which is pretty much similar to
the one that we have in Java
of course it supports polymorphism the
community among breast is very strong
and active a lot of the documentation
was were actually written
by members of the community and it's
open source so it meets a bunch of
interesting requirements based on what
we saw in the previous slides and has
some bonus you know about us the same
level for buzzes yes Java and the
compiler itself for very verbose all
they're interesting and for me those
were like heroes features about rust is
the absence of a garbage collector and
if you have ever worked with embedded
systems sometimes the garbage collector
can be inconvenient so sometimes people
claim that they're going to use C++
because there's no GC but rust has no GC
as well so how does it work
so every time I sell language that has
no GC I start praying and say oh no now
I have to do manual memory management
and that's not really true russ has a
bunch of features she prevents you doing
manual memory management and providing
the absence of a garbage collector so
first of all how do you achieve the
safety risk claims that there are no
segmentation faults how do you achieve
that that's that's brave to claim that
so let's see some interesting features
in Braille that actually prevents
segmentation faults so imagine this
factory here can we actually do that we
saw an example before can we do that
you're getting a factor and get another
factor in passing it if everything is
immutable can I do that yes no you can't
because you're explicitly moving the
value of a binding to another one
so when you have a binding this is
immutable and attached to what you
defined so we can't really do that the
rest the rest compiler is gonna yell at
you
and by this point you're almost giving
up or moving on to rest because it looks
like you can't do anything so
let's understand what's going on here
it's not impractical it's just a way to
prevent memory errors and again to
prevent segmentation faults if you
really want to share a reference you
need to tell the compiler so you
remember if you really want to have a
mutable value we had used the specific
keyword mute the same thing is going to
happen here so if we really want to
share a value let's say with a function
we need to tell the compiler so let's
build this together we have to chill
vectors and you need to call a function
passing the values of these factors but
again if we call this function and in
pass a value we are screwed up the risk
of Polaris Gunilla is not gonna let you
do that
so let's build this function it's going
to reduce the values of two vectors into
a single integer okay that's the the
goal of this function so in order to do
that we need to get those factors sum
them and iterate of the values and
actually come up with an integer but at
the moments that you pass the values of
factor 1 and factor 2 the compiler is
gonna blow up because remember the
binding is actually attached to the
variable so you can't really do that but
in this case you really want to do that
you know that your function is not gonna
harm your own code so what do you do so
in the rest you need to tell the
compiler that I want to borrow this
value to a function and that's the
meaning of this symbol here you're
telling a compiler I know what I'm doing
and I'm borrowing this value to a
function and you need not only on the
function but I need to specify that on
the argument you know that those
arguments here are being borrowed you
land them ok does it make sense
and again that's a way to prevent memory
management problems
so this function does this this feature
is called boring for obvious reasons and
you might be wondering why is this thing
done on this way have you ever heard of
the read writers Locke motto it's pretty
common for distributive systems for
example for those who are not familiar
with imagine that I have my vector one
here and I have a bunch of fried readers
asking hey if you want what's her value
hey everyone what's her value so since
the value here doesn't change I'm safe
to be telling what my value is but what
would it happen if a writer shows up
trying to change the value it wouldn't
be safe anymore to provide the value of
v1 so when you have a writer coming on
what really happens is like the writer
kicks out the readers get out of here
and now the writer can actually modify
the value that you have here does it
make sense and one it's done the writer
goes away and the readers can go back
and again ask for the value of a certain
variable that's the read write read
writing lock model so in rest we have a
similar memory model where we have
either many readers or one single writer
and their readers they do not require
exclusive access you hope you can have a
bunch of fritter at the same time but
you can only have a single writer at a
time okay we're gonna make sense that's
why birds can prevent seg faults because
it follows this policy so in relased
again you have the base type that owns a
value that's immutable remember we just
solved the boring and the boring is a
shared reader and when you have the mute
is an exclusive writer does it make
sense now why you have all these
keywords and how they are combined
together then when you have the muse
then you have the immutable reference
and remember mutable reference
references need to be exclusive so
imagine that have this code here you
have a moveable reference right and then
you have these and your boring a mutable
reference what do you think is gonna
happen does it look good
remember you have either a single writer
or shared readers so that looks totally
wrong right and that's really wrong and
the compiler is gonna be a lien to you
what the hell are you doing stop so the
compiler is going to prevent you from
doing most of these mistakes with memory
management so borrowing prevents
iterator invalidation data rates
problems the user of the you try to use
a variable after freeing it and so on
this does this memory model makes sense
to you up to now we are still missing
some things if the rest has no GC how do
you get rid of all these variables we're
missing that and it it could be very
easy to mess up with boring if you don't
know for how long a variable is
available to you so that sounds terrible
but now you don't have to handle memory
allocation manually compress like I said
there is another strategy that's pretty
convenient before you give up and say no
that's too difficult for me so let's see
a little bit of life timing rest so
every time you start a function the
function itself has a lifetime
and wants to declare a binding here the
binding is going to live from the moment
you declare this on this line until the
end of the function we know that so for
instance which one is going to live
longer a one or a two
hi a one lives longer than eight you
because a one was the clock declared
after and so on and so on does it make
sense
we know that these variable binding
starts living here and it ends by the
end of the function so everything every
function ever every inner function here
it's going to keep this variables alive
because the outer function is not
finished yet and by the end of the
function the lifetime is over death
massive death destruction you can't
access that anymore does it make sense
that's why it's important to keep that
in mind it's it's when it's your flag
sign to tell you when you can use a
variable or not so you can also make
their lifetimes explicit in rest let's
say you want to make sure that b1 is
gonna live enough to reach this function
but not this function how can it make
life time shorter so have some control
over the lifetime by making them
explicit on the function calls so every
time you pass a parameter to a function
you can also make the lifetime explicit
you can also have multiple lifetimes for
every parameter that you have and turns
out that's pretty convenient if you want
to have a fine-grained memory management
right does it make sense you can control
the lifetime here and by the end of your
lifetime of course a variable is free so
with lifetime the GC is not really
necessary anymore because we have an
idea of how much every variable is gonna
live and we know that after that lot
that lifetime no one can access that
variable and turns out that's a very
good mechanism to avoid dangling
pointers I've done lots of objective-c
and I was always running into dangling
pointers and turns out that that's a
difficult issue to notice that you're
going to have and rest is very good to
prevent dangling pointers of course no
manual memory allocation nor free you
just need to
be aware of the lifetime of your
function so is Russ always safe that's
one thing that I asked myself and by
following the ideas of borrowing
immutability in lifetimes it is pretty
safe however you can explore other areas
by interfacing with C++ and then Russ is
not going to beat that safe okay before
we talk about safety let's go through a
quick comparison between rest and Java
and then if you want we can jump into
the interfacing with C++ because I think
that's quite interesting so risk has a
good generics system it's pretty much
similar to the one that we have in Java
it also has traits pretty much like
Scala has so let's compare some classes
in Java this is a random class in Java
and this is how it looks like in rust we
don't really have classes itself we have
something similar to C in C++ where I
have a struct
I stripped and an implementation for
that right does it make sense you have
the future on a place and the methods in
the other right that's pretty much how
we can compare both languages both have
primitive types both Java and rust if
you want to write an interface that
would be something like that and here's
an interface for Java 8 here is a trait
for rust and we can explore some
concepts for interfaces notice that we
can have a trait so we can implement
certain anymore for the trait and we can
implement the same animal for without
being bound to the trait that's
something powerful that Russ has so you
can bounce multiple structures to
interfaces to different interfaces and
have the same type without being bound
to an interface so if you notice I have
animal here
and have horse and have like this horse
following this contract but this horse
doesn't fall off the counter and if they
are both horses when following the
contract and the other one not following
it so that's a feature that you can try
to achieve by giving different names for
interfaces in Java but I don't think
there's a real one-on-one equivalence
the generics are my favorite part
because they are much shorter and the
syntax for rusts generics for me it's a
little bit better to manage it's not
that convenient when you're managing
lifetimes for generics because then you
have to make the lifetime its explicit
but it tends to be a little bit shorter
than than Java
here is a more complex example with
upper and lower bounds same idea that
Scala or even even a little bit
difference you are specifying the the
classes there are boning individually
not in a group of subclasses it's not
really an upper bound you're just
throwing the classes that you're going
to allow here so I think I have a few
minutes left and I would like to talk a
little bit about rest interfacing with
C++ and C and that's when things can get
complicated because your sense of safety
is compromised like I said you can call
native functions from scene C++ inside
rust but when you do that since the the
C and C++ are not really safe they don't
provide your lifetimes and borrowing and
so on you need to use this word unsafe
and that's when bad things can happen
because if you explicitly announce that
you're being unsafe then you can get
dangling pointers and problems with
segmentation faults and so on so be very
careful by using this directive here
when I was learning rust
I used to add this involving my code
because it would compile so that's
basically their active
that says compiler shut up I know what
I'm doing
however it can bring you a bunch of
problems so use that wisely
I've been doing some respect projects
and the best way that i have found to
use unsafe is for native calls and i
always wrap them in another function
that i have control over so if you have
an unsaved call wrap it well wrap it up
into an external function digits in
other words don't do that don't open
your main and then throw your code in
there and then everything and expect
everything to be fine because it won't
be so Israel's perfect of course not and
I would like to tell you a little bit
about the downsides of the language of
course I'm kind of evangelizing the
language for because I think it's
helpful but I felt some of the downsides
of this language in some of my projects
the first thing that I noticed was about
the learning curve because oh man you
get the language you can download the
compiler and then you try to bind a
variable ends at +1 and it doesn't
compile and then you try like sheep as a
factor to a function and it doesn't
compile so the learning curve is kind of
frustrating it was it was one of the
most difficult languages that I try to
learn in a short amount of time and it
was really challenging for me I got lots
of new concepts I wasn't familiar with
lifetimes at all and it took me a while
to understand how it works and it took
me a while to understand why my code
wasn't working or why my code is working
which is even worse that was a pretty
new language I mean it's been developed
but since eight years ago however it
just came out as a popular language in
the last three or four years so it's
pretty new so the amount of questions on
Stack Overflow was quite reduced
when I tried rest for the first time so
that it was quite challenging so I think
the community really helped on the
process to make all these three points a
smoother
like I said they tried to come up with
better docks so for instance Mozilla
reached a campaign to encourage people
she improved the dog the dogs and it
turned out pretty well the docks are
much better nowadays by starting meetups
I noticed that other people around me
were trying to learn rust and we started
studying together to try to figure out
how to solve some of our problems and
fight and last but not least the tools
so when I started playing with rust it
was only the language and then they came
out with cargo which is like a maven for
for managing dependencies in libraries
in rust which is pretty convenient and
then after coming up with a cargo lots
of people started creating their own
libraries and sharing it so nowadays you
can do a bunch of things in rest
starting with web development going to
you I don't know linear algebra with n
dimensional matrices if you want to do
something like that there is a library
rest going to genetic algorithms and
things like that which is pretty amazing
for a four-year-old language having the
amount of research resources that Russ
has is quite impressive and I'm not even
counting things that focus on hardware
and embedded systems because you are
gonna find a ton of things and get help
starting for starting with your own form
words written in Braille or things like
that
so this disengagement that the community
has with the language really helps you
to jump into a real project and get
something done with rust even though
like the learning curve is not the best
having active and you know interesting
projects it really helps you to get
something by the end of the day
so quick Manos how do you describe the
rest type system following this this is
a PhD thesis I was reading and that's
quite interesting there was someone
that's doing his PhD and he's trying to
formalize their birth type system there
was quite challenging actually and I
would classify it as static and somewhat
strong for most cases pretty much like
Java a static and somewhat strong
comparison which one is faster Russ or
Java so turns out that rest is much
faster than Java for some particular
problems so if you get the well-known
Mandelbrot algorithm rest is gonna be I
know to time more than two times faster
than Java and that's happened if you go
like to the famous benchmarks game
website which is kind of a reference to
benchmark different languages you can
see other different algorithms that rest
easily could be Java on the other hand
some of them are really bad so if you
get the K nucleotide it's gonna be much
worse for both standing Java for example
this those were between rust 1.5 and
Java age some of the versions of Java
eights the most recent versions so yeah
we can see like we have good and bad
points of adopting rust not everything
is going to be faster here's a free gift
for you because you made it to the end
of this presentation so here are some
references this first one is a video
about a tutorial if you want to jump if
you want to jump into rest that's one of
the best tutorials that I have ever seen
because it's not one of those is lo
tutorials where people say now type this
now check this function I just clone a
repo and then you can interact and then
you can fold these tabs on the video so
that's pretty good
I also already have some external
references omits just a bunch of links
but the most important it's the first
one and the last one of course that here
is good comparison between Java and Russ
in terms of performance I've been
talking about Russ for a while I have
some talks for intercessions with rest
and pokemons if you like pokemons like I
do you can follow my tutorial by
building pokemons with rest I also built
I also delivered another talk about the
rest type system itself if you're
interested I presented this at Python
Brazil last year and that's it special
thanks for the devoxx team who brought
my rest talk into into this conference
and thank you very much for attending
this session we have ten minutes and
questions hi so first thank you very
much for an interesting talk and the
previous one - so you talked about when
you talk about type safety in life times
I could see how it would walk if you
have you know stuck allocated stuff and
then you know they go out of scope
essentially again uh-huh how does it
deal with something like a linked list
where you don't know in advance how many
elements you're gonna have how does it
deal with the now kind of type safeway
doesn't make sense so it doesn't have a
link at least as a building type have a
race and factors but if you want to if
you want to build that remember that
evening always need to borrow your
reference so if you if you have a
linkedlist you have to borrow your your
previous reference so have to keep
borrowing it and if you try tracks or
something that it didn't borrow the
compiler is going to blow up you don't
do you it's not you that's gonna do
located it's so wild the linked list
isn't a lifetime you can safely access
its members once the lifetime is over
you can't
and the compiler can evaluate if you try
in compiler time it can evaluate if
you're trying to read something outside
of the lifetime remember it's a static
typed language so it means that there's
code
tracing some stuff for you and they can
actually in for the lifetime is valid or
not so think about that when you compile
it's gonna bow to removal you don't get
the same object you need to copy the
object for example that's how I use of
that yeah that's the way to solve that
to remove it you copy I think I'm not
sure about that but there's probably a
better way it should do that without
copying or like doing a backup of parts
of your list and then to allocating the
rest but the first thing that I would
think about doing is copying because
things are immutable and removing it'll
be the case where it can't borrow so we
have to copy
and what do you personally use Russ for
so I like maths and I was personally
trying to develop some linear algebra
libraries for replacing some maths code
that I found in octave so I built in
rest and it actually became part of an
open-source project
I was helping some postgraduate students
at the University that I graduated in
and we came up with some improvements
for this linear algebra library I gave a
session at West fest
in Europe to talk about this library so
that's my particular interest for us and
turns out that the performance is much
better I've seen a bunch of people
building embedded systems for drones for
robots for IOT with rust because it can
replace in C++ and I saw lots of people
who are tired of C++ it's not well it
happens to some people they get tired
and they try to to find a new language
and they might rest any other questions
gifts all right thank you very much if
you have any further questions I'll be
around</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>