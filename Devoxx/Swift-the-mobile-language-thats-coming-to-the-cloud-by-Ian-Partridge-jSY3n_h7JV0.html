<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Swift: the mobile language that's coming to the cloud by Ian Partridge | Coder Coacher - Coaching Coders</title><meta content="Swift: the mobile language that's coming to the cloud by Ian Partridge - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Swift: the mobile language that's coming to the cloud by Ian Partridge</b></h2><h5 class="post__date">2016-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jSY3n_h7JV0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon everyone welcome thank
you very much for coming hopefully
you're in the right room we're here to
talk about Swift which as the subtitle
suggests is is a mobile language which
is being expanded into a new and
exciting opportunities just a very brief
background my name's Ian partridge I
work for IBM as part of the Swift IBM
team my background is is in runtime
systems I worked for a long time on the
development and support team for IBM's
Java Virtual Machine I was one of the
authors of the garbage collector in the
IBM virtual machine my parents always
thrilled that I was working on the
garbage collection team it sound it's so
glamorous but for recently I've moved
over and I am now I'm working on Swift
which is a new language and a new
opportunity you can catch me on Twitter
or github and see what me and the team
were up to there if you've got any
feedback from the talk afterwards please
do tweet me and let me know so what are
we going to talk about today well we're
going to talk about Swift what what it
is where it's come from where it might
be going in the future
so a bit of the history of how we got to
this point then we're gonna talk about
the Swift language itself this is kind
of gonna be a bit of a language 101 for
people who've never seen Swift before to
kind of give you the the basics and a
flavor of of how the language looks and
how it works and then we're going to
talk about the work that's going on to
bring Swift to new places mainly the
server side so what it takes to bring a
new language to the server from from a
completely different background we'll
talk a little bit about what you need to
do that and also a bit about the web
framework which we're developing inside
IBM in Swift
so what swift it's a new programming
language designed by Apple to be the
future of iOS and Mac OS development so
I could see a lot of people with Apple
hardware in the room for the last 20
plus years if you were developing
applications for Mac OS or more recently
for iOS TV OS watch OS you'd have been
doing that in Objective C but Apple are
engaged in a huge migration effort to
move that developer community from
Objective C to Swift and that that that
has been ongoing for a number of years
now and that that migration is still
happening Swift is a general-purpose
systems programming language it's
designed to be a replacement for
objective-c obviously but also for
languages like C and C++ so it's a
compiled language the three bullet
points that people mainly associated
with it are that it's safe fast and
expressive and I'll talk a little bit
about now about what each of those kind
of means and why why you might use them
so why is it why do people describe it
as a safe language well firstly it's a
type safe language so everything in your
program has a defined type unlike
languages like JavaScript which are
dynamically typed but it does have type
inference so you can avoid a lot of the
kind of unnecessary keystrokes that you
get in languages like Java where you're
constantly having to teach the compiler
over and over again what the type is
that you're talking about it's also safe
because it solves a whole category of
problems which kind of well-known that C
and C++ have been dogged with so for
example in CMC fly sauce you don't have
to initialize your variables and if you
don't their contents are undefined well
you have to in Swift the all you have
look variables have definitive
initialization it has immutability as a
core language feature and what I mean by
that is that when it's just as easy to
define something at the constant as a
non constant and in many ways defining
things as constants is the
is the right way to do things it has no
implicit type conversions if you want to
go from a 64-bit to a 32 bit int or vice
versa or you want to convert between an
int or string you have to there's
nothing comes for free you have to you
have to say where you're going from and
where you're going to and that forces
you to think of programming time about
these things so issues like integer
overflows type conversion errors all
those things are designed out of been
designed out of the language and the
final one is kind of strange is that
objects cannot be null when we're kind
of used in languages like Java that if
you have an object and you don't want to
refer to it anymore you can just set
that reference to nil or null in Swift e
in Swift you can't do that everything
all the reference every reference has to
point to an object at all times unless
you use a specific language feature
called optional which I'll talk about
later and of course the consequence of
this is if something can't be null you
can never have a null pointer exception
so the kind of designs that problem out
of the language but of course sometimes
you need something to be null in this
there's a way to do that which I'll show
so the syntax which I'll get to in a
minute is is broadly inspired by the C
family of languages so if you know Java
or you know JavaScript or you have come
of worked in some of these other
languages with that kind of heritage
you'll feel at home it's not wacky and
out there but at the same time it has a
lot of modern features which are more
commonly known from scripting languages
like Ruby and Python it has features
like generics it has closures aka
lambdas it has two pools which we'll
look at and it also supports some
functional programming ideas things like
map filter reduce come baked into the
standard library ready for you to use so
if you're a fan of functional style
programming you can do that in Swift as
well and that the third bullet point was
fast it's fast because it's compiled
native language so when you run the
Swift compiler you're not generating
some bytecode which is then going to be
interpreted and possibly
did your gets compiled directly down to
machine code and it's built on top of
the LLVM optimizing compiler
which is an existing open source project
which is produced amongst other things
the clang C compiler it's also fast
because there's no GC pauses those of us
who worked in Java for a long time have
spent many many hours tuning our garbage
collectors to eke out another one
hundredths of a second on each pause
time I know I made a career of it for a
while but what it so it doesn't have a
garbage collector but what it does have
is something called automatic reference
counting so in in an AR C scheme every
object in your program has a number
associated with it which is the number
of times that object is referred to so
the number of pointers to the object so
every time a new reference is created to
the object and that number is
incremented and when the reference is
broken is decremented by the system
automatically and of course when the
number drops to zero
that means the objects no longer
referred to so it can be freed the the
problem with these kind of systems is
when you have two objects which refer to
each other because then both of them
have a reference count of 1 but
technically if there's nothing else
coming from outside then they could be
collected
that's called a reference cycle and
there's syntax in the language for
working around that it also has
concurrency so it supports multi-core
hardware and there's a framework called
Grand Central Dispatch which I'll run
through the basics of later which lets
you have run parallel programs so what's
the timeline we don't know exactly when
Swift kind of began but we can make a
guess guess is around 2010 when it
started on someone's laptop inside out
inside Apple but it was kind of revealed
to the world
two years ago WWDC is Apple's annual
developer conference as many people know
it was June 2014 when they revealed that
they've been working on this language
and they released at that point of beta
of Swift 1 and since then it's been kind
of going on a yearly cadence so at each
successive WWDC there's been a new beta
with the GA later on in the year
coincidental with a release of iOS but
the really interesting thing happened
last December and that's when Apple open
sourced Swift on github they denounced
their we're going to do that at WWDC but
their code finally landed on I think it
was December the 4th last year and
that's when a lot of other people got
interested because until this point
Swift had been interesting technology
but closed closed source proprietary
entirely limited to apples ecosystem of
devices as soon as it was open sourced
on github there were new opportunities
so the main Swift website is Swift org
and the code is all on github slash
Apple slash Swift I said we thought it
started in 2010 well the reason is
because they actually open source the
entire repo history at that time so it
came with a history of tens of thousands
of commits and the first one of those
was in 2010 so you can really do some
software archeology if you if you want
to do that that number there's
out-of-date it's well over 40,000
commits on the open source project now
and more landing by the hour is one of
the most active projects on github and
the reason Apple put on github I think
is because they wanted to build an open
developer community around it and
certainly I found and we found in IBM
that it's it's been really good working
in open source Apple have even recently
started guaranteeing commits access to
their repos to community contributors so
there's just a few smatterings of
comments and feedback on github which
has been really great to see and of
course one of the things about open
sourcing something is people can take it
in directions you might not have
anticipated so yes you can now build the
Swift compiler for Android and you can
you can call your Swift code from inside
an Android application if that's what
you want to do
no user interface compatibility between
the two those actually mentioned or you
can't see the bottom there there's a
link there I'll put the slides on speak
attack afterwards if you follow me on
Twitter you can get them but github
satellite where as a conference earlier
this year where github spoke about the
work that's been going on an open source
with Swift how fast the innovation has
been happening and so there's a there's
a talk with a youtube link there which
is worth watching and and this is kind
of what's happened so to explain what
you're looking at here on you've got two
graphs obviously two plots separated by
two years so third quarter 2014 and
third quarter 2016 and what we've got on
the x-axis is popularity ranked by
number of github projects and on the
y-axis we've got a popularity rank
buying number of Stack Overflow
questions which is kinda interesting
thing to plot for a whole bunch of
different languages and see how that
changes over time so you can see that
back in 2014 two years ago there was a
much code on github we're pretty much on
the left-hand side of the chart but that
people are asking a lot of questions
about Swift it was a brand new language
only just been announced and over the
last two years Swift has drifted top
right up towards up towards the top
right there and you can see now there's
lots of code on github and still even
more questions and answers being
generated on Stack Overflow so Swift is
rapidly approaching languages like Scala
Perl you can see rubies up there the the
big the big languages also worth
mentioning them when it was open sourced
it was I've been sourced under the
Apache License version 2 which as you
may know is one of the most popular
open-source language open source
licenses so that provides kind of the
reassurance that the community needs and
also that companies need that this is
this is something they could get
involved with from a legal point of view
I'm ention der leer that swift's built
on top of the LLVM compiler in
for structure but that's not the only
existing open source project that's
being used like pretty much all software
nowadays Swift is current building on
the shoulders of the Giants of people
gone before so as well as the LLVM
compiler infrastructure which is
underlying the Swift compiler you've
also got things like it uses lib XML for
XML uses ICU for Unicode the build
system has C make and they use Python to
auto generates code so Swift itself is
is building on solid foundations so if
you go to Swift org and you download
Swift what do you get you get a compiler
obviously which will take your Swift
code and generate a binary it also has a
ripple that's read evaluate print loop
which is kind of surprising because
ripples tend to be more associated with
scripting type languages but they've
managed to create a ripple for Swift as
well so you can usually you can use that
if you want to there's a debugger which
is a customized version of LL DB the
low-level debugger you can do unit
testing through a framework called XC
test as I mentioned earlier at their
support for multi-core hardware through
a concurrency library known as Lib
dispatch and also there's the standard
library and the foundation which are
basically equivalent to what you might
call a class library that kind of thing
and finally new and Swift 3 there's a
package manager which aims to help
people to obviously package bundle up
their code and manage the dependencies
between those that's still under active
development but was released earlier
this year with Swift 3
the language is evolving still so each
major release of Swift from one to two
to three has been a major source
breaking change language compatibility
is now a goal going forward but until
now there hasn't been the case
but one one thing that's happened since
it's been open sourced is to how the
language itself evolves has been part of
the open source project so there's a
separate repo on github called swift
evolution which is where people are
proposing pull requests and writing
proposals about how they think the
language should be changed and in the
swift a3 timeframe a lot of those
proposals came from the community not
just from within Apple there's also an
extremely high traffic mailing list
which you could subscribe to if you're
if you want to receive hundreds of
emails a month all about our languages
might change or might not change okay so
that's kind of a little bit about the
project and where it's come from and
where it is but but why why is it why is
it interesting at all and to do that I
just want to talk briefly about some of
the performance characteristics of Swift
so here we've got a graph with a whole
bunch of different languages along the
bottom and each of these languages is
implementing the same algorithm so we
this is a benchmark known as n-body it's
a kind of it's it's what it does isn't
particularly interesting but but the
point is it's a compute benchmark which
is CPU bound so you can see that
different languages take different
amounts of time to run the same
algorithm and in fact some of those ones
on the right-hand side have been chopped
off because they took longer than 100
seconds so you've got a wide variety
Asian in performance there but Swift
stacks up pretty well in the in the kind
of middle of the pack typed type range
so that's looking at how long it took to
do something but as well as how long it
took it's also interesting to see how
much memory was it taking to do that
work so here's the same list of
languages but this time sorted by how
much memory they were using so you can
see that in the JVM based languages
the middle tend to poor perform
particularly poorly and that's kind of
unsurprising because we know that if you
want to really get screaming performance
out of Java you have to make sure that
you've got a Java heat big enough not
just to contain your workload but to
give you a head room on top as well but
these modern native languages down on
the bottom left go swift and rust
perform really well in terms of memory
usage so we've looked at duration and
we've looked at memory usage let's
combine the two and kind of divide them
and look at kind of duration by memory
so this is almost like seconds per
megabyte or what everyone call it and
you can see here that when you when
you're looking at the two combined Swift
starts to look really attractive now you
might you might wonder well okay why is
this interesting it's interesting
because of of this which is how
workloads tend to be billed in the
clouds you tend to be billed by how much
memory you're using for how long
gigabytes per hour it is really matters
nowadays with cloud workloads and when
you've got something like Swift which is
very competitive in those kind of
measurements that can mean real money so
here's how you do hello world in Swift
we're just going to do a quick tour
through the language that's what hello
world looks like and that's how you
define a string you say let the keyword
let means you're defining a constant so
I'd say that's dev ox and then you say
hello and then the backslash syntax is
how you kind of do string interpolation
so inserting one string into another so
let was for doing a constant which means
that if I then try to assign that to
something or somewhere else that would
be an error and we that would be a
compile time error as well kind of going
back to what I was saying earlier about
Swift prioritizing safety as a language
feature so if you wanted to be able to
change your variable you would use a var
instead so there we go
DevOps UK this time if you move into a
different event control flow so here's
how you define an array you'd say array
let expense costs with then you've got
three doubles inside that array note
that I haven't said what the type of the
array is so this is an example of the
type inference in the language so it
would note the compiler would notice
that I've got three doubles in the array
therefore it must be an array of double
and they didn't have to say that but on
the second line where it says sum double
equals zero I've told the compiler what
the type is because if I hadn't it would
assume it was an integer because I'd
said zero not zero point zero and then
for each of those we can iterate over
them with a for in loop add them up and
print the result out
it has switch statements obviously so
here we've got a constant string of
vanilla and we're going to switch on
that so depending on what the string is
set to you can print out various
different things a few nice little
things you can match two cases on the
same line by putting a comma between
them and you can also put kind of code
inside there as well so case let strip
where Stroh has prefix mint that's
saying if the if the string starts with
prefix mint then we will assign it this
local variable called struck and then we
can print that out using the string
interpolation default at the bottom you
have to have a default case statement
they are required even if it does
nothing just kind of force you to think
about that possibility
so I said the object reference this
could might or can never be null and
that there was a feature to kind of
allow that to happen if you want it to
happen that feature is known as
optionals and it's one of the really
kind of interesting features of the
language there was an optional type
introduced into Java in Java AIDS but
that's what was kind of bolted on to the
side as a new package optionals in Swift
or a core feature of the language itself
so you can see I've got defining a
variable called name which is an
optional string so when it says string
question mark that means if it's an
optional string
which means it is that variable is
allowed to be nil and they're not the if
let statement does an assignment which
basically says if name is not nil then
assign it to valid a name else we would
print out anonymous so that that's known
as optional unwrapping the next thing
let's say we've got a string which is
set to 42 and then we're going to want
to convert that mmm that string to an
integer in that case you can call the
initializer on integer passing in your
string but because that could fail for
example if the string wasn't 42 but it
was ABC and that's not an integer that
that that initializer on integer
actually returns an optional integer so
then if you want to check whether the
conversion succeeded or failed you would
check whether the number you got back
was nil or not if that makes sense and
just a way that you can simplify that
you can do the whole thing on one line
so you can say if let numb equals instra
and then it succeeded or it failed which
is kind of nice one of the downsides
about optionals though is if your
console if something can be optional
that means you can be constantly
checking whether or not it is optional
or not and and you can end up with
what's known as kind of a pyramid of
Doom where your code gradually drifts to
the right-hand side of your editor
there's an example of that at the top so
let's say you have an optional you're
going to check it and then once you've
unwrapped it exclamation mark is a kind
of force unwrapped saying I know I'm
guaranteeing that this is not nil at
this point so you can kind of unwrap one
then I'm wrap another and drift the
right-hand side of the page instead of
doing that you can use what's known as
optional chaining which is to put a
question mark in the middle of the chain
of things that you're an dereferencing
so what this means is in in the second
section here is if my optional was nil
the assignment would bail out at that
point without even
looking at another optional which means
you can you can chain these things
together and make your code more
readable right so Swift has functions so
here's a function which takes two
parameters a and B both of virtual
integers and returns an integer so the
return type goes on the right-hand side
after the little arrow sign so this
function just adds the two work together
and the way that you would call that
function is to say add int a and then B
so you actually pass the name of the
parameter when you do the function call
which is unusual or certainly different
to how Java works so what if you didn't
want to have to pass those names in that
case you would put an underscore at the
start so functions kind of have two
different function parameters have two
different names there's an internal name
in this case a and an external name in
this case under school or you don't have
to provide it so in that case you could
call add-ins one three which would look
a lot more familiar so you can make a
decision for each of your parameters
whether you want your user to have to
provide the name or not why is this a
good thing
well because it lets you do things like
this so here we've got a function called
move which we're defining and you can
say things like move from start to end
and then put your code in which makes it
kind of nice and readable because inside
the function when you're writing it you
would talk about start and end which
makes sense but when you're calling the
function from outside you we talk about
from and to which is more natural
English and and makes more sense from a
from a from a readability point of view
so by having both internal and external
names for the functions you can make
your code more readable
it has ver ogz which let you pass more
than one or instance of a particular
type to a function so here it's the what
kind of well-known three dot syntax to
say this is one or more integers that
can being passed to it so in this
example I'm just calculating the maximum
of the integers that were passed in and
the way you would do call
that function is one two three four five
like that so in in that case you don't
have to pass the name of the parameter
because I thought you would be silly if
you have to do numbers one number two
number three you go crazy and if you
don't pass anything at all that's an
error I said that Swift has two pulse or
tuples depending on how you want to call
them tuples are known from pythons is a
way to return more than one thing from a
function so in a language like Java if
you want to return more than one thing
from a function you'd have to wrap it up
in some other type and maybe create a
class or just just for that particular
purpose here you can see that the return
type of this function is a tuple of min
and Max so I can return two things at
the same time which is kind of nice and
then when I call that I can fish the
result out and print out result min and
result dot max so that's nice and saves
you kind of bloating your type hierarchy
for something that's quite simple
it has closures like which are kind of
equivalent to lambdas so here's an
example I've got an array of three
integers and I'm going to call the map
function on those so what this is doing
is I'm calling the map function and
passing a closure to the function with
the curly braces first of all you see
the closure signature so it takes an
integer and returns an integer and then
the keyword in is where the body of the
closure starts and so this closure just
returns the number multiplied by five so
you would get five ten fifteen that's a
bit wordy though so another way to do
the same thing is just to pass the
closure without the signatures and in
that case the compiler will infer them
for you if it can and even simpler still
you can just do this
so you'll notice here that the
parentheses have vanished and we're just
left with the curly braces if the last
parameter to your function is closure
you can kind of you can do what's called
trailing closure syntax so in this case
you can omit the parentheses because
you're only passing a closure so that's
nice and dollar zero is shorthand for
the first parameter so if you've got two
parameters you'd call you
to them as Donna zero and dollar one so
let's talk about how you encapsulate
your code now you've got structs so
here's a struct which has an x and y
variables in and it defines a function
as well which returns a description just
saying what those is currently set to so
how would you create one of these like
this notice I haven't had to define a
constructor or an initializer for this
with structs you get a free one which
initializes each of the elements inside
your struct so let's say I created a new
cord and assigned it it's two cord and
then I set cord dot X to be equal to
four so I've got in this case one which
is set two to four and then I change it
and if I print it out the original
cordon net will say x equals y x equals
4 y was four as you would expect whereas
new cord will say x equals two y equal
four so when I did that assignment
that's not giving me a reference to the
same object this is known as passed by
value instead so you what you're
actually getting is a reference to the
value of it and then when you update the
new one you it does a copy at that point
to give you a new object so structs are
passed by value it has enumerations as
well well that's a long way to the top
right so here's an enumeration with
three cases enumerations are well known
what's different about them in Swift is
that you can assign what's known as an
Associated value to each of them so here
two of my cases I've got a string
associated value so what that means is I
can create an approval status and say
who it's depending on so in this case
I'm passing a string to that enum there
and then if I set it to something else I
can send it to approved and change what
the string is what that means is that
you can then switch on your enumeration
and say according to the status in you
can fish out what that Associated value
was by saying
let's approve of their so that's a
really nice feature that lets you just
stash something inside an enumeration
without having to go to all the hassle
of kind of sub-classing it or adding
state to it which is nice so I said it
had struts which were passed by value it
does also have classes which are passed
by reference as you would expect
so here's class which has one instance
variable called area here I've creating
an initializer which is basically a
constructor for setting that up and then
I've got a variable here known as side
length which has getters and setters
which is kind of nice new value there is
kind of a bit of magic
it's whatever I'm setting it to comes in
as something called new value you can
give it another name if you want to and
finally in our lightning language tour
and it has something called protocols
and which may be familiar to people
who've done java before in that they're
a bit like interfaces in Java so here
I've got a protocol which is called
describable which is declaring one
method signature so anyone who wants to
conformed to that protocol would have to
in as in the second example struct car
conforms to describable would provide an
implementation for that method so far
not very interesting where it gets
interesting is with what's called
protocol extensions so here double is a
type one of the built-in types which
comes from the standard library so what
we're doing here is we're adding an
extension to double to make it conform
to a new protocol and then providing an
implementation for that method so this
is kind of interesting that now all
doubles in your program will have that
description method available to them so
it's kind of letting you compose new
functionality on top of the existing
types without having to do things like
inheritance so that's what kind of an
interesting feature of the language it's
a bit similar to traits in Ruby if
you've have you've done anything like
that so if you want to get going with
the language and kind of kick the tires
try it out what can you do
and while our teams created a website
which you can visit which is known as
the called the IBM Swift sandbox and
it's a bit like a rebel in that you have
kind of a split screen in fact I'll show
you why not so here's the Swift sandbox
if I make that bigger maybe can you read
that probably not not too bad
okay so on the left hand side you've got
your code I just refresh it and on the
right hand side you've got your output
so you can just run the code and there
you go what's actually happening when
you're doing this is your code gets
packaged up sent to the cloud and it's
actually executing on a docker container
on on our cloud and then the result gets
sent back to your browser so so the what
you're doing here is you're actually
compiling your code on Linux in the
cloud executing it then the results come
back down
which is kind of nice so we've got a few
samples which you can load in to the
system here's one that just does
Fibonacci so we can do that we have
various different versions of Swift you
can choose your of course most likely to
want the most recent version of Swift
but you can choose between different
ones if you want and the most recent
thing is that we have beta support for
running Swift on Linux one which may be
something people don't know about that's
the mainframe so if you're interested
let's see if we can get this to work
version so here we have a tiny slice of
an IBM mainframe and if we execute that
with any luck we'll get the same result
yeah so you've ever if you ever wanted
to have a play around and have a tiny
tiny piece of a mainframe there you go
so to do that we've IVM supported the
swift compiler to the s/390 architecture
okay so that's the swift sound box if
you interested in having a play around
go and go and have a tryout and one of
the nice features it's got as well is if
you've got a little snippet of code and
you want to share that with someone you
can get a permalink to that so what
we're seeing is that a lot of people are
taking those links and they're dropping
them into Stack Overflow or slack or
wherever
sharing them and that's really great to
see that people are really using the
tool and getting a lot of benefits out
of it let's move on to talk about Swift
on the server side which is a really
interesting topic so we've spoken so far
about some of the runtime
characteristics of Swift which spoke a
bit about the performance how it has low
memory usage all of this makes Swift a
good fit for the server side as well
combined with a good developer
experience and in doing that enables
something called isomorphic development
which I'll talk a bit more about in the
next slide it's also fun to work on
something new it kind of feels a bit
like back in the old days when you're in
Java and nothing worked yet and yeah but
isomorphic swift code what's that what's
that this is the idea that you could
reuse code from the client-side be that
iOS or whatever and on the server side
as well and you would be able to develop
for both without having to have a
separate front-end and back-end team who
don't talk to each other as much as they
ought to it's the idea that your code
can be more reusable between the front
and the back end we're working on this
at the moment in our team it's it's kind
of not it's not finished yet it's
working progress but the goal is that
you'll be able to define REST API
through some definition language like
swagger for example and then from that
you'll be able to generate both the back
end and the front end and write both
sides in Swift which would be really
cool but what what does it take to
enable that well to bring Swift to the
server side you've got to take all the
things you've got on the left-hand side
in your client and you've got to have
those on the right-hand side and server
side as well so that the developer
experience is consistent and the
libraries that you have on the client
you also have on the server side so a
few of those libraries are on the right
are in slightly lighter blue so these
are the things which weren't initially
there on Linux and that we've been
working to develop and enhance at IBM
one of those is Foundation which is kind
of equivalent to the class libraries so
on the on the Apple platforms on the
left hand side the foundation code is
all still written in Objective C Swift
has really good interoperability with
Objective C so that works really really
well and seamlessly on those platforms
but there is no none of that Objective C
code available on the server side so
we've been working in open source with
Apple to kind of develop those libraries
in Swift itself another one is
dispatched down the bottom there which
is the multi-core concurrency library so
that was open sourced by Apple as well
at last December and we've been porting
that to Linux so that Swift on Linux has
the same concurrency story that it does
on the client side so I'm just going to
talk a little bit more about dispatch
actually because it's an interesting
topic about how you exploit multi-core
hardware with Swift dispatch is the
library itself is called Lib dispatch
but the marketing name for it is Grand
Central Dispatch and the basic idea is
that you can execute your code on
multi-core hardware by submitting your
code to dispatch queues which are all
managed by the system so all of these
cues are first-in first-out
so the idea is you put a task in on the
Left it's managed by the dispatch system
eventually it's executed and then your
code runs so it's a it's an abstraction
which doesn't involve threads so that
the three main pieces here are the queue
that you're creating so that's an
abstract work containing which you're
going to put some work on that could be
a serial queue in which case all the
items in the end queued would be
executed in order or it could be a
parallel queue in which case the items
are DQ'd off the right-hand side in
sequential order but they're executed
simultaneously
what work can you do well anything you
can just pass any swift closure through
so you can call any Swift function you
want to as puck as part of block that
you pass to Grand Central Dispatch and I
said it's all managed by the system so
dispatch itself maintains a thread pool
in the background and then work is as it
you might guess dispatched onto those
threads by the system so this is a
different model to some languages like
Java where you explicitly create threads
yourself and manage them and have to
deal with mutual exclusion and lock in
version and all these kind of problems
there's a system to make this all easier
for you so here's how it actually looks
you would import the dispatch library
create yourself a new dispatch queue and
give it a label in this case we get
serial queue and then the method call
you made is doc dot async which says I
want to execute this block of code on
that queue asynchronously so here I'm
using that trailing closure syntax as
well so that is a method call I'm
calling the DA async method which has
one parameter which is a closure there's
also things like async after so you can
pass in a deadline and say I want to
execute this one second in the future so
that's a serial queue there are also
concurrent queues as well in that case
you pass the concurrent attribute when
you're creating your dispatch queue and
in that case you get unsurprisingly a
concurrent queue which you can then call
the async or sync method on depending on
what on what your use cases so you can
see it's really easy for to kind of take
a block of code throw it off to dispatch
and let dispatch work out which threads
going to run it and you can obviously
get notification back when your works
done there are additional api's for
grouping you'll work together so let's
say you've created a dispatch Q which is
a concurrent one if you can then create
a group as well so what you can use
groups to do is to aggregate work
together so let's say you've got four
things you want to execute
and once those four things have all
completed then you can go on and execute
the next bit of work so here when you
call cue door async you can pass a group
through so this is kind of incrementing
account internally to say this group has
been entered does the work and exited
and then at the end you would do group
notify which says once all of the items
associated with this group have executed
then we could print out that all the
works done so it's quite a flexible
system for managing work and we've been
using it successfully in our team what
did it take to bring Grand Central
Dispatch to Linux in Swift three well we
had to do a port to Linux we're
depending on some user space modules
Lippe thread worker queue and live KQ to
provide some primitives that Linux
operating system doesn't provide but Mac
OS does also new in Swift three there's
it's got a new from that API I just
showed you as a new friendly API it used
to be pretty horrible to work with but
the new API came in in Swift 3 and also
the we've been working to enhance the
performance of sort of Grand Central
Dispatch as part of the Swift 3 release
so we've got all the pieces and kind of
spoke about how we've got foundation
which is the the class library
equivalent we've got dispatch for the
multi core support we've got a compiler
we can execute it on dot on you know
docker container we've got Linux support
so what that means is that quite a
number of open source projects have
sprung up which are all interested in
kind of Swift on the server side and
what the possibilities are in
experimenting and innovating in this
space which is really interesting
so there's if you if you go on github
you'll find a whole bunch of different
projects we were all doing fantastic
work on server side Swift and the one
that I'm going to talk about in the
moment is cateura
which is the one that our team has
created inside IBM Couture is a web
framework written in Swift but you
should definitely check out all these
other ones as well because they're doing
fantastic stuff
I said we were bringing all the api's
that we needed to Swift but doing work
on the server side has very different
kind of requirements and and different
you need different libraries than you
would on a client side so at recently
Apple and IBM and a few others have
launched a new workgroup inside the
Swift org project where this is a
workgroup specifically for developing
server-side api s-- all these frameworks
that I showed you on the previous slide
so far have all been kind of rolling
their own four core bits of
functionality that you need to get work
done on the server side
whether that's networking or security
and encryption or HTTP and WebSockets up
until now everyone's been been writing
their own hopefully going forward we're
all going to work together a bit more
and provide some of these foundational
technologies which no one really wants
to compete on do those collaboratively
through an open-source project and then
concentrate our innovation further up
the stack all of the so this is this is
the kind of thing that we're going to be
working on as part of the server api
workgroup and all of those all of the
results of this will be released as
Swift packages so I said in Swift 3
there's a new package manager for Swift
so all of the the out all of the outputs
from this workgroup will be Swift
packages so we've actually created
another website to help people discover
these Swift packages which is called the
Swift package catalog so you can see
here the it's lets you create share and
discover Swift packages explore the
dependencies between them and you can
also now log in using your github ID and
kind of save your favorites that kind of
thing so if you're developing in Swift
and you want to find there must be a
library out there that does I don't know
yeah mall encoding and decoding go on
package catalog tightly yeah Melin and
if there is one we'll find it
we're crawling github for all the active
Swift projects which are producing Swift
package manager packages so I mentioned
that when we created a web framework
that's called cateura it's as you might
expect it's open source on github and it
runs on Mac OS or Linux it's inspired by
Express for nodejs so if you've had an
experience of back-end development with
Express you'll feel right at home with
cateura it has flexible routing you can
plug middlewares which you write
yourself into the request response chain
and it's really easy to deploy it either
locally on a machine or on on a cloud so
how would you get started with cateura
so this is kind of a bit of an
introduction to Swift package manager as
well
but here we go let's create a directory
change into it and then you initialize a
brand new swift package so here we're
saying Swift package in it and we're
saying we want an executable if you
don't say that you get a library but
because we're writing a program we're
actually going to execute we're going to
say we need an executable and once
you've done that that will give you kind
of a basic structure you get different
you get a few different files packaged
or Swift is where your package
definition is it's kind of equivalent to
app KS for for JavaScript main dot Swift
is where a swift code is going to go and
then you get a test directory as well
where you can put your unit tests so
inside that package dot Swift file
that's just been created you would add
cateura as a dependency and the way that
works is like this so here's a little
bit of Swift code so we're creating a
package giving it a name and then
declaring its dependencies and the
dependencies are defined by the get URL
and then also the major minor version
and the way this works is by uses semver
so semantic versioning and it's looking
at tags on the github project so we will
have
a 1.1 tag of keturah on our github
project and then you can depend on that
and the SPM will pull down that exact
tag for you
ok so you've said that you're depending
on cateura how do you actually use it so
now inside your main dot Swift you would
create a Rooter and then you would
define a root so here we've got a new
router and we called get which sets up a
new root so what this is saying is every
time anyone goes to slash hello in their
web browser we will set the HTTP
response to be ok which is 100 I think
and then send a little bit of HTML back
so that's that's kind of the basic hello
world for it you can also do JSON if you
want so here's a root called hello dot
JSON and in that case we would send back
a little bit of JSON as well and oK
you've created a Rooter you defined a
root what else do you need to do you
need an HTTP server so you create one of
those and tell it which route to you
want to use and then finally you just
kick off the cateura framework called
run and off it goes so you're kind of
hello world app looks like this which is
what 10 lines of code and that's
defining two routes one of which is
doing Jason as well so it's really
simple together to get started
out-of-the-box once you've written your
code you need to compile it so you do
that with Swift build and once you've
executed Swift build you would then just
run it because it's an executable on
disk and once you've done that if you go
to the splash screen so the root
directory you'd see our splash hello is
the root we just defined with the h1 tag
and hello Jason was the JSON root we
defined so that's really nice to make it
even easier to get started with cateura
we've created a project which is sample
project so this the sample project
depends on cateura itself so you could
pull down to our sample we even provide
and make fast all you need to do is make
run and that will build and run your
webserver
out-of-the-box which is nice there's
also there's another
project which is for pushing to our
cloud bluemix has built-in support for
pushing to their and we're also starting
to work on some cognitive api's with
swift so you might have heard of IBM
Watson which is our cognitive computing
platform we've got some Swift api's for
that so you can interface with things
like I think there's weather data image
processing a few different things so
that's worth having a look at as well
once you so the hello world example is
really simple obviously you're just
defining a route returning some static
HTML or JSON real apps need to talk to a
back-end so we've been developing
drivers for common no sequel databases
so we got drivers for Apache Cassandra
for Redis or for apache couchdb so
depending on what your flavor of no
sequel is you can easily get started
with one of those so it's easy to
connect your Couture app to a back-end
all in Swift you might also want to
support some authentication in your app
so we have a framework in cateura the
credentials framework was kind of like
passport j/s and we've got built-in
plug-ins for facebook google or github
so you could allow your apps users to
log in using their credentials from any
of those ooofff providers and we also
have created an end-to-end demo app so I
spoke earlier about this idea of
isomorphic development the idea of being
able to write your client side app in
Swift and your back-end in Swift so what
we've created is an app called blue pick
this is an iOS app which you can
download into Xcode and deploy to your
to your iPhone it's it's a photo sharing
app think kind of like Flickr I suppose
but but it also has a back-end which
we've written in cateura as well so both
sides of the app written in Swift and so
you can experiment with that which is a
really nice nice way to go
another demo we've got is for to-do list
so there's a there's a website called to
do back-end where people write kind of
different to-do list apps whether it's
ruby on rails or Django Python we've got
one of those for cateura
as well so if you want to see how to
write a simple backend with kind of crud
semantics create delete update all that
kind of stuff
we've got a back-end for that so you can
try that out and we also have a desktop
app for deploying to the cloud so once
you've created an app a Couture app and
you want to run that on the cloud you
want to push it up to Cloud Foundry
provider for example bluemix you can you
can do that using our using our app
which integrates with xcode so if you've
got if you've got a Mac and you want to
try that out that would be great and
once you've used the cloud tools tool to
push it up to a cloud you then need to
run it on the cloud and so I think last
month or a month before we released
support for Swift on IBM's cloud bluemix
so you see we've got a swift runtime
there which you can use which will run
your cateura application on top of cloud
foundry in the bluemix platform as a
service so it's kind of a kind of an
end-to-end story really you can you can
use Swift on Linux you can use it on iOS
you can create an iOS app link it to
back-end written and Swift as well and
you have an end-to-end story for pushing
directly to the cloud so that's kind of
cool what's coming next for cateura well
we're still we released cateura 1.0 last
month or maybe the month before now
which had a whole bunch of really
important and useful features but things
are marching on we're currently working
on WebSocket support for cateura
we hope to start working on HTTP two at
some point in the future currently if
you want to connect to a back-end using
one of our drivers you have
- kind of right for that specific driver
we're trying we're thinking about how
ways we could abstract that away perhaps
through some kind of ORN framework we're
working on performance monitoring
clustering all the important things
people need if you're going to actually
deploy this to production in a real
cloud so that's the future of keturah
and what about the future of Swift on
linux itself the implementation of
foundation is not quite complete yet
there's more work to be done there we're
continuing to work on performance for
multi-core support live dispatch we want
there to be a really vibrant Swift on
Linux community I think we're really
getting there with that with things like
Swift running on Android Swift running
on the Raspberry Pi things like that so
that's growing all the time which is
really nice we know we need better
support for ideas at the moment it's not
quite an Xcode only story there are
plugins for things like the s code Atom
vim if that's you're poisoned but
there's more work to be done on an IDE
support so I hope you found that
interesting it's kind of been a quick
introduction to Swift itself how Swift
is coming to the server and what iBM is
doing to help make that happen if you
want to find out some more and I hope
you do we've got a developer Center so
if you go to develop all the IBM comm
slash Swift you can read more about what
the team is doing if there's anyone in
the audience who has kind of a mobile
team in their organization who might be
interested in working with us on on
developing a swift back-end we'd love to
talk to you I'll be around afterwards or
you can tweet me but for now thank you
very much for listening I hope you found
it interesting and if anyone's got any
questions I'd be really happy to take
them I gather there's a mic just over
there or you could shout</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>