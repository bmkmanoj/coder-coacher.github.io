<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Fallacies of Doom   Lessons learned from porting Doom 3 to Java Mahmoud Abdelghany | Coder Coacher - Coaching Coders</title><meta content="Fallacies of Doom   Lessons learned from porting Doom 3 to Java Mahmoud Abdelghany - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Fallacies of Doom   Lessons learned from porting Doom 3 to Java Mahmoud Abdelghany</b></h2><h5 class="post__date">2017-11-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cyCxhVoBWfw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yes all right
welcome my name is Ronnie and I'm gonna
tell you some stuff about my project
forging doom 3 to Java first have to
apologize has a bit of a cold so if you
can't understand me it's because I have
a goal and incidentally enough last time
I gave the talk I also had cold so I
think it's relief to talks whatever so
where to start sort so I'm gonna start
off with a boring intro because every
talking you needs a boring intro but
there's a point to this intro you will
understand a fountain with it so first
of all its software company actually
paid to do the actual game they're very
unusual company if they always did very
interesting stuff you know
groundbreaking stuff legendary stuff
like yeah like people saying nowadays
these are some of the games I did you
know Commander Keen for example it's too
easy to the game at the time they did to
these calling smooth series go to these
swirling on the computer which was next
to impossible to do actually sorry so
this was 20 years ago something and it
was very interesting some other games
the most interesting thing they did for
me at least is the open-source almost
everything they do and that's very
interesting and everything is imported
and especially doom and there's somebody
here from a team called doom anywhere
and those are the guys that poor doomed
literally to anything they ported the
original doom to toasters washing
machines lately to the touch bar thing
from the new Macintosh and stuff so it's
the most ported game on the planet I
think the original do at least not not
this one so these guys they started 20
years ago it was a very small team
nowadays you would call this an India
studio and indie development team or
something like that and at the bottom
this table that this shows a bit of the
evolution of their engines over time so
doom did the original doom well I think
is 91 or something in 1991 something
like I know forty thousand lines of code
and 150 thousand lines of code and then
the last one this is doom three there's
six hundred thousand lines of code I
don't know I always think this these
numbers are interesting not sure why
that's you know they always say every
presentation has to have graphs and
numbers and stuff so this is a table so
that sorry
oh yeah the Nerds were a chant ago so
this is this is a very interesting story
has absolutely nothing to do with me but
the back in the 90s doom back before
Facebook and the air gotta stuff on it
and that's social media and stuff
there's stuff called mailing this and
news groups and stuff and back then the
doom guys they had a mailing list for
for doom you know talk about how you can
have to do how you can modify doing that
kind of stuff and somebody figured out
how the asset loading works in doom and
acid loading is basically you have a
large zip file and you basically zip
file is basically you know like a list
in Java for example and you can't just
get something from the list it's a
linked list actually you know you just
have to iterate over everything to we
find the state of the thing uni and kind
of a flame war started this is dumb this
is stupid this is not the way you should
do it everybody knows you should put
this in a hash map or something loaded
once and then put the indexes indices in
a hash map then you say okay I once I
don't know the picture of the doom guide
and I know from the hash map it's the
fifth file in the zip file and that kind
of stuff and a big war started and
whatever and and the doom guys their
reaction was something like now we
actually tested this and it doesn't
matter but nobody believed them you know
and what turns out they were actually
right you know putting it in a hash mark
you have to understand this was 20 years
ago and 20 years ago my I had a very
high-end computer and I had four
megabytes of RAM for example so this was
very limited hardware and putting
something in a hash map or whatever or
the quite too much processing power too
much memory and whatever and it doesn't
really do much so asset loading is a
fraction of the level loading so why
would you improve that you know why
would you improve your level
from 10 seconds to either no mine points
eight seconds or something
who cares so I always found a story very
interesting because everybody nowadays
you know goes to schools universities
and learns computer science and you just
learn you know stuff like this you put
it in the hashmap and this and that and
then you put it in the hash map and your
program is slightly faster but the code
is much more and people say okay but
hardware is cheap and that kind of stuff
so I like that story and just have to
say it I have to tell it's a know it's
interesting telling stories and
absolutely nothing to do with you you
know it's just yeah yeah I mean great
stuff for other people did especially
yeah so so June 3 so that's that's the
name of the projects and as you can see
I have an excellent sense of naming so
so why doom 3 I'm not really sure why
it's just fun that's actually basically
as I've been working on a project for
about three years now it's it's starting
to work Sylla it's very buggy and I'm
sure yeah so so forcing software it's so
let's just skip the porting software
action so why the boring intro actually
or the awesome intro so why did was so
the reason I'm telling all this is a lot
of stuff you know I came across into a
lot of stuff actually that's done in the
video gaming industry has absolutely
nothing to do with what we do in our day
to day jobs you know it's very different
they have very different requirements
that was an excellent talk yesterday
don't remember the guys name but it's
video games are for idiots and he was
talking about how people develop in the
video gaming industry and one of the
things is everybody thinks unit tests
are very good but nobody actually does
them and the reason for that is in the
fast-moving environment like a video
game industry it's just not very viable
now to write a lot of code that has a
very large chance of not making it in
the final product you know and units are
so duplicate code actually so that's the
kind of surface you know it's it's a
very different point of view you know
and
and a lot of stuff so that this stock
has a lot of C++ and a lot of stuff in
C++ that's in the doom and doom 3 engine
is if you show to a normal C++ developer
they will actually you know run away
screaming or something you know it's
it's just bad coding that standard it's
bad bad practice and that kind of stuff
but it works for games you know so
that's the reason for this intro also to
play sometime you know so yeah so
disclaimer I'm an expert I didn't work
on the original doom that kind of stuff
whatever I'm an assassin's Creed fan but
I really think this is true for
programming and in general you know just
have to try stuff don't believe anything
you know don't take it at face value
so with that you know take everything I
say with a grain of salt and so yeah so
how this talk is divided it's you know
so first I'm gonna talk about some stuff
that I really like in C++ I really liked
how they did it in doom engine and it
was difficult or not possible to port to
Java so this is bits you know this part
is what we would like from you know I
just noticed actually because the guys
from Daleks when you want to use on your
song guts except that they send you this
template and say you can use our
template if you if you like but then you
know you get the templates and then you
have another deaf ox there and some
sponsors and then the devoxx thing here
so it's wait not your problem
I know but it's weird so the first thing
I'm going to talk about I'm running out
of time very fast actually on video it's
immutability you know so c++ headed it
has very good support from youtuber
immutability and java has very very very
bad support for immutability and also
the immutability in in java is run time
stuff you know so so you have the
unmodifiable list for example it's
throws an exception if you try to do
something or that kind of stuff or so
it's not really compiler level stuff you
know so C++ has the awesome keyword
Const Co NS D comes I think it stands
for constant but it
and ironically enough we have this
keyword in Java just doesn't do anything
is just one of those reserved keywords
that do absolutely nothing and we keep
hoping or I keep hoping actually that
that we actually use it someday someday
but the discussion so far nobody is
going to use it actually so comes in C++
is actually outside you know so if you
have a Const integer so if you look to
the highlighted blue line for example so
there's it comes and then as a vector
you can't actually pass anything to the
function except accounts vector you know
and you know when you pass a contract
it's constant so it can't be changed you
know so when you pass it it's not going
to be changed within the function so I
really think that's awesome and the
closest thing I can actually do with
this in Java you know just just define
it as final and just be very very
careful you know you can still change
for example it a vector has an x y&amp;amp;z you
can still change them with within the
function in Java C++ you can't do that
anymore so there's not really a direct
sway or easy way to do this in Java this
is very unfortunate so I like this a lot
the yellow line that's my favorite
actually so when C for suppose you can
define a function comes and this
basically says this is a read-only
function this doesn't change anything
within the what's it called somebody
help me yeah no that's not what I'm
looking for but thank you no sorry
that's not the one I look for oh yeah so
this dimension is there's an function
within it back three and this means this
function get get dimension can't change
anything within it back three you always
do you know if you call this function it
will never change something within the
object is so close class was the word I
was looking for sorry what
No so if I say anything wrong
you know just attributed to that I have
a call so the last one as the one in red
this is also one of my favorites
actually is you can simply yeah you know
like I said conscious a type so you can
also return it you can return something
that is immutable you know and in this
particular case I just cloned the object
and return it you know it's the easy
solution
sometimes it's C solution of the times
it is
and I'm gonna skip this one but alright
so yeah Java has some stuff you know
final and final just some weird stuff
you know it's it's it's it's awesome for
some things but not for immutability you
know so final four variables I'm not
really sure why we have this no I mean
final references it's not there are not
very helpful but okay uh on-site
primitives so yeah thank you
on such primitive so I really like
unsigned primitives I know a lot of
people have a lot of different opinions
about this but generally speaking you
know so actually let's show this one so
Java doesn't have on-site primitives and
this is actually legal Java code
you know this will compile it won't run
but it won't will compile because you
know and an array it takes an integer
you know an integer can be a negative
number so this will compile I know and
that's weird I find that very very weird
but anyways so the easy solution to
using unsigned primitives for me is to
use the next primitive over so I need an
unsigned in so I need a very large range
of positive integer so I just use along
and it works for most cases but
sometimes it doesn't and no presentation
is complete without some benchmarks so
there's some benchmarks about using in
sandbox and whatever and it turns out is
not as cheap as people think so for
those of you who've never really made a
game a game is basically an infinite
loop you know it runs for as long as
you're playing actually so but it's
basically a lot of infinite loops you
know so it really doesn't matter how
many objects you create it really
doesn't matter how many instance
instances you run and that kind of stuff
and some and going from something to in
from in to a long for example it really
costs you you know and and same thing
with floating points or whatever and
that kind of stuff and I know people
like begins and big decimals and you
always hear conferences begin so big
decimals are as fast as primitives and
whatever and I really don't think they
are
and again micro benchmarks don't mean
anything they're just there for fun
actually
whatever so that's one sign primitives
this is going to slow overloading nice
picture over learning operator
overloading so Java doesn't have
operator overloading operating
overloading is basically for those of
you who don't know what it is so you can
in other languages you can define an
object you can say okay if I use the
plus sign for example with this object
it should do this and such but this is
misused sometimes and people don't like
it so they didn't put in Java
um this this line is actually from paper
guy Steele Rhodes long long ago and he
was saying okay it's actually a good
thing and we want to add it to Java but
I'm not sure what happened to guy Steele
so they never added this so this is how
so operator overloading is used
everywhere of course in the put in and
in the game it's it's you know is it's a
very you know it's a game 3d graphics a
lot of math involved a lot of vectors
and matrices and that kind of stuff so
we have to overload those operators if
you want to multiply with vectors or
whatever so so this how I did it you
know this is how every Java developer
would do it actually they might choose
different names for for the operators
themselves but you know I did some
simple stuff Oh operator and a multiply
a plus Oh multiply applause that kind of
stuff this is the same actually but you
know if you replace it with two
underscores to be Java nine compatible
and this is actually how it looks in the
C++ code you know and I don't know I
still believe this is more readable than
the whole function thing above but
people who disagree with me very much I
know this that's sure okay yeah I'm
giving talks so you have to believe me I
think I think the one below is still the
best and I think our own operator
overloading is also a reason why
templates suck in Java for example but
that's a different discussion oh yeah so
so this is this is an example so another
thing would operate it with operators in
general you have operator precedence you
know my multiplier comes before plus and
that kind of stuff and you have to read
from left to right or from right to left
and the cannister so how does this
if you use functions you know and the
same applies for bigdecimal actually it
was because big decima has infinite
precision it doesn't really matter much
but it really does actually so so this
is how I would write it at first you
know but it's actually wrong you know
this is how you should write it
you know you multiply B by C and then
you add the result to a that's actually
what happens in the line above in C++
and this is actually what the compiler
does you know so yeah this is tricky
stuff I had a lot of bugs somebody asked
me over here why do you have a lot of so
many bugs and this kind of stuff you
know one bracket that is too far too
soon or too narrow whatever so that kind
of stuff sighs off so sorry I keep
looking to the slides because I forget
what ordered the slides are in so but
size up so Java doesn't have an
out-of-the-box solution to measure how
many bytes and objects should should
take in memory
um it's understandable why you know I'm
in Javas memory managed and it's not
always the same and a lot of overhead on
that kind of stuff but I mean the basic
stuff you know so if I have an object
with three integers I know an integer is
4 bytes so it should be 12 bytes
actually you know it's not very true in
Java but it's very very true in C++ and
it's very used in C++ and it's very very
used in OpenGL and this is okay this is
a wrapper around the opengl but it's
OpenGL and you need a lot of this stuff
actually to make OpenGL operate so my
solution for this was to implement a
bytes a static I know int for for every
object this is actually what Java does
so if you do integer bytes you will
actually get this you will get four
bytes or is it for this four you'll get
four bytes back and it it look basically
looks something like this actually um
technically technically speaking this is
actually faster than than the C++
solution it's just a lot of work because
this is something you do want but sighs
off every time we do signs off you have
calculator sighs so it's very important
for this kind of stuff in the game again
this might seem trivial for everybody
and you know I do web services and I do
you know enterprise applications and I
never use this stuff so that's why I I
wanted to read it to know to disclaim
people at the beginning if you only read
the title of the talk don't really
attend the talk you know so
destructors so another cool picture so
destructors Java doesn't have it
actually has destructors but they're not
very used you know so Java has what's it
called finalized which i think is
deprecated I'm not sure I know there was
a proposal to deprecated it is it
deprecated its deprecated it's still
there it doesn't really do anything it
actually it does exactly what you wanted
to do it just doesn't do it when you
want it to do want to do it you know
that's that's the problem with finalized
so destructors generally speaking
destructor is it's the opposite of
constructor obviously and you want to
free memory in a structure or free
resources that kind of stuff in C++
that's very important because people
suppose you manage everything yourself
in Java everything is managed for you so
what's the point
the problem with this argument is a lot
of people misuse destructors or
deconstructors I'm not sure which one is
correct actually but destructors so this
is this an example from from from the
game you know this all happens within a
destructor you know and yeah so so I
can't put this in a finalize method I
could put it in there but it might never
run it might run I'm not sure so yeah I
just opted to create a function and just
call the function it's not very hard but
most most C++ developers would actually
not think of this as a good code but it
works and you let the machine or you
know the compilers do the work for you
which is what you want actually the same
thing which we do with with JP and the
JVM does a lot of work for us sorry yeah
Java has some other stuff like also
closeable which was a good idea but you
know we always have to try catch and
whatever and oh
um okay let's keep peanuts for
inheritance
so um father actually remove this one
but okay so a common pattern in games up
in games actually but but in this game
is you know you have a lot of
inheritance you know they and and the
common thing you do is you could have an
object that inherits an object an
inherited object and you want to call
the super super function in Java terms
and this is impossible in job you know
and I'm not really sure
should I I kind of know why but it's
it's just weird that it's not possible
in Java area and see if I suppose you
can just do this so this is you know
this this this class and harness from
this class and this inherits from the it
AF and entity on scored base class I can
just call the function this way so how
did I solve this in Java I just made and
it's AF and the base think function
within the middle class and I can call
it from the middle class and that kind
of stuff it's not very beautiful code or
whatever but it works and I don't know
it annoys me and it also knows me that
equals and hashcode are inherited but
like I said I thought I removed that
because that's very long around so yeah
that's it for inheritance I think so
yeah I was a to t2 to buy this picture
so that's why you have the big ugly
water park there but I think everybody
can read it and I kind of like it
so pointers pointers are awesome I know
people hate pointers and I hope people
don't point to get a very good bad rap
and I know when I started when I took
programming classes in school people
were only dissing pointers and whatever
and Java was new back then and everybody
said hey Java does everything for you
you never need pointers again it's to me
you don't really need them but it can be
very helpful and you have to remember
your computer works with pointers you
know on a fundamental level on the
electronic level your computer has
pointers so it's very helpful to be able
to simulate your computer a little bit
so this for example the above function
you get two pointer parameters and you
can assign so this is basically if you
have a function that has more than one
return type which is impossible in Java
and other languages have this but you
have a doesn't have it and C++ doesn't
have it either actually and C++ holds it
went okay and it just passed two
pointers or whatever and just a silent
how do did I solve this I just made one
element arrays I have a lot of one
element arrays in my in the code and
it's basically just a poor-man's pointer
actually I cannot like to call it and
they just do this kind of stuff and he
still gets you know kind of pointer
pointer like behavior without very
convoluted code of putting something
within an object or whatever or
references or this is another one you
can with pointers you can basically just
cast pointers to cast anything to
anything else
so this is basically a class with with a
lot of floats you know and you just cast
it to to a float pointer and you know it
because this class has nine flows this
will give you a flow pointer with nine
positions by actually more but and how
did I solve this just create a new float
array and and very carefully hope that
nobody wants to change any of these
values because you can't change this is
basically an immutable array which which
you chair which you send back you can
change the values we can't change
anything within the matrix itself oh
yeah and this is the funny slide
actually so why don't you ever have no
but no pointer exceptions without
actually having no point no point is you
know in general so yeah well we're
mature okay this part is where actually
the other way around stuff that I really
don't really love it in Java is just
that Java doesn't have it and I think it
was a correct decision not to implement
it stuff in Java Mac
so there was a project actually about
ten years fifteen years ago to introduce
macros to Java and thankfully it never
succeeded actually the macros is one of
those things even the C++ guys the
architects of C++ hate macros but you
know they're so intrinsic in the
language that everybody uses them and
it's very difficult to move them you
know so a macro is basically it's you
can define a piece of text and it will
be searched and replaced within your
program that's basically it you know
this is literally actually actually it
and this happens before compile time is
a preprocessor a process and it's very
error-prone a lot of ID's don't okay now
that is more IDE support this kind of
stuff but in the early days and a lot of
ideas didn't support it's very hard to
debug this kind of stuff and like this
it's very error-prone so so this for
example is a very simple macro you say
you know square this and whatever um I'm
very certain none of you thought not
none of you but most of you didn't think
this would be replaced with this you
know I didn't know that actually you
know this is a common example they show
on the internet for why you shouldn't
use macros and this is another common
example so this is actually from an
article called death by macros hence the
title and this was a piece of code that
they would show anybody who would use
macros and for those of you so here are
highlighted actually where the macros
are this is actual piece of code this is
from a linux shell one of the Linux
shells and yeah this is very bad code or
very very hard to understand you know so
so that so yeah the game has a lot of
macros a lot of markers and this this is
for example a very simple macro and this
unrolls actually something like this um
my biggest problem with this is I didn't
see a lot of this stuff because you can
place macros anywhere in the code
actually and they have a weird kind of
scope so you might not necessarily see
it at first that this macro is for this
class
actually nothing something this big so I
missed a lot of these things but later I
implemented them the implementation
itself is not a big deal but macros are
evil so thank you yeah yeah people
actually understand this thank you very
much
so usually only C++ developers
understand this one so C++ has something
like you know the same way camel case is
religious in in Java C++ usually has
something called Hungarian notation and
this is a Hungarian notation this
actually means hWnd means handle window
and this is the handle of a window pen
students is kind of funny but not when I
explain it so Hungarian notation is very
weird
you know I didn't really have much
trouble with this in the game itself
but it's it's still in there you know
and when it's in there
I usually now have to go up on Wikipedia
or C++ references or whatever to
understand what this actually means that
kind of stuff so this is simple how you
got Hungarian notation and people
actually use this you know people still
use this so if you have for example I
don't know a class foo and it has a
member bar or whatever in C++ people
would call bar I'm on the square bar
because M is a member of a class you
know and it doesn't really make sense to
me you know that's okay you know and P
means pointer and SZ means you know
which is string as zero terminated no
terminated or whatever and then you get
the name and that's the actual name of
your field so Hungarian notation is also
very evil I'm very thankful that Java
people don't do this most most of the
code and in Doom is actually camelcase
so that's also very good but it's still
it's still in there you know and you
know oh yeah this was a funny quote
you can you can look it up further later
there's a lot of rants about Hungarian
notation thank you
oh yeah so yeah so this was about
Hungarian notations but you know
camelcase can also be very evil you know
so the one above that's an actual class
name in Java
I think they removed us but it was an
actual class name and this this stack
envelope post was actually removed I'm
not sure why but I got it via you know
wayback machine so this is awesome
you know this is actually this is really
awesome I'm not sure who this guy is
beef lorry but you're awesome so so
that's that yeah
unions so Union I'm not really sure some
so C++ is existence 770's I'm not sure
I'm not sure since when it seemed
possible existed but I'm sure it exists
it started out sometime okay let's let's
go back see this is a unions are from C
and C is very old and back in the old
days you had limited memory so somebody
came up with something called the Union
that's basically you can define sort of
an object and the object only takes
limited amounts of memory and all the
members overlap that's basically it so
here this is simple example you have my
p address and within the IP address you
have a struct which is lazy class or
class with nothing and you can you know
we defined a couple of chars you know
but they overlap with the integer IP
address itself so you can you know read
the IP address or read one letter of the
IP address and that kind of stuff which
is I know could be helpful
I was telling a friend of mine about
this and he sent me this screenshot from
a book you know this is one of the
usages of unions for registers CPU
registers you know CPU registers are
divided into smaller registers or sub
producers or whatever they're called
okay now it's also good usage for unions
and such and yeah this is actually one
of the worst parts of the code that I
had port so yeah this is from south
inception doesn't know doesn't know but
a union within union so this is this is
a union within C++ or within the doom
engine and I'm not sure if I can use a
pointer here can I use the pointer yeah
so if you look here the Union references
itself itself within the Union it has a
pointer to a union with the same time
this this was plain evil I'm not sure
why they did this you know and I ported
this it took me about three months to
port the single Union I'm really I'm
really really not sure what this you
know there are stories about developers
that at the beginning of a project that
would reserve some memory for example
and in the old days you know when memory
was was expensive and it would reserve
some memory it you know to push all the
developers to use memory as efficiently
as possible well nobody can go any
further they would aha
here nothing free something memory for
you I think this is that kind of thing
you know this is really some kind of
hazing stuff I really don't know and a
lot of these fields are actually not
used within the game itself so I'm not
sure why they did this but it took a lot
of time unions are also very evil I
think they might have their usages but
I'm not sure what they are but again I'm
not super suppose developer so who knows
yeah so yeah this is a list of something
in between I think it's not basically
it's stuff Java doesn't have but yeah
you know it's not very essential but so
Java doesn't have default arguments for
example I'm not really sure why this is
very simple to implement I think it is
very you know it's it would make your
code much more readable so this is the
above example that one line and this is
the simplest way I could define it in
Java for examples I don't know six seven
lines or something why don't we have
this I'm not sure so sorry
so yeah inlining so so Java doesn't have
it does have inlining but the JVM does
it for you you can't force it to in line
something you can but it's not easy to
force the JVM to in line something for
you in C++ you can just you know
underscores course in
then it will force this function to be
inlined everywhere it is called and
again this might not seem as important
to our day jobs you know but a game is
an infinite loop and you call methods
thousands and millions of times or
whatever and such and you would think
that JVM would always in line that kind
of stuff
I hope the JVM does it but I would like
to be certain you know I know this
function has to be in line because the
original doom guys in line that you know
and they're smarter than me so I would
like to inline it so Java doesn't have
an easy way to do this also something I
would I think a lot of us could benefit
from right yeah so this one so everybody
has done this at some point of time you
know you want to concatenate two strings
so we want to insert a string within
London
other string and you have to do some
substring stuff or whatever or if you're
much more fancy would use string utils
or that kind of stuff and the equivalent
of that ugly line of code above is that
code below in C++ and it's really
mind-boggling why we don't have that
kind of simple stuff in in Java you know
it's very basic stuff people do string
manipulation all the time so why is it
so hard
and some people use string buffer sting
builders and whatever and those things
are very expensive so so I you know I'm
not really sure either so that's why
this is a wish you know nice to have
list very simple I think to implement
again I'm not an expert I'm not a JD I'm
an architect or one of those awesome
guys so it might be very very hard to
implement but I don't know it seems easy
everything seems easy when you don't
have to do it here ah
I'm actually ok on time so so this is
awesome stuff in C++ that's it's very
very hard to do in Java I know so and C
first because you have pointers you have
memory addresses in yes stuff doesn't
move around in memory you can actually
watch your memory address and what's
what that's helpful for is for example
we have I don't know a vector and
somebody changes it but
vector has I don't know something like
200 references or such and you want to
know which reference you know changes
the exact X variable to 1.76 whatever
you know and see Paz first you can just
watch it you know as soon as somebody
changes that memory address you get the
breakpoint goes off you know in Java
it's it's much harder you know it's it's
it's nearly impossible actually or I
thought it was nearly impossible but the
fine guys of IntelliJ implemented this
and fairly certain most people don't use
this it's a very helpful feature
actually sorry yeah the only problem
this is very very very slow
it exists in IntelliJ I think it's a
success and challenging for two years or
something like that and actually
yesterday I walked to the IntelliJ guys
downstairs and asked them why is this so
slow you know um I got a very
unfortunate answer is the JVM T is slow
this has nothing to do with us I thought
they implemented a very fancy feature in
IntelliJ because as far as I know it
cliffs doesn't have this and NetBeans
either correct me if I'm wrong anybody
but so this is basically JVM TI's I
think tools interface or something
that's that's basically where the
debugger and all the fancy stuff we use
in Java comes from and this is one of
the features nobody uses it because I
don't know why but it's just very very
slow but again this is slow for for for
my purposes for the purposes of the doom
game you know for purposes of you know
your day-to-day job
once again or my day-to-day job this can
be helpful you know so from the hundred
times I've used this it actually was
useful once and it wasn't for the game
it was for you know just a Java into my
certification so setting it up is a bit
annoying and not be what's called
IntelliJ you know you have to know that
the the number of your instance and the
exact field and that kind of stuff and
usually you know that stuff but it's
much more annoying than just doing that
what what you didn't see puss-puss yeah
so another feature I'm not sure a lot of
people know but this is a very old
feature and most IDs supported but you
can just pop the call stack you know so
if you within a function you can just
pop that frame and you go back to the
frame before that the problem is if you
if you change any state outside of the
scope of the function within that
function it doesn't reverse that state
but it's a very helpful feature I use it
a lot
everywhere they job my job anything but
so this this is the gdb C++ equal
Fitness the c++ section because this is
from gdb but you have something called
diverse stuff so the same way you
stepped into something can reverse step
out of something and it just turns
everything back we rented this is not
100% it's really enough 100% but it's
much better than we what we have I think
a while back there was an a debugger
called crony cronin something with
Cronus in the name they try to do this
but I never got it working and they're
also not free so so maybe it does work I
have no idea but this is a very nice
feature oh there's a nice feature I
think we would benefit from a lot okay
yeah yeah I usually skip this slide but
so Java has this you know we had this is
five point one point two that is
actually the the number within the JVM
spec actually of the widening primitive
conversion so this is actually something
documented as this happens and it's very
weird that it happens without warning
you know you can put a float with a
double and the value may change and you
will get no warning you can put in along
with a new double and the value will
change and you will get no warning and
it just happens it's a very error-prone
and I've had a lot of bugs you know
around this stuff with doubles and
floats and such these are some examples
for you know if you look at them it very
very simple you would expect them to not
change
but they do change so again not sure why
I'm telling you this but I'm here so why
not so yeah this is related to the one I
told before about operator overloading
and you have operator precedence so why
is operator precedence actually
important for certain operators so
example the one left it's you know it's
multiplication and division you know and
as we all know from math class it
doesn't really matter in what already do
the multiplication and division it
matters a little but it doesn't really
matter generally speaking but for
floating points it does matter
and the reason for that is it's very
simple as floating points don't have
infinite precision they have a very
limited precision and the already do
things in can change the precision so
the one on the left with a
multiplication and division I think I
don't remember which one either blonde
one or blah to actually produces zero
and the other one produces an actual
results you know um it's strange it took
me a while actually find this book this
is actual bug in the doom engine I'm
sorry the one on the right is actual bug
and doom engine but it's the same
concept actually but yeah it's very hard
to find and you know cheapest processors
as well I mean Java everybody has this I
Triple E standard thing it's just very
annoying and again a warning would be
nice or something no one arrives
yeah you wouldn't expect this to go
wrong either actually but it's the same
concept you don't have inferred
precision you have very limited
precision
so if you add things you know if you
have the bracket so you add them first
and then you subtract them from a or you
subtract everything in that order I said
it makes a lot of difference for the
precision and yeah
this one like that this one is in the
engine itself the problem it's not a
problem actually but why it's not a
problem in the engine is because it's
it's very it's it's constant you know so
they have a different class where all
the classes make this all the functions
make this error and if everyone makes
this error it's it's an acceptable
actually so sorry
yeah conditional breakpoints another
micro benchmark if you haven't noticed I
hate micro benchmarks people always you
know use them and they mean something or
people like to say that they mean
something that don't mean anything
actually except that this simple test is
much slower if I do conditional
breakpoints instead of no so conditional
breakpoints are basically when you make
a breakpoint it set a condition within a
breakpoint itself you know an IntelliJ
or whatever your idea is and again again
it's an infinite loop and infinite loop
you do a lot of you know if you put a
breakpoint in there the very point gets
tripped a lot you know so you have to
check the condition every time so I made
it a very simple experiment the first
experiment is I set this condition an if
statement and within the earth statement
I set a breakpoint and you know every
time you get stripped a normal break
point you know I just measured itself
the other one is instead of the if
statement I put removed your statements
and I just put the condition of the if
statement within the breakpoint itself
and it turns out in my experiment at
least the conditional breakpoint is
about 180 times slower so I'm very sure
this number isn't accurate
I know it's slower but not 108 times
because that's ridiculous
but you know I made this slide and I was
too lazy to change it and measure it
correctly and I used basic self adultery
to use micro benchmarking tools whatever
just sister printouts and that kind of
stuff so you know this is something I
just go I didn't know about this I
discovered it while I was supporting the
game and I thought it was very helpful
to tell you find people ah so this is
the last slide and this is the right on
time actually so yeah backwards
compatibility so I had a very annoying
bug the screen on the left was the not
correct one the skier on the right is
the correct one if you look on this very
fine big screen you can see the screen
on the left is very blue you know and I
couldn't understand why it was blue you
know I thought it was a very simple part
you know something like I don't know
something simple I can't really think of
anything right now but I thought it was
something simple you know and I was just
this was very early in the game so this
was the first time I was getting asked
and working screaming the game I was so
happy you know so I just ignored it and
I thought okay it's a simple bug
actually at first I didn't even notice
that it was blue I was so happy that I
didn't know it was the wrong color but
that's a different story
so so yeah I thought this is a simple
bug let's just you know do it's during
downtime you know so when you when you
want to change base and you fix a simple
bug to give yourself so a good feeling
you know that kind of stuff I thought it
was very simple but it took me about two
weeks to figure out what it is actually
and what it is it's very simple
something actually is for this I used by
buffers and by powers are awesome if you
never use my buffers they're awesome but
they have a very big problem is if you
duplicate the byte buffer is a very
basically a class with the bytes array
underneath I could do very fancy stuff
you can do something like put an int in
there and then get the bytes back and
that kind of stuff and for this kind of
manipulation is very easy and for a lot
of OpenGL stuff in Java it's it's
necessary actually it's it's it's it's
just forced upon you so for this part I
was using a byte buffer and I was doing
a lot of duplicates on my profits
basically a clone method but for the
back buffer and what turns out when you
do duplicate on the byte buffer the byte
buffer ignores which endianness you've
chosen yes so the people made that sound
right now yes thank you so so most of
the stuff was little-endian I think and
when I when I did the duplicated to
revert it back to big-endian and it's
basically just flips the bytes around
and this is our RGB a red green blue and
alpha and it just gets twisted around
and you get this blue tint so it was
very simple it was simple to find oh
yeah so I went on the internet and I
searched you know why is this so when
everybody says now it's worse as
expected this is spec this is according
to spec and somebody made a bug on the
Java
Java bug border or something in much
let's go and some one of the architects
I think or one of the guys involved or
you know he replied none of this is a
suspect it should work this way and the
bug was closed it was until a couple of
years ago I went to him ask the
architect session like the one being
held today and and I asked one ask the
architects people great people great
architects why is this so and I finally
got my answer this is actually a bug you
know what has been in there so long you
know and not many people are complaining
about it but they just have to leave it
in there so that's you know that's why
it's a backwards-compatibility storm so
this is just you know you come across
this kind of stuff a lot on Java it's
annoying I hope it changes one day I
know it won't but I hope I can so and
that's it questions yes sir sorry ok
yeah if I can find my pointer yeah
there's no point
not yet no not yet so the game isn't
fully functional yet it's kind of
functional yeah I'm not done with all
the bugs yet right now yes so right now
the code is basically just the C++ code
but you know translated to Java with
some fixes here and there so my plan was
at a certain point in time to actually
translate you know rewrite a lot of
stuff for job you know because a lot of
stuff that's performed in C++ doesn't
really matter for job doctor and vice
versa
any other questions because this takes a
while
slightly less because a lot of the code
in the C++ version is for instance just
for has a lot of assembly in it and you
know at first I was really you know
thinking about porting that but then I
thought no I won't for the assembly
codes it's too hard and such any other
questions
this will still take them on this level
to get us started so the blue screen
which I showed but that was when it
first started to work that was about I
think a year yeah and this is actually
what I'm showing right now this is an
older build as my current bill doesn't
do compile time oh it's very fast
it's Java yeah it's one of the
advantages you know when I first checked
out the C++ code I started building it
without a multiprocessor support which
is something is not on and default by
default in Geneseo suppose it took like
I think 20 minutes to build or something
or 25 minutes now it takes about five
minutes but in Java takes on right now
one minute half a minute yeah so
everything is in wireframe because I
still have a problem with the lighting
and I didn't show the wireframes you
wouldn't see anything you would but you
have to you know get very close to the
screen which is difficult and you can
see the guys are a bit mangled and
whatever and flying heads like that one
I'm sorry can actually see it right
there
supposed to look that way for people
haven't played doom yeah
the sound was actually working better
than this but I broke it somewhere and
like I said it's an older build and I
can't remember which build I fixed it
again in so I just leave it at that yeah
I have a lot of problems with versioning
and that kind of
oh yeah so now we are within the game I
think I hope I might within the game Oh
a great rose
so this happens during demos of course
so this screen says I'm out of time
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>