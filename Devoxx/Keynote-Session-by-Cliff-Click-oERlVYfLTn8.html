<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Keynote Session by Cliff Click | Coder Coacher - Coaching Coders</title><meta content="Keynote Session by Cliff Click - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Keynote Session by Cliff Click</b></h2><h5 class="post__date">2016-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/oERlVYfLTn8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay maybe we have a fewer fewer AV
problems here so um if you're if you're
like me you have a mother um and like
you know mothers everywhere she she
wants to know what you do for a living
and and so you know one day I had this
this I guess it's kind of hypothetical
but I've had this conversation versions
of it several times you know what do you
do well I write compilers I do a lot of
things but compilers is one of the
things I've known for but what's a
compiler oh well it's a program that
what's a program hmm okay so okay so now
explain what a program is ok let me back
up and say what is a program well we
don't firms that we're all programmers
ok we know Fergus write a HelloWorld ok
right well or it's some machine code
that you know we just get Jay and I bits
and pieces it does something with some
piles and piles of assembly maybe you
know we widen the net a little bit it's
a recipe for getting something done it's
you know what it takes to bake a cake
it's a pile of instructions that I'm
going to use to pay my taxes you know in
in this talk this context a compiler is
a recipe for em except our program is a
recipe for getting something done it's a
set of instructions and I'm going to
follow and you're the cook Oh not
usually usually there's some machine and
what I mean by machine well you know in
the first example we all know it's a
computer right it's your desktop or your
whatever maybe it's an embedded device
maybe it's in my pacemaker no I don't
have one um maybe it's my cars lots and
cars right maybe there's a person maybe
it's the chef and he's going to follow
this recipe to do something maybe it's
me and I'm having to follow this tax
form mile after mile after mile so you
know I can give Donald Trump's money
it's an actor that follows instructions
to change the physical world right it's
it's a doer it's an activity
what's getting baked oh okay good
question um well the answer is getting
baked what's the answer well so and this
is a very general idea here the answer
is a hello world or email or it's a
browser so i can look at these cat
videos or it's a database or some game
i'm playing or it's a phone call and i
don't mean the conversation or the
ability to have a phone call I mean the
active dynamic phone call with sound
getting digitized over internet and back
out again it's the action piece of it or
the answer is the cake yeah okay or you
know it's Uncle Sam with my money he's
very happy and maybe I'm not quite so
happy um then this model of the world
there's a machine in the middle as that
actor and he's going to take a set of
instructions a recipe for getting
something done and change the physical
world getting the answer i went out
right the program then is defined by
rules that we make up and therefore it's
easy to change and we call that software
whereas the machine is defined by the
laws of physics and it's hard to change
we call hardware and the answer is just
what we want out of the thing so what's
a compiler well it's a program and
what's it used for let's talk about IO
for a second here I for input right so
in my little model of the world here the
machine's going to take this pile
instructions and change the physical
world produce an answer for me it's also
going to take an input okay and then the
first case here the example inputs might
be things like files and keystrokes and
mouse clicks it might be physical
reality sound waves and radio waves that
are part of the whole interrupt the
microphone is taking sound waves and
getting some little signal out that's
getting digitized and processed it might
be flower for my cake but it might be is
also the position of the flour container
because that dictates what that Chef has
to do to go use the flour in the first
place it's not just simply the flower is
the obvious analog and of course for me
it's everything the government wants to
know about me am I married or not
income and taxes I've already paid
whatever so the input is the real-time
state of the physical world it's not
part of the program it's not part of the
machine we write the program but the
input is something we react to now put
is well it's just another answer
programs can be outputs well and inputs
as well so that brings me round to what
a compiler is what is a compiler
compilers our program that changes a
program into another program the pilot
instructions that that machine is going
to work on it's going to take us an
input a file with a pile of instructions
and produce an output which is another
pile of instructions how does that help
well not all programs are created equal
programs follow rules but often the
rules do not mention time faster
programs are usually better same program
same answer but faster faster is good
often the program changes languages
computers only do machine code so you
know I have my C or my job on the left
I'm a machine code on the right the
machine has to have the machine code so
the input program which might change
from Java or C here into machine code
and then my robot chef can do my cooking
for me so the cake but faster yes seems
complicated yes compile then run two
steps GCC and the left takes a foo CC
program runs it through the machine
produces an 8 out pile of machine
instructions which are then run through
the very same machine to read the inputs
from the real world produce down so I'm
really looking for two steps well what I
do it all at once you used to be that
way when we toggled machine code in a
memory and then hit the Run button way
back in the day I did not do any act
here but I did do machine code toggling
into actual machines thought I
physically toggle the buttons for and it
was machine code I did and I hit the Run
button but it was too hard to write
machine code so we wrote simple English
text for the code like my cake
assembly here and let me write a
compiler to make the actual code and we
ran that we call it assembly sir have an
assembler my left takes my cake and
assembly produces a kakie exceed machine
code which I couldn't run and actually
get a cake out so simply is easier to
write yeah sees easier to write than
assembly and java versus C and so on
instead of asteroid games are writing
things like Google Maps or tensorflow
our YouTube videos of cats what about
faster programs yeah what about faster
programs compilers got slow to make the
program's go faster you want to do the
compiler once and then do the faster
program thereafter and you mentioned
doing it all at once it's this old idea
it's been around forever and ever and
ever keeps getting forgotten a numbered
compilers don't have to be slow but
nobody paid attention because you only
did that step once if they're fast
enough you can combine the steps combine
them yeah so in my example here where
I'm taking this you know c compiler and
my cake sec one step is to produce the
machine card and the next step is to
actually run the machine code to get my
cake we can combine the steps seems
obvious and we call it just in time
compilation the JVM both runs the runs
the compiler and runs the rest of the
program as well and takes as input the
Java code as a class file and the real
world inputs builds the machine code
runs it reads the real word inputs to
produce the answer looking for its
compile then run all in one step wait a
second where do the compiler come from
well we wrote them but you need one or
and or else you write a machine code and
you said that's hard and the answer is
yes it is hard the first compiles were
written the hard way and they had to be
simple later compilers could be written
using the earlier ones the programming
community pulled stuff up by its own
bootstraps this used to me to you know
to better oneself by one's own unaided
efforts it was definitely a monumental
effort they get compilers to
state where they are now and this is why
we boot compilers yep I thought it was
to kick the lazy bum awake no so later
compilers are written with earlier
compilers yes there was some step one
written a long time ago or some poor
person whose name I found in the Wayback
Machine wrote a compiler and machine
code which reads assembly and writes
machine code it has to be written in
machine code to run on the machine but
you wanted to actually read a program
and assembly so in step two the same
person wrote compiler an assembly which
reads assembling White's machine code
and the answer of course is a compiler
it's in machine code which is reads
assembly and writes machine code and
that's assembler the first one is hard
to write because he write in machine
code and the second one's a lot easier
but the new compiler is the same as the
old one what was the point well we have
the easier to write one an assembly and
then what you need the old one for turns
out you don't you can toss it and then
you can use the second one the compiler
in machine code as your input program as
well so you now have a compiler an
assembly which reads assembling rights
machine code and you have a compiler to
machine code which reads assembling
rights machine code and one makes the
other and there's a closed-cycle there
and we call this being self hosted we
repeated that step a few times so on the
left then I have my assembler now and on
the top I'm bringing in a compiler in
assembly which reads c-cut not assembly
and writes machine code again and then I
get out of C compiler because it's
written in assembly it's much easier to
write than the one in machine code
because it's easy to write I can solve a
harder problem but Jacob I can write a
compiler that reads C code a much harder
language to write a compiler for then
assembly and we repeated this step a few
times to get to see through some in
between steps I didn't mention here
including things like a bliss and force
and Fortran and now they're always a
bunch of in between languages so we're
actually headed for this compiler here
which is in see and read see and it
produces as output a compiler and
machine code
treat see and whites machine code and
that is goodness is it Turtles all the
way down well no mom at what's not there
was the first one but not anymore well
mostly people start from C or its
follow-on C++ many languages claim to be
self hosted but few actually are for
instance they rely on the GCC toolchain
or llvm or based on virtual machines
such as Java or JavaScript themselves
based in C heavens all those funny names
what's a virtual machine wow it's a real
machine pretending to be another kind of
machine V for virtual virtual machine
the real machine runs a program that has
it mimicked the virtual machine and the
virtual machine is one that's just too
hard to build physically that's why were
you doing it virtually so here I have a
program that's a virtual machine program
and it's in machine code to run on the
real machine but it's going to read
something that's not machine code I'll
call it bytecode here and it's going to
write out machine code inside the real
machine but if I go outside that box the
virtual machine looks like a real
machine it's going to run virtual
machine code by codes and it's going to
take real wood inputs and put a real
answer out but under the hood there's a
mimic for the virtual machine that's
running on the real machine the Java
Virtual Machine is a well-known example
but there are others browsers run
JavaScript in much the same way Pascal I
think did has a peacoat machine that's
very similar oh I didn't realize there
are other kinds of machines yeah yeah
there are lots used to be lots more
everyone's new x86 now but actually
there's still wats because most your
cell phones have all kinds of funny
processors in them besides either next
86 or are more one of a handful of those
and each one needs a compiler well we
use cross compiler cross compiler knows
how to write many different kinds of
machine code so it takes as an input a
program in some language you want and
the kind of machine you're going to
target and the cross compiler here xec
will run on a machine and read your cake
sec and produce out a bunch of machine
code for machine number one and you can
run that on a machine number one and get
a cake or machine to or machine three
and all the cakes are the same
yes by design but only up to a point we
call it program semantics the compilers
try very hard to preserve the sameness
where it is defined time is not part of
the definition so programs allowed to be
faster or slower and still be the same
in here I'm going to vary from my slides
a little bit and this represents one of
my might be one of the greatest
weaknesses of the current crop of
programming languages in the planet they
don't refer to time directly so faster
or slower actually makes a difference of
course because of the moment we're born
to moment we die we have a finite amount
of time on the planets the most scarce
resource of all so time is actually the
most important thing the act of dropping
time from probing languages was done to
make the language mathematics simple and
able to let us do the things we do as
compilers right now but it is not it
misses out on a fundamental truth of the
universe so I think there will come a
time when we will put time back into the
programming languages and then we'll
have hard real-time baivers possible
right now everyone who does hard
real-time has to work very hard because
I only get so much help I vages and the
rest of it they do themselves you ever
make a mistake what is it compiler has a
bud yes then things get complex I should
talk about the best compiler bed of all
time that ken Thompson hack whoa slow
down okay okay let's look at a simple
compiler button what's it do suppose I
make a mistake well I'm trying to make
fast machine code so i have a seat
compiler on my left here which is in
machine code it's going to read see in
right machine code i have the same
compiler in source code and see in
reading see and i'm going to write out
machine code and when we run out better
machine code faster machine code but i
make a bug so I then compile my compiler
and out comes a new compiler which is
like the old one but it has a bug in it
I take the buggy compiler and I run it
to go you know try to go use it on my
cake that CC program to get something
done there instead of getting it out of
pilot machine code it probably just
crashes but it could be that my bug is
subtle and I just make bad machine code
out when i run the cake exe on the
flower the instructions are bad and the
robot burns the cake
right there's some problem in the
generated code but your compiler is now
buggy and i'm using the compiler i can't
make a good new one because i'm using
the compiler to make my compiler so we
have to roll back we have to keep a good
old copy and then we can start with the
broken c code that has my bug in it and
hopefully fix it and make faster code
out and when i compile it I get a
compiler in faster machine code which
will read c and write faster machine
code will call this an optimizing c
compiler who was ken thompson and what
was this hack well he was an early
compiler writer he came with this really
cool hack he said suppose suppose i have
this you know bug i wrote into the
source code and the bug is kind of
special it says if i see that i'm
compiling the root password checker
insert a secret back door so i can log
into every UNIX machine on the planet in
the output of compiling this is another
compiler that looks for all the world
like a c compiler it has all the things
you expect us you can probably to do
except that has a bug in it that when it
compiles the unix source code the
password checker has the secret backdoor
and now i can break into any unix
machine on the planet a giant security
hole okay okay but this is a bot right
just fix the compiler in the problem
goes away i can look and see the source
code it's got a bug in it ah not so fast
kim tak is more clever than that i'm
going to insert a second bug second blog
says if i see that i'm compiling myself
i'm going to serve both of these bugs
and now in a compiler that has both of
these bugs in it no problem works the
same as they did before when i run it on
the UNIX kernel compiler compiles unix i
get out a root password checker and a
back door i can break into i can itself
host and take my compiler and run it on
myself and when you see that i'm
compiling myself i'll insert both of
these bikes notice i didn't need the
piece of bugs to say that so i can self
host and throw away the old good
compiler and fix the source code and now
the bugs only live on
in the machine code which is too hard to
read for humans miles and miles and
miles of it so when I compile myself I
get out a new compiler which is the same
as the old one it's truly self-hosting
and it has these two bugs in it the bug
is only in the compiler you can't see it
in the source code at all and you can
repeat this for all the tools in the
tool chain / Rose editors kernels no
evidence we found the source code the
bug is only ever in the machine code but
when reads itself poussez the bug back
went to read your debugger pushes a
buggy to bugger that hides itself right
really slick there other tricks you can
do for instance 80s game emulators oh
now I've heard enough go ahead a
compiler save the world or some such yes
mom I've done</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>