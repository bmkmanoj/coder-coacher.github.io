<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What's New in Java EE Security: JSR-375 and Beyond by Will Hopkins | Coder Coacher - Coaching Coders</title><meta content="What's New in Java EE Security: JSR-375 and Beyond by Will Hopkins - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What's New in Java EE Security: JSR-375 and Beyond by Will Hopkins</b></h2><h5 class="post__date">2017-04-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/D0SfxPvUj18" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay sorry for the late start had
trouble getting my machine to like this
VGA so I'm well Hopkins I'm the spec
lead for jsr 375 I'm going to talk about
what's new in EE security jsr 375 and
beyond this just says that you can't
really believe anything I say I'm gonna
start out talking about sort of where we
are today with jsr 375 and how we got
here then talk a little bit about what's
actually in the jsr the API is were
defining talk about what comes next
there are some things we can get to and
other things we'd like to do so
hopefully they'll be a follow-on jsr and
wind up with some pointers to resources
and any questions you might have this is
Jay SRS 375 expert group there's myself
the spec lead a lot of other folks on it
many of whom you might know and several
contributors jsr 375 started in early to
mid 2014
there was a Java EE survey that showed
strong support for security
simplification and security interceptors
we took that and made a proposal for a
jsr GFI 375 proposal was submitted and
approved in late 2014
I think December it was approved expert
group discussions began in the spring of
2015 we had a renewal ballot in the fall
of 2015 from there until maybe the
middle of 2016 there was not a lot of
progress for various reasons but in the
fall of 2016
to come in and take the speckly job from
somebody who was transferring which I
did and we had another renewal ballot
not to keep the DSR alive we've started
up discussions again and just published
an early draft for review that's
actually out in review right now the
primary motivations were to simplify and
standardize in terms of portability and
modernize the API is somewhat there are
a lot of different security mechanisms
and EE today their container API is
there's Jack there's a spec proprietary
IP api's in the different vendors
implementations and particularly there's
a lot of proprietary configuration and
management which makes it difficult to
arrange for security for applications
the EE container is to find similar I
api's in many cases but with slightly
different syntax you've got
httpservletrequest as user enroll versus
EJB context is call or enroll mechanisms
like Jack and jaspe can be difficult to
use particularly a spec jack is not so
hard for the programmer but tough to
implement an existing API is don't
leverage modern capabilities like CDI
for the most part so there was a goal to
define simpler security mechanisms
implement them in a standard way across
containers and use update the
technologies that we used the other sort
of strong thread there is to enable
developers to manage and control
security for themselves so they're you
know previously was no standard portable
mechanism for controlling how
authentication happened you could say
you wanted basic or form in a web app
but he didn't get a lot of control over
how the authentication happened on the
back end
there wasn't any support for configuring
and managing identity stores or for
managing user roles and permissions you
could define what roles were but you
couldn't really assign them
and there was no support for deploying
customer authorization rules so a second
goal is to find portable API is for
authentication identity stores roles and
permissions and authorization so the
list on the left is what was originally
proposed the final spec that we have is
not going to include all of that the so
we're defining that the first four items
there and basically the idea is we
wanted to get something standardized
some time for EE 8 so that we could get
a foundation in place we felt that these
three in particular were a necessary
foundation for cloud environments that
are important these days and not that
the other things weren't important also
but to seem like a good chunk of
necessary foundation and and we had a
good start on on completing out so the
idea is to basically wrap that up and
deliver that with EE eight less left to
do the spec is currently an early draft
review we need to have that draft
reviewed and incorporate the feedback we
get we need to prepare a final draft
final review draft with updated spec in
code we need to update the reference
implementation sotiria to match the
final api integrate that with GlassFish
5o and write the TC code TCK code and
documentation this is what our schedule
looks like for the the rest of the jsr
early draft reviews underway the public
review draft public review period is
from April 17th through the 16th of May
followed by a public review balance
proposed final draft On June 12th and a
final approval ballot from the 26th of
June to the 10th of July
so what's in the jsr so there were some
common principles that we were trying to
adhere to so the idea generally is to
simplify things enable developers to
manage security have the api's work
together so that one might delegate to
another and their composable or
appropriate and use CDI and annotations
the first api is HTTP authentication
mechanism and the basic idea there is
that it's a simpler way to leverage a
spec so the a spec is a pretty powerful
mechanism it's got rich functionality
for authentication
it's even really broader than that it's
a message processing model securing
messages and validating messages so it's
it's very broad very flexible you can
support about any token type or
credential you could imagine it can
manage multi-hop conversations between
clients servers and third parties and
it's integrated into the server
container via the servlet container
profile but it can also be difficult to
use for some of the same reasons one
reason is that there's not a standard
declarative configuration so there is a
standard configuration mechanism but
it's programmatic and it's sort of a
last one wins in terms of registering
things kind of a a model which is not
always very deterministic the other
aspect of it is that you have to
implement a lot of different interfaces
and objects that you don't really care
about if you just want to deploy a
server authentication module with Sam so
the things you would have to do to use
Jasper today would be you'd need to
write an auth module which is the thing
at the top right you'd also need to
write an auth config provider which
would be responsible for handing out off
configs which would be responsible for
handing out off contexts which is
responsible for
invoking on the Sam so the PC one
implement is just that the top right
part the author module but all the other
stuff that you have to code or configure
is is the bottom three boxes on the
right and on the left if you want to
have a standard way of configuring this
Sam you need to register it yourself
which may or may not have conflicts with
other things that the container might
register or other apps and things like
that so HTTP authentication mechanism is
meant to address some of those issues
there's one interface to implement HTTP
authentication mechanism you can deploy
it with your application just by
including it in the archive you make it
available via CDI so that it's known to
the runtime and then you tell the serval
container you want to use it by setting
your auth method in web.xml to auth Mac
and so what you implement is just the
thing that you care about which is the
module with the actual authentication
logic in it and the configuration is an
edit to the web.xml
so the container is responsible for
doing some things for you for HTTP
authentication mechanism one is that it
provides a wrapper server authentication
module and basically this is a jaspis
Sam whose job it is is to invoke the
HTTP authentication mechanism that it
injects through CDI
so it's a standard thing it can deal
with any HTTP authentication mechanism
cuz the interface is the same the server
also provides all the related objects
that you need for Jasper configuration
so there's an auth context and auth
config and auth config provider it
recognizes the auth mech off method and
arranges for all of that to be
registered in the gastric factory for
that application context so all of the
sort of heavy lifting forge a spec the
container does for you behind the scenes
the interface mirrors the server off
module interface so it's so that the
wrapper is actually pretty
straightforward in terms of what it
needs to do is just sort of delegates to
this object it knows so the validate
requests method gets invoked just as in
jaspe for the due filter service method
it's called secure responses invoked
after do filter or service and clean
subject is invoked in response to the
application calling logout on its
httpservletrequest that's the interface
at least as much of it as would fit on a
slide but it's the important bits
there's the validate request the secure
response there are default
implementations for a couple of those so
in many cases all you'd need to
implement is validate request and secure
response and clean subject have
reasonable defaults
identity store is the next API so the
idea with that one is easier identity
management so previously there was no
portable way for an application to
configure user stores every container
differently identity store interface
enables lightweight user store
implementation so there's a fairly
simple interface again you can implement
if you want to write your own identity
store that talks to a store that that
you understand but there are also
built-in identity stores so there is
annotation based configuration for LDAP
and our DBMS which will result in a
default implementation supplied by the
container being instantiated for your
application context so in essence it
lets you sort of configure your own the
the LDAP where the database has to be
out there somewhere
but you can point your application at it
pretty simply the interface is intended
for programmatic invocation so it's a a
layer that could be used the intent is
primarily for HTTP authentication
mechanism but really any code that
needed to authenticate users could use
it but there's no direct container
integration in the sense that containers
are not required to use identity store
for anything they're certainly allowed
to but they're not required to so it has
a pretty simple interface there's a
validate method which will take a
credential a username password
credential for example and a method to
get the group's for a particular user
based on the principle an implementation
can support either or both of those
methods the it declares which by what it
returns from the validate type method
and that's either going to be
authentication meaning that it supports
the validate method or authorization
meaning and supports get groups by
caller principle the idea there being
that authorization is typically based on
group membership or achoms
support both and it has to declare a
numeric priority for ordering when there
are multiple identity stores that's the
identity store interface
it also has default implementations for
all of his methods really the first one
actually determines so the type argument
there's credential but if you pass for
example user name password credential
this default implementation determines
whether the interfaces implementation
has a method matching that type and if
so it invokes that method and then there
are sort of trivial defaults for the
remaining three methods sure
right so the the lower number is higher
priority and I I honestly can't speak to
why that decision was made it was made
before I came on board as suspect leave
but that's how it behaves it won't if
there's multiple they'll they'll all be
you know I'll get to that in a minute so
the interaction with the identity store
is always through an identity store
handler calling code invokes on the
identity store handler and should never
call identity store directly
identity store handler delegates to the
configured identity stores and manages
invocation across multiple identity
stores and aggregates the results
there's a default identity store that's
supplied by the Container applications
can replace the identity store handler
if they want to if they'd like a
different algorithm but the default
handler provided by the container is a
fairly reasonable algorithm so that's
the identity store handler interface
you'll notice that there's only a
validate method the get groups by caller
principle method is not exposed it's
meant for internal use as part of
orchestrating authentication with
multiple providers and wouldn't ever be
de vocht invoked directly by the
external code the result this returns as
a status which is either valid meaning
that the credentials were validated
invalid meaning that somebody tried to
validate them but they weren't valid and
not validated meaning that there was
it's an identity store handler or an
identity store that was willing to
handle the credential or was
successfully able to so you get a status
back in the success case the valid case
you also get the caller principal back
and you get the call to groups if any
this is the algorithm for the default
identity store handler so it first
constructs a list of the available
identity stores which is ordered by
priority lower number is higher priority
and it iterates over that list invoking
the validate method for each identity
store where the type is either
authentication or both meaning that it
supports the validate method if any of
the identity stores returns invalid then
we remember that result because we might
need it later
if no identity store returns valid then
we return invalid if any previous
identity store returned that status
otherwise we return not validated
because it means that no identity store
was able to attempt some validation
assuming that we got a valid results at
that point then we iterate over the list
again invoking get groups by caller
principle for each identity store of
type authorization so that only the ones
that have said valid so in step two we
would have returned already if we didn't
get a valid no for the for the first one
that's a good point I left that out of
this description but the first valid we
get we break out of that loop and then
we correct but we do make a second pass
call and get get groups by caller ID to
get any groups that might be in in other
stores
no because the the the first time we
only invoked validate on the identity
stores that declared themselves to
support authentication or both the
second pass is over the identity source
that declared themself to be type
authorization so by definition is only
the ones that we have not yet invoked
the the idea is that you might you might
authenticate credentials against one
store but then fetch user attributes
from a different store so assuming we
got past step three we return over a
result that says valid and you'll have a
caller principle and the aggregated
group so you may have some groups from
from the identity store that validated
the credential that one's going to in
turn the caller principle and might also
return groups and then you may have
additional groups from the authorization
identity stores that you invoked
so that's what it would look like if you
had multiple identity stores and you
invoke this through HTTP authentication
mechanism HTTP authentication mechanism
will invoke on the identity store
handler which will iterate over the
configured identity stores and each of
those are pointing at some user store
yeah this one
yes
yeah so so that's not a very good
picture of the loop but basically the
identity story handler is going to
iterate in this particular case it would
iterate over the first two to do
authentication and then in the second
loop it would it would only invoke on
the the last one there but there could
be any mix of authentication and
authorization there and it would iterate
over the asset twice or it might even
make two different lists right it
doesn't have to be one list but it can
either iterate over one list asking each
time where it can make two lists and
iterate over one and then the other
right so that that's an equally valid
implementation
so there are annotations for the
identity stores an ldap one and our DBMS
one LDAP identity store definition and
app database identity store definition
they're modeled on the app data source
definition annotation the idea is that
you would annotate some class that's
visible to CDI and during the annotation
processing it would cause an instance of
the built in identity store for either
LDAP or database to be instantiated and
populated with the configuration values
that you specified in the annotation
yes identity stores are injectable
yeah
that's correct so jsr 375 says that the
container must provide a built-in LDAP
identity store and a built-in our DBMS
identity store and then these
annotations would be used to configure
them and instantiate them but you're not
required to use those identity stores
you could implement your own if you
wanted and as long as you make it
available to CDI it will be used so
that's the LDAP identity store
definition
so one one interesting question that
would be useful for us to have feedback
on is the extent to which people feel
like this set of values is sufficient to
is sufficiently rich to handle all the
cases that people are likely to
encounter so we we can't be all things
to all people and there are certainly
environments where some fairly arcane
configuration for LDAP can be required
but does this cover the you know the
basic requirements for the 80 or 90
percent case so I'm not necessarily
asking for feedback right now but if
people are reviewing the EDR spec that
would be a useful piece of information
this is the corresponding one for the
data database identity stored definition
and databases are a little bit simpler
generally but again the same question
would apply is this sufficiently rich
configuration
but Energy's identity stored is one of
the areas where we have some ongoing
conversation in the expert group one
question is whether get groups by caller
principle needs to be privileged or not
there's a pretty good argument that it's
a dangerous method to have just sort of
available in the container
especially injectable by essentially any
bit of code when you can basically hand
at a principal name and find out all the
groups that that principal belongs to
and you could even use it to poll the
user store and say is there a user
account for John is there a user account
for Joe's or a user account for Lucy or
Frank or Sally and that's a pretty big
security hole realing so one solution to
that is to require that the calling code
is privileged to invoke it either always
or when security manager is enabled and
then the other change this under
consideration is to pass something other
than a call or principal to get groups
by caller principal that would obviously
require changing the name of the method
but the idea is that in some
environments a caller principle isn't
going to be enough to uniquely identify
the user so would we want to pass in for
example the credential validation result
which would have not only the call of
principal but also perhaps a unique ID
or a user DN or some other bit of
information that would help the identity
store number one recognized if it was a
user that it knew anything about and
number two disambiguate the user
accurately identify the user so that you
make sure you return the right groups
for for the user as opposed to the
groups that belong some other user with
the same name
and lastly might make sense to return a
set rather than a list of groups
security context is the last item that
we're working on for this this jsr the
idea behind security context is to
provide consistent access to security
information across containers so today
the various containers implement context
objects and methods for access to
security you've got get user principal
and httpservletrequest is user enroll
authenticate EJB context has very
similar methods but they have different
names so security context is intended to
provide a consistent interface across
different containers for this sort of
information and also an extension point
for for adding security functionality at
the moment it has three methods get call
or principal is call or enroll and
authenticate but we expect more methods
in subsequent ASRs authenticate by the
way only works in the servlet container
it's essentially dependent on the HTTP
servlet requests to authenticate method
that's the interface
the additional parameters on
authenticate are basically a way of
providing a little bit richer input and
a little bit richer response reflecting
what you might be able to do with an
HTTP authentication mechanism and for
that matter with Jessica so jessica has
a model where authentication might need
to continue because you've just sent a
challenge to the client and the client
has to respond that sort of thing so
servlet httpservletrequest so to
authenticate will return true or false
depending on whether you need to whether
you should expect that you're going to
continue or not but it's not very rich
in terms of the information that it
gives you I'm sorry
I'm sorry I didn't catch that
yeah oh so I think the Assumption there
is that that the request is available
from the CDI context at that point
that's a good question though
off to go back and ask our Jen that
yeah
so I think security context should be
injectable I don't know I've talked my
head if it is now or not that's a good
question the existing API is aren't
going to go away and honestly I don't
think we've looked carefully yet about
at the interaction between CDI and
security contexts in that environment
but the the broader notion is that get
call a principal and his collar and role
should return the same results as you
would get by calling any similar method
in a different container so I haven't
thought through the CDI case
specifically but the servlet container
case the EJB contacts case the results
should be the same and this spec doesn't
require a particular implementation so
it doesn't require that that this gets
the principal from the CDI context it
doesn't require it require that the CDI
context get the principal from security
context similarly for several container
or EJB contexts the requirement is that
the behavior be the same and the
containers get to implement it however
makes sense on that platform
I'm sorry can
right
well I think it depends on that the
context in which it's invoked because
the the current implementation uses CDI
to inject the the the relevant context
object so depending on the context that
you called it you'd get a different
context object and inject it and return
a different answer but that's something
we probably should look at in terms of
what when it should be I on some level I
think it it's probably moot it certainly
moved for the caller principle because
you are who you are right the principal
won't be different depending on the
calling context unless somebody's pushed
it on the stack as far as roles jack has
a lot to say about context IDs and and
role mapping and things like that so we
would want to be consistent with what
jack says there
so I made this one already but
containers are free to choose the
implementation approach that they want
to use its jsr 375 is really trying to
specify the behavior in terms of what
containers do now so we're not trying to
necessarily at least with these methods
to find new behavior but define a
consistent interface to existing
behavior authenticate provides slightly
richer functionality in the servlet
container and at the moment has sort of
an implied contract with issue to be
authentication mechanism in terms of
signaling that it does back and forth
between the two to sort of emulate the
Jass pick message flow behavior so
that's what's in 375 next I'm going to
talk a little bit about what might come
after so there's a number of ideas that
we have for that so completing the
remaining items from the original jsr is
obviously one of the things we want to
look at we've also had features
requested by the community and features
that we think are sort of implied or
driven by cloud and micro services use
cases the first four on this page we
expect to have been done in 375 so the
remaining ones would be password
aliasing enroll permission assignments
and authorization of scepters
interceptors the most recent Java EE
survey came up with a pretty strong
result showing that Roth 2 and o IDC
ranked as the third most important
technology that people wanted to see him
in Java EE so we took that as a pretty
strong clue of what people want us to do
there in terms of cloud driven features
secrets management and encryption I
think is is
one of the most important ones that
isn't already on the list that the cloud
use cases are driving so password the
only thing I think it's probably a
subset of that but secret management is
crucial for cloud deployments because
you often need secrets and keys of one
sort of another and you need to be able
to securely store them and retrieve them
and manage them and do this while you're
deploying to a cloud that may or may not
have services to support that and then
you need to be able to use them securely
once you've once you're managing them so
you need to be able to do encryption and
signing in a secure Lane so I'm not
going to talk a lot about details of
OAuth 2 but basically it's an
authorization and delegation framework
there's some RFC's that define it based
on he was listing work defining token
types one particularly interesting
challenging thing about OAuth 2 for Java
is that there's multiple identities
involved so there's a resource owner
which is not necessarily the same entity
as the client that the server is talking
to and then there are two different
servers involved so it's not just sort
of a client-server model but there's a
client and a resource server and there's
a client or an authorization server and
again the clients and the resource owner
aren't necessarily the same person and
that presents some challenges in terms
of the Java model where you're sort of
presumes any requesters presumes to be
executing with a particular subject but
in fact you might have be talking to one
entity but having to authorize access on
behalf of some other entity in the
course of Olav one last thing to note is
represented as scopes which in some
senses can be thought of as similar to
roles this I'm really not going to talk
about it all partly because it's an eye
chart and partly because
it's a lot of complicated stuff and we
don't have a lot of time I'd need to
look at all these very carefully to
explain them but in terms of the
implications for what Java he needs to
do the basic requirements are you've got
an app you've got a couple of resources
that you want to protect you've got some
client that's trying to access those
resources and again the client may not
be that the actual owner of the
resources on the back end there so a
number of things have to happen for that
to work you've got these resources
there's this external authorization
server out there the application needs
to be able to create the OAuth resources
because the authorization server needs
to know about them so that it can
authorize them in terms of issuing
tokens with scopes in them and the app
needs to be registered with the
authorization server for that purpose
the client also has to register and
update the Scopes that it's interested
in then it needs to execute an
authorization foil getting an access
token for those scopes and optionally a
refresh token then it calls the
application on the server passing the
token the server needs to validate that
token and get the subject and then it
also needs to think about okay so now
I've validated the token how do I
represent that internally and how do i
how do i model the Reese of the access
grants that are implied by the scopes
and the token given who I'm talking to
so on the server side how do I register
OAuth resources how do I indicate my
scopes on the client side how do I
register my OAuth client how do I know
what scopes to ask for how does my
client get tokens how do I handle token
expert
can we abstract variations and
authorization servers so every
implementation of an authorization
server is a little bit different they
are often configured differently so the
tokens have different attributes in them
is it possible to abstract that in a
sufficiently rich way without making it
overly complicated and how do we deal
with scopes and clients and resources
have scale so some ideas would be on
server-side annotating resources to be
secured so that a lot of that process is
hidden from the implementer and you just
annotate your air your method and the
caller that gets in or doesn't annotate
whether a resource needs basic auth or
Roth to 400 secured resources
standardized a scope declaration
standardized a resource registration
with an authorization server that might
be a tough one given that we don't
necessarily you know and less we're
going to build a Java EE authorization
server that one's gonna be hard to do or
adapt to specific authorization servers
in document off methods and scopes
client side life cycle to handle client
registration static or dynamically
created clients secure management of
client ID and secrets discovering
capabilities on targets for constructing
tope scopes in token requests and
abstractions to acquire tokens a lot to
flows the strategies token X free
handling expiration to inject tokens on
invocation
so those are things that we could look
at doing for oauth a lot again seems to
be the sort of most requested feature
role and permission assignment has a use
case applications may want to manage its
users or exert externally managed users
and may need to assign roles to users or
groups based on an application specific
model user groups assigned to roles
changes based on deployment
representations changed based on what
identity store you're bound to and both
two scopes versus roles you know is
there overlap there the same thing of
the complementary those are questions
that would have to be answered some
ideas would be to support deployment
descriptors can change the binding at
deployment based on configured ID stores
so at the moment role bindings actually
do happen a lot of times and deployment
descriptors but their proprietary
deployments Krueger's so you know
WebLogic xml has some role bindings but
web.xml does not assigning scopes to
auth to resources to roles so that would
enable an app to bind scopes to roles
and map users and groups may change
authorization interceptors the use case
there's that the application must
restrict access to functionality enrolls
by themselves to to coarse-grained
and we need or the use case requires
application business model or that
determines rules to drive access there's
no consistent interceptor for policy
enforcement there's no consistent to
externalize level rules and it needs to
be bindable to changing identities by
business and operation so if you
hardwire a bunch of rules based on
specific identities into your
application that's going to be pretty
brittle over time some ideas to address
that are standardizing on some
interceptors allow security teams to
build custom authorization logic with
some external externalized and
standardized rule language and make it
identity and security context aware
secrets use case for that as application
needs to be able to securely manage
secrets that might include passwords for
resources like an OAuth client ID in
secrets applications are able to secure
secrets in a portable way they aren't
stored in clear text values can change
and be bound for deployment meaning that
you have an application has a referenced
some secret but when you deploy that the
actual value of the secret might be
different state needs to be externalized
or at least external as a bowl an
application may consume secrets from a
key management system and there's more
and more of those showing up in clouds
so some ideas their applications refer
to secrets via aliases that's similar to
the password aliasing feature that was
earlier talked about those could be
configured via annotation their
deployment descriptors and have a life
cycle where you bundle an alias and a
value as a secrets archive with the
application or bind values to aliases at
deployments possibly from an external
key management system and you would need
tooling to manage Secrets and in an
archive or elsewhere another thing that
we could look at is relying on pkcs12
support in java does security key storm
so that's basically the the content of
the presentation here I've got a list of
things you could look at if you're
interested more information we've got
the JCP page the java.net project the
code and the spec are actually out on
github at the moment we have a github
project there are a couple of mailing
lists you can join the users list at
java.net there's also the expert lists
which you could send to but it's it's
moderated if you're not on the expert
group everything on the expert list is
copied to the users list so if you join
the users list you'll see all the
experts right
lissa traffic as well and we do have a
twitter feed if you're interested in
contributing certainly the most
important thing or the most valuable
thing at the moment would be to look at
the EDR spec draft and provide feedback
you can download it from the downloads
page on JCP org and send comments to the
users email list if you're interested
you could also join the jsr as an expert
or a contributor again comments or
suggestions to the users list you're
welcome
or come and talk to me or to any of the
other expert groups that you expert
group members that you may know that was
all I had any questions
Open ID Connect I think yeah I thought I
had a slide on that I guess maybe I
didn't
but yeah along with oauth2 I mean the
two are highly related because Open ID
Connect is built on top of the oweth oo
auth two protocols so doing open ID
connects what it presupposes that you've
got some level of support for the basic
protocols already in place but yeah
that's absolutely an authentication
mechanism that we think is important
I think they're in a different space so
the HTTP authentication mechanism you
could use that interface to implement an
HTTP authentication mechanism that could
do open ID connect so you could
implement open ID connect by by writing
an HTTP authentication mechanism so
they're they're complimentary in that
sense but this spec does not define or
require support for open ID Connect
specifically I think a follow-on jsr
that's something we'd want to look at
very carefully we would want to look at
how do we provide support for for
consuming at a minimum that there's a
lot of stuff we talked about here in
terms of what you could do on the client
side and the server side but at a
minimum I think on the server side the
rest container needs to be able to
consume an OAuth token and do something
useful with it and I would say that
server container and any other HTTP
based container would you'd want to be
able to consume an OAuth token that
happened to be an open ID an ID token as
opposed to an auth token right but the
again a lot of the underlying protocols
and token types and things like that are
the same
it's a different spec it's one of the
token types that Roth and therefore open
ID support JWT is the one that I've seen
most commonly used
yeah but oscillation model based on
group seems to be pretty cost-efficient
modeling
I think that's true and I think it's
actually a little bit unfortunate that
we've got the word authorization in
there at the moment so the identity
store includes authorization as one of
the things that an identity store can do
my view is that that's a misuse of the
word because it's not really doing
authorization it's fetching attributes
right so you might use those attributes
later on to do authorization but it's
not right exactly and I'm actually
having this conversation at the moment
in the expert group and so it's possible
that may change but yeah I agree 100% on
that
anything else thank you for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>