<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Spring REST Docs - Documenting RESTful APIs using your tests by Andreas Evers | Coder Coacher - Coaching Coders</title><meta content="Spring REST Docs - Documenting RESTful APIs using your tests by Andreas Evers - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Spring REST Docs - Documenting RESTful APIs using your tests by Andreas Evers</b></h2><h5 class="post__date">2015-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/iWj-t69EdN4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone welcome at my talk about
spring rest docks I think we can start
all right so it spring rest docks new
library from spring team is there to
help you document restful api but using
your tests that's a new approach which
is really interesting but first things
first Who am I am I work for or Deena
Belgium I'm on vs Avis I really love
open source and I also contributed a bit
to this spring res Docs library and at
the moment I'm actually working for
Proximus as technical data encoding
architects so actually documenting
restful api s is not that easy not that
straight for it but there are some tools
to help you out and when you're actually
setting setting out to select a tool for
helping you do - it's important to
really keep in mind some ideas some
concepts which are really important with
actually documentation in general so the
first concept of ID or ID is actually
that having no documentation it's better
than having wrong documentation so when
you're actually documenting your
contracts it's very important that you
have some assurance that your API is
really up-to-date that it's accurate
because otherwise people are not going
to trust your documentation anymore and
they are not even going to read it so
that's it's very important that you keep
it up to date and if your tool helps you
to do this then that's just the first
step in the right direction right then
the next thing is that documentation
should be easy to write and should be in
a format which is designed for writing
that's not that easy if you if you for
example work with HTML then you gotta
work with all this verbose syntax so
using something like for example
markdown which we do in our readme files
in github this really helps you along so
actually spring res Docs uses asciidoc
for this which is a nice formats which
is similar to markdown okay and I don't
really believe that you can generate
almost
everything for for your documentation I
always think that there should be
something which you still write manually
and for that you need to have some kind
of format right so the next thing to
keep in mind is I don't believe that
frameworks should be analyzing your
implementation to predict documentation
okay it's something that other tools do
but it's very hard to do this and the
chance is that your documentation will
eventually not be up to date or will not
be accurate or not even correct is
pretty big it's it's very hard to
predict what will be going on with your
requests and responses when you actually
try to analyze your implementation
details so a tool which is actually
doing this is swagger and I think most
of you know about swagger is that right
okay that's a lot of people and who
actually uses swagger in their project
okay bit less okay but for those people
this won't come as a surprise this is a
nice UI that swagger actually provides
and it's really useful if you like to be
your eyes centric in your documentation
so it's it actually puts the your eyes
first and you can actually by clicking
on those your eyes discover which
resources are are available and what
they expose what information they they
expect and what information they expose
okay so that's all nice but it actually
when you actually want to go full rest
which is rest level three then you
should think about hyper media so
swagger doesn't support hyper media and
hyper media is it's really the glory of
rest is are you guys familiar with a
hyper media constraints okay that's not
that many so there's this maturity model
for rest where you can use these links
to actually navigate from resource to
resource and that's the the last step of
the maturity model and if you do this
then you're actually building something
which made the web great because in the
web we have all these HTML pages which
are actually resources as well and they
have links since
sites and forms inside and they actually
perform like a gas or a post on other
resources nor the so they're like links
okay so this this actually allows you to
not having to bookmark every web page in
the whole world wide web and if you
apply this to your API your own API you
have two great benefits the first one is
that you have independent evolution and
second one is that you have the cobalt
implementation and those things are
pretty important if you want to be able
to to evolve really easily for example I
have here an example of such hyper media
enabled JSON response which has two
parts really so the first part is the
data part which you normally have as
usual in your JSON just a bunch of
properties and then you have these links
which are actually pointing to other
resources and this allows you to just
have the keys of the links the
relationships such as self nodes and
tags and not care about the URI itself
because you can just use JSON path to
get that your I and then follow it so if
the server changes that URI then you
don't care you're still gonna work from
a client point of view okay so that's
really useful and if you apply this then
your your tool your documentation tool
should really be able to to document
this functionality because what you
actually want to know if you use this is
what resource do I have and from this
resource which links do I have and when
I follow those links what am I going to
find if I actually reach it okay
so unfortunately swagger doesn't support
this by design and that's fair choice
because probably they're going to have
to rewrite everything but it's just not
possible
so if you want to use hypermedia you're
gonna have to look for another tool
another thing about swagger is that it's
pretty intrusive in the production code
so it does use all these annotations
that you have to put on your production
code and that's maybe like a nice design
if in theory but if you look at this
then maybe you might not like that that
much anymore and I've seen worse
examples actually so you do have some
check
surest annotations on top but then you
have a ton of annotations which are just
documenting and we already have all
these annotations there we really don't
want more annotations especially not for
documentation so this is something which
we might want to avoid and also because
of these annotations it's actually
trying to to rely on implementation
details like I already mentioned at the
start of this session it's pretty
dangerous to do this you just want to
document your contract and you don't
want to document your implementation
this also allows you to to just change
your implementation and as long as your
contract doesn't change your
documentation is going to stay the same
it's pretty hard to actually do this if
you like to rely on the implementation
details because for example if you have
this these annotations that's on the
controller but your response actually
goes through maybe some filters or
interceptors or even the HP client and
they could all do some changes to your
to your response so it's it's just very
hard to do this to get this right and we
actually see this by some sometimes
mistakes and that swagger has for
example this one it might be a bug
that's already solved but it's testament
to how difficult this can be we have
this response and T body which actually
has insights status code headers and
body so that's that's not really part of
the body but okay and then you have
status codes with all these different
status codes and I'm sure that this API
this this this resource doesn't expose
all these kind of read this all these
kind of status codes probably a couple
of them but not all those and that's
probably because the enum consists of
all these sales codes but that's you
don't really want to leak that into your
documentation what you wrote in your
domain model because that's separate
should be documenting your contract
instead so aside from this the framework
is still heavy before August it was
about 31 megabytes but then they removed
the Scala runtime library and now it's
about half that size but it's still
pretty big so for a documentation tool
that really want it has to be like lean
and mean you don't want to have that big
dependency especially if you're going to
build marker services for example then
you want to have small services
and not drag all this extra extra
libraries with that so we should be
looking at a new alternative right
because there are some downsides to
swagger although it does have some pros
as well but if we could actually solve
those downsides we'd all be better off
right so actually and the Vulcan son
from the spring team he experienced
these issues or these concerns firsthand
when he actually used swagger on a
project and he started out building a
new approach a new way of thinking and
implemented this by using integration
tests so when you're building
integration tests you can actually for
example with McCann BC make requests and
get responses back do some assertions on
that and then there's also the
possibility to - with spring grass talks
of course to add some extra
functionality which will check if
certain fields are there and if they are
documented and then also make that
documentation itself it will just I'll
just show an example right away so once
you've got these integration tests they
can be ran
and then once they're run you can
actually get automated generated
snippets which are just serialized
requests and responses or some tables
about what fields you have in the
responses and all that kind of stuff and
that's all generated and guaranteed up
to date so once you got that you also
want to have that manual documentation
that I was talking about
so you're just creating a template which
can actually state some more interesting
information to the clients that you
don't want to have automatically
generated it's just human language
basically right so that's the template
and you can actually insert those steps
the snippets in the templates once
you've done that you can actually have
your eventual HTML generate it and
that's what you're going to send to your
clients that's your actual documentation
okay so now let's take a look at each of
these steps and see how they look into
the code so we've got integration tests
mokan BC and one familiar with this I
suppose most of you it's just making a
perform so it's making a call on that
URI and then so the request is sent the
response comes back it's checking in the
status code is 200
then it's doing some more assertions
with Jason path to see if certain fields
are there so that's all standards that's
what you would write when you were doing
a regular integration test with mocha BC
and then you have this undo method which
is basically a hook that mocha BC
provides to add extra and extra
functionality and spring res Doc's
office that in form of the document
static methods this really allows you to
to add some link documentation some
response fields information some request
fields documentation even more stuff
which I will show you later and for each
of the links for example you have to say
okay which relationship which key do
they have and what's the description and
that's the documentation okay for the
response feels the same thing which path
and then the description of this field
so the ID that actually it's behind this
to keep it accurate is that it will
check if all these links are actually
present in the response or these fields
so every field is missing in the
response but it's documented it's gonna
fail the test and it's the other way
around as well if it feels coming back
in the in the response but you haven't
got a document yet it will also fail the
test so this is the act the actual
assurance that your documentation is
always going to be up-to-date because it
will just not build it won't even try to
deploy this this new form of
documentation which is out of date it
will stop it okay so that's the
interesting part so once you got this
it's also gonna read these links parts
and response fields parts is going to do
this request and response and it's
making snippets as I told you so
these snippets for example for requests
come in two different flavors the curl
flavor and basic HTTP notation flavor
which you can easily just copy paste in
in a batch window and just reproduce it
for response when you have a body you
see body which is also very concise
notation and as well for the links which
is a table so that's asciidoc format
it's representing a table but it's
really easy to write you don't have to
mess around with table tags from HTML or
whatever and you can just you can just
see that it's like two deaf
and columns and then a3 rows which fill
in this information and this information
is generated and it's coming from that
fluent API which I showed you in the
first slide here so as you can see self
no tags and then this information next
to it is the description and that's just
filled in here okay so this is generated
out of that and then you've got same for
response fields also the table so once
you've got these snippets you have to
inject them in a global template and
that's written like this so you can see
there's an anchor resources note and
then the title note then you can fill in
some manual documentation okay you can
really just describe it a bit also the
resources documentation the resource the
subscription or description really isn't
really going to change that often so
it's fine to document as manually but
what you don't want to manually document
is which fields are coming back which
links are coming back because this could
change a lot this could change often as
well so that's what actually we inject
which we include them with those
snippets okay so that's always going to
be up to date same goes for the other
ones so you can have response fields go
request HTTP response all these snippets
are getting injected so once we've got
this template we inject these the
snippets inside we can just compile this
into HTML which acts key doctor is doing
for us so this asciidoctor is like a
plug-in in maven or in cradle which just
takes this as part of the bill flow and
will just generate these HTML so here
you can see it for note it's an example
where you have these self
no it's tags this table which we had an
ASCII dog before and the same for for
the other tables and the coral snippet
and then this response snippet so that's
how it's really eventually looking okay
so that's the HTML that you want to give
to your clients
okay so aside from this standard flow
which is the basic functionality there
are also some extra features that that
are provided so one of the features is
that it's really easy to package the
documentation in your products delivery
so this can be a jar file your buffer
file your file whatever and you can
really easily configure it that your
these html's are packaged inside so that
when you deploy it you also deploy aside
from your API also the documentation D
htmls then there's also the possibility
to do other snippets than the one we
talked about
you've got the hypermedia links so that
one that we store already the request
and response payloads as well but you
can also document request parameters
both parameters and HTTP headers also in
a similar way with kind of tables so
aside from this is also possible to
customize the request and response
before you actually go into document
document it that sometimes required when
you for example want to pretty print
your your response body or your request
body before you're going to document
because that's easier to read or when
you see for example some headers that
you don't care about in your
implementation or in your documentation
I mean and you just want to strip them
off so that's also possible to do it's
really easy with a fluent API then it's
also easy to add extra information to
the snippets so now we've saw for
example but fields we saw the path of
the fields inside the response body we
also had dynamically added the type
which it can deduct and then we also
have description which was the third
column but what about for example
constraints if a certain fields can only
have between four and twenty characters
we'd like to mention that as well so
that we can do as well by just using
this extra information that we also put
as part of that integration test
documentation part ok that's also with a
fluent API so that's really easy to do
we can also ignore parts so let's say
something is coming back in the request
or in the response something is coming
back in response body and we don't care
about a certain fields or we don't care
about a header or something that's
coming back we can't really ignore these
parts so it doesn't fail the built that
way normally if you don't have something
documented and it's actually coming back
in the response body let's say then it
will feel the built but when you ignore
them it won't fail the build it's pretty
straightforward and on the our way
around you can also you can also mark
parts
as optional so that it's it's just the
other way around where you have
something coming back or you have
something in the documentation and you
don't have it coming back
always so maybe something which is only
in a specific flow available then you
can say okay I'm not gonna crash my
built when when this is not coming back
in in all the other cases so we also
support while this library supports
Jason and also XML so if you have
responsibilities or requests bodies in
XML it's also supported and there's
support upcoming for rest is shirt which
is this is really nice
because not specifically about the rest
assure to while it's a nice tool and
it's nice to have it integrated it will
D couple spring rest Doc's from from
from spring McCann BC so you can use it
without it really and that's that's
really nice right so that's coming up
probably in the next minor release I
would say and there's one more feature
which is it's not really a feature of
the library itself but you can use it
for that you can actually use these
snippets this request and response
snippets for stubbing purposes and so
you can just for example have a wire
mock server where you use these requests
and responses as disturbing information
so if somebody is calling with the same
request then you can just return that
snippet that response snippet and they
just see this as as a stub of a real API
but the real part of the real nice part
of this is that's always up to date just
like it is for the documentation always
up to date these snippets are generated
and whenever you make a change to your
API you're going to have to change this
documentation as well or your bill
doesn't work and therefore those
snippets will be changed and as well of
course the setting solution okay so
that's pretty nice
okay so those are the features now I
have a really short demo to show you the
way this disc and this accuracy this
this this certainty of having accurate
documentation actually works okay so let
me quickly can you guys see that No
hmm let me just mirror these displays
okay great
so you can see this right okay so is it
clear at the back as well good ah
perfect
okay so we've got this car right it's in
the spring boots application by the way
really nice tool so we got a car which
has an ID and a brand this is most
simple budget you probably ever saw so
this car gets exposed in the API through
the color controller which is just doing
a request mapping in cars usage Jason
actually uses howl Jason and it's it's
exposing cars /id but also just cars by
the default mapping and there you can
see that the car is being retrieved
always but the idea that you asked for
it's really stupid but at least it will
show the idea so it will also have a
soft brow this is the link the
hypermedia part and for the cars it has
also embedded I'll show you once we
actually have it running okay so that's
that's basically the application as its
spring boot I can just run it by
right-clicking the application run as
spring boot app okay so it started on
port 8080 I can check my okay so I can
go to the cars slash cars and I get this
back and it's not really nicely shown
boom boom boom yeah okay but I suppose
can you see it there's okay so there's
links then you've got self row which is
this part just the course itself and
then embed it you've got a car list with
one car here that's one car and then
links inside that car as well because
that's the self roll itself for that
core which is embedded so I can just
follow this this link to that first car
here okay so this is what this hyper
media
strain is all about I don't need to know
the the UI of the first car specifically
I'm just going to follow the south route
of that first car which is in this array
so I'm going to go to to this okay and
now you can see I have a brand which is
BMW and I get itself itself right back
so this is the resource which I'm going
to change okay so mm-hmm
let's see how we write our documentation
for this okay so we've got this
integration test here which is just a
lot of configuration up front and then
we've got this test which just does
should get car there we do to perform
with more can be G a little bit like we
saw that example in the slides we just
call Garcia the first one we expect that
we have a two hundred and then we do
this extra documentation so we
documented in the folder get car we do
that's pretty print which is this
altering of the of the request before we
or the response before we document it
and then we will document some links how
links because we use the hell format and
the cell for all is actually the one
that we want documents we also have some
response fields which is the field
brands right you saw that here the brand
and then another fields called
underscore links okay so this is working
pretty straightforward if we execute
this then it should run as usual green
at suppose yes green perfect so now my
maven configuration has this asciidoctor
plugin configured so if I now run the
full builds the maven built for this
whole project then it should actually
start generating the snippets and then
also put it into this template yes first
let me show you the template so the
template looks like this I have a bunch
of top-level stuff then these these
anchors have some more information about
the API in general that you want to
document manually for example which
first drops you can use which status
codes that are possible then what is the
hypermedia
format or the constraints all about
because clients might not notice and
then we actually get to the
to the resource part so for the car we
just say the car resources used to show
cars available and system and we have a
get part where we retrieve the car and
little description and then we have all
these snippets okay the response fields
the response itself and then links okay
so if I run this as a maven install
there we go then as you can see it's
going to do the tests once it doesn't
done the test it will actually start
packaging it and then it does the
process asciidoc the tasks which will do
this asciidoc merging ok so let's take a
look at what this is generated so here
we've got in the target folder a couple
of directories we've got two generated
snippets and the car cats we've got the
coral request we've got the HP request
got the HP response we've got the links
and the response fields this is just
like in slides they should just
generated out of this couple of lines
that we added to our integration test so
then we need to merge this these
snippets with our templates that we
wrote and from there we actually get
this here so let me open this in the
browser okay all right so this is what
we got this is all generated okay and
you can see here that the car resource
has these snippets injected this is all
because of those couple of lines that we
added to the integration test now let's
take a look at what happens when we
change the production code okay so we
can easily do that by just in the car
adding a field that would already
invalidate our documentation so let's
add a field called type okay get type
set type okay simple um so then also in
the controller let's add some
information about this type gortat set
type and then the
type BMW type 320d that want to hear it
okay great so let's just run this test
first okay because the test should
already be feeling okay it's failing
let's take a look what it says it says
the following parts of the payload were
not document type to read 320d okay so
that just tells you that you forgot the
document a certain field
okay so let's document that in the test
we just use here type and we actually
call it the type of this car okay
so let's see if our test is running and
yes it's running so that's now do the
maven install again to also get that
process ask a doctor done and yep here
it is
okay that's yeah it's really nicely so
let's refresh
there it is okay so the type is now
documented so your bills works and in
documentation is up to date so now let's
do it the other way around that let's
say we remove something from the car
again so this is pretty straightforward
we remove it again here we of course
change our controller as well so here
let's continue now to load test again
okay it's failing again and now the
other message is filled with the
following path we're not found in the
payload the type it's not found with the
actual no can be see response okay so
that's easy to fix
again by just changing this and of
course it's just rewinding and it's
going to work again okay so that's
basically the gist of it there are also
like headers that we can document and
these path variables and these request
parameters all that stuff and actually
actually if you want to see more samples
there are some some projects which are
in the github repository which give you
this all the possibilities that
that'sactually can do so if you just
check here again okay it's back to the
old one okay so I think that's
for me I hope this inspired you to give
this this tool a chance it's a really
nice approach I believe but it's still
also evolving while it's already mature
enough for us and proximity for example
we use this all over the place and it's
really giving us a great value so
definitely check out the project's page
and to get a page and if you like some
some features added to this and the
Pelican is really a great guy even if
you do blow requests he is giving great
good reviews so definitely vs. shot okay
so if there are any questions yes the
localization hmmm that's a good question
I think there is a possibility to do
this although I'm not entirely sure I'll
get back to you on that but I'm not sure
I know that for for example constraints
you can add more constraint information
for that you can have property files
where you can have one for each language
of course so that's possible but for
those those fields and in the
integration test itself I'd really have
to check that but I suppose if it's not
there
we can definitely it can definitely be a
good suggestion for an extra feature and
I don't suppose this is too hard to
implement if it's not there and okay but
I'll definitely let you know on Twitter
any more questions
yes is it
rath stock is just the documentation so
it doesn't allow you to do tests against
it unless you used as a stubbing
solution and then you can probably just
I mean if you combine it with by amok
you can in call it but there's no
there's also a new feature to generate
your code from from your from swagger
you can generate the clients right
that's that's not there which is not a
design of it but if you combine a wire
mock then you can test against it so
that's easy right I hope that answer
your questions okay all right that's my
time
thanks everyone for for coming over</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>