<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Post Apocalyptic sun misc Unsafe World | Coder Coacher - Coaching Coders</title><meta content="A Post Apocalyptic sun misc Unsafe World - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A Post Apocalyptic sun misc Unsafe World</b></h2><h5 class="post__date">2017-04-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_bVcHCt-J6Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay I guess we can all come a bit
further to the front right okay
post-apocalyptic some miss gun safe
world first question what do you guys
expect from something after something's
gun safe do you think the future will be
bright okay I see one saying yes I think
the picture is kind of nice
who can say what that is by the way you
guys know Tower Bridge perfect and does
it like Oh does it look like a very bad
future well probably not right it's kind
of a weird future maybe but we're
looking into the proposal of what is
going on when some is gonna save will go
away right we have to somehow exchange a
lot of things and yes I think if the
future is bright the future might be
nice so here's my disclaimer I'm not
going for a safe harbor statement I'm
just saying this talk is not going to be
negative except for the first section
maybe but still don't believe anything
I'm saying right you know all know this
whatever we use somebody says as a
conference various like no truth at all
and that okay so who I am
Christopher Albert come from Germany
working for hazel caste who knows hazy
cast perfect at least somebody I'm
actually working with the community
speaking at conferences working with
customers pretty much doing everything
like the jack-of-all-trades right the
guy that leads my community and does all
that stuff I'm working with Java for I
think by now it's like 13 or 14 years I
just stopped counting at some point as
like 10 plus whatever it is ten plus
most of my time in those weird sections
that most Java developers try to not
engage with garbage collection issues
performance optimization Network
protocols my personal favorite is still
benchmark fairy tales right who know who
believes that benchmarks are real who
believes but Nvidia is faster than AMD
or aim DS faster
in video right nobody the only
benchmarks you can trust in are the ones
you do for yourself with your own use
cases okay so back to the topic son miss
gun safe what is some is can safe oh
well I googled a little bit it's not
like I know that stuff right so I had to
google it and I just have some words
which popped up quite often there is
something which is platform-specific
dangerous discourage performance low
level pointers pointers okay own and
unsafe obviously right whenever you
search for unsafe that is probably the
most common word to find okay so but
what does that actually mean well if we
could change my name today to something
more useful we would probably call some
misc scissors right running with
scissors isn't is essentially dangerous
we all know that we learned that as kids
if you recall something unsafe it just
encourages you to do that so we're going
to play a couple of little games and I
try to find movie quotes that actually
fit the next section and you guys tell
me what it is so a lot of the Rings
very good so my precious son mace gun
safe
what did actually have well what is some
is can save well first of all and I
think everybody knows that it's an
internal class from the JDK it is
certainly not supposed to be outside it
to be used outside of the JDK and they
had a good call even what is it 1998
that's the oldest thing I could find so
we keep telling us for a while that
we're not supposed to use anything in
Sun Sun dot or comes on dot right did we
care no not really
right there are a good couple there are
a couple of use cases and by the way you
guys know the Wayback Machine right
awesome technology what would we do
without it so but there are a couple of
use cases and good use cases why people
actually use some
and who was in the earlier sessions from
Paul Sanders and John Rose except you
nobody okay you should have done that it
was it was awesome so a couple of very
good use case and I think one of the
most common ones is GC overhead we're
trying to solve GC issues so that means
we're storing information off of the
heap or updating things in a different
way not to fiddle with a garbage
collector a couple of people want to
have 64-bit memory allocation me for
example I don't believe that 32-bit is
still a thing it was probably not a
thing when the byte buffer API came up
efficient memory layout
I don't get object-- headers I don't get
all this this byte padding if except I
really want it which means I also get
some some very efficient and and concise
object bio-data layout right that is
something which is try to solve with
some of the proposals that John Rose
showed earlier for example fast memory
access fast desire ization most probably
the most common use case even though you
don't know it because most of these
serialization frameworks use some miss
can save internally and then you have
those weird things like custom memory
fences and arrays array volatile
semantics you know what I'm what every
volatile semantics means right what
happens if you mark an array as volatile
and Java what is what is actually a word
right the pointer to the area small at
all it doesn't mean that the array
elements actually have any volatile
semantics and that is something which
from my perspective is missing in the
language for a long time so you can use
some is kind safe to do that actually
and give this volatile semantics to an
array element which officially doesn't
exist in the language so I found a
little bit of code and I don't know who
ever looked into the fork/join pool this
is very common code with if do you see
something that duck Lee wrote
it looks very C++ ish short short
variable names the shorter the better I
wonder that it is not just ABCD but it
works pretty well and he uses a lot of
some nice gun safe in the old versions
it will change with Java 9 though very
interesting but do you see it looks kind
of weird right so he's asking for an
object field offset and an array base
offset and a couple of weird things
normally don't want to interact with in
the java language so next one titanic
perfect
alright so use cases outside of the JDK
and I have to thank Mark Reynolds for
this amazing finding it's still my
absolute favorite so what do we want to
do here well we all or let's say star
here we want to allocate an object we
use allocate instance which creates an
instance of of a class without actually
running any console any initialization
so that's nice and I'm coming from from
Ubisoft I worked at Ubisoft before join
haze' cast so player that is certainly
something would gain so that is
something I'm familiar with and then he
says well ok so I created this object
but how do I actually delete it right
we're having this C++ semantic or see
them semantic when we allocate something
we have to free it so how do you get the
pointer to the object to actually free
the memory afterwards and that was his
idea
does that work no what is what what is
the hash code is it the pointer to the
memory location of the object no it's
not right and we all know this thing can
be negative very very interesting use
case what actually happens is so you get
something like that add some very very
nice missing the name sackful right
thank you sec fault i just choose a
different method because i wanted it to
make a wanted it to be consistent so i
use set native address and i just
try to write in zero so I basically
created a null pointer in the JVM yep
and you see mark posted it
he used it I think 2015 for the Java
language jvm language summit and posted
it on Twitter and it's like awesome
fining never seen anything awesome like
that so next one
any idea Mary Poppins and I can't even
say it in I can't say it in English and
I can't say it in German
don't worry oh yeah
Mary province so I'll look their bid or
around and we try to find out what
frameworks used some is gun safe and I'm
not the only one there were a couple of
people trying to do that and I just
listed a few of them maybe like 50% of
what what I could find but be more
common one so who's using the spring
framework who's using hibernate right
let's see what else what else
umm disruptor well probably not
nettie well okay oh whatever
it's better anyone who doesn't find any
framework you're using on the slide oh
my personal favorite ones are like where
is it easy mark where the other map
frameworks I can't find them but they
are pretty much all mocking frameworks
and the list you guys use mocking
frameworks in your tests perfect very
good I like this answer so and obviously
there are just a few big ones right and
there is the biggest one we are
obviously losing it as well for multiple
use cases so for example we have this
very nice use case and this is our
unsafe util this is where we hide or we
would collect all the amazing unsafe
magic we we use in hazy cast and I just
searched for the source code like how
often does we actually use this thing it
was like 78
use cases or 78 classes well probably
not a good thing but I'm proud of it so
what do we do well I already set 64-bit
memory allocation we we are a cache
first and foremost we store huge amounts
of data so 32-bit is not an option for
us we want to store 32-bit well we can
go with a fruity two-bit JVM why would I
care otherwise right fast memory access
GC overhead minimization I think as I
said this is like the most common thing
where all people use it and these
civilization Lloyd I also mentioned for
first teaser ization most mostly in the
case that we use this allocate instance
to create an object an object instance
without actually running any
initialization and then just restoring
the the the objects content from the
byte stream because we override it
anyway so why should we actually run any
constructor right okay that's a hard one
pretty old no idea The Wizard of Oz very
good movie not the remake the original
one so here's here's the thing and I
hear this all the time people will keep
telling me son Mis gun safe is hots box
Pacific white we were talking about
platform-specific spangs
and it just works on hotspot so why
should I care anyways right it's not
portable well unfortunately it kind of
is these are all JVM implementations
including weird ones like JavaScript C
microkernel don't ask there are weird
things oh and there's my my personal
favorite where is it there you go
i KVM you know what that is i KVM net
it's a JVM implementation in for the.net
language for interoperability between
c-sharp and Java very cool stuff and
even that one has some it's gun safe
because everybody uses it anyway so you
can't run a single framework with all
some it's gun safe right so here's that
is that is certainly a problem which
means people actually have to support it
in their JVM implementation
and as you see the green ones are
obviously these supporters and the red
ones are like Anna know funny enough B
JavaScript implementation doesn't
support it because it runs in a browser
right okay that is easy that is very
easy Toy Story right so where did all
this start or when B when it did it
became a thing there was this amazingly
nice email from Donald Smith a general
very nice guy but I think he had a very
bad day at this when you broke this
email so let's let's go for it and find
like the important bits so he said some
misconceived must die in a fire ignore
any kind of theoretical rope right and
kill unsafe kill unsafe dad kill unsafe
right I love that it's really cool and I
read it over and over again at this
feeling like did Oracle create like a
new task force because now everybody was
like unsafe is like the worst thing ever
and that was what came to my mind right
like could kill unsafe tol death but
we're honest here right I mean I'm I'm
on the on the side of the defenders of
removing unsafe but I think the
important bit is we can't just remove it
right now right we need to have some
replacements in place that we can
actually is because big use cases are
valid so what do you I read this email
again and what he says is this is the
year to explain where the API is broken
to get it straight and I think well fair
enough a lot of love for single sentence
that makes sense to me
and that is where all this started so we
created a working group with people in
the Java community that are actually
pretty active and strong users of some
miss Gunn save a lot of them are
actually in the JCP Executive Committee
if you guys are familiar with the Java
community process so you see there's as
all systems haze' cast regularity not 5
into halter for the people that use pipe
buddy he's the guy behind it a lot of a
lot of people and what we
we created those lists and try to figure
out which framework actually or which
library uses which features how should
they be resolved our features in some is
gun safe completely useless to the
community because there are a couple of
things that really don't make sense so
we created this document and I think
overall there were like a hundred fifty
committers not all of them are named not
all of them added their name to this and
this is a very very interesting document
because it lists like all the use cases
and how what what is actually necessary
in some is gun safe to be available it's
probably not still not complete even
after a year and a half or something but
I think it's a very very good reference
so what happened is that after a lot of
well I could say probably bullshitting
like raising a voice or two in the end
Oracle's or Mark Reynolds said okay we
understand there is a problem and we see
we can't just remove it and what it
would he said in an anecdote is we
actually set that but that was never the
plan and it was probably right so they
created this this is text and that says
how some is gonna save some miscount
safe features are going to go away and
what it says is well if we have a
suitable replacement for feature we're
going to deprecated it in that version
of Java and then we remove it in the
next version so var handles are coming
in Java nine so var handles are a nice
replacement for a couple of features so
we deprecated those features and some is
gun safe and we're going to remove them
in Java ten that actually gives
everybody about a version of Java
version time which is two years where
we're not measuring six to seven let's
say two years to actually re-implement
or build some fallback hopefully not
fallback mechanism for the new versions
of Java and use many features in your
own libraries so that works for me and I
think this is actually a very valid way
of solving the issues Oh a step by step
right it will only remove features that
are already available and there's a good
reason for that because you just don't
remove it it's not possible or do you
want to have no application running
anymore probably not right so what is
what is the movie Jurassic Park I think
last time somebody said Jurassic Park I
don't know why no it's x-men very sure
oh you be mutation maybe maybe that's
the reason why all the very things okay
bad better example bad quote okay so
mutation right mutation means change so
we need to change our application first
of all let's get to the problem so how
do we get some misconceive axis well the
easy one you are part of the JDK or jury
system and there is just a very very
simple thing you say unsafe get unsafe
that's about it you don't have to do
anything else
there is interestingly a security check
that makes sure you can only do that if
you are in the bootstrap class loader so
all the other ones are doing something
like that you actually ask the unsafe
class for the unsafe field you use this
in famous set accessible some not all of
you guys were at Paul Santos session
this morning he wants to get set
accessible going away for various
reasons because you can do pretty weird
stuff with it
right we can just hook any anything in
there and then you get the unsafe
instance well and depending on if you
have a fallback or not well if there's
no unsafe access you just go away right
okay so that is the ugly one it just
gets uglier because the the some JVMs
don't call it the unsafe the biggest
version of it is android so in the
Android system it is called v1 because
there's only one Highlander right it's
like a single one so what you try is
well most of the time like 90% of the
time the unsafe works so we try that
first
if that doesn't work you just walk for
all the fields and try to cast them too
unsafe and if you find something well
you're a good girl right then you just
return that very very ugly use case well
but it it works on like a 99.9% of all
the JVMs
at least if they have something like
unsafe so the tricky one is actually my
favorite child snatcher the JRuby guy he
said well I don't care for Singleton's
because Singleton's are not existing in
the java language so I just create my
own instance of unsafe what actually
works pretty well so you just break the
singleton idea and create your instance
for your use case I'm not sure if I were
to do that but well right because we set
single ins single ins are not available
in the JVM at least not at the current
point we'll probably get them at some
some stage so the problem is does any of
that feel right no it doesn't and that
is a real picture that was our first
office not not that it's not the office
but it's the restroom of the office but
it is the at the first office there were
two things two toilets one lockable door
don't ask me why it's probably parallel
computing or something I don't know but
no it really does not feel right and
that is the German fire department we
don't have the smartest guys as you see
it probably works is if the Train is
fast enough so what is the solution well
we don't need an e because we get public
API we don't need all this crappy stuff
anymore so that sounds right that sounds
good to me and has you figured out I'm
from Germany so you all know Germans
like nudism right so that that actually
works pretty well not anymore but in the
past we did so problem too
you guys weren't at the session from
from John Rose as well so atomic updates
you know how that works right we
increment some so increment works the
way we store the old version we
increment it into an
field incremented by one and then we say
compare and swap comparing swap means
you give it the old value to give it new
value and atomically it will test if the
old value is still true if yes it will
atomically exchange it otherwise you
have to retry so that's where the while
loop comes from what we do in this case
is we use unsafe so we have our magic
trick over here and we have this version
offset and you remember this this offset
like object field offset kind of thing
and from the from the Dudley example
that is what this offset means this
offset is a number of bytes into the
object from the start of the object like
10 bytes into it there is my field
sounds pretty c++ ish right yeah and it
probably is so can we do better yes we
can we have atomic long that is what
hides all this magic from us there is
just a bad problem we get one instance
per version field in terms of hazel cows
that means we have records because we
store information and we store creation
time we store a number of hits we store
this we store that and I think we have
overall like 10 different properties we
store for every single record so instead
of just storing one element or two we
actually store at least twelve doesn't
sound right right hmm maybe not so can
we do even better yes we can we have the
amazing atomic long field updater and
that does some extreme constant magic
you give it the the type of the oh it
should be actually record of class I
guess you give it a type of the the
element you're looking for and the name
of the field please make sure that you
tell your colleagues
hey this is updated there is actually a
write operation on that because every
IDE will tell you oh this field is never
written it is never updated because they
feel updater does it with unsafe magic
itself it just hides all this unsafe
stuff on tip from you so tell your
colleagues hey this is not an unused
field place don't remove it
right and then you just do increment and
get which is the same thing so we're
still have all this unsafe magic but it
hides us from us and the good thing is
this is a static file so I just need to
create one for all of my records so
instead of creating ten error elements
per record I just create one and can
abuse pad for all so that IEP is fairly
ok let's say that way it's still not my
favorite but I would say this is already
like a good way to solve the issue but
we can do better so there you go so the
solution is actually var handles and var
handles give you the option to do this
on fields as well but without using all
this weird magic so what it how it works
is you create a field handle so that is
at the moment the API and just this
morning we heard they're looking into
options to make this like more usable so
at the moment it looks pretty much like
the idea of the atomic field updater
right how we give it the class name we
give it the field and we actually have
to give it the type of the field as well
because it generates some magic
underneath so what what probably comes
in the future is this colon colon
version just as we use method handles we
can use var handles or we can create
very notes and that would be awesome
because in this situation that looks
like pure Java code and the way we want
it to be so we just create one one
static bar handle and we're pretty much
at the same point where we were with the
atomic field updater the only thing is
bar handles are more useful or more
generic and not only for this single use
case so we see this second thing while
the third problem and that is memory
management so now we're storing data off
heap we're allocating eight bytes and we
put in a long eight bytes right and
exactly one thing and for allocation we
get back an address that is a native
address a pointer in the way we use it
in C++ and we just write it to this
address and we say okay please read the
value obviously that will return long
Val max value
pretty pretty simple but it stores it
outside of the Java heap and that is an
interesting thing so we can do this in
Java today with 32 32-bit api's we can
tell the byte buffer please create me a
direct byte buffer which will do this
unsafe allocate memory underneath it
will create a it will allocate 8 bytes
and I can write to it on position 0
because they don't I don't know about
the pointer so now I have this offset
kind of thing and my offset obviously is
0 and I can get the element the problem
is all of that so this 0 this offset
here is 32-bit so I can never get any
byte buffer bigger than 2 gigabytes
roughly it's 1.9 something right
something like that so here coming so
and here is where the var handles coming
back so we can say I created by buffer
and please use the byte buffer with a
var handle view so create a view on top
of this byte buffer that actually looks
like a long array but story underneath
as single bytes so I don't need to do
this this transition magic it is all
handled for me and I can say ok place on
the on the view please set in the byte
buffer the first element in this case we
have an this is so this is the index
right we have a view that looks like an
array so that is the first element
inside of the array for 8 bytes of his
views just one element and we set the
same value okay second use case for var
handles we see there are more generic
and more useful than just one use case
but we're still stuck with the byte
buffer API so we're still stuck with 32
bits so and here comes the interesting
thing and that is my absolute personal
favorite going forward so we have
something we call scope as we all know
scopes from the programming language
right between the curly brackets we have
scopes where variables exist and when
they get the allocated or finalized
whatever you want to call it and the the
scope for this is pretty much the same
thing so we have this native scope which
okay whatever you do with this scope
please a located outside of the Java
heat which is again off heap okay then
we say oh there's another error it
should be a long area again a long I
ordered class so we create a layout and
the layout says okay you remember this
view and that is pretty much the same
thing it says please create a layout
that looks like a long array and
allocated with the number of elements in
this scope the interesting thing is the
scope is in a try with resource block so
that means whenever I leave this try
with resource box
all everything in the scope will be
automatically D allocated because it's
now two closable very interesting thing
especially if you have those very narrow
interoperability down to two C++ code or
two C code so you just need to pass some
information to C or get some back so we
allocated in Java past the point pointer
down to the C++ code and you get the
result back the interesting thing is
here is actually a pointer class and
there is a reference class and we have a
pointer we have an offset and we have to
dereference the pointer who remembers
this gold c++ times that looks extremely
familiar and this is where my my
favorite joke comes in right now because
inside of bounded pointer there is a
static final pointer which is called
null and that actually is position zero
so we actually have the first time a
chance to get a real null pointer in
Java we actually get a real not pointer
that is where everyone in Java work
waited so long for with a null pointer
exception which is completely wrong it's
not a null pointer so Serta's asian and
we are like what is it 30 minutes okay
civilization I already set that right we
we do we create a new instance with
allocate instance in this in this
situation we create a string and since
we D Sur lies the content of the string
from the byte stream we don't need to
run the constructor it doesn't make
sense and in this case we actually want
to do something weirder because we solve
second issue and don't do that at home
place don't do that at home
so string has a constructor where you
can pass in a char area so we do Sarai's
the char is somehow magically from a
string and we could call this
constructor the only problem is Java
doesn't have immutable up immutable
arrays which means they create a
defensive copy because the string has to
look immutable right so they can't they
just don't trust the char I pass it
sorry they don't just trust the char
area I pass in they actually create a
copy of that and that is the second
thing what you really want to try to
prevent first for four strings so what I
say is I create an instance I don't care
for the constructor and then I just
change the value of the charterer
afterwards so I pass in my char because
I know when I remove when I return from
this method I don't use this chart
anymore so it is inherently immutable at
least from the use case of a string but
as I said don't do that at home that is
very hacky ow
and we don't do that in hazel cast as
well but for all the other classes where
you don't have like this defensive
copies that makes perfect sense
all right and it will break with Java 9
because we get compressed strings so
there's no biochar anymore there's a
bite area I think right yeah binary ok
so you'd have would have to do some some
weird magic anyways to encode in the
right way and you again just don't do it
so how does that or how's that supposed
to be solved and you kind of can do this
right now so you see the underneath the
code there is sun reflect reflection
factory so the way it works is you get
the reflection factory and you say
please create new constructor for
civilization and that is very a very
weird thing because that can spin a
constructor at runtime that actually
doesn't exist that is what Java
civilization uses internally so instead
of using this allocate instance I now
use this magically appear in constructor
wherever it comes from and that will
most most most probably and I think it's
already moved so it is a it is going to
be in Java 9 it will move to the
official
if we are if we use allocate instance
that is the way to go in the future and
this objects is I think it it's of gems
evade the library that can create
instances in different ways that is one
of their strategies already so it is
used outside of the JVM already even
with the Sun roof Sun reflect reflection
Factory so well I'm not sure if that
solves all the problems but it will
solve most of them at least what I
really don't understand how this
constructor is created I never looked
into the C++ code it does look a lot of
weird things it does some matching with
the parameters I pass in trying to match
them to the fields don't ask me I
probably don't want to know it works for
Java civilization so it probably works
for me the biggest problem that is going
to be solved from my perspective in the
future of Java is native
interoperability and who did see Jane I
code in the past ok did you like it
no no anyone anyone's saying yes Jane is
awesome you liked it 15 years ago go out
so the way it works is the first part is
beheader
right we have to define it then we have
the the implementation or C class very
simple we just want to get the process
idea right it's it's not a lot of stuff
and then we have to do this weird Java
binding John just said it the other way
around you have to do a Java code and
then a C binding I say you have to do C
code and then Java binding because I
have to tell the JVM how to use this
library not very nice not very efficient
I have a better example with a bit more
complicated kernel call and that is
about that size of code together with
Java and and and C really not so if we
talk about efficient programming Java
that is not Java
and is most specifically not efficient
because nobody wants to deal with that
this is something that should be done
automatically and Jane are a Jane are
the Java native runtime we're coming
back to to Charles Nutter the JRuby guy
can do this right now
so we create a la interface and we say
hey we have a cold which is called get
PID that is what the name in the kernel
is and we say okay please create me an
instance of this interface and bind it
to the c standard c library fair enough
i can call that and it will spin all
this magic jane i whatever code
underneath and i can just use it the
same way i would use it in our kind of
same way i would use any kind of java
method the interesting thing is the the
code that is actually produced here
under the hood is faster than most of
the Jane Aiko code you can find because
they do a lot of weird tricks in in
terms of type conversion but we want to
solve the issue in a better way right
inside of the JVM so what we do is we
create a method type so who worked with
method handles so far okay so the rest
doesn't know what method handles our
imagined method handled as a better
version of the reflect method API to the
JVM it looks the same way as you would
actually call this method in bytecode
and it would be integrated or compiled
into your bytecode the JVM can do all
the nice inlining stuff you normally get
everything that far with that reflection
doesn't have that's I think it's the
easy explenation how to how that works
so the way it is we create a method type
and we say oh okay we have a return type
of int and we have no parameters that's
why there's just one parameter in there
method type and we say okay please find
me a method handle which is native we
pass in null because it's a kernel call
we don't have a library name in this
case the method name is called get PID
and it has my method type as the
signature of the method and then I can
just call it
and we have this in the session before
you actually have to cast it just though
because the way how pull a signature
polymorphic methods work you don't have
to understand how that works but it is
kind of kind of nice and easy to do that
and there is most probably something
coming up that looks closer to Vijay now
where you just write an interface and it
will spin all this magic around it if
it's not coming in the JVM believe me
anyone will actually do this for you
because this interface idea is just
great and it will in line just perfectly
and there are a couple of other things
you can do but the way this is actually
created internally right next thing
immutable types who thinks Java needs
immutable types okay
Oh at least free people the rest doesn't
think so
you don't like immutability you're not
working with scalable or concurrent
systems right okay so we're coming back
to this defensive copies bang and that
is something from hazel cast code and it
says well more defensive copying in case
of binary format I think there is like
70 positions where we do the defensive
copies in Java in Hazel cast internally
just to make sure that these are get the
expected result and doesn't do any kind
of weird stuff right
the most common use case for defensive
copy and is that is something like
almost nobody knows who used in Amjad
values at some point in his life did you
ever realize that it creates a new array
all the time right they have to because
if they return the array you can
actually change it so they have to
create a defensive copy so if you use if
you have in your in your inium class
something like I'm looking for all the
values to find something based on a name
or on an idea or something please please
make your own public private static
final and store the values once stole
this error array because it is a huge
benefit in terms of garbage collection
and
you just figured that out when it shows
up in the profiler for the first time we
like what the is going on right so
defensive copying is is a pretty bad
idea I would say pretty shitty maybe so
value types who heard about value types
so far okay that is actually pretty good
so you guys know what value types are
there are what what is a nice sentence
it coats like a class it works like an
int or perform behaves like an int so
the idea is you can do something that
looks probably close to a struct in C so
you can create something which is
basically a primitive value it is
something like an indoor long in Java
and you could create it yourself so the
API is not what it will be in the future
at the moment its underscore underscore
by value class I stay with value class
because I think that is better to
understand and I say I create a point
and this point has two integers and I
think you don't even have to map them
final anymore because they are
inherently final it's a value class and
it doesn't get any constructor but you
have something like a factory method so
the the layout of the point value class
actually defines how I have to construct
it so that means one if they make value
one will always go into X and two will
always go into AB and into Y fairly very
simple very nice use case especially if
I put this so the way it looks like it
will kind of look like an int array that
is normally how I define it it will not
have the header of the Aerie but the
elements are straight after another
there is no magic going on it's
basically just an area of your elements
and the good thing is it will be
allocated on the stack stack allocation
for the win I think that is one of the
most common features that Java
developers especially in the
high-frequency trade area wants to have
because you don't want to allocate those
things on the heap and it gets a bit
more it's not on here it gets a bit
better so if you have actually an error
point it will not have this reference
you understand right if you have an area
of a class you actually have an area of
the references pointing to other
locations in the heap where you're
actually elements are if you have an an
area of point and the point is a value
class it will just store all the values
right after another because there there
is no object so I don't have a reference
to this object which is very nice
especially if you have things like
linear scan or some addition or whatever
right some some some multiplications
some operations those kinds of things or
average calculation generics my most
probably personal favorite
so generics and primitives
who thinks that is something we
definitely need and I think that is
something that every Java developers
would love to see the problem is so what
we do here is we pass in along a
primitive long but what actually happens
is P JVM has two outer box it because we
can only work on the object types right
I personal feeling or my personal hope
is that we value that the wrapper types
will actually become value types in the
future I'm not sure if that is actually
on the planet but I hope so that would
be nice but what we actually want is we
want a map of a lower case int a lower
case long so primitive long and string
something that is not possible right so
we want some so here is here is some
current proposal and I think I have like
12 minutes left or something so this
looks pretty similar to the current
generic classes we do there's only one
big difference and this is this any key
word any means
okay now I'm not bound to objects
anymore or to six minutes I'm not bound
to object classes anymore but I actually
can put in primitives as well so any
okay what they actually call it a
specialized generics and when you
specialize something it is a species so
the way you can imagine is it is as they
would spin individual classes forever
every type I actually use on this box
kind of type so I can create a box of
int it will look like a box and there's
some magic class that this that appears
in the JVM because I use this type int
and the interesting thing is it will
reach Ange this with int and the return
type will actually be int as well it
will not use integer anymore so this is
literally like a template very
interesting thing for object types it
will still be compatible to the normal
box object kind of thing just the way we
have your in generics for the primitive
classes I think they gave up on that
idea they tried a couple of a while I
think they gave up because it from my
perspective it doesn't make sense it
doesn't make sense to make this
compatible this box of object so what
you can actually do is this code and it
will not do any boxing anymore so we
have to speed up a bit a little bit
there is a bit more and I'm just going
quickly Aries 2.0 64-bit arrays very
nice 64-bit indexes so you are not bound
to two integer max value anymore you can
slice down Aries if you figure out there
too too big you can't size them up you
can only chunk them to chop them down
whoa why ever you can create generic
arrays did you ever try to do that you
know what the compiler says please don't
do that because arrays are inherently
not generic because the generic
information are erased at compile time
but what the new specialized generics
that will be a thing and there will
actually work the way we wanted
obviously also with primitive types
frozen Ares immutable air is finally
immutable Ares the best thing since
sliced bread cleaner API the new
finalizer api if you want to say it that
way for people that haven't figured it
out there is a nice discussion on the
mailing list going on about deprecating
finalized errs probably the second best
thing since sliced bread these slides
are online so I'm not going too deep you
pretty much
the same thing as with with the scope
you can create your own other closable
scopes and kind of thing in this case
the clean IP I will make sure that your
the objects are actually D allocated or
cleaned whatever you want to call it
class dynamic implements some kind of an
aspect type thing class dynamic is kind
of a weird thing so you can say okay for
every method in something please apply
this template synchronize all the
synchronized collection thing wrappers
are pretty click clear you have the
original call you synchronize on this
and then you call the underlying method
pretty simple common use case log
logging aspect something like that right
plenty of stuff more don't forget the
use magics are builds they're not early
access anymore their release cannulate
it's a rescan you know already I don't
know maybe but but please try
application with jela 9 because you
might get some issues still and the last
one and that should everyone no come on
what is it first come welcome very nice
so for people that are interested in the
egg proposals and want to dig deeper
into it there is a couple of things
there are a couple of more just for you
to have your afternoons wasted like I
did mine and in general as I said any
question I think I have from one minute
or something left ok
no question alright thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>