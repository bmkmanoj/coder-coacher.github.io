<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Invocation Game by John Rose and Paul Sandoz | Coder Coacher - Coaching Coders</title><meta content="The Invocation Game by John Rose and Paul Sandoz - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Invocation Game by John Rose and Paul Sandoz</b></h2><h5 class="post__date">2017-04-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gkWSrdSEL4o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay we just come from the keynote
people still flowing in I wondering if I
should way to just start now because I
guess we're a 10 minutes running or 10
minutes late anyway okay let's just
start had people roll in that's good so
thanks for attending this this is going
to be something called the invocation
game play on the movie title we're not
as smart as the person that movie is
about so I'm Paul this is John it really
should be the resolution linking and
vocation gay but that is not as pithy
title and this is this talk is John is
going to get warmed up and get going for
his next tour where he really let's rip
on the VM so safe I have a statement so
this is I just want to explain what is
in the current stack in JDK 8 and 9
today and say how method handles are
where they are and how they're built up
and what depends on what a rough stack
so at the bottom here we have something
called method signature polymorphism
which I'll explain a call this that the
C of signature polymorphism it's the C
where all possible signatures can reside
and we we will we will explain what this
actually means with respect the two
things above that method handles and
file handles they have special methods
on them in method handles you'll see
something invoke exact and invoke and
you'll see on bar handles a bunch of
methods like get acquire compare and set
and they look a bit strange compared to
other methods out there in terms of if
you look at the source code the
annotations they have on and their final
natives and so forth like this so a
method handle is essentially a
dynamically type reference to a method
that's essentially it looks a bit like
java.lang reflect method but it's much
more powerful explain them do some
coding explain that and var handles are
essentially a dynamically type reference
to a variable where you can perform some
exotic form of access control on there
like we've added a bunch of new
to compare an exchange and so forth like
that but you can't do on the Atomics
that we have some motivations for adding
bar handles to the the set here was to
get very fast atomic access to stuff and
replace atomic filled up data classes
and so forth like that and replace
unsafe usage so you can use these
classes if you use them in a special way
to get as fast as unsafe access that
people using to do forms of access
control like a choir release type things
for lock free algorithms and a lot of
the we move up the stack on bar handles
some of the java.util concurrent code
like import join has been modified to
use bar handles and that is a good plus
in terms of yes you can trust this in
terms of performance because it dug leak
and trust this and build this for joinin
areas okay with performance and we're
all looking good so we need to do some
more work here what one issue we have is
a cyclic you'll refuse when we're
booting up the JDK and we need to
resolve and tease apart B so I can put
more stuff into Java util concurrent and
replace I'm safe so not only are we
suggesting others to replace something
we can be reading our own dog food and
trying to replace unsafe in our own code
because that makes it more correct and
more readable and more understandable
less risk for us for crashing the VM as
well but I expect going forward we're
probably going to use unsafe in a row
things the new stuff to to get the
performance we want to so it's not going
to be a sort of religious replace a
substitution replace with everything so
on top of method handles we have what
you might be familiar with is invoke
dynamic how many people are familiar
with this concept I see some people of
the CR so essentially I call it
pluggable linking essentially the VM
does not know how to link this call side
so it appeals to some Java code it says
how do i link it here's a method handle
you will call after linkage to actually
invoke this call side but that's
essentially it at the method handle
invocation the VAR handle invocation of
these signature polymorphic methods are
actually doing a very similar trick but
it's hard-coded essentially these
provide hard-coded bootstrap methods
that inde provides actually
mechanisms for people outside and us to
provide a more generic pluggable
mechanism on top of invoke dynamic we
have lambdas lambda Java C compiles
Landers and it uses invoke dynamic to
not bind to the implementation technique
to how these lambdas are actually
supposed out we we don't compile Java C
does not compile these things to
anonymous inner classes it uses invoke
dynamic with a bootstrap that generates
the code dynamically so it allows us to
to hide the implementation techniques so
we can optimize that later on and we've
done this same recently Alexei ship
lifted string concat
bead plus some non constant in there you
might find that now encoded in an indie
as well if you look at Java P output so
we can get we can actually optimize the
concatenation of strings much better
than Java C trying to do something and
potentially hotspot to in its intrinsic
some string optimization it allows us
potentially to remove a bunch of code
complex code in hotspot potential we
haven't done that yet but I think that's
something we could pursue in the future
and clean up that code then on the side
we have something called Dino link which
I don't know huge amount about that I
know it's used by Matterhorn and it's
essentially utilities on top for
building dynamic languages and that's
the module in the jdk and then we have
some future stuff I let John talk a
little bit about that ok thank you so we
we think we want to build more on top of
this framework it's it's been enjoyable
for us and we and it's allowed us to do
optimizations that we wouldn't
ordinarily have done before so there's a
there's a couple things that though that
we're thinking right now one is that we
can use method handles to call not only
Java methods but native methods a method
handle after all is a compiled diddid
intrinsic that has arbitrary VM assigned
behavior so why not push some some raw
arguments on the native stack and call a
raw native entry point well there are
many reasons why not right this is not
terribly safe but when you need to do it
this is probably the most effective way
to do it through a method handle as
opposed to thrown through some special
special API like jmf i which always has
some interpretive overhead in it so
that's a that's like you can take that
and and double down on that crazy
proposition and say well if I'm going to
call native entry points why don't I
just call native instructions and once
again you can spin method handles around
arbitrary native instructions you give a
little information to the JIT as to
where the register motion is on either
side of the instruction and wrap it in a
method handle and once again if the JIT
sees that in the mix of a bunch of java
code it says oh okay i guess i got to
put an instruction there I got to assign
some registers and plug it in and boom
you've got it you've got a way to
directly put as in statements in Java
which is pretty cool when you need to do
it it's cool when when you don't need to
do it it's not cool to do it right and
likewise with them suppose we want to
introduce a new type into the JVM value
types well that involves a whole set of
change through the tools the stack the
the language the compiler the bytecode
set the optimizations we're not ready to
do that yet but we want to give you guys
a preview of value types so in a very in
a very soon upcoming release we expect
to be able to give you access to these
new types but not in the form of source
code or bytecode underneath the
underneath the method handles so
basically say I'm going to be able to
make method handles it can work with
these strange types I just can't say
them in source code it sounds
paradoxical but it works and we're
actually able to use this technique
today with some early pathfinding we're
doing with Intel engineers to to create
roll the whole thing together to use
value types to represent larger than 64
bit vectors and to represent intrinsics
in the Intel hardware for those vectors
and get tight loops out of the out of
the jet doing vector eyes code manually
it's probably the best way on earth to
code with those instructions it's even
better than new CC intrinsics which is
not a high bar another thing another
thing we're doing we've got the
prototype just about ready to publish
where we're able to put invokedynamic in
the constant pool and that means being
able to assign a bootstrap method not to
a call instruction but to a point in the
constant pool and that means when you
LDC it
bootstrap method runs the first time you
touch it it fills in the constant and
then that constant is in your constant
pool forever for you to use and it could
be of any type whatsoever
that's called constant dynamic or conde
for short conde in india or a nice pair
and then finally we have something
called bridge o matic
or or lazy bootstrap methods the idea
there is to be able to once again use a
bootstrap method to tell what's in a
method so the first time you call the
method you run a bootstrap method for
the method and then that expands it why
would you want to do that that's crazy
isn't it well no actually what about a
two-string method it has a ton of
boilerplate in it it's really
stereotyped you really want to have that
sitting on disk in your application
especially if you never use it better if
you can just when you when you first use
that to string method spin it up real
fast from some sub metadata and then you
have you have your code just as if it
had been coded there all along but you
don't have to deal with it until then so
those are some of the ideas that we're
working with in the near future
one other thing is not only are we
putting invoke dynamic in more places in
the VM we're putting it in more places
in the source code the the idea there is
we're working on some syntaxes this is
all TBD but we think we've got a line on
how to do it to be able to actually for
the first time write java code that can
create constant expressions which folds
down to Indy and Condy so you can write
you can write your own in Java you don't
have to spin byte codes no as a no azzam
yeah
no Azzam and so that that will unlock
creativity I think you know you know
amongst more people than just those who
spin byte codes so we'll find more uses
for in D&amp;amp;D I'm on the mic yeah like my
mic I'm going to explain a little bit
about signature polymorphism photo you
don't know ever curious so say we have a
public class test it has a method in it
M take some arguments returns something
and we have a method M that's associated
looked up to that method and we have a
method handle that's looked up to that
method as well and if we if we look at
this reflect method that invokes
java.lang reflect method em we pass the
arguments in we passed the instance of
test we pass some values in here and we
look at the handle method that calls the
method handle it looks almost the same
there's no look very very similar if you
look at the comments here the method
signatures are actually different if you
look at in there in the source code in
the Javadoc you'll see that the the
method signature for java.lang reflect
method takes an object and then a VAR
args object for all of the parameters it
takes the object that's a receiver and
all of the parameters and the receiver
could be null if it static and it's a
instant test in this case because it's a
virtual method whereas in the method
handle version it just takes of our odds
and that's it so you wondering how the
heck can that work is this going to be
efficient what are we going to do here
so if you look at the Java P bytecode
you can get some clues about what's
going on these special methods of a
method handle invoke and invoke exact
and the VAR handles methods it's a
signature polymorphic so I've
deconstructed the bytecode here using
java p of the method the java.lang
reflect method and what you see going on
you see the invoke virtual at line 30
here and you got all this ceremony
beforehand before you actually do the
invoke virtual of the java line reflect
invoke here with the method signature
see the object and the array of object
here expresses as invite code method
signature and you got essentially what I
call packing the boxes you have to
create an array at the top here of size
3 it's in the green and then the first
argument has to be put into the array
the second argument and the third
argument and you notice that the the are
we calling 42 and 3.14 argues they have
to be boxed into integer and double so
is packing and boxing there and that is
quite a lot of bytecode and it's quite
hard for the the VM to optimize this way
using escape analysis and so forth like
that it's a really hard optimization
problem so
signature polymorphism just does away
with all that and it says here's Java
see whatever you see here as the types
just put him in as a signature instead
soon in essentially we have the the
loading of this we just push a onto the
stack
push the integer push that the double
and the signature is encoded into here
directly rather than the varargs
and that is what signature polymorphism
is and it's and then there's some nice
sort of contract between this and the VM
that understands what this means of how
to optimize it under the covers so it
compresses it all down like so and the
see of signature polymorphism could be
infinite in a sense but actually in
practice it's limited in terms of its
arity and also the types of these two
covers we we we widen billions chars
shorts and that tends to reduce purpose
of permutations we have under the covers
to deal with all this so hoping that
gives you a sense of what it is and when
you see this word it's not so magic and
strange it's actually very simple in
Java see what's actually going on more
complex in hotspot so now I'm going to
talk about the concepts of lookup an
invocation so how do you actually get a
method handle say to an Efford virtual
method to the field or something like
this you can fit a method handles as a
new-and-improved way to reflect over
classes at runtime you can you can
there's an aesthetic judgment you can
decide on that or not but we're trying
to move people away from reflection to
method handles as a way to operate on on
stuff and act the difference between a
new java language and here is access
control occurs when you actually look up
a method handle it does all the work
before hand so that when you operate on
the handle you don't have to take that
hit every time and because of this you
have to guard these handles very
carefully if they're pointing to stuff
you don't want others to use you have to
you have guard these handle to make sure
they don't leak out so when you have
these keep keeping tight to you if
they're important to you yeah this is I
don't think this diagram is doing
anything useful
except that what we want to do is make
that accessible go away eventually every
accessible object has a bit associated
with it whether it's accessible or not
and it completes access control with the
fields with pounding on final fields as
well which we want to get rid of
ultimately we want to make final fields
final so the JIT can actually optimize
these things but we're struggling to do
it because said accessible can stomp on
final fields and turn into non final
field which they did for good reasons in
Java serialization which we also want to
change as well and try and fix that
going for there's a separate problem so
some hard problems here before we may be
able to get rid of this thing but we're
trying to actually get rid of it
encourage people to move away to look up
so I'm going to do some rage don't think
about look up first yeah look up is a
capability object how many of you have
used to look up ok small number so said
accessible is a very crude hammer you
can take any pre-existing any
pre-existing reflective thing and Hammer
it to make it crack the system open and
that that means that it's hard to prove
that the any particular usage is correct
but with lookups it's a it's much more
fine-grained you you take a look up
which represents your your own
capabilities your own universe of
allowed access actions and that lookup
can only give you method handles which
correspond to things that you could have
done with byte code in the first place
so lookup lets you get to private fields
and but it does not let you get to
someone's private fields other than
yourself so it's a much it's much more
graceful and it's easier to prove
correct and there are of course some
sledgehammers hidden in the back closet
where you can where you can get to stuff
that isn't your private but it's very
clear from code when you're doing that
kind of a really edgy thing as opposed
to the more pedestrian thing of getting
to your own privates
hopefully we'll explain this a little
bit more in some demos here so if you
know about this already this is a J
shell demo for you so that's how would
you do lookup method M just using
java.lang reflection what you do is you
get the class you get the method and
then you would look at the method name
like so
and then the parameter type like this
and if I get my my Vulcan death grip
thing going go she'll you can do you can
do this so we have a method here when we
then we just invoke and we can do test t
equals new test so see you like so and
then we can in invoke that that should
be familiar to everyone like so that's
very familiar to people using Java
language selection so how we do this
using method handles we essentially
create essentially create a method
handles look up here let's call it L the
context of this lookup is essentially
the caller so when you call lookup its
caller sensitive and it says Who am I
and it encapsulates Who am I into the
lookup and that is that is where we can
start doing our access control from
who's looking up to whom and decide
whether we're allowed to actually make
this happen so in this scent you can
look you get a sense of how Jay shells
working here because it's creating
anonymous inner classes here and in this
sense it would be different if you doing
this in the IDE but we got to look up
with a look up class and once we got
this look up class we can save find
virtual like this and look up M so our
reference classes is C MSM and then we
have it when we have a method type that
we need to create which is our method
signature and a method type return zan
int and takes an int if that works and
we get a method handle out and then we
turn then we can essentially invoke it
so we can VOC it with it exact semantics
if we want to which means that the
method signature in the core site here
has to match exactly the target
and that is a very efficient way of
invoking and if we don't get that right
we get to what's called a wrong method
type exception so this is where the sort
of little bit of strangeness comes in
here that we have to actually do a cast
like so oops
swirly ogre sure thank you like that
that cast is not it not encoded as an
explicit cast with boxing and casting to
an end that actually says what is the
return type of this signature
polymorphic method like so otherwise you
can just do the slow way with invoke
person C and that will actually do
transformations it will it will do
casting or do widening primitive
conversions so forth and that can be the
slope at of it some optimizations in
there it's not as optimal as you might
think all the time line m it probably
ways we could improve it in the future
but it's quite a hard thing to improve
generally so if you really want speed
using VOC exact rather than invoke there
so now let's look at the look at the
class see here we have a private field
in there so can a shell what we're doing
the shell access that private field in
there so if we just do C C dot I equals
1 we can't do it because we got private
access here so what would we do so if
you're doing in reflection land what you
do well we get it we would get a get
declared field what's what's that it's
the name I think it's I so we've got a
field to private in C so what happens if
we try and set that with some value we
get a legal acts exception when we
actually operate on it so what happens
if we try and look up to a field instead
now field is not a method but the
low-level mechanisms in method handles
have bytecode equivalent functionality
and behavior so how will you look up a
method handle to that so we got a look
up L we can find setter like so forth we
need to specify a class in that class so
are we allowed to look at that field
from our context of where we're in it
shouldn't work it won't work because we
don't have access so how do we how do we
get access to it because if we're in the
same context in this case we're in the
same class loader we're in the same
module in a sense of where you get
around this so what would we do if we're
in the field let's go back to our field
here what we do we would have to do set
accessible true which is the blunt
hammer here and then we can then we can
do a set and now we're all we're all
good that is a bad way of doing it we're
trying to encourage people not but I
realize those reasons why people need to
do it but we're trying to move people a
so what would we do instead so we have
something method handles dot private
look up in where we take out we take her
have a look at the signature here so we
take our target class which is C dot
class and we take our lookup we want we
want to teleport am I allowed to
teleport into this thing do I have the
right permissions to do so
and now we're actually allowed to do it
it gives us the permission to it so this
is set accessible principle set
accessible on steroids
it won't stop on final fields it will
just allow you to have accessibility
we're actually using this in the JDK
because some stuff in Java util
concurrent wants to get access to fields
in Fred and it's been using unsafe to do
this so we can use method handles look
at private looking so yes I'm allowed to
do this because I'm in the same boot
class class loader and then I can use a
method handle to access this rather than
using unsafe and the whole thing is much
clearer on the contract between the
thread and stripe 64 in this case we
want to do it two more cases than Java
EE two concurrent Fred local random does
the same thing as well it's much more
principled way of doing and like the way
it's turned out so now we can we can
invoke that and can't don't know why
that's null quite a mess is that no
anyway demo sailors returned Mill pum
setters returned milk signature yes of
course what am I thinking the return
void void wait appears as null to like
chain like look I think it was a bar
handle so if we do if we do 24 like this
so we got a getter instead when we get
get back what we set okay yes so it's
kind of strange when others return
because it's void is signature
polymorphism is popping its head out in
an ugly way here if you didn't invoke
exact then it would it would come back
as void yep so we can also do a fine
finder var handle on this class and do
exactly the same thing with method
handle and then do compare an exchange
and so forth like this on the field so
hope if that's given you a flavor of
that what time how much time do we have
left
you're halfway through okay let's
continue on
so now there's method handle
Combinator's which allow you to build up
behavior in it sort of BSL light manner
you see a lot of method methods or
method handles that allow you to do some
quite sophisticated stuff and underneath
the covers the framework should actually
optimize this and generate some quite
efficient bytecode which then the JIT
can operate on when you do this you kind
of need to think in Reverse and think a
bit like a compiler so it's quite
mind-bending if you're not used to this
kind of thinking charlie another has
something called invoke binder which is
a way of trying to do this in the right
order and express this very cleanly and
maybe it's something we you might want
to consider going forward to make this
easier to use they see is a bunch of
methods to do argument and return value
manipulation and there's a bunch of
stuff let's do control flow like if-else
try catch and loops there's no switch
yet there's a bunch of things we could
add here go show a quick demo I'm not
going to show all of it because we're
running out of time I just want to get a
quick get the concept across so I want
to I created some snippets in here which
a method handles to begin to add and
begin to do multiply and I've just
created some constants for myself so
they'd be the add dot type you can see
it takes two big integers and return the
big engine I think nothing outstanding
there I want to combine these using
method handle combinators and I want to
do something like like this I want a
credit function like this now I are
using these combinators here so the way
the way to think about this is to
actually have it have a different
function X Y comma Y Prime
like so and then our function f of X is
just a call to f prime X comma Y comma Y
so this is thinking like a compiler
might think and go to thinking like an
AST manner as well so how once you get
this style of thinking coming in and
manipulating arguments on on the stack
then it becomes much easier to
understand how combinations work so how
we do this so we have method handles
that collect collect arguments here and
what we want to do is we want to say
well a last thing in the tree here is a
multiply operation so we got a mole
method here and then we want to combine
the arguments we take from ad at
position 0 in our argument list and
return a value and pass that to mol as
the first value and the other mold can
take the third value in this list and
that makes sense so let's let's just
look at the method handle here function
option F 1 F prime so we get a method
handle here it takes three values this
is my front my f prime function here it
takes X Y and Y prime so we can actually
invoke this 1 comma 2 comma comma 2
there's nothing exciting to get the
right value out here now we want to sort
of up level that again so we want to
pass in any two arguments so what do we
do there we have method handles dot dot
permute arguments so you want to take F
prime as a input here we want we want
the method type for just taking two too
big integers at and returning a big
integer and we and it's basically saying
we've got three arguments here it's the
first one and the second one in the
second one or zeroth argument and the
first and that's so we get a method
handle here string 34 and we see it just
takes a big in such a big integer if we
put invoke here one kind of two we get
the same value so this is how you have
to think in this model and it gets it
gets look gets a little bit more
complicated say we want to look up
combinators two loops which we recently
Michael Hubbs added I don't have time to
go into this but this is this is a way
that you might do a method handle
combination to sum up big integers in in
a loop essentially we have a counted
loop here it takes how many how many
things do we need to count is going to
accept a big integer array as input into
this method handle but it needs to know
how many things to count so it's the
array length of what you pass in is a
big integer array and then we need to
say what's that what's our initial loop
value loop result value is going to be 0
and then we need a way to actually sum
up the values so this is the way I'm
doing it here and we need to shuffle our
arguments a bit like we did before to
get things in the right place so we can
extract an element out of the array and
sum it up to a loop value and swap
argument so forth like that so I'm not I
don't have time to explain that but
that's how it gets complicated the more
you think about this but it's hopefully
the end result here is you'll get an
efficient byte code out and then the JIT
can efficiently operate it so this is
not something you would do normally in
source code this is something you might
do in an indie when you're dynamically
generating stuff so you don't have to
use Azzam and stuff like this if you
stick native method handles that punch
down to single instructions instead of
the big integer primitives that he's
using then this this loop stuff combines
them in the right way so you actually do
get your vector loop that fits in one
cache line at the end and in fact this
is the same tricks that been doing is a
vector API in graves in Intel he's doing
these loops and doing the the code
snippets thing and getting very
efficient loops with AVX instructions
and vectorized loops in there and it
actually pops out amazingly what the
hotspot can do just crunch it all down
to a very very tight loop okay so that's
method handle on the native so
quick thing about constant dynamic to
explain this so this is something done
by Louis what's a Fulton if something
interminable who I think is going to
come out and as a patch or as in branch
or you can have a look at so the idea is
to do to invoke dynamics of course like
to do it for constant pool there's only
a limited way you can express constants
in the constant pool primitives class
method type method handle what happens
if I wanted to have var handle in a
constant pool I can't do it today I
wanted to but it's kind of it was just
too much work to do it and question
whether we should have another explicit
types of a constant pool is there a way
we can make this almost the last thing
we add in terms of expressing stuff in
the constant pool it's another level
this is a classic level of indirection
trick essentially so it's an
experimental mechanism
the idea is you should LD you should be
able to LDC that's the bytecode for
loading a constant LD see almost
anything and the VM appeals to a
bootstrap method to say what the heck
are you going to return to me
essentially from some constant arguments
like Indy has a bunch of constant
arguments you pass to it consume ammok
has a bunch of constant arguments and
they thank you effectively these are
like lazy static finals and this is
interesting to us inside the JDK because
we have circularity issues I'm wondering
if we can use this to break the
circularity chain or the recycle if you
were so that when you need something you
don't have to put it in a static
initializer it's initialized when you
actually need it not not up front indeed
class initialization so here's an
example this is how you'd write an
efficient var handle mechanism today you
would have a static final you initialize
in a static initializer and then you'd
use it later on say like compare and set
and in a method like this this is ugly
Dudley hates this it's no worse than
atomic filled up dated ugly hey stomach
filled add data to this and improve
matters yeah yep
it's where we are but I want this I
really do want to get kind of this type
of sting or this
expression we're using the same syntax
used for method references here now
there are issues here we're in terms of
source code and overloaded overriding
methods and all this but that's the
expression I want to sort of get to or
something close to it we express what we
want to the field and we have a very
handily to but we want that deficiency
we want this to be rooted as a static
final want to be routed as a constant so
the the hot spot and constants old early
access when we do this compare and set
operation
so here's I've been playing around with
a prototype and I did some hacking and
got some Java P output here when we
encode this so here's an example of this
CAD method I showed so here at line 0 we
have the LDC instead of referring to a
static final field here we say load this
constant what is this constant well in
the constant pool at 23 it points to
something at 0 which is a bootstrap
method which says an invoke static to
something here which said get me the VAR
handle for this information with the
static constants here of through s and
java.lang string so it has all the means
to do this like in the static
initializer but it's lazy and it invokes
this and appeal to Java to go up and do
this rather than at static
initialization so that's the essence of
it and it's going to be recursive too
because we have no way of representing
in that class in the constant pool if
you look at if you compile in a referred
input class in Java to other source code
and compile it you might be surprised
about how Java C encodes that
information so if this was this still
was an intent of a java.lang string we
might appeal to another condi coming in
to actually resolve what that means and
you can you can actually take this even
server and get lazy expression lazy AST
trees or trees lazily to produce we
think we can push this quite hard that's
the reason we don't just simulate it
with an L Airy indeed because if we just
wanted to get a one-off LDC of something
then a null area in D works pretty well
but if you want to have constants
referring to constants basically upgrade
the whole constant pool not just the
parts that the LDC touches then you need
this yep
this feeds off India as well Envy has
certain restricted way to represent
constant that we can make in be even
more powerful with this mechanism as
well okay start ramping up all right so
this is all speculative well you already
did to safe harbor sake statement but
there there's some future Combinator's
we haven't come to the end of the we
haven't come to the last Combinator you
will ever need and so for starters the
switch statement is something you can
write in Java and it has a bytecode for
it but you can't write that in method
handles and there are there are actually
good reasons to fix it other than just
sort of picking and thread off off your
sweater a Swit switch Combinator for for
method handles might be unlike a regular
switch in that it might be open-ended
you might actually have the switch
itself have a little bootstrap method in
the default that says every time you see
a new switch selector do a little logic
to say well should this have a
specialized case statement for it and so
you develop the cases lathe lazily now
that's a very powerful technique that's
used for example in the pi PI
interpreter to have the to have the
language runtime sort of grow itself as
a user exercises new path so you don't
have to compile it all up front you just
have a thing compile itself as needed
another one that's really simple is
synchronize on object we don't have a
way to do that that's built into the
language there's a number of really
simple byte codes like monitor enter
monitor exit I add ll mole compare byte
codes but they're like those are all
byte codes which have a really simple I
want to say stereotype or monomorphic
job we should have built in method
handles for all those in some place but
you can get to it right now the
workaround is you code a method of your
own that does the synchronization or the
add or whatever and then you um you you
pick it up that's that's the secret
reason why Paul's demo earlier used
ignant integers instead of plain Long's
or something because there aren't any
well-known method handles for getting at
long add or float add it's just an over
oversight that you know will eventually
fill in a much more a much deeper one
would be partial construction
this is this is the very small number of
people have said why don't you give me
invoke special in it in my superclass
because I want to get my super
constructor call but while I'm in the
middle of initializing an object the
groovy wants this for example this is
really hard to do because it tie it
disturbs the most complicated part of
the verifier which is the part that
makes sure that you initialize the super
part of yourself in your constructor
before your constructor initializes the
rest of the object it involves partial
object States which are very dangerous
very insecure if we were to give people
hooks to just play around with partial
objects that we get I don't know someone
might build a D serialization framework
ad vitur something and then there'd be
all sorts of security problems oh wait
yeah so we we think there's ways to do
this using the method handle framework
but it's kind of a research problem
still the idea would be to have a you're
partially constructed object in kind of
a locked box that only authorized
Combinator's could get into and so you
work on the object sort of at a distance
while it's in the uninitialized form but
the locked box ensures that you apply
the the right sequence of constructor
components in it that way you can prove
you can prove that nobody does anything
that they couldn't already do in
bytecode and and nobody does anything in
the wrong order that the verifier would
reject and yet it's all done with method
handles so we think we think we have a
line on eventually filling in that that
hole and that will be maybe the last
thing that you can do today in bytecode
that you can't do with method handles
higher-level things sort of die no link
level things
melty methods are interesting what if
you had a method handle Combinator that
said I know I'm going to call a whole
family of different methods but
depending on the arguments I want to
look at the argument and then decide
which of the family I'm going to call
right we make stuff like this right we
make like virtual object hierarchies
that have this flavor and the multi
method can potentially dispatch on all
the arguments instead of just the
receiver argument some languages do this
sometimes it's useful the the key thing
is that that you you run different
snippets of code depending on the
dynamic value of one
our arguments this is the kind of thing
you can capture in a Combinator and I
think what I think we might come up with
something like that in the future as a
utility lest you think this is too weird
and researching a simple example of a
multi method that fits the definition I
just slipped by you would be printf
printf looks at the dynamic value its
first argument which is a format string
and uses that to count and interpret the
the remaining arguments right so imagine
a you know a printf that sort of for
every format string or every class of
format strings went to a different
optimized optimized method you might be
able to get printf that doesn't have so
much interpretive overhead in it and
then of course if you constant fold fold
the format string then the multi method
collapses to a single method but the
code is actually optimized for that one
particular format string so that's an
example of multi methods well actually
you use them every day and they could be
optimized better also a control flow
that's slightly non-local do break is
something we write sometimes you write
have you written a do statement in Java
where you don't intend to do it more
than once because you want to break out
of it and you break to a label that's a
Combinator to and so that's that's like
a piece of language capability that's
missing from method handles you can
build it yourself of course but it'd be
nice to have it built-in so that so you
know the system's going to optimize it
what do we got we got five minutes okay
I'm going to race through this this do
you have any more okay all right I've
got the podium I'm going to talk about
this a little bit in the next talk too
but basically are one of one of the
things we want to do is put bootstrap
methods in more places so Indian conde
have already been talked about
I mentioned the lazy boy boilerplate
method earlier there are other things we
might want to be able to do such as what
if you could have a superclass which
said everyone in my subclasses will have
a two-string method if they don't define
the to string that I'm going to define
it for them as a piece of boilerplate
that expands differently in each
subclass right that's that's not a bad
idea and we can do that with a bootstrap
method and proper wiring in the VM and
so we want to be able to do bootstrap
methods not only at the time we do them
now which is on first execution but also
maybe a little bit more eagerly when the
class is linked or maybe even super
early at a ot time this is something
that we have to do in some cases now and
we want to generalize this pattern of
being able to sort of provision or
provision the the action of a bootstrap
method at a ot time because a OT is
becoming a reality in the java world
we've food you know there been a ot
compilers for a long time now we have an
AMT compiler in Java 9 and let's let's
teach that anti compiler to do some
interesting partial bootstrapping
at a OT time this will give us some Java
applications that are quicker to startup
I want to say a couple words about code
formats this is an invocation when you
invocate invocation talk when you invoke
you invoke some piece of code it doesn't
have to be byte codes it could be method
handles and Combinator's and we're
aiming to have a close symmetry and and
synergy between what you can do in byte
codes and what you can do in method
handles but then maybe also we want a
third thing someday what I call
transparent expressions this would be
expressions which are like byte codes
easy to assemble sequentially but
they're not they're less contextual it's
just basically a sequence of tokens
there they're not as compact as byte
codes but they're easier to understand
the byte code so you basically would say
here's an a' message handle oh that
means execute that method handle on
whatever is on the stack and then push
the result of the method handle so you
write code that looks like forth code
the advantage of these is it would be
easy to analyze these backwards without
executing them you'll be able to say oh
yeah I see someone has asked me to do
and as type transform on a method handle
I'm going to get conclusion about that
that doesn't necessarily involve
executing it we talked about constant
format so I'll just quit that except
there is some there's a few extra things
you want to do conde isn't actually the
last we also want a grouping constructs
so we can have more than two to the
sixteen constants and that's that's not
too hard to do what we haven't figured
it out yet we want to do new kinds of
calling sequences right
now we have the native colleague
sequence which is strongly typed by the
verifier but we have also met the handle
based calling sequences we have the
reflective one which which Paul already
showed you with all the boxing but then
there's some other possibilities too we
think we want a way to wrap up a
sequence of strongly typed arguments
without boxing but in one sort of
shrink-wrapped pique slug of data on the
stack not necessarily an object is where
value types come in and then be able to
efficiently hold that until it's time to
call a method handle then put them
together and not have any boxing just
basically slide the argument list into
place argument arguments should be
worked backwards - this is object
deconstruction if you if you take a
bunch of arguments and you construct an
object you should be able to reverse
that process to take the object apart
this gives us a handle on doing let's
say D serialization and serialization
done right you know you you want this
you want you want a strongly typed set
of operations that does the expand and
contract and panfish and passing matches
yes and it gives you pattern matching
and a final call out to co-routines
we're not ready to say much about that
yet but basically that's where you start
invoking slices of methods that haven't
finished but are you're going to help
them finish by invoking the part that
isn't isn't done yet Paul we're done
these are some more links to more
information you know watch watch the
watch the open JDK traffic we were
thinking about all this stuff I think we
have about three minutes the question
everyone's done ok
we're working on one yeah to come out
soon too yeah there's there's a there's
a bug are Fe about bug track are Fe that
talks in detail about it which we should
probably okay thank you thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>