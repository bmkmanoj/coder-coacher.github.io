<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Deploy microservices with Certainty by Alex Soto | Coder Coacher - Coaching Coders</title><meta content="Deploy microservices with Certainty by Alex Soto - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Deploy microservices with Certainty by Alex Soto</b></h2><h5 class="post__date">2017-11-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ZyZP9EpTr30" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right thank you very much for coming
to this session about how to deploy
micro services with certainty my name is
Alex Soto I'm poor girl Red Hat and
narrator of lots of the jaws calm and
you have any question any feedback or
whatever you can do it on my Twitter
which is Alec so to be and also I'm the
careful of testing Java micro-services
in this book we are covering some of the
things that I'm going to show you here
more extensively and also other
techniques and the first thing that I
would like to tell you is that what you
are going to see here is a really simple
example I know I like to call it a
Mickey Mouse project
I know it's simple but the thing that I
want you to get it from this session is
the idea right then your I know that in
your projects in your real world
projects it's it's going to be harder
that what I'm going to explain you here
but you just get the idea and then go
deep on your on your time basically what
we have in a microservices of character
is like tens of services interconnected
between them some of the services maybe
are in the same cluster others in a
different cluster or even in external
third parties but at the very end there
are several micro services that are
interconnected and one of the key points
that you will get in Microsoft's
architecture is that each of the service
must be deployable independently so it
means that you may have two three four
five ten services and you must be able
to take one and update it to a new
version without updating the rest of the
services so the example is as I said
really really simple it's a blind
database application and I'm not get any
browser
I just a postman right so it lets it's
simple and then we have a consumer and
consumer it's a service that consumes
data from another service and in this
example I've used barracks but it's it
doesn't matter here the underlying
technology it's exactly the same then we
have a provider and the provider is the
service that exposes data to another
service in this case it's used vertex
but it could be what was form knob GS or
whatever all this application is going
to be deployed on an open ship cluster
and OpenShift is like it's right in fact
its kubernetes plus and now some futures
that are lock on cuban errors and
basically what we're going to check is
that the postman is going to do a get in
a /p lines slash grew the consumer will
get all the crimes of that can be
committed by guru this produces will
return a JSON file our a JSON document
which is an array of all the crimes
which in this case is the moon the name
of the v/line and also the wiki page
where you can see information of what
they want to still I'm finally the
consumer is going to get the information
from rule like the area of influence
it's going to take all the origin crimes
and they are going to zip and generate a
JSON document with all this information
it's a simple example but I think it's
easy to follow so let's see how you can
destroy your production environment I've
got the code here this is the crimes
service and what I'm going to do is just
remove the wiki so suppose that the
developer because he misunderstood
something or by error or whatever he
removes how the wiki information is
sorry all asset then I've got here my
test I've of course I've read test and
and here in I'm using rest assured I'm
saying that when I go to crimes a / dub
a line in this case GRU I want to return
the moon and Times Square Jumbotron and
it should have a week
I feel Tazewell with all the information
so since I know that I've removed this I
can comment this line and then all my
tests are green so you go here and if
you want before I break something you
will see that it's really working and
have this deployed on on the cluster
notice that it again going to the
cluster slash balances slash crew and
it's returning the JSON as I said the
cluster is just here this is my cluster
with the billing service deployed and
the crime service deployed so now I can
go to the to the crimes and I said okay
I want to create a new version which is
the one that one clean run the test and
deploy the new version I run it
that's right I mean that since it's an a
vertex application it's bring up the
birth text runtime and then do that
rest assured connection to be sure that
it works
now it's creating all these you were jar
let's say and now it's building the
image and what's happening
what wait now well actually doesn't
matter so yeah now it's going to deploy
theory the new crimes but yeah now it's
building the image yeah now now it's
building the docker image with this new
crimes and notice now that is changed
from crimes to and now if you open here
you see that I'm scaling down the
previous version and scaling up the new
version so now we have the crimes one
that one deployed on my cluster notice
that I'm not touch belong villains is
still the number one version and then
I'm going here I descend and I get an
internal server error and then I can
just say okay what's happening they can
go here in the crimes the number two
which is active one and go to the logs
and can it's not shown but basically it
throws that a new pointer exception oh
yeah sorry
because what is failing is the balance
right and balance throws more format URL
exception because you passed a null
right because you have not serious to
fill so you break production and it's
not very good thing so what you need to
do is we'll go here and called OC role
work coming on so what is happening now
is that I'm rolling from the new one
that one version to the previous one 1.0
version so now if I go here again and I
do send everything is still still I'm
gonna start working again as expected so
as you can see it might be really easy
to break production and this is
something that probably your consumer
your customers are not very happy that
you deploy something and then when you
deploy your micro-service there
all the environment has been broken so
how we or what we can do to ensure that
deploying a new service does not break
the communication within existing all
services and the answer is contract test
and at the end contract as is really
easy concept it's like the contract in
real life and a contract at the end it's
women between a consumer and the
producer and how the APL should look
like
so it's both of the parties signed this
contract so if we follow this contract
all the time it's not going to happen
anything if we break the contract then
we know that something wrong is going to
happen the question is who is the
responsible of create and evolve the
contract there are several approaches
all of them are ballot one is the
provider
it's the provided contracts the provider
means that is the provider who write the
contract and all the consumers needs to
follow that contract the other one is a
consumer which is the other way around
which is the consumer defines the
contract and then the providers need to
adapt to that contract and finally we
have which I will say that the ninety
percent of the cases works which is
consumer driven contracts which is that
the driver I the consumer stars the
communication of the contract but it's
like something that you need to do
together between consumer and the
provider so consumer start writing the
contract pass to the provider provider
validate give some feedback and so on so
far until you have a design of what your
API should look like so usually what's
happening with all the count or all the
contract ask how they run we have a
consumer test so the contract is
something that you can you can write the
contract by hand usually all the all the
products that's that are up there
they're using JSON so you need to start
writing the zone which is not very good
idea so you can create a consumer test
which is going to be in charge of
generating this contract then we have a
stop server obviously
and you don't need to communicate with
the real server notice that if you start
communicating with the real service what
you are will end up is by an end-to-end
test and this is something that you want
to avoid you're going to end with an
end-to-end test because you have service
a that wants to communicate with service
B service vicuna cache with C and D C
maybe have a MongoDB D maybe have a
Paschal sequel so you need to put up all
this environment to just generate the
contract of the consumer so as you can
see it's Li bad idea and probably you're
going to end up creating a flaky test so
what you are going to do is just using a
stop server and you're going to write
some expectations obviously you need to
see ok for this server for this request
I want this answer then you have the
coin this is your Java code where you
have your gateway class that is in
responsible of communicating with the
provider so what you're going to do is
just do get in this case slash crimes
slash grew to this a stop server this
server is going to check his
expectations and we say ok when I know
that because you have programmed me that
when you go to get a slash crime this
wash rule I need to return this array of
JSON objects which is the name the week
and so on so far in this case finally if
everything works I mean that if the
consumer is able to consume these
expectations
that consumer that is going to create a
contract and this contract is this JSON
file it's a big JSON file with all the
interactions finally this contract must
be put somewhere so the provider can
take it this can be a shared folder can
be a git repository or can be any kind
of broker what's happening the provider
side ok the provider needs to validate
that he is able to produce these
requests and responses so you need to
validate that the provider
agrees the content meets all the
contract expectations so again you need
to have a provider the real provider and
you have some kind of automatic test you
will see that it's a generic test which
basically starts doing the next thing
taking the contract from the sharing
folder or git repository or your gender
repo and a start replaying automatically
all the requests against a real provider
so in case of this simple example that I
show you this contract will have all the
interactions which this interaction will
be a get in a slash crimes slash crew
and then the real provider is going to
return something this something is the
document I mean that it's the JSON array
of the crimes and then we have all the
real rico's and response and then we
have the contract so the next thing that
this test will do is just do all the
checks it makes a matches between the
real rico's and response and the real
under contract so if everything is fine
then the test is green because it means
that the provider is able to produce
responses for that contract and if it
fails then you know that you don't need
you it's better that you don't deploy
this service to production because
you're going to break your consumer
actually there are two big frameworks
for contract test one spot and the other
one is a spring cloud contract spring
crop contracts although it has the
spring word it can be used by any JBM
project but I'm going to use I'm going
to show you packed and I will I'm going
to explain you why packed the first
thing is that it's a foundation it means
that there is some organization that
it's defining how a contract should look
like and currently the the packet
specification is the v3 what means that
that packet is a foundation that there
is integration with several languages
this for all the jvm languages Scala
Java Ruby Python go the net fist and
JavaScript this means that since you're
probably your front-end is in JavaScript
and your browser is also consumer you
can use the same tool with the same
approach for the browser the front end
and the back end and even your back and
you're using a polyglot approach where
you have one micro service with the net
another one with Java another one with a
JavaScript then you can still use the
same approach for validating the wall
contracts of your architecture finally
pack comes with a pack broker you can
think about the pack broker as a hub
where you can publish contracts tack
contracts and then get contracts by tag
or or by version or several ways and
finally it integrates with arquillian
albarran and this means that you have
all the features of our killer an
ecosystem prospect and also we provide
some futures that are not provided by
pack itself so let's see how to work
with with pact we are going to fix this
problems I have here yeah yes and no I
mean that I would try to figure out when
the question is if this is something
like slower no package it's a
specification which is they have their
own format the problem you have with
swaller is that you cannot write
expectations so you can say these are my
I mean that this is going to change in
the lot in the next version of smaller
but currently you cannot put for example
examples or regular expressions you can
you cannot say something like I want a
name and the name should be this one you
cannot do this kind of things of this
code examples in this are God I know I
think the next version is going to
happen but currently you cannot you have
not the same
degree of for making your contract be
really concrete if you can use swallow
but then the contract is somehow quite
generic and with this specification it's
more concrete of what you're expecting
this is yeah these crimes I'm going to
start with a consumer because we said
that we want to use consumer driving
contracts and this they're basically
have another branch which I have all the
dependencies and so on so far so and
that's all so this is the consumer
contracts that now it doesn't compile
the thing the first thing that you need
to do is annotate with the runner and in
this case I'm going to use our Killian
algorithm because I want to use some
features that they are not private by
pact but in case of PI you should use
here the runner of pact I mean that in
both cases you need to use a runner so I
use the clean runner then remember that
I said that Durr is Anna stop server and
this is stop server can be local I can
be running local or locally or remote
remotely can be a docker host or a
server in Australia and PAC doesn't have
any way of to be able to deal with this
thing you need to manually set where is
the server but in case of our key logger
on has some way to detect this and just
provide this URL for you so you don't
need to record nothing in your code so
you so you can just annotate a feel with
stop server and then here you will have
the URL where this stop server is host
currently it will be localhost then you
need to define the expectations remember
that you have the stop server and you
want to say when I receive something I
want to return this thing to do it you
need to create a method which returns
rico's response pact which is the
expectation is a class
you can put here return rule crimes for
example then we do and probably will
change it to something better and it
receives a pack DSL with provider and
that's called builder that basically
this is a DSL for generating all the
hrickos response team then I have here
this the first thing that you need to
put here is a string well is to identify
the use case in the cases grew beeline
to get all crimes the path which as we
say as we said before is a slash crimes
as large room methods yet we respond
status 200 the body think that the yes
and then to pact and finally you need to
define where when who is the provider
who is the consumer for this part of the
contract so it's done this is done by an
using the pact annotation and where you
say the provider its crimes and the
consumer is Billund
I'm finally what we need to do is create
a gateway that is able to communicate
with this stop server so I have here a
method this is sorry
this is the replying provided by birth
text to communicate with other HTTP
servers and then the next thing that we
need to pass here the web client and of
course the PAC server sorry because this
is new crimes scheduie no so current
great way is just a class which do all
this is like a web client again that how
will you connect to another server this
is something specific to vertex but
which checks over as you have the same
and with the spring would you have the
rest template on transfer this is Legia
this so now I can run this example and
what you're going to see is that the
stop services is up I mean it's going to
start then all the expectations are
going to be loaded and then the tests
will start doing the request response
and not here that the request is just
saying get crimes web Alliance name I
know it fails
okay well it's working
say that they cannot connect to them to
where what in this case what I can do
yes just to not lose more time here is
doing it this is exactly the same by the
change the branch it is exactly the same
project and then one thing that I miss
is this thing that you need to put down
where you get it you need to put back
verification to say I want to verify the
crimes part missed is a notation and now
probably everything is going to work
yeah notice that now I've it's boot up
this stop server which is a nettie
server it puts all the expectations and
then I do this as Earth at the
extracting the the object the names and
wiki are correct and this generates one
file which is the contract itself which
is that build facts and this is the real
contract this how a country looks like
instead of you have instead of writing
you manually DS with this test you are
generating the real contract where you
have the consumer the provider and all
the interactions between this consumer
and provider which you can see that this
the method the path and all the response
and the body of the response so this is
the contract that's fine then let's go
to the crimes and in crimes I have the
same thing right so if I go to source
here
I'm not going to code because I'm
nothing we're going to get out of time
but basic what you do is like saying
this is a test for the provider crimes
this is where the folders are stored by
default or not by default but I mean
that you can configure packed to
generate this contract in a in a folder
you know and you know in a local folder
but you can change this for a PAC broker
for a git repository for the maven
artifact or whatever so then you do this
then you have here the target this
target is a web HTTP client to that it's
responsible of reading the contract and
start replaying all the rico's responses
and then I'm using here a sub J
integration I mean that our Killian
algorithm has an assert J integration
with pack so you can do something like
assert that target this target is the
real provider with URL this URL
satisfies the contract so well now when
I'm going to run this what is going to
happen is that the provider is going to
boot up the
is going to start replaying all the
Rico's and response that are in the
contract and then asserting that the
response is exactly the same as one
defined in the contract
notice that now it's green and it says
something like very fine pact between
billions and crimes
rooo billion to get all crimes returned
to response which has status 200 okay
and has a matching body okay so now we
know that this provider is compatible
with the current consumer what's happen
if I do the exactly the same as before
that saying the you the user know for
any for no reason that wiki is really
important to remove the wiki and then I
run again
the test
you're going to see a really big stock
trades because it says all the
differences and so on but at the end the
important thing is here when it says
guru billions written response which has
a status code to headed in it okay but
it says has matching body failed because
you've modified the body of the return
of the body so before deploying
something to your production environment
you get the failure that someone by
error has removed something that makes
this provider not compatible with your
current consumer and here it says
expectations and what is the difference
and so on so far surface of everything I
mean this has been a really quick tool
in action of pack but ultimate
everything everything that I've showed
you here like deploying to the cluster
doing the rollback or running the
contract test in the provider and the
consumer side must be done automatically
not manually letting down conclusions
just try to avoid end-to-end test
because it will give you late feedback
because they are really really slow just
use contract tests in the micro services
instead of end-to-end tests any change
on your architecture it's a deep impact
on the changes that you need to do in
your end-to-end test so probably you're
going to end up by by a flaky test and
finally it's really difficult to
orchestrate end to end test nowadays
with micro service is really hard and
finally for in the consumer-driven
contracts they feel fast you've seen
that the test runs really really quick
and it feels just when probably in the
and the commuter stage of your CI CD
pipeline so it means that you get quick
feedback that your consumers not so good
it allows you to do it dependent
independent manned deployments so you
can deploy consumer or providers in an
isolated way and without having to
deploy both of them at the same time and
what
of the important things that improve the
communication notice that the consumer
start writing the contract without
knowing if the providers it's already
developed or not because you are using a
stop but then you have a contract that
you can share with the provider guys
maybe it's the same team as you up well
maybe not you can share the the contract
and say look this is what you can do we
look good yes okay perfect no okay what
we can fix and so on so far and then the
provider can even implement it run its
code against your contract and if it's
brain they know that they have done his
work correctly and if not they need to
check what is the problem we have 30
seconds but I will be here after the
session so if there is any question yeah
yeah yeah well it's empty mob but yeah
the question is about what happened with
dynamic data not not that one here it's
everything her code with guru the name
and so on so far yeah it has a it's
really a versatile thing there is one
thing that called random staff which
means that it's like a regular
expression where you can say something
like here there will be a field called
name and it will be any string or it
will be a date that will be any date and
they it generates a date but then what
they really have is that the matches
doesn't take doesn't take into account
this random data this or one thing and
the other thing is that something what
you need to do is that the consumer but
it's quite not a very good practice but
something the consumer needs to set to
the provider loop for example if this is
a user if this provider is a user and
you want to say I need a user on the
provider with name this one and surname
this one so there is also one thing that
it's called a state where you can say
from the consumer which is that data
that did you need in the provider so you
can work with these two approaches for
generating network for having dynamic
data alright thank you very much
and well here you can see that this is
where you can find the examples</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>