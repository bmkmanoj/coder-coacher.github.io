<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Modern Java Component Design with Spring 4.2 by Juergen Hoeller | Coder Coacher - Coaching Coders</title><meta content="Modern Java Component Design with Spring 4.2 by Juergen Hoeller - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Modern Java Component Design with Spring 4.2 by Juergen Hoeller</b></h2><h5 class="post__date">2015-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Innj76v7TxI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right everything set up we're just
on time and I'm going to definitely use
the time that we have here so let's
start right now
welcome welcome back maybe how many of
you have been to my Spring Framework
roadmap quickie the slightly improvised
one right just in the other room the
original arrangement was actually the
other way around the quickie was
supposed to follow up on this one but
the schedule didn't work out any other
way so I had to do the quickie first and
you know how those things go anyway for
this session here it's about the spring
component model story it it literally is
a story line so I'm going to basically
tell you a story about the spring
component model from its very core
principles up to the various endpoint
models that we have in spring these days
this is an entirely source code based
presentation
it's just slides I'm not going to do
live demos because we are going to have
a design discussion it's almost a design
study but we're going to look at the
plenty of source code so no bullet
points in this one
no animations either for those having
been to the road map park so just very
quickly my own roll my name is Jurgen
hala I am I have been leading the Spring
Framework project for many years now I'm
actually doing it for 12 plus years it's
going to be 13 in just a couple of
months time 13 years so I've been
guiding the spring from a core project
from its very early inception literally
from the set up of the source which
project up until today where the spring
team recites at pivotal and well
actually does more things
brings out more things into open source
story than ever before we're going to
take a spring framework perspective here
I might make a mention or two of spring
boot and other projects but
fundamentally it's about the core
programming model which to the day still
lives in the spring from a core project
including many of the endpoint
arrangements so weapon points WebSocket
endpoints messaging endpoints all of
those things come out of the core spring
from a project
I'm currently working on arranging
spring framework for the - along with
boot one two three so boot one two three
four the to base this coming up any day
now but uh spring chemic for the to
itself has already been GA generally
available since end of July so it's
already out for a couple of months and
we're working towards for the two two
three right now alright
about the for the two nests maybe a
quick note this talk will highlight many
features in the spring component model
and the point of the talk is that it
does not really matter where this way
and when those features have been
introduced in many ways the spring
framework component model should be
looked at as a as a coherent
comprehensive whole right now not as a
sequence of version numbers so the
spring fabric for the two just means
we're talking about the component model
at the very current state of the art as
it is in spring framework for the two
obviously there are some new for the two
features in there in particular for the
ones with a lot of spring usage
experience already there's a subjective
selection of many features in here there
are more personal favorites of mine
really some might even look a little bit
esoteric a little bit nuanced but they
make a lot of sense
they are underappreciated and not as
well-known as they should be for a mod
from my perspective that's why I kind of
baked them into this presentation so
there is quite a bit of photo to stuff
in there and I will be dropping a note
when we are talking about a brand-new
for the to feature alright let's start
the story where it begins with the cool
component model so I assume most of you
are familiar with the core model can we
maybe do a quick inverse poll who has
who hasn't had much experience with
spring before not much opportunity to
work with spring is there anyone in here
who has not seen any spring before at
all all right I hope the presentations I
can
can be followed even with very little
spring exposure before but of course it
helps if some understanding of the core
concepts is already present all right
this kind of component class highlights
the typical spring annotation based
component style
it's annotated with a stereotyped
annotation at service on top yet serve
is indicating a role for this class so
from from a source code perspective we
are looking at a piece of Java code
write a regular Java class following
standard object-oriented principles it's
implementing a service interface it has
a name my pocket means service it even
says service in the name but the
annotations used on this class add a add
a notion that otherwise isn't present we
formally declare this class to have the
role of a service we can reason about it
we can introspect this at runtime
tooling understands that it has a
service role it can be used as an
indicator even for generated component
model graphs of your application ID the
service annotation formally declares it
as a service instead of just naming it
service the auto wired annotation found
on the constructor here indicates that
this constructor is supposed to be all
to Wyatt at runtime auto wiring in
spring terminology means that its
parameters are going to be resolved
against components known to the spring
application context so spring is going
to select possibly create a
corresponding account repository and
inject it for you if there is no other
metadata indicating otherwise spring is
going to select this constructor and
going to resolve it that way that's what
Auto Wyatt means an auto Wyatt
constructor the naming of the annotation
describes the role of the constructor
there might be other constructors which
are just meant for manual use for
programmatic use there wouldn't be
annotated with editor why attend
the update book method down here is a
service mafada
let's assume it's also present in the
book admin service interface but not
necessarily its annotated with a
transactional a transactional is a it's
one of many notations in spring that
allow you to tap into a typical
middleware service into a runtime
processing arrangement usually backed by
transaction manager at runtime spring is
going to intercept the method start a
transaction first call the body of your
method and trigger a commit or rollback
when the method returns when you method
body returns so much for the runtime
semantics pretty commonly known anyway
from a source code perspective at
transactional well describes the method
right it tells you something about the
method this is a transactional method we
formally declare that this method has
transactional requirements transactional
semantics well the reason why I'm
highlighting the source code level so
much is because we are staring at source
code all day long as application
developers source code is the essence of
what we're doing in terms of what we
work with even if the outcome is the
binary spring's annotations in
particular really work well at the
source code level you can read them
nicely my book admin service is a lazy
service the my pocket means service
constructor is auto whyatt
the update book method is transactional
it's about readability about
understanding the purpose of your source
code so those annotations may all have a
runtime role but they also have a
descriptive role they tell you something
about your class that otherwise the Java
code itself wouldn't be able to express
or not not as easily anyway all right so
much for the core purpose let's have a
run through a couple of various
annotations in spring can be composed
this is a pretty cool feature in
particularly in the spring framework for
world it's a very powerful mechanism it
allows you to build custom annotation
such as this one a custom stereotype
here dubbed my service but obviously
you're free to choose your own name I
mean by all means please use a proper
name I'm using the mine prefix
consistently in this presentation but by
all means please use a name that
indicates something in your architecture
that has a meaning in your architecture
you could call it all the service
account service or even just based on
some vertical or some horizontal slice
give it give it the proper name that
indicates its role in your architecture
if you're building such a custom
annotation you can meta annotate it put
annotations on your annotation type so
this public ed interface is just a
regular type in your own code base
annotations are after all just regular
Java types the meta annotations would
typically come from spring itself so
your my service here
it's meta annotated with EPS service it
kind of inherits shares the
characteristics of a standard spring
service annotation
it changes the default scope to session
it indicates a default primary role
which is a hint resolved in case of type
match ambiguities where more than one
type matches it's always the primary one
that wins if there's no qualifier in
particular that can be a default
characteristic entities here and there's
even a default transactional role
applying to all public service methods
of this class instead of repeating the
transactional annotation on each method
this combination of characteristics is
now baked into your mind service
annotation every time you're using at my
service in classes in your codebase
could be all across a really large
corpus every time you're saying at my
service
what you really mean is the combination
of semantics a path from that
perspective it's a short cutting model
so it allows you to combine
characteristics into one sweet shortcut
but it's way more than that right
a free and main freely chosen it can be
a stereotype that has a meaning in your
architecture and it also carries those
combined characteristics
composable annotations can have
attributes as of spring framework for
and the attributes would typically
mirror an attribute from a standard
spring annotation um generally speaking
composability of annotations works
everywhere in spring in particular in
for that one and for the two we made
sure that we allow you to compose
annotations almost anywhere you can
compose your own Idina notation your own
at Auto ID annotations your own mapping
annotations almost anywhere when you're
currently using a spring annotation you
could use a custom annotation instead
that's meta imitated with the spring
annotation that you're using there and
that works out of the box nothing to
register just do it we ought to detect
that you're using the method annotation
model so if you're using this if you
choose to use this you may build custom
scoping annotations like my session
scoped above a name of your choice of
course so again the mine in there in
this presentation and instead of just
hard coding the session scope which is
some value in its own right there's no
free scope name anymore your hard coding
the session which means no typos it's
type safe from that perspective right
nothing can happen to the session type
name here scope name here so my session
scope has an attribute proxy mode which
mirrors the same name attribute on the
spring at scopa notation through really
clearing it on your own annotation you
allow your users the uses of your
annotation to change the proximal to
influence the proxy mode in Springs
scoping proxying is off by is basically
off by default you get the raw instance
on request
if you access a scoped component and you
can enforce proxy in through a target
class or interface proxies on the proxy
mode here the proxy mode is set to no
but if also no change in the defaults
but you could choose a different default
rida clearing an attribute means you
allow your users to change it you could
also choose a different default
that defaulting thing may be even more
obvious below a custom transaction
annotation called my transactional my
transactional really Claire's the
read-only attribute from the spring ex
transactional annotation so it's kind of
a actually longer named version of the
standard transaction annotation in
spring you could choose a shorter name
right just call it my TX or just TX you
could choose a name as short as possible
if you if you like to it this annotation
here really clears the read on the
attribute if you pay close attention
here the read-only attribute does not
declare an default there's no default
for this annotation attribute here in
Java language rules right no default
statement what does this mean
everybody using your transactional
tation has to choose a value for the
read-only attribute so any use of at my
transactional has to explicitly say
read-only equals true or read-only
equals false which just means you're
forcing your users to set a to set a
concrete value to reason about the
read-only nature of of this transaction
of this transactional scope and to
explicitly indicate read-only Ness
otherwise it's too easy to forget and
everything's read-only false by default
so it's about guidance to some degree
it's about guiding the user they allow a
development team through the use of
annotations through the use of custom
annotations by allowing them to change
some things but not others through
forcing them to set some attributes but
not others because a transactional has
plenty of attributes the only one were
read eclair in his read-only so no
timeout change no propagation behavior
change no as relational level change
just the read on the attribute but that
has that one has to be set all right
a for the to feature you can't become
more explicit here you can choose to
declare at Alliance for annotations this
this annotation allows you to
explicitly say that a specific attribute
read eclairs some other attributes
pointing to the type to the annotation
type where the original attribute lives
and indicating the name of the attribute
this can be a way of
self-destructiveness rather it can be a
measure to take just to make it more
obvious what actually happens here if
the previous example on the previous
slide was a little too conventional for
you this might be more a more explicit
way of expressing the same relationship
it also allows you to change the name of
the attribute so my session scoped has a
scope approximate attribute called mode
not proxy mode we are pointing to the
proximity attribute but our local
attribute is named mode of course the
naming convention would otherwise force
you to call it proxy mode the read-only
attribute down here is actually the same
right it's just explicitness explicit
metadata saying I want to overwrite this
attribute of dead annotation here thank
you in a complex composition scenario
where many meta annotations live on the
same custome notation it may also be a
way to isolate the defect so the moment
that you're saying I'm pointing to this
specifically declared attribute over
there it's only really overriding that
one if there is a read-only attribute on
any other meta annotation it does not
matter this one will not override it see
also isolating the effect of the
redecoration scenario all right so much
for composite annotations a change of
topic to configuration classes I suppose
most of you have seen them in one way or
the other in the end they are just
regular spring components with a special
role in the container because each of
those configuration classes allows you
to declare add pin methods they are
fundamentally a container for editing
methods in their own right
so a configuration class is an instance
the managed instance in spring can have
its own auto wired fields and so forth
the tests can have state of its own but
its purpose is to contain
those factory methods that add
additional pin definitions to the
container so in a typical modern-day
spring configuration scenario you have a
selection of configuration classes which
combined make up the configuration of
your system no external metadata beyond
those possibly except maybe for
component scanning so a typical modern
day spring scenario has some
configuration classes and some
components can instructions where you're
just searching the class path for
annotated components like at service at
control and the fourth component
stereotyped spring components and auto
register them right so configuration
classes and component scanning has a
pretty immediate relationship in this
often being combined with component
scanning the container will create your
components through regular constructor
invocations if all constructor or
annotated or to our constructor whereas
in a configuration class scenario it's
about factory methods
every time the container needs to create
a new instance of your being it's going
to call back to the factory method that
you are declaring here the name of the
factory method is the beam name right
any other meta data sits at the method
level in this case we are session
scoping it so we are going to get an
invocation of this method for every new
session where that component isn't
present yet configuration classes can do
many things between methods can refer to
other admin efforts the container
understands that a call to another admin
method is a symbolic call so it's going
to intercept it and it's going to use
the right instance it's going to in case
of a singleton use the singleton
instance now create a new one so there's
a call out to another factory method
like indicated by the book admin
datasource call in there is specifically
handled in configuration classes and
configuration classes are a container
for common configuration instructions
right for common configuration
Arrangements like at a naval transaction
management and the naval annotations are
about activating certain container
functionality out of the box in a in an
explicit opt-in way but in a
a convenient way very convenient opt-in
way so in spring you typically get would
you declare right it's a company it's a
what you do what you do what you define
is what you get approach we not automate
automatically registering a transaction
manager or a thread pool or anything
else for you you need to opt in if you
want transaction management say at an
able transaction management once in your
configuration arrangement declare a
transaction manager based on the
conventions there and the rest will be
taken the framework will take care of it
right at profile above is an example for
a condition and both the at enable story
the attend a plantations and the
conditions can be found in boot in
spring boot heavily I mean spring boot
is basically conditions and at enable
annotations on steroids it really shows
you how far this can be taken so if you
want to see the full power of the spring
framework for configuration class model
in action just have a look up at how
boot works how some of the boot
configuration classes are designed the
condition model is extensible boot makes
heavy use of that it doesn't have to be
aesthetic as reacting to a profile
setting and at enable is a freely
composable model you can build your own
at na plantations spring boot in
particular ships quite a few of its own
at enable annotations but it's all built
on the core spring framework
configuration class story alright a
couple of variants again configuration
classes are regular Java classes regular
spring component classes and therefore
regular Java classes so they can use
inheritance because easy enough to do
right from our perspective it's more
like the other way around we let them be
regular Java classes what do we do if
you if you use inheritance right well we
try to derive natural semantics we're
going to go through the inheritance
hierarchy and find 18 methods for you so
if you have a custom map occasionally
class extending a base class that base
class happens to have a bin methods then
you are my application and fibulas is
going to inherit all of those you can
selectively override
of those ethnic methods otherwise you
just inherit the factory method from the
base class right so it is Java
inheritance at work selective overriding
if you choose to do so
you can of course also have abstract
base classes right leaving some factory
methods without a body and defined
abstract allowing you to compose
configuration fragments where the
concrete subclass substitutes some of
those points to arrive at an actual
concrete configuration arrangement so
configuration classes are pretty
powerful tools they are Java classes
after all in spring framework for the
two we are applying the same reasoning
to Java eight default methods what do we
do if you choose to declare a
configuration class that implements an
interface look at the implements class
my pocket in config and in the interface
you chose to declare some default
methods Java a default methods methods
in an interface with a body obviously
not accessing any state it's an
interface but with a body well we do the
obvious now we find them for you
we need to explicitly find them we find
them for you we automatically register
them for you just like if they were
present on the base class so it's now
another tool in the configuration class
toolbox you may choose to move some
common admin definitions into
configuration interfaces with default
methods your concrete class could then
implement more than one of those
interfaces right implements my pocket
min config and my system config you
could implement several interfaces to
get a multiple inheritance scenario not
arriving at any state clashes just
getting all those admin methods
according to the standard Java eight
default method rules and just collapsing
them into one configuration class which
may selectively overwrite some of those
or not standard Java eight language
semantics applied to the spring
configuration class model
alright a couple of other little nuances
did you know that you can auto
configuration classes it's new in for
the two as a kind of special purpose
thing to do right if you have several
configuration classes and you find the
configuration classes themselves through
component scanning in the class path you
don't actually have a well-defined order
the class path iteration may almost have
an arbitrary order
there's no well-defined order from class
path resources in particular if you
change the JVM or upgrade to JVM to a
new from like 7 to 8 you might get a
different order
what if you actually rely on ordering in
some specific arrangements what if some
configuration class needs to be
absolutely needs to be executed and it
spins
needs to be instantiated before that
other configuration class because you're
setting up some static state you're
initializing some whatever resource
underneath that needs to happen first
you could use standard Spring means you
could to some degree even use injection
relationships or depends on
relationships but you could also simply
order your configuration classes
throughout all the notations spring has
a comment at Auto notation has had it
for a long time and it's almost
universally used many components in
spring can be naturally at ordered even
configuration classes that's the way to
look at this if you happen to express an
oath on configuration classes we're
going to take it into account and always
initialize the one with the lower order
first and in this particular case that
was even for name based overriding if
you spotted that right because there's a
same named method in this case name
based overriding applies and the class
above has the most special version that
means to overwrite the other so it
always needs to come after the other
because latest one last one wins with
name based overriding but there may be
other reasons why you're doing this
right slightly different topic injection
points in spring the design of injection
points an injection point is the
simplest one that we've seen is the auto
wired constructor right and auto wide
annotation on a constructor asking for a
specific dependency to be injected there
could be a number of dependencies you
can have any numbers of constructor
arguments after all each one of those is
going to be resolved individually the
most important part is that the type
really matters so if it's not just a
regular Java type if it's a generic type
structure if you say this my pocket bean
service here once a man repository of
account what does this really mean and
how does the framework react to it in
traditional Spring Framework 2 and 3
we've only really looked at the primary
type and in addition to the primary type
we resolved qualifies matched qualifies
for use some additional metadata that
suggests which my repository you mean if
there's more than one right the problem
only really manifests itself if there's
more than one my repository
implementation in your context in your
context more than one mine repository
assignable bean definition doesn't
matter whether there are the classes on
the class path just matters what's
registered with the spring application
context all right if there's more than
one it's a good idea to use generic
types generic type variables let's
assume that my repository has a type
variable that's substituted with a count
here as of spring filmic form we're
taking the full generic type structure
any complexity and level of nesting into
account we're going to find an
assignable match based on the generic
type as an ability rules in the Java
compiler so we're going to look for
matches for the parameter type we're
going to find to my repositories first
among those candidates the my repository
of accounted the my repository of
product just suggested by these admin
methods up there probably living in a
configuration class in a different
corner of your application code base but
they need to come from somewhere so
let's assume the 18f
we find both of them then we take the
generic type structure into account and
we find out that only one of them
matches our declaration there's only one
my repository of account in this case
it's even an exact match
it actually works with assan ability
rules so even if the one above is a mine
repository in pull off account which
happens to be assignable to my
repository of account that's okay it
just needs to be assignable so we're
going to do the right thing and choose
tomorrow account repository above for
you without any extra metadata no
qualifiers involved in Spring Framework
3 you would have had to add like an add
qualifier account down here in the net
qualify account up there or some other
arrangement that hints at which one you
wanna pick but now it's about the type
declaration if the type declaration is
expressive enough and sufficient to
resolve the dependency then that's all
you need to do in spring framework for
world we're on a mission to explore the
type structures to the best possible
degree and to avoid extra metadata
wherever possible if the type itself is
expressive enough this is one of the one
of the one of the examples I have in
this presentation there's another one
coming all right
so generic type structures can of course
also be used in combination with for
example collections what if your
injection point down here declares that
it wants a list of my repository of
account well simply enough we're doing
the obvious thing for you hopefully
obvious you said you want all my
repositories of account collected into a
list that's exactly what we're doing
we're going to look for all my
repository bin matches my repository of
account
images in this sketched scenario here we
find two of them we're going to build a
list and collect them into a list if you
happen to give us at all the values like
like we have before I add all the values
next to the pin declaration point
we're going to preorder them for you
into a list where the account repository
Y is going to come before mine my
account repository X and we're going to
inject that list into your constructor
of course that works with arbitrarily
deep structures and it's again and as an
ability role if the Java compiler would
allow you to assign the target pin to an
element of that list then we consider
eight the match and in are going to
include it in the list a nice little
variant again a recent spring from a
feature is laziness of injection points
so in this case again a regular my
repository of account not a list but
this time we're saying please give me a
lazy reference to this my repository of
account
what does lazy mean in this context lazy
can be put at declaration points right
it's all it's actually also up there the
factory method has a net lazy at least
yet the beam method level has the same
effect as at lazy at the stereotype
level at the component type level it
suggests that the container will please
create it as late as possible it tells
the container to not created up front in
particular if it's a singleton that
really matters it it's not created on
startup it's created the first time
somebody is trying to obtain a reference
to it while trying to obtain a reference
to it is exactly what is constructed us
and semantically a regular injection
point is asking for a fully initialized
version of the dependency of the pin so
if you have a regular my repository of
account injection point you basically
cement the same it needs to be fully
initialized I insist on it with it lazy
you're expressing that it's okay if the
target pin is not initialized yet you
just want an invoke it'll reference you
don't want a fully initialized State
over there yet so it changes the
semantics of the injection point what
you will what this will result in is a
lazy initializing proxy it's a proxy
implementation
you're my repository the first method
invocation under the proxy we'll going
is going to trigger the actual
instantiation the actual creation of the
target pin but chances are that you're
not going to invoke it right away you're
going to store the reference in some
field and you're going to invoke methods
on it later on semantically at least is
a good idea in that context and in some
scenarios it may make an enormous
difference you could even break cycles
between beans that way a cycle between
being a and B and another reference from
in B back to a is only a problem if both
ends insist on a fully initialized other
if one of them says I'm okay with the
reference a lazy initializing reference
the cycle is not really a cycle anymore
at least not in terms of resolve ability
at runtime just in just the conceptual
cycle please avoid cycles between
components but if you happen to have
them they might also come implicitly you
know through some role of your
components and listen the role of your
components there are many reasons why
you might end up in a cycle one way or
the other right so at least it can do
this for you and it's a simple little
innocent-looking annotation next to the
parameter type of your constructor
that's all it takes
alright variants of annotated components
in in spring include components where
you intentionally choose to not use any
spring inputs not use any spring
annotations so spring traditionally
supports standard Java X dot something
annotations some of them shown here like
managed bean as a simple stereotype
coming out of chaser 250 at inject as a
replacement of at Otto Wyatt maybe not
quite as readable a more like an
instruction in terms of its naming but
it has the same purpose essentially and
pre destroy is an example for a
lifecycle a notation also coming out of
chat 250 so if you use them in your
components spring is going to auto
detect they use the presence and it's
automatically going to react to them no
need to configure anything extra really
so it's your choice some components may
use standard annotations some may use
spring annotations
you may even mix and match Java X
annotations and spring annotations in
the same class so we we implement them
as individual concerns so you may use
@inject with spring stereotypes or at
auto wired in this context here no
problem at all your choice a nice little
variant that works best in this context
here is our support for optional also a
pretty recent Spring Framework feature
optional it's a Java 8 type Java util
optional you're basically saying look at
the constructor here you're saying I
want a my repository of account but if
it's not there I'm ok with it Java util
optional is one way of of sending that
signal declared this optional of non
repository of account then spring is
going to understand that you're saying
that you want a matter post area of
account we're going to look for it if
it's there you're going to get an
optional handle pre-populated with that
reference if it's not there you're going
to get an optional empty reference and
based on the Java util optional
signature you can then react to the
presence or non presence of that target
pin in your constructor implementation
it's your choice right we're not forcing
you to use optional you declare optional
we react to it again about the
expressiveness expressiveness of the
signature
you said optional we know what optional
means actually in a in a standard at
auto wired world you have a another
option you could say at Auto Wyatt
required equals false in which case
you're injected references will be null
if the target pin is not there with no
matching Venis there so there is a way
to do this with Senate spring
annotations you can also combine
optional of course with a thought oh I
had no problem with that but at inject
Java X dot injected inject doesn't have
a required flag so optional is
particularly useful in in this context
all right while we are with Java AIDS
why not talk about Java the time quickly
this is a different scenario again we're
not in an injection point world at the
moment we are or anymore actually we're
now in a data binding scenario so spring
getting some input data from some text
representation request parameters or
wherever else and trying to bind it to a
target class in this particular scenario
Spring has a binding and formatting
framework doing that work for you I
highly customizable one that framework
reacts to the types of your fields and
your properties we're seeing annotated
fields here where they come out of to
come from the Java toad time package in
Java 8 so those are Java 8 date/time
types one of them is declared as a local
date the other as a local date time and
they come with at day time formatting
notations spring at day time for
mathematicians yet not null and net past
actually supposed to come from the pin
validation and our GSR here they happily
live next to this so the at date-time
format annotation on the local date/time
field below specifies a pattern right it
says here's a parsing pattern and the
rendering pattern please take this into
account
if a text representation is being bound
to it or if the field is being rented
out to a text representation so all's
good because that pattern is pretty
individual can be pretty individual
anyway the local date field above the
birth date field doesn't have any
special binding rules you could assign
an edit a time format in this case
saying at day time form it is a date
standard date parsing rules however you
don't have to do this because the type
itself is actually expressive enough you
set local date we infer the is owed a
parsing from that type so you can just
omit the data and format annotation
that's why it's commented out you can
just drop it the type itself is
expressive enough you only need to add
to add formatting and binding
annotations if the type itself isn't
expressive enough so in the
the case of java.util date and java.util
calendar you almost always have to add
them simply because java.util date
doesn't really say what it is is it the
timestamp they add a plus time within
the day completely unclear really
whereas the Javadoc time types are
pretty expressive in terms of what they
are local date local time local day time
sound day time or instant they say what
they are
so they imply some parsing and rendering
roles much better than Java util data's
by the way this also works with
joda-time
actually it's in Spring Framework 3
already this is folded l+ but you can
still do it with Joe Dirt ham right if
you happen to use the Joe doe time types
they have the same names even for those
two here we also ought to detect the use
of those types and apply the same kind
of rules
it's your choice in the end we can do
the same as of photo 2 we can do the
same even with the chaser 3 5 for money
and currency types so if we encounter a
binding scenario where you are asking us
to bind a text representation to a
monetary amount field from the Java X
dot money package we're going to we
automatically detect that's what you're
using is Joseph you have for money and
currency here and we invoke the
framework the rendering binding and
rendering framework that comes with the
chase our unless you are adding a
specific formatting annotation in which
case we of course are going to honor the
instructions that you give us there so
the base price is going to be parsed
with the standard set up in a energy
official for money and currency provider
whereas the net price field below comes
with a number format annotation it's
going to be parsed exactly according to
that number format representation same
ideas with the Java totemo to all the
time types so that's pretty new because
Joseph e54 is pretty new it's only went
GA in April we shipped this in July here
so the timing just about worked out
Java 8 again quickly in to more subtle
usage scenarios at async types in spring
have a well well-established meaning of
course call comes in we are going to
intercept it wrap it into a callable
pass it on to a thread pool that you
configured you said it enable async
somewhere if you're using Java based
configuration and you specified a task
executor somewhere afraid pool
processing this so no automatically
setup but if you set it up once you can
use at async all over your code case and
that's the semantics that you get async
behavior on invocation since this is an
asynchronous invocation if you want to
have a relationship connection back to
your caller you can return the future so
a regular future handle a listener a
future handle in spring or as of Java 8
the one in the middle a completable
future completable futures a Java 8
Edition it's actually a concrete type
not an interface it has plenty of
methods that allow you to go to compose
to combine several futures into a
combined future and that sort of thing
to react to the outcome in a nice in a
nice follow-up way as of current spring
framework for the two we allow you to
just declare a completely future we
understand that that's what you're
asking for and we automatically take
that into account build a completed
future for you return it to the caller
the implementation of the async method
needs to return its outcome its value
its result as a completable future as
well
syntactically because that's what the
return type is and completable future
for that purpose even has a nice
completed future factory method whereas
with a standard future you need to use a
wrapper like this is incredible so it's
actually pretty nice if you're using
complete of the future there
automatically works if you're using
spring for the two on Java 8 and declare
your return type like that
at schedules below so also has a little
Java eight twist it's a it's a cron
trigger right a callback for that method
every time to create the trigger fires
the method is supposed to be to get
invoked but in this case it's not one
country gets to through to add scheduled
annotations
well semantically not a problem right
just two triggers however according to
the good old Java 5 annotation rules you
can only have one annotation of a
specific type on the same effort or the
same field
constructor whatever same element
semantically you want to hear and as of
Java 8 that's exactly what you can do
just another at scheduled annotation
because we declared that scheduled as
repeatable a new concept in Java 8
repeatable annotations annotations can
opt in to being repeatable so you need
to specifically declare them to be
repeatable that's what we did for
selected spring annotations in the
spring framework for generation you can
just use it like this on Java 6 or 7 or
with annotations not declared as
repeatable you would have to have a
break by notation that can add schedules
with nested at scheduled in in an array
pretty ugly this is much nicer and much
more natural and even Java 6 7
compatible honestly you can't use them
in a repeatable form there but the same
spring framework for the 2 version of
had scheduled works in its regular form
on Java 6 and 7 still but on Java 8 the
repeatable nature is being understood
alright so for the remaining quarter of
the presentation let's move on to the
endpoints the endpoint model in spring
is pretty well established probably the
most well-known the web endpoints HTTP
endpoints I suppose most of you have
seen this one way or the other so we're
not going to dive deep in this
particular example into this particular
example but just a couple of things to
note here from a design perspective it's
a regular Java class has a stereotype on
top here it says at rest controller
which is a spring stereotype meta
notated with that component spring
understands that
even gives the general crossorigin
allowance here but let's ignore that for
the moment or for the purposes of this
presentation and it has a couple of
mapping annotations methods so called
handler methods with a mapping
annotation that indicates when to call
that handler method or where to bind
that handler method to depending on how
you want to see it
request mappings in spring MVC adjust
HTTP mappings binding to NHB HTTP path
potentially assign associating
themselves with restricting themselves
against a specific HTTP method would be
good that he actually to do that for the
second mapping down here as well if you
want that to be a post why not say
method post and restrict it that way and
nested parameter notations so have close
look at this find book method it says
find book once a path variable long ID
this is a parameter in spring embassy
and in general spring endpoint models
you'll you have mmm the kind of
analogous use of parameter notations per
request values are typically injected as
parameters because a controller is
typically a single so it's shared state
applies to all requests can have
references to other components and so
forth but the per invocation state is
typically request specific in this case
we want to extract the value from the
path where we have this ID binding
variable this path variable in there
through the add path variable annotation
we are well we are instructing the
framework to do the right thing right
this is a long I want you to get it out
of this path variable with the same name
extracted and converted for me place you
could say at request parameter request
header at cookie value there are
different string or simple types to get
out of a request the parameter level and
notation indicates which one it is and
it also adds to the readability if you
look at this piece of source code you
understand what it does to just looking
at it right the find books signature is
self explaining yet path variable
annotations actually seek
be contained in the source code not just
the runtime hint this long IDE parameter
is the puffer blur it's a path variable
of type long and name ID reads pretty
nicely let's have a look at some
endpoint variants that you might not be
as familiar with if you're using the
stomp messaging protocol typically but
not necessarily on a WebSocket channel
the corresponding endpoint model in
spring code this is actually spring from
a for core functionality Oh oops
what's that I'm sorry for some reason
Open Office decided to just to just
close itself another check oh no I'm not
sure what it is but windows background
updates
well unfortunately it's probably going
to install I don't know 15 updates now
so I'm not exactly sure how we get out
of this here
does anybody have a laptop now I'm
serious this is actually a little bit of
a pain I tried to prevent it by yes of
course that's what it does right oh okay
well I'm going to complete the story in
some other ways and give you some we
were almost done anyway to give you some
some insight into the endpoint design so
what you've seen where remember when
messaging notations message mapping
annotations the consistency consistency
in Springs endpoint model is actually
about the style the that you're using
the mapping for it
it's called collar ball handler methods
each handler method has a mapping if the
mapping is soon HTTP path that's what
you've seen if the mapping is to a
message path that's to Train message
binding a message ID a an incoming
message queue or topic that's exactly
what your message mapping annotation is
going to express in terms of extracting
values from this per invocation state
you can typically extract the message
payload our design guideline is simply
to take the spring MVC endpoint model
and to make sure that the consistency
the readability that you're used to when
you're looking at spring MVC endpoints
translates very naturally very well to
the annotated endpoint maps you can use
this with stomp endpoints you can use
this with GMS listener endpoints you can
use this with event listener endpoints
and you're going to find yourselves in
familiar territory that's the whole
point of the endpoint design arrangement
the extension of it can be found for
example in spring integration even
spring integration has an endpoint model
and message endpoint model that's very
consistent even the spring AMQP project
with rabbit listen annotations has an
endpoint model that is consistent with
this design philosophy well in terms of
what's the reason feature here for JMS
listeners actually a for that one
feature and event listener for the two
feature so some of this stuff is pretty
recent our mission at the moment is to
complete the picture to complete the
programming model this means that we are
trying to identify gaps some things you
can express in one version of the
endpoint model but not in the other some
things you can do with JMS endpoints but
not with the entropy endpoints or the
other way around and we're trying to
make that as consistent as possible this
is actually something that we're working
towards in full of three
so in folder three if you are aware of
some subtle incompatibilities between
the endpoint models design
inconsistencies rather that are not
justifiable through the use of well the
particular technology meaning there's no
good reason for it right I mean some
things are different between GMS mqp
and stomp there are different messaging
protocols they have different
destination binding rules some things
have to be different those annotations
are specific annotations particular for
the reason that they aim to take the
target technology take the full power of
the target technology and kind of find
to it in a natural form right so if
you're binding to an HTTP endpoint you
talk you know that you're binding to an
HTTP request if you're binding to a
stomp message you know that you're
binding to a stomp message or a stomp
subscribe instruction if you're binding
to GMs you know that that's what you're
doing you know that you need to be
specific about the cue or topic that you
can use message selectors our endpoint
design our endpoint annotations lets you
do those things work as closely with the
technology as you like to at the same
time having a design consistency you can
see where we're going with this right in
spring framework for the three we have
about 150 issues collected already in
the in JIRA so you can have a look at
kind of tech
that we are already aware of the little
fine-tuning that we already intend to do
there if there's anything we're missing
or if you have any particular favourites
let us know comment on JIRA vote on JIRA
we are taking that into account because
we do aim for a release candidate in
well at least in early April GA target
kind of late May
end of May next year it's not that much
time really and we are working with an
existing spring framework for
arrangement so we are not going to do
anything radical we're just going to
find him the model as much as it's
needed in practice right and springtime
ak5 has an opportunity to be a little
bit more aggressive in some corners all
right so that's really what we're
working towards as a kind of follow-up
to the design discussion I hope that the
little design story even if it ended a
little abruptly kind of make make sense
in your ears I hope that they have
there's been something in there for
every one of you I'm pretty sure that
hardly anyone if you will have known all
of those variants some of them are
really pretty recent and not that that
commonly known I'm happy to take any
questions since it's an opportunity all
right if we if I can show you the
remaining three slides I'm going to let
you ask a question or two in in this
forum here are there any questions about
the presentation about the spring
roadmap anything that you have on mind
at the moment any takers
otherwise there let me invite you to the
spring bath tonight 7 p.m. if I'm not
mistaken there's a dedicated one our
spring buff session that allows you to
well have a discussion raise questions
or participate them just listen to the
discussions that we're having there it's
largely going to be about the coming
roadmap about for the 3 5 to the plants
but we're also willing to discuss any
kind of well any kind of spring issues
really so if there's anything you would
like to raise with us where it makes
sense to have a discussion in the group
about it rather than an individual
discussion please come to the buff and
raise it if you want to approach us
individually we're around not just
myself but also a couple of colleagues
of mine Stephan Nichol brian kocel and
oliver kicker so if you find us around
at the pivotal pouf or anywhere out
there please just approach us we're
happy to talk about anything spring or
anything Java really well one more
opportunity to raise a question that we
are covering here otherwise one quick
forward-looking note from my side our
Spring Framework five mission for next
year is closely aligned with JDK 9 if
you have an interest in JDK 9 the module
system is presented in today's keynote
then please if you're a spring user
right or having spring interest let us
know what you expect to work for you
here Spring Framework 5 is going to be
JDK 9 based out of the box so doesn't
really have that much impact onto the
component model itself however it does
have impact obviously on the spring
modules we'd like to ship them with JDK
9 module metadata even more importantly
we would like to allow you to declare
your components within a JDK 9 module
arrangements and to let spring naturally
understand
understand it and handle it doesn't
really mean that much in terms of the
framework itself it's more about
allowing you to refer to this framework
- the framework artifacts through gdk9
module
names and module metadata there's more
than gdk9 phone there's a new HTTP key
HTTP client plant we intend to allow you
to use this new gdk9 HTTP client
everywhere in spring where an HTTP
client is used underneath the covers for
example interests template so if you
have any interest in that combination of
technologies by all means let us know
it's a little bit early still we don't
have a spring framework 5friends yet
just a prototype project and R&amp;amp;D project
for our reactive efforts different
feature theme in spring time ik five
we're going to create the spring time ik
five branch very soon now so we're going
to build it onto the key nine snapshots
from day one and we'd like to include
quite a bit of the JDK nine feature
coverage out-of-the-box so if you're
willing to give that a try
TJ de canine team wants you to give the
JDK nine snapshots a try we want you to
give the spring from ik five snapshots a
try on JDK nine once they are out so
it's a particularly mutation if you have
some spare time that you where you spent
the time on preparing for the future
that combination of technologies would
be a great candidate all right well then
thanks for your attention thanks also
for your extra attention after the
disruption enjoy the conference and see
you at the spring off of the cure for it
Thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>