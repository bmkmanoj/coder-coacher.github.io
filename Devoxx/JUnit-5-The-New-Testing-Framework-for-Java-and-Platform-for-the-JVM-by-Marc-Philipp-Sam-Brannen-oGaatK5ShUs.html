<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JUnit 5 — The New Testing Framework for Java and Platform for the JVM by Marc Philipp, Sam Brannen | Coder Coacher - Coaching Coders</title><meta content="JUnit 5 — The New Testing Framework for Java and Platform for the JVM by Marc Philipp, Sam Brannen - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>JUnit 5 — The New Testing Framework for Java and Platform for the JVM by Marc Philipp, Sam Brannen</b></h2><h5 class="post__date">2017-11-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/oGaatK5ShUs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so welcome to the talk on jayna
five today we're going to talk to you
about how jayna v is both the new
testing framework for java and
simultaneously a new testing platform
for the JVM yeah a couple words about us
I'm mark Philip I work as a software
engineer for lock me in and Karlsruhe
Germany I've also been a consultant
trainer and coach him a formal life I've
been in China maintainer since 2012 so
so the old Jay in it
I also Jamie's keeper of the green bar
which is a fancy title for the project
lead for the last two years and here's
my twitter handle make it a background
and my website in case you want to reach
me after the conference
a couple words were logging in we have
about 3000 employees and 18 offices
worldwide to RIA sauce company so we've
products like GoToMeeting or LastPass
you might know those in the back end for
a mostly work we do micro services
mostly with Springwood and Tucker and
hosted in the cloud using AWS and yeah
do DevOps okay so my name is Sam Brennan
I'm a spring and Java consultant at a
company called Swift mine in Zurich
Switzerland um
trainer and coach but a hardcore
developer at heart I've been a Java
developer for about 20 years
cork emitter for the Spring Framework
since 2007 once I took over the testing
support and I maintain that even today
and the main reason I'm up here today
with Mark is that I'm also a corps
commander for June 5 since October 2015
few words about my company we're experts
in spring Enterprise Java spring
portfolio in general Dana 5 obviously
know right Java EE stuff like that if
you need help with code reviews and
stuff like that get in touch with us so
the agenda for today first off we're
going to talk about the impetus for
change why we have a new version of Jane
it and then we'll dive into Jane unit
itself some about the architecture some
examples we'll have some demos and some
live coding and then I'll briefly talk
about some of the integration with
spring and at the end of it we'll have
time for Q&amp;amp;A but if not we have a Boff
coming up later this evening so you can
follow up there as well so first up show
Vance who's writing tests I guess
hopefully everyone all right who's a
writing unit tests yeah integration
tests
okay system tests and in tests fewer and
fewer hands okay who's using a framework
called j-unit for testing most people
okay JUnit 3 anyone whew
sorry Souls okay Jana for I can see what
everyone all right for 12 yeah the
latest and greatest not everybody okay
what about Janet Jupiter or Jane in five
anyway okay only five percent so that's
not bad anyone using like testing G like
that
the alternatives Spock anything like
that okay so mainly Jane it for all
right so the question is why do we have
a new version of Jane yeah that's a good
question so here are the reasons first
of all Jim before was released a decade
ago so it's more than ten years old and
a lot of change since then we've all
grown older and the testing needs to
also have matured and in particular the
expectations of grown so j-unit
sounds like unit testing but it's
actually used for more than that and
especially for integration testing you
need to have different extension
mechanisms in place from and you expect
that from such a framework in terms of
modularity that's just one jar file
right so as a maintainer it's impossible
to know which part is used by an IDE or
by a test author and especially since
test discovery and execution are tightly
coupled it's really hard to evolve the
old a unit so it was really hard in
terms of extensibility they also was a
lot of room for improvement as we'll see
in a minute and let's not forget about
Java 8 in Java 9 and all the nice new
language features that those will bring
or have brought already and we want to
use that also in the testing framework
and enforce still backwards compatible
with Java 5 so that's that's one of the
reasons as well so extensibility there's
the training for run or API which is
very powerful you can do almost anything
but you couldn't combine runners so in
case you want to use permit Erised
with the spring runner well you're out
of luck there's no way to do it then
also in a later versions unifor
introduced rules and rules you know are
meant to be broken
of course you can read that sentence
yeah in whichever way you but you would
like to
so this method rule so that wraps around
the execution of a test method there's
also a class rule annotation that as you
wrap around the execution of the whole
test class this is really great for
simple use cases like reusing as test
fixture but and they can even be
combined yeah and they're designed to do
that actually however a single rule
can't be used for something to do
something on the method level and on the
class level at the same time and there's
zero support for instance number called
X so for Sam here actually to write two
rules spring class rule and string
method rule if you wanted to use rules
with spring and users have this awkward
setup where they have to declare both of
them in the in the test class so that's
not really great so all these reasons
brought us to adding a crowdfunding
campaign in 2015 initiated by Johannes
link and me and ya later Matthias and
Stephan and Sam here joined it ran from
July to October 2015 and we collected
over 50,000 euros from almost 500
individuals and companies and also later
four companies donated six weeks of
developer time so we had at least six
weeks to get started so thanks again to
all the people who contributed all the
companies that was really great support
and what we did first was then to have a
kickoff a whole week of kickoff meetings
and we brought together the new team
basically so we hadn't worked together
before but also people from IDs and
build tools to get their support and
their feedback and to decide what's next
for teh unit so I handed out to Sam what
was next for J unit good question
all right so where we went from there
kind of the road map so we started off
with a prototype we actually started on
it that week and we continued on that
until to the December then we ended up
releasing an alpha release on the next
year based on feedback from from the
prototype and then we had several
milestones I think six in between and
then a couple of release candidates from
July 2016 and August 2017 and then we
had GA released for 500 back in
September this year and 501 released in
October so last month and right now
we're working on 502 that should come
out maybe in
week or two and then the first milestone
for five down moments and new features
coming out soon ish as well so what is
to five in a nutshell it's several
things so first off it's modular you'll
see that later on with the architecture
and the diagrams and stuff like that
it's also extensible right so we have a
new extension model which we'll look at
we like to think it's modern it's least
based on on Java 8 so you can use stuff
like land expressions and stuff like
that and another key feature the really
talked a lot about is making it both
forward and backward compatible at the
same time so what does that mean well we
knew we had to support older versions of
Jane it new version to Jane and other
testing frameworks so the platform
itself now supports all of these at the
same time and new testaments can also be
run with the old Jane for infrastructure
so for example if your IDE or your bill
doesn't your support on the Jaina
platform you could use the old at Rome
with annotation from Jane for in this
Jana platform class here to actually
launch the platform with Jane for
infrastructure in terms of Java versions
obviously it's based on on Java 8 as the
baseline but you can of course a test
application code written in another
version right so maybe your applications
written Java 6 for Java 7 but you can
write the tests on Java 8 that shouldn't
be a problem
Java 9 so works fine on jdk 9 you might
have heard that from Mark Reinhold right
so we've already tested JUnit 5 on in
Java 9 and every artifact in fact has a
stable automatic module name in it
already and we're adding a module path
scanning support coming in 5.1 in the
first milestone Java 10 can't say too
much about that yet we just started
building against that last week and
we'll be waiting on some some
dependencies to upgrade so they're not
checking the wrong version numbers and
stuff like that ok so this part here is
really crucial
this Jana 5 equals the platform plus
Jupiter plus vintage and what does that
mean I like to say there actually isn't
a JUnit 5 so why are we standing here
talking front of you
Junya 5 it's actually kind of an
umbrella project and along the way we
realized that we were actually inventing
kind of three separate entities so first
off we have the platform released at
version 1.0 and that's a foundation for
launching any kind of testing framework
on the JVM and it has a launcher API and
a test engine API for that
also has console support so plugins work
for a grave gradle in maven and the next
thing is Jayne at Jupiter and this has
the number 5 do so you might consider
this Jayne at 5 right that's actually
the new programming model in extension
model for show unit 5 that replaces how
you would have done in Jayne at 4 and
the last part we have the last piece of
the puzzle is what we call Jane at
vintage vintage we thought about calling
it legacy or retro or something like
that but basically it's the support for
running Jane u3 based tests and Gen 4
based tests on the new platform
infrastructure so you can run all these
kind of tests all at the same time and
have them all reported together so this
first part like to point out again this
is basically revolutionary right this is
never really existed before people kind
of use J and it for like that but it
wasn't the goal or the plan behind the
architecture JUnit 4 and with a Jana
platform now it is actually the idea
that anyone can build upon this this
basis here the next up is evolutionary
right so kind of building on the
learning experiences from Java JUnit 4
and other things out there like Springs
testing support and stuff like that and
the last part we say is necessary right
because we want to make sure people can
continue to use their existing test
bases and use it on the new platform so
this launcher API it's used by the IDE s
typically or a build tool to actually
launch the framework and it's the
central API for discovering the tests
like finding the classes with test
methods in them and actually executing
those tests your one or more registered
test engines and for that we have what's
known as the launch or discovery request
what that allows you to do is basically
on select things like select classes or
select packages or select individual
test methods and then also filter stuff
out right so based on class name
patterns or tags or engines and stuff
like that and then in terms of getting
feedback there's a test execution listen
your API so you can tie into that to
basically generate your own reports if
you want but that's also how to build
tools and IDs get information about the
execute and test plan and the last part
here is this console launcher so you can
actually run or launch the entire
platform from the command line if you
want to build that in some kind of
scripts so this test engine API it's
kind of like the runner from Janie 4/5
remember that it's responsible for
discovering tests and executing them but
particularly for one particular of
programming model so like just the Jana
Jupiter model or just the chain of four
and Jana 3 program models or something
else
and the way these are registered that
happens automatically with the service
loader mechanism from Java so we have
one for Jupiter to protest engine so the
new kind of j5 stuff we have one for
vintage so for jigging two for and jaded
three and you can implement your own
which people have in fact done so
there's already some third-party test
engines out there so this first one here
spec C supports like Scala groovy and
Java spec is for Kotlin got a couple
others out there for interested in
seeing what people have developed anyone
can contribute to this this wiki page so
people are actively employing their own
test engines so let's take a look at the
big picture okay here we have the
platform in the middle right so that's
this whole Jana platform the new
revolutionary part and then we have the
other things building on top so we have
the vintage support up here on the upper
left and then Jupiter in the middle and
then on the right in the blue that could
be any third party that's contributing
their own test engine so as an example
here this this spec c1 and then what you
program with as a developer is what you
see on top kind of the outer surface
there and what the IDs and build tools
use they focus on the platform and they
actually don't have to know about which
engines are currently present in your
test plan so looking behind the scenes
we see if you're using them Jana
for right you continue to program
against the the JUnit for API and then
we have this vintage engine that's an
adapter between them and then for the
new stuff if you want to use the new
Jupiter you would program against the
Jupiter API and the Jupiter engine when
then end up finding those things and
running them and the same would be true
for any other kind of test engine and
then we middle in the middle we see this
new platform right so we see the
launcher API and that's what all the
build tools and everything would
delegate into whether it's our runner
for Jada for the sheriff fire support
from maven the Gradle plug-in the
console launcher all these things
interact with the launcher API and then
that in turn delegates to the individual
engines right internally so in terms of
IDs and and build tools IntelliJ
supported j25 that the longest so since
the 2016 - and I think most recently on
2017 dot 2.5 so that's good Eclipse
joined a bit later but also has very
good support now and Eclipse oxygen 4.7
one a and we'll be seeing that in the
demos and NetBeans I let the emoji speak
for themselves
Gradle so we have an interim solution
from the
team that we've written ourselves but
that's to be taken over by the Gradle
team potentially by the end of this year
and maybe early next year and the same
is um well uh sorry there's some support
of Android as well the nice gentleman in
the community has contributed that you
can check that out if you're interested
in that
maven we also have another internal
solution we've written and that's also
being taken over by the maven surefire
team so if you want to see examples for
that we will show this today but you can
see them in the user guide and the
sample apps okay so what is Janey
Jupiter as you said of basically two
things so it's an extension model and a
programming model so this is what you
need to write tests so the extension
model there's just one Marc interface
called extension and in the extension
package there's all kinds of extension
API that extend this extension interface
and you can implement as many of those
as you like and you register them using
extend with that's kind of like run with
and Jane it for days but you can use it
to register one or more extensions so
it's not just one and you can put it on
the interface or on the class or method
level so we can just have an extension
registered for one method it's also
possible now or you can even use it as a
meta annotation so what excellent
extension API is are there the first set
is what we call lifecycle callbacks so
we can do stuff before all the tests in
the class or before each test in the
class or immediately before or after
test execution
another one is test execution exception
handler that lets you post process
exceptions or in drop them there's
execution condition which lets you
specify your own logic when you want to
actually skip a test this test instance
post processor and parameters over those
are useful for dependency injection so
the first one for fields the late the
latter one for yeah parameters of
methods or constructors and there's test
template invocation context provider
which is the longest name and the most
complicated one of these we use that
internally for parameterised tests and
repeated tests but it could also use it
to implement your own test template yeah
we'll hear later about that what that
actually is so this source the extension
model the programming model now lists in
the or
an interpreter API package and yeah in
the powers package as well and when you
want to use parameterize tests because
that's in a separate artifact it
contains all the annotations like add
tests and so forth
it has assertions and assumptions of
course you need to also write tests it
supports custom display names the
visibility we're not as stubborn anymore
you don't have to make any everything
public you just diva desu
yeah the default visibility it's for its
tagging of tests conditional test
execution and also dependency injection
for constructors and methods you can use
lambda expressions and method references
with a lot of these api's we support
interface default methods for tests and
also nested test classes to allow you to
structure it has better and there's
repeated tests parameterize tests and
dynamic tests and this is just an
overview we'll see examples for most of
these in the remainder of the talk the
annotations there's a test which is the
one you'll use most I guess this is
actually the only one we didn't change
the name for because we didn't really
couldn't think of a better name
and there's also test factory that lets
you produce tests which we'll see in a
second repeated tests for meteor eyes
tests also they're nested for inner
classes test instance this one has lets
you actually change the test instance
lifecycle configure it so change for
also used the same life cycle I was
doing to build by default namely you get
a fresh test instance for every test
method invocation and test instance for
class lets you change that to a single
test instance for the whole class
there's before all after all that kind
of analogous to the callback interfaces
and before each and after each that's
also display name which lets you
customize or define a different display
name so not the test method there's tag
and Janet for we had categories tag as
if it's simpler to use disabled is
likely ignore and Jane it for lets you
disable tests rules are not actually
supported by Jupiter with a few
exceptions so we provide some migration
support as we call it and this is this
enable my true migration support which
comes from a separate module and it's
experimental so it restitch this three
extensions actually so the first one is
external resource support that as you
use all the rules at extent external
resource like temporary folder for
example there is also very fire support
the same for very fire implementers like
error collector so you can continue to
use those for a while and the same thing
holds true for expected exception you
can continue to use it but we would
encourage you to move over to the new
API that we provide to test for
exemptions and we have some minor bugs
in there and they are now fixed at least
in 502 they will be fixed at least one
we know of so yeah of course you need
assertions and they're now in an
assertions class so it's not called
assert anymore we provide a limited set
of core assertions those look familiar
from June for like assert equals source
did not know but they are also new ones
like assert throws which actually takes
the lambda so makes use of Java it
features the lambda is the plug of code
that you expect you throw an exception
and only if it throws the correct
exception this will pass there's also a
certain time out and assert timeout
preemptively that both take a block of
code that you can write as a lambda
expression the first one will just check
the timeout after the code is finished
so it will not stop it if it takes
longer but the second one or so timeout
preemptively will do that but you have
to be careful a bit if you use a
framework like spring and have thread
locals and this might break because it
will execute the code in a different
thread this also assert all basically
takes of our arcs of yeah assertions
written as lambdas so those all all
checked so imagine an integration test
where you want to check multiple things
at the end and wanna get an aggregated
report that's what I search all is for
so it's like soft assertions in a search
a if someone knows that we also support
suppliers for failure messages so
whenever you pass a failure message you
can use a string or a supplier of string
and this message is now the last
parameter and in the arguments list so
we made that change because it's
actually an optional argument and that
by convention come last this is meant to
be only a basic set of assertions to get
you started so if you want more power
please use a surge a hamcrest truth
whatever yeah and the same holds true
for assumptions which come from the
assumptions class these are useful if
you want to abort your test that has
already started like mid-flight you can
use that to define like a precondition
in your test but the test will actually
be aborted so it will be started and if
you want to really well skip the test
entirely you should rather implement an
execution condition extension and define
that logic over there this is some true
and assume false and the basic things
they take a boolean and a string but
also it pulls in supplier and their
supply off string if you fancy that so
you can also use that with some does
that's also assuming that which takes
the condition and a lambda expression
and will only execute the lambda
expression in case the condition holds
true and now we'll jump into the first
live coding demo which Sam will do okay
let's see how it goes all right so this
is using eclipse oxygen most recent one
right and we've got some demo calculator
here nothing very exciting one
demonstrates the testing part right so
it can add subtract multiply divide
etcetera division could be divided by
zero right Fibonacci could take too long
depending on which number you ask it for
so we've got an example here with sorry
I can give this one the junior for one
so the way you would have done it in
Jane at four is that big enough to see
should I make it bigger make a little
bigger okay so we've got a calculator
subject on the test we've got an
expected exception using the rule
support from Jane for the same with
their global time out and then just
touching their various things like add
subtract etc even support for checking
for an expected exception with divided
by zero and that the timeout should kick
in if we make this number bigger than
than forty or something like that so if
we just run this right it should just
she just work everything passes so
that's good that's the checking it for
way so let's see if we can migrate that
to
Jupiter okay so now mm-hmm
pick the right one that one okay so just
run again as J and at four
all right so we will want to migrate so
what can we start off with we can get
rid of the the assertions right move to
the new ones and pick the one from the
right package so I should get the one
from Jupiter right so we see the stop
analysis coming from the assertions from
Jupiter and that should still whoops did
I miss something
yes I did so why is this not why is this
not passing right why is this red why
did we mention about the messages they
now come at the end okay so if we put
that at the end then that should should
actually pass right and we're talking
about the what if this were some kind of
complex logic we wanted to build up what
if we were actually going off and doing
something else right two plus three
equal slide well if it's something that
you want to calculate dynamically you
can make a land expression and it only
gets evaluated lazily if the thing
actually fails so that should also work
all right so we've done that we talked
about visibility right so we should be
able to get rid of some some public
stuff but not on the rules because Janet
four requires that so for the methods
test methods in the class we can get rid
of public on all those and it would
start to work except it right if we
tried to do this with Janet for it's
what I gonna say there no no test
methods found right so we need to switch
the annotations a lot right so going
from the Jane at forlán to the Jane to
Jupiter one pick it from the right
package and if we run that now what
happens so the divided by zero failed
why is that that's because that actually
threw the exception and we have the
expected exception there and we need to
tell Jane a Jupiter to turn on this
migration support so now if we run that
now hopefully that will pass it indeed
does so we're using the expected
exception that's there but the timeout
isn't actually doing anything so how do
we actually see that right if we change
something like 42 and run just this test
then we see it actually keeps running
right
it didn't timeout so it ran for more
than a second yeah more than a thousand
milliseconds so if we wanted to turn
that on we can basically get rid of the
the timeout support here that's not
supported and we could do that the J and
a Jupiter way so what's what's that one
called and when pain is engine to start
timeout of adoration maybe milliseconds
something like that thousand and then
what is the executable gonna be this is
our little block of code which we can
implement as a lambda expression all
right so see we got that that's our
lambda expression and now if we run it
what's going to happen it still runs for
more than a thousand milliseconds but we
see that it failed right so this says
execution can we see that yes we
exceeded time out of a thousand
milliseconds by 400 right but what if we
wanted to actually kill it off early
right we wanted to kill it print of Li
run that in a different thread you could
do that switch into the preemptive one
and we'll see the difference now so now
it will run exactly a second oops what
happened here
so timed out after a thousand bills like
insane it didn't run any longer than
that so that's we're saying that one
gets started in a new thread so what
else can we do we can actually get rid
of the rules completely if we want to so
if we didn't want to use this this rule
support and we wanted to get rid of this
here
then how would we handle this exception
so this is the code of block block code
we want to actually execute and we would
switch that to assert throws and expect
the type is arithmetic exception dot
class right and this can be replaced
with the lambda expression not good name
though hmm the good name has to be gone
thank you
that would be strange okay so that
should actually work now we run this one
it does and what if we wanted to get
hold of the actual exception we can do
that get a hold of it
it's articles what are we expecting that
for exception get message okay so we
have migrated from JUnit 4 to Janie
Jupiter we see nothing left in here from
JUnit 4 so I believe that's good for
that yeah yeah another new feature of
text so you can declare tags on test
interfaces classes or methods looks like
that on a method so we can use that to
execute on a certain set of tests done
from your IDE or build tool the thing is
it is the strings and not class literals
anymore so you can't really search for
references sorry in case you want to I
mean we deliberately did that it was
always easier to use but if you want to
continue to search for references for
tags then you would have to use
something like this so we can actually
declare tag as a meta annotation so here
we define the fast annotation and put
tag on that annotation and then we can
write this code which is equivalent to
the code on the slide before so we have
a fast test with two annotations we can
also go one step further in compose tags
so we can dictate a tag as a meta
annotation and combine it with other
annotations from J unit or from spring
and that's actually possible not only
for tag but for all the annotations that
come with Jennie Jupiter so here's the
first test annotation that has tagged
fast and test on it and you can use it
in your test code like at fast test so
you could define like education test for
example and yeah use that in the same
way also test naming has changed so so
by default it's the test class or method
name and that's very limited at least in
Java and we provide display name
annotation and so you can actually
customize the display name which can
contain spaces or special characters in
even emoji so you should use that wisely
though right not all the test should be
named flag emojis
but you could she wanted dependency
injection is also very interesting it's
one of the places where the extension
model meets the programming model so
there's a parameter resolver extension
API that you can implement and have yeah
implement support for resolving per
parameters for tests and lifecycle
methods and even constructors
you can register multiple of these
simultaneously and only one can win so
in case multiple parameter resolver say
hey I want to resolve this
then James will throw an exception use
cases are plenty so this you might want
to inject the server URL into your test
or a data source or a spring application
context or spring beam for example so
that's all very useful and also Jane it
provides some support of out-of-the-box
this test info object you can inject
that into a constructor test or before
each method and access the display name
tags or the class or method of that
corresponding test and it's actually
implemented using a parameter resolver
internally that just happens to be
activated by default so we're eating our
own dog food here as well so if you want
to have more examples there's four
petition info and test reporter in the
Jupiter sources but there's also a
sample mockito extension and well of
course the spring extension which is
part of JUnit a lot of j-unit part of
spring five actually so why is that so
significant so I'm disabled yeah so some
people ask why don't we just have like
at ignore right yeah I ignore was kind
of just one way it was there's static
right and so with um doing it dude we
decided we'd like to have be able to
enable and disable programmatically
right to make make a decision about that
so that brings us to the topic of what
we call conditional test execution
somewhat borrowed from the idea of
profiles in spring you're familiar with
that so basically it's another place
where the extension model meets the
programming model and there's an
extension condition API you can
implement and it basically decides if
the test is enabled or disabled and
that's why the annotation is called
disabled right it's static as well which
you can write your own if you want to
see how to do that you can check out the
code for disabled condition so this is
basically a game changer right so it's
actually very powerful you can write
your own kind of conditions for like
disabling on the Mac disabled on Windows
enabled only on the CI server disabled
on weekends right you could pick
anything based on their JDK version
stuff like that so it's quite quite
powerful and if you want to um turn
these things off we actually have a
feature for that so maybe you had some
stuff that's disabled or for some
certain reason you want to just see if
those tests should actually pass in the
current environment then you can
actually do you activate those via the
launcher with um system property or in
the Jaina platform properties file and
that's via a key named Ginny conditions
deactivate and accepts a pattern so you
can turn off all the jaynette conditions
or any conditions you've written in your
company or spring conditions or stuff
like that so now we'll take a look at
these things in turn tags display names
dependency injection and conditions so
we have a class with a gigantic name
fast test and a normal test how do we
make them tests right pick the right
annotation all right so that would make
them just run as is alright if we should
see two two out of two that's good we
want to make those some fast right so we
would say something like tag right pick
it the right one say fast and the other
one maybe is as normal so now we still
Steve um to a tattoo that looks very
strange what happened there it looks
like my Eclipse is having a problem it
says around two out of two yeah how did
I click there okay so it's showing both
right they're both there they're both
running so what if you want to filter
based on that well Eclipse has support
for that I'm not sure if IntelliJ has it
yet but you can go to run configurations
and eclipse oxygen click on the
configure for include nicely tags
exclude everything that's tagged with
fast apply it and run it and now we'll
see that we have only one right so it
doesn't even show up in the results so
that's a the tagging in action and we
mentioned as well you could have a
custom
annotation something like fast test and
let's just take a look at that same as
from the slides but basically it's a
used on methods retaining runtime and it
combines a fast tag and test together so
if we run this test again we'll see the
results are the same that the fast test
does not show up only the normal test
actually got executed so that's how you
can have stuff like integration test
smoke test fast test and stuff like that
and you can combine multiple tags and
also combine that with stuff like spring
with a transactional and stuff like that
so that's the tagging part and the
display names so we mentioned right by
default it just picks fast test display
name we could say something like fast
test something like that right and we
could um go back and make sure we pick
this turn that exclusion off again so I
want to actually run now apply and run
and now we'll see something different so
now it says fast test right and that it
can have any kind of special characters
you want and this is a the super cool
feature that everyone loves so you can't
type an emoji in Eclipse but you can
copy and paste them into Eclipse so now
I have one and if I run that what's
going to happen yes that's right it
shows the emoji yeah
and you can even double click and it
goes straight to the method so that
works the way you'd expect just to show
you that's working with the build as
well so if we were to run the test when
the command line using the the Gradle
plugin we should hopefully see an emoji
spit out somewhere and test some types
are expected to fail but we should see
there you go so even though moto G shows
up and in the test results on your CI
server and stuff like that so we don't
recommend it actually maybe for
something like locales with flags and
stuff like that but maybe not the the
poop emoji or anything like that all
right so that's a custom display names
you can do it at the the method level
you can do it at the class level right
so you could say demos right and if we
run the whole thing we see even the
class gets a custom name so demos fast
tests etc and what if we wanted to
access the stuffs we're talking about
dependency injection there's a thing
called test info which basically
replaces what is it test name the test
name rule from jana for right yes right
so you could say test info and I'm just
gonna be lazy and print this thing out
it has a super nice - string will print
all the information for us so now if we
run just this test here and we should
see some stuff the console so right so
the display name is listed there any of
the tags that were there listed out the
actual test class is there and the test
method so you can access that stuff if
you want to do something
programmatically based on that or if you
want to just log it or something like
that that's an option so what's left is
conditions so what if you wanted to
disable the normal test like right now
if we run it we see two of two should be
right
so the normal test is running as well
and if we just wanted to disable it for
some reason we could say disabled and
now if we run them we'll see that it
actually gets skipped completely right
so in the IDE it probably showed you to
something like this little grey icon -
OH - bit one was skipped and this other
conditional stuff so there's this other
thing I'm just gonna talk about briefly
now like I was saying anyone can build
on these these conditions this disabled
on Mac comes with from the spring
support that author for spring five and
it has a disabled if annotation which
builds on the J and Jupiter support but
supports Springs a spell expression so
any kind of dynamic expressions built in
line very powerful in spring so we're
checking the system property os name if
it contains Mac then this thing should
be disabled on a Mac so if I now run
this test class again then we should see
that in fact that one is disabled
because it's on a Mac so that's very
powerful and you can do anything like
that on your own as well okay so yeah
testing traits what are testing traits
like Java doesn't really have traits
right not really no so but they have
interface default methods now so that's
kind of yeah but you can call testing
trade so we support interface default
methods and this kind of enables the
concept of a test interface so you can
inherit from multiple of these
interfaces and define tests as interface
default methods so we're actually
inherits like testing traits and we
support also before all after all on
these interface default methods but they
have to be non static and in order for
that that you have to use test instance
per lifecycle to a class sorry before
each and after each are supported
without any changes also the other test
annotations tag extend with and you'll
actually look at some example right now
so the string test here so this is an
example I will run it first as you can
see there were six six tests that were
executed and yeah so but they're
actually not test in this test class
right but it implements two interfaces
one is called comparable contract and
you one other one equals contract so
when you go there you will see that
they're actually default methods in here
that are annotated with tests and in
this case this is kind of the contract
for that the comparable interface so
that's one way you could use this for or
the equals contract also has tests and
they have some abstract methods of
course you need some have some concrete
values and yeah these are implemented
here in the string tests class so this
is kind of a new way you could use this
for for testing and this would not have
been possible without support for Java 8
all right you ever seen all that yeah
next up nested test classes that enabled
you to yeah have logical hierarchical
grouping of test classes so you can
actually share initialization and state
from outer test classes into the nested
class you have to declare a nested
design
on your non-static nested classes also
known as in your classes and you can
even combine nested classes and these
test interfaces so that's not perfectly
composable and we'll look at the testing
a stack example so you get some better
feel for this so this is quite a
elaborate example we run this first and
expand all here so this also uses
display name oops
where did it go Sam not here found it
yeah right to scroll zoom so we actually
have a stack and they use display name
so it's readable like a stack when you
after pushing an element it is no longer
empty right and when you look at the
implementation for that this is actually
the outer test class a stack and it's an
inner class when you and each of these
things has a before each method so
that's the stack has actually come
actually declared in the outer class and
then initialized here and then used
throughout the nested test classes so
you can have grouping and for your tests
but also share the common setup for a
group of tests
so we mentioned test templates
previously can you tell us something
about those yes test template is
basically like a test method that serves
as a template that can be invoked
multiple times in different ways so like
first up we have repeated tests you want
to invoke the same thing just multiple
times
basically just annotate a method with at
repeated tests instead of at test and
then specify the number of repetitions
and you can optionally have the
repetition info injects it into it to
get access to the current repetition or
the total repetitions and stuff like
that you can also optionally override
the display name so seeing that in
action and would look something like
this here we have the first one here on
repeated test five and gaining access to
the repetition info so we're seeing that
the total repetitions is five just for
an example here and the next one we see
how you can actually have custom names
with placeholders in there so if you
wanted to translate into German or some
of the language for example here we're
saying this is the same as repetition
105 or Peter holding science and Foom
something like that so you could do that
as well the next thing we have support
for word templates is much more powerful
one of the most powerful features in
Jana Jupiter so that's parametrized
tests and just annotate a method with at
parametrized test instead of test and
specify on the source of the arguments
where they should come from so you can
also optionally override the display
name like with repeated tests and in
terms of sources we got lots options
there so value source just for some
scalar values like strings and Long's
and doubles an enormous source to pulled
out constants from an enum even based on
ranges and patterns and stuff like that
method source is the most powerful one
that's where you can have Jane and
invoke your own factory method to
provide the parameters for your
parameterize test we also have support
for complicated values either in lined
as strings or actually pulled from a
file in the the class path so it's also
a nice option and if none of those meet
your needs you can configure your own
arguments source and a custom argument
survivor pulling your data from wherever
you want maybe from a database or some
other type of file and stuff like that
in terms of the argument conversion we
have some built-in support for that
there's implicit conversion for the
basic types primitive primitives and
their wrappers and stuff like that I'm
also for enum constants and types from
from Java time like local
date and things like that but there's
also explicit conversion support if you
need to implement that so you can use
the act convert with annotation on a
particular parameter and implement your
own argument converter where you know
how to convert into the the target type
but we also have some built in support
for Java time Java time conversion
patterns so you can define a pattern if
it's doesn't align with a fault pattern
that we use so what that looks like
again just put a parameterised test on a
method like this and then specify
something like value source so here
we're specifying a list of strings here
some candidates for things that should
be palin gems so you can read them
forward and backward and then each one
of those gets passed in individually so
this would get invoked five times we
hate to do those strings and they would
actually show up as individual tests
right so we can use that to parametrize
so let's just see those executing in
action so it hits home a little better
all right so we've got from here working
repeated tests so this is the example we
saw before repeated tests with the
repetitions and here the translation and
if we execute that then we should see
those all show up all right so expand
all and now we can see that we do indeed
have those so each one of those gets
displayed underneath that template
method that serves as a container for
all these invitations and the same is
true for a parametrized test so if we
were to look at those this example here
commented out with the value source and
demonstrating how to do it with the
method source you just name the method
here candidates static method and this
is a factory method for your arguments
and here we just returning a stream of
those same values so if we were to run
this test here we would see that the
results are similar so again as the
container is the method and then we see
all the indications with the default
display names where a parametrized test
so the invocation count plus the
arguments all of the arguments that were
passed in to that method
so we've seen how we can use lambdas for
things like assertions but how can we
use a lambda as a test is that possible
of course of course yeah so we have
dynamic tests so why is this called
dynamic conventional tests or static in
a sense so you know all the test methods
once you compile the test class write a
dynamic test on the other hand is
registered at runtime so it doesn't
exist at compile time at least not not
in code but not really so it's a lambda
expression and that you can return as a
stream of dynamic tests and by a method
that is annotated with test factory
instead of test because it produces
tests you can also use dynamic
containers if you want to have some
structure in there some nesting again
it's somewhat analogous to parameterize
tests but just more dynamic in a sense
so let's look at some example here is a
method that's a test factory method and
returns a stream of dynamic tests and we
started off by using an in-stream to
iterate over all even numbers then limit
it to ten and which of these numbers we
mapped the integer to a dynamic test
using a static factory method here that
takes the test name as its first
parameter and a lambda as well the test
body basically so this is what you would
normally write in a test method body
yeah let's look at the source code in
Eclipse so we have done any tests here
oh those extensions here well anyway
okay yeah we have a method here and this
is the same method from the slides and
I'm just going to run it yeah I don't
mind that right now so you can see we
have first ten even integers as a method
and that's basically one test for all
for every even number yeah for the first
10 even numbers because we limited it to
10 right here and yeah so the name is
built from the test string and the
number and again this is
like one assertion is the only test so
let me change that to make it fail
quickly run it again yes I want to save
that okay as I spent more but you can
see five tests I've felt now and
basically I made it so that I tested at
all even numbers are divisible by four
which is of course not wrong yeah not
correct sorry and so two fails right and
six fails for example so that's how you
would use dynamic tests and you can use
lambdas now to write tests basically you
can write any any code in this test
factory method and you could load the
data from anywhere again from a database
or from some file or generate some
random data even that's all perfectly
possible now so what's missing yeah but
you don't have scenario tests yet which
is what we call tests where you have
dependencies imagine UI test that locks
into a website and browse the some to
some page and locks out again in the end
why you would like to formulate these
these steps or specify these steps as
individual test methods but then have
them executed in the correct order of
course and maybe even share state
between those so we have that in on the
roadmap still and we'll work on that I
hopefully soon there's also ordering of
test methods and of extensions as well
which we don't right now have parallel
execution as well execution in a
user-defined threat is something that's
missing declarative and programmatic
test suites for the premium platform we
actually have a runner the training
platform runner that Sam mentioned
previously that you can use to declare a
test suite but that uses the change for
to run it and not a platform directly
that's kind of strange and we're gonna
have first-class support for that and
also tell a nine module path scanning is
something we are currently already
working on and this will be added soon
so we'll skip this live coding demo I
guess yeah and maybe if you have some
time at the buff do it then I think so
yeah so the same for for spring I'll
just mention briefly that there is full
support for Jana new programs
five supporting all the core features in
spring setting support also support for
advancing gestured for test methods and
stuff like that already showed the
disabled if stuff like that but it also
works with spring for three if you use
my project here on github so we can look
into some of these things during the
buff and show some more some more demos
for how to actually implement some
extensions so in closing the slides will
be made available online we have links
to Jane at resources and spring
resources and all the code that we've
used so far is available in my github
repository so in 20 minutes you can come
join us
Boff room number two will be there for
an hour and we were there to answer
questions and demo anything that anyone
wants to see so thank you very much for
coming
yeah thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>