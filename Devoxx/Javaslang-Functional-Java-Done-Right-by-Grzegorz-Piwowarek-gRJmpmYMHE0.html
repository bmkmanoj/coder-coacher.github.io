<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Javaslang - Functional Java Done Right by Grzegorz Piwowarek | Coder Coacher - Coaching Coders</title><meta content="Javaslang - Functional Java Done Right by Grzegorz Piwowarek - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Javaslang - Functional Java Done Right by Grzegorz Piwowarek</b></h2><h5 class="post__date">2016-11-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gRJmpmYMHE0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay guys it looks like times up so
let's start okay so I'm first things
first I'm glad that you came here and
decided to see this talk my name is
Gregor Spielberg
I'm from Warsaw in Poland I work in a
software house called Stoke and besides
being a software developer I I used to
be a professional yo-yo player and
part-time musician but enough small talk
we don't have much time so let's get
straight to the essence
ok so Java 8 was a very special release
because it brought the Java ecosystem
some ideas from functional programming
like lambdas optional streams and so on
and actually some people started calling
this release functional but it was not
that much functional after all because
people started noticing that all this
function nests of new Java release is
basically optional streams future
lambdas and not that much after all so
basically after people were very very
excited at the beginning the release was
heavily anticipated but it turned out
after some time that it's not that nice
so people starting made making members
and stuff that functional programming in
the Java is basically pretty much like
this and started discovering other other
issues with Java 8 so at the beginning
people started noticing that there are
only basically three functional control
structures like optional streams and in
future and other languages like Scala
they have many more there was no such
concept as memoization introduced to
Java don't worry if you don't know those
terms we'll get back into this in a
minute
there was no partial functions lifting
and still after so many years we don't
have tuples in Java for some reason
silly to write them ourselves or use
some external libraries optional wasn't
failure is able and iterable and it cost
some problems in different situations
the biggest problem for me actually was
that streams and optionals were not
actually introduced to IP eyes but we
all know why why didn't happen because
Java creators are on a holy crusade and
they have very like noble reasons to be
backwards compatible with previous devil
releases but sometimes you need to break
stuff to make something better but so of
course this couldn't have been avoided
some people also complained that when
when it comes to function representation
instead of like one on very 1:1 function
type we got functions by functions
predicates by predicates
unary operators binary operators and so
on and so on this was confusing for some
people and also people were kind of
disappointed that even the simplest
operations like mapping for mapping
collections and needed to need it so
much boilerplate and probably there were
more and so much more problems but but
Before we jump straight into the essence
of the stock let's let's have a look at
this slide basically when you write code
in Java in many cases the list of
parameters the clutter
the declared parents are not all perms
that we operate on so usually in many
cases we have all our functions our
methods except some they the results
might depend on some mutable instance
state on some mutable global state but
still if we if those states influence
the final outcome of a function they
still need to be considered of course
inputs and when it comes to outputs
let's please notice that we are not only
returning basically declared return
value but we also have mutable instance
state global state because obviously if
those can influence the outcomes of
other functions
well those are some kind of return out
the outputs that we need to consider
obviously we could also change mutable
params and throwing exceptions that
obviously change how methods behave so
in a perfect world we would like to
write functions and write code that
accepts params and returns value and
connection between input and output is
very clear and that it that out that
this direct connection that there are no
other stuff that could influence output
than the input so basically this is all
done by going to avoid mutable states in
our either instance States or global
states and here comes I want to recall
that basically there is a common
misconception that some people some
people consider some people's talk say
that if you have a language programming
language and if you have lambdas there
somehow it makes it functional but it
couldn't have been further from the
truth so basically there are many
different approaches to defining what
functional programming is but I really
like there is this definition that I
found on one block that functional
programming is about writing few
functions about removing hidden outputs
and inputs and about minimizing moving
parts
so that our code is our methods just
describe the relationship between inputs
and outputs in a as directly as possible
so before we go further we need to
recall also two very special terms for
functional programming which is
imitability this term is pretty pretty
intuitive to understand it means that
when we are creating objects after
creation we can't modify them this gives
us this gives us fruit safety for free
and allows us to avoid many potentially
many potential problems for example when
we are putting a
to hashmaps this half gets calculated
and stirred inside but when we if we
modify this object outside of a hashmap
suddenly it might lose and I too might
lose him and contains never dynamic
respond might return false so we using
when dealing with immutable values we
might avoid many problems like this the
other thing is referential transparency
which could be explained in such a way
that if we have we have some methods or
statements expressions if we call them
with the same set of params and
regardless of the amount of times a
quantity of times we call them they will
always produce always the same results
so in such case we if function method is
finite efficient transparent we should
be able to be able to substitute the
call with params with result is produced
and it's all it should always work so
few tweets s again functional
programming is by using imitability and
avoiding side-effects we essentially
just minimize the amount of moving parts
that can break at some point but also
there's another misconception many
people say that that functional
programming is all about removing
mutability and side-effects from our
world but obviously it's not it can't
avoid it all the time so function in
functional programming we are trying to
encapsulate everything in such a way
that we don't need to directly deal with
the problems that mutability and
side-effects cause and since we if we do
we already know that functional
programming is not about lambdas but the
very important is thing is to be
actually able to pass actions some way
because in functional programming we are
trying to use very small build very
small trivial blocks and compose them
together and when we are composing very
small trivial potentially working blocks
together we end up with something that
eventually will probably work and when
we are when we are having
blocks that might throw exceptions or
behave in a very way that's hard to
predict when we compose them together
eventually probably there is a huge
chance that this might blow up so as we
know alumnus is not everything we can
probably program functionally bound
lambdas if we can if we are able to pass
actions some way but actually it's very
hard to do if we don't have the right
tools for the job
so if we have a look actually at Java
collections API we have many methods
like add remove clear and if we look at
the values that get returned there we
can observe that the whole collections
API embraces mutability it encourages us
to write Muta use mutable structures and
there is a problem because let's say
that we really want to deal with we
decided to try imitability
but we can do this because one of the
basic building blocks of a language is
something that embraces MIT ability of
course we could go over and other stuff
and some immutable views for collections
but still the DOS world has more like
half-measures and this is basically
where Java Swan comes into play
java slang was designed as a set of
tools that fill in all those blanks and
make functional programming in Java 8
and higher much more easier okay so
what's the first one
Travis long this is what what you can
see there as you can see it might be not
very readable especially from guy
sitting in far away so let's break it
down so the first on basic consists of
like three more three building blocks we
have a lambda we have set of tuples and
MIT value when it comes to lamp what's
lambda lambda is basically the same it's
a is a set of functional interfaces
quite similar to those that our in Java
8 but those are kind of on steroids so
for example if you look have a look now
at the first line this should look
pretty similar for you because it's
pretty much like Java it but if you look
at the of the name of the function you
can see this - at the end this number
signifies arity of a function so in Java
you don't need to try to search for
different name for those functions and
here it's very predictable okay so if
you are looking for a function that
accepts seven parameters did Swan be
called well I don't really know how to
call how to use this world with seven
for seven but in this case we are simply
looking for function seven and this is
very predictable and easy to use
intuitive also the very big pain when it
comes to Java eight was dealing with
tracked exceptions the problem was that
in all those functional interfaces when
if you looked inside there were there
was no first clause in the method that
was supposed to mimic and serve as a
body of a function so every time we
encounter the trek exception
unfortunately we needed to try and catch
this and some unusual it was either pack
it into a runtime exception or dress
swept it under the carpet so it was
really painful especially when you were
dealing with streams and multiple lines
of lambdas and let's suppose that you
wanted to catch only one situation when
some let's say one of five lambdas throw
an exception you couldn't do this you
need to repack all repack all of those
exceptions and try to catch them again
it was a hell so this time now we now
it's solved we have like a set of we
have checked function which is like a
brother to a normal function interfaces
and they all support throwing track
exceptions so it's not a problem anymore
also those those interfaces can be
composed together just like in Java but
additionally we can perform partial
function lifting we can carry them and
my favorite feature we can memorize the
results what does it mean let's start
with lifting okay
so in a world of functions we have
something like perfect
functions that means this is a set of
functions that accept some parameters
but do not always give us a result and
in a Java world it usually means that
some encryption exception is being
thrown so if you look at the first
function over there you have three
parameters integer integer integer which
means that function accepts two integers
and returns integer 2 but if you look at
the body of a function you receive that
add some there's some different pinter
form so as we all know that if we divide
by zero nothing good will happen so we
can perform lifting on such a function
in a very easy way and thus right we use
--lift static function or lift instance
method and as you can see now return
type has changed from integer to option
of integer okay so we will always get an
option that if some exception was from
there we will get an empty object this
way we are getting rid of option of
exceptions and partial function is being
transformed into total function
returning optional carrying carrying is
a concept of representing function of
hierarchies with a function with a
higher function of a narrative one that
read instead that instead of accepting
many different parameters that it
returns another function that accepts
one parameter list okay and so so so if
we have function 485 we want to carry it
it will be represent as function 5
returning function for func that
function for turn in function 3 and so
on and so on when we have function in
such representation it's very easy to
apply partial application there so as
you can see here we define a function
called sum that's supposed to sum two
integers together and we are creating a
curried version of it and notice now
that function is returning another
function and let's say that we want to
apply two in the second in the last line
so after applying two we actual
change the sum function interface you we
fixed one parameter so instead of
summing two integers we are now
basically just summing what some integer
with - okay and how here comes my
favorite which is a memoization so if we
are dealing with referential transparent
functions as I as I told you before we
can we could substitute the function
calls with results with some return
values associated with inputs so if we
are dealing with such a functions why do
actually bother with calculating
everything every time for the same set
of parameters we could just catch the
results so let's do this we let's let's
catch the results and next time if we
encounter the situation when we are
calling the the function with the same
parameter let's return it from a cache
okay so to create such a function in
diversifying it's very easy because you
just use the inference method called
memorized and it's already cached so as
you can see now let's let's have a look
at this situation it's actually very
nice let's actually it's very easy to
show how it works on a very bad examples
so I created a function of math.random
it's something that's totally opposite
of what should be a refresher
transparency FFL transparent because we
are expecting now function to basically
return and other results every time it's
being called so let's try to memorize it
and this is how you can basically break
math.random so now after the first call
the return result is cached
and for every future call it will be
returned straight from a cache okay we
also got tuples if you don't know what
the table is it was a simple nice way of
grouping few objects together so
basically if you have a situation in
your code that if you need to group sum
up some properties together and this
situation doesn't deserve another object
to create it for them you can use
doubles obviously they are immutable and
they support from nice thing so you
perform mapping by providing to mapping
functions there you can transform them
and even convert them to sequence as you
can see we are trying to utilize
polymorphism as far as possible also
very the most important thing them in
java tank is set of values like option
try lazy eye their future validation
what's more whole collections api is a
value too
and what's very important is that value
extends and iterable so this is like the
common denominator between java slang
and colliculus 89 known from java this
is how we can ensure interoperability in
many cases also but now you think wait
option try lazy either they extend value
and they extend it terrible toe okay
because it makes sense from some point
of view if you think if you think about
them all of them are kind of containers
that can hold the value or not so
basically yeah we can consider them in
terribles that can hold at most one
value it can be really useful in some
cases so let's have a look at some
details option as you all probably know
from java if it allows us to operate on
values that can be nullable in a very
nice and concise way so obviously here
it will be additionally it will be
serviceable and iterable so as you can
see we are putting into an option
something that might be knowable then we
are declaratively providing with two
functions that need to be performed on
the underlying value and then in the
last line defining default value that
should be returned in a case nothing is
inside okay and here is a very common
problem because if you encountered
situation where you had a stream stream
of optionals
in Java it you need to do some with some
kind of workaround if you wanted to
filter only like present values you
needed to at first filter using optional
is present predicate and then map and
extract this value from an optional I
don't of course another
I'm collect a list and it doesn't seem
like it's I have a feeling I already
feel that it could have been done much
easier but now in rank if you're if
option is terrible you can simply use a
flat map and in such case we are after
performing a simple flat map after one
liner we end up with values that were
called inside optionals and those that
were optional were empty were omitted as
simple as it is also try another nice
tool it's kind of similar to an optional
but this time we are dealing with values
that might produce an exception so we
put something inside and try and perform
some operations declaratively and in the
last line when we can scandal a
situation if some if some exception has
been thrown so in this case as you can
see we can declare it if we can just
specify that gutter else unknown and in
this case it means that if some
exception was thrown on the way the
unknown string will be returned also the
very nice thing Java as a language
doesn't support lazy initialization so
we needed so but sometimes we need to
implement it ourselves in Java Strunk
you can also find this one the API is
pretty much similar as option option try
and other other tools so you can pretty
much usually just specify it using
method off and putting there a result of
some that's a very long lasting
computation then specified declaratively
what should be done on this object at
value that will be calculated eventually
but everything will be calculated when
we call dot get method also Java slang
utilizes set of functional data
structures unfortunately we don't have
much time to talk about this but there
is a very good talk about about this
concept for is the whole conference talk
by all extra life it was presented on
Java one and
folks Poland and probably a few other
divorces too so definitely check it out
but what you need to know is that
functional data structures are
functionally immutable a persistent that
with reference transparent methods what
does it mean to be persistent in terms
of data structures it means that the
internal structure of now if a data
structure allows us to somehow retain so
how to save and reuse other data
structures before modifications so if
you have some list if we modify it if
you want to do the immutability we would
need to create copies copies copies all
over again and we will be able to just
end up with too many copies so when we
have persistency we are somehow saving
trying to reuse the previous versions of
some data structure so for example if
you have a list you is organized in such
a way that you hold the reference to
each stay and a new head element and
it's constructed in such or cursive way
but once again all extra life stock is
very good and you should definitely
check it out and now let's go to
sequence from java slang once again we
don't have much time to go through the
whole the whole tree here but basically
as you can notice all those structures
like RI vector stack q they obviously
persist they're functional data
structures you probably know you know
how they work but there's also one that
kind of doesn't fit here from the Java 8
point of view because you have a stream
there stream in Java 8 is basically a
very fancy form of an iterator but here
it's a full normal 1% collection that we
can use
ok what's also very interesting that if
we if it traverse this type querque
up we'll see at some point that
something is that sequence extends
function well very interesting we are
again trying to like squeeze as much as
possible from polymorphism because if
you think about this for a while you
will
that when we are we don't have in
sequences we have kind of connections
there between indexes and values those
do we form some connection between
integers and index F in values so why
not treat it as a function in some case
it might be reducible if you if you
wanted to map some other collections
according to values cut in another
collection in a map it's very handy to
sometimes just provide the collection as
a mapping function instead of just
trying to deliver this manually okay and
the best thing over there when I was
playing with stream stream API from Java
8 at the beginning it I felt kind of
overwhelmed because we kind of too many
too many I felt that there are too many
methods in the API but at some point I
noticed that there are some lags and as
you can see this is this is a screenshot
of some some from IntelliJ IDEA and you
can see that the amount of methods is
pretty much overwhelming and you can
find pretty much anything you really
want for every context so all those
methods that you missed in your in Java
it's from API all of this is here and
it's really good ok so you can even
create nice stuff like this and impress
your colleagues at work but now the the
nicest thing in java slang
does that they guys manage somehow to
implement pattern matching in java which
is which is a feature known from finally
other functional languages pattern
matching is alike switch case on
steroids and in this case it can see
it's a very nice and concise way of
performing actions according when you
have many different conditions that
could be met so as you can see you can
write just match match off and then
specify different cases and results that
should be returned in case one of those
is matched obviously what's really nice
that you you are not committed to
further cuts only you can basically use
match the
home values at the same time using this
nice dollar sign what's really
interesting that you can match you don't
need to match the whole objects you can
match objects partially in this case
seem to use special patterns created
using special annotations from one of
the Java slang modules and you can
perform matching only on certain
elements inside okay so you can forget
so much local date alok updates 2016 and
let's say only but I'll grab all that
are in 2016 but match and hold and
perform some operations on remaining
fields what's really nice that you can
also use some perform matching using
types and as you can see here we are
matching an optional and trying to match
situation when there something is inside
and when it's not
also don't worry interval strength there
is a predicates class which comes out
which comes with set of predefined
predicates for every possible situation
so there is no need of defining them all
the time very simple cases like
predicate is is in or instance of it's
already out of the box also what's
really nice is that I want to remind you
that you don't need to use a pattern
matching standalone okay it blends
really nice with the API so of try and
all func try options and other tools in
Java slang so we are getting straight to
the end and I do I was just talking
about Java on core but we have there are
many more that are worth exploring we
have a Java tank module for drag sounds
week there are there's some silk
codebreaker and much more very
interesting stuff engineer that's all so
thank you very much I have a lot of
stickers for you so don't hesitate and
come here and I hope you liked it and I
hope that I sparked some ideas so for
you too
go explore Java flunk and try using it
on daily basis
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>