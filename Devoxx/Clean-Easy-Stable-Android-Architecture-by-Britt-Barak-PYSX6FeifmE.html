<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Clean, Easy &amp; Stable   Android Architecture by Britt Barak | Coder Coacher - Coaching Coders</title><meta content="Clean, Easy &amp; Stable   Android Architecture by Britt Barak - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Clean, Easy &amp; Stable   Android Architecture by Britt Barak</b></h2><h5 class="post__date">2017-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PYSX6FeifmE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone hi yay how are you great
I'm so how's that work so far good I
just came I don't know let me know if
it's fun or not hopefully we'll have
some fun tonight
today it's three all right something
like that
so I'm Britt Barak I came all the way
from Israel I'm an Android developer and
I've been leading mobile teams in Israel
in a few startups that I'll tell you
about those in a little bit
I'm also leading Android Academy TLV
community which is totally voluntarily a
big community for for Android developers
and designers you can look us up and
meetup or Facebook when I'm also leading
women techmakers in Israel so if you're
in Israel just let me know in all kind
of cool meetups to go to so just let me
know I want to hear a little bit though
before we begin about you guys who it's
not working so I want to hear about you
a little bit who's here a developer yay
who is an Android developer okay like
half okay good I wanted to know who is
working for start-up very small startup
okay
and for a very big company so the rest I
guess in is in the middle yeah okay good
just wanted to know what am I talking to
so this is working no good
so like I told you I've been working and
if your startups team liking a very core
team from scratch to growth and one
thing that I've learned is that there is
one thing that is always certain when
are we talking about small startups when
everything is changes the product
changes that
design changes all the time the the
priorities changes sometimes the
business even changes one thing is
always always always certain and that is
that everything is gonna change and it's
gonna change really really really quick
therefore our architecture or app or
code base should support that all the
time
and we're gonna take a look a little bit
of my experiences and how to do it
before that I want to share with you
some small story about my first startup
I guess it happened when I was in high
school I grew up like I told you in
Israel in a very small and new town and
one of I guess my first startup was that
me and my high school peers decided that
we want to major in high school in
theater so we had to establish the
theater class which was something that
never existed and it was all about going
and finding the teachers and budgets of
course in classes and costumes it was
really really really fun and then we had
some shows and plays that we had so we
can earn some money and buy some more
stuff so this is kind of my first
startup the thing that I really loved
about it about the creation and
everything was amazing but a guy that
inspired me the most was my favorite
playwright do you maybe recognize this
person
yeah no it is Shakespeare this is
William Shakespeare you guys so William
Shakespeare was my favorite playwright
and my favorite one of my favorite plays
was it's called as you like it it's a
very good place you haven't read it I
really encourage you to do that so there
is a very famous quote from there
hopefully you know it where is a
monologue and it says that
world's stage and I'll men and women are
merrily players they have their accents
they have their entrances and one man in
his time plays many parts and then it's
a really beautiful monologue and Donna
it describes like the parts the seven
steps in a man's life it's very nice you
should read it if you haven't well for
me this was kind of inspiring for the
code that I wrote later on why did I
what did I love about it or what makes
sense for me is first of all we're
talking about players so for me each
class that I wrote is like a player that
I want to understand what's what's it's
part in the play what is here to do
second thing we're talking about exits
and entrances which is like defined
interfaces for each class I have to know
who is gonna use it how is it gonna be
used and so on and also about the
playing parts think so the playing parts
meaning that each person or each class
has a part a specific part each time on
his life or on the app of course when
we're talking about our code and this is
kind of like the separation of concerns
I want each class to be in charge
basically about a specific thing so this
is kind of gave me some inspiration that
I wanted to share with you today but
let's talk about the app that I want to
show you a little bit that I wrote so
just before that I mean we are pretty
close by now I told you a lot of stories
about my life and I want to kind of ask
you another question so sorry so before
I'm going to ask you this personal
question just want to say that our goals
when we create the apps is not about
writing a beautiful architecture or
creating this classes this beautiful
classes it is about first write quicker
code right
to make all the changes that we talked
about like really really quick but we
have to write a code that would be easy
to change and to maintain and then we
can rely on so it's easy to test and is
it to understand I say it has to be easy
to understand by others because if we
wrote the code ourselves it's well it's
easy for us to understand we wrote it so
it makes sense that we can understand it
the goal is for others to understand it
really well so what I'm going to talk to
you today about is kind of how I create
or how I think about the architecture
for the app that will help us achieve
the goals that we just said we're gonna
talk about the architecture luckily for
us
Android very recently on recent Google
i/o announced on a very cool project
which is the architecture component who
have heard about it
just know okay so the the thing is that
developers from the community kind of
gave the the notes that we need some
help with realizing what's the right way
to architect or apps so there are a few
things that Google did for us and
actually it was done very closely with
the community I was part of the early
access program for this thing so it's
been very great that we can actually
give some best practices and give back
and forth with this amazing project so
there are two parts for this project of
the new architecture components one is
actually giving us architecture
components like objects in the framework
that are supported by the framework and
can help us we're gonna actually see how
to use them and to work with them but
it's not the main point the main point
is kind of understand whether the best
practices for the architecture like
illogically and we're going to use the
new architecture component but the thing
is
understand the mindset and luckily for
us like few days ago it actually became
stable and official so we can all feel
very comfortable and using them also in
production which is awesome so the
personal question I wanted to ask you
guys is who view loves jelly beans not
too many I don't believe that well I for
one love jelly bean I really really love
them and there is a small secret about
jelly beans that not everyone know just
the experts one is that instead of
eating them just like that one by one
you can actually create recipes and then
if you make the right combinations
instead of eating jelly bean flavor with
flavours you actually eat jelly beans
that's like which tastes like desserts
very cool desserts so this is kind of
very very very cool and I really wanted
to create an app that can allow me to
see them and to create them when I do
that so my app of course can help me
understand that if for example I take
two green apple jelly beans and one
cinnamon it's gonna taste like apple pie
try it at home it's very good and of
course I'm going to have the list of
jelly beans that I can see all of them
that I can create the recipes with and a
jelly bean activity or screen to add a
new one or to edit the older ones this
is the kind of the app that I created
and I want us to take a look a little
bit on how to did or where to start when
I have this kind of idea how can I look
at the app and understand what's the
what's the different components that I'm
gonna use so the way I like to look at
the app and to think about that is
something like that so we're going to
talk about each of them a little bit
different in a few minutes in general I
have three layers not too many just
three layers the presentation layer is
about the views and about the UI about
how things are
looking for the users we have on the
other hand the data layer which is very
objective it's about the data entities
and the way that they are represented on
different servers or on our database and
so on and then we have the domain layer
to just be the intermediate between them
and have our app logics and actually all
the things all the use cases that we do
with the app get users get jellybeans
and so on they'll be all on the domain
layer so let's consider this screen to
create a new jelly bean what do I have
on the screen I have the user the flavor
name that the user can type in and I
have three SiC bars each of them is for
the RG and B of the jellybeans colours
and when I change them it automatically
like straight ahead changes the color on
the top so let's think about how we want
to create those first thing is the
presentation layer its job its role it's
part it's about the UI it is not at all
about any logic so it's kind of a Johnny
Bravo person that is like all about the
look it doesn't want to think a lot okay
so to create that and to make it even
easier for the UI for the presentation
layer I don't want it to be thinking at
all I'm gonna create an object I call it
a view model because it's here to serve
the view anything the view needs in the
and to make it very easy for the viewers
easy as possible for the view I'm gonna
create the fields for it and then it
would be able to the view would be able
to use it as easy and as quick as
possible so we created this view model
since it serves the view and then on my
own create basically what I want to do
is set the view model for the view and
then to set all the other things on the
UI so the set view model currently what
it does it
create a new view model why because this
is a new jellybean that we're creating
so it's a new object is currently empty
with any data and the thing that we have
to remember always that the point is
that the UI represents the view model
state right not the other way around so
currently the view model is empty
therefore the UI is empty awesome
basically I will want to create this is
the presentation layer quick has the
view the layout right and then it has
also the view model and now when the
user gives us any kind of input for
example here it just moves around the
the SiC bars for the colors the view is
gonna know about it obviously because he
have the inputs what your going why
didn't like the talibans I'm guessing so
the view ma the view is gonna let the
view model know that something has
happened but the view model is gonna
have to change its state and then to
notify the view about the changes
alright we'll see how it's gonna happen
so first step we have to update the view
model here just for example we're
talking about the sick bar so when the
sick bar changes we're gonna grab the
progress so it's where we're at which
new value did you get and the view model
is gonna set the are filled with a new
progress that's it
the view model that has to notify about
the change how do we do that there are
many ways that you can use we have just
plain callback don't do it but we can
use that we have the data binding we
have the rx Java which is like kind of
hip right you know but we're gonna talk
about actually is the live data what is
the live data is a new object or
component from the architecture
components that we talked about and what
it does it just holds some kind of a
data whatever we want
and it allows other classes to register
to it and one it changes when the value
is changes it's going to notify everyone
so yeah it's kind of absorbed
observables kind of like our Java but
the thing here is that its life cycle
aware this means that automatically
without us needing to do anything it
would only get the notice the updates
when the life cycle is started or
resumed and it will remove itself when
the life cycle is destroyed it does it
automatically if I used arc Java I
should have done that myself this thing
helped us a lot mainly with memory leaks
that we don't have them anymore if we're
using that so that's a great great
advantage why do we do instead of just
having intz at this instance we're gonna
wrap them up with live data object and
then when you're gonna set the R value
we just have to we can't validate it
it's just something that I created
because I wanted to make sure that this
value I accepted it's between 0 and 255
and then I'm gonna set value for the R
which is the live data once I said the
value everyone who observes this R value
is gonna be notified about the change
awesome so now what we need to do is
well create the observer create the one
who's gonna listen to the changes right
how do we do it we have the observer
it's the observer from the lifecycle
component it's an Android component and
create just the observer whenever there
is a change I'm gonna be notified here
and I can change the beam image view
color that's it very very simple so next
thing we have to do is just observe the
view model changes
so I have the view model and I set the
observer to listen to the are right they
are filled this is what we wanted you
the thing is that we have to notice here
is that on the observe a part of the
observer we have this this is for the
lifecycle owner livestock the owner is
also a new thing and it it has it's
something that an activity or a fragment
or whoever who has life cycle in it has
has it where it implements it it's an
interface so since we attach the
observer to the to the life cycle all
the things that I told you before all
the magic just happens and it just know
for example will will stop listening
whenever the life cycle ends that's
great so we just saw the input changes
the notifies the view the view sets and
new value to the view model the view
model notifies to everyone who observe
it and then the view ma the view itself
changes here we change the color awesome
now a small thing that we have to
consider when we're talking about
Android or applications and platforms
with like a life cycle is about the
persistence of the view model why
because we have this kind of a thing
when we when we have our app or activity
active or started when we switch the
configuration when we have a
configuration change here for example I
rotated the screen then the activity
just creates itself from from scratch
and this means changes that we made are
deleted so in order to support that we
actually have to save the state and then
to set the state of the view model and
then when it's recreated we have to like
take the view model back again and to
fill the field so here with the new
component there is something that can
really really help us without we
easily so when we set the view model I
have the view model providers class
which actually saves the view model
States for me pair life cycle you see
again that this this is per lifecycle
owner and then I can just get the view
model get the jelly bean with the state
and persisted and set the UI like like
it was before they change so this makes
it very very easy for us now what about
if I have some more complex view models
this happens sometimes what I have to
say about that is just don't be afraid
to create multiple view models and
multiple live data objects then just
have them bind it into one object one
view model that would actually talk with
a UI that will have all the other view
models with it and then and then it
would be very easy for you like you
separate to any other classes when you
have too much logic or too much data
they're just separate them just make
sure there are life cycle where and
they're like view models like we saw
before so we created the UI and
everything no let's save the jelly bean
alright we want to save it on our on our
storage here comes the data layer into
action so data layer is all about the
objective I call it objective data
because it represents the actual state
of the data whether it's on a network
service we maybe have like different API
that we're dealing with so we don't know
how is it gonna look like and it doesn't
no one in the application has to care
except of the data layer it is not about
caring about how the consumer would use
this use the data how this DUI is going
to use the data it doesn't care about
this at all and the way we're gonna do
it is to have two specific entities so
it's all about rules and
books we have two kinds of entities one
is the data model then we're going to
see in a minute
which is the entities of the data and
then we have repositories that we'll see
in a bit well the model is just like I
said the way it is on the servers on the
databases or whatever we don't control
it at all but we need to have an an
object a model of it a POJO of course on
our app so we can so we can use that
just to just to make sure this is the
view models that we saw before they are
not the same it's a totally different
object like I said the UI doesn't care
and doesn't know about the
representation of the data
in the dead in the data layer in the in
the servers or or the services so this
is kind of about that now the
repositories that I mentioned before we
have one repository pair this data type
so here for example it's the jelly bean
repository that we're gonna use but
we're gonna have a recipe different
repository we're gonna have users
repositories I guess so each data entity
data model gets a separate repository
its goal is to encapsulate the logic
meaning how we get or set or save the
data no one should know about this
except of the specific repository we'll
see in a second how it works and all the
crude operation the create update read
and delete are gonna be done here on the
repository so for example the jelly bean
repositories and I'm gonna show you why
this is a good pattern that I love to
use is what we're gonna do here is for
example we're gonna get jelly bean by ID
it's just an example the way it's gonna
work for example for me I just needed
you know if you'll see it just did this
app from scratch and I wanted to do it
really quick so I decided to use a
firebase client
so I don't need a server right now I
just want to show that I can do whatever
I want to do so currently I'm just using
the firebase club the firebase client
that I created but then I want to make
things better and more efficient so I
add a cache who knows about this change
only this class only the repository now
I wanted to add an app database a local
database I can do it and only I know
about it only the repository and then if
I changed from firebase to my servers my
servers so I have another API client who
knows about it only the repository so
this is kind of something that I really
like to use for this reason so we have
the presentation layer with the view
models because it serves the view like
we saw before now we saw the data layer
with data models but they are totally
completely different right so this is
kind of frustrating like how can I make
the connection between them so for that
I'm sure you'll remember we have another
layer which is the domain layer the
domain layer has interactors and that's
their job to make the connections and
the conversions between the different
data models all of the logic of the
conversion is here meaning all of the
use cases all of the app business logic
and what we want to do in the app is
here with the interactors and the use
cases so it's kind of if you remember
Angelica from Rugrats that could have
spoken the the baby's language and also
the adult language this is exactly that
a person who can speak with both of the
layers but that's only what it does so
let's say if the gentleman how can we do
it first of all we're going to create a
use case for each of the features let's
call it that or the tasks that I want to
do in my app I'm going to create a
separate use case for them so here I
have this saved jelly bean
use case it's what its gonna do it just
to execute execute the save Jellyman so
it's pretty easy to understand
what its gonna do is to convert between
the models right I'm gonna get the view
model that I just created an updated
from the view from the presentation and
then I need to convert it how do I do it
it's very very simple in this case here
for example what I want what I mainly
need to do is to switch between the
three ends that I had for color I need
to prepare a string with them so I can
save it on the data layer so that's what
I'm gonna do and then I'm gonna ask the
repository to do it for me because the
use case doesn't do it at all but it
knows all the repositories so we give
the repository the data for the save
being operation and that's it and then
we just need to execute it and it's all
going to happen so this is kind of how
we create the interaction between both
of the layer what did we have so far the
presentation layer has this view and the
domain layer has the use case for the
Save Belly jelly bean we're gonna
execute it on the data layer we're gonna
ask to do the actual saving and the
presentation doesn't really know where
is it gonna save the when is it gonna be
saved how even if maybe the repository I
decided to throw it away we don't we
don't really care each one has their own
part to play so another good thing about
the the interactors that this helps us
with all these changes that we're doing
is that the fact that we can reuse them
for example here let's say I want to
create the edit screen it can look
completely different than the new add
new jelly bean screen so it looks
differently but the operation at the end
is the same to save alright so we can
actually use the interactor just use a
different UI
all right so a little bit more about the
repository and how does that work or the
domain layer actually so the domain
layer has a use case usually what we
love to do is to create a cache maybe
sometimes it's needed sometimes it's not
dependent performance mainly and then we
want to save everything to the local
database and then if we need to we're
going to sync with with servers with
network services but the thing is we
always want to have this local database
that we're talking to and with so it is
like one source of truth and all the
data is saved there with the state that
is like the real truth that we want to
that we want to use the way to do it is
a very cool way that the way to do is is
basically with SQL databases but now
with the new component we have something
that is called room and this is kind of
a wrapper for the SQL databases that we
already have and know and know how to
use but it's very very complicated and
it gives us many actually advantages so
first it generates a lot of boilerplate
code I don't know if you've the Android
developers here probably have but create
to create vascular light database and
the helpers and everything it has to do
with a lot of other code so this does it
for us all so this is the first time
that our queries our SQL queries are
being verified at compile time if we do
something that is all wrong we can know
it before before any crashes and
everything and also it helped us to
avoid calls
I mean database calls on the UI thread
this is something we never want to do of
course because the databases is
something that is heavy to call from
word to so it helped us and compile time
to to avoid that to avoid that so how do
we gonna use room
first of all that we need to do what we
need to do is to create the entities
meaning the databases the tables that we
want to save so we just annotate a class
a POJO with an entity annotation and
this means that we got this is going to
be saved in a separate table and
basically that's it we don't need to do
much more than that only thing is we
have to have a primary one primary key
which has to be not no we have to take
care of that but the part of it we can
save basically anything we want like
that and it would be saved on a on a
separate table next thing we need to do
is to create at day a dowel is a data
access object and this is how we're
going to access this specific table
alright so for this instance we're
creating a jelly bean dowel we have the
annotation on the top so we know this is
Dao and then here we can just create all
the operations that we need to do and we
want to do and to allow on the database
in just to have them here on the on the
Dell
very simple so we have the queries for
two so you have the annotations for the
queries for example we have inserts we
have deletes everything is really simple
and it just generates all the SQL code
for us so after we do sorry after we do
that we create an app database instance
this is just the database that we have
to define we just need to define here
the version which entities are we going
to save here some in it and destroyed
code that is not very much interesting
so I didn't put it here for this context
but this is what we need to do and then
for each dowel that we create so for
each table that we create we're gonna
have the dowel here as a public field so
each one who needs to
ask something in the database we do it
through the Dow so after we created the
database instance we just have to use it
from the repository only the
repositories know about the database
this is something that is really
important and like I said it's not just
goes directly to the database it asks
the the Dow the model to do all the
operations that we had before on the
interface this is uh this is very simple
this is quite cool isn't it
another thing that that I do want us to
notice right now is that when I return
the whatever I wanted to do for example
here the guide jelly bean I do not
return the data objects themselves I
return them wrapped into a live data and
that way whenever they return it's gonna
be the same communication as we did with
the presentation layer so anytime it
returns and has a new data in it the use
case is gonna take it and do whatever he
wants all the conversions it's gonna
work quite the same with notifications
so we have the presentation layer that
we saw before we have the domain layer
with the safe jelly bean and then we
have the data layer what do we have
there we have the jelly bean repository
we ask it to save it actually goes to
the local database and the actually
there to the Dao and then it returns
that's everything that we need so the
presentation layer like we said has the
views the view models and sometimes food
presenters depends on how you want it to
implement it the domain layer has all
kinds of interactor and specifically use
cases that we talked about here data
layer is built of repositories and data
models so what we saw here that if
you're if you're gonna use the this
structure or this architecture that I
that I showed you before hopefully and I
I can promise you that all those players
and the axis and the entrance and the
plays and the parts that they play are
going to be very very well defined so
this means that all these principles
that we're really trying to to have on
our app is gonna be resolved for you and
of course like we said the point is to
have a code that we can write quickly we
can change easily like we saw it's very
easy to change when we know it's it's
sorry object what the part it's playing
and we can test it very very simple
because each one of them has a very
specific logic or no logic at all and
since we have this kind of architecture
that we all understand which who needs
to do what then it's easier for others
on our team to understand it that's it
for now I have some medium posts about
this what we talked about so far that
are like notes for this this kind of
lecture and for with code examples so
you can check them out um and a part of
this thank you so much I'm here for
questions or anything here or later we
have a little bit of time for questions
if you want to ask something
no yeah
this is I mean this is kind of how we we
use the okay so the question why was the
the data access object our abstract
class this is kind of what allows the
framework to do a lot of stuff in our
behalf and it generates a lot of code
that you can actually see I mean if you
look at the code that is generated on
compiled time you can see all this code
that is generated for us so this is
basically it's any questions yeah
okay so the question is if we can use
reuse a view model for different kind of
views basically I think that if you have
views that they look quite the same it
can make sense I mean we want if if this
is something we want to use that I don't
think you should write that again the
thing is that the view model should
always be there for the view itself so
if the views are different just don't
bother to use the same view model
basically if there's a different fields
that you need or different logic there
you just create a new view model it
would help you like not to be confused
later on because you might
it is well the different thing about the
presenter is that it knows a lot more
the presenter or an MVP it knows a lot
more it has to know the view it has some
logic in it and so on here the view
model is just for it just knows the view
and it emits changes so it's a different
kind of model it's it's like kind of
mvvm it's more like that so it emits
changes it knows less about about
anything if I make sense any more
questions alright so thank you so much
I'm here if you want to ask me later on
and thank you so much had a great time
with you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>