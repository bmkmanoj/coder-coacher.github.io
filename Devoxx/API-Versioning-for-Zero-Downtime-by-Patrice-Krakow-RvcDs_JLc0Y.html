<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>API Versioning for Zero Downtime by Patrice Krakow | Coder Coacher - Coaching Coders</title><meta content="API Versioning for Zero Downtime by Patrice Krakow - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>API Versioning for Zero Downtime by Patrice Krakow</b></h2><h5 class="post__date">2017-11-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RvcDs_JLc0Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello so I hope you had enough coffee
during the break in order to stay awake
for the next 15 minutes because I have a
lot of slides for you my name is Patrice
croco I'm working at ING as the lead
architect of the the API platform
I guess that most of you know that ing
is is a bank and for the one who did not
know now you know but I'm not here to
talk about this this good ol Bank so
let's let's remove this let's remove
this picture I'm here to talk about
api's web api is but but before that if
I may let's check if you are actually
awake I have a few questions for you so
could you please raise your hands if you
have at least one current bank account
Wow all the heads up please
stay stay with your because now the
trick is that please keep your hands as
long as you can answer yes to all the
questions so in order to manage your
bank account in order to make payments
to check your past pavements do you use
a web or mobile application great so no
one is using paper form anymore now the
real question who has at least two
current bank account from two different
banks still a few and if I'm right in
order to manage those bank account you
have multiple applications right yeah
correct how do you like to make banking
with different application no one great
and I have a good news for for you
because that that annoying experience
should stop thanks to PSD two who has
heard about PSD - Wow quite quite a few
people so PSD to s European
directive the payment services directive
- so not only the the Hollywood movies
like Blade Runner goes for a version -
but also the European directives but I'm
not I am NOT here to talk about it so
very very quickly this is about the
obligation for four banks to open bank
account information and payment
initiation through other banks of intact
so it will be possible to create an an
app with which you will be able to
manage multiple bank account from
different things and that will be
probably done via Web API eyes but I am
I do not want to concentrate on on PSD
to PSD to is not that interesting
because PSD to is what we are obliged to
do at ING we do care about web api
because of this because we want to be
part of the World of Tomorrow we want to
be part of this world where you do you
have an ecosystem of businesses and
where customers have experiences that go
cross the barriers the traditional
barriers of businesses and this is
really going way beyond this this idea
of digitalization we do not want to
digitalize our existing banking business
but we really want to transform
ourselves and i would say that at ING we
have the the chains and i I personally
feel lucky that we have this this
visionary CEO Ralph summers who recently
declared to two journalists that he
wants to transform ing and a tech
company with a banking license and by
the way last thing about last word about
I
and I will stop in order to achieve this
this transformation we are recruiting we
are recruiting good developers good Java
developers in in particular and we are
really proud to be a platinum sponsor of
this fantastic devoxx even and and I
hope to see you all at our conference
stand downstairs but as I said enough
about ing let's talk about something
much more interesting let's talk about
me so just kidding this is just a brief
introduction about myself details have
not importance just be aware that I'm
working for the past 20 years within the
the integration area so 20 years yes
time quite all hopefully with some
technology that you have never heard
about
unless today where I'm now focusing of
this on this rest API so now time to
dive into the subject api's and and I've
picked up the one of the subject that I
prefer and and one of the most debatable
subject which is the versioning of of
API and traditionally if you Google API
versioning and you have an article it
will start without how to version do I
put the version here do I put the
version there and this is exactly what I
will not do today
I want to step back a bit and and ask
ourself why why do we need to do version
by the way this is this is the book I'm
currently reading from Mike Amundsen and
I will definitely encourage you to
follow this guy if you are interested by
web AP is not only about the the
versioning and so the idea is really to
go back to the why is it important to
care about the versioning of of API and
who when we talk about version we
actually talking about changes how do we
handle change over time and again that's
asking ourselves why why is it important
to to handle this change why do we have
why does it change and and a way to
answer that question is to say that
because there is a tension there is a
tension between on one hand the API
provider and on the other hand the API
consumers as an API provider what what
you what you want to do is to change
your API as soon as you have a new
brilliant idea that's what you want to
do and from an API consumer you want
your API to be quite stable unless you
are interested by this new brilliant
idea of course talking about API
versioning there is also a well known
back best practice coming from Roy
fielding the the father of of rest so if
he's saying something about the API that
that should be something interesting and
what is he saying about API versioning
we probably all know is don't and that
is that is actually nice but it's a
little bit short when when I go to the
squats and they are asking me a fat is
how do we version the our API and I say
don't they feel a bit ok missing
something by the way this this dawn
comes from really famous keynotes it's
already from 2013 and you can see here
the the original slides unfortunately I
have not find any recording of of it if
if you ever find one please
please let me know one of the important
thing now in order to continue I already
need to to pose a bit and to talk about
to about some terminology about some
some meta model because this is really
something that we have find out within
gee when we started this one year one
year and a half ago is that it was
extremely difficult to to discuss
specifically about versioning because we
were not talking about the same thing
and this is why I will start with a
result of this this work that we have
done one year ago about meta model and
terminology which is still involving
first of all and maybe above everything
we make a radical distinction between
the API being solely the interface and
the implementation of it the code that
implements that API that we call service
and and I would say I mean with with all
the the DSM presentation that that you
will see all this overwhelming
information you will probably not
remember a lot about my little
presentation but let me get a chance
right now that if you would remember one
and only one thing about my presentation
it's this please make a had achill
distinction between the API being solid
interface and the service that's it so I
still have 40 minutes so I will continue
so the the the real atom of in our API
terminology is not the API but it's an
API endpoint made up of HTTP method a
host and a URL path template and when
you write a program you do not call an
API you call an API endpoints and then
what we call the API is just a set of
API endpoints that share a common
purpose then you have the API
specification which is the description
of all the API endpoints that are part
of that API and we are quite lucky
nowadays you have an a winner standard
for that being this swagger also known
as open API but I will come back to that
and then we have the service which is
the actual code it's the things you put
into you you get up repo which
implements one of multiple API endpoints
B we also put this additional constraint
which is not necessarily needed but I
just wanted to share with you that a
service can implement different
endpoints but all these endpoints should
belong to the same API we do not have a
service that implements different API
endpoints coming from a different API
then we have the version of the of the
service and when you when you have your
code into your github repo you version
it you tag it and then you deploy it and
you have what we call an instance so the
instance is the running process the
things which is actually listening to an
IP address and a TCP port and that makes
our now common terminology and now I can
talk about version and what why is this
important because I will not talk about
a version but I have two different
version the first one which is quite
obvious it's already there that's the
version of the service the version of my
code and I will also version the API
specification and I need these two
because there are there can be
independent you can you can fix a bug
into your code that does not need does
not trigger any change into the API
specification and vice-versa you can fix
a typo into the the description of your
view with a new swagger that does not
require a change into the service so
these two things are two different
versions so normally from now I should
never talk any more about the version of
the API but I should specify talk about
the version of the service implementing
the API of the version of the API
specification implementing describing so
here the different API endpoints from
the API
you see that we are both using semantic
versioning for these two I guess you are
all familiar with with this idea of the
the semantic versioning from the founder
of of get-ups where you have this these
three numbers X Y Z X Y where you
increment the Z when you have a backward
compatible bug you increment the Y when
you add a functionality in a backward
compatible manner and the the X if you
are not backward compatible the
interesting thing is that it perfectly
fits because this is about the version
of the service and it explicitly refers
to an API within the semantic versioning
specification but it it's not really
precise in terms of API it's quite open
and in this in our context of the the
Web API we are again lucky that a very
easy way to be precise and comprehensive
is to use swagger a lot of the usage of
semantic versioning for swagger itself
is maybe not that abuse because it's
it's not a software so maybe we would
have to adapt a bit the semantic
versioning specification but this is way
too much text let's just focus on on two
things so as I already said the set of
the Z of the service and the API
specification are interval and from from
each other and if you promote an API
design first you could see that the Y of
the service is following the Y of the
API specification so please keep that in
mind for the rest of the discussion and
now I can introduce our journey to the
to the zero downtime so we have started
with this with this meta model I will
now introduce you to you our API gateway
API services
napi registry which forms our API
platform then we will talk about the
idea that whatever problem we have it's
a problem of routing and we will
implement the routing needed to go to to
make a canary Hilly's which is our on
our way to the zero downtime and to be
honest with you I will stop in this
presentation with with the kennedys
being one part of the zero downtime but
all the other special routing that might
be needed we should be able to
accomplish them with this with this
platform so let's start with the API
gate where API service discovery API
registry the most easy one the most
classical one is the the API gateway so
we are still making a distinction from a
network perspective between inside ing
and outside ing and we put a gateway in
between within ing we also make a
distinction between let's say the data
center and the D office the office being
this network zone where the laptop of
the employees are running and we put
also a gateway there and we call the
first one the API gateway on the
external edge and the second one the API
gateway on the internal edge and not the
internal API gateway because inside
within the data center in terms of
communication between services API we
put nothing there is no Gateway no load
balancer no proxy no HT proxy no bus
nothing just a pure peer-to-peer TCP
connection and when I say that a
traditional I mean middleware architects
or engineer he said yeah but how do we
do
the logical logical addressing or do you
really need all the service to know the
IP address of the IP addresses of all
the other services and how do you do the
load balancing and the answer is that we
use a service discovery so the way it it
works is that we starts with an API and
let's say an API endpoint I will
represent this API endpoint with those
three characteristic the HTTP method the
host and the you will help us template
and then I have the service so you see
that I try to have a notation which is
consistent with this clear separation
the API is just this little circle and
the box is the the service which is
implementing an API we start the service
and we got an instance and what is the
first thing that an instance is doing is
that it raises its register to the API
service discovery and by the way you
should here tell me that this this
drawing is not really nice because one
of the important rules that we we try to
apply when building this API platform do
to help the service is to communicate it
is to eat our own dog food so the API
serve this discovery that I have shown
is a service which is also exposing an
API so this drawing should be drawn like
this what does he do so the API self is
discover here you can just see it as an
an empty database and the instance is
sending the logical name being the API
endpoint together with the physical
address in the IP address and the port
so it can reply to the to a code to
something which is addressable so let's
put some some application and let's
isolate a part of the the code that we
call the
who I will come back to that also so
what does the hood do when I caught my
application I call that I want to call
this API endpoints that's what I find
into the API specification I pass it to
the API surface discovery which
associate with the physical address and
then I can have a direct call so this is
the way we have a genuine PhIP TCP call
but we do not need to know in advance
within our application the IP address of
the targeted instance regarding the load
balancing if you have a second instance
of that service it again register and
this time if the application is asking
the same question it will get two
responses and it will be able to make
the load balancing in between now
usually when I have when I show that
people are saying okay let's have a look
in more detail so let's remove this
let's focus I have here the same thing I
have here the same thing here it's also
the same so what do I have something
that looks like a DNS name and two
different IP address should do that with
DNS and by the way this is still still a
subject when you are talking about API
service discovery you still have a lot
of people asking why don't you do that
with with DNS and and here I just want
to take some times to go to a particular
example to to show you that DNS is not
sufficient I will not be exhaustive but
let's just take a little example again I
will metamodel let's clean it a bit so I
have API let's say that I have two API
endpoints which are part of an API but
this time I will in
and each API endpoints in a particular
service and let's take an example of
that so I have this get payments that
will give me the list of all the
payments I have done and I will have a
post payments which allows me to
initiate the payments and let's say that
I will implement that into two separate
codes to get up repository and by the
way this is making more and more sense I
I think you know you will hear I have
seen a few conference here talking about
seeker has even sourcing it makes more
and more sense to completely separate
the writing part from from the reading
path so let's say that we have that we
have this we instantiate those two
services we have our API service
discovery the first one register the
second one register has well now I have
my application so let's imagine that
this is my mobile banking application
which give me the list of all the
transaction but I can also initiate a
payment so I will start with having the
the list I will call the service
discovery and get the address of the
first instance and I will have the list
and if latter I want to initiate a
payment I'm asking for the post payments
and I get the address of the other one
and if you look now at what you have
here you see that the mapping you have
to do is between the method and the IP
address not anymore
between the host and the IP address and
basically you can have all sorts of of
combination and this is where DNS is is
not sufficient to to have this kind of
flexibility all you you do have of
course the option to to tweak DNS to add
more records and those kind of things
but but then you do not have
really DNS anymore API service discovery
and client-side load balancing I have I
went to a few few tools here and I hear
about this client side load balancing so
website load balancing and I would say
that that here I will be will be a but
architects and I will clearly say that I
really have a preference I really do
prefer this this client side load
balancing and that's something I would
like to share with you talking about me
being and why do I say about architects
do I have some architects in in the
homes people who have architects in
their title are quite quite a few in the
other ones do is there any people who
would like to become an architect
because if yes no need to answer I can I
can give you the the trick that this is
a typical question you got client-side
load balancing server-side load
balancing and as an architect you should
not answer you should pose think and say
and then say it depends so here
I do not want to say it depends I want
to say I love client-side load balancing
and here is why
so you have here two equivalent
situation one with server-side load
balancing and client-side load balancing
you have for services or micro services
you may say and what is happening with
such an infrastructure is that the
system grows and you have more services
and then what is happening when you have
a server-side load balancing what is
happening is that you put more pressure
on you server-side load balancing the
computing of the balancing is increasing
and that can become
a bottleneck that will become a
bottleneck a new entire system and yes
you can cluster it you can augment the
the capacity but that's something you
have to care about and you have to be
careful about while on the other side
each node is coming with this with this
little capacity of balancing will which
will be enough for the for the entire
system and this is where on on this side
we can say that we have something like a
self provisioning system and not self
provisioning in the sense that you have
to increase the capacity but no you by
design when the system grows the
capacity is nicely distributed I I
highly recommend you to to read this
this little article this is really from
that has really before me the the
eye-opener and and I hope it might be
the same for you to promote load
balancing and being a but architects and
not say it depends last one the API the
API registry again my API or API
endpoints and I have always worked with
this little addict notation but as I
said we are quite lucky thanks to smart
beer that is a software company which is
therefore quite sometimes they they were
the one bit behind
so P wise but the time that soap was an
interesting integration technology but
they are the one who have also come up
with with swagger and when I started one
year ago I would have a completely
different speech here because there was
a war between swagger ABI proclaimed a
hey ml but but now
I think it's it's done swagger has won
and they have moved their specification
to the Linux Foundation which has
renamed the the swagger by open API and
be careful open API without a blank
don't know if you if you have noticed
but we we start to have a kind of
strange relationship with this this
knowns which have glued together without
the the blank anymore in front of it I
would say that within this conference
and and it has been quite something like
that I'm really quite happy that we do
not have any problem anymore with this
micro service being micro service
without a blank and not with with a
blank and we now start to have probably
the same kind of confusion around open
api where you have the open API without
the blank which is the swagger and the
open API with the blank which makes
sense but which is complete something
completely different it's usually
something we we use to say that it's an
API which is accessible outside of the
network of the company via the gateway
groups 20 minutes so open API without a
blank yes for the moments there is
already an API open API version 3 dot
all but at least at int for the moment
we stick with the open API to dot all
which is equivalent to the swagger to
doto and this is how my little Simplot
here will be put into a nice swagger and
those things are exactly what we put
into the API registry so we have a
database with all the description of all
our API but not only that so let me take
but this little drawing two things here
which are extremely important the API
and the service are two different things
but they are linked an API is
implemented by a service and a service
is exposing its functionality via the
API and when you have such an automatic
runtime registration to the service
discovery the question that you could
ask is is that a load is this service
allow to implement this API endpoint
otherwise it would be too nice I go to
the API registry I take the the swagger
of the payments API I make my little
services i register to the api service
discovery saying that i'm implemented
the payment api and I got the money so
something very important that we store
within the registry and more classically
also when an application is calling an
API we have to notify the the service
needs you know if this application is
actually allowed to do that call or not
and these two things we store them into
the registry in form of what we call a
manifest for the authorization to
implement and that we call the
subscription or a PF token for this
authorization to consumer the manifest
so let's go back to our terminology
again this is the thing that we put
between the API endpoints and the
service that is the things that makes
the link between the two and one thing
that will be important just try to keep
that in a corner of your mind that when
we create a manifest at that moment the
API endpoint is described by your
particular
version of the API specification and
that particular version we store it into
the manifest we pin it into the manifest
so the manifest will remember that at
the moment this service was implementing
this API this API was described this API
endpoint so he was described by this
version of the API specification to to
fix the ID we we put the manifest in in
a simple JSON structure so if we go back
to our little example with the DOE
swagger this is the way we can easily
populate the manifest so it makes the
links between the service via its name
to the list of all the API endpoints
that this service is implementing and it
remembers the version of the API
specification where this API endpoint
was described at the moment this
manifest is created now the other one
the authorization to consume the the
subscription so the ID within our API
platform is that if with a piece of
software wants to consume an API
endpoint it has first to declare it and
so use and this piece of software who
wants to call an API endpoints that's
what we we call in an application this
is a traditional name used in most of
the API developer portal so this is
something which has done at design time
via a user interface again there is this
little trick to pin the version of the
API specification of the which is
describing the API endpoints at the
moment the application subscribe to the
API endpoint again that will live into a
peer token and you can see that we have
really a similar structure than for our
manifest but this time what we store in
this is that
so here I have a subscription that will
be later approved to this get accounts
so that's what that the application one
can have access to the get account and
by the way at the moment that
subscription was done the get account
was described by the version 1.0.1
of the api specification so we have them
them all now I will just redraw the
whole thing together and in parallel
with the component and the metamodel so
we start by our API endpoints which is
part of an API described into an API
specification and that's what we put
into the registry then yeah the way we
put that into the registries via the API
developer portal that you you can see as
the content in front of the e of the API
registry and by the way again this API
developer portal is just an application
calling a service which is the API
registry via its API which is the API
had history API so I should draw it like
that the service saw the code behind the
the API which gets his manifest from the
registry manifest which is spin with the
specification API specification version
the service has the version and that's
the API provider the instance which is
the running instance of a specific
service version and the manifest by the
way is something that can be acquired at
runtime the API service discovery the
application so that's the the classic
interaction here the
PAF token which is the which contains
the subscription which is given at one
time by the 2d application again the
spinning and here I will introduce the
last one which is our API SDK because
this this hooter part so the way the
application is interacting between the
API service discovery and the API
registry and also the way the service is
interacting within this the API service
discovery we do provide library through
an API SDK to help developer to develop
that property but on the other hand it's
just REST API so you do not it's really
help you do not need those those
libraries and then you can make the call
and the idea here is that with a hooter
which is a part of the code of the
application who has access to both the
API service discovery and the API
registry we have all the ingredients so
we can make routing decision that will
allow us to go via this zero downtime
status of our system I have insisted a
lot of this pinning and this is indeed
actually what is important and that's
what I will describe now for our Kennedy
villains I will just quickly go through
so what is what is a cannery release so
the idea is to expose a change in a
gradual manner not in not in a big bank
but just a few n and these this this
terminal G is coming from this habit of
the the miners that when they go to to
the mind they take a canna here with
them so if there is a problem like a gas
leakage it will kill the
can he before the minor so they have
time to to escape so it's this kind of
early warning that we would like also to
have in our system we want to introduce
the change and then if something goes
wrong have an early warning about it and
or all this terminology by the way is
coming from the the Martin Fowler with
young Kennedys and he's describing the
the Kennedy Hill is this way that you
have an application calling an instance
of a service via hooter you introduce a
change that does nothing and then you
gradually expose your system to that
change and at the end you can
decommission the old one and if you have
something wrong during all this
trajectory the whole Bacchus is
extremely simple you just redirect to
the to the old one and the idea is that
with the with the platform we have we we
can do that and we can do that including
some some annoying scenario so imagine
you have your application calling you
her service and that has been done at
the same time so you have the same
version now you introduce a change into
your service a backward-compatible
change so you can expose your
application to this to this new service
and of course the idea is to get rid of
the old one
but I can tell you that within a big
organization saying that Kennedy should
last only one day of two days you will
always have a good exception for that
not being the case so let's imagine that
this old service stays for whatever
reason but then comes the pressure to
have a new application that will of
course register to the new version of
the service and this is where you start
to have a problem because
you do not want to have that if you have
the new application so which is
expecting the change in from the the API
endpoint so for instance an additional
field into a response if we direct it to
the the old service there is a change
that it does not get the answer that
he's expected so this is something we
need to avoid but we can avoid that
hello how can we how can we avoid that
so let's go back this is this is my last
my last animation so I start with an API
an API endpoint which is my my get
accounts and that one is described into
a swagger of version 1.0.0 it is and
that is something that I put into the
registry via the API developer portal
now my service my code which gets the
manifest the authorization to implement
it from the API registry so I will say
that here I will instantiate my service
my manifest can come at runtime my API
service discovery you already know the
story now I will send the physical
address together with the logical one
which is by the way just the manifest
the list of API endpoints that this
instance can serve I will save that in a
corner and I will now introduce my
application the first thing the
application needs to do is to subscribe
to the API endpoints this is done at
design time via the API developer
that this is the peel token that will be
generated so I instantiate the
application I have this scooter which
will get this time at runtime the peer
token and then the hooter of course the
API service discovery and gets the
physical address and now the hooter has
all the information that he needs to
make the correct hooting the true
version match so he can safely redirect
the code now let's continue I make this
change to this endpoint so I have a new
swagger I make a new version new
instance I got this new manifest can you
still hear me yeah okay
where am I the manifest then yes it
registered to the API service discovery
the known story which means that when
the hooter will request again the API
service discovery he will get now these
two instances and here you will see that
you have a new instances which
corresponds to a service which have been
created when it was a newer version of
the API specification but a backward
compatible one so I can safely direct as
well and then I have this situation with
my old service and my new service and
here comes the new application which
subscribed to the new version of the API
specification again same thing I have
this subscription that will be
transferred at one time as the peer
token and I will ask when I will ask the
API service discovery I will get the
exact same response and this time again
I have
all the information I should not
redirect to this instance because there
might be a change that the application
will not get what they want and I
directed to this so here it is as a
summary make an explicit distinction
between the API endpoints and the
service and I still have few minutes so
I can continue use the semantic
versioning for both the service and the
API specification make an explicit link
between the service and the API food is
manifest use this API service discovery
to register your instance at runtime
have an explicit subscription that can
leave at runtime as the the peer token
and enjoy the fact that there are quite
they have a similar structure and then
you who'da can make a wise decision and
we conjecture here is that this
mechanism can be extended to other
routing techniques such as other
strategies for Kanna heavy knees here it
was just a random 10% but we can do a
canary release with a selected set of of
users confidence check a be testing and
and so on so final conclusion make an
explicit distinction between API and and
service have been a teacher in a
previous life and I know that repetition
is the mother of all learning so if you
have to remember one and only one thing
this is this is this and as a conclusion
API versioning don't bother your
customer with it thank you
so I have one minute left so I can maybe
take a few questions or you just join
that at the stand downstairs from from
ING and I will be there to continue the
discussion thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>