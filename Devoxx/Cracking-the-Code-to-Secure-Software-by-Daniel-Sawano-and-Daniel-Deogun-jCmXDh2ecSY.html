<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Cracking the Code to Secure Software by Daniel Sawano and Daniel Deogun | Coder Coacher - Coaching Coders</title><meta content="Cracking the Code to Secure Software by Daniel Sawano and Daniel Deogun - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Cracking the Code to Secure Software by Daniel Sawano and Daniel Deogun</b></h2><h5 class="post__date">2017-08-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jCmXDh2ecSY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright I'm so glad to see there is so
many that are interested in learning how
to crack the code to secure software but
Before we jump into the fun stuff my
name is Daniel DeLeon from a company
called Omega points in Stockholm that
specializes in security and the crossing
between application development my name
is Daniel Solano I work at a company
called Avanza also based in Sweden we're
an internet-based stock broker and banks
in terms of size we're the biggest actor
on the stock exchange in terms of trade
that's where I spend my days alright if
you're more interested in that please
Google us so cracking the code isn't
that really part of a you know a bigger
topic called secured by design yeah so
you know the stuff that we will be
talking about today is is very much
scraping on the surface of this concept
secured by design which is basically you
know an approach where you can you know
create secure software without
constantly thinking about security
explicitly so this almost sounds too
good to be true a little bit of snake
oil right I mean I'm as a developer I
mean nobody's really interested in
security right so we should be able to
somehow use design but that's also what
troubles me what's design all about
design is a very broad concept but what
we mean by design we were talking about
secure by design is basically any
activity that is involved is involving
an active decision making while you are
creating your software so when I'm
drawing stuff on the board with an arrow
if that design that's part of the design
process you know writing an if statement
is your code you're making an active
choice even if you're not thinking about
you make any choice about how should I
write that
you know the criteria that's in a
statement that's also part of the design
process of your software so any active
decision making like a variable name how
you integrate between systems what kind
of language should you think everything
is really part of your design yeah and
the reason for where this in our
experience works so well is because
because for you know for the everyday
developer we're all you know this is
thinking about creating features
business features we don't have time to
think or we're not interested in
thinking about you know cross-site
scripting all this specific security
issues but we're interested and are able
to focus on good design that's something
we can do okay fantastic but in case you
have to run out or you fall asleep the
key takeaway today it's really that if
you focus on you know good design
principles you can actually start
creating secure software without
actively thinking about security yeah
that's what we want you to walk away
from from all this so what you will
learn also is that secured by design is
not really a replacement for all the
other security parts but secure by
design we really narrow the attack
surface of your application and by that
we actually create a better software
that's more secure yeah so enough
talking let's start dive into the
details well this is what we'll go
through today we'll start off with some
of the key design principles
they're called domain primitives and
entity snapshots and then we'll move on
to C on how we can actually apply this
in the real world on code to make code
more robust and more secure and we'll
see how we can utilize our existing
infrastructure in journals and
continuous integration and continuous
development to continuously test our
security and then we'll take a look at
something called a domain dolls and see
what that is all about
yeah the domain dot is really really fun
and scary and you'll actually learn what
that is later on so let's jump into the
first topic called domain president
isn't this like a you know a domain
driven design value object yeah a lot of
the concepts
from secure birth design builds on
concepts that are already existing in
domain-driven design so it helps to know
a little bit about DVD so a value object
in DDD is basically a representation of
something important in your domain you
represent that as a value object and
what sets the value object apart is that
it's totally defined by its value hence
the name okay so that means like money
for instance if I have like a 20 slot a
bill that would be you know doesn't
matter which one I would lend to you
right I get a 20 slotted bill from you
and then I can give another one back we
don't care which one is also in heaven
identity is just a value 20 that is
important right and the classical value
object also is immutable and has all
these properties so a domain primitive
we're taking that to the next level
we're saying that okay not only does it
define a important concept but we're
also going to enforce all the invariants
that are well in your current domain wow
that's that's really specific you saying
that by the mere existence we know is
true exactly because we're enforcing
those invariants when we're creating the
object so if it's not valid in the data
that makes up the object and the object
doesn't exist okay this is kind of
abstract let's look at some code I'm a
bit developers right so in this here we
have actually designed a value of sorry
domain primitive called quantity right
so a couple of details we make the the
class is the final and we also enforce
two invariant that in our current domain
a quantity is not just an integer it's
something between 1 and 200 right those
are the only valid value values in our
current domain and then of course we can
add additional things and just not a
data holder you can add domain specific
behavior and encapsulate that two
together all the domain logic okay okay
I think everyone in here agrees that you
know this is pretty good I mean solid
design but this was a talk about
security right and how can crack the
code to it how does this crack the code
security
yeah you could call it just beautiful
code well in order to you know reason
and discuss about security and software
it helps to bring in a couple of terms
just to get a framework to discuss wrong
so if you look at the information
security you know area they like that
called CIA not Trump CA right no not the
trunk okay but it's also confidentiality
integrity and availability and how you
know they are important for security so
confidentiality confidentiality what
what does that have to do with security
well if you think about it if you bring
in a medical record or something I'm
sure that you think that nobody else
except you and perhaps the doctors
should be allowed to read that kind of
data so that is really important that we
keep the secret sort of say right let me
have you know integrity that's kind of
closely related I guess yeah it's like
making sure the data is isn't altered in
a way it's not supposed to a real-world
example let's say you're sending a
message over the internet like and we
all know though if we want to we can
attach an hash value to that and then we
can compare it at the end and we'll know
if someone tampered with the data that's
an example of keeping the integrity of
the data right so if you had a shopping
basket or an order you know that if you
have past checkout you shouldn't be able
to add stuff to it afterwards or remove
stuff from it okay exactly if I pay for
five items I shouldn't next item before
it goes off the shipping and then I get
six right and also availability that's
something that we're quite familiar from
the I guess when you build up for the
cloud
you know scalability and all that
because availability focuses on making
data available when you need it it
shouldn't be blocked or prevented from
accessing it yeah making sure that the
data or functionality is available for
those who needs it okay
so let's jump back to the you know the
quantity now and see how we actually
address some of those concerns with this
piece of code
okay so what we can solve here are using
the main primitives compared to let's
say just an int values we're actually
solving the integrity shear here mm-hmm
right because the object itself is
immutable and it's not just immutable
it's actually valid and immutable so we
actually get the integrity part so
that's right but what about
confidentiality or confidentiality we
don't really solve that with the
mainframe this because we don't have any
you know username check or authorization
checks we don't solve that with your
main primitives but we do solve
availability oh yes you're right look at
it's immutable exactly and what does
that have to do with availability well
you know if it's immutable we don't need
to use any locking right and if there's
no locking there's no blocking so
therefore you can scale it and share it
and it becomes available for whoever
needs it we can pass this around in
whatever multi-threaded environment you
have and you don't have to do locks and
synchronization stuff okay
okay so we actually address two issues
like that's a great deal and
availability and you know once you start
getting all your domain primitives you
will actually end up in your domain with
a huge bunch of those and we can call
this your domain primitive library and
then you can start those building use
those building blocks to build the rest
of your code and your code will
gradually become more and more robust so
but wait a minute that quantity that we
just saw is saying building building
blocks how can I reuse it you know
everywhere because the quantity of pens
is not the same as quantity of you know
books if it's hard that's a good point
as we saw in the previous life an
important aspect of the domain primitive
is that it's defined in the current
context you mean whatever business
domain or problem-solving domain that
you are currently in that's where it's
defined okay it's a really world example
say you have an email uh-huh an email
address you could say the one definition
is the one made by an RFC somewhere
which is if I don't anyone read it it's
a huge definition of what makes up a
valid email address but you might say
you know in our domain we'll only have a
subset of those that are valid so yet we
define that that's true you're the email
addresses thing I think it's RFC 5 3 to
2 they're really funky and those are not
the ones that you probably want in your
system yeah so for example the RFC says
email addresses are case sensitive but
pretty much every implementation of an
email functionality is treating the
email address those case insensitive
right right ok so to sum up two main
primitives we know that they're the
smallest building block in your domain
model right they call it they're like
the integers the strings the float the
doubles and all that we've kind of used
to using those but that's not what we
are talking about when we're building or
solving a problem in a domain right
we're talking about track number or
train or you know gate if you're talking
about airplanes and stuff like that
right and again by focusing on this
basic design principles domain
primitives we're solving integrity and
availability issues without actually
having to think about those terms or
even know about them so once you can
think and focus on the design and you
will get the security benefits of side
side effects okay so immutability was
pretty good and the domain primitives
but there's a lot of times when we
actually want to you know change things
mutate things right yeah pretty much
every real-world system needs to mutate
data so how to handle that or do have
any issues with mutable data well
actually we do well let's start with you
know in DDD we have this countless
concept of entity which I would like to
explain for the not familiar with it an
entity is something important in your
domain that has an identity all right
the comparative value object it's an
entity is not defined by the value the
data is defined by some unique identity
in our domain so that would be like a I
guess a customer Qaddafi's exactly and
if if you have a customer in your system
you might define some numerical ID when
the customer first registers and then
you have the data in the custom
could be address telephone number and
during the lifetime of that customer in
your system the day they of the customer
may change they may change address
change age change telephone number with
still the same customer so the identity
remains as the data itself mutates over
time so the difference between an entity
and a value of it in a nutshell
so an entity really isn't unique by
value but rather by identity and has a
lifespan right so how do we usually
model this in code well we model it by
creating some kind of object and we're
making mutable so an example oh sorry
let's jump back there we go so we have
the order here again right the order
that we said that if you you know add an
item gets added to your order and then
you can check that out which looks
pretty decent you know that's what we do
how can you implement the shopping
basket otherwise right it's a classic
entity so what's the is there a problem
with it well you know we can see that we
we start to use the main primitives like
the order ID is a domain primitives
we're starting applying the concepts but
some of the issues wherever here is we
have a problem with integrity right I
think you can mutate it and you know we
don't enforce any specific invariants
right now and if we want to start making
sure that we're not altering data when
you start adding you know thread lock
synchronization all that kind of stuff
okay to saying that by ensuring that we
only allow modification by one thread at
a time you have some sort of locking
mechanism outside yeah I guess I would
block
that would prevent availability
eventually we get a high load okay and
integrity yes I guess this object could
have been modified afterwards or
something okay so I mean how should we
do that well we can introduce something
called an entity snapshot right okay and
we're solving the problem with mutable
state by making mutable state in you
what how's that for arrangement we're
fixing mutable by immutable yeah that's
kind of weird
okay well it's actually not that word it
exists in our everyday life all the time
so let's say you know we have something
mutable like a person moving has a state
the position of the person is constantly
changing so if you can please move there
okay I'll be running moving is moving
the state is changing then BAM I'll take
a snapshot with my camera so the
snapshot is obviously immutable with
this photo it's not like one of those
live but but I keep running right
yeah you're getting running but my photo
is still immutable and then I can take
another photo at a later point in time
and that snapshot is also immutable all
right so it's basically a representation
of a mutable state in a certain point of
time okay that's about a weird example
let's go back to IP please okay now I
see example let's say we'll use websites
we'll browse the Internet
so you request some information from the
server and then you get a nice page with
colors and data that's a snapshot right
right that's the data on the server
might change while you're reading the
page then you have to reload it the page
or maybe you're being fancy and pushing
data it's still what you're looking at
is still just a snapshot okay so that
makes sense but how would we do it then
in the order example here okay so here
we design our order entity into being an
entity snapshot so if you look closely
you'll see that it pretty much looks
like a domain primitive right that's
right we enforce the bunch of invariants
that are domain-specific it's immutable
you can't change this object right but
the only thing is that we have this
order ID and that really is the
difference we have this concept of
identity but otherwise it's very similar
to a demain primitive so this is pretty
neat and you're saying that by enforcing
you know invariants or checks when you
create this order and make it immutable
we can guess build on the same
principles as a domain primitive and we
and share this between threads we can
scale oh wow
so that entity actually became a lot
more available yeah okay that's
fantastic
the only problem now Daniel is that we
need to mutate oh yeah there was a whole
setting that went like would be the
thing we were trying to solve right so
how do we do it done well the way we
solved is that we create something
different to mutate in this case we call
it a writable order and the only thing
you can do here is mutate the state of a
specific order you can get to say like
there's no get methods you know just
forged methods so this only allows
modification exactly Wow so we have
separated I guess
writing from reading isn't that quite
similar to the CQRS pattern that greg
young is extremely similar with
same basic concept you can also draw
parallels to like the single writer
principle you know we try to separate
and why this is good is because you're
if you're basically using separation of
concern and make your code easier to
read less you know bug right and I guess
if we go back and try to reference this
back to the CIA principle now again you
can see that by separating read and
write we sort of enable confidentiality
checks right it becomes much easier yes
if you use a micro service architecture
it could be that you know the right
thing service it's over there and only
certain users have access to that one
and you have the read service over here
and doesn't matter if you somehow hack
the read service you won't be able to
change that data so it becomes a lot
easier to uphold the confidentiality and
again with the separation it becomes a
little bit easier to uphold you know
availability because in here on the
right side you can really focus on just
doing the
synchronization and things like that so
that's pretty neat so again we're
solving those those CIA issues by folk
primarily focusing on the design again
okay we don't want you to start thinking
about CIL focus on the design principles
okay moving on so now at this point we
have learned two very important patterns
we know that you can use domain
primitives to just you know create a
precise defined behavior in our building
blocks and we can use entity snapshots
to deal with mutate all state and
simulate the behavior of a domain
primitive this sounds great but you know
it's probably great when you're in like
a greenfield project but for us who are
in the the brownfield world we have an
existing tool there's a lot of legacy
code yeah how many of you are doing
greenfield well Miriam no oh yeah got to
arms over the exit good okay you're
gonna start um you know turning anything
yeah that just kidding but you know how
can we apply this in our everyday life
so we actually very good design patterns
that you guys can use I guess tomorrow
if you like for today
and the first one is called draw the
line and draw the line is really about
starting to identify how bad your data
is because what we want to do is to
create domain primitives right yes you
start defining and creating your domain
primitives and then you start using it
but like daniel said you know in the
real world data tends to be bad or maybe
you've spent several years of patching
bad input and try to do something
sensible with it so if you just put a
domain primitive at the entrance of your
system you're just going to break the
system so that doesn't really work so to
do this now we can't just add our domain
primitives to our code because what
happens if you do that well you break
things or at least you make it explicit
that data is bad
so one way is to add a hidden
translation layer be just behind your
API and you get your strings your
objects in or whatever you get and you
try to translate them into a domain
primitive and if you really tough
you can go I'm just going to reject that
data but then you get that problem of
breaking things or you can log it right
exactly so what you're saying is that
you try to create this domain from you
blows up in your face and then you log
that you can start finding the bed the
spots with bad data enters and they can
gradually start to refactor towards
either better data or better logic to
handle that and the police of course
that eventually you will be at the point
where you can actually enforce the
invariants by actually using the domain
primitives not just trying to use them
so when you end up in a state where you
actually say I'm pretty confident about
the data now they've cleaned it up it's
pretty good now it's time to actually
force your expectations on your
consumers right so at this point we
should actually start expressing our as
they say requirements on our users so in
this case here we have a generic one
that was the you know the old way of
doing it you have to pass a string and
an INT when you bought a book but it's
specific now what you require in your
domain is really an ISBN and a quantity
because an ISBN is really tricky to be
honest and so what happens if you have a
lot of consumers how do you deal with
them yeah you probably not going to be
able to force the consumers to upgrade
your new shiny API at once so of course
you probably will introduce a new API
that does use two main premises and so
on and you deprecated those I mean try
to gradually remove the consumers over
to the new API right and of course under
the hood you can the consumers that are
calling you old API you can just kind of
convert it
so the old API actually calls the new
logic and you gradually starting to use
your domain primitives to harden your
API as your public API is what about you
know in words you're still you know
messy in words right and we're inside of
your component so once you have this
this good protection so your API the new
if you deal will deal with all the code
that you have so this example is a
typical maybe you have an entity that is
a bit messy taking a string
representation of an ISBN and into the
quantity and in this case we're checking
that ISBN is valid all right we want to
add a book right so we have all this
checks and it turns out that there's a
bug here right we forgot to check the
checksum of the ISBN to see if it's a
valid eyes BM ah so what we do the thing
is that I did it over here and this
other piece of code yeah so we solve
this by adding a line making sure the
checksum is correct that we forgot to
add it over there Daniels place you have
all this issues so if we said start to
refactoring and introducing the main
primitives then get something like this
so you're encapsulating all the
invariants into the domain primitives
the name you know that everyone is using
an IP and we can assume that it's valid
otherwise it wouldn't exist so the neat
part here said because of the definition
of a domain primitive we know that it's
true by design otherwise it wouldn't
been able to create it we would have
checked all the checksums we'll check
that it you know it's only contain
digits you know whatever it does right
the same thing goes with quantity in our
domain a quantity is defined between one
and two hundred and now it's like an
integer that could be a negative two as
a two billion and positive two billion
so you're gradually making your code
more robust young to read and when you
reduce bugs you actually reduce security
issues because to be honest a security
bug is no different from any other bug
that you spend all your days fixing
it's not nothing magical about it so if
you can reduce the amount of bugs you're
actually getting more secure code by
default okay so this is fantastic but as
developers we kind of used to working we
know continuous delivery and you know
our build service running our tests we
can't be like you know check security
all the time exactly just the way we
make sure the business feature is
working all the time we should check
this our security features works all the
time and this can be a pretty broad
topic when again getting to you like
unit test integration test system test
deployment is everything but we're going
to talk a little bit about the lowest
level the unit testing part because it's
closest to the code if anyone doing you
know security checks with their unit
test today
not single 101 there yes you're our
friend okay okay so maybe you are
without you're not conscious about it
yes so what's the very basic type of
testing you do when you're called in
other ways it's important to explain
this in a good way this is actually a
real-world example but we can't really
as I say reveal where it was to protect
innocence we've altered the story to the
hospital to do something else could be
something out but the case was this that
and doctors and nurses they were all
using a very advanced the medical system
and they were communicating you know
about sensitive patient data medical
journals you know the education and
everything like that in this system and
yes it's very important for that system
to make sure that the data doesn't end
up somewhere it shouldn't end up exactly
and in the underlying mechanism in this
system turn out to be email based okay
that's how the community a bit odd but
yeah maybe it makes them okay it's a
standard way to test information of
course then we need to be sure that you
know if you pass a message to someone we
need to make sure that this is email we
don't only accept ha Hospital comm right
okay otherwise you could get you know
you could leak out data to a third party
and that's kind of bad yeah you don't
want to send the medical journals to
like Gmail or right now I know I need to
fix for that how no you just the only
thing you have to do is make sure you
configure your email servers not to send
emails to something else in hospital
common you know since I'm a security
minded person I would probably firewalls
and stuff like that to protect no
outbound SMTP traffic problem solved
okay Daniel that to be honest that's
exactly what they did
they created its perimeter based
security around their system to what was
the problem the problem was that the
upgraded I guess the firewalls or the
email servers and those settings either
they got overridden or somehow lost in
that upgrade and sensitive data actually
leaked out without anyone noticing okay
so in order to address this we're going
to show you now how we can use you know
I guess testing and actually create or
derive a domain primitive called email
address in order to create security
in-depth and security in-depth is
actually that if you break one layer of
security you just hit the next one and
the next one and the next one so it's
actually become secure throughout and
we're going to do this without actively
thinking about security so we're still
keeping the you know the configuration
of the email servers but we're also
making it hard to do the wrong things in
the code yes so let's go back to when we
talk about the main primitive we said
that it was important and different to
define it in the current context right
mhm
so in this case our context would be a
valid email would be something with
TOCOM domain right yes if you look on
the left there you will see you know
every possible email like it can be
something for
email or some other address that you
have but on the right there we have a
context where only addresses in the
hospital com domain are valid everything
else is considered invalid and then
maybe our more rules like you certain
lengths and yeah a lot of
domain-specific rules exactly so as
developers what we tend to do is that
when we write our tests we start by what
I would call normal testing that would
be you know testing John Doe or Jane Doe
at hospital comm does it work so it's
like vanilla testing right it obviously
should work for this kind of input and
when you're done and satisfied with that
you will go for boundary testing right
no we can use I guess you're choosing
the normal ninja taking testing data
that is just outside of the valid
boundary and then right inside so that
could be like saying Jane Doe at
hospital dot PL sorry I just changed a
little bit and it's just right outside
or could be a little bit too long
address or too short if that's a
requirement and so on right yeah that's
the typical approach that most of us do
when we work out so we did that and when
we start applying that who get an email
address an implementation of the email
edit that looks like this this is
version 1 but this is the version that
you know put the current testing
fulfills all the domain rules right and
since everybody is in regular expression
specialists in this room we won't
actually dig into that reg X but the I
guess the essence of it is I were
checking for a certain length
requirements contain all the certain
type of characters and it should be you
know ending with hospital calm so at
this point a lot of us just stop this is
where we say we're satisfied
email address is good it's a fairly good
demand primitive but I think we can do
better than this yeah so what if we
start adding more tests so what we do
invalid impetus thing what's that
yeah in invalid input test it's actually
something that's broader than you know
boundary test we're going to test two
data that's further out sort of say if
are even some understanding you
correctly we're testing things that are
obviously invalid yeah it's not even
supposed to be valid this compared to
the boundary testing like yeah this is
very much invalid but but it could also
be like saying I mean we could use
addresses that look pretty legit but
they are invalid in our domain okay okay
so let's see we're going to look at this
piece of code here this is J unit 5 so
don't get too intimidated about it
basically what it is is that we have a
stream of input and then we map that to
a dynamic test and we execute but an
increasing part is the data itself right
yes you're testing null and you have
some tab science and really where data
is invalid data so the key here is that
this is really your imagination along
with the domain expert and trying to
identify what kind of data is invalid in
our domain and obviously we should
reject it right so when we do that and
maybe when we ran this particular test
it turned out that we had forgotten an
explicit null check okay but you know I
guess that but wouldn't we still get a
null pointer in the old version yes
what's the difference of adding an
explicit invariants word okay okay good
good question the thing is that when you
get a null pointer exception just by
accident that's really not part of your
contract for your code if I consumer
could check what kind of preconditions
do I need to satisfy in order to you
know use your API this thing would have
to be part of it you say you know
everyone's going to
in old values and we require the address
to be of a certain length certain
characters and so on and I guess it's
also helpful when you're investigating
that stacktrace production that you'll
see okay this is not next to them it's
actually by design so it's really that
we're not long null values but the fact
Daniel we don't stop here we need to
move even further right because all of
us now we know that availability is
something we need to consider as well
right so for that case we need to
actually add what we would call extreme
input testing what's that well that's
when we're starting to put in data that
is ridiculous I guess like a gazillion
type of gazillion characters is not a
valid email at it but we know it will
fail but how does the system as a whole
behave how does your code behave so in
written history here we have you know in
the bottom there we have is a string of
40 million characters and the question
is is the design going to handle that
well it's a going to choke or is it
going to be a simply rejected like that
okay so what happened with our code well
how could pass that test right it did
but it was by lucky shot or by you know
good design we don't know but the thing
is if we have written our regular
expressional just a little bit different
right and if we had excluded the
explicit length check that we then we
the movie actor had ended up in
inefficient backtracking in the regular
expression engine and what does that
mean in practice what would happen we
passed in a huge amount of data well we
would halt more or less I mean we
consume all the CPU I guess yeah the
mechanism trying to resolve the regular
expression would just go on for very
long time maybe forever
so we would have affected availability
also an important note here is that when
you add that test everything works fine
but someone might look at that regular
expression you know like you know what I
know a better way to
design it and we all know that reg X are
really difficult to deal with so if you
do it a little you know less efficient
it's going to blow up and that's pretty
neat to catch and we're also we're
touching on a subject that is really
interesting that is how you should
actually enforce your invariants how
should you validating for data and one
of the specs there is that you should
one of the first things to do is check
the length of the size of the data which
is the key important here making four
important part here yeah it's exactly a
topic on its own it is pretty big so
just keep that in mind okay so we have
covered you know the design pattern and
now we also know how to apply security
in our you know unit test and we can
somehow derive secure software without
really thinking about security only
design okay so as all these parents are
protecting us from things that happen
because of someone doing something
malicious sending corrupt data trying to
do an operation they're not allowed to
do the water what about you know
security issues the Rises because you're
doing something valid right doing things
you're supposed to do but it turns out
to be malicious and that really brings
us into that you know that's correct
that we were talking about and in order
to understand that we need to understand
what a denial of service attack is and
probably a lot of you know what it is
but you have to bring everybody up to
the same level and we would say that if
we somehow interact with our system in a
way that would make it totally
unavailable we have succeeded and one
way of course is to use a lot of you
know servers or making a lot of requests
and then we can you we can't serve
everyone and therefore we can't use that
system yeah but from from an attackers
point of view good attack would be
something that is asymmetrical so it's a
little farm of the attacker I want to
have a small effort result in a big
effort
the receiving side right so the the cost
for doing an attack should be cheap for
the attacker and expensive for the ones
that gets attacked okay so what if we
move into the term domain das well
you're doing something that is you know
you're just using the valid domain rules
but you're using it in a way that is
malicious that's what a domain does is
wait a minute are you saying that by
simply using the system acid is intended
I'm able to somehow make it unavailable
unavailable or you know causing
financial harm or whatever you're trying
to do well let's look at it a real-world
example
okay let's say I'm operating a hotel my
clicker works yeah so I'm running a
hotel and I'm a business developer at
the hotel so I think you know we should
give we should maximize the customer
service how can we make our customers
more happier okay I guess we could say
that you know it's you can you can
cancel your bookings free of charge
before 4 p.m. at the same day over your
stay
that's pretty good offer right yeah like
the orange did you check in at 12 but if
you don't show up to just call and say
yeah I want to cancel my booking and you
get a full refund that's great customers
are happy but what what if someone else
may be a competitor books all the rooms
on your hotel and then cancel it on the
day we're just supposed to arrive you
know your real customers are not going
to be able to book in rooms and
everything gets cancelled so you're
ending up with an empty hotel not making
any money yeah kind of an attack right
but your shooter sure sure but I mean in
the real world who does that I mean that
won't that won't be a problem it turns
out you know it's actually happens more
than we think
you know in India everybody knows about
uber right yes like this internet stays
taxi sharing thing with a popular in
India there's a company called Ola which
is basically like the Indian version of
uber and
yeah turn out that Ola or accident is
what uber claims Ola has done they still
a lawsuit going on and I guess they
registered I think of 90,000 fake
accounts yeah and then they registered
like four five hundred thousand rides
right like a ridiculous amount and then
they canceled the rights that's a little
while like so all the drivers were got a
ride going to pick up the customer and
then you cancel it oh nothing
so the uber car is just driving around
without customers and of course
customers trying to get right at uber
had to call Ola and says because you can
never get a car from uber and the funny
thing here is that this is according to
the domain rules and of course you know
Hoover I mean they can even have a hard
time creating business and they're the
you know the innocent ones here right or
the irony is that about two years
earlier lyft accused uber to do the
exact same thing right so we're not
judging anyone but it happens you know
and we're just using the system as
you're supposed you are allowed to book
a ride and you are allowed to cancel the
ride you can cause some pretty good harm
by doing that so one thing you guys need
to think about when you go back to your
own project your own systems is that is
it possible to use your domain rules
your business rules in a way that
potentially blocks out the usage or you
know impairs availability yeah and then
the important question is a person of
how can we protect ourselves against
this well in some businesses they're
actually pretty used to this type of
behavior and one thing you can do is try
to monitor the standard behavior and
then see if you see anomalies you can
detect those let's say in trading you
have you're allowed to buy and sell
stocks but then you can buy and sell
stocks in a way that is illegal now you
have some kind of fraud detection right
and they monitor all the trades on the
stock markets and they they can see
various behaviors that's one way to
detect maybe not prevent something to
happen you can detect it afterwards and
you can find out who did it and you know
possibly prosecute them so that's the
business is very used to this but I
think you know more and more industries
is going to have to start thinking about
how to protect it against these types of
attacks okay so in case you fell asleep
and now you wake up you'll find out that
the key takeaway here is that by you
know focusing on good design principles
we're able to you know create secure
software without actively thinking about
security and it's pretty neat we use our
domain primitives to you know enforce
certain rules the Macan use entities
snapshots to get our availability going
and then we can start using you know
good testing in order to you know flush
out security problems you know in our
daily code no and again we're not saying
that this is not replacing you know
specific security test penetration
testing is on but it's a complement and
it's a lot easier to attain in our
experience for the everyday developer
there might not be that interested in
security might have you know deadlines
to meet and so on so it complements all
the other stuff that you do to ensure
your software is secure right and now
it's time for our shameless plug of
course in case you were really
interested in this and thought this was
kind of cool Daniel and I together with
a colleague we're actually writing a
book about this called secure by design
and there's a discount code that allows
you get 40% discount and you can join
the early access program so you can read
chapter by chapter and you can give us
feedback on that and say hey I did not
understand that or maybe we should do it
this way or that way and we can you know
create an awesome book about this yeah I
know in a way to say thank you for that
works we're giving away a couple of free
ebooks if you're interested you can
catch us we will hang out outside for in
the break you just come up to us and
talk to us and I think we have time for
a few questions if anyone yeah is
wondering something it's a microphone
down there - can you hold your hand up
here we go
there's a question over there yes I have
a question regarding primitives data
size does it mean that you should Rob
for all the primitive like all the
things in the other main objects okay so
the course yeah pretty much
so the question if I'm still you
correctly should drop all the standard
language primitives in your domain codes
and I would say the answer is yes the
smallest building blocks tends to be to
always be the domain primitive because
one wants to start to think about and
how do we really represent our domain
very rarely things just an integer it
always says a meaning and the way you
want to represent that meaning is by
creating a domain primitive I think
there might be time for one more
question
well they're on a question thank you
very much thank you for hanging out</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>