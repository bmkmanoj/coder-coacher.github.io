<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Testing Microservices with a Citrus twist by Christoph Deppisch | Coder Coacher - Coaching Coders</title><meta content="Testing Microservices with a Citrus twist by Christoph Deppisch - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Testing Microservices with a Citrus twist by Christoph Deppisch</b></h2><h5 class="post__date">2015-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/FPgXJveaLTo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so hello everybody and welcome to
testing micro-services with the citrus
twist we're at citrus is the tool that
we want to see in action in the next 30
minutes a few words to my person my name
is Christopher fish and I'm working as a
software developer in Munich in Germany
the company that I'm working for is
called console and at console I am
primarily working with Java enterprise
applications in the middleware
integration field and during this work
my passion for automated software
testing is really strong and this is
what leads us to the test framework
citrus which is our topic right now and
I have to say I'm really happy to be
here today so what is citrus citrus is
an open source integration test
framework which focuses on the messaging
interfaces of your software so you as a
developer you write some software and
you have interfaces to other components
or other services you consume services
or you provide services for others so
you have interfaces and these interfaces
should be tested in an automated way and
this is what citrus is doing and for
that citrus offers ready to use endpoint
components for the message exchange so
citrus is able as a client and as a
server to send and receive messages to
different message transports as a
framework citrus also works well with
non libraries such as testing G or J
unit so a test in citrus is nothing else
but a normal unit test and on top of
that we have added the capabilities for
this sending and receiving on different
message transport and what is really
important to validate incoming messages
and as we will see later in the examples
citrus also worked together with well
you know libraries such as apache camo
and spring docker and arquillian in
order to have
the integration test scenario done so
what is integration and why are
integration tests important for the
project if we have a look at how we
develop software today then it is very
likely for you that you have to share
some data with others and commonly or
usually you do this by providing some
kind of service so a client can call
your service and can retrieve some data
and on the other side you can also
consume a foreign service so you have to
retrieve some data from some other
software component and in nowadays this
is done over remote interfaces so we
have HTTP REST interfaces or JMS
interfaces some file based interfaces
what what not and these interfaces
should be tested in an integration test
where two services integrate with each
other so at some point every project
needs integration tests so this is the
common scenario we have two services and
these services are connected over some
kind of interface this can be as I
already mentioned some rest interface or
JMS interface a file-based interface or
soap yeah soap is not that yet this is
commonly used interface out there and
you as a developer you have simply the
problem that in a testing environment or
on your local machine you don't have the
service partner so you want to call the
other service and in a testing
environment this is simply not available
so you have to think of writing some
mock or some simulator for that if you
want to really call the interface and
this is a painful thing to do because
you have to rewrite and you have to
re-implement all the logics again for
simulating an HTTP server for instance
and this is what citrus comes in so Sid
Rowse is able to provide you a service
partner in your test case on your local
machine or in the testing environment in
order to receive your service calls and
give back some responses or on the other
side Sid Rowse is able to call you as
and get back some response from your
software and then validate the content
so this is the basic idea
and then there's micro services and when
we think of micro-services the picture
gets even more complicated because we
don't have one service to talking
another service exchanging data when we
have micro services we split or divide
our applications into smaller pieces we
want to have smaller pieces of software
independent services we want to have
smaller deployments faster deployments
and the picture looks a little bit like
this so you have several services that
all interact with each other and all
communicate with each other
commonly over some kind of remote
interfaces meaning rest or JMS and some
of these services might be replicated
some of these services might be in a
load-balanced setup or in a
fault-tolerant setup whatever so the
picture is really getting more
complicated in terms of messaging and in
terms of having interfaces that have to
work and interact together to have the
whole complete picture and when you want
to do this continuous delivery or even
when you want to get close to this you
need to do one very critical and very
important thing and this is automation
you have to do automation wherever
possible you have to do an automated
configuration automated infrastructure
set up automated deployments and of
course you have to do automated testing
and in the unit testing we have good
automation but when it comes to
acceptance tests or integration tests
where we want to really send some
messages over the wire having real HTTP
connections real JMS connections amour
that whatever this is a hard thing to do
until now because you're sitting in the
right room you know about citrus in a
few minutes so this is a simple citrus
test case as I already mentioned this is
a normal unit test so here I'm using
test and G you can do the same with a
unit and we have this test and
tation at the class level normal unit
test and we have a method which is
annotated with the citrus test
annotation telling citrus framework that
this is a test case in order to handle
or different methods in it in the same
class and then we extend some test
designer and this is simply because we
want to use some java DSL methods or
some fluent API and as in this example
we are using the echo statement so the
echo method coming from this test
designer in order to add a test action
to the sudras test saying ok print this
line to the console it's very simple
test action but you should get the idea
that we have a normal unit test and with
adding this java DSL method calls we are
able to construct a testing logic so
what are these test actions that I have
mentioned the test actions are actions
that you can combine in a fluent API
mode and the two most important ones are
the send and receive operations because
we want to do integration tests for
message exchange so we have to do
sending and receiving some messages but
you can do a lot of other things also
with the fluent API you can wait until
something is happening or you can do
something in conditional or repeat on
error this is not the complete overview
you can do a lot of other things but
let's concentrate on the send and the
receive operation because this is the
most important thing so how can we use
this in a test you see we have some
endpoint that is all the wired this is
because citrus is using the spring
framework as a central configuration so
you have some endpoints configured in
your spring application context and you
can auto wire it into your test we can
ever look at this in a few slides
but what is important is in a send
operation we can reference this endpoint
and we can say it citrus please send out
the message using this endpoint
implementation and this goes then to JMS
or file or mail or whatever
and we simply say I need a payload and I
need something for the message content
let's have a closer look at this what
the payload means so we can have inline
payloads for XML data or JSON data
plaintext CSV whatever you like here in
this example this is a simple XML
payload and what is very important you
can have variables so you can say I have
test variables at the very beginning
here is it an order ID with a random
number and we can reference this order
ID several times in our test case in
payloads and in header information so
this is a good abstraction and then
citral sends out the message and on the
receive side citris has a very important
thing to do this is validation because
we want to write a test and we want to
make sure that things are working as
expected so we need to do some
assertions and here in this receive
operation and the developer can say this
is my expected payload and this is my
expected header data and then Sid Rowse
will do a very powerful comparison of
what is really coming in and what was
expected and Sid Rowse is offering a
really powerful validation mechanism for
XML or JSON you can use XPath statements
and JSON path whatever you can use the
the ignore statements which is good for
ya things that you simply cannot expect
like this time stamp which is a
millisecond so you cannot really expect
the milliseconds so you ignore it inside
of the payload and you can have a lot of
other features like functions or
validation matches I cannot show you
everything today because we only have
like half an hour but you should get the
idea how to construct the payloads so
what are these endpoints I already
talked about that and these endpoints
are implementations in citrus that are
able to send and receive messages to a
certain transport so we have HTTP client
components and we have HTTP server
components
after Ms we have like a male so you can
start up a mail server within citrus and
you can receive some mails and the
Mail's are then forwarded to the test
case and the test case can have a
receive operation and define some
expected payload there and what is also
very important is the camel integration
because with the camel integration you
can use the camera components and as you
might know camel has a huge support and
a huge amount of components for
connecting to different message
transport and for different message data
formats so you can use all the chemicals
in your citrus test case to send out
messages and to receive messages this is
very important and there are a bunch of
other things but we we should move on so
in the spring configuration you simply
configure or add these components and
citrus provides XML components for that
as you can see in this example we're
using a JMS endpoint you give it a
destination name which is a topic or a
cue name and we need some connection
factory as a spring bean in the
configuration or in the application
context and then citrus is able to
connect to this JMS and to send and
receive JMS the same with HTTP for
example so we have this client component
that is able to call a service on this
request URL and when the response is
coming back we can have the receive and
can say ok i expect that this and that
is coming and also the server component
with these three lines you can start up
a complete server component which is an
HTTP server listening on port 8080 and
when requests are coming in again the
test case can have a receive and can say
respond and yeah define the HTTP status
code and also payloads and whatnot so a
lot of information given right now let's
have an example where we test an
application so maybe that in your mind
things get set up and you you can
understand how the components are
working to
so this is my example that I want to
test
it's called cookie factory example
because I like to eat cookies very much
so within this example this is several
services that this should be in a micro
services environment we will see this
later on so we get different orders of
different cookie flavors into the web
application and the first thing that is
done is the content based routing so the
web application will look at the order
type and route these two different
workers so we have several workers
running and each worker is four on a
specific order type and when the worker
has processed the order then a central
reporting server is invoked and the
worker will tell the success to a
reporting server and then the reporting
server can tell us what we have produced
so far and give us an overview so this
is the example that we want to test in a
docker infrastructure this looks like
follows so we have the web application
which is running inside of a docker
container in a tomcat application server
then the we have an active MQ broker JMS
message broker which is also running in
a docker container and connected to that
we have three worker instances running
as Java standalone applications in
docker containers and last not least we
have the reporting server which is also
a web application running inside the
Tomcat in a docker container so we have
six total containers and all these
docker containers in services should
work together and they have to work
together to get the orders processed so
this is what what microservices brings
in from messaging so only if all the
services are working together and the
interfaces then we can process the order
in Citrus tests scenario you simply
would send in some orders to the web
application let the orders go through
and process them and on the other side
you can receive the reporting so making
sure that the reporting has received a
successful order this is a very simple
and
completes or tests the complete picture
of our environment and we will have a
look at this in a in a demo so can you
see that I have talker on my machine and
as you can see we have no to her
containers running and I can start the
whole docker environment for this
example with a maven docker start Oh
maven no and what I'm using here is a
docker may be plugin
written by roland host and this is
really great for me as a developer to
have several docker containers
configured in my maven pom and all these
containers then can be started by this
dock start command and on the in the
left hand side in green you see that
different containers are right now
starting this is the reporting server
soon there will be the web application
starting and I can really start my
complete infrastructure with this maven
command and so I can test and can
execute some some citrus tests against
that so this will be shortly finished
right now this is the the webserver
starting and always fingers crossing
that everything is working now the first
worker is startling it starting this is
for the chocolate cookies and this is
right now I'm starting this manually
yeah but you can as this is a maven
plug-in you can also link this startup
to a lifecycle phase meaning you can
have pre integration tests you can start
up all the docker containers execute all
integration tests with maven and then
stop all Coco container so then you
would have a real complete automated
build right now I have started them
manually so let's have a look at docker
PS and
hopefully you can see that we have some
docker containers on this machine
running we have active MQ broker a
reporting server some webserver and
three workers so let's give it a manual
test on the left hand side you see the
bakery application where I can place
some orders so let's play some orders
for different kinds and different amount
amount of cookies on the right hand side
this is a reporting overview so if I
click the reload and everything is
working then I should see that the
reporting has received the processed
orders and this is what I did manually
right now I tested that my environment
is set up and that all the interfaces in
this complete picture are working
otherwise I wouldn't have received the
reporting and let's test this in an
automated way running maven integration
tests and now some testers test cases
get executed that I have prepared and
this will do the exactly the same they
will place some orders of different kind
and on the other side citrus will make
sure that the reporting's service or the
reporting has received this so this is
running through and if I click the
reload button again then we should see
okay there are some orders and what is a
really important thing is that I can
just retest because tests should always
be repeatable without having to restart
any container or web application or
whatever so I can simply retest and the
test cases the citrus test cases are
running again and we can see in the
reporting there are some more orders and
these are successful here is the
overview of citrus I have written some
test cases so let's have a look at this
in IntelliJ and these are my
these are my four modules I have the
worker the web application in the
reporting and in this acceptance module
I have the acceptance tests which are
written in Citrus and as you can see we
have some two deuce here and let's fix
them there's a test case which is not
completed yet and for that I have to
show you the reporting service we are at
the right line code here if it says if
the get cookie order count is greater
than thousand then we should inform our
stakeholders and we inform the
stakeholders by sending out an email to
the stakeholders and we say
congratulations we have produced one
thousand plus cookies and we are rich
and now I want to test this in in my
citrus test so I have prepared a citrus
test and here I send in some order over
some JMS endpoint and the amount of
cookies I'm ordering is one thousand and
one so it should trigger this email and
here at this to do we should be able to
receive the the email so let's quickly
go to the configuration this is the
spring configuration I already have
added the citrus mail context so then
the citrus components for the mail
module are available and I can say
citrus mail server give it a name give
it a port usually the port comes from
some property file so let's use a
property expression for the port and say
auto start is true and that's it
we can use the mail server component
right now let's add it to our test case
let's just copy and paste
and use the mail server which is of type
mail server and now we can use it in the
receive so here let's add a receive
using the mail server and as payload we
should add the expected yeah mail
content and I use a class plant resource
that I have prepared it's a mail dot XML
you can never look at this and we should
send a response stating that everything
is okay and the mail is accepted
so we also send response here with class
pass or source oops
templates mail response so let's have a
look at this this is an XML structure so
citrus will automatically marshal the
incoming email to an XML structure so
that we can reuse the powerful XML
validation in citrus and then citrus
will compare the incoming email with
this expected email and we have a
subject here with which says
congratulations and we have produced
1000 plus cookies and so on and the
response so we tell the citrus mail
server you should response with a 250 ok
status code which is a mail status code
telling that mail client that everything
is OK at this point we can also yeah
have an error code or simulates
something that is wrong with with a mail
but let's keep it like this and the test
should be completed and we can start it
so let's enable it and cross the fingers
that I haven't messed up in the
background my docker containers are
still running yeah and we have a green
test
let's have a look here it's saying
success and let me quickly find the
validation here it is so this is the
validation we have a received message
which is the XML payload and we have a
control message and now citrus is
starting to go element through element
namespaces are supported and all this
stuff with ignoring and XPath can be can
be included in here so with every
receive we make sure that everything is
as expected so if I go in here and say
greetings we should have a failing test
ferry execute this yep test is read and
we should see some error message here
and validation exception where we say
the element subject is not X expected we
expected greetings and it was
congratulations good so let's go back to
the presentation these are the tools
that I have used for this quick demo as
I already mentioned the maven plug-in
which is really I can really recommend
this if you using maven and this really
brings the the talker stuff to the maven
build which is what we want to use or
what we are likely having to use and the
apache camel stuff i'll use this for the
content based routing or the rest
interfaces and you can see the whole
demo code on github just have a look at
that and you will see there some details
for how the docker containers are
configured in the poem and so on and if
you have questions please go there and
put some issues at the docker account so
we can just discuss and you can answer i
can answer your questions okay so we
have tested this picture every docker
container was started and we just tested
on the boundaries
is a good idea but it is not enough in
order to have the whole scenario tested
so you could also think of other
scenarios where you just start the web
application and citrus is sending in
some orders and citrus is simulating the
workers so on both sides then making
sure that the interfaces are as expected
and in another scenario you could start
in and send in some orders and the
workers are started and on the reporting
server side citrus is simulating the
reporting server and making sure that
the reporting calls are correctly and
last not least you could only start the
reporting server and then citrus is
simulating the worker sending in
different reports and on the other side
citrus is making sure that the reporting
server is as expected and with all these
tests we are sending real messages over
real gem as real HTTP and so on so this
is the idea that we have testing on
multiple levels in order to have an
automated test and when we want to do a
release and we can say let the citrus
test run and everything should be green
so what else in the framework this is
something for you to explore on your own
we have docker integration which is an
extension where you can have inside of
your test case you can start and stop
talking containers so if we are in the
example we could send in some orders and
why Lynn's sending in some orders we
could just kill the ActiveMQ broker with
the docker container so then a failover
scenario would be tested or we could
just kill some workers or we can add
some workers and so on and see what
effects do we have and see what we can
do with that we cannot we also have an
equivalent extension so if you have an
equivalent test case
testing your je application with this
extension you can use the citrus
framework with the Java DSL fluent API
and all the components that we have seen
the endpoints inside of your equivalent
test and we have a camel integration so
there you can start and stop camel
routes you can inspect your camera
and you can have access to the JMX
exported operations of the of the route
and so on so this is something that for
you to explore at home and I'm really
happy to have your feedback and to get
what your thoughts are this is the
information given so all these stuff
that I have shown is in the reference
guide and we should provide some blocks
for new releases and so on so I'm happy
to receive your your thoughts on that so
we have 1 minute and 30 left for
questions are there any questions
pardon can be the question is can it be
used outside of spring I would say no
because it's really heavily using the
spring framework for also internally to
have things all the wired so you have
this spring context that I've that we
have seen but citrus also works with
internal components that are started and
then added to the application context in
order to have order wired it into
several things so this is not usable
without having spring but it's it's an
test dependency or you shouldn't have
this in your productive code so you have
a separate module for that it's just the
integration test this is a spring yeah
component or a spring application see it
as a spring application but it doesn't
really have to use your your production
code spring so it's your reusable
reusable with all the others one one
question maybe any questions
pardon one after another in the front
row can it be used for consumer okay can
you can repeat can it be used for
consumer driven testing consumer driven
testing so you have a consumer that is
waiting for a message and then the test
is started is that what you what do you
mean I mean when the two services are
implemented by different teams yeah it
would be nice that the output of the
tests of one service is used as input so
you have separate teams working on
separate services and you want to make
sure that these are in sync yeah yeah
yeah you should have some kind of
interface contract with that team and
you should work on that so it is it is
not able to use of course you can share
your test cases but on if you have the
services on the one side you are client
and on the other side you are server so
it is all it is every time it is the
different direction so you can reuse the
test in both teams to share some data
for the customer and so on but I think
you should rely on the interfaces then
and be testing the interfaces from
different sides then but it is possible
maybe again your test this was your
question okay
so my times up I am happy to receive any
questions I'm round here and on the
conference thank you very much for being
my audience and have a nice day thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>