<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lazy Java by Mario Fusco | Coder Coacher - Coaching Coders</title><meta content="Lazy Java by Mario Fusco - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lazy Java by Mario Fusco</b></h2><h5 class="post__date">2018-03-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/exEuie-wyCI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I thank you for coming my name is
Mary Fusco and here to speak about
laziness in Java which could be seen
also a good continuation of what of the
former bank at Stoke okay
bankers mentioned laziness in his
immutability talk and now we can explore
the the advantages of laziness a bit
more so what is laziness normally you
are not used as a Java developer to
finge in lazy terms normally when you
pass a meted to tor me - sorry when you
pass an argument to me that the argument
is fully evaluated and then pass it to
the to the method okay with laziness ISM
is happening something else the the the
argument is not fully evaluated until
the method needed until the meter does
to use it and hopefully the method will
never have to use that that argument so
when you will never evaluate it so in in
Java when you have Street function
everything is evaluated all arguments
are evaluated regardless they are useful
or not okay
while with laziness only what is needed
will be actually evaluated so to recap
thickness which is the opposite of
laziness in in programming sickness is
about doing things regardless okay while
laziness is about nothing nothing things
to do and just doing those things the
really necessary thing okay
I said Java is a strict language
everything is not late
this is mainly true of course there are
something that has to be lazy okay so
you have the boolean shortcut operator
you have the ternary operator you have
the if-else condition the for loops and
I'm not a multiple addition to Java East
Java it streams which as well got say
take advantage of laziness okay but the
question is can exist a totally strict
language I believe it cannot because if
if the ternary operator and sorry in
this case if the if you wouldn't have
the shortcut and in in Java this
statement will fail with a
nullpointerexception in case the person
is now because both part of the of the
both predicate the left and right
predicate of the condition will be
evaluated regardless if the force is
true or false and then you will get an
operator exception on the second so
laziness in in some cases is unavoidable
it's really really hard if not
impossible to think about a programming
language which doesn't have some part of
laziness in it okay
and moreover if you think about it we
also used to act in lazy in a lazy way
we learned to be lazy very early in when
we grow up if you if you know me you
know that I'm like to make example based
on my parenting experience and if you
have kids probably you have seen a scene
like like this III tell to my daughter
Sophia is your room is everything sorted
out in your room did you put your toys
away unless she says yes you said that
everything
okay everything is fine okay now I'm
coming to check if it's true or not and
at that point Sofia start putting stuff
start putting stuff in in the right
place that I start to start ordering the
room okay
so Sofia learn very early to to be lazy
because why because lazy is the most
effective thing way of doing if if I'm
not going to check the room of Sofia
Sofia has was that work regarding in a
room without any need because I'm not
going to check it okay so she learned
very early to be lazy and actually is
quite simple to a less evaluation in
Java 9 in Java 8 by means of a lambda
expression okay so here I was trying to
recreate a ternary operator in with a
function okay so instead of using the
result one is is evaluated using the
ternary operator while result 2 is
evaluated doing calling martes ternary
meter today I created there are the two
things the same alternately they aren't
because as I said that the ternary
operator is lazy while I am passing well
one and ball two to the method both well
one and well two will be evaluated
regardless which of them is usually
easier used in the in the metered or not
okay but it's really simple in Java to
turn this stuff into a less evaluated
meted to recreate a ternary operator
with this method the trick is just
modifying the to argument changing and
the type of the to two argument instead
passing supplier to them
okay so I'm not passing to the metered
the result of the invocation I'm passing
to the method to lambda that will
eventually invoke Valois number two
method and and I'm calling the supplier
the meter the lambda that will supply
the father the the value only if and
when is necessary okay so I'm not
calling both the first and the second
I'm just calling one of them and you can
see this technique that are ready used
in many libraries around for a for
instance log4j is using it if you bee
for Java 82 what you what you did if you
have a log sentence that was a really
computation intensive you wanted to
avoid it when you are not doing tracing
okay if you are doing if you are ever
trace logging you want to of course
calculate and print the string but
otherwise you don't okay so you to avoid
the the wasteful computation of the
string you just put it in E inside in in
this if lock with Java 8 you don't need
this anymore you can do this okay you
don't need to put the if block you'd you
are you won't pass the string but you
will pass a supplier of that string and
that supplier will be called by log4j if
and only if it is the interesting mode
for that specific method for that
specific class is that okay it's clear
okay so to cut it short laziness is the
ultimate optimization technique
performance optimization technique okay
why because there is there isn't
anything more efficient that not doing
something at all
okay you can do something very very fast
but probably what you're doing very very
fast is not useful at all so why are you
doing it the most efficient thing is not
doing it at all right so and as I said
Java it's trim it's a very specific case
because for the very first time we had
the in Java an API which is which is
lazy what does it mean
laziness allow me to ever an infinite
stream why because the stream is not
computed when it is created otherwise it
won't work of course you can you
couldn't have an infinite stream which
is not lazy of course and and moreover
when you call this map and filter a
metered when you call all the
intermediate method as I said they are
this metered are acting as my as my
daughter Sophia do the map okay I'm at
dawn do the filter Camden and in reality
is not doing anything okay because you
are not asking for a result you are not
you ain't going to check the room of
Sophia yet okay at the moment you you go
to check the result at the moment you
ask for a result at the moment you do a
terminal operation which is the fine
force in that in the case although so
all the other operation of triggered in
a lazy way and then you have the
advantages that also when God showed in
stool okay so a stream is not this is a
very common mistake a stream is not a
data structure per se okay a stream
eventually wraps a data structure but
what a stream is is a lazy specification
of how to manipulate that data structure
that is wrapped by the stream okay so
and of course there are things that you
can do much more elegantly if you use
laziness so let's suppose that we have a
list
the positive integrals we and we want to
filter on only the prime number and we
want to take only the first and result
okay
and the algorithm explain it in a
declarative way in a functional way is
exactly as I said okay and why I can do
like I could implement this algorithm in
this way in this declarative way because
I'm leveraging laziness if a wouldn't
leveraging laziness of course I could
obtain the same result but I will I will
have a list of imperatives steps which
will be harder to read and order to
implement okay so of course it's doable
but what a mess so and why laziness also
allow me to achieve this result because
laziness allow me to also better clarify
the concern of which statement it also
it is enabler for for a separation of
concern and let me show this with a very
simple example okay so what I'm doing
here here I I have a log file okay and
I'm filtering only the line that starts
with error I want to filter only the
error statement in the log file and I
want to take the first 40 of them okay
can you spot it yeah let's try to write
TC in a using a stream with that in a
declarative way in a functional way you
you can do something like this okay and
okay you I don't want you to focus on
the fact that this second version is
more compact is more concise than the
former one okay of course yes it is true
it is true that is more readable but
there is a one more important concept
here which is the separation of concern
in the stream based implementation we
have
while one line dealing with the opening
and traversal of the file while this
concept is spread around in the in the
imperative implementation and the same
apply for the filter the same apply for
the limit I want to limit this thing to
the first fourth for this statement I'm
just saying
limit 40 in one case I'm having trace
statement in the second case that are
spread around my code
okay and and same thing for collecting
the result into a list so you see in the
in the declarative way you have step by
step a clear separation of concept of
what each sediment does
okay so cool cool now we know streams
are great let's let's try to also use
stream for the prime number of problem
that I presented you before okay so just
to recap I want to I have an infinite
stream of prime number of a positive
number I want to filter the prime number
and I want to I want to take only the
first ten okay so yes I could do this
way okay I have a emitted that returns a
boolean saying if I if a number is prime
or not and then I can use this predicate
this method to filter the the numbers
and then I can limit the result to the
first ten and I'm done okay so yes this
work but to be honest this is a bit
inefficient why it is inefficient
because every time I'm deciding if a
number is prime or not I'm not using all
the primes that I computed before if I'm
deciding if seven is prime or not I'm
also dividing it by I'm dividing it by
three okay but I'm also dividing it by
four and I I don't need to divide
by four because I already know that four
is not a prime number
so it's pointless to do this it's a
waste okay so I want I would like to
keep track of the prime number that I
have ready found during the search and
just reuse the prime number and divide
the new candidate number only for the
prime number that I discovered so far so
how could I do this okay this is a trait
or a TC
in Java and yes it looks cool the
insular code it makes sense but of
course it this doesn't work okay
what this does doesn't work so what I'm
doing here
I'm recursively calling primes okay and
I have emitted that created that takes
in one case the head of the stream the
first item of the stream and in the
other case the tail and I'm reusing the
the head of the stream which is the the
first prime that I found to filter the
remaining part of the of the stream and
I'm doing this recursively you see
Prime's
reek recalling itself so this could work
sort of but there are two reason why it
is not working the first reason is that
is that by calling this head and tail
I'm actually calling to terminal
operation on the same Java streams which
you know it isn't it isn't allowed
once you have called a terminal
operation on a stream you are done you
cannot call on another operational need
otherwise you will get an exception and
the second part which is even more
relevant for my example is that you
don't have a lazy evaluation so this
recursive call of primes will just blow
up the stack without doing anything
useful okay and this is not because my
or
Enel idea was wrong it's just because
this is how Java works meaning that if I
try to implement this exactly the same
idea in Scala it works because Scala is
this okay this fancy concatenation
operator that is this - column column
which does what I was saying before okay
it does a concatenation but in a lazy
way so if you if you if you run this
stuff in Scala it works it's exactly the
translation of what I did before in Java
in Java you can do that this color you
can because Scala is this is a you know
it's a more functional language so it is
more this concept of laziness embedded
in the language okay so but this is
doesn't mean that we cannot achieve the
same result in Java so let's try to
create a different data structure that
is lazier than the stream okay it is a
list
okay this ELISA you can think about this
as a stream of number but what is the
but I can implement this in a very lazy
way okay so the the interface is that I
have an ADD the TTC list is made by an
ad which is the first element and the
tail which is the remaining part of the
element I have an operator that say if
the list is is empty or not and I have a
way to filter the list okay really
simple but what what is the added value
I can implement this interface in a lazy
way okay so I if you look about it in
the implementation of this interface I
don't have detail I have a supplier of
the tail okay here I'm introducing the
laziness so this list is made by the
first element which is the the only male
element that IRI
really already calculated at that point
and and the tail is made by the tail is
as a being calculated yet I just have a
supplier of the tail so when you call
tell you will be returned with another
lazy list which is the remaining part of
the list where only the first item has
been calculated okay and with this data
structure you can implement a lazy
filter which is like that okay which is
a okay if the if the list is empty
return the list and then I have the I
test the the predicate on the head on
the head of the list and if the
predicate is true I return a lazy list
with the head and the the filter
recursively called
on the tail otherwise I directly
recursively call filter on the tail and
why am can I do this because it is lazy
okay because of the laziness because the
tail is just a supplier okay
once I've done this I can feel I can
finally implement in exactly the same
day idea that didn't work in in Java but
worked in Scala this is exactly the same
the translation of the Scala code but
with this new data structure that I've
implemented in Java so how can I use
this okay I started with with a list
that infinite list has start start from
- you can see better how it works here I
start with a with a list that as just -
as the head as the heat and and the tail
is our supplier about the number
starting from tree right and then I I
call give me the primes filter this list
with only the primes and the result will
be due to we
cause two is a prime and then the test
will be true and then I have a supplier
of the primes I love from tree of the
list of items starting from tree
filtered by two okay because if you
remember filter called themselves but in
a lazy way and then I said give me your
tail and the tail is from true from tree
filtered by two so it's it's the the
list starting with tree and having a
still at least a supplier or from four
filtered by two and filtered by three so
you see what I'm doing I'm doing i'm
concatenating in a lazy way the
filtering of all the of only the prime
number okay and and once again if I if I
ask again
give me the tail now the head of the
list will be five and that there will be
the supplier of about the prime number
starting from a given point which is the
point that I haven't calculated lead yet
filter it by only the prime number that
I will that I've found so far so this is
how it works internally question okay
maybe give a look at the code after the
talk and hopefully it will be clear or
or it is already OOP okay so one more
thing there are a few ways to to
traverse a list normally you can do this
in an iterative way but a more
functional style is the recursive way
okay and in reality about iteration you
have two kinds of iteration you have the
external iteration which is the
iteration we are used to use till Java 7
which is let's say a for loop that
iterates a set of number
okay and then with stream we introduced
this internal iteration okay but as I
said there's a this internal iteration
made with stream but as I said as a
third way the third way to do this is it
not iterating but recursing okay so this
this thermal method that sum all the
number from 0 to n you see recursively
call themselves so recursion is very
elegant and in many cases is the
preferred functional way of doing things
and there are many algorithm that relies
on recursion ok
for instance I I supposed to have a
string and I want to test if this string
is a palindrome or not ok if you can
read the string in the same way from
left to right of or from right to left
ok so what I do here I start with the
string I remove ok I remove the spaces
if there are and then I take the very
first and very last character which are
not spaces I compare them if they are
different I know that the string is not
a palindrome and I return force
otherwise I remove the first and the
last character and I call is palindrome
recursively ok and if I end up with an
empty string I know that that the
original string was a palindrome very
simple what's the problem with this bank
I'd mention it this problem in his talk
I mean if you have a deeply recursive
algorithm what you can expect at some
point that yeah it works in simple cases
but if it is deeply recursive you are
adding fun a call on the stock and
ending and ended in ending and at some
point you will end up with the stock
overflow
so so I have this filtering predicate
here okay and if I try to if I try to
run this everything is fine
okay but if I try to apply the same
algorithm with a very long string which
by the way it is a palindrome I I don't
know what this thing says but apparently
it's valid the English and I found this
on the internet and it's a palindrome if
you try to also add check this string
with with the algorithm ah I mentioned
it before you will get you will get of
course sorry you will get of course a
sock overflow okay so what because it is
calling is falling through too many
times and at some point you blow up
realistic the stack okay normally you
have 2000 know 6,000 calls I've around
available available on your stack and
and after that you will get a stack
overflow exception okay so what you can
do to fix this I mean I don't want to
give up to to this algorithm I want to
use the same algorithm but avoiding this
problem in reality in reality in Scala
you don't have this problem at all
because there is something that is
called tail call optimization meaning
that if a metered is returning the
result of the very last call as in this
example that last call is not added to
the stack okay so this is the bytecode
saldo byte code that you have in java if
you do the same in scala the invocation
of do that is not added to the stack the
control is directly passed to do that
because that is the value that I'm
returning
okay this is called
tail call optimization that the last
call is optimized it is not he the the
old call the old function is Papa to
this from the stock before adding the
new one okay so my algorithm in Java in
Java would work by the way okay in sorry
in Scala this is exactly the same
algorithm in Scala and this work without
any problem what we can do in in in Java
we can do something to also have to work
around this problem and they have a tail
recursion also in Java which without
with a part and a studies called
trampolines
what is patent does when I invoke a
function with this button I'm not
returning with the result because if I
need to return the actual result and the
result is calculated in a recursive way
you will end up with the stack overflow
problem so when I call apply to a
function I am not return it with the
result but I'm returning with another
function okay and then I call on it
apply again and again and again okay at
some point I will be returned it with a
function which is the last one the
terminal 1 and at that point I can call
apply on it and get the result ok how
can you implement this stuff this stuff
in Java I imply ie declared this
interface which is a tear hole which is
a supplier of a tail call meaning that
when you call get on it you will return
another tail cool
so if the function returns another
function what is invoked okay and so
this is an intermediate tell call so
it's complete return false
you cannot ask the result to it you will
get an exception but when you invoke it
you will call this
line areas linearize it stream of
function one after the other as I show
it in the former slide until you get the
result so there is a terminal variant of
this case it is tail coal which returned
true on the is complete and only on this
you can call result okay and here I have
a ascetical factory meter that is called
on the which return a terminal tell Cole
okay so if you see what they do on the
invoke method you are you are lazy
reiterating this potentially infinite
list of function until life I find one
which is complete with which will be the
terminal take hole and on that one I can
goal I can say give me the result okay
is this clear so you can have this this
new class in your in your code if you
want and then it's quite straightforward
to ride it but it's much more
straightforward to use it okay so oh how
can I fix my problem as I said here the
problem is that I'm returning a boolean
okay what I want to return really is a
lazy supplier of this boolean is a tail
call of the boolean okay so in this case
I got the empty string by removing all
the character till I get the empty
string so I'm Rita I'm Rita I'm done
with without value to with a result true
so I just said this okay
that is that these
Don method that I mention it before
which create the terminal cool okay and
the same thing if I find two different
character in this case I'm done with
false okay and the other thing is that
when I do the tail recursion
i I I cannot do the tail recursion this
way I need to return a supplier of the
tail recursion so is as simple as doing
this okay
that's all and then here I'm this is
palindrome meter this returning a tell
Cole I just say invoke on this and I'm
done okay so if I try to rerun my my
formal example you will see that it will
calculate the is palindrome function
even with a very very long string so it
is clear why why this worked it is it is
not adding up on the stack the function
it is lee i linearizing them okay this
is how it work very simple okay
okay one last example i know we used a
lot dependency injection we really use a
lot I II really use a lot I often find
that I abuse of youth and there is
something you are using dependency
injection is very nice but in my opinion
there is something not really sounding
in it okay because okay
of course it is eager in nature but
there are worse things the problem is
that you can in general you cannot use
the new keyword you the main problem is
that the the beans
you're pojos your object are not the
lifecycle of this object are no longer
under your control okay the lifecycle of
the object are under the control of the
dependency injection framework so there
is this this this thing that I called
all your beans belong to us syndrome
okay you lost the control of the
lifecycle of your beans because
everything is under the control of the
dependency injection framework okay and
this lifecycle could become quite
complicated and depending of the scope
of this object you could have a thread
problem you could have concurrency
problem I find that it's really
everything is great until it works but
it's really hard to debug when it
doesn't work from some reason and as I
say it's something that is really easy
to abuse and sometimes also it broke
Sanka polish and encapsulation so don't
get me wrong
dependency injection is great but I
believe we are abusing of it and there
could be different different way of
doing this okay and in reality the
annotation based dependency injection
transforms a compile-time problem into a
runtime problem okay
in this case I believe that dependency
injection is sort of transforming Java
into JavaScript in the sense that if you
have a problem you probably would like
to have that problem at compile time but
instead you will have it our runtime
because you have a missing injection
okay so how can we achieve a similar
result in a more functional way in a
lazy way okay here I'm introducing the
the reader Monett the reader mana
he is Amanat okay what's the particular
thing of this model normally in a mana
do rapper value and the
gives you the map and flatmap meter to
compose with itself so the optional
model wraps a single value the stream
mana traps are an at least eventually
infinite list of values the completable
future wraps up value that ISM is no
longer is event or Eno yet there it will
be computed some times in future okay
that what the reader mana does is
something that you use for laziness
because it doesn't wrap up value it
wraps up function as you see okay so
it's used for laziness and for function
composition okay so so what the reader
Millan does is making lessee computation
explicit in your type system while
adding the logic to apply and compose it
so let's come with a very simple example
I have this bin which is a bank account
and I can do some operation on the on
this pin I can open the bank account and
I can credit some value on it or I can
debit money okay and what I want to do
every time one of this operation is
performed is locking it and normally
what I do is that in my case this logger
is very simple it's just a consumer of a
string is something that consumes a
string so it's something that could
consume a string a prett and print out
on the standard output or print out on a
file or set by email whatever you want
and this logger usually is injected okay
so I'm injecting this implementation of
the logger and and everything works
hopefully so if you use dependency
injection as I said you cannot use the
new keyword anymore if you do this you
are creating an account without a logger
and end of and the things that happens
is that you will get a
nullpointerexception as soon as you try
to use it because you don't have any
longer injection injected in it okay so
let's try to achieve something similar
with these reader monitor okay so as I
said I have this account I try to I
created it in this way I try to perform
some operation on this account but if I
try to do so I will get a null pointer
exception because there is no longer
injected okay so what I want to do I
want to inject the logger in a lazy way
I want to do to inject the logger only
when it is necessary
I want to possibly define all the
operation that I want to perform on this
account without really performing it
okay this is similar to the stream you
for think about it and only when I
trigger all this computation
I will inject the logger throughout
through the reader mana or through the
through a simple function as we will see
after okay so how can how can I do this
okay as I said you can think a reader
mana this just a preparer of a function
so in some way you can think about it
just as a function okay so I'm writing
reader here of logger and account and
and in this moment you can think about
this as a function from logger to
account it's the same thing okay
and what I will do is is this I will
lift my account my object a inside the
reader monitor okay and I will lift this
with the object itself and a big
consumer a B consumer of the object
which is the account in my case and the
dependency that has to be injected which
is the logger in my keys okay
so so when I use stills this lift I will
be returned it with this account with
this reader of lager and account so I'm
lifting the account and as I said I need
to pass this be consumer I need to pass
a function that when it is invoker it
injects the logger into the account
which is simply a concept logger nothing
else right okay and at this point I can
perform my operation so I can perform I
can open the account for Alice okay and
then I can pair I can perform all this
order operation the only thing I have to
do is place them into a map okay because
I want to do to do them in a lazy way
okay and as you see
okay as you see I haven't any lager so
far I perform an operation actually I
haven't performed them I define at them
and I haven't used any locker so far now
I can trigger the operation and to
trigger them yes I will need to to pass
a lager so I can say apply on on this
reader monitor as I said you can think
about the reader mana daza a function so
I can call apply on it and I just pass
to it a logger which is in my case is
very simple it's just the console output
okay and and yes and then I'm done so if
I try to run this
it works and it is login the operation
okay
so well what's the main point here is
that dependency injection is eager you
it has to be performant when the object
is created so at the very beginning of
the lifecycle of that object and this is
often not necessary okay
what this new way of doing things along
all of you is to clearly separate the
business logic definition from its
execution so I have a business logic
definition when I don't need any
dependency to be injected because I'm
not performing action I'm just defining
them okay and only when I I'll go to
execute the operation I will need
actually the my dependencies to be
injected okay and in reality so okay so
this is a schema what I'm doing here I
have an account I'm lifting I'm lifting
this account into a reader monitor I'm
calling map map and again and again and
only when I'm reader I'm reading I can
apply this function with the dependence
here be written it with the value okay
and in reality of I agree I use the
disruption but if you think about it
what I'm doing is just function
composition okay so in reality for this
very simple case I in I don't need to
introduce the reader monitored all a
simple function will be will be enough
so let's try this I have a function that
that is doing exactly the same thing
that I that I'm doing here you see is
taking an account and injecting a logger
inside it okay and I call this function
in check
and then I can define a function that
goes from a logger from a logger to an
account I'll call it f which is that
this inject function okay and then on
this inject function I can compose this
injection function with all the
operation that I want to perform on the
account so I can do exactly the same
thing that I did here with only one
different it's the metered is not called
map as you know but is called and then
okay so I'm composing this phat the
function this way okay and then I call
apply shuttle in the same way for this
simple use case I will be I will obtain
exactly the same result so I don't need
the trigger model at all in this simple
case why I'm using the trigger MA not
because the reader ma not allow me to
give me iron and iron ore destruction
for compositional function okay so let's
suppose that I have a second object
which is a money transfer so when I call
transfer on an account or will be
returned with a money transfer and also
the money transfer needs a logger to
work exactly in the same way as the
account did in this case I won't be able
to use the simple function anymore
but I can fix the problem by using the
flat map instead of the map okay so when
when the transfer method returned me the
money transfer object
I'm also lifting it with with the it's
injector of the lock there okay and in
this case of course I cannot call map I
will call flat map because I am passing
to it not a fungal not a function from A
to B by the
function from a to our reader of B right
and and in this case I will get for free
the injection of the logger on both
object okay and it will work as you
expect so the key takeaways is Java
Sestak lambda elastic language but with
lambdas you can make it lazy with a
supplier you can make it lazy in a very
simple way and again laziness is the the
most important form of performance
efficiency because there is nothing more
efficient that not doing something at
all and laziness favors
the quality programming is an important
part of functional programming and
favors and aloes separation of concept
so marker it can be implemented in a
more elegant way by using the functional
approach and the functional approach
very often requires that laziness and
you know in some simple case as the one
I showed you you can probably try to
avoid the traditional dependency
injection and use a simpler up approach
based on function injection as I showed
you and I'm done is there time for
question or no okay well well is there a
question there no okay so ping me
offline if you have question and thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>